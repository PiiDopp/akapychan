[
  {
    "source_file": "900.json",
    "problem_index_in_file": 0,
    "title": "安全除法",
    "description_snippet": "請寫一個程式，讓使用者輸入兩個整數 a 與 b，輸出 a / b 的結果。若輸入的資料非整數或除數為 0，請顯示錯誤提示『輸入錯誤或除數為 0』。程式必須使用 try / except 結構。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code step-by-step with explanation. Must use try/except structure, input two integers, divide, output result, else error message \"輸入錯誤或除數為 0\". Use virtual code with arrows. Let's construct steps.\n\nStart\n→ Step 1: 輸入字串 a_str\n→ Step 2: 輸入字串 b_str\n→ Step 3: Start Try block\n    → Step 4: 轉換 a_str 為 int a\n    → Step 5: 轉換 b_str 為 int b\n    → Step 6: 若 b == 0 → Raise DivisionByZeroError (custom)\n    → Step 7: 計算 result = a / b\n    → Step 8: 輸出 result\n    → Step 9: End Try\n→ Decision: 是否發生例外? // 處理 try/except\n    Yes → Step 10: 輸出 '輸入錯誤或除數為 0'\n    No → Step 11: (nothing)\nEnd\n\nBut need explicit except block. Use Try/Except. So:\n\nStep 3: 開始 Try\nStep 4: ...\nStep 9: End Try\n\nAfter Try, have except block:\n\n→ Decision: 例外? // Actually we can show Try...Except structure: after Try block, we have Except section.\n\nSimplify: Use \"→ Step 3: Try\" then indent inside. Then after that, \"→ Step 9: End Try\". Then \"→ Step 10: Except\" indent etc.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 輸入字串 a_str // 取得第一個輸入\n→ Step 2: 輸入字串 b_str // 取得第二個輸入\n→ Step 3: Start Try // 進入例外處理區塊\n    → Step 4: 轉換 a_str 為 int a // 解析為整數\n    → Step 5: 轉換 b_str 為 int b // 解析為整數\n    → Step 6: Decision: b == 0? // 檢查除數是否為零\n        Yes → Step 7: Raise DivisionByZeroError // 手動拋出除零例外\n        No  → Step 8: 計算 result = a / b // 執行除法\n    → Step 9: 輸出 result // 顯示結果\n→ Step 10: End Try // Try 區塊結束\n→ Step 11: Start Except // 例外處理區塊\n    → Step 12: 輸出 '輸入錯誤或除數為 0' // 顯示錯誤訊息\n→ Step 13: End Except // Except 區塊結束\nEnd // 程式執行結束\n\nNeed to ensure the flow: After Try, we have Except. In pseudocode, we can just show Start Try ... End Try, then Start Except ... End Except. Might include Decision: 是否發生例外? but not needed.\n\nMake sure each line follows \"虛擬碼步驟 [space] // 解釋\". Use \"→\" for steps. For indentation, show with spaces. Let's craft final output accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 輸入字串 a_str // 取得第一個輸入\n→ Step 2: 輸入字串 b_str // 取得第二個輸入\n→ Step 3: Start Try // 進入例外處理區塊\n    → Step 4: 轉換 a_str 為 int a // 解析為整數\n    → Step 5: 轉換 b_str 為 int b // 解析為整數\n    → Step 6: Decision: b == 0? // 檢查除數是否為零\n        Yes → Step 7: Raise DivisionByZeroError // 手動拋出除零例外\n        No  → Step 8: 計算 result = a / b // 執行除法\n    → Step 9: 輸出 result // 顯示結果\n→ Step 10: End Try // Try 區塊結束\n→ Step 11: Start Except // 例外處理區塊\n    → Step 12: 輸出 '輸入錯誤或除數為 0' // 顯示錯誤訊息\n→ Step 13: End Except // Except 區塊結束\nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef main() -> None:\n    try:\n        # 從標準輸入讀取兩個整數，允許任何空白分隔\n        a, b = map(int, sys.stdin.read().split())\n        # 計算除法並輸出結果\n        print(a / b)\n    except (ValueError, ZeroDivisionError):\n        # 捕捉非整數輸入或除數為 0 的錯誤\n        print('輸入錯誤或除數為 0')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "10 0",
          "expected_output": "輸入錯誤或除數為 0",
          "success": true,
          "output": "輸入錯誤或除數為 0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "900.json",
    "problem_index_in_file": 1,
    "title": "統計文字行數",
    "description_snippet": "請寫一個程式，開啟名為 data.txt 的檔案，讀取內容並輸出總共有幾行文字。若檔案不存在，請顯示『找不到檔案！』。請使用 with 語法搭配 try / except。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code, line by line, with explanation. Use structure: Start, End, Decision, etc. Use with, try/except. Provide virtual steps. Let's craft.\n\nLine 1: Start // start\n\nLine 2: → Step 1: 初始化行數為 0 // count lines\n\nLine 3: → Decision: 嘗試打開檔案? // try open file\n\nNeed try/except inside? We can represent with Decision for success/failure.\n\nWe can write:\n\n→ Decision: 檔案存在且可開啟? // try open\n\nYes → Step 2: 以 with 讀取檔案 // open file\n\nInside that, read lines loop.\n\nWe might need nested steps: with, for each line increment counter, then after with, output count.\n\nIf fail: No → Step 3: 輸出『找不到檔案！』 // error.\n\nLet's produce.\n\nWe need to maintain correct indentation representation. For Decision with Yes/No, show subsequent steps with indentation.\n\nLet's craft.\n\n```\nStart // 程式開始執行\n→ Step 1: 初始化行數計數器為 0 // 設定行數為 0\n→ Decision: 檔案存在且可開啟? // 進行檔案開啟嘗試\n    Yes → Step 2: 使用 with 語法開啟 data.txt 為 file // 開啟檔案\n        → Step 3: 讀取每一行並遞增行數計數器 // 計算行數\n        → Step 4: with 區塊結束，輸出行數計數器 // 顯示結果\n    No  → Step 5: 輸出 '找不到檔案！' // 檔案不存在時顯示錯誤訊息\nEnd // 程式執行結束\n```\n\nBut we should represent the read each line: Step 3: 讀取每一行並遞增行數計數器.\n\nWe might need an inner loop decision? but we can just note that step.\n\nAlternatively, we can add Decision: 行還存在? but not necessary.\n\nBut the instructions: use with and try/except. So the decision representing try/except is good.\n\nHowever we need to show try/except explicitly? We can represent with Decision: 是否出現例外? Yes → Step 5 etc.\n\nLet's refine:\n\nLine 1: Start\n\nLine 2: → Step 1: 設定行數計數器 = 0\n\nLine 3: → Decision: 嘗試以 with 開啟 data.txt? // try\n\nYes → Step 2: 使用 with open('data.txt','r') as file // open file\n\n    → Step 3: 逐行讀取，對每行行數計數器 +1 // count lines\n\n    → Step 4: with 區塊結束後，輸出行數計數器 // output\n\nNo → Step 5: 輸出 '找不到檔案！' // error message\n\nEnd\n\nYes.\n\nMake sure to include arrow lines. Use \"→\" for normal steps, indent after Decision.\n\nMake sure each line has \"虛擬碼步驟\" then space then \"// 解釋\".\n\nThus final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定行數計數器 = 0 // 初始化行數為 0  \n→ Decision: 嘗試以 with 開啟 data.txt? // 進行檔案開啟嘗試  \n Yes → Step 2: 使用 with open('data.txt','r') as file // 使用 with 語法開啟檔案  \n  → Step 3: 逐行讀取，對每行行數計數器 +1 // 計算檔案中每一行  \n  → Step 4: with 區塊結束後，輸出行數計數器 // 顯示總行數  \n No → Step 5: 輸出 '找不到檔案！' // 檔案不存在時顯示錯誤訊息  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef main():\n    # 讀取標準輸入，若有輸入則忽略，符合「從標準輸入讀取」的要求\n    _ = sys.stdin.read()\n\n    try:\n        # 使用 with 語法安全開啟 data.txt\n        with open('data.txt', 'r', encoding='utf-8') as f:\n            lines = f.readlines()\n        # 輸出行數\n        print(f'檔案共有 {len(lines)} 行')\n    except FileNotFoundError:\n        # 檔案不存在時顯示錯誤訊息\n        print('找不到檔案！')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "（假設 data.txt 內容如下）\\nHello\\nPython\\nWorld",
          "expected_output": "檔案共有 3 行",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '檔案共有3行'\nGot (Norm):      '檔案共有1行'\n--- (Raw) ---\nRaw Expected: '檔案共有 3 行'\nRaw Got:      '檔案共有 1 行'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "300.json",
    "problem_index_in_file": 0,
    "title": "表達式計算",
    "description_snippet": "請寫一個程式，輸入三個整數 a、b、c，計算並輸出結果：a + b * c 和 (a + b) * c。請觀察兩者的不同。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation. Each line includes \"虛擬碼步驟\" + space + \"// 解釋/說明\". Use Start, End, Decision, arrow. Input 3 ints. Compute two expressions: a + b * c and (a + b) * c. Output them. Probably steps: input a, input b, input c, compute expr1, compute expr2, output expr1, output expr2, End.\n\nNo actual code. Just virtual steps. So lines like \"Start // 程式開始執行\" etc. Use arrow lines. We need to include the arrow \"→\" before step lines. For decisions? No decision needed. So only sequential steps. Ensure each line has a space between code and explanation. Use Chinese for explanation.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Input a // 取得第一個整數\n→ Input b // 取得第二個整數\n→ Input c // 取得第三個整數\n→ Compute expr1 = a + b * c // 計算 a + b * c\n→ Compute expr2 = (a + b) * c // 計算 (a + b) * c\n→ Output expr1 // 顯示第一個結果\n→ Output expr2 // 顯示第二個結果\nEnd // 程式結束\n\nNeed to make sure each line ends with \"// 解釋\". Also use \"虛擬碼步驟\". But format says \"虛擬碼步驟\" + space + \"// 解釋\". So we just write like above. No requirement to prefix \"虛擬碼步驟\" text, but the content is virtual code step.\n\nLet's ensure each line includes a space after code and before //. Also include arrow \"→\" as required.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input a // 取得第一個整數  \n→ Input b // 取得第二個整數  \n→ Input c // 取得第三個整數  \n→ Compute expr1 = a + b * c // 計算 a + b * c  \n→ Compute expr2 = (a + b) * c // 計算 (a + b) * c  \n→ Output expr1 // 顯示第一個結果  \n→ Output expr2 // 顯示第二個結果  \nEnd // 程式結束",
      "generated_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    a, b, c = map(int, data.split())\n    expr1 = a + b * c\n    expr2 = (a + b) * c\n    print(f\"a + b * c = {expr1}\")\n    print(f\"(a + b) * c = {expr2}\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "2 3 4",
          "expected_output": "a + b * c = 14\n(a + b) * c = 20",
          "success": true,
          "output": "a + b * c = 14\n(a + b) * c = 20"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "300.json",
    "problem_index_in_file": 1,
    "title": "平均分配",
    "description_snippet": "小明有 n 顆糖果，要平均分給 m 個小朋友。請輸入 n 和 m，輸出每個小朋友分到幾顆糖果，剩下幾顆糖果沒有分完。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code that meets the format, includes each line with arrow and explanation. Use Start, End, Decision. Provide steps: Input n and m, compute quotient and remainder, output. Need to handle maybe division by zero? The requirement: small number of children m. Should we handle? Could add Decision: m == 0? maybe.\n\nBut output format: \"Start\" then arrow lines. Provide steps. Let's produce:\n\nStart // 程式開始執行\n→ Step 1: 讀入 n 和 m // 取得糖果數量與小朋友數\n→ Decision: m 是否為 0? // 檢查是否有小朋友\n    Yes → Step 2: 輸出 '無小朋友，無法分配' // 如果無小朋友則直接告知\n    No  → Step 3: 計算每人糖果 = n // m // 求整數分配\n→ Step 4: 計算剩餘糖果 = n % m // 求餘數\n→ Step 5: 輸出 每人糖果 // 顯示每個小朋友分到的糖果數\n→ Step 6: 輸出 剩餘糖果 // 顯示剩下的糖果\nEnd // 程式執行結束\n\nWe need to include arrow for Step 1, Decision etc. Use the arrow arrow. Use correct syntax: \"→ Step 1: 讀入 n 和 m // ...\" etc.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀入 n 和 m // 取得糖果總數與小朋友人數  \n→ Decision: m 是否為 0? // 檢查是否有小朋友  \n Yes → Step 2: 輸出 '無小朋友，無法分配' // 若無小朋友則直接顯示訊息  \n No  → Step 3: 計算每人糖果 = n // m // 求每人可分得的完整糖果數  \n→ Step 4: 計算剩餘糖果 = n % m // 求餘下未分配的糖果數  \n→ Step 5: 輸出 每人糖果 // 顯示每個小朋友分到的糖果數量  \n→ Step 6: 輸出 剩餘糖果 // 顯示未分配完的糖果數  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef main() -> None:\n    # 從標準輸入讀取資料，按空白分隔\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return  # 沒有輸入，直接結束\n\n    # 取前兩個整數：糖果數 n 和小朋友數 m\n    n, m = map(int, data[:2])\n\n    # 檢查是否有小朋友\n    if m == 0:\n        # 若 m 為 0，無法進行分配，直接輸出訊息\n        print(\"無小朋友，無法分配\")\n        return\n\n    # 計算每個小朋友分到的糖果數和剩餘糖果數\n    per = n // m          # 整數除法，得到每人分到的數量\n    left = n % m          # 取餘數，得到剩下的糖果數\n\n    # 輸出結果，格式為「每人=X 剩下=Y」\n    print(f\"每人={per} 剩下={left}\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "20 6",
          "expected_output": "每人=3 剩下=2",
          "success": true,
          "output": "每人=3 剩下=2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "800.json",
    "problem_index_in_file": 0,
    "title": "模擬擲骰子遊戲",
    "description_snippet": "請使用 random 模組，寫一個函數 roll_dice(n)，模擬擲 n 次六面骰，並回傳所有結果的串列。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step. Use random module; define function roll_dice(n); simulate n rolls of a six-sided die; return list of results.\n\nWe output each line: \"虛擬碼步驟 // 解釋\" with Start, End, Decision, etc. Use arrow. Let's craft.\n\nLine 1: Start // 程式開始執行\n\nLine 2: → Import random module // 導入 random\n\nLine 3: → Function: roll_dice(n) // 定義函數 roll_dice，參數 n\n\nLine 4: → Step 1: results = [] // 初始化結果列表\n\nLine 5: → Decision: 如果 n > 0? // 檢查是否有擲幾次\n\nLine 6:    Yes → Loop 1: for i in range(n): // 循環擲 n 次\n\nLine 7:        → Step 2: roll = random.randint(1, 6) // 擲一次六面骰\n\nLine 8:        → Step 3: results.append(roll) // 將結果加入列表\n\nLine 9:        → End Loop // 結束一次迴圈\n\nLine 10:   No → Step 4: pass // n <= 0 時不做任何操作\n\nLine 11: → Step 5: return results // 回傳結果列表\n\nLine 12: End // 程式執行結束\n\nBut we need proper arrow syntax: → Step 1: ... etc. Also Decision with Yes → etc. Also Start and End. Provide each line with comment.\n\nLet's produce lines.\n\nAlso ensure arrow \"→\" used before each step. For decisions: \"Decision:\" then indent Yes → etc. Use indentation as in sample: but we just show with spaces. In sample they used tab spaces. We'll replicate.\n\nWe'll produce:\n\nStart // 程式開始執行\n\n→ Import random // 導入 random 模組\n\n→ Function: roll_dice(n) // 定義函數 roll_dice，參數為 n\n\n→ Step 1: results = [] // 初始化結果清單\n\n→ Decision: n > 0? // 判斷擲骰次數是否大於 0\n\n    Yes → Loop 1: for i in range(n): // 進入迴圈擲 n 次\n\n        → Step 2: roll = random.randint(1, 6) // 擲一次六面骰\n\n        → Step 3: results.append(roll) // 將擲到的點數加入清單\n\n        → End Loop // 迴圈結束\n\n    No → Step 4: pass // 若 n <= 0，不做任何擲骰\n\n→ Step 5: return results // 回傳所有擲骰結果\n\nEnd // 程式執行結束\n\nMake sure arrow lines.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Import random // 導入 random 模組  \n→ Function: roll_dice(n) // 定義函數 roll_dice，參數為 n  \n→ Step 1: results = [] // 初始化結果清單  \n→ Decision: n > 0? // 判斷擲骰次數是否大於 0  \n    Yes → Loop 1: for i in range(n): // 進入迴圈擲 n 次  \n        → Step 2: roll = random.randint(1, 6) // 擲一次六面骰  \n        → Step 3: results.append(roll) // 將擲到的點數加入清單  \n        → End Loop // 迴圈結束  \n    No → Step 4: pass // 若 n <= 0，不做任何擲骰  \n→ Step 5: return results // 回傳所有擲骰結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport random\n\ndef roll_dice(n):\n    \"\"\"\n    擲 n 次六面骰，回傳結果列表。\n    \"\"\"\n    results = []\n    for _ in range(n):\n        results.append(random.randint(1, 6))\n    return results\n\nif __name__ == \"__main__\":\n    # 讀取所有輸入\n    raw = sys.stdin.read().strip()\n    if not raw:\n        sys.exit()\n\n    # 若輸入形如 print(roll_dice(5))\n    if raw.startswith(\"print(\") and raw.endswith(\")\"):\n        expr = raw[6:-1].strip()\n        try:\n            value = eval(expr, {\"roll_dice\": roll_dice})\n            print(value)\n            sys.exit()\n        except Exception:\n            pass\n\n    # 其他情況：直接把輸入視為整數 n\n    try:\n        n = int(raw)\n        print(roll_dice(n))\n    except Exception:\n        # 無法處理的輸入，保持安靜\n        pass",
      "validation_results": [
        {
          "example_index": 0,
          "input": "print(roll_dice(5))",
          "expected_output": "[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,6,1,4,2]#(結果會隨機，每次可能不同)'\nGot (Norm):      '[2,6,6,4,6]'\n--- (Raw) ---\nRaw Expected: '[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)'\nRaw Got:      '[2, 6, 6, 4, 6]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "800.json",
    "problem_index_in_file": 1,
    "title": "計算程式執行時間",
    "description_snippet": "請使用 time 模組，寫一個函數 measure_time(func, *args)，用來測量函數 func 執行所需的秒數，並回傳結果 (四捨五入到小數點 3 位)。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nThe user wants virtual code for a function measure_time(func,*args) that uses time module, measures execution time, returns result rounded to 3 decimal places. Provide line-by-line virtual code with arrow and explanation. Need to include Start, End, decisions if any. Steps: import time; define function; start timer; call func with args; end timer; compute duration; round to 3 decimals; return duration.\n\nVirtual code lines: Start; import; define function; start timer; call function; stop timer; compute diff; round; return; End.\n\nUse arrow for steps: e.g., \"→ Step 1: import time module // 引入 time 模組\". And function definition lines maybe like \"→ Step 2: Define function measure_time(func, *args) // 建立函式\". Then inside function: start timer: \"→ Step 3: Record start time // 取得起始時間\". Then call: \"→ Step 4: Execute func(*args) // 執行傳入函式\". Then stop: \"→ Step 5: Record end time // 取得結束時間\". Then compute: \"→ Step 6: Calculate duration = end - start // 計算執行時間\". Then round: \"→ Step 7: Round duration to 3 decimal places // 四捨五入\". Then return: \"→ Step 8: Return rounded duration // 傳回結果\". End.\n\nAlso note that function returns the duration only, not the result of func. The problem says return result (the time) not the func result. So we keep that.\n\nShould we include decision? No decision. So just steps.\n\nReturn value: rounded seconds.\n\nOk. Output format: each line \"虛擬碼步驟 [space] // 解釋/說明\". Use arrow \"→\" and \"Start\", \"End\".\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Import time module // 引入 time 模組  \n→ Step 2: Define function measure_time(func, *args) // 建立 measure_time 函式，接受任意函式與參數  \n→ Step 3: Record start_time = time.time() // 取得執行前的時間戳  \n→ Step 4: Execute result = func(*args) // 執行傳入的函式，儲存其回傳值（若需要可忽略）  \n→ Step 5: Record end_time = time.time() // 取得執行後的時間戳  \n→ Step 6: Calculate duration = end_time - start_time // 計算函式執行所耗費的秒數  \n→ Step 7: Round rounded_duration = round(duration, 3) // 四捨五入到小數點 3 位  \n→ Step 8: Return rounded_duration // 傳回已四捨五入的時間值  \nEnd // 程式執行結束",
      "generated_code": "import time\nimport sys\n\ndef measure_time(func, *args):\n    \"\"\"測量函式 func 執行所需秒數，回傳四捨五入到小數點 3 位的時間值。\"\"\"\n    start = time.time()          # 開始時間\n    func(*args)                  # 執行傳入的函式\n    end = time.time()            # 結束時間\n    return round(end - start, 3) # 以秒為單位，四捨五入到 3 位小數\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取完整程式碼\n    code = sys.stdin.read()\n    # 在當前命名空間執行讀取的程式碼\n    exec(code, globals())",
      "validation_results": [
        {
          "example_index": 0,
          "input": "import time\n\ndef slow_add(a, b):\n    time.sleep(2)\n    return a + b\n\nprint(measure_time(slow_add, 3, 5))",
          "expected_output": "約 2.0 秒 (依電腦執行環境略有差異)",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '約2.0秒(依電腦執行環境略有差異)'\nGot (Norm):      '2.0'\n--- (Raw) ---\nRaw Expected: '約 2.0 秒 (依電腦執行環境略有差異)'\nRaw Got:      '2.0'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "200.json",
    "problem_index_in_file": 0,
    "title": "BMI 計算器\n",
    "description_snippet": "請撰寫一個程式，依序讀入使用者的姓名、身高（公分，float）、體重（公斤，float），計算 BMI = 體重(kg) / (身高(m))^2，並印出「<姓名> 的 BMI 為 <數值>」。數值四捨...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines following format: each line: 虛擬碼步驟 [space] // 解釋/說明. Use arrows. Use Start, End, Decision. No real code, just virtual. We need to read name, height (float cm), weight (float kg). Compute BMI: weight/(height_m^2). Height_m = height_cm/100. Round to 1 decimal place. Print \"<name> 的 BMI 為 <value>\". No actual code, just virtual. Provide each line sequentially.\n\nNeed to incorporate input steps, conversion, calculation, rounding, output. Use decision? Not necessary. But we can show steps.\n\nLet's draft.\n\nStart\n→ Step 1: 輸入使用者姓名 // 取得姓名字串\n→ Step 2: 輸入身高 (公分) // 取得身高浮點數\n→ Step 3: 輸入體重 (公斤) // 取得體重浮點數\n→ Step 4: 轉換身高到公尺 // 將身高除以 100\n→ Step 5: 計算 BMI = 體重 / (身高(公尺)^2) // BMI 公式\n→ Step 6: 四捨五入 BMI 到小數點後 1 位 // 取整數後一位\n→ Step 7: 輸出 \"<姓名> 的 BMI 為 <數值>\" // 顯示結果\nEnd\n\nMake sure each line uses appropriate arrows. Use \"→\" before each step except Start maybe? In example, Start line no arrow. They use \"Start // 程式開始執行\". Then \"→ Step 1: ...\". So follow that.\n\nAlso we may use \"Decision:\" only if needed. Not needed.\n\nOk produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入使用者姓名 // 取得姓名字串  \n→ Step 2: 輸入身高 (公分) // 取得身高浮點數  \n→ Step 3: 輸入體重 (公斤) // 取得體重浮點數  \n→ Step 4: 轉換身高到公尺 // 將身高除以 100  \n→ Step 5: 計算 BMI = 體重 / (身高(公尺)^2) // BMI 公式  \n→ Step 6: 四捨五入 BMI 到小數點後 1 位 // 取整數後一位  \n→ Step 7: 輸出 \"<姓名> 的 BMI 為 <數值>\" // 顯示結果  \nEnd // 程式執行結束",
      "generated_code": "def main():\n    name = input().strip()\n    height_cm = float(input())\n    weight = float(input())\n    height_m = height_cm / 100.0\n    bmi = weight / (height_m ** 2)\n    print(f\"{name} 的 BMI 為 {bmi:.1f}\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "Alice\n160\n50\n",
          "expected_output": "Alice 的 BMI 為 19.5\n",
          "success": true,
          "output": "Alice 的 BMI 為 19.5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "200.json",
    "problem_index_in_file": 1,
    "title": "兩數計算小工具\n",
    "description_snippet": "請撰寫一個程式，讀入一行包含兩個以空白分隔的整數，將其轉為 int 後，計算並輸出四個結果：和、差（第一個減第二個）、積、平均（保留到小數點後 1 位）。輸出格式固定為：\n和:<和> 差:<差> 積:...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation. Format: each line: \"虛擬碼步驟 // 解釋/說明\". Use Start, →, Decision: etc. We need to read input line, split, parse ints, compute sum, diff, product, average. Output formatted string.\n\nMake sure to use arrows. Example: Start → Step1: 讀取輸入行 // etc. Need to split by space. In virtual code: maybe Step: parse? We can do Step 2: Split input into tokens. Step 3: Convert tokens to int. Step 4: Compute sum, diff, product, average. Step 5: Format output. Step 6: Output. End.\n\nWe need to incorporate arrow. Each step line begins with \"→\" maybe? In example, they start each line after Start with \"→ Step ...\". So we will use that. Provide each line.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 讀取整行輸入 // 從標準輸入讀取包含兩個整數的字串\n→ Step 2: 用空白分割字串得到 tokens // 取得兩個數值字串\n→ Step 3: 將 tokens[0] 轉為 int → a // 第一個整數\n→ Step 4: 將 tokens[1] 轉為 int → b // 第二個整數\n→ Step 5: 計算 sum ← a + b // 整數和\n→ Step 6: 計算 diff ← a - b // 差\n→ Step 7: 計算 prod ← a * b // 積\n→ Step 8: 計算 avg ← (a + b) / 2.0 // 平均值（浮點）\n→ Step 9: 格式化輸出字串 result ← \"和:\" + sum + \" 差:\" + diff + \" 積:\" + prod + \" 平均:\" + format(avg, \".1f\") // 組合結果字串\n→ Step 10: 輸出 result // 將結果寫到標準輸出\nEnd // 程式執行結束\n\nBut we need to mention format? For Virtual Code, we can mention placeholder. Use e.g., Step 9: 輸出格式化字符串 result ← \"和:\" + sum + \" 差:\" + diff + \" 積:\" + prod + \" 平均:\" + avg.toFixed(1)\n\nBetter.\n\nOk produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取整行輸入 // 從標準輸入取得包含兩個整數的字串  \n→ Step 2: 用空白分割字串得到 tokens // 取得兩個數值字串  \n→ Step 3: 將 tokens[0] 轉為 int → a // 第一個整數  \n→ Step 4: 將 tokens[1] 轉為 int → b // 第二個整數  \n→ Step 5: 計算 sum ← a + b // 整數和  \n→ Step 6: 計算 diff ← a - b // 差  \n→ Step 7: 計算 prod ← a * b // 積  \n→ Step 8: 計算 avg ← (a + b) / 2.0 // 平均值（浮點）  \n→ Step 9: 格式化輸出字串 result ← \"和:\" + sum + \" 差:\" + diff + \" 積:\" + prod + \" 平均:\" + avg.toFixed(1) // 組合結果字串  \n→ Step 10: 輸出 result // 將結果寫到標準輸出  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef main():\n    line = sys.stdin.readline().strip()\n    if not line:\n        return\n    a_str, b_str = line.split()\n    a = int(a_str)\n    b = int(b_str)\n    sum_val = a + b\n    diff_val = a - b\n    prod_val = a * b\n    avg_val = (a + b) / 2\n    print(f\"和:{sum_val} 差:{diff_val} 積:{prod_val} 平均:{avg_val:.1f}\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "12 3\n",
          "expected_output": "和:15 差:9 積:36 平均:7.5\n",
          "success": true,
          "output": "和:15 差:9 積:36 平均:7.5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "1100.json",
    "problem_index_in_file": 0,
    "title": "學生資料類別設計",
    "description_snippet": "請定義一個 Student 類別，具有屬性 name（姓名）與 score（分數）。\n1. 於 __init__() 建構子中初始化這兩個屬性。\n2. 定義方法 show_info()，輸出『XXX ...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line with \"虛擬碼步驟\" + space + \"// 解釋\". We need to use Start, End, Decision maybe but not necessary. Just steps. Provide sequential steps: Define class, init, show_info, create objects, call methods.\n\nLet's produce steps like:\n\nStart // 程式開始執行\n→ Step 1: 定義 Student 類別 // 宣告類別\n→ Step 2: 於 __init__() 初始化 name, score // 建構子設置屬性\n→ Step 3: 定義 show_info() 方法 // 方法以顯示訊息\n→ Step 4: 建立 student1 = Student(\"Alice\", 90) // 第一個物件\n→ Step 5: 建立 student2 = Student(\"Bob\", 75) // 第二個物件\n→ Step 6: 呼叫 student1.show_info() // 顯示第一個學生資訊\n→ Step 7: 呼叫 student2.show_info() // 顯示第二個學生資訊\nEnd // 程式結束\n\nBut each line after the code part includes // explanation.\n\nAlso maybe we should show more detailed inside class: Step 2: __init__ 方法: 設置 this.name = name, this.score = score // etc.\n\nBut the requirement: \"逐行地產生對應的虛擬碼 (Virtual Code)，並在每行虛擬碼之後立即提供該行的簡短、直觀的解釋。\" So we can have multiple lines inside the class definition.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 定義 class Student // 宣告 Student 類別\n→ Step 2: 定義 __init__(self, name, score) // 建構子，接收姓名與分數\n    → Step 3: self.name ← name // 存儲姓名\n    → Step 4: self.score ← score // 存儲分數\n→ Step 5: 定義 show_info(self) // 方法，顯示學生資訊\n    → Step 6: 輸出 f\"{self.name} 的分數是 {self.score}\" // 顯示訊息\n→ Step 7: 建立 student1 ← Student(\"Alice\", 90) // 創建第一個物件\n→ Step 8: 建立 student2 ← Student(\"Bob\", 75) // 創建第二個物件\n→ Step 9: student1.show_info() // 呼叫第一個學生的 show_info\n→ Step 10: student2.show_info() // 呼叫第二個學生的 show_info\nEnd // 程式結束執行\n\nWe should maintain format: \"虛擬碼步驟 [空格] // 解釋\". So after each step, we include // and explanation. The indentation inside class? We can use arrow for steps inside class too. But arrow is for decisions? But we can just use steps with indent.\n\nBut maybe better to use the arrow \"→\" to indicate step. But the requirement: Use 虛擬碼的箭頭 (→, Yes →, No →) and 結構 (Start, End, Decision:). So we can use \"→\" for steps, maybe indent for nested steps. Let's produce accordingly.\n\nAlso the explanation: keep short but clear.\n\nLet's produce final answer in Chinese.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 class Student // 宣告 Student 類別  \n→ Step 2: 定義 __init__(self, name, score) // 建構子，接收姓名與分數  \n→  Step 3: self.name ← name // 存儲姓名屬性  \n→  Step 4: self.score ← score // 存儲分數屬性  \n→ Step 5: 定義 show_info(self) // 方法，顯示學生資訊  \n→  Step 6: 輸出 f\"{self.name} 的分數是 {self.score}\" // 顯示格式化訊息  \n→ Step 7: 建立 student1 ← Student(\"Alice\", 90) // 創建第一個 Student 物件  \n→ Step 8: 建立 student2 ← Student(\"Bob\", 75) // 創建第二個 Student 物件  \n→ Step 9: student1.show_info() // 呼叫 student1 的 show_info 方法  \n→ Step 10: student2.show_info() // 呼叫 student2 的 show_info 方法  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Student:\n    def __init__(self, name, score):\n        self.name = name\n        self.score = score\n\n    def show_info(self):\n        print(f'{self.name} 的分數是 {self.score}')\n\ndef main():\n    # 讀取所有非空行\n    lines = [line.strip() for line in sys.stdin if line.strip()]\n    students = []\n\n    # 如果有輸入，解析成 name 與 score\n    if lines:\n        for line in lines:\n            parts = line.split()\n            if len(parts) >= 2:\n                name = parts[0]\n                try:\n                    score = int(parts[1])\n                except ValueError:\n                    score = 0\n                students.append(Student(name, score))\n\n    # 若沒有輸入，使用預設兩個學生\n    if not students:\n        students.append(Student('Alice', 90))\n        students.append(Student('Bob', 80))\n\n    # 顯示所有學生資訊\n    for s in students:\n        s.show_info()\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "Alice 的分數是 90\nBob 的分數是 80",
          "success": true,
          "output": "Alice 的分數是 90\nBob 的分數是 80"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "1100.json",
    "problem_index_in_file": 1,
    "title": "動物類別繼承",
    "description_snippet": "請設計一個父類別 Animal，包含方法 make_sound()，印出『動物發出聲音』。\n建立子類別 Dog 與 Cat：\n1. Dog 覆寫 make_sound()，輸出『汪汪！』。\n2. Ca...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line, each line \"虛擬碼步驟 // 解釋\". Use arrow and Start, End, Decision etc. For this OOP scenario.\n\nWe need to produce step-by-step creation of base class Animal, method make_sound prints '動物發出聲音', subclass Dog overrides prints '汪汪！', subclass Cat overrides prints '喵～', then instantiate and call.\n\nWe need to reflect virtual code: Use arrow → Step X etc.\n\nWe need to follow output format example: Start // 程式開始執行 etc.\n\nMake sure each line has \"虛擬碼步驟 [space] // 解釋\". Use arrow lines starting with →.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 定義類別 Animal // 建立父類別\n→ Step 2: 在 Animal 中新增方法 make_sound() // 定義動作\n    → Step 2.1: make_sound() 內執行 印出 '動物發出聲音' // 初始聲音\n→ Step 3: 定義類別 Dog 繼承 Animal // 子類別 Dog\n→ Step 4: 在 Dog 中覆寫 make_sound() // 覆寫父方法\n    → Step 4.1: make_sound() 內執行 印出 '汪汪！' // Dog 聲音\n→ Step 5: 定義類別 Cat 繼承 Animal // 子類別 Cat\n→ Step 6: 在 Cat 中覆寫 make_sound() // 覆寫父方法\n    → Step 6.1: make_sound() 內執行 印出 '喵～' // Cat 聲音\n→ Step 7: 建立 Dog 物件 dog = Dog() // 產生 Dog 實例\n→ Step 8: 建立 Cat 物件 cat = Cat() // 產生 Cat 實例\n→ Step 9: 呼叫 dog.make_sound() // 執行 Dog 聲音\n→ Step 10: 呼叫 cat.make_sound() // 執行 Cat 聲音\nEnd // 程式執行結束\n\nBut the arrow pattern: we can nest decisions but here no decision. Use arrows as in example. Provide indent maybe not needed.\n\nBetter to follow format: Start // 程式開始執行\n→ Step 1: 定義類別 Animal // 建立父類別\n→ Step 2: 在 Animal 中新增方法 make_sound() // 定義動作\n→ Step 2.1: make_sound() 內執行 印出 '動物發出聲音' // 初始聲音\n→ Step 3: 定義類別 Dog 繼承 Animal // 子類別 Dog\n→ Step 4: 在 Dog 中覆寫 make_sound() // 覆寫父方法\n→ Step 4.1: make_sound() 內執行 印出 '汪汪！' // Dog 聲音\n→ Step 5: 定義類別 Cat 繼承 Animal // 子類別 Cat\n→ Step 6: 在 Cat 中覆寫 make_sound() // 覆寫父方法\n→ Step 6.1: make_sound() 內執行 印出 '喵～' // Cat 聲音\n→ Step 7: 建立 Dog 物件 dog = Dog() // 產生 Dog 實例\n→ Step 8: 建立 Cat 物件 cat = Cat() // 產生 Cat 實例\n→ Step 9: 呼叫 dog.make_sound() // 執行 Dog 聲音\n→ Step 10: 呼叫 cat.make_sound() // 執行 Cat 聲音\nEnd // 程式執行結束\n\nBut we need to maintain \"每行必須包含：虛擬碼步驟 + [空格] + // 解釋/說明\". So we need to put space between code and //.\n\nAlso each line must start with either Start, → etc. So we will write:\n\nStart // 程式開始執行\n→ Step 1: 定義類別 Animal // 建立父類別\n→ Step 2: 在 Animal 中新增方法 make_sound() // 定義動作\n→ Step 2.1: make_sound() 內執行 印出 '動物發出聲音' // 初始聲音\n→ Step 3: 定義類別 Dog 繼承 Animal // 子類別 Dog\n→ Step 4: 在 Dog 中覆寫 make_sound() // 覆寫父方法\n→ Step 4.1: make_sound() 內執行 印出 '汪汪！' // Dog 聲音\n→ Step 5: 定義類別 Cat 繼承 Animal // 子類別 Cat\n→ Step 6: 在 Cat 中覆寫 make_sound() // 覆寫父方法\n→ Step 6.1: make_sound() 內執行 印出 '喵～' // Cat 聲音\n→ Step 7: 建立 Dog 物件 dog = Dog() // 產生 Dog 實例\n→ Step 8: 建立 Cat 物件 cat = Cat() // 產生 Cat 實例\n→ Step 9: 呼叫 dog.make_sound() // 執行 Dog 聲音\n→ Step 10: 呼叫 cat.make_sound() // 執行 Cat 聲音\nEnd // 程式執行結束\n\nWe may also indent lines with arrow but it's fine.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類別 Animal // 建立父類別  \n→ Step 2: 在 Animal 中新增方法 make_sound() // 定義動作  \n→ Step 2.1: make_sound() 內執行 印出 '動物發出聲音' // 初始聲音  \n→ Step 3: 定義類別 Dog 繼承 Animal // 子類別 Dog  \n→ Step 4: 在 Dog 中覆寫 make_sound() // 覆寫父方法  \n→ Step 4.1: make_sound() 內執行 印出 '汪汪！' // Dog 聲音  \n→ Step 5: 定義類別 Cat 繼承 Animal // 子類別 Cat  \n→ Step 6: 在 Cat 中覆寫 make_sound() // 覆寫父方法  \n→ Step 6.1: make_sound() 內執行 印出 '喵～' // Cat 聲音  \n→ Step 7: 建立 Dog 物件 dog = Dog() // 產生 Dog 實例  \n→ Step 8: 建立 Cat 物件 cat = Cat() // 產生 Cat 實例  \n→ Step 9: 呼叫 dog.make_sound() // 執行 Dog 聲音  \n→ Step 10: 呼叫 cat.make_sound() // 執行 Cat 聲音  \nEnd // 程式執行結束",
      "generated_code": "class Animal:\n    def make_sound(self):\n        print('動物發出聲音')\n\nclass Dog(Animal):\n    def make_sound(self):\n        print('汪汪！')\n\nclass Cat(Animal):\n    def make_sound(self):\n        print('喵～')\n\ndef main():\n    import sys\n    # 讀取所有輸入（若有）但不做處理\n    sys.stdin.read()\n    # 建立物件並呼叫方法\n    dog = Dog()\n    cat = Cat()\n    dog.make_sound()\n    cat.make_sound()\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "汪汪！\n喵～",
          "success": true,
          "output": "汪汪！\n喵～"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "400.json",
    "problem_index_in_file": 0,
    "title": "溫度判斷",
    "description_snippet": "請寫一個程式，輸入一個整數代表氣溫，並依下列規則輸出：\n- 小於 0：『冰點以下』\n- 0~29：『正常範圍』\n- 30~39：『炎熱』\n- 大於等於 40：『極端高溫』...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps line by line, with explanation after each line, no real code. Use Start, Decision etc. Use \"→\" arrows. Provide the logic: Input integer. Decision chain: <0, else 0-29, else 30-39, else >=40. Let's produce.\n\nMake sure to include End. Each line: \"虛擬碼步驟 // 解釋\". Use Chinese. Let's generate.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入整數氣溫 // 從使用者處取得氣溫值  \n→ Decision: 氣溫 < 0? // 判斷是否低於冰點  \n    Yes → Step 2: 輸出『冰點以下』 // 氣溫低於 0，顯示對應訊息  \n    No → Decision: 氣溫 <= 29? // 氣溫非低於 0，檢查是否在 0~29 範圍  \n        Yes → Step 3: 輸出『正常範圍』 // 氣溫在 0 至 29，顯示正常訊息  \n        No → Decision: 氣溫 <= 39? // 氣溫超過 29，檢查是否在 30~39 範圍  \n            Yes → Step 4: 輸出『炎熱』 // 氣溫在 30 至 39，顯示炎熱訊息  \n            No → Step 5: 輸出『極端高溫』 // 氣溫大於等於 40，顯示極端高溫訊息  \nEnd // 程式執行結束",
      "generated_code": "def main():\n    temp = int(input())\n    if temp < 0:\n        print(\"冰點以下\")\n    elif temp < 30:\n        print(\"正常範圍\")\n    elif temp < 40:\n        print(\"炎熱\")\n    else:\n        print(\"極端高溫\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "35",
          "expected_output": "炎熱",
          "success": true,
          "output": "炎熱"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "400.json",
    "problem_index_in_file": 1,
    "title": "三數最大值",
    "description_snippet": "請寫一個程式，輸入三個整數，輸出其中最大的數字。不得使用 Python 內建 max()。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code with lines each step, each with explanation. Use arrows. Must include decision steps to find max among three integers. Must not use Python built-in max(). So algorithm: compare a, b, c. We'll do nested decisions: set max = a; if b > max then max = b; if c > max then max = c. Then output max.\n\nNeed to format as lines with 虛擬碼步驟 [space] // 解釋. Use arrow arrow etc. For decisions: Decision: If b > a? etc.\n\nWe need to start with Start. Then input 3 integers. Then set max = a. Then decisions.\n\nWe'll produce like:\n\nStart // 程式開始執行\n→ Input: a, b, c // 取得三個整數\n→ Step: max ← a // 初始化最大值為 a\n→ Decision: if b > max? // 判斷 b 是否大於目前最大\n    Yes → Step: max ← b // 若是，更新最大值\n    No → // 不變\n→ Decision: if c > max? // 判斷 c 是否大於目前最大\n    Yes → Step: max ← c // 若是，更新最大值\n    No → // 不變\n→ Output: max // 輸出最大的數字\nEnd // 程式結束\n\nBut need to follow exact format: each line includes arrow? The sample uses \"→ Step 1: ...\". For decisions, \"Decision: 如果數字大於 0?\" with arrow under Yes/No. So we need to replicate similar style. For decisions, we need to indent sub-steps.\n\nSo we need lines:\n\nStart // 程式開始執行\n→ Input: a, b, c // 取得三個整數\n→ Step 1: max ← a // 初始化最大值為 a\n→ Decision: b > max? // 判斷 b 是否大於目前最大\n    Yes → Step 2: max ← b // 若是，更新最大值\n    No  → // 不變\n→ Decision: c > max? // 判斷 c 是否大於目前最大\n    Yes → Step 3: max ← c // 若是，更新最大值\n    No  → // 不變\n→ Output: max // 輸出最大的數字\nEnd // 程式結束\n\nNeed to include \"Yes\" and \"No\" arrows. In sample, they use \"Yes →\" and \"No  →\". Need to include trailing arrow after \"No\". In sample, they indent \"Yes → Step 2...\" etc. For No line they use \"No  → Decision:\" etc. For us, we just put No → // 不變. Should be \"No  → // 不變\".\n\nAlso after the Decision lines, we need to indent sub-steps.\n\nWe must maintain line formatting. Each line must contain \"虛擬碼步驟\" then space then \"// 解釋\".\n\nThus each line as:\n\nStart // 程式開始執行\n\n→ Input: a, b, c // 取得三個整數\n\n→ Step 1: max ← a // 初始化最大值為 a\n\n→ Decision: b > max? // 判斷 b 是否大於目前最大\n\n    Yes → Step 2: max ← b // 若是，更新最大值\n\n    No  → // 不變\n\n→ Decision: c > max? // 判斷 c 是否大於目前最大\n\n    Yes → Step 3: max ← c // 若是，更新最大值\n\n    No  → // 不變\n\n→ Output: max // 輸出最大的數字\n\nEnd // 程式結束\n\nNeed to check spacing: After \"No\" they have two spaces before arrow in sample: \"No  →\". So use same pattern.\n\nAlso \"Decision:\" lines have no arrow at start? In sample, they used \"Decision: 如果數字大於 0?\". So just \"Decision: b > max?\" no arrow.\n\nAlso \"Start\" line no arrow.\n\nThus produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input: a, b, c // 取得三個整數  \n→ Step 1: max ← a // 初始化最大值為 a  \n→ Decision: b > max? // 判斷 b 是否大於目前最大  \n    Yes → Step 2: max ← b // 若是，更新最大值  \n    No  → // 不變  \n→ Decision: c > max? // 判斷 c 是否大於目前最大  \n    Yes → Step 3: max ← c // 若是，更新最大值  \n    No  → // 不變  \n→ Output: max // 輸出最大的數字  \nEnd // 程式結束",
      "generated_code": "def main():\n    a, b, c = map(int, input().split())\n    max_val = a\n    if b > max_val:\n        max_val = b\n    if c > max_val:\n        max_val = c\n    print(max_val)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "12 25 7",
          "expected_output": "25",
          "success": true,
          "output": "25"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "500.json",
    "problem_index_in_file": 0,
    "title": "倍數輸出",
    "description_snippet": "請寫一個程式，輸入一個正整數 n，使用 for 迴圈搭配 range()，輸出 1~50 之間所有能被 n 整除的數字。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code lines. For the user request: input positive integer n, use for loop with range(), output all numbers from 1 to 50 inclusive that are divisible by n.\n\nWe must produce virtual code with arrows and comments.\n\nWe need to use Start, End, Decision, Yes/No, Step.\n\nWe need step lines: Start, → Step 1: 輸入正整數 n, → Step 2: 迴圈從 i=1 to 50, → Decision: 是否 i % n == 0, Yes → Step 3: 輸出 i, No → nothing.\n\nFinally End.\n\nWe must ensure each line includes explanation after //.\n\nAlso maintain indentation? Use spaces maybe.\n\nMake sure to include the arrow lines appropriately. Let's produce.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 輸入正整數 n // 從使用者處取得 n\n→ Step 2: 初始化迴圈 i 由 1 開始到 50 // 準備檢查 1~50\n    → Decision: i 是否小於等於 50? // 確認迴圈是否還在範圍內\n        Yes → Step 3: 判斷 i 是否能被 n 整除 // 檢查可除性\n            → Decision: i % n 等於 0? // 判斷餘數是否為 0\n                Yes → Step 4: 輸出 i // 找到可整除的數字時輸出\n                No  → Step 5: 跳過輸出 // 不可整除則不輸出\n        No  → End // 迴圈結束\nEnd // 程式執行結束\n\nBut we need to follow format: we can use indentation to show nested decisions.\n\nThe example shows:\n\nStart // 程式開始執行\n→ Step 1: 輸入使用者數字 // 從使用者處取得一個數值\n→ Decision: 如果數字大於 0? // 檢查數值是否為正\n    Yes → Step 2: 輸出 '正數' // 如果是正數，顯示該訊息\n    No  → Decision: 如果數字等於 0? // 如果不是正數，檢查是否為零\n        Yes → Step 3: 輸出 '零' // 數字是零，顯示該訊息\n        No  → Step 4: 輸出 '負數' // 否則數值是負數\nEnd // 程式執行結束\n\nThey don't include loop statements explicitly but they used Decision: if number > 0.\n\nBut for loop, we can use Decision: i <= 50? etc.\n\nWe might also use Step 2: for i in range(1, 51): but the requirement says use for loop with range().\n\nIn virtual code, we could write:\n\n→ Step 2: for i in range(1, 51) // 開始 1 到 50 的迴圈\n\nBut the arrow maybe not necessary inside loop? They want each line of virtual code plus explanation. We can include Step 2: for i in range(1, 51) // 開始迴圈.\n\nThen inside loop, we need Decision: if i % n == 0. So:\n\n→ Decision: i % n 等於 0? // 判斷是否能被 n 整除\n    Yes → Step 3: 輸出 i // 輸出符合條件的數字\n    No  → Step 4: 跳過輸出 // 不符合條件時不輸出\n\nFinally End.\n\nWe should also include the End of program after loop.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: 輸入正整數 n // 從使用者取得 n\n→ Step 2: for i in range(1, 51) // 開始從 1 到 50 的迴圈\n    → Decision: i % n 等於 0? // 檢查 i 是否能被 n 整除\n        Yes → Step 3: 輸出 i // 輸出符合條件的數字\n        No  → Step 4: 跳過輸出 // 不符合條件則不輸出\nEnd // 程式執行結束\n\nBut we need to ensure that End is outside the loop. In virtual code we can show that after the for loop ends, End.\n\nBut the sample shows End at last line. It's fine.\n\nWe should also maybe show a Step 5: 迴圈結束 but not necessary.\n\nAlso maybe we should include \"End of loop\" but not required.\n\nNow, the instructions: Each line must include \"虛擬碼步驟\" + \" \" + \"// 解釋/說明\".\n\nAlso the virtual code arrow must use \"→\" for step lines, and \"Yes →\" \"No →\" for decisions.\n\nLet's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入正整數 n // 從使用者取得 n  \n→ Step 2: for i in range(1, 51) // 開始從 1 到 50 的迴圈  \n    → Decision: i % n 等於 0? // 檢查 i 是否能被 n 整除  \n        Yes → Step 3: 輸出 i // 輸出符合條件的數字  \n        No  → Step 4: 跳過輸出 // 不符合條件則不輸出  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef main() -> None:\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    divisible = [str(i) for i in range(1, 51) if i % n == 0]\n    print(' '.join(divisible))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "7",
          "expected_output": "7 14 21 28 35 42 49",
          "success": true,
          "output": "7 14 21 28 35 42 49"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "500.json",
    "problem_index_in_file": 1,
    "title": "密碼檢查",
    "description_snippet": "請寫一個程式，讓使用者重複輸入密碼，直到輸入正確的密碼 'python123' 為止。每次輸入錯誤都提示『密碼錯誤，請再試一次』，輸入正確時輸出『登入成功』。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code lines each with explanation. We need to produce a loop: while true prompt password. If matches, print success, break. Else error message, continue. Use virtual code arrow syntax. Let's craft.\n\nStart\n\n→ Decision: 是否已輸入正確密碼? // initial check, but maybe just loop. Instead use While.\n\nWe can structure:\n\nStart\n\n→ Decision: 密碼是否正確? // check if correct? But we need to get input first.\n\nMaybe:\n\n→ Step 1: 輸入密碼 // get input\n\n→ Decision: 密碼等於 'python123'? // check\n\n    Yes → Step 2: 輸出 '登入成功' // success\n\n    No  → Step 3: 輸出 '密碼錯誤，請再試一次' // error\n\n    → Step 4: 迴圈回到 Step 1 // repeat\n\nBut need to show loop: maybe use Decision: 是否正確? Yes → End, No → goto Step 1.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 輸入密碼 // 從使用者取得密碼輸入\n→ Decision: 密碼等於 'python123'? // 檢查密碼是否正確\n    Yes → Step 2: 輸出 '登入成功' // 密碼正確，顯示成功訊息\n    No  → Step 3: 輸出 '密碼錯誤，請再試一次' // 密碼錯誤，提示重試\n        → Step 4: 迴圈回到 Step 1 // 重新輸入密碼\nEnd // 程式執行結束\n\nNeed to ensure virtual code arrow: \"→\" before each. Use indentation for nested. Format similar to sample.\n\nMake sure each line includes explanation after //.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入密碼 // 從使用者取得密碼輸入  \n→ Decision: 密碼等於 'python123'? // 檢查密碼是否正確  \n  Yes → Step 2: 輸出 '登入成功' // 密碼正確，顯示成功訊息  \n  No  → Step 3: 輸出 '密碼錯誤，請再試一次' // 密碼錯誤，提示重試  \n    → Step 4: 迴圈回到 Step 1 // 重新輸入密碼  \nEnd // 程式執行結束",
      "generated_code": "def main():\n    while True:\n        password = input()\n        if password == 'python123':\n            print('登入成功')\n            break\n        else:\n            print('密碼錯誤，請再試一次')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "abc\n1234\npython123",
          "expected_output": "密碼錯誤，請再試一次\n密碼錯誤，請再試一次\n登入成功",
          "success": true,
          "output": "密碼錯誤，請再試一次\n密碼錯誤，請再試一次\n登入成功"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "600.json",
    "problem_index_in_file": 0,
    "title": "串列操作練習",
    "description_snippet": "請建立一個串列，內容包含整數 1 到 5，接著完成以下操作：\n1. 新增一個元素 6 到串列尾端。\n2. 刪除串列中的第 2 個元素（索引 1 的位置）。\n3. 輸出最後的串列結果。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code lines with explanations in Traditional Chinese. Use Start, End, Decision arrows, etc. We need to cover the steps: create list 1-5, add 6, delete second element, output list. Use → arrow for steps. Provide explanation after space. Each line: virtual code step + space + // explanation.\n\nWe need to use \"Start\" and \"End\". Steps: Step 1: create list [1,2,3,4,5] // initialize. Step 2: add 6 at end. Step 3: delete element at index 1. Step 4: output list.\n\nNo decisions needed, but we can still use decision to show check if list length >? not necessary. Just sequential steps.\n\nSo output:\n\nStart // 程式開始執行\n→ Step 1: list ← [1, 2, 3, 4, 5] // 建立包含 1~5 的串列\n→ Step 2: list.append(6) // 在串列尾端加入 6\n→ Step 3: list.remove_at(1) // 刪除索引 1（第 2 個）元素\n→ Step 4: output list // 輸出最終串列\n\nEnd // 程式執行結束\n\nBut ensure each line includes virtual code step with arrow or maybe \"Step 1:\"? The sample uses \"→ Step 1: 輸入使用者數字\". So use that.\n\nWe can include \"Decision\" but not needed.\n\nSo final answer: lines.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: list ← [1, 2, 3, 4, 5] // 建立包含 1~5 的串列  \n→ Step 2: list.append(6) // 在串列尾端加入 6  \n→ Step 3: list.remove_at(1) // 刪除索引 1（第 2 個）元素  \n→ Step 4: output list // 輸出最終串列  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef main():\n    # 讀取任何輸入，雖不需要但符合「從 stdin 讀取」的規範\n    sys.stdin.read()\n\n    # 建立包含 1 到 5 的串列\n    nums = [1, 2, 3, 4, 5]\n\n    # 在串列尾端加入 6\n    nums.append(6)\n\n    # 刪除索引 1（即第二個）元素\n    del nums[1]\n\n    # 輸出最終串列\n    print(nums)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "[1, 3, 4, 5, 6]",
          "success": true,
          "output": "[1, 3, 4, 5, 6]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "600.json",
    "problem_index_in_file": 1,
    "title": "集合函數練習",
    "description_snippet": "請建立一個集合 fruits = {'apple', 'banana'}，並完成以下操作：\n1. 使用 add() 新增 'orange'。\n2. 使用 update() 一次新增 'grape' 與...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with arrows. Starting with Start, then steps for each operation, then End. Must follow the format exactly: each line: \"虛擬碼步驟 // 解釋\" with arrow or Decision.\n\nThe operations are straightforward, no decision branches needed except maybe when removing. But we can include Decision for remove? Not necessary. We'll just do Step lines. For discard, we can mention that it's safe. End.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: fruits ← {'apple', 'banana'} // 建立集合 fruits\n→ Step 2: fruits.add('orange') // 使用 add() 新增 'orange'\n→ Step 3: fruits.update({'grape', 'melon'}) // 使用 update() 同時新增 'grape' 與 'melon'\n→ Step 4: fruits.remove('banana') // 使用 remove() 移除 'banana'\n→ Step 5: fruits.discard('pineapple') // 使用 discard() 嘗試移除不存在的 'pineapple'\n→ Step 6: print(fruits) // 輸出最終集合\nEnd // 程式執行結束\n\nWe should ensure the arrow format: \"→ Step X: ...\". Each line. Yes.\n\nReturn that.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: fruits ← {'apple', 'banana'} // 建立集合 fruits  \n→ Step 2: fruits.add('orange') // 使用 add() 新增 'orange'  \n→ Step 3: fruits.update({'grape', 'melon'}) // 使用 update() 同時新增 'grape' 與 'melon'  \n→ Step 4: fruits.remove('banana') // 使用 remove() 移除 'banana'  \n→ Step 5: fruits.discard('pineapple') // 使用 discard() 嘗試移除不存在的 'pineapple'  \n→ Step 6: print(fruits) // 輸出最終集合  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef main() -> None:\n    # 讀取標準輸入（若有提供），但對於本題並不需要使用這些資料\n    _ = sys.stdin.read()\n\n    # 建立初始集合\n    fruits = {'apple', 'banana'}\n\n    # 1. 新增 'orange'\n    fruits.add('orange')\n\n    # 2. 同時新增 'grape' 與 'melon'\n    fruits.update(['grape', 'melon'])\n\n    # 3. 移除 'banana'\n    fruits.remove('banana')\n\n    # 4. 嘗試移除不存在的 'pineapple'，discard 不會拋出錯誤\n    fruits.discard('pineapple')\n\n    # 輸出最終集合\n    print(fruits)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "{'apple', 'orange', 'grape', 'melon'}",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '{\"apple\",\"orange\",\"grape\",\"melon\"}'\nGot (Norm):      '{\"grape\",\"orange\",\"melon\",\"apple\"}'\n--- (Raw) ---\nRaw Expected: \"{'apple', 'orange', 'grape', 'melon'}\"\nRaw Got:      \"{'grape', 'orange', 'melon', 'apple'}\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "700.json",
    "problem_index_in_file": 0,
    "title": "質數判斷函數",
    "description_snippet": "請寫一個函數 is_prime(n)，判斷一個整數是否為質數。如果是質數回傳 True，否則回傳 False。\n\n質數定義：大於 1，且除了 1 和自己本身外，沒有其他因數。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line with explanation. Should use virtual code arrow style. Must follow format: Each line: \"虛擬碼步驟 // 解釋\". Use arrow ->. The structure: Start, Step, Decision, End. Should include decision tree. For function is_prime(n) with logic: if n <= 1 return False. If n <=3 return True. If n%2==0 or n%3==0 return False. Then loop i=5; i*i <= n; i+=6; if n%i==0 or n%(i+2)==0 return False. Else return True. Represent steps. Provide explanation each line. Use arrow and decision. Provide Start, End. Let's write lines accordingly. Use proper indentation maybe. Use \"→\" arrow. For decisions: \"Decision: ...?\". Use Yes → and No →. Let's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Function is_prime(n) // 定義函式以判斷質數  \n→ Decision: n 是否小於等於 1? // 檢查輸入是否小於等於 1  \n  Yes → Return False // 不是質數，立即回傳 False  \n  No  → Decision: n 是否小於等於 3? // 仍可能是質數，檢查小於等於 3  \n   Yes → Return True // 2 或 3 為質數，回傳 True  \n   No  → Decision: n 是否能被 2 或 3 整除? // 檢查是否為偶數或能被 3 整除  \n    Yes → Return False // 不是質數，回傳 False  \n    No  → Step 1: 設定 i = 5 // 開始 6k±1 節點的迴圈  \n→ Step 2: Decision: i*i 是否小於等於 n? // 判斷是否還需檢查更高因數  \n  Yes → Decision: n 是否能被 i 或 i+2 整除? // 檢查當前 6k±1 兩個候選因數  \n    Yes → Return False // 找到因數，非質數  \n    No  → Step 3: i = i + 6 // 移動到下一個 6k±1 組合  \n     → Goto Step 2 // 回到判斷 i*i 的條件  \n  No  → Return True // 所有檢查完成，n 為質數  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef is_prime(n: int) -> bool:\n    \"\"\"\n    判斷 n 是否為質數。\n    質數定義：大於 1，且除了 1 與自身外沒有其他因數。\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:          # 2、3 都是質數\n        return True\n    if n % 2 == 0 or n % 3 == 0:   # 能被 2 或 3 整除的非 2、3 的數不是質數\n        return False\n\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef main() -> None:\n    \"\"\"\n    讀取標準輸入並執行其中的程式碼。\n    這樣即可支援「print(is_prime(7))」等測試用例。\n    \"\"\"\n    code = sys.stdin.read()\n    # 執行輸入程式碼時提供 is_prime 函式，並允許使用內建函式\n    exec(code, {\"is_prime\": is_prime, \"__builtins__\": __builtins__})\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "print(is_prime(7))\nprint(is_prime(12))",
          "expected_output": "True\nFalse",
          "success": true,
          "output": "True\nFalse"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "700.json",
    "problem_index_in_file": 1,
    "title": "計算平均分數",
    "description_snippet": "請寫一個函數 calc_avg(*scores)，接收多個分數作為參數，並回傳平均值 (四捨五入到小數點後 2 位)。\n\n限制：不可使用內建函數 sum()。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step. We need to show steps to compute average with *scores, no sum(). So we iterate over scores, sum manually, count, divide, round to 2 decimal places.\n\nAlso we need Start, End, Decision maybe. Not necessary for simple function but we can show start, step, decision maybe if check length >0? We can avoid division by zero.\n\nWe produce lines like:\n\nStart // 程式開始執行\n→ Function: calc_avg(scores) // 定義函式接收多個分數\n\nWe need to incorporate parameter *scores: we can represent that.\n\nWe need to show steps: Initialize total = 0, count = 0, iterate each score, total += score, count +=1, then if count==0? return 0? We might show decision.\n\nCompute average = total / count\n\nRound to 2 decimal places: average = Round(average, 2) // 假設 Round 兩位\n\nReturn average\n\nEnd // 程式執行結束\n\nNeed arrow formatting.\n\nLet's produce lines with \"→\". Use indentation for decision branches.\n\nLet's produce virtual code lines. Each line: \"虛擬碼步驟 // 解釋\". Use \"Start\", \"End\", \"Decision:\". Use \"→\" for steps. Example: \"→ Step: 初始化 total=0, count=0\".\n\nWe can also use \"→ Function: calc_avg(scores)\" as step.\n\nLet's output accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Function: calc_avg(scores) // 定義函式，接受多個分數作為參數\n→ Step: total = 0, count = 0 // 初始化總分與計數\n→ Decision: 如果 scores 為空? // 檢查是否有輸入分數\n    Yes → Return 0 // 若無分數，直接回傳 0\n    No  →\n        → Step: for each score in scores: // 遍歷每個分數\n            → Step: total = total + score // 累加分數\n            → Step: count = count + 1 // 增加計數\n→ Step: average = total / count // 計算平均值\n→ Step: average = Round(average, 2) // 四捨五入到小數點後 2 位\n→ Step: Return average // 回傳平均值\nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef calc_avg(*scores):\n    \"\"\"\n    計算多個分數的平均值，並四捨五入到小數點後兩位。\n    \"\"\"\n    total = 0\n    count = 0\n    for s in scores:\n        total += s\n        count += 1\n    # 若 count 為 0，避免除以 0，這裡直接回傳 0\n    if count == 0:\n        return 0\n    return round(total / count, 2)\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    code = sys.stdin.read()\n    # 執行輸入的程式碼，calc_avg 會在全域範圍可見\n    exec(code, globals())",
      "validation_results": [
        {
          "example_index": 0,
          "input": "print(calc_avg(80, 90, 100))\nprint(calc_avg(70, 75, 85, 95))",
          "expected_output": "90.0\n81.25",
          "success": true,
          "output": "90.0\n81.25"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "1000.json",
    "problem_index_in_file": 0,
    "title": "列表與條件生成式練習",
    "description_snippet": "請寫一個程式，建立一個包含 1 到 20 的整數列表，接著使用列表生成式（List Comprehension）產生一個新列表，只保留偶數並將它們平方後輸出結果。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nThe user wants pseudocode for program: create list 1-20, then list comprehension to filter evens and square, output result.\n\nNeed to output lines with \"虛擬碼步驟 // 解釋\" format, using arrows Start, →, Decision etc. Use bullet? Just lines.\n\nLet's produce: Start, Step 1: Initialize list 1-20, Step 2: Create new list via list comprehension: [x*x for x in list if x%2==0], Step 3: Output result. End.\n\nWe can incorporate decision? Not needed. But we can add decision: maybe not needed.\n\nThe requirement: Use virtual code arrow. It's fine to use →. Provide explanation after //.\n\nLet's output lines as:\n\nStart // 程式開始執行\n→ Step 1: 建立整數列表 range(1,21) // 產生 1 至 20 的數字\n→ Step 2: 用列表生成式過濾偶數並平方 // 只保留偶數，並將其平方\n→ Step 3: 輸出新列表 // 顯示平方後的偶數列表\nEnd // 程式執行結束\n\nMake sure each line has \"虛擬碼步驟\" + space + \"// 解釋\". They use \"虛擬碼步驟\" like \"Start\". Should we label? They used \"Start // 程式開始執行\". Use that.\n\nThus output:\n\nStart // 程式開始執行\n→ Step 1: 建立列表 numbers = range(1, 21) // 產生 1~20 的整數\n→ Step 2: new_list = [x*x for x in numbers if x % 2 == 0] // 過濾偶數並平方\n→ Step 3: 輸出 new_list // 顯示結果\nEnd // 程式執行結束\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立列表 numbers = range(1, 21) // 產生 1~20 的整數  \n→ Step 2: new_list = [x*x for x in numbers if x % 2 == 0] // 過濾偶數並平方  \n→ Step 3: 輸出 new_list // 顯示結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef main():\n    # 讀取標準輸入，即使此題不需要任何輸入，也要遵守規範\n    _ = sys.stdin.read()\n\n    # 建立 1 到 20 的整數列表\n    nums = list(range(1, 21))\n\n    # 用列表生成式過濾偶數並平方\n    result = [n ** 2 for n in nums if n % 2 == 0]\n\n    # 將結果輸出到標準輸出\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "[4, 16, 36, 64, 100, 144, 196, 256, 324, 400]",
          "success": true,
          "output": "[4, 16, 36, 64, 100, 144, 196, 256, 324, 400]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "1000.json",
    "problem_index_in_file": 1,
    "title": "map() / filter() / lambda 綜合練習",
    "description_snippet": "請寫一個程式，建立一個列表 numbers = [3, 7, 10, 15, 20]。\n1. 使用 filter() 搭配 lambda 篩選出可被 5 整除的數。\n2. 使用 map() 將這些數字...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line, with arrows, decisions etc. It's a straightforward program: initialize list, filter with lambda, map to multiply by 10, output list. Use virtual code style. Provide explanation after space. We need to follow format. Use Start, → Step, Decision etc. But there's no decision here. Just straightforward steps. We should include End. Each line: \"虛擬碼步驟 // 解釋\".\n\nLet's create:\n\nStart // 程式開始執行\n→ Step 1: numbers = [3, 7, 10, 15, 20] // 初始化數字列表\n→ Step 2: divisible_by_five = list(filter(lambda x: x % 5 == 0, numbers)) // 篩選可被5整除的數\n→ Step 3: multiplied = list(map(lambda x: x * 10, divisible_by_five)) // 將篩選結果乘以10\n→ Step 4: print(multiplied) // 輸出最終結果列表\nEnd // 程式執行結束\n\nThat's it. No decision. Provide explanation after each. Use correct spacing: virtual code step space // explanation. Ensure each line ends with explanation.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: numbers = [3, 7, 10, 15, 20] // 初始化數字列表\n→ Step 2: divisible_by_five = list(filter(lambda x: x % 5 == 0, numbers)) // 篩選可被 5 整除的數字\n→ Step 3: multiplied = list(map(lambda x: x * 10, divisible_by_five)) // 將篩選結果的數字乘以 10\n→ Step 4: print(multiplied) // 輸出最終結果列表\nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef main():\n    # 讀取並忽略 stdin 的內容，確保程式符合「必須從 stdin 讀取」的要求\n    sys.stdin.read()\n\n    # 建立列表\n    numbers = [3, 7, 10, 15, 20]\n\n    # 先篩選可被 5 整除的數字\n    filtered = filter(lambda x: x % 5 == 0, numbers)\n\n    # 再將篩選結果乘以 10\n    result = list(map(lambda x: x * 10, filtered))\n\n    # 輸出最終結果\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "[100, 150, 200]",
          "success": true,
          "output": "[100, 150, 200]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "1200.json",
    "problem_index_in_file": 0,
    "title": "JSON 檔案儲存與讀取練習",
    "description_snippet": "請寫一個程式，建立一個字典 data = {'name': 'Alice', 'age': 25, 'city': 'Taipei'}。\n1. 使用 json.dump() 將其寫入 data.jso...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation, following format. The user wants a virtual code to:\n\n- Define dictionary\n- Use json.dump() to write to data.json\n- Use json.load() to read back\n- Print name and city\n\nWe should produce steps like:\n\nStart\n→ Step 1: data = {'name': 'Alice', 'age': 25, 'city': 'Taipei'} // 初始化字典\n→ Step 2: open 'data.json' as file_out in write mode // 準備寫入檔案\n→ Step 3: json.dump(data, file_out) // 將字典寫入檔案\n→ Step 4: close file_out // 關閉檔案\n→ Step 5: open 'data.json' as file_in in read mode // 準備讀取檔案\n→ Step 6: loaded_data = json.load(file_in) // 讀取 JSON 成字典\n→ Step 7: close file_in // 關閉檔案\n→ Step 8: print loaded_data['name'] // 輸出 name\n→ Step 9: print loaded_data['city'] // 輸出 city\nEnd\n\nMake sure each line has arrow \"→\" except start and end.\n\nBut the format example uses \"Start\" then \"→ Step 1: ...\" each line. Use same pattern.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: data = {'name': 'Alice', 'age': 25, 'city': 'Taipei'} // 初始化字典\n→ Step 2: open('data.json', 'w') as file_out // 準備寫入檔案\n→ Step 3: json.dump(data, file_out) // 將字典寫入 JSON 檔案\n→ Step 4: file_out.close() // 關閉寫入檔案\n→ Step 5: open('data.json', 'r') as file_in // 準備讀取檔案\n→ Step 6: loaded_data = json.load(file_in) // 讀取 JSON 成字典\n→ Step 7: file_in.close() // 關閉讀取檔案\n→ Step 8: print(loaded_data['name']) // 印出 name 欄位\n→ Step 9: print(loaded_data['city']) // 印出 city 欄位\nEnd // 程式執行結束",
      "generated_code": "import json\nimport sys\n\ndef main():\n    # 讀取標準輸入，雖然此程式不需要實際輸入，但為符合題目要求必須讀取\n    _ = sys.stdin.read()\n\n    # 建立字典資料\n    data = {'name': 'Alice', 'age': 25, 'city': 'Taipei'}\n\n    # 寫入 JSON 檔案\n    with open('data.json', 'w', encoding='utf-8') as f:\n        json.dump(data, f, ensure_ascii=False, indent=2)\n\n    # 讀取 JSON 檔案\n    with open('data.json', 'r', encoding='utf-8') as f:\n        result = json.load(f)\n\n    # 輸出結果\n    print('姓名：', result['name'])\n    print('城市：', result['city'])\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "姓名： Alice\n城市： Taipei",
          "success": true,
          "output": "姓名： Alice\n城市： Taipei"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "1200.json",
    "problem_index_in_file": 1,
    "title": "即時匯率查詢小工具",
    "description_snippet": "請使用 requests 模組串接匯率 API（https://api.exchangerate-api.com/v4/latest/USD），取得當前美元兌換台幣（TWD）的匯率。\n將結果顯示在 t...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need produce step-by-step virtual code lines, each with explanation, using the specified format. No actual code. Just steps. Should describe using requests, tkinter, etc. Use Start, End, Decision. Include steps: import modules, define function to fetch rate, create window, label, button, set command to fetch, update label, mainloop.\n\nWe need to be thorough but not too many lines. Each line is a step. Use arrows →. Provide explanation after //.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 匯入 requests 模組 // 引入 HTTP 請求庫  \n→ Step 2: 匯入 tkinter 模組 // 引入 GUI 庫  \n→ Step 3: 定義函式 fetch_rate()  \n  → Step 3.1: 發送 GET 請求至 https://api.exchangerate-api.com/v4/latest/USD // 取得最新美元匯率資料  \n  → Decision: 如果回應狀態碼為 200? // 檢查請求是否成功  \n    Yes → Step 3.2: 解析 JSON 資料 // 取得回傳的 JSON  \n     → Step 3.3: 取得 TWD 匯率值 // 從 JSON 取出 'rates' -> 'TWD'  \n     → Step 3.4: 回傳 TWD 匯率值 // 返回匯率  \n    No → Step 3.5: 回傳 '錯誤' // 失敗時回傳錯誤訊息  \n→ Step 4: 建立 tkinter 視窗 root  \n→ Step 5: 建立標籤 label 用於顯示匯率 // 初始化顯示文字  \n→ Step 6: 建立按鈕 update_btn，文字為 \"更新匯率\"  \n  → Step 6.1: 設定按鈕 command 為 lambda：fetch_rate() 並將結果顯示在 label 上 // 觸發更新操作  \n→ Step 7: 把 label 與 update_btn 放置於視窗中 // 佈局  \n→ Step 8: 呼叫 fetch_rate() 以取得初始匯率並顯示在 label 上 // 開始時顯示一次  \n→ Step 9: 執行 root.mainloop() // 開始事件迴圈，等待使用者互動  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport requests\nimport tkinter as tk\n\ndef fetch_rate() -> str:\n    \"\"\"\n    取得美元兌台幣匯率並回傳字串\n    若請求失敗則回傳錯誤訊息\n    \"\"\"\n    try:\n        url = 'https://api.exchangerate-api.com/v4/latest/USD'\n        r = requests.get(url, timeout=10)\n        r.raise_for_status()                     # 若 HTTP 狀態碼非 200，拋出例外\n        data = r.json()\n        rate = data['rates']['TWD']\n        return f\"目前美元匯率：約 {rate} TWD\"\n    except Exception as e:\n        return \"更新失敗，請檢查網路連線\"\n\ndef get_rate() -> None:\n    \"\"\"\n    更新 GUI 標籤內容\n    \"\"\"\n    label.config(text=fetch_rate())\n\n# ---------- GUI 設定 ----------\nwin = tk.Tk()\nwin.title('匯率查詢')\n\nlabel = tk.Label(win, text='請按下按鈕更新匯率', font=('Arial', 12))\nlabel.pack(pady=10)\n\nupdate_btn = tk.Button(win, text='更新匯率', command=get_rate)\nupdate_btn.pack(pady=5)\n\n# ---------- 主程式 ----------\nif __name__ == \"__main__\":\n    # 讀取 stdin，若有輸入則視為「更新匯率」指令，直接列印結果\n    input_data = sys.stdin.read().strip()\n    if input_data:\n        # 只要有任何輸入，就執行一次匯率查詢並輸出\n        print(fetch_rate())\n    else:\n        # 無輸入時，顯示 GUI 介面\n        win.mainloop()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "按下「更新匯率」按鈕",
          "expected_output": "目前美元匯率：約 32.5 TWD",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '目前美元匯率：約32.5TWD'\nGot (Norm):      '目前美元匯率：約30.66TWD'\n--- (Raw) ---\nRaw Expected: '目前美元匯率：約 32.5 TWD'\nRaw Got:      '目前美元匯率：約 30.66 TWD'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode306.json",
    "problem_index_in_file": 0,
    "title": "Additive Number",
    "description_snippet": "An additive number is a string whose digits can form an additive sequence.\n\nA valid additive sequenc...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode lines with explanations. It's additive number detection. Use backtracking. Steps: Start, iterate i from 1 to n-2, j from i+1 to n-1, get first two numbers, check leading zeros, then try to extend sequence by sum until reach end. Use while loop. Provide decisions. We'll generate lines. Ensure each line has \"虛擬碼步驟 // 解釋\". Use arrow formatting. Provide Start and End. Use Decision. Provide loops. Let's craft.\n\nNeed to output in Traditional Chinese. We'll use Traditional characters. Provide step lines.\n\nWe'll produce:\n\nStart // 程式開始\n→ Step 1: 輸入字串 s // 取得待檢查的數字字串\n→ Decision: s 長度 < 3? // 最短三個字符\n    Yes → End with False // 無法形成三個數\n    No  → \n→ For i = 1 to |s|-2 // 第一個數字長度\n    → For j = i+1 to |s|-1 // 第二個數字長度\n        → Step 2: first = s[0:i] // 取第一個數字\n        → Step 3: second = s[i:j] // 取第二個數字\n        → Decision: first 或 second 有前導零且長度 >1? // 檢查前導零\n            Yes → Next j // 跳過此組合\n            No  →\n                → Step 4: 以 first, second 為起始，進行遞迴檢查\n                → Decision: 以遞迴結果為真? // 檢查是否整串可拆分\n                    Yes → End with True // 成功\n                    No  → Next j\n→ End // 所有組合檢查完畢，回傳 False\n\nNeed recursive pseudo function Check(start, num1, num2). Provide steps.\n\nLet's embed recursion lines within Step 4. We'll show:\n\n→ Step 4: Function Check(idx, num1, num2) // idx 為下一個待匹配的索引\n    → Decision: idx == |s|? // 到達字串末尾\n        Yes → Return True // 成功\n        No  →\n            → sum = num1 + num2\n            → sumStr = sum.ToString()\n            → Decision: s.Substring(idx, sumStr.Length) == sumStr? // 匹配\n                Yes → Return Check(idx + sumStr.Length, num2, sum) // 進一步遞迴\n                No  → Return False\n\nBut need to embed in pseudo flow. Let's produce with Start, End, Decision, etc.\n\nAlso must not output actual code, just virtual code lines.\n\nLet's produce all lines with // explanations.\n\nUse arrow \"→\" preceding each step except Start and End.\n\nWe'll format loops with \"For i = 1 to ...\" etc.\n\nWe'll add indentation comments.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入字串 s // 取得待檢查的數字字串  \n→ Decision: s 長度 < 3? // 至少需要三個數字才能形成序列  \n    Yes → End // 回傳 False（由程式邏輯決定）  \n    No →  \n→ For i = 1 to |s| - 2 // 第一個數字長度迴圈  \n    → For j = i + 1 to |s| - 1 // 第二個數字長度迴圈  \n        → Step 2: first = s[0:i] // 取第一個數字 substring  \n        → Step 3: second = s[i:j] // 取第二個數字 substring  \n        → Decision: first 或 second 有前導零且長度 > 1? // 檢查前導零合法性  \n            Yes → Continue // 跳過此組合，進行下一個 j  \n            No →  \n                → Step 4: 呼叫 Check(j, first, second) // 以第一、第二個數字作起始，檢查剩餘序列  \n                → Decision: Check 回傳 True? // 整串能形成加法序列嗎？  \n                    Yes → End // 成功，回傳 True  \n                    No → Continue // 進行下一個 j  \n\n→ Function Check(idx, num1, num2) // idx 為下一個待匹配的索引  \n    → Decision: idx == |s|? // 是否已到達字串結尾  \n        Yes → Return True // 成功完成序列  \n        No →  \n            → sum = num1 + num2 // 計算兩數之和  \n            → sumStr = sum.ToString() // 轉成字串形式  \n            → Decision: s.Substring(idx, |sumStr|) == sumStr? // 前綴是否等於和  \n                Yes → Return Check(idx + |sumStr|, num2, sum) // 進一步遞迴，num2 成為前一數，sum 成為後一數  \n                No → Return False // 無法匹配，回傳 False  \n\nEnd // 所有組合檢查完畢，回傳 False（若未提前返回 True）",
      "generated_code": "import sys\n\nclass Solution:\n    def isAdditiveNumber(self, num: str) -> bool:\n        n = len(num)\n        # Try every possible split for the first two numbers\n        for i in range(1, n):\n            for j in range(i + 1, n):\n                num1, num2 = num[:i], num[i:j]\n\n                # Leading zeros are not allowed (except for the number 0 itself)\n                if (len(num1) > 1 and num1[0] == '0') or (len(num2) > 1 and num2[0] == '0'):\n                    continue\n\n                k = j\n                # Extend the sequence while the next part of the string matches the sum\n                while k < n:\n                    sum_str = str(int(num1) + int(num2))\n                    if not num.startswith(sum_str, k):\n                        break\n                    k += len(sum_str)\n                    num1, num2 = num2, sum_str\n\n                # If we reached the end of the string, we found a valid sequence\n                if k == n:\n                    return True\n        return False\n\nif __name__ == \"__main__\":\n    # Read the entire input, strip whitespace and any surrounding quotes\n    data = sys.stdin.read().strip().strip('\"')\n    solution = Solution()\n    result = solution.isAdditiveNumber(data)\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "\"112358\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "\"199100199\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode71.json",
    "problem_index_in_file": 0,
    "title": "Simplify Path",
    "description_snippet": "You are given an absolute path for a Unix-style file system, which always begins with a slash '/'. Y...",
    "examples_loaded": 5,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code steps for simplifying Unix path. Provide each line: \"虛擬碼步驟 // 解釋\".\n\nFollow format: Start, → Step X:..., Decision:, Yes→, No→, End.\n\nWe need to produce pseudo steps. Let's design:\n\nStart\n→ Split path by '/' into tokens // break on slash\n→ Initialize stack empty // stack to store directories\n→ For each token in tokens: // iterate tokens\n    → Decision: token empty? // skip empty tokens\n        Yes → Continue // ignore\n        No → Decision: token == '.'? // current directory\n            Yes → Continue\n            No → Decision: token == '..'? // parent directory\n                Yes → Decision: stack not empty? // pop if possible\n                    Yes → Pop stack\n                    No → Continue // at root, ignore\n                No → Decision: token == ''? // already handled, but keep\n                    Yes → Continue\n                    No → Push token onto stack // valid directory name\n→ Build canonical path by joining stack with '/' // join\n→ Decision: stack empty? // root\n    Yes → Result = '/' // root\n    No → Result = '/' + join(stack with '/')\nEnd // end\n\nNeed to produce line by line with appropriate arrow structure. Might need loops: For each token. Use Decision block. Provide steps inside. Use indent with tabs? Format not strict but need arrow \"→\" preceding each step. Use nested decisions.\n\nLet's craft.\n\n```\nStart // 程式開始執行\n→ Step 1: tokens ← split(path, \"/\") // 將路徑以 '/' 分割為字串陣列\n→ Step 2: stack ← empty list // 用來儲存合法目錄名稱的棧\n→ Step 3: for token in tokens: // 逐一處理每個分隔出的字串\n    → Decision: token == \"\"? // 判斷是否為空字串（多個 '/'）\n        Yes → Continue // 跳過空字串\n        No → Decision: token == \".\"? // 判斷是否為單點\n            Yes → Continue // 跳過，代表當前目錄\n            No → Decision: token == \"..\"? // 判斷是否為雙點\n                Yes → Decision: stack not empty? // 是否有上一層目錄可退回\n                    Yes → Step 4: pop(stack) // 從棧中移除上一層目錄\n                    No → Continue // 已在根目錄，忽略\n                No → Step 5: push(stack, token) // 把合法目錄名稱加入棧\n→ Step 6: if stack empty? // 判斷是否仍在根目錄\n    Yes → Result ← \"/\" // 根目錄\n    No → Result ← \"/\" + join(stack, \"/\") // 重新組合成簡化路徑\nEnd // 程式執行結束\n```\n\nCheck format: each line has virtual code + space + comment. Use `→` arrow. For nested decisions we indent? Not required but helpful. Use indentation spaces.\n\nEnsure we don't output actual code, just pseudo. Provide lines.\n\nLet's output.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: tokens ← split(path, \"/\") // 將路徑以 '/' 分割為字串陣列\n→ Step 2: stack ← empty list // 用來儲存合法目錄名稱的棧\n→ Step 3: for token in tokens: // 逐一處理每個分隔出的字串\n    → Decision: token == \"\"? // 判斷是否為空字串（多個 '/'）\n        Yes → Continue // 跳過空字串\n        No → Decision: token == \".\"? // 判斷是否為單點\n            Yes → Continue // 跳過，代表當前目錄\n            No → Decision: token == \"..\"? // 判斷是否為雙點\n                Yes → Decision: stack not empty? // 是否有上一層目錄可退回\n                    Yes → Step 4: pop(stack) // 從棧中移除上一層目錄\n                    No → Continue // 已在根目錄，忽略\n                No → Step 5: push(stack, token) // 把合法目錄名稱加入棧\n→ Step 6: if stack empty? // 判斷是否仍在根目錄\n    Yes → Result ← \"/\" // 根目錄\n    No → Result ← \"/\" + join(stack, \"/\") // 重新組合成簡化路徑\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\n\ndef simplify_path(path: str) -> str:\n    \"\"\"Return the simplified canonical Unix path.\"\"\"\n    stack = []\n    for part in path.split('/'):\n        if part == '' or part == '.':\n            continue\n        elif part == '..':\n            if stack:\n                stack.pop()\n        else:\n            stack.append(part)\n    return '/' + '/'.join(stack)\n\ndef main():\n    # Read all input from stdin\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n\n    # If input looks like \"path = \"/home/\"\" parse it\n    if '=' in raw_input:\n        _, value = raw_input.split('=', 1)\n        path = value.strip()\n    else:\n        path = raw_input\n\n    # Remove surrounding quotes if present\n    if (path.startswith('\"') and path.endswith('\"')) or (path.startswith(\"'\") and path.endswith(\"'\")):\n        path = path[1:-1]\n\n    result = simplify_path(path)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "path = \"/home/\"",
          "expected_output": "\"/home\"",
          "success": true,
          "output": "/home"
        },
        {
          "example_index": 1,
          "input": "path = \"/home//foo/\"",
          "expected_output": "\"/home/foo\"",
          "success": true,
          "output": "/home/foo"
        },
        {
          "example_index": 2,
          "input": "path = \"/home/user/Documents/../Pictures\"",
          "expected_output": "\"/home/user/Pictures\"",
          "success": true,
          "output": "/home/user/Pictures"
        },
        {
          "example_index": 3,
          "input": "path = \"/../\"",
          "expected_output": "\"/\"",
          "success": true,
          "output": "/"
        },
        {
          "example_index": 4,
          "input": "path = \"/.../a/../b/c/../d/./\"",
          "expected_output": "\"/.../b/d\"",
          "success": true,
          "output": "/.../b/d"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode347.json",
    "problem_index_in_file": 0,
    "title": "Top K Frequent Elements",
    "description_snippet": "Given an integer array nums and an integer k, return the k most frequent elements. You may return th...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line with arrow notation etc. Provide explanation after each line. The algorithm: Count frequencies, build heap or bucket sort, extract top k. But we can produce simple steps.\n\nWe'll produce Start → Step1: build frequency map → Step2: build min-heap of size k → Step3: iterate freq map to push/pop → Step4: extract results → End.\n\nNeed to include Decision steps? maybe if heap size < k? but we can just always push and if size > k pop. That might not need decisions. But we can include decision: if heap size > k? Yes → pop. Use Decision structure.\n\nLet's produce.\n\nLines:\n\nStart // 程式開始執行\n→ Step 1: 建立空的字典 freq // 用於計算每個元素的出現頻率\n→ Step 2: 對 nums 中的每個值 val 執行: freq[val] = freq.get(val, 0) + 1 // 逐個累加頻率\n→ Step 3: 建立一個最小堆 minHeap // 用於維護頻率最高的 k 個元素\n→ Decision: 如果 minHeap 大小小於 k? // 判斷堆中元素是否已達 k\n    Yes → Step 4: 將 (freq[val], val) 插入 minHeap // 直接加入\n    No  → Decision: 如果 freq[val] > minHeap[0].freq? // 與堆頂頻率比較\n        Yes → Step 5: 將 minHeap[0] 移除，然後插入 (freq[val], val) // 替換\n        No  → Step 6: 跳過此元素 // 仍保留前 k 個最頻繁的\n→ Step 7: 建立結果列表 res // 用於儲存最終答案\n→ Step 8: 從 minHeap 中彈出所有元素並將其 val 加入 res // 取得 k 個最頻繁元素\nEnd // 程式執行結束\n\nBut we need to show iteration over freq map. We'll need a loop: for val, count in freq.items().\n\nAlso we need to maintain heap of tuples (count, val). Use heapq.\n\nOk.\n\nAlso need to explain each line.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空的字典 freq // 用於記錄每個數字的出現頻率  \n→ Step 2: 對 nums 中的每個值 val 執行: freq[val] = freq.get(val, 0) + 1 // 逐個累加頻率  \n→ Step 3: 建立一個最小堆 minHeap // 用於維護頻率最高的 k 個元素  \n→ Decision: 如果 minHeap 大小小於 k? // 判斷堆中元素是否已達 k  \n Yes → Step 4: 將 (freq[val], val) 插入 minHeap // 直接加入堆中  \n No  → Decision: 如果 freq[val] > minHeap[0][0]? // 與堆頂頻率比較  \n  Yes → Step 5: pop minHeap[0]，然後將 (freq[val], val) 插入 minHeap // 替換為更高頻率的元素  \n  No  → Step 6: 跳過此元素 // 保留前 k 個最頻繁的  \n→ Step 7: 建立結果列表 res // 用於儲存最終答案  \n→ Step 8: 從 minHeap 中彈出所有元素並將其 val 加入 res // 取得 k 個最頻繁元素  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom collections import Counter\nimport heapq\nfrom typing import List\n\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        \"\"\"\n        使用 Counter 統計頻率，再用 heapq.nlargest 找出頻率最高的 k 個元素。\n        \"\"\"\n        freq = Counter(nums)\n        # heapq.nlargest 會根據 key 取得最大的 k 個項目，這裡的 key 是頻率\n        top_k = heapq.nlargest(k, freq.items(), key=lambda x: x[1])\n        # 只取元素值，忽略頻率\n        return [item for item, _ in top_k]\n\ndef parse_input(input_str: str):\n    \"\"\"\n    從形如 'nums = [1,1,1,2,2,3], k = 2' 的字串中提取 list 和 k。\n    \"\"\"\n    pattern = r'nums\\s*=\\s*(\\[.*?\\])\\s*,\\s*k\\s*=\\s*(\\d+)'\n    match = re.search(pattern, input_str, re.DOTALL)\n    if not match:\n        raise ValueError(\"Input format not recognised.\")\n    nums_str, k_str = match.groups()\n    # 使用 literal_eval 以安全方式解析 list\n    from ast import literal_eval\n    nums = literal_eval(nums_str)\n    k = int(k_str)\n    return nums, k\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n    nums, k = parse_input(raw_input)\n    solution = Solution()\n    result = solution.topKFrequent(nums, k)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,1,1,2,2,3], k = 2",
          "expected_output": "[1,2]",
          "success": true,
          "output": "[1, 2]"
        },
        {
          "example_index": 1,
          "input": "nums = [1], k = 1",
          "expected_output": "[1]",
          "success": true,
          "output": "[1]"
        },
        {
          "example_index": 2,
          "input": "nums = [1,2,1,2,1,2,3,1,3,2], k = 2",
          "expected_output": "[1,2]",
          "success": true,
          "output": "[1, 2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode380.json",
    "problem_index_in_file": 0,
    "title": "Insert Delete GetRandom O(1)",
    "description_snippet": "Implement the RandomizedSet class:\n\nRandomizedSet() Initializes the RandomizedSet object.\nbool inser...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines step-by-step with explanations. The user wants Virtual Code for RandomizedSet with average O(1). We'll outline initialization, insert, remove, getRandom. Use hash map for value to index and array list for values. Steps: Start, initialize map and list. Insert: check if val exists in map; if so return false; else append to list, record index in map, return true. Remove: check if exists; if not return false; else get index, swap last element with index, update map, pop last, delete map entry, return true. getRandom: generate random index in 0..len-1, return list[idx]. Also handle empty? Guarantee at least one element. Provide each step as a line with // explanation. Use arrows. Let's structure with Start, End. For methods, maybe define separate sections.\n\nWe'll output virtual code lines.\n\nNeed to keep each line simple, but include explanation.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化 RandomizedSet // 準備空資料結構\n    → Step 2: 創建空哈希表 map // 用於存儲值到索引的映射\n    → Step 3: 創建空動態陣列 list // 用於存儲所有元素\n\n→ Step 4: 定義 insert(val) // 插入元素\n    → Decision: 若 val 已存在於 map? // 檢查是否重複\n        Yes → Step 5: 返回 false // 已存在，插入失敗\n        No  → Step 6: 將 val 加入 list // 新元素放到尾端\n            → Step 7: 在 map 中記錄 val → 索引 (list.length - 1) // 記錄位置\n            → Step 8: 返回 true // 插入成功\n\n→ Step 9: 定義 remove(val) // 刪除元素\n    → Decision: 若 val 不存在於 map? // 檢查是否存在\n        No  → Step 10: 返回 false // 不存在，刪除失敗\n        Yes → Step 11: 取得 val 的索引 idx = map[val] // 獲取位置\n            → Step 12: 取得最後一個元素 last = list.last() // 取陣列尾部\n            → Step 13: 將 last 放到 idx 處 list[idx] = last // 位置交換\n            → Step 14: 更新 map[last] = idx // 更新 last 的新索引\n            → Step 15: 刪除 list 的最後一個元素 list.pop() // 移除尾部\n            → Step 16: 從 map 刪除 val // 移除映射\n            → Step 17: 返回 true // 刪除成功\n\n→ Step 18: 定義 getRandom() // 隨機取元素\n    → Step 19: 生成隨機整數 r 在 0 到 list.length-1 之間 // 隨機索引\n    → Step 20: 返回 list[r] // 取得對應元素\n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\nimport random\n\nclass RandomizedSet:\n    \"\"\"O(1) average time complexity for insert, remove, and getRandom.\"\"\"\n    def __init__(self):\n        # Map from value to its index in the list\n        self.val_to_index = {}\n        # List storing the values\n        self.values = []\n\n    def insert(self, val: int) -> bool:\n        \"\"\"Insert val into the set if not present.\"\"\"\n        if val in self.val_to_index:\n            return False\n        self.values.append(val)\n        self.val_to_index[val] = len(self.values) - 1\n        return True\n\n    def remove(self, val: int) -> bool:\n        \"\"\"Remove val from the set if present.\"\"\"\n        if val not in self.val_to_index:\n            return False\n        idx = self.val_to_index[val]\n        last_val = self.values[-1]\n        # Move the last element into the spot of the removed element\n        self.values[idx] = last_val\n        self.val_to_index[last_val] = idx\n        # Remove the last element\n        self.values.pop()\n        del self.val_to_index[val]\n        return True\n\n    def getRandom(self) -> int:\n        \"\"\"Return a random element from the set.\"\"\"\n        return random.choice(self.values)\n\ndef main():\n    # Read entire stdin, strip whitespace, and wrap with brackets to form a JSON array\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n    # Convert input into a JSON array of two elements: operations and arguments\n    data = json.loads('[' + raw_input + ']')\n    ops, args = data\n\n    res = []\n    obj = None  # Will hold the RandomizedSet instance\n\n    for op, arg in zip(ops, args):\n        if op == \"RandomizedSet\":\n            obj = RandomizedSet()\n            res.append(None)  # Corresponds to 'null' in JSON\n        elif op == \"insert\":\n            res.append(obj.insert(arg[0]))\n        elif op == \"remove\":\n            res.append(obj.remove(arg[0]))\n        elif op == \"getRandom\":\n            res.append(obj.getRandom())\n        else:\n            # Unknown operation; append None\n            res.append(None)\n\n    # Output the result list in JSON format (null, true, false, numbers)\n    print(json.dumps(res))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"RandomizedSet\", \"insert\", \"remove\", \"insert\", \"getRandom\", \"remove\", \"insert\", \"getRandom\"], [[], [1], [2], [2], [], [1], [2], []]",
          "expected_output": "[null, true, false, true, 2, true, false, 2]",
          "success": true,
          "output": "[null, true, false, true, 2, true, false, 2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode519.json",
    "problem_index_in_file": 0,
    "title": "Random Flip Matrix",
    "description_snippet": "There is an m x n binary grid matrix with all the values set 0 initially. Design an algorithm to ran...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to output virtual code step-by-step. Should not output actual code. Should use arrows. We need to explain each line. For this problem, algorithm: use reservoir of available cells. We can map 1D index to 2D. Use total = m*n. Use list of available indices from 0 to total-1. We can simulate shuffle with mapping dictionary. flip: pick random k between 0 and remaining-1. let idx = mapping.get(k, k). mapping[k] = mapping.get(remaining-1, remaining-1). remaining--. Convert idx to (i, j). return [i, j]. reset: clear mapping and set remaining=total. Also need to handle calls to random minimized: each flip uses one random call. Complexity: O(1) avg time per flip.\n\nWe need virtual code with step lines: Start, Step: Initialize variables. For flip: Step: pick random, map to index, update mapping. Convert. For reset: clear mapping, set count.\n\nLet's produce.\n\nUse format: \nStart // ...\n→ Step 1:  // description\n\nNeed to include arrows. Let's produce each line with // explanation.\n\nWill use decisions maybe not needed. Provide simple flow.\n\nLet's output:\n\nStart // 程式開始執行\n→ Step 1: Set total ← m * n // 計算矩陣總格數\n→ Step 2: Set remaining ← total // 記錄尚未翻轉的格數\n→ Step 3: 初始化 mapping as empty map // 用於存儲已交換的索引\n\nFlip() method:\n→ Step 4: Call rand_int ← random(0, remaining-1) // 隨機取得一個可用位置\n→ Step 5: If rand_int in mapping then idx ← mapping[rand_int] else idx ← rand_int // 取得真實索引\n→ Step 6: Let last ← remaining-1 // 取最後一個可用位置\n→ Step 7: If last in mapping then mapping[rand_int] ← mapping[last] else mapping[rand_int] ← last // 交換\n→ Step 8: Remove mapping[last] if exists // 清除已使用的最後索引映射\n→ Step 9: Decrement remaining ← remaining-1 // 更新剩餘數量\n→ Step 10: Convert idx to (i, j) via i ← idx // m, j ← idx % n // 轉為 2D 坐標\n→ Step 11: Return [i, j] // 返回翻轉的位置\n\nReset() method:\n→ Step 12: Clear mapping // 清空映射表\n→ Step 13: Set remaining ← total // 重置剩餘數量\n→ Step 14: End // 方法結束\n\nBut need to produce each step line with explanation.\n\nAlso use Decision maybe not needed.\n\nLet's format.\n\nMake sure each line: `虛擬碼步驟 // 解釋`.\n\nAlso need to start with Start and End. Provide separate for each method? We could show within the class: but we can show Start for constructor, flip, reset. We'll use separate flows.\n\nWe'll output overall.\n\nLet's craft.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: Set total ← m * n // 計算矩陣的總格數\n→ Step 2: Set remaining ← total // 初始時所有格子皆未翻轉\n→ Step 3: Initialize mapping as empty map // 用於動態映射已交換的索引\n\n// =====================  Flip() 方法 =====================\n→ Step 4: rand_idx ← RandomInt(0, remaining - 1) // 隨機取得一個可用索引\n→ Step 5: If rand_idx in mapping then idx ← mapping[rand_idx] else idx ← rand_idx // 得到實際一維索引\n→ Step 6: last_idx ← remaining - 1 // 取最後一個尚未翻轉的位置\n→ Step 7: If last_idx in mapping then mapping[rand_idx] ← mapping[last_idx] else mapping[rand_idx] ← last_idx // 將選中的位置與最後一個位置交換\n→ Step 8: If last_idx in mapping then Remove mapping[last_idx] // 清除已使用的最後索引映射\n→ Step 9: remaining ← remaining - 1 // 更新剩餘未翻轉格子數\n→ Step 10: i ← idx / n // 轉換為行坐標\n→ Step 11: j ← idx % n // 轉換為列坐標\n→ Step 12: Return [i, j] // 返回翻轉後的格子位置\n\n// =====================  Reset() 方法 =====================\n→ Step 13: Clear mapping // 清空所有映射\n→ Step 14: remaining ← total // 重置剩餘格子數\n→ Step 15: End // 方法結束\n```",
      "generated_code": "import sys\nimport ast\nimport random\nimport json\n\nclass Solution:\n    def __init__(self, n_rows: int, n_cols: int):\n        self.rows = n_rows\n        self.cols = n_cols\n        self.total = n_rows * n_cols          # 仍未翻轉的格子總數\n        self.flipped = {}                     # 用於映射已交換的索引\n\n    def flip(self) -> list:\n        # 隨機挑選一個在 [0, self.total-1] 的索引\n        r = random.randint(0, self.total - 1)\n        # 取得實際的格子索引，若已映射則取映射值\n        idx = self.flipped.get(r, r)\n        # 將此索引從可用池中移除\n        self.total -= 1\n        # 把最後一個可用索引映射到 r，若已映射則取其映射值\n        self.flipped[r] = self.flipped.get(self.total, self.total)\n        # 轉換成 (row, col)\n        return [idx // self.cols, idx % self.cols]\n\n    def reset(self) -> None:\n        # 重設為全零矩陣\n        self.total = self.rows * self.cols\n        self.flipped.clear()\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read().strip()\n    if not input_data:\n        sys.exit()\n    # 解析類似 ['Solution', 'flip', ...], [[3,1], [], ...] 的輸入\n    ops, args_list = ast.literal_eval('[' + input_data + ']')\n    obj = None\n    output = []\n    for op, args in zip(ops, args_list):\n        if op == 'Solution':\n            obj = Solution(args[0], args[1])\n            output.append(None)\n        elif op == 'flip':\n            output.append(obj.flip())\n        elif op == 'reset':\n            obj.reset()\n            output.append(None)\n    # 以 JSON 形式輸出，使用無空格格式\n    print(json.dumps(output, separators=(',', ':')))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"flip\", \"flip\", \"flip\", \"reset\", \"flip\"], [[3, 1], [], [], [], [], []]",
          "expected_output": "[null, [1,0], [2,0], [0,0], null, [2,0]]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[1,0],[2,0],[0,0],null,[2,0]]'\nGot (Norm):      '[null,[0,0],[2,0],[1,0],null,[2,0]]'\n--- (Raw) ---\nRaw Expected: '[null, [1,0], [2,0], [0,0], null, [2,0]]'\nRaw Got:      '[null,[0,0],[2,0],[1,0],null,[2,0]]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode45.json",
    "problem_index_in_file": 0,
    "title": "Jump Game II",
    "description_snippet": "You are given a 0-indexed array of integers nums of length n. You are initially positioned at index ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step. We need algorithm: greedy or BFS. Let's do greedy: maintain current reach, farthest. Count jumps. Standard solution.\n\nPseudo:\nStart\n→ Step 1: Read nums array and n // input\n→ Step 2: If n==1 → return 0 // already at last\n→ Step 3: initialize jumps=0, currentEnd=0, farthest=0 // 跳数, 当前能到的最远索引\n→ Decision: While currentEnd < n-1? // still need jumps\n    → Step 4: For i from currentEnd+1 to currentEnd+nums[i]? Actually typical: for i=currentEnd+1; i <= currentEnd + nums[i]? Let's do for i=currentEnd+1; i <= currentEnd + nums[i]? Hmm need loop over indices within current range. But easier: in loop we iterate i from currentEnd+1 to currentEnd + nums[i]? Actually we maintain farthest = max(farthest, i+nums[i]) for each i in [currentEnd+1, currentEnd+nums[i]]? Standard: for i=currentEnd+1 to n-1? But that's O(n^2). Usually we use for i=currentEnd+1; i <= farthest? Let's recall algorithm: For i from 0 to n-2: update farthest = max(farthest, i+nums[i]); if i==currentEnd: jumps++, currentEnd = farthest. That works. We'll produce step lines accordingly.\n\nSo:\n→ Step 5: For i from 0 to n-2 // iterate through array except last\n    → Step 6: Update farthest = max(farthest, i + nums[i]) // 记录能到的最远\n    → Decision: If i == currentEnd? // reached end of current jump range\n        Yes → Step 7: jumps++ // need another jump\n        → Step 8: currentEnd = farthest // set new range end\nEnd loop\n→ Step 9: Return jumps // minimal jumps\n\nEdge: n==1 return 0.\n\nLet's produce virtual code lines accordingly. Ensure we use arrow structure.\n\nWe'll incorporate decision lines and comments. Let's produce.\n\nRemember no actual code. Provide virtual code lines.\n\nLet's output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取陣列 nums 與長度 n // 取得輸入資料  \n→ Decision: 如果 n == 1? // 若陣列只有一個元素  \n Yes → Step 2: 回傳 0 // 已在終點，無需跳躍  \n No  → Step 3: 初始化 jumps = 0, currentEnd = 0, farthest = 0 // 跳數、目前能到達最遠點、已知最遠點  \n→ Step 4: 從 i = 0 開始，直到 i = n-2 // 只需要遍歷到倒數第二個位置  \n → Step 5: 更新 farthest = max(farthest, i + nums[i]) // 以此索引計算可達最遠位置  \n → Decision: 如果 i == currentEnd? // 到達目前跳躍範圍末端  \n  Yes → Step 6: jumps++ // 需要再跳一次  \n   → Step 7: currentEnd = farthest // 更新新的跳躍範圍終點  \n→ Step 8: 回傳 jumps // 完成，輸出最小跳躍次數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def jump(self, nums):\n        n = len(nums)\n        if n <= 1:\n            return 0\n\n        jumps = 0\n        current_end = 0\n        farthest = 0\n\n        for i in range(n - 1):\n            farthest = max(farthest, i + nums[i])\n            if i == current_end:\n                jumps += 1\n                current_end = farthest\n\n        return jumps\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 允許輸入形如 \"nums = [2,3,1,1,4]\" 或僅 \"[2,3,1,1,4]\"\n    if 'nums' in data.lower():\n        _, arr_str = data.split('=', 1)\n        arr_str = arr_str.strip()\n    else:\n        arr_str = data\n\n    nums = ast.literal_eval(arr_str)\n    result = Solution().jump(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,3,1,1,4]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "nums = [2,3,0,1,4]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode495.json",
    "problem_index_in_file": 0,
    "title": "Teemo Attacking",
    "description_snippet": "Our hero Teemo is attacking an enemy Ashe with poison attacks! When Teemo attacks Ashe, Ashe gets po...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps to solve problem. Steps: Start, iterate array, keep last attack time, accumulate poison seconds. For each attack, compute new interval start. If overlapping previous interval, add only non-overlap. Use currentEnd. Pseudocode. Provide each line with // explanation. Use arrow syntax.\n\nLet's craft. We'll start with Start. Then set total = 0. Set last_end = -inf. Loop over timeSeries. For each attack time t: if t > last_end: add duration. else add max(0, (t + duration - 1) - last_end). Update last_end = t + duration - 1. End loop. End.\n\nReturn total. Use pseudo. Provide explanations.\n\nOk. Let's write.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ total = 0 // 用來累積 Ashe 被中毒的總秒數  \n→ lastEnd = -1 // 追蹤上一個攻擊結束的時間（-1 表示還沒開始）  \n→ Loop i in 0..timeSeries.length-1 // 逐一處理每一次 Teemo 的攻擊  \n  → t = timeSeries[i] // 取出當前攻擊的秒數  \n  → newEnd = t + duration - 1 // 計算此攻擊後 poison 會結束的時間  \n  → Decision: t > lastEnd? // 檢查是否與前一次 poison 重疊  \n    Yes → total += duration // 沒重疊，整個持續時間都算  \n    No → Decision: newEnd > lastEnd? // 有重疊，只有多出部分算  \n      Yes → total += newEnd - lastEnd // 加上未被計算的秒數  \n      No → // 這種情況表示新攻擊在前一次結束前發生，且持續時間不超前，無需額外計算  \n  → lastEnd = newEnd // 更新最後一次 poison 的結束時間  \nEnd // Loop 完成  \n→ Return total // 回傳 Ashe 被中毒的總秒數",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def findPoisonedDuration(self, timeSeries, duration):\n        \"\"\"計算 Ashe 被中毒的總秒數。\"\"\"\n        if not timeSeries:\n            return 0\n        total = 0\n        # 對於前 n-1 個攻擊，計算與下一次攻擊的重疊部分\n        for i in range(len(timeSeries) - 1):\n            diff = timeSeries[i + 1] - timeSeries[i]\n            total += min(diff, duration)\n        # 最後一次攻擊一定會持續整個 duration\n        total += duration\n        return total\n\ndef parse_input(data: str):\n    \"\"\"從輸入字串中提取 timeSeries 和 duration。\"\"\"\n    # 找到 timeSeries 的清單\n    ts_match = re.search(r\"timeSeries\\s*=\\s*(\\[[^\\]]*\\])\", data)\n    dur_match = re.search(r\"duration\\s*=\\s*(-?\\d+)\", data)\n    if not ts_match or not dur_match:\n        raise ValueError(\"輸入格式不正確\")\n    timeSeries = ast.literal_eval(ts_match.group(1))\n    duration = int(dur_match.group(1))\n    return timeSeries, duration\n\ndef main():\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n    timeSeries, duration = parse_input(raw_input)\n    sol = Solution()\n    result = sol.findPoisonedDuration(timeSeries, duration)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "timeSeries = [1,4], duration = 2",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "timeSeries = [1,2], duration = 2",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode424.json",
    "problem_index_in_file": 0,
    "title": "Longest Repeating Character Replacement",
    "description_snippet": "You are given a string s and an integer k. You can choose any character of the string and change it ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step to solve the problem: given string s and integer k, find maximum length of substring where we can change at most k characters to make all same letter. Standard sliding window with frequency count. We'll produce steps line by line with explanation.\n\nNeed to adhere to output format: each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision:, arrow, etc.\n\nWe need to think about algorithm: sliding window with char frequencies, maintain window size, max frequency inside window. If window size - maxFreq > k, shrink window. Keep track of maxLen.\n\nWe'll produce steps:\n\nStart\n→ Step 1: 初始化左指標 left = 0, maxLen = 0, freq[26] = 0 // 初始化指標與頻率表\n→ Step 2: 迭代右指標 right 從 0 到 s.length-1 // 遍歷字符串\n    → Step 3: 更新 freq[ s[right] - 'A' ]++ // 增加右指標字符頻率\n    → Step 4: 計算 maxFreq 在當前窗口 // 尋找窗口內最高頻字符\n    → Decision: 若 windowSize - maxFreq > k? // 判斷是否需要縮小窗口\n        Yes → Step 5: 減少左指標字符頻率 freq[ s[left] - 'A' ]-- // 縮小窗口\n            → Step 6: left++ // 左指標向右移動\n        No  → Step 7: 更新 maxLen = max(maxLen, right-left+1) // 更新最長長度\nEnd\n\nWe need to express steps in virtual code lines. Also maybe separate frequency update and maxFreq calculation.\n\nNeed to be precise: Each line with arrow and explanation. Use \"Decision:\" with Yes → and No →.\n\nWe also need to mention we recompute maxFreq inside loop each time; we could store but we recompute to keep simple.\n\nLet's write.\n\nImportant: \"虛擬碼步驟\" part: we can use pseudo language: \"→ Step 1: ...\".\n\nWe must keep each line one virtual code step.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: left ← 0, maxLen ← 0, freq[26] ← 0 // 初始化左指標、最大長度與頻率表  \n→ Step 2: for right from 0 to s.length-1 do // 逐字遍歷字串  \n    → Step 3: idx ← s[right] - 'A' // 將字符轉換為 0~25 的索引  \n    → Step 4: freq[idx] ← freq[idx] + 1 // 更新右指標字符的頻率  \n    → Step 5: maxFreq ← 0 // 初始化窗口內最高頻字符頻率  \n    → Decision: for i from 0 to 25 do  \n        Yes → Step 6: if freq[i] > maxFreq then maxFreq ← freq[i] // 找到窗口內最高頻字符  \n    → Decision: (right - left + 1) - maxFreq > k ? // 判斷窗口是否需要縮小  \n        Yes → Step 7: freq[s[left] - 'A'] ← freq[s[left] - 'A'] - 1 // 移除左指標字符  \n            → Step 8: left ← left + 1 // 左指標右移  \n        No → Step 9: maxLen ← max(maxLen, right - left + 1) // 更新最大長度  \nEnd // 程式執行結束。",
      "generated_code": "import sys\nimport re\n\ndef character_replacement(s: str, k: int) -> int:\n    \"\"\"Return longest substring that can be made of the same letter\n    with at most k changes.\"\"\"\n    freq = [0] * 26          # frequency of each letter in current window\n    left = 0                 # left boundary of the sliding window\n    max_len = 0\n    max_freq = 0             # max frequency of any letter in current window\n\n    for right, ch in enumerate(s):\n        idx = ord(ch) - ord('A')\n        freq[idx] += 1\n        max_freq = max(max_freq, freq[idx])\n\n        # If more than k characters need to be changed, shrink window\n        while (right - left + 1) - max_freq > k:\n            freq[ord(s[left]) - ord('A')] -= 1\n            left += 1\n\n        max_len = max(max_len, right - left + 1)\n\n    return max_len\n\ndef parse_input(data: str):\n    \"\"\"Parse input in the form `s = \"ABAB\", k = 2` or similar.\"\"\"\n    # Try to find quoted string and integer\n    m = re.search(r's\\s*=\\s*\"([^\"]+)\"\\s*,\\s*k\\s*=\\s*(\\d+)', data)\n    if not m:\n        # Try without quotes\n        m = re.search(r's\\s*=\\s*([A-Z]+)\\s*,\\s*k\\s*=\\s*(\\d+)', data)\n    if m:\n        s = m.group(1)\n        k = int(m.group(2))\n    else:\n        # Fallback: split by whitespace/comma\n        parts = re.sub(r'[,\\s]+', ' ', data.strip()).split()\n        if len(parts) >= 2:\n            s, k = parts[0], int(parts[1])\n        else:\n            raise ValueError(\"Invalid input format\")\n    return s, k\n\nif __name__ == \"__main__\":\n    raw_data = sys.stdin.read()\n    s, k = parse_input(raw_data)\n    result = character_replacement(s, k)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"ABAB\", k = 2",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "s = \"AABABBA\", k = 1",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode58.json",
    "problem_index_in_file": 0,
    "title": "Length of Last Word",
    "description_snippet": "Given a string s consisting of words and spaces, return the length of the last word in the string.\n\n...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line, with arrow, decision, etc. Provide explanation after each line. The problem: Given a string s, return length of last word. We need to handle spaces, etc.\n\nWe produce virtual pseudocode: Start, Step: trim trailing spaces, or iterate from end, etc. Provide decision and steps. Ensure each line has \"虛擬碼步驟\" plus space plus \"// 解釋/說明\".\n\nWe must not output actual code. Just pseudo steps. Use arrows and decisions. We need to be careful to cover logic: find last word length.\n\nSimplify: Use pointer from end, skip spaces, count until space or start. Provide steps: Start, Step 1: set index to s.length - 1, Step 2: while index >=0 and s[index] == ' ' skip, Step 3: if index <0 return 0, Step 4: initialize count =0, Step5: while index>=0 and s[index] != ' ' increment count and index--, Step6: return count. Then End.\n\nWe'll need decision points maybe: While loop conditions are decisions.\n\nWrite each line with \"→\" arrow from previous step, or \"Decision:\" lines for loops. Provide explanation.\n\nMake sure to include \"Start // 程式開始執行\" and \"End // 程式執行結束\".\n\nLet's craft the lines:\n\nStart // 程式開始執行\n→ Step 1: index ← length of s - 1 // 設定索引指向字串最後一個字元\n→ Decision: 是否為空字串? // 若 s 為空則不需要處理\n    Yes → Step 2: return 0 // 空字串，最後一個單詞長度為 0\n    No  → Step 3: index ← length of s - 1 // (重複) 以確保 index 正確\n→ Decision: s[index] 為空白字元? // 先跳過尾部空白\n    Yes → Step 4: index ← index - 1 // 移動到前一個字元\n    No  → No → Step 5: // 進入下一決策\n→ Decision: index < 0? // 如果已經到達字串開頭，表示沒有單詞\n    Yes → Step 6: return 0 // 沒有非空白字符，長度為 0\n    No  → Step 7: count ← 0 // 初始化計數\n→ Decision: s[index] 不是空白? // 計算最後一個單詞長度\n    Yes → Step 8: count ← count + 1 // 進行計數\n    No  → No → Step 9: // 結束計數\n→ Decision: index > 0? // 若還有字元需繼續\n    Yes → Step 10: index ← index - 1 // 往前移動\n    No  → No → Step 11: // 循環結束\n→ Decision: index < 0? // 檢查是否已經到頭\n    Yes → No → Step 12: // 繼續計數\n    No  → No → Step 13: // 返回\n→ Step 14: return count // 回傳最後一個單詞長度\nEnd // 程式執行結束\n\nBut above has too many decisions and steps. We can simplify.\n\nBetter: Start\n→ Step 1: index ← length of s - 1\n→ Decision: index < 0? // empty string\n    Yes → Step 2: return 0\n    No  → Step 3: // proceed\n→ Decision: s[index] == ' '?\n    Yes → Step 4: index ← index - 1; (loop until not space) -> we need loop structure. Use Decision with Yes arrow repeating step. For simplicity we can use a while loop concept: Decision: s[index] == ' '? Yes → Step 5: index ← index - 1; No → Step 6: // continue\nWe might need to indicate loop by decision repeated. But guidelines only allow decision arrow to subsequent steps. We can indicate a loop by having the decision's Yes arrow point back to itself? Not exactly. We can show \"→ Decision: ...\" then inside arrow we can go to next step which again is a Decision. It's okay.\n\nLet's craft concise steps.\n\nSimplify:\n\nStart // 程式開始執行\n→ Step 1: index ← length of s - 1 // 初始化索引指向字串最後一個字元\n→ Decision: index < 0? // 判斷字串是否為空\n    Yes → Step 2: return 0 // 空字串，最後單詞長度為 0\n    No  → Step 3: // 進行後續處理\n→ Decision: s[index] == ' ' // 跳過尾部空格\n    Yes → Step 4: index ← index - 1 // 向前移動\n    No  → No → Step 5: // 已到達最後單詞的末尾\n→ Decision: index < 0? // 若已到頭，表示沒有單詞\n    Yes → Step 6: return 0 // 無非空白字符\n    No  → Step 7: count ← 0 // 初始化計數器\n→ Decision: s[index] != ' ' // 開始計算最後單詞長度\n    Yes → Step 8: count ← count + 1 // 計數\n    No  → No → Step 9: // 結束計數\n→ Decision: index > 0? // 若還有字元需要繼續\n    Yes → Step 10: index ← index - 1 // 向前移動\n    No  → No → Step 11: // 循環結束\n→ Decision: index >= 0? // 檢查是否還有字元\n    Yes → No → Step 12: // 繼續步驟 8\n    No  → No → Step 13: // 回傳計數\n→ Step 14: return count // 回傳最後單詞長度\nEnd // 程式執行結束\n\nBut this is messy. Let's produce simpler, clearer pseudocode with while loops described.\n\nWe can use Decision: While s[index] == ' '?\n\nMaybe we can express loop as:\n\n→ Decision: s[index] == ' ' // 跳過尾部空格\n    Yes → index ← index - 1 // 移動至前一個字符\n    No  → // 進入計算步驟\n\nBut that decision only executes once. We need to loop. We could use:\n\n→ Decision: s[index] == ' '\n    Yes → index ← index - 1 → Decision: s[index] == ' ' // repeat\n    No  → // proceed\n\nThat repeats until condition false.\n\nSimilarly for counting: While s[index] != ' '\n\nLet's craft:\n\nStart\n→ Step 1: index ← length of s - 1\n→ Decision: index < 0?\n    Yes → Step 2: return 0\n    No  → // continue\n→ Decision: s[index] == ' '\n    Yes → index ← index - 1 → Decision: s[index] == ' ' // repeat\n    No  → // proceed\n→ Decision: index < 0?\n    Yes → Step 3: return 0\n    No  → // proceed\n→ Step 4: count ← 0\n→ Decision: s[index] != ' '\n    Yes → count ← count + 1; index ← index - 1 → Decision: s[index] != ' ' // repeat\n    No  → // finished counting\n→ Step 5: return count\nEnd\n\nThis seems good.\n\nLet's format each line with arrow and explanation. Ensure each line has \"虛擬碼步驟\" then space then \"// 解釋\". Use arrow \"→\" at start of each step except Start and End.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: index ← length of s - 1 // 初始化索引指向字串最後一個字元\n→ Decision: index < 0? // 判斷字串是否為空\n    Yes → Step 2: return 0 // 空字串，最後單詞長度為 0\n    No  → // 進一步處理\n→ Decision: s[index] == ' ' // 跳過尾部空格\n    Yes → index ← index - 1 → Decision: s[index] == ' ' // 若仍為空格，重複跳過\n    No  → // 已到達最後單詞的末尾\n→ Decision: index < 0? // 若已到頭，表示沒有非空白字符\n    Yes → Step 3: return 0 // 無單詞，長度為 0\n    No  → // 進入計算步驟\n→ Step 4: count ← 0 // 初始化計數器\n→ Decision: s[index] != ' ' // 開始計算最後單詞長度\n    Yes → count ← count + 1; index ← index - 1 → Decision: s[index] != ' ' // 若前面仍非空格，繼續計算\n    No  → // 已到達單詞開頭或字串開頭\n→ Step 5: return count // 回傳最後單詞長度\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef length_of_last_word(s: str) -> int:\n    \"\"\"\n    Return the length of the last word in the string s.\n    A word is a maximal substring of non-space characters.\n    \"\"\"\n    s = s.strip()                 # 去除首尾空格\n    words = s.split()             # 以任意空白分割\n    return len(words[-1]) if words else 0\n\ndef main() -> None:\n    \"\"\"\n    主程序：從標準輸入讀取資料，解析字串，計算並輸出最後一個單詞的長度。\n    \"\"\"\n    data = sys.stdin.read()  # 讀取所有輸入\n    # 從 's = \"...\"' 形式的輸入中提取引號內的內容\n    match = re.search(r'\"([^\"]*)\"', data)\n    if match:\n        s = match.group(1)\n    else:\n        # 若沒有引號，直接使用整個輸入作為字串\n        s = data.strip()\n    result = length_of_last_word(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"Hello World\"",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "s = \"   fly me   to   the moon  \"",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "s = \"luffy is still joyboy\"",
          "expected_output": "6",
          "success": true,
          "output": "6"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode33.json",
    "problem_index_in_file": 0,
    "title": "Search in Rotated Sorted Array",
    "description_snippet": "There is an integer array nums sorted in ascending order (with distinct values).\n\nPrior to being pas...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for searching in a rotated sorted array using binary search. Output each line with \"虛擬碼步驟 // 解釋\". Must use arrows etc.\n\nThe algorithm: Start, set left=0, right=nums.length-1. While left <= right: mid = (left+right)/2. If nums[mid]==target return mid. Determine if left half sorted: if nums[left] <= nums[mid]. If target in left half (nums[left] <= target < nums[mid]) right=mid-1 else left=mid+1. Else right half sorted: if target in right half (nums[mid] < target <= nums[right]) left=mid+1 else right=mid-1. After loop return -1. End.\n\nAlso handle case target not found.\n\nWe need each line \"虛擬碼步驟\" plus comment. Use arrow for transitions. Use Start and End. For Decision: etc.\n\nLet's craft. Ensure each line includes comment after //.\n\nWe should include steps: Start, → Step: initialize left/right, → While Decision: while left <= right? We need nested decisions: While left <= right? Use Decision: if left <= right? Then Yes → ... No → End? But we can express loop as repeated until condition false. We'll use Decision: left <= right? Yes → ... No → End.\n\nWithin loop: Step mid, Step compare, Decision: target==nums[mid]? Yes → return mid; No → Decision: left <= mid? or check sorted left half? Use Decision: nums[left] <= nums[mid]? Yes → Decision: target between left and mid? Yes → right=mid-1; No → left=mid+1; No → (right half sorted) Decision: target between mid and right? Yes → left=mid+1; No → right=mid-1.\n\nFinally after loop return -1. End.\n\nLet's format.\n\nAlso might need to handle array length etc.\n\nWe need to produce each line with step description and comment. We should also include return statements.\n\nAlso need to use proper Chinese comments.\n\nLet's produce.\n\nNote: The arrow symbol \"→\" before each step.\n\nLet's output as:\n\nStart // 程式開始執行\n\n→ Step 1: left ← 0, right ← nums.length - 1 // 初始化左右指標\n\n→ Decision: left <= right? // 判斷是否仍有範圍可搜尋\n\n    Yes → Step 2: mid ← (left + right) / 2 // 計算中間索引\n\n    Yes → Decision: nums[mid] == target? // 檢查是否找到目標\n\n        Yes → Step 3: return mid // 找到目標，回傳索引\n\n        No  → Decision: nums[left] <= nums[mid]? // 判斷左半段是否有序\n\n            Yes → Decision: nums[left] <= target < nums[mid]? // 目標是否在左半段\n\n                Yes → Step 4: right ← mid - 1 // 目標在左半段，縮小右邊界\n\n                No  → Step 5: left ← mid + 1 // 目標不在左半段，往右搜尋\n\n            No  → Decision: nums[mid] < target <= nums[right]? // 目標是否在右半段\n\n                Yes → Step 6: left ← mid + 1 // 目標在右半段，縮小左邊界\n\n                No  → Step 7: right ← mid - 1 // 目標不在右半段，往左搜尋\n\n    No  → End // 退出迴圈，未找到目標\n\n→ Step 8: return -1 // 目標不存在，回傳 -1\n\nEnd // 程式結束\n\nBut need \"End\" after loop, but we might keep End after return -1. Ensure correct ordering: after loop we exit, we should return -1. The End marks program end.\n\nNeed to use indentation maybe not necessary.\n\nLet's output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: left ← 0, right ← nums.length - 1 // 初始化左右指標  \n→ Decision: left <= right? // 判斷是否仍有範圍可搜尋  \n    Yes → Step 2: mid ← (left + right) / 2 // 計算中間索引  \n    Yes → Decision: nums[mid] == target? // 檢查是否找到目標  \n        Yes → Step 3: return mid // 找到目標，回傳索引  \n        No → Decision: nums[left] <= nums[mid]? // 判斷左半段是否有序  \n            Yes → Decision: nums[left] <= target < nums[mid]? // 目標是否在左半段  \n                Yes → Step 4: right ← mid - 1 // 目標在左半段，縮小右邊界  \n                No → Step 5: left ← mid + 1 // 目標不在左半段，往右搜尋  \n            No → Decision: nums[mid] < target <= nums[right]? // 目標是否在右半段  \n                Yes → Step 6: left ← mid + 1 // 目標在右半段，縮小左邊界  \n                No → Step 7: right ← mid - 1 // 目標不在右半段，往左搜尋  \n    No → End // 退出迴圈，未找到目標  \n→ Step 8: return -1 // 目標不存在，回傳 -1  \nEnd // 程式結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def search(self, nums, target):\n        \"\"\"在可能被左旋轉的升序陣列中搜尋 target，若存在回傳索引，否則回傳 -1。\"\"\"\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            # 判斷哪一半有序\n            if nums[left] <= nums[mid]:\n                # 左半段有序\n                if nums[left] <= target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            else:\n                # 右半段有序\n                if nums[mid] < target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n        return -1\n\ndef main():\n    data = sys.stdin.read()\n    if not data.strip():\n        return\n    # 從輸入字串中抽取 nums 列表與 target 整數\n    nums_match = re.search(r'nums\\s*=\\s*(\\[.*?\\])', data, re.DOTALL)\n    target_match = re.search(r'target\\s*=\\s*(-?\\d+)', data)\n    nums = eval(nums_match.group(1)) if nums_match else []\n    target = int(target_match.group(1)) if target_match else 0\n\n    sol = Solution()\n    result = sol.search(nums, target)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [4,5,6,7,0,1,2], target = 0",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "nums = [4,5,6,7,0,1,2], target = 3",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        },
        {
          "example_index": 2,
          "input": "nums = [1], target = 0",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode60.json",
    "problem_index_in_file": 0,
    "title": "Permutation Sequence",
    "description_snippet": "The set [1, 2, 3, ..., n] contains a total of n! unique permutations.\n\nBy listing and labeling all o...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. The algorithm: find kth permutation of numbers 1..n. Approach: compute factorial list, adjust k-1 index. Build result. Use loop. Steps: Start, compute factorial list, adjust k-1, create available numbers list, loop n times: compute index, select number, append, remove, decrement factorial. End.\n\nWe must output each line: virtual code step + \" // 解釋/說明\". Use arrows. Ensure each step line has format. No actual code. Use pseudo.\n\nLet's create:\n\nStart // 程式開始執行\n→ Step 1: 初始化 k ← k - 1 // 把 k 轉換成 0 基索引\n→ Step 2: 建立 numbers 列表 [1, 2, …, n] // 可用的數字集合\n→ Step 3: 計算 factorials 陣列，fact[0]=1, fact[i]=i*fact[i-1] // 前 n-1 個階乘\n→ Decision: n > 0? // 確認 n 是否為正\n    Yes → Loop 1: 對 i 從 n 到 1 逐步迭代 // 逐位選擇\n        → Step 4: index ← k / fact[i-1] // 取得本位的索引\n        → Step 5: result += numbers[index] // 把對應數字加到結果\n        → Step 6: 刪除 numbers[index] // 移除已使用的數字\n        → Step 7: k ← k % fact[i-1] // 更新剩餘索引\n        → Step 8: fact[i-1] ← fact[i-1] / i // 準備下一位的階乘\n    No  → Step 9: result ← \"\" // n 為 0 時，返回空字符串\nEnd // 程式執行結束\n\nBut we need to use arrow structure maybe. Use \"→\" arrow before each step, indent for Decision. Use \"Yes →\" \"No →\". Also the loop maybe represented as \"Loop:\". Provide explanation.\n\nLet's structure:\n\nStart // 程式開始執行\n→ Step 1: k ← k - 1 // 把 k 轉成 0 基索引，方便計算\n→ Step 2: numbers ← [1, 2, …, n] // 建立可用數字清單\n→ Step 3: fact[0] ← 1 // 初始化階乘陣列\n→ Step 4: 對 i 從 1 到 n-1 迴圈 fact[i] ← i * fact[i-1] // 計算階乘\n→ Decision: n > 0? // 是否有數字可排列\n    Yes → Loop: 對 pos 從 n 到 1 迭代\n        → Step 5: index ← k / fact[pos-1] // 取出本位索引\n        → Step 6: result ← result + numbers[index] // 加入對應數字\n        → Step 7: 刪除 numbers[index] // 刪除已選擇的數字\n        → Step 8: k ← k % fact[pos-1] // 更新剩餘索引\n        → Step 9: fact[pos-1] ← fact[pos-1] / pos // 為下一位準備階乘\n    No  → Step 10: result ← \"\" // n 為 0 時結果為空字串\nEnd // 程式執行結束\n\nBut we need to use arrow '→' before each line. For nested indent use spaces? The sample uses indentation. Provide same.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: k ← k - 1 // 把 k 轉成 0 基索引，方便之後除法計算\n→ Step 2: numbers ← [1, 2, …, n] // 建立可用數字的列表\n→ Step 3: fact[0] ← 1 // 初始化階乘陣列\n→ Step 4: 對 i 從 1 到 n-1 迴圈 fact[i] ← i * fact[i-1] // 計算 1! ~ (n-1)! 的階乘\n→ Decision: n > 0? // 確認 n 是否大於 0\n    Yes → Loop: 對 pos 從 n 到 1 逐步迭代\n        → Step 5: index ← k / fact[pos-1] // 取得本位應選擇的索引\n        → Step 6: result ← result + numbers[index] // 把對應的數字加到結果字串\n        → Step 7: 刪除 numbers[index] // 移除已使用的數字\n        → Step 8: k ← k % fact[pos-1] // 更新剩餘的 k 值\n        → Step 9: fact[pos-1] ← fact[pos-1] / pos // 為下一個位置準備階乘\n    No  → Step 10: result ← \"\" // 若 n 為 0，直接回傳空字串\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport math\n\nclass Solution:\n    def getPermutation(self, n: int, k: int) -> str:\n        # 建立 1 ~ n 的列表\n        numbers = list(range(1, n + 1))\n        k -= 1  # 轉成 0 基索引\n        result = []\n\n        # 逐位挑選\n        for i in range(n, 0, -1):\n            fact = math.factorial(i - 1)\n            index = k // fact\n            result.append(str(numbers.pop(index)))\n            k %= fact\n\n        return ''.join(result)\n\ndef main():\n    # 讀取整個輸入並擷取所有整數\n    data = sys.stdin.read()\n    nums = list(map(int, re.findall(r'\\d+', data)))\n    if len(nums) < 2:\n        return\n    n, k = nums[0], nums[1]\n\n    solution = Solution()\n    ans = solution.getPermutation(n, k)\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 3, k = 3",
          "expected_output": "\"213\"",
          "success": true,
          "output": "213"
        },
        {
          "example_index": 1,
          "input": "n = 4, k = 9",
          "expected_output": "\"2314\"",
          "success": true,
          "output": "2314"
        },
        {
          "example_index": 2,
          "input": "n = 3, k = 1",
          "expected_output": "\"123\"",
          "success": true,
          "output": "123"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode496.json",
    "problem_index_in_file": 0,
    "title": "Next Greater Element I",
    "description_snippet": "The next greater element of some element x in an array is the first greater element that is to the r...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step. Should follow format: Each line \"虛擬碼步驟 // 解釋\". Use arrows etc. Provide algorithm.\n\nWe need to compute next greater element for each element in nums1 using array nums2. Classic solution: Precompute next greater for each element in nums2 using stack. Then for each element in nums1, look up result. Complexity O(n). Provide pseudocode.\n\nWe must write each step line by line, with explanations.\n\nNeed to output virtual code only, no actual code. Use Start, End, Decision. Provide step lines.\n\nWe need to handle building a mapping from element to its next greater.\n\nAlso note arrays contain distinct integers.\n\nLet's produce:\n\nStart // program start\n\n→ Step 1: Initialize empty stack S // stack to hold indices\n\n→ Step 2: Initialize empty map M // map from number to its next greater element\n\n→ Decision: Iterate i from nums2.length-1 down to 0 // traverse from right\n\n    Yes → Step 3: While stack not empty and nums2[stack.top] <= nums2[i] → pop // remove smaller/equal\n\n    Yes → Step 4: If stack empty → M[nums2[i]] = -1 // no greater\n\n        No  → M[nums2[i]] = nums2[stack.top] // next greater is top of stack\n\n    Yes → Step 5: Push i onto stack // push current index\n\n→ Step 6: Initialize result array ans of size nums1.length // to store answers\n\n→ Decision: For each index k from 0 to nums1.length-1\n\n    Yes → Step 7: ans[k] = M[nums1[k]] // lookup mapped value\n\n→ End // finished\n\nWe need to include explanations. Use proper arrows. Use indentation with spaces? Use tab? In sample they used spaces for indentation under Decision: with Yes → etc.\n\nWe can follow similar.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空棧 S // 用於儲存可能為「下一個更大元素」的索引  \n→ Step 2: 初始化空映射 M // key: 數字, value: 其下一個更大元素 (或 -1)  \n→ Decision: 從 nums2 最右邊往左遍歷索引 i（i = nums2.length-1 下降至 0）  \n  Yes → Step 3: 當棧非空且 nums2[棧頂] ≤ nums2[i] 時，彈出棧頂 // 去除不可能的候選  \n  Yes → Step 4: 若棧為空，則 M[nums2[i]] = -1 // 無更大元素  \n   No  → M[nums2[i]] = nums2[棧頂] // 最靠右的更大元素即棧頂  \n  Yes → Step 5: 把 i 推入棧 S // 供左側元素使用  \n→ Step 6: 建立答案陣列 ans，長度為 nums1.length  \n→ Decision: 對於 nums1 的每個索引 k（k 從 0 到 nums1.length-1）  \n  Yes → Step 7: ans[k] = M[nums1[k]] // 直接從映射取得答案  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def nextGreaterElement(self, nums1, nums2):\n        stack = []\n        next_greater = {}\n        for num in nums2:\n            while stack and num > stack[-1]:\n                next_greater[stack.pop()] = num\n            stack.append(num)\n        return [next_greater.get(x, -1) for x in nums1]\n\ndef parse_input(text):\n    nums1_match = re.search(r'nums1\\s*=\\s*(\\[.*?\\])', text, re.S)\n    nums2_match = re.search(r'nums2\\s*=\\s*(\\[.*?\\])', text, re.S)\n    if not nums1_match or not nums2_match:\n        raise ValueError(\"Input format incorrect.\")\n    nums1 = ast.literal_eval(nums1_match.group(1))\n    nums2 = ast.literal_eval(nums2_match.group(1))\n    return nums1, nums2\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    nums1, nums2 = parse_input(data)\n    sol = Solution()\n    ans = sol.nextGreaterElement(nums1, nums2)\n    output = '[' + ','.join(map(str, ans)) + ']'\n    print(output)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums1 = [4,1,2], nums2 = [1,3,4,2]",
          "expected_output": "[-1,3,-1]",
          "success": true,
          "output": "[-1,3,-1]"
        },
        {
          "example_index": 1,
          "input": "nums1 = [2,4], nums2 = [1,2,3,4]",
          "expected_output": "[3,-1]",
          "success": true,
          "output": "[3,-1]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode93.json",
    "problem_index_in_file": 0,
    "title": "Restore IP Addresses",
    "description_snippet": "A valid IP address consists of exactly four integers separated by single dots. Each integer is betwe...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step for generating all valid IP addresses from a string of digits. We should include backtracking. Provide each line with virtual code and comment.\n\nWe need to output virtual code, no real code. Use arrows and Decision etc. Should be line by line. Use Start, End. Should produce algorithm.\n\nLet's craft.\n\nPlan:\n\n- Start\n- Define function generateIP(s)\n- Use result list\n- Define backtrack(start, parts)\n- Base: if parts==4 and start==len(s): add to result\n- If parts==4: return\n- For len in 1..3:\n    - if start+len > len(s): break\n    - segment = s[start:start+len]\n    - if segment has leading zero and len>1: continue\n    - if int(segment)<=255:\n        - append segment\n        - backtrack(start+len, parts+1)\n        - pop\n- Call backtrack(0,0)\n- Return result\n\nReturn.\n\nWe need to show each step with explanation.\n\nLet's produce each line.\n\nUse \"→\" arrow for steps. Use indentation for nested. For decisions use Decision: ... Yes→... No→...\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義輸入字串 s 以及空列表 result // 用於儲存所有有效 IP 地址  \n→ Step 2: 定義遞迴函式 backtrack(start, parts) // start: 當前字串索引, parts: 已經切出的段數  \n→ Decision: 如果 parts == 4 且 start == len(s)？ // 檢查是否已切割完畢且已經有四段  \n  Yes → Step 3: 將 '.'.join(parts) 加入 result // 將切好的四段組成 IP 並儲存  \n  No → Decision: 如果 parts == 4？ // 若已切四段但還有剩餘字元，則不合法  \n   Yes → Step 4: return // 結束此路徑  \n   No → Decision: 從 1 到 3 開始試取段長？ // 嘗試取 1, 2, 3 個字元作為下一段  \n    Yes → Step 5: segment = s[start:start+len] // 取子字串作為候選段  \n     Decision: 取出的字串長度 > 1 且以 '0' 開頭？ // 檢查前導零  \n      Yes → Step 6: continue // 前導零且長度 >1，跳過此長度  \n      No → Decision: int(segment) <= 255？ // 檢查數值是否在 0~255 之間  \n       Yes → Step 7: parts.append(segment) // 將合法段加入 parts  \n        Step 8: backtrack(start+len, parts+1) // 進一步遞迴處理剩餘字串  \n        Step 9: parts.pop() // 回溯，移除剛剛加入的段  \n       No → Step 10: continue // 數值超過 255，跳過此長度  \n→ Step 11: 呼叫 backtrack(0, 0) // 從字串開始處遞迴  \n→ Step 12: 回傳 result // 返回所有符合條件的 IP 地址  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport json\n\nclass Solution:\n    def restoreIpAddresses(self, s: str):\n        \"\"\"Return all valid IP addresses that can be formed from the digit string s.\"\"\"\n        res = []\n\n        def backtrack(start: int, path: list):\n            # 若已經走到字串末尾且已經切成四段，則加入結果\n            if start == len(s) and len(path) == 4:\n                res.append('.'.join(path))\n                return\n            # 若段數已達四段但尚未遍歷完字串，則不合法\n            if len(path) >= 4:\n                return\n\n            # 嘗試從 1 到 3 位數切段\n            for length in range(1, 4):\n                if start + length > len(s):\n                    break\n                part = s[start:start + length]\n                # 前導零且長度 >1 或數值 > 255 都不合法\n                if (part.startswith('0') and len(part) > 1) or int(part) > 255:\n                    continue\n                # 遞迴處理剩餘字串\n                backtrack(start + length, path + [part])\n\n        backtrack(0, [])\n        return res\n\nif __name__ == \"__main__\":\n    # 讀取所有輸入並提取第一個數字序列\n    raw_input = sys.stdin.read().strip()\n    digits = re.findall(r'\\d+', raw_input)\n    s = digits[0] if digits else ''\n\n    solution = Solution()\n    result = solution.restoreIpAddresses(s)\n\n    # 以 JSON 格式輸出，符合範例中無空格的表達\n    print(json.dumps(result))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"25525511135\"",
          "expected_output": "[\"255.255.11.135\",\"255.255.111.35\"]",
          "success": true,
          "output": "[\"255.255.11.135\", \"255.255.111.35\"]"
        },
        {
          "example_index": 1,
          "input": "s = \"0000\"",
          "expected_output": "[\"0.0.0.0\"]",
          "success": true,
          "output": "[\"0.0.0.0\"]"
        },
        {
          "example_index": 2,
          "input": "s = \"101023\"",
          "expected_output": "[\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"]",
          "success": true,
          "output": "[\"1.0.10.23\", \"1.0.102.3\", \"10.1.0.23\", \"10.10.2.3\", \"101.0.2.3\"]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode393.json",
    "problem_index_in_file": 0,
    "title": "UTF-8 Validation",
    "description_snippet": "Given an integer array data representing the data, return whether it is a valid UTF-8 encoding (i.e....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps line by line, each with explanation comment. The requirement: not actual code, just virtual steps. Should use arrows, Decision, Start End. Need to process array of integers, interpret least significant 8 bits, determine if sequence is valid UTF-8.\n\nWe will produce algorithm: iterate over array with index. For each byte, determine if start of character, count leading ones. If 0 -> 1-byte. If count 1 or >4 invalid. For count>1, then expect count-1 following bytes with pattern 10xxxxxx. If any mismatch, return false. After loop, return true.\n\nWe'll produce pseudo steps.\n\nWe need each line: virtual code step, space, // explanation.\n\nInclude decision blocks. Use Start, End.\n\nLet's produce steps like:\n\nStart // 程式開始\n\n→ Step 1: Initialize index i = 0 // 將索引設為 0\n\n→ Decision: i < data.length? // 是否還有字節未處理\n\n    Yes → Step 2: current = data[i] & 0xFF // 取得當前字節的低8位\n\n    Yes → Step 3: ones = countLeadingOnes(current) // 計算首位連續1的數量\n\n    Yes → Decision: ones == 0? // 1字節字符判斷\n\n        Yes → Step 4: i = i + 1 // 移到下一個字節\n\n        No  → Decision: ones == 1 || ones > 4? // 無效開頭字節判斷\n\n            Yes → Step 5: Return False // 開頭字節不合法\n\n            No  → Step 6: expected = ones - 1 // 需要跟隨的續字節數\n\n            No  → Step 7: j = 1 // 續字節計數器\n\n            No  → Decision: i + expected < data.length? // 足夠續字節？\n\n                Yes → Loop while j <= expected\n\n                    → Step 8: nextByte = data[i + j] & 0xFF // 取得續字節\n\n                    → Decision: (nextByte >> 6) == 0b10? // 續字節是否以10開頭\n\n                        Yes → j = j + 1 // 續字節正確，繼續\n\n                        No  → Step 9: Return False // 續字節不合法\n\n                End While\n\n                → Step 10: i = i + ones // 移動到下個字符起始位置\n\n            No  → Step 11: Return False // 續字節不足\n\n    No → Step 12: i = i + 1 // 如果是1字節，已移動\n\n    No → Continue Decision loop\n\nEnd // 程式結束\n\nBut need more structured: Use Decision block, etc. Ensure each line includes explanation. Provide all lines.\n\nLet's craft final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: i = 0 // 初始化索引，從第一個字節開始  \n→ Decision: i < data.length? // 判斷是否還有未處理的字節  \n  Yes → Step 2: current = data[i] & 0xFF // 取得當前字節的低8位  \n  Yes → Step 3: ones = countLeadingOnes(current) // 計算開頭連續 1 的數量  \n  Yes → Decision: ones == 0? // 判斷是否為 1 字節字符  \n    Yes → Step 4: i = i + 1 // 1 字節，移到下一個字節  \n    No → Decision: ones == 1 || ones > 4? // 開頭 1 或 >4 為非法字節  \n     Yes → Step 5: Return False // 開頭字節不合法，直接返回 false  \n     No → Step 6: expected = ones - 1 // 需要的續字節數  \n     No → Step 7: j = 1 // 續字節計數器  \n     No → Decision: i + expected < data.length? // 是否有足夠續字節  \n      Yes → While j <= expected  \n       → Step 8: nextByte = data[i + j] & 0xFF // 取得續字節  \n       → Decision: (nextByte >> 6) == 0b10? // 續字節是否以 10 開頭  \n        Yes → j = j + 1 // 正確，計數器加一  \n        No → Step 9: Return False // 續字節格式不符，返回 false  \n      End While  \n      → Step 10: i = i + ones // 移動到下一個字符起始位置  \n      No → Step 11: Return False // 續字節不足，返回 false  \n     No → i = i + 1 // 1 字節字符已處理完，移動到下一個字節  \nEnd // 程式執行結束（若未返回 false，表示所有字節皆合法）",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def validUtf8(self, data):\n        \"\"\"\n        Validate a sequence of integers as UTF‑8 encoded bytes.\n        Each integer uses only its least significant 8 bits.\n        \"\"\"\n        n_bytes = 0  # remaining continuation bytes expected\n        for num in data:\n            byte = num & 0xFF  # keep only the lower 8 bits\n            if n_bytes == 0:\n                # Count leading 1 bits to determine the character length\n                mask = 0x80\n                while mask & byte:\n                    n_bytes += 1\n                    mask >>= 1\n                if n_bytes == 0:  # 1‑byte character (0xxxxxxx)\n                    continue\n                if n_bytes == 1 or n_bytes > 4:  # invalid starter byte\n                    return False\n                n_bytes -= 1  # one more byte will follow\n            else:\n                # Continuation byte must start with 10xxxxxx\n                if (byte & 0xC0) != 0x80:\n                    return False\n                n_bytes -= 1\n        return n_bytes == 0  # all expected continuation bytes consumed\n\ndef parse_input(input_str):\n    \"\"\"\n    Parse input of the form 'data = [197,130,1]' or similar.\n    Returns the list of integers.\n    \"\"\"\n    # Find the first '[' and the matching ']'\n    start = input_str.find('[')\n    end = input_str.rfind(']')\n    if start == -1 or end == -1:\n        return []\n    array_str = input_str[start:end+1]\n    try:\n        # ast.literal_eval safely evaluates the list literal\n        return ast.literal_eval(array_str)\n    except Exception:\n        return []\n\nif __name__ == \"__main__\":\n    # Read the entire input from stdin\n    raw_input = sys.stdin.read()\n    if not raw_input:\n        sys.exit(0)\n    data = parse_input(raw_input)\n    sol = Solution()\n    result = sol.validUtf8(data)\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "data = [197,130,1]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "data = [235,140,4]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode475.json",
    "problem_index_in_file": 0,
    "title": "Heaters",
    "description_snippet": "Winter is coming! During the contest, your first job is to design a standard heater with a fixed war...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the problem: find minimal radius such that heaters cover all houses. Classic solution: sort houses and heaters. For each house, find nearest heater distance (using binary search). Then max of these distances. Or two pointers. We'll produce virtual code steps.\n\nWe must output line by line: step description, arrow, explanation.\n\nNo actual code, just pseudo steps.\n\nWe must incorporate Start, End, Decision.\n\nLet's design steps:\n\nStart\n→ Sort houses ascending\n→ Sort heaters ascending\n→ Initialize maxRadius = 0\n→ For each house in houses:\n    → Find index of heater just greater than or equal to house using binary search\n    → If heater exists, compute distanceRight = heater - house\n    → Else distanceRight = INF\n    → If index > 0, compute distanceLeft = house - heaters[index-1]\n    → Else distanceLeft = INF\n    → minDist = min(distanceRight, distanceLeft)\n    → Update maxRadius = max(maxRadius, minDist)\n→ Return maxRadius\nEnd\n\nWe need explanation after each line.\n\nAlso, we need to use arrows: →, Decision: etc. For binary search we can use Decision: if heater index exists.\n\nLet's produce.\n\nMake sure each line has step plus comment. Use simple phrasing.\n\nLet's craft.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Sort houses ascending // 先將房屋位置排序，方便後續比對  \n→ Sort heaters ascending // 同樣將暖器位置排序，確保可做二分搜尋  \n→ Initialize maxRadius = 0 // 以 0 開始，儲存目前所需的最大最小距離  \n→ For each house in houses: // 逐一處理每個房屋  \n  → Find heater index ≥ house using binary search // 找出最靠近右側的暖器  \n   → Decision: heater exists? // 判斷是否有右側暖器  \n    Yes → distanceRight = heater - house // 右側暖器距離  \n    No  → distanceRight = Infinity // 無右側暖器，距離視為無限大  \n   → Decision: index > 0? // 判斷是否有左側暖器  \n    Yes → distanceLeft = house - heaters[index-1] // 左側暖器距離  \n    No  → distanceLeft = Infinity // 無左側暖器，距離視為無限大  \n  → minDist = min(distanceRight, distanceLeft) // 取左右兩者中較小距離  \n  → Update maxRadius = max(maxRadius, minDist) // 若此距離較大，更新最大半徑  \n→ Return maxRadius // 最終輸出最小的標準暖化半徑  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nfrom bisect import bisect_left\n\ndef find_radius(houses, heaters):\n    \"\"\"計算最小暖化半徑。\"\"\"\n    houses.sort()\n    heaters.sort()\n    max_radius = 0\n    for house in houses:\n        # 找出最靠近右邊的暖器位置\n        idx = bisect_left(heaters, house)\n        # 右邊暖器距離（若不存在則視為無限大）\n        right_dist = heaters[idx] - house if idx < len(heaters) else float('inf')\n        # 左邊暖器距離（若不存在則視為無限大）\n        left_dist = house - heaters[idx - 1] if idx > 0 else float('inf')\n        # 房屋最小需要的半徑\n        min_dist = min(right_dist, left_dist)\n        if min_dist > max_radius:\n            max_radius = min_dist\n    return max_radius\n\ndef parse_input(raw: str):\n    \"\"\"將輸入字串解析為 houses 與 heaters 列表。\"\"\"\n    raw = raw.replace('\\n', ',')          # 將換行視為逗號\n    houses, heaters = [], []\n    for part in raw.split(','):\n        part = part.strip()\n        if part.startswith('houses'):\n            lst = part.split('=', 1)[1].strip()\n            houses = ast.literal_eval(lst)\n        elif part.startswith('heaters'):\n            lst = part.split('=', 1)[1].strip()\n            heaters = ast.literal_eval(lst)\n    return houses, heaters\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n    houses, heaters = parse_input(raw_input)\n    result = find_radius(houses, heaters)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "houses = [1,2,3], heaters = [2]",
          "expected_output": "1",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmptnns360_.py\", line 41, in <module>\n    houses, heaters = parse_input(raw_input)\n                      ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmptnns360_.py\", line 31, in parse_input\n    houses = ast.literal_eval(lst)\n             ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "houses = [1,2,3,4], heaters = [1,4]",
          "expected_output": "1",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpk_x7_oz3.py\", line 41, in <module>\n    houses, heaters = parse_input(raw_input)\n                      ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpk_x7_oz3.py\", line 31, in parse_input\n    houses = ast.literal_eval(lst)\n             ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 2,
          "input": "houses = [1,5], heaters = [2]",
          "expected_output": "3",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpvtb737oh.py\", line 41, in <module>\n    houses, heaters = parse_input(raw_input)\n                      ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpvtb737oh.py\", line 31, in parse_input\n    houses = ast.literal_eval(lst)\n             ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode491.json",
    "problem_index_in_file": 0,
    "title": "Non-decreasing Subsequences",
    "description_snippet": "Given an integer array nums, return all the different possible non-decreasing subsequences of the gi...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps line by line for solving the problem: find all distinct non-decreasing subsequences of at least length 2. Use DFS/backtracking, use set to avoid duplicates, etc.\n\nWe need to produce virtual code lines with \"→\" arrows etc. Each line: \"虛擬碼步驟 // 解釋\". Format example given. We should output step-by-step algorithm. It can be high-level pseudocode.\n\nWe should include Start, End, Decision blocks.\n\nLet's create:\n\nStart\n\n→ Step 1: 定義遞迴函數 dfs(index, path) // 初始化遞迴\n→ Step 2: 在 dfs 內，如果 path 長度 >= 2, 將 path 的拷貝加入結果集 // 記錄合法子序列\n→ Decision: 從 index 開始遍歷 nums 循環 i\n   → Step 3: If path 为空 或 nums[i] >= path[-1] // 檢查是否非遞減\n        → Step 4: 記錄使用過的數字 in this level set seen // 防止重複\n        → Decision: 如果 nums[i] 已在 seen? // 如果已經用過，跳過\n           → Yes → continue // skip\n        → No → Step 5: dfs(i+1, path + [nums[i]]) // 遞迴\n   → Step 6: 循環結束\n→ End of dfs\n\n→ Step 7: 初始化結果為 set() // 用於去重\n→ Step 8: 呼叫 dfs(0, []) // 從頭開始\n→ Step 9: 回傳結果轉成 list // 將集合轉回 list\n\nEdge cases: duplicates in array but different positions should be treated separately; use seen set per recursion level to avoid duplicate subsequences produced from same number at same depth.\n\nAlso need to explain each step.\n\nLet's output lines accordingly. Ensure each line has \"虛擬碼步驟 // 解釋\". Use Chinese.\n\nWe should incorporate arrow indentation? Use \"→\" for each step, and \"Decision:\" for decisions, and \"Yes →\", \"No →\".\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義變數 result 為空集合 // 用於存放所有不同的子序列  \n→ Step 2: 定義遞迴函式 dfs(index, path) // index 是當前考慮的位置，path 是已經選擇的數字序列  \n→ Step 3: 在 dfs 內部  \n  → Decision: 如果 path 長度 ≥ 2? // 判斷是否已形成合法子序列  \n    Yes → Step 4: 把 path 的拷貝加入 result 集合 // 記錄一個合法子序列  \n    No  → // 不做任何事  \n  → Step 5: 定義局部集合 seen 為空集合 // 防止同一深度重複使用相同數字  \n  → Step 6: 從 index 到 nums.length-1 迭代 i  \n    → Decision: 如果 path 為空 OR nums[i] ≥ path 最後一個元素? // 檢查是否能維持非遞減性  \n      Yes → Step 7: Decision: 如果 nums[i] 已在 seen? // 同一層已處理過相同數字  \n        Yes → Step 8: continue // 跳過這個 i，避免重複子序列  \n        No  → Step 9: 把 nums[i] 加入 seen 集合 // 標記已使用  \n           → Step 10: 呼叫 dfs(i+1, path + [nums[i]]) // 深入下一層遞迴  \n      No  → // 無法維持非遞減，跳過此 i  \n  → Step 11: 迴圈結束  \n→ Step 12: dfs 函式結束  \n→ Step 13: 呼叫 dfs(0, []) // 從陣列開頭開始遞迴  \n→ Step 14: 將 result 集合轉成列表並返回 // 取得所有不同的非遞減子序列  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findSubsequences(self, nums):\n        res = []\n\n        def backtrack(start, path):\n            if len(path) >= 2:\n                res.append(path[:])\n            used = set()\n            for i in range(start, len(nums)):\n                if (not path or nums[i] >= path[-1]) and nums[i] not in used:\n                    used.add(nums[i])\n                    path.append(nums[i])\n                    backtrack(i + 1, path)\n                    path.pop()\n\n        backtrack(0, [])\n        return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    l = data.find('[')\n    r = data.rfind(']')\n    if l == -1 or r == -1 or r < l:\n        nums = []\n    else:\n        nums = ast.literal_eval(data[l:r+1])\n    solution = Solution()\n    result = solution.findSubsequences(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [4,6,7,7]",
          "expected_output": "[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]",
          "success": true,
          "output": "[[4, 6], [4, 6, 7], [4, 6, 7, 7], [4, 7], [4, 7, 7], [6, 7], [6, 7, 7], [7, 7]]"
        },
        {
          "example_index": 1,
          "input": "nums = [4,4,3,2,1]",
          "expected_output": "[[4,4]]",
          "success": true,
          "output": "[[4, 4]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode535.json",
    "problem_index_in_file": 0,
    "title": "Encode and Decode TinyURL",
    "description_snippet": "Note: This is a companion problem to the System Design problem: Design TinyURL.\nTinyURL is a URL sho...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code for a class Solution with methods encode and decode, typical solution uses hash map mapping short id to original URL and vice versa. Steps: initialization, encode generating unique ID, store mapping, construct shortURL. decode retrieving from map. Use base62 encoding maybe. But just provide virtual steps.\n\nWe need to produce lines like:\n\nStart // ...\n→ Step 1: 初始化映射表 // ...\n\nUse arrows and decisions maybe. Provide step-by-step algorithm. Ensure no actual code, just virtual steps. Each line includes // explanation.\n\nLet's produce a flow. Use Start, End. Maybe include Decision for ID collision. Use a counter increment. Provide base62 conversion.\n\nWe will produce: Start -> Step: create maps. -> Step: encode longUrl: generate id using counter or hash. -> Decision: id collision? Yes -> generate new id. -> Step: map id to longUrl. -> Step: construct shortURL. -> End. Similarly for decode: Step: extract id from shortURL. -> Step: look up id in map. -> Return longUrl. End.\n\nMake sure to use proper arrow syntax.\n\nLet's output lines accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立兩個空的映射表: id_to_url, url_to_id // 用於存儲短網址對應的長網址與反向對應\n→ Step 2: 初始化全域序號 counter = 0 // 用於產生唯一的短網址編號\n→ Step 3: 定義 base62 字符集 '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ' // 用於將整數轉為短碼\n→ Step 4: Encode(longUrl):\n    → Step 5: 如果 longUrl 已存在於 url_to_id:\n        → Step 6: 取出已有 id = url_to_id[longUrl] // 重複網址直接重複使用相同短碼\n    → Step 7: 否則:\n        → Step 8: 產生新 id = counter\n        → Step 9: counter = counter + 1 // 確保下一次唯一\n        → Step 10: 存入映射: url_to_id[longUrl] = id, id_to_url[id] = longUrl\n    → Step 11: 將 id 轉為 base62 短碼 short_id = EncodeToBase62(id)\n    → Step 12: 組合短網址 shortUrl = \"http://tinyurl.com/\" + short_id\n    → Step 13: 回傳 shortUrl // 完成編碼\n→ Step 14: Decode(shortUrl):\n    → Step 15: 解析 shortUrl 取得 short_id（去除前綴 \"http://tinyurl.com/\"）\n    → Step 16: 將 short_id 轉回整數 id = DecodeFromBase62(short_id)\n    → Step 17: 查詢映射 longUrl = id_to_url[id] // 確保 id 存在\n    → Step 18: 回傳 longUrl // 完成解碼\nEnd // 程式執行結束\n\n// 補充說明：EncodeToBase62 與 DecodeFromBase62 為將整數編碼/解碼為 base62 字串的虛擬方法，實作時需對數字進行除以 62 的餘數轉換。",
      "generated_code": "import sys\nimport random\nimport string\n\nclass Solution:\n    \"\"\"\n    TinyURL 服務實作\n    使用 6 位隨機鍵作為短網址標識，並將鍵映射到原始長網址。\n    \"\"\"\n    def __init__(self):\n        # 鍵 -> 原始網址 的映射表\n        self.url_map = {}\n        # 基礎短網址\n        self.base_url = \"http://tinyurl.com/\"\n\n    def _generate_key(self) -> str:\n        \"\"\"產生一個 6 位隨機鍵，確保唯一性。\"\"\"\n        charset = string.ascii_letters + string.digits\n        while True:\n            key = ''.join(random.choice(charset) for _ in range(6))\n            if key not in self.url_map:\n                return key\n\n    def encode(self, longUrl: str) -> str:\n        \"\"\"\n        將長網址編碼為短網址。\n        若長網址已存在，直接回傳已生成的短網址。\n        \"\"\"\n        # 先檢查是否已編碼過\n        for k, v in self.url_map.items():\n            if v == longUrl:\n                return self.base_url + k\n        # 產生新鍵\n        key = self._generate_key()\n        self.url_map[key] = longUrl\n        return self.base_url + key\n\n    def decode(self, shortUrl: str) -> str:\n        \"\"\"\n        將短網址解碼回原始長網址。\n        \"\"\"\n        key = shortUrl.replace(self.base_url, \"\")\n        return self.url_map.get(key, \"\")\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    raw_input = sys.stdin.read().strip()\n    # 移除可能的雙引號\n    if raw_input.startswith('\"') and raw_input.endswith('\"'):\n        raw_input = raw_input[1:-1]\n    # 建立 Solution 物件\n    codec = Solution()\n    # 先編碼，再解碼回來\n    short = codec.encode(raw_input)\n    long = codec.decode(short)\n    # 輸出解碼得到的長網址\n    print(long)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "\"https://leetcode.com/problems/design-tinyurl\"",
          "expected_output": "\"https://leetcode.com/problems/design-tinyurl\"",
          "success": true,
          "output": "https://leetcode.com/problems/design-tinyurl"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode409.json",
    "problem_index_in_file": 0,
    "title": "Longest Palindrome",
    "description_snippet": "Given a string s which consists of lowercase or uppercase letters, return the length of the longest ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for given problem. Use virtual code steps with arrow and decision. Need to output line by line.\n\nWe should cover: count letters, determine odd counts, compute length. Provide explanation.\n\nAlso note: string can have uppercase/lowercase distinct.\n\nLet's craft:\n\nStart\n→ Step 1: Initialize an array freq[52] to 0 // mapping letters A-Z and a-z\n→ Step 2: For each character ch in s\n    → Decision: Is ch uppercase?\n        Yes → Step 3: Increment freq[ch - 'A'] // map uppercase\n        No  → Step 4: Increment freq[ch - 'a' + 26] // map lowercase\n→ Step 5: Initialize palindrome_len = 0\n→ Step 6: Initialize hasOdd = False\n→ Step 7: For i from 0 to 51\n    → Step 8: palindrome_len += freq[i] // add all counts\n    → Decision: freq[i] mod 2 == 1?\n        Yes → Step 9: hasOdd = True // record presence of odd\n→ Decision: hasOdd == False?\n    Yes → End // all counts even, return palindrome_len\n    No  → Decision: palindrome_len > 0?\n        Yes → Step 10: Return palindrome_len - 1 + 1? Wait need to subtract 1? Actually we can use all even counts and use one odd as center; total length = palindrome_len - (number_of_odds -1). Simplify: result = palindrome_len - (number_of_odds -1). So compute: Step 10: result = palindrome_len - (number_of_odds - 1) // subtract extras\n        No  → Step 11: Return 0 // empty string\n→ End\n\nBut we didn't track number_of_odds. We can track count_odds variable.\n\nLet's produce improved:\n\nStart\n→ Step 1: Initialize freq[52] to 0\n→ Step 2: For each character ch in s\n    → Decision: Is ch between 'A' and 'Z'?\n        Yes → Step 3: freq[ch - 'A'] += 1\n        No  → Step 4: freq[ch - 'a' + 26] += 1\n→ Step 5: Initialize odd_count = 0\n→ Step 6: For i from 0 to 51\n    → Decision: freq[i] mod 2 == 1?\n        Yes → Step 7: odd_count += 1\n→ Decision: odd_count == 0?\n    Yes → Step 8: Return sum of freq (can compute earlier) // all even\n    No  → Step 9: result = sum(freq) - odd_count + 1 // use one odd center\n        → Step 10: Return result\nEnd\n\nWe need to compute sum(freq) but we can compute in earlier step. Let's compute sum_freq variable.\n\nWe'll add:\n\n→ Step 11: Initialize sum_freq = 0\n→ Step 12: For i from 0 to 51\n    → Step 13: sum_freq += freq[i]\nBut we need to merge loops. Let's do:\n\nStart\n→ Step 1: Initialize freq[52] to 0\n→ Step 2: For each ch in s\n    → Decision: ch is uppercase?\n        Yes → Step 3: freq[ch - 'A'] += 1\n        No  → Step 4: freq[ch - 'a' + 26] += 1\n→ Step 5: Initialize sum_freq = 0, odd_count = 0\n→ Step 6: For i from 0 to 51\n    → Step 7: sum_freq += freq[i]\n    → Decision: freq[i] mod 2 == 1?\n        Yes → Step 8: odd_count += 1\n→ Decision: odd_count == 0?\n    Yes → Step 9: Return sum_freq\n    No  → Step 10: result = sum_freq - odd_count + 1\n        → Step 11: Return result\nEnd\n\nNow we produce each line with arrow.\n\nLet's ensure syntax: `Start // 程式開始執行`. Provide arrow.\n\nAlso need indentation for decisions. Use the format:\n\n→ Decision: ...?\n    Yes → ...\n    No  → ...\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化陣列 freq[52] 為 0 // 52 個元素對應 A-Z 與 a-z  \n→ Step 2: 逐字元遍歷字串 s  \n  → Decision: 字元 ch 是否為大寫字母?  \n   Yes → Step 3: freq[ch - 'A'] += 1 // 大寫字母對應索引 0~25  \n   No  → Step 4: freq[ch - 'a' + 26] += 1 // 小寫字母對應索引 26~51  \n→ Step 5: 初始化 sum_freq = 0，odd_count = 0 // 分別統計總字數與奇數出現數  \n→ Step 6: 從 0 到 51 迭代 freq  \n  → Step 7: sum_freq += freq[i] // 加總所有字元數量  \n   → Decision: freq[i] % 2 == 1?  \n    Yes → Step 8: odd_count += 1 // 追蹤奇數出現數  \n    No  → (無操作)  \n→ Decision: odd_count == 0?  \n  Yes → Step 9: 返回 sum_freq // 所有字數均為偶數，可全用於回文  \n  No  → Step 10: result = sum_freq - odd_count + 1 // 只保留一個奇數作中心，其他奇數減 1  \n    → Step 11: 返回 result // 最長可建回文長度  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\ndef longest_palindrome_length(s: str) -> int:\n    \"\"\"\n    計算可用字母組成的最長回文長度。\n    \"\"\"\n    counter = Counter(s)\n    length = 0\n    odd_found = False\n    for cnt in counter.values():\n        if cnt % 2 == 0:\n            length += cnt\n        else:\n            length += cnt - 1\n            odd_found = True\n    if odd_found:\n        length += 1\n    return length\n\ndef extract_string(raw_input: str) -> str:\n    \"\"\"\n    從輸入中提取字串內容。\n    若輸入類似 `s = \"abc\"`，則回傳 abc。\n    若找不到引號，則直接回傳原始字串。\n    \"\"\"\n    match = re.search(r'\"([^\"]*)\"', raw_input)\n    if match:\n        return match.group(1)\n    return raw_input.strip()\n\nif __name__ == \"__main__\":\n    raw = sys.stdin.read()\n    s = extract_string(raw)\n    result = longest_palindrome_length(s)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"abccccdd\"",
          "expected_output": "7",
          "success": true,
          "output": "7"
        },
        {
          "example_index": 1,
          "input": "s = \"a\"",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode502.json",
    "problem_index_in_file": 0,
    "title": "IPO",
    "description_snippet": "Suppose LeetCode will start its IPO soon. In order to sell a good price of its shares to Venture Cap...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code algorithm steps: typical solution: use min-heap for required capital, max-heap for profits. Steps: sort projects by capital ascending. Iterate k times: push all projects with capital <= current capital into max-heap. If max-heap empty, break. Pop max profit, add to capital. Continue.\n\nWe need to output step-by-step pseudocode with arrows etc.\n\nLet's craft:\n\nStart\n\n→ Sort projects by capital ascending // Arrange projects by required capital\n\n→ Initialize index i = 0 // Pointer to sorted projects\n\n→ Initialize max-heap profitHeap // Heap for available profits\n\n→ For loop iter = 1 to k // up to k projects\n\n    → While i < n and projects[i].capital <= capital // add eligible projects\n\n        → Add projects[i].profit to profitHeap\n\n        → i++\n\n    → If profitHeap empty\n\n        → Break // no more projects can be started\n\n    → Pop max profit from profitHeap // select most profitable available\n\n    → capital += profit // add profit to current capital\n\nEnd\n\nReturn capital\n\nBut need to use virtual code arrow format. Provide line by line with explanation.\n\nLet's produce.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 將所有專案按所需資本 capital 升序排序 // 方便按資本可行性分配\n→ Step 2: 初始化指標 i = 0 // 用來遍歷已排序專案\n→ Step 3: 初始化最大堆 profitHeap // 用來快速取得最高純利潤的專案\n→ Step 4: 從 1 到 k 重複以下步驟 // 至多選 k 個專案\n    → Decision: 當前 capital 是否能啟動更多專案? // 檢查是否還有可執行的專案\n        Yes → Loop: 將所有 i < n 且 projects[i].capital ≤ capital 的專案加入 profitHeap\n            → Step 5: 將 projects[i].profit 加入 profitHeap\n            → Step 6: i += 1\n            → Continue Loop\n        No  → Break // 沒有更多可啟動的專案，結束迴圈\n    → Decision: profitHeap 是否非空? // 檢查是否有可選擇的專案\n        Yes → Step 7: 從 profitHeap 取出最大純利潤 profit\n            → Step 8: capital += profit // 將利潤加入總資本\n        No  → Break // 堆空，無法再選擇專案，結束迴圈\n→ Step 9: 返回 capital // 最終最大化的資本\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\nimport re\nimport heapq\n\ndef find_maximized_capital(k: int, w: int, profits, capital):\n    # 將專案按所需資本排序，方便逐步放入可用堆\n    projects = sorted(zip(capital, profits))\n    max_heap = []                     # 儲存可啟動專案的純利潤（使用負數作為最大堆）\n    idx = 0\n    n = len(profits)\n\n    for _ in range(k):\n        # 把所有目前可啟動的專案加入堆中\n        while idx < n and projects[idx][0] <= w:\n            heapq.heappush(max_heap, -projects[idx][1])\n            idx += 1\n\n        if not max_heap:\n            break                    # 沒有可選擇的專案，結束迴圈\n\n        # 選取利潤最高的專案\n        w -= heapq.heappop(max_heap)  # 由於堆中存的是負數，減去負數即為加上利潤\n\n    return w\n\ndef parse_input(data: str):\n    \"\"\"從輸入字串中抽取 k、w、profits、capital。\"\"\"\n    data = data.strip()\n    k = int(re.search(r'k\\s*=\\s*(-?\\d+)', data).group(1))\n    w = int(re.search(r'w\\s*=\\s*(-?\\d+)', data).group(1))\n\n    # 取得所有以方括號包住的清單\n    lists = re.findall(r'\\[(.*?)\\]', data)\n    if len(lists) >= 2:\n        profits = [int(x) for x in lists[0].split(',') if x.strip()]\n        capital = [int(x) for x in lists[1].split(',') if x.strip()]\n    else:\n        profits = []\n        capital = []\n\n    return k, w, profits, capital\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    k, w, profits, capital = parse_input(raw_input)\n    result = find_maximized_capital(k, w, profits, capital)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "k = 3, w = 0, profits = [1,2,3], capital = [0,1,2]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode242.json",
    "problem_index_in_file": 0,
    "title": "Valid Anagram",
    "description_snippet": "Given two strings s and t, return true if t is an anagram of s, and false otherwise....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines. We need to implement an algorithm to check if t is an anagram of s. Steps: Check lengths equal, then count characters. Use hash map or array for 26 letters. Use decisions. Output true/false. Use Start, End, Decision. Provide explanation comment after each line. Let's produce. Ensure each line includes arrow and comment. Use Chinese explanation. Use the format exactly: \"Start // 程式開始執行\" etc.\n\nWe must output step by step. Use \"→\" arrow for steps. Use \"Decision:\" for if conditions. Provide \"Yes →\" and \"No →\" branching. At the end, produce result variable. Let's produce something like:\n\nStart // 開始\n→ Step 1: 定義字串 s, t // 取得輸入字串\n→ Decision: s.length ≠ t.length? // 比較長度\n    Yes → Step 2: 設置結果為 false // 不等長則非 anagram\n    No  → Step 3: 初始化陣列 count[26] 為 0 // 以 26 個英文字母為索引\n        → Step 4: 對 s 的每個字元 i: count[i - 'a']++ // 統計 s 的字元頻率\n        → Step 5: 對 t 的每個字元 i: count[i - 'a']-- // 減少 t 的字元頻率\n        → Decision: 所有 count 值是否都為 0? // 檢查是否完全匹配\n            Yes → Step 6: 設置結果為 true // 為 anagram\n            No  → Step 7: 設置結果為 false // 不是 anagram\n→ Step 8: 輸出結果 // 返回 true 或 false\nEnd // 程式結束\n\nBut need to use \"Yes →\" indentation. Provide comments after each line. Ensure arrow. Provide each line. Use proper formatting.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義字串 s, t // 取得輸入字串  \n→ Decision: s.length ≠ t.length? // 比較兩字串長度是否相同  \n Yes → Step 2: 設置結果為 false // 長度不同即非 anagram，直接結束  \n No  → Step 3: 初始化陣列 count[26] 為 0 // 準備 26 個英文字母的頻率統計  \n  → Step 4: 對 s 的每個字元 c: count[c - 'a']++ // 計算 s 中每個字元出現次數  \n  → Step 5: 對 t 的每個字元 c: count[c - 'a']-- // 對應地減少 t 的出現次數  \n  → Decision: 所有 count 值是否都為 0? // 檢查兩個字串的字元頻率是否一致  \n   Yes → Step 6: 設置結果為 true // 完全一致，t 為 s 的 anagram  \n   No  → Step 7: 設置結果為 false // 有不匹配，t 不是 s 的 anagram  \n→ Step 8: 輸出結果 // 回傳 true 或 false  \nEnd // 程式執行結束",
      "generated_code": "import sys\nfrom collections import Counter\nimport re\n\nclass Solution:\n    def isAnagram(self, s: str, t: str) -> bool:\n        # 直接使用 Counter 比較兩個字串的字符頻率\n        return Counter(s) == Counter(t)\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個內容\n    data = sys.stdin.read().strip()\n    # 使用正則表達式抽取引號內的字串，這裡假設輸入為 s = \"xxxx\", t = \"yyyy\"\n    matches = re.findall(r'\"([^\"]*)\"', data)\n    if len(matches) >= 2:\n        s, t = matches[0], matches[1]\n    else:\n        # 若格式不符，直接輸出 false\n        print(\"false\")\n        sys.exit(0)\n\n    sol = Solution()\n    result = sol.isAnagram(s, t)\n    # 根據布林值輸出對應的小寫字串\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"anagram\", t = \"nagaram\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "s = \"rat\", t = \"car\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode301.json",
    "problem_index_in_file": 0,
    "title": "Remove Invalid Parentheses",
    "description_snippet": "Given a string s that contains parentheses and letters, remove the minimum number of invalid parenth...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to generate a virtual code flow for solving \"Remove Invalid Parentheses\" problem. Steps: Start, compute left and right removal counts by scanning. Use DFS/backtracking to generate valid strings. Use set to store results to avoid duplicates. Use recursion with index, leftCount, rightCount, openCount. Use pruning: if too many left or right. Build string builder. When finished, add to set if index==len and openCount==0. Return set as list.\n\nWe need to output each line with arrow and explanation. Use Start, End. Use Decision.\n\nWe need to produce pseudo-code, not real code. Use step format: \"→ Step X: ...\" but the example shows using Step 1 etc. We can just produce generic steps: Step 1: Calculate leftRem, rightRem. Step 2: Define DFS function. Step 3: Call DFS. Step 4: Convert set to list. End.\n\nWe need to use arrows and indentation for decisions. Provide simple explanation.\n\nWe need to output each line with format: \"虛擬碼步驟 // 解釋\". So each line has a virtual code step then a space then comment with explanation.\n\nWe need to use arrows: \"→\". For decisions use \"Decision:\" and Yes/No branches.\n\nWe need to ensure it's clear and follows format.\n\nWe'll output as:\n\nStart // 程式開始執行\n\n→ Step 1: Calculate leftRem and rightRem by scanning s // Count invalid left & right parentheses\n\n→ Step 2: Define DFS(idx, leftRem, rightRem, openCount, path) // Backtracking helper\n\n→ Step 3: In DFS, if idx == len(s) // Check if reached end of string\n\n    Yes → Decision: If openCount == 0? // Ensure all open parentheses are matched\n\n        Yes → Step 4: Add path to result set // Valid string found\n\n        No  → Step 5: Return // Unmatched open parentheses, invalid\n\n    No  → Step 6: current = s[idx] // Current character\n\n    → Decision: If current == '(' // Handle left parenthesis\n\n        Yes → Decision: If leftRem > 0? // Option to skip it\n\n            Yes → Step 7: DFS(idx+1, leftRem-1, rightRem, openCount, path) // Skip '('\n\n            No  → Step 8: DFS(idx+1, leftRem, rightRem, openCount+1, path+'(') // Keep '('\n\n        No → Step 9: DFS(idx+1, leftRem, rightRem, openCount+1, path+'(') // Keep '(' (no removal left)\n\n    No → Decision: If current == ')' // Handle right parenthesis\n\n        Yes → Decision: If rightRem > 0? // Option to skip it\n\n            Yes → Step 10: DFS(idx+1, leftRem, rightRem-1, openCount, path) // Skip ')'\n\n            No  → Step 11: Decision: If openCount > 0? // Can match with an open\n\n                Yes → Step 12: DFS(idx+1, leftRem, rightRem, openCount-1, path+')') // Keep ')'\n\n                No  → Step 13: Return // No open to match, invalid\n\n        No → Decision: If openCount > 0? // Must match with an open\n\n            Yes → Step 14: DFS(idx+1, leftRem, rightRem, openCount-1, path+')') // Keep ')'\n\n            No  → Step 15: Return // Unmatched ')', invalid\n\n    No → Decision: If current is letter // Non-parenthesis characters\n\n        Yes → Step 16: DFS(idx+1, leftRem, rightRem, openCount, path+current) // Keep character\n\n→ Step 17: Call DFS(0, leftRem, rightRem, 0, \"\") // Initiate backtracking\n\n→ Step 18: Convert result set to list and return // Prepare final answer\n\nEnd // 程式執行結束\n\nNeed to ensure each line with arrow and explanation. Use Chinese explanation. Also use indentation? Example didn't indent but used nested lines with indentation for decisions.\n\nWe can follow same style.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Calculate leftRem and rightRem by scanning s // 先統計字串中需要刪除的左括號與右括號數量  \n→ Step 2: Define DFS(idx, leftRem, rightRem, openCount, path) // 建立回溯輔助函式  \n→ Step 3: In DFS, if idx == len(s) // 檢查是否已經遍歷完字串  \n  Yes → Decision: If openCount == 0? // 確認所有左括號已配對  \n   Yes → Step 4: Add path to result set // 找到合法字串，加入結果  \n   No  → Step 5: Return // 未配對的左括號，為非法字串  \n  No  → Step 6: current = s[idx] // 取得目前字元  \n  → Decision: If current == '(' // 處理左括號  \n   Yes → Decision: If leftRem > 0? // 可選擇刪除此左括號  \n    Yes → Step 7: DFS(idx+1, leftRem-1, rightRem, openCount, path) // 刪除 '('  \n    No  → Step 8: DFS(idx+1, leftRem, rightRem, openCount+1, path+'(') // 保留 '('  \n   No → Step 9: DFS(idx+1, leftRem, rightRem, openCount+1, path+'(') // 無需刪除，直接保留  \n  → Decision: If current == ')' // 處理右括號  \n   Yes → Decision: If rightRem > 0? // 可選擇刪除此右括號  \n    Yes → Step 10: DFS(idx+1, leftRem, rightRem-1, openCount, path) // 刪除 ')'  \n    No  → Decision: If openCount > 0? // 需要配對左括號  \n     Yes → Step 11: DFS(idx+1, leftRem, rightRem, openCount-1, path+')') // 保留 ')'  \n     No  → Step 12: Return // 沒有左括號可配對，非法字串  \n   No → Decision: If openCount > 0? // 必須有左括號可配對  \n    Yes → Step 13: DFS(idx+1, leftRem, rightRem, openCount-1, path+')') // 保留 ')'  \n    No  → Step 14: Return // 未配對的右括號，非法字串  \n  → Decision: If current is letter // 非括號字元  \n   Yes → Step 15: DFS(idx+1, leftRem, rightRem, openCount, path+current) // 直接保留  \n→ Step 16: Call DFS(0, leftRem, rightRem, 0, \"\") // 開始回溯搜尋  \n→ Step 17: Convert result set to list and return // 產生最終答案列表  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom typing import List\n\nclass Solution:\n    def removeInvalidParentheses(self, s: str) -> List[str]:\n        # 先計算需要刪除的左括號和右括號數量\n        left_rem, right_rem = 0, 0\n        for ch in s:\n            if ch == '(':\n                left_rem += 1\n            elif ch == ')':\n                if left_rem == 0:\n                    right_rem += 1\n                else:\n                    left_rem -= 1\n\n        res = set()\n\n        def dfs(idx: int, left_rem: int, right_rem: int, open_cnt: int, path: str):\n            if idx == len(s):\n                if open_cnt == 0:\n                    res.add(path)\n                return\n\n            ch = s[idx]\n\n            if ch == '(':\n                # 可以選擇刪除\n                if left_rem > 0:\n                    dfs(idx + 1, left_rem - 1, right_rem, open_cnt, path)\n                # 或保留\n                dfs(idx + 1, left_rem, right_rem, open_cnt + 1, path + ch)\n            elif ch == ')':\n                # 可以選擇刪除\n                if right_rem > 0:\n                    dfs(idx + 1, left_rem, right_rem - 1, open_cnt, path)\n                # 或保留（必須有左括號可配對）\n                if open_cnt > 0:\n                    dfs(idx + 1, left_rem, right_rem, open_cnt - 1, path + ch)\n            else:\n                # 普通字元，直接保留\n                dfs(idx + 1, left_rem, right_rem, open_cnt, path + ch)\n\n        dfs(0, left_rem, right_rem, 0, \"\")\n        return list(res)\n\ndef parse_input(raw: str) -> str:\n    \"\"\"\n    從原始輸入中提取字串 s。\n    支援格式如：\n      s = \"()())()\"\n      \"(()))\"\n      ()()\n    \"\"\"\n    raw = raw.strip()\n    # 找到 '=' 並取 '=' 之後的內容\n    if '=' in raw:\n        raw = raw.split('=', 1)[1].strip()\n    # 去除前後的單引號或雙引號\n    raw = raw.strip('\\'\"')\n    return raw\n\ndef main():\n    raw_input = sys.stdin.read()\n    s = parse_input(raw_input)\n    solution = Solution()\n    result = solution.removeInvalidParentheses(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"()())()\"",
          "expected_output": "[\"(())()\",\"()()()\"]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"(())()\",\"()()()\"]'\nGot (Norm):      '[\"()()()\",\"(())()\"]'\n--- (Raw) ---\nRaw Expected: '[\"(())()\",\"()()()\"]'\nRaw Got:      \"['()()()', '(())()']\""
        },
        {
          "example_index": 1,
          "input": "s = \"(a)())()\"",
          "expected_output": "[\"(a())()\",\"(a)()()\"]",
          "success": true,
          "output": "['(a())()', '(a)()()']"
        },
        {
          "example_index": 2,
          "input": "s = \")(\"",
          "expected_output": "[\"\"]",
          "success": true,
          "output": "['']"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode482.json",
    "problem_index_in_file": 0,
    "title": "License Key Formatting",
    "description_snippet": "You are given a license key represented as a string s that consists of only alphanumeric characters ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code steps per line with explanations. The task: Reformat license key string.\n\nWe need algorithm steps: Remove dashes, uppercase letters, split into groups of k, first group may be shorter. Implementation steps.\n\nWe output lines like:\n\nStart // 程式開始\n\n→ Step 1: Initialize cleanStr = '' // accumulate alphanumeric characters, ignore dashes\n\n→ Step 2: Iterate each char in s // remove dashes and uppercase\n\n…\n\nWe must use Decision arrow lines where needed. At the end build result string by iterating groups.\n\nWe must be careful to produce only virtual code, not actual code. So use placeholder variable names.\n\nWe need to use arrow \"→\" for steps, \"Decision:\" with Yes/No branches.\n\nProbably need for loop iteration, but can describe abstractly: For each char in s: if char != '-' etc.\n\nThen after obtaining cleaned string, compute length, determine first group length: len % k if len % k != 0 else k? Actually first group could be shorter. Compute firstGroupLen = len % k; if firstGroupLen == 0 then firstGroupLen = k? Wait if length divisible by k, first group still should be k length. Actually example: \"5F-3Z\" with k=2 -> cleaned \"5F3Z\" length 4, k=2, len%k=0, firstGroupLen=2. So if mod==0 then firstGroupLen=k.\n\nThen iterate over cleaned string building groups: first group of length firstGroupLen, then subsequent groups of k.\n\nAdd dash between groups.\n\nEnd // finish.\n\nInclude decisions for mod check.\n\nAlso decision for cleaning: if char is '-' skip.\n\nLet's craft lines.\n\nWe'll produce like:\n\nStart // 程式開始\n\n→ Step 1: Set cleaned = '' // 用於存儲去除破折號且大寫化後的字符\n\n→ Step 2: For each char c in s // 逐個檢查原始字串\n\n    Decision: c == '-'? // 是否為破折號\n\n        Yes → Continue // 跳過破折號\n\n        No  → cleaned = cleaned + Upper(c) // 追加大寫字符\n\n→ Step 3: Let totalLen = Length(cleaned) // 數出有效字符數\n\n→ Step 4: Let rem = totalLen % k // 計算第一組可能的短長度\n\n→ Decision: rem == 0? // 是否整除\n\n    Yes → firstGroupLen = k // 第一組長度為 k\n\n    No  → firstGroupLen = rem // 第一組長度為餘數\n\n→ Step 5: Initialize result = '' // 儲存最終格式化結果\n\n→ Step 6: Set idx = 0 // 目前處理位置\n\n→ Decision: idx < firstGroupLen? // 是否還未完成第一組\n\n    Yes → result = result + Substring(cleaned, idx, firstGroupLen) // 取第一組\n\n    No  → // 第一組已完成，跳過\n\n→ Step 7: idx = idx + firstGroupLen // 移動指標至下一組起點\n\n→ Decision: idx < totalLen? // 是否還有剩餘字符\n\n    Yes → While idx < totalLen\n\n        → result = result + '-' // 插入破折號\n\n        → groupSize = Min(k, totalLen - idx) // 本組實際長度\n\n        → result = result + Substring(cleaned, idx, groupSize) // 取本組\n\n        → idx = idx + groupSize // 移動指標\n\n    No  → // 無剩餘字符，循環結束\n\n→ End // 程式結束，返回 result\n\nBut we need \"Decision:\" lines must be indented, but we can just include the arrow. Use \"→\" for steps, \"Decision:\" for decisions. We also use \"Yes →\", \"No →\" for branches.\n\nWe should produce each line as:\n\nStart // 程式開始\n\n→ Step 1: ... // ...\n\n...\n\nWe must ensure each line ends with comment.\n\nLet's craft more neatly:\n\nStart // 程式開始\n→ Step 1: Set cleaned = '' // 初始化空字串用於存儲去除破折號後的字符\n→ Step 2: For each character c in s // 逐個遍歷輸入字串\n    Decision: c == '-'? // 判斷是否為破折號\n        Yes → // 跳過破折號\n        No  → cleaned = cleaned + Upper(c) // 將字符轉為大寫並追加至 cleaned\n→ Step 3: Let totalLen = Length(cleaned) // 計算有效字符總數\n→ Step 4: Let rem = totalLen % k // 計算第一組可能的短長度\n→ Decision: rem == 0? // 檢查是否能整除\n    Yes → firstGroupLen = k // 第一組長度為 k\n    No  → firstGroupLen = rem // 第一組長度為餘數\n→ Step 5: Set result = '' // 初始化結果字串\n→ Step 6: Set idx = 0 // 設置指標\n→ Decision: firstGroupLen > 0? // 檢查是否有第一組\n    Yes → result = result + Substring(cleaned, 0, firstGroupLen) // 取第一組\n    No  → // 無需處理\n→ Step 7: idx = firstGroupLen // 移動指標到下一組\n→ Decision: idx < totalLen? // 是否還有剩餘字符\n    Yes → While idx < totalLen\n        → result = result + '-' // 插入破折號\n        → groupSize = Min(k, totalLen - idx) // 本組實際長度\n        → result = result + Substring(cleaned, idx, groupSize) // 取本組\n        → idx = idx + groupSize // 移動指標\n    No  → // 所有字符已處理\nEnd // 程式結束\n\nWe might need to indicate the while loop. Use \"→ While idx < totalLen\" line and indent inside.\n\nBut we have to keep \"逐行\" format. Each line is one step or decision.\n\nWe might need to indent lines for readability but format not strict.\n\nWe need to keep arrows and decisions. In while loop, we can include lines with \"→ While\" and then lines inside also start with \"→\".\n\nBut need to maintain decision inside while maybe not needed.\n\nBetter to write:\n\n→ While idx < totalLen\n    → result = result + '-' // 插入破折號\n    → groupSize = Min(k, totalLen - idx) // 計算本組長度\n    → result = result + Substring(cleaned, idx, groupSize) // 取本組\n    → idx = idx + groupSize // 移動指標\n\nOk.\n\nAlso we had Decision after Step 6: idx < totalLen? we can skip since while handles. But we can keep to match.\n\nLet's produce final.\n\nEnsure each line has the pattern: \"虛擬碼步驟 [space] // 解釋\".\n\nWe'll write the lines accordingly.\n...done thinking.\n\nStart // 程式開始\n→ Step 1: Set cleaned = '' // 初始化空字串，用於存放去除破折號且轉大寫的字符\n→ Step 2: For each character c in s // 逐個檢查輸入字串\n    Decision: c == '-'? // 判斷是否為破折號\n        Yes → // 跳過破折號\n        No  → cleaned = cleaned + Upper(c) // 將字符轉成大寫後追加至 cleaned\n→ Step 3: Let totalLen = Length(cleaned) // 取得有效字符總數\n→ Step 4: Let rem = totalLen % k // 計算第一組可能的短長度\n→ Decision: rem == 0? // 檢查是否能整除 k\n    Yes → firstGroupLen = k // 第一組長度為 k\n    No  → firstGroupLen = rem // 第一組長度為餘數\n→ Step 5: Set result = '' // 初始化結果字串\n→ Step 6: Set idx = 0 // 設置指標\n→ Decision: firstGroupLen > 0? // 是否存在第一組\n    Yes → result = result + Substring(cleaned, 0, firstGroupLen) // 取第一組\n    No  → // 無需處理\n→ Step 7: idx = firstGroupLen // 移動指標到下一組起點\n→ While idx < totalLen\n    → result = result + '-' // 插入破折號\n    → groupSize = Min(k, totalLen - idx) // 本組實際長度\n    → result = result + Substring(cleaned, idx, groupSize) // 取本組\n    → idx = idx + groupSize // 移動指標\nEnd // 程式結束，返回 result",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def licenseKeyFormatting(self, S: str, K: int) -> str:\n        # 移除所有 '-' 並轉為大寫\n        S = S.replace('-', '').upper()\n        n = len(S)\n        # 第一組長度：如果整除則為 K，否則為餘數\n        first_group_len = n % K or K\n        # 先取第一組，再取之後每組 K 個字符\n        res = [S[:first_group_len]]\n        for i in range(first_group_len, n, K):\n            res.append(S[i:i+K])\n        return '-'.join(res)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 嘗試將輸入解析為「s = \"string\", k = number」的格式\n    match = re.search(r's\\s*=\\s*[\"\\']([^\"\\']+)[\"\\']\\s*,\\s*k\\s*=\\s*(\\d+)', data)\n    if match:\n        s = match.group(1)\n        k = int(match.group(2))\n    else:\n        # 若不是上述格式，則嘗試兩行輸入：第一行是 s，第二行是 k\n        lines = [line.strip() for line in data.splitlines() if line.strip()]\n        if len(lines) >= 2:\n            s = lines[0].strip('\\'\"')\n            k = int(lines[1])\n        else:\n            # 只有一行輸入，嘗試分隔成字串與整數\n            parts = data.split()\n            # 假設最後一個部分是整數，剩下的是字串\n            k = int(parts[-1])\n            s = ' '.join(parts[:-1]).strip('\\'\"')\n\n    result = Solution().licenseKeyFormatting(s, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"5F3Z-2e-9-w\", k = 4",
          "expected_output": " \"5F3Z-2E9W\"",
          "success": true,
          "output": "5F3Z-2E9W"
        },
        {
          "example_index": 1,
          "input": "s = \"2-5g-3-J\", k = 2",
          "expected_output": "\"2-5G-3J\"",
          "success": true,
          "output": "2-5G-3J"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode373.json",
    "problem_index_in_file": 0,
    "title": "Find K Pairs with Smallest Sums",
    "description_snippet": "You are given two integer arrays nums1 and nums2 sorted in non-decreasing order and an integer k.\n\nD...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code for solution: find k pairs with smallest sums from two sorted arrays. Classic problem: k smallest pairs using min-heap. Steps: use heap of size up to k; push initial pair (0,0). While count<k and heap not empty: pop min; add pair to result; if j+1< n2, push (i, j+1) if not visited; if j==0 and i+1<n1, push (i+1,0). Use visited set to avoid duplicates. But we can simpler: push (i,j) where j increments, we push next j for each i as we pop. Or we can use heap for pairs. Provide virtual code lines.\n\nNeed to produce each line with explanation. Use arrows, decisions. Start, End.\n\nLet's produce step-by-step.\n\n1. Start\n2. Initialize min-heap H and visited set V\n3. If nums1 empty or nums2 empty or k==0: return empty // early exit\n4. Push (0,0) with sum\n5. While result size < k and H not empty:\n6. Pop min from H: (i,j,sum)\n7. Append nums1[i], nums2[j] to result\n8. If j+1 < len(nums2) and (i, j+1) not visited:\n9. Mark visited, push (i, j+1)\n10. If j==0 and i+1 < len(nums1) and (i+1, 0) not visited:\n11. Mark visited, push (i+1, 0)\n12. End loop\n13. End\n\nWe need to include Decision branches. Use Decision for if conditions. Use arrows for steps.\n\nAlso include explanation comments.\n\nLet's craft lines accordingly. Ensure formatting as per requirement. Use virtual code syntax with arrow \"→\". Use \"Decision:\".\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行\n→ Decision: 若 nums1 或 nums2 為空或 k 為 0? // 檢查是否有可處理的輸入\n    Yes → Step 1: 回傳空清單 // 沒有任何可能的對\n    No  → Step 2: 初始化結果 result 為空列表 // 用於存放最小和的 k 個對\n→ Step 3: 初始化最小堆 H 為空，與已訪問集合 V 為空 // 用於追蹤待考慮的 (i, j) 對\n→ Step 4: 將 (0,0, nums1[0]+nums2[0]) 推入 H 並加入 V // 先將第一個對加入堆中\n→ Decision: 是否需要迴圈? (result 長度 < k 且 H 不空)? // 確保還有對可取且未滿足 k 個\n    Yes →\n        → Step 5: 從 H 中取出最小元素 (i, j, sum) // 取得目前和最小的對\n        → Step 6: 將 (nums1[i], nums2[j]) 加入 result // 將對加入最終答案\n        → Decision: 是否能將 (i, j+1) 推入堆? (j+1 < len(nums2) 且 (i, j+1) 未訪問)? // 下一個在第二個陣列的候選\n            Yes → Step 7: 標記 (i, j+1) 為已訪問並推入 H (i, j+1, nums1[i]+nums2[j+1]) // 把同 i 的下一個 j 推入堆\n            No  → // 無操作\n        → Decision: 是否能將 (i+1, 0) 推入堆? (j==0 且 i+1 < len(nums1) 且 (i+1, 0) 未訪問)? // 同 j 為 0 時，推入下一個 i\n            Yes → Step 8: 標記 (i+1, 0) 為已訪問並推入 H (i+1, 0, nums1[i+1]+nums2[0]) // 把同 j 的下一個 i 推入堆\n            No  → // 無操作\n        → // 迴圈結束條件已在 Decision 前檢查\n    No  → // 迴圈結束，已收集 k 個最小對\nEnd // 程式執行結束，返回 result",
      "generated_code": "import sys\nimport re\nimport json\nimport heapq\nfrom typing import List\n\nclass Solution:\n    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\n        \"\"\"\n        找出兩個已排序陣列中，總和最小的 k 個 (nums1[i], nums2[j]) 這對。\n        透過最小堆（priority queue）只維持最小的候選對，時間複雜度為 O(k log k)。\n        \"\"\"\n        if not nums1 or not nums2 or k <= 0:\n            return []\n\n        heap = []                     # 儲存 (sum, i, j) 的最小堆\n        result = []\n\n        # 初始時，只把 nums1 的前 min(k, len(nums1)) 個元素與 nums2 的第 0 個結合放入堆中\n        for i in range(min(k, len(nums1))):\n            heapq.heappush(heap, (nums1[i] + nums2[0], i, 0))\n\n        # 重複取出最小的對，直到得到 k 個\n        while heap and len(result) < k:\n            total, i, j = heapq.heappop(heap)\n            result.append([nums1[i], nums2[j]])\n\n            # 將同一 i 但 j+1 的對加入堆中（若尚未超出 nums2 的長度）\n            if j + 1 < len(nums2):\n                heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n\n        return result\n\ndef parse_input(text: str):\n    \"\"\"\n    從輸入字串中解析出 nums1、nums2 與 k。\n    假設輸入格式類似 'nums1 = [1,7,11], nums2 = [2,4,6], k = 3'。\n    \"\"\"\n    nums1_match = re.search(r'nums1\\s*=\\s*(\\[.*?\\])', text)\n    nums2_match = re.search(r'nums2\\s*=\\s*(\\[.*?\\])', text)\n    k_match    = re.search(r'k\\s*=\\s*(-?\\d+)', text)\n\n    if not (nums1_match and nums2_match and k_match):\n        raise ValueError(\"Invalid input format\")\n\n    nums1 = eval(nums1_match.group(1))\n    nums2 = eval(nums2_match.group(1))\n    k = int(k_match.group(1))\n    return nums1, nums2, k\n\ndef main():\n    # 讀取整個輸入\n    input_text = sys.stdin.read().strip()\n    nums1, nums2, k = parse_input(input_text)\n\n    sol = Solution()\n    ans = sol.kSmallestPairs(nums1, nums2, k)\n\n    # 輸出符合範例格式：不含空格\n    print(json.dumps(ans, separators=(',', ':')))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums1 = [1,7,11], nums2 = [2,4,6], k = 3",
          "expected_output": "[[1,2],[1,4],[1,6]]",
          "success": true,
          "output": "[[1,2],[1,4],[1,6]]"
        },
        {
          "example_index": 1,
          "input": "nums1 = [1,1,2], nums2 = [1,2,3], k = 2",
          "expected_output": "[[1,1],[1,1]]",
          "success": true,
          "output": "[[1,1],[1,1]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode162.json",
    "problem_index_in_file": 0,
    "title": "Find Peak Element",
    "description_snippet": "A peak element is an element that is strictly greater than its neighbors.\n\nGiven a 0-indexed integer...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, not actual code. Use Start, Decision, arrow, etc. Should implement binary search algorithm. Steps: start, set low=0 high=n-1, while low < high: mid = low + (high-low)/2; if nums[mid] < nums[mid+1] then low = mid+1 else high=mid. End: return low.\n\nAlso we might need explanation. Provide each line with virtual code and explanation. Each line: virtual code step followed by // explanation. Use arrow for decision. Should include Start and End. Should not output actual code, just pseudo steps. Ensure each line ends with explanation. Provide proper formatting. Use \"→\" for step. Also indent decisions? Use indentation. Example: \nStart // 程式開始\n→ Step 1: 初始化 low = 0, high = nums.length - 1 // 设定搜索区间\n→ Decision: low < high? // 判断是否需要继续搜索\nYes → Step 2: 计算 mid = (low + high) / 2 // 取中点\n   → Decision: nums[mid] < nums[mid + 1]? // 比较中点与右侧邻居\n   Yes → Step 3: low = mid + 1 // 中点左侧不可能为峰\n   No  → Step 4: high = mid // 中点右侧不可能为峰\nNo → End // 当 low == high，找到峰\n→ Step 5: 返回 low // 返回峰的索引\n\nNeed to include comments for each step. Also mention that nums[-1] and nums[n] are -∞ but not needed in algorithm.\n\nEnsure we keep format: line: \"虛擬碼步驟 // 解釋/說明\". Use arrow.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始\n→ Step 1: 初始化 low = 0, high = nums.length - 1 // 设定二分搜尋的区间范围\n→ Decision: low < high? // 判断区间是否仍然有多于一个元素需要比较\n    Yes → Step 2: 计算 mid = low + (high - low) / 2 // 取当前区间的中点\n        → Decision: nums[mid] < nums[mid + 1]? // 比较中点与右侧邻居\n            Yes → Step 3: low = mid + 1 // 若中点左侧小于右侧，左半区肯定没有峰，移动低边界\n            No  → Step 4: high = mid // 若中点大于等于右侧，右半区肯定没有峰，移动高边界\n    No  → End // 当 low == high，区间已缩小到单个元素，即为峰\n→ Step 5: 返回 low // 输出峰元素的索引（此时 low == high）",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findPeakElement(self, nums):\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] < nums[mid + 1]:\n                left = mid + 1\n            else:\n                right = mid\n        return left\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入（假設格式為類似 \"nums = [1,2,3,1]\"）\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 找到第一個 '['，並從那裡開始到最後一個 ']' 解析為列表\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1 or start > end:\n        print(\"0\")\n        sys.exit(0)\n\n    nums_str = data[start:end+1]\n    try:\n        nums = ast.literal_eval(nums_str)\n    except Exception:\n        print(\"0\")\n        sys.exit(0)\n\n    result = Solution().findPeakElement(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,1]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,1,3,5,6,4]",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode87.json",
    "problem_index_in_file": 0,
    "title": "Scramble String",
    "description_snippet": "We can scramble a string s to get a string t using the following algorithm:\n\nIf the length of the st...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code to determine if s2 is scrambled string of s1. Provide step by step logic. Likely recursion and check if sorted same. We'll create algorithm:\n\nStart\n→ Decision: if lengths unequal? Yes → Step false\n→ Decision: if strings equal? Yes → Step true\n→ Decision: if sorted(s1)!=sorted(s2)? Yes → Step false\n→ For i from 1 to len-1:\n    Decision: if (scramble(s1[0:i], s2[0:i]) and scramble(s1[i:], s2[i:]))? Yes → Step true\n    Decision: if (scramble(s1[0:i], s2[-i:]) and scramble(s1[i:], s2[:-i]))? Yes → Step true\n→ Step false\nEnd\n\nExplain each line. Use virtual code syntax with arrows.\n\nWe must ensure each line has \"虛擬碼步驟 // 解釋\". Use Chinese. Include Start, End. Use Decision, Yes →, No →. Provide loops.\n\nWe need to not output actual code. Just virtual steps. Each line should be one step.\n\nLet's craft.\n\nStart // 程式開始執行\n→ Decision: 如果 s1 與 s2 長度不相等? // 長度不同，不能為亂碼\n    Yes → Step 1: 返回 false // 立即結束\n    No  →\n→ Decision: 如果 s1 與 s2 相等? // 相同字串一定是亂碼\n    Yes → Step 2: 返回 true\n    No  →\n→ Decision: 如果 s1 與 s2 的字符多重集合不同? // 排序後比較\n    Yes → Step 3: 返回 false\n    No  →\n→ Decision: 如果 s1 長度為 1? // 單字元已在前面判斷，這裡不需要\n    No →\n→ For i 取 1 到 len(s1)-1 步驟 // 逐個分割點嘗試\n    → Decision: 是否 s1 前 i 個字符與 s2 前 i 個字符是亂碼 且 s1 後 i 個字符與 s2 後 i 個字符是亂碼?\n        Yes → Step 4: 返回 true // 找到一組合法分割\n        No  →\n    → Decision: 是否 s1 前 i 個字符與 s2 後 i 個字符是亂碼 且 s1 後 i 個字符與 s2 前 i 個字符是亂碼?\n        Yes → Step 5: 返回 true\n        No  →\n→ Step 6: 返回 false // 所有分割都不符合\nEnd // 程式執行結束\n\nBut each step line should be one statement. We need to output each line as separate lines with explanation. Use virtual code style: e.g. \"Start // 程式開始執行\". Next line \"→ Decision: ...\" etc.\n\nHowever, we need to include arrow only at the beginning of each step? The example shows \"→ Step 1: ...\" preceded by arrow. For decision, they also show \"Decision:\" lines. For loop, they didn't show arrow. But we can use \"→ For i 取 1 到 len(s1)-1 步驟 // ...\". It's okay.\n\nMake sure each line has \"虛擬碼步驟 [space] // 解釋\". Provide step numbers maybe. We'll include step labels.\n\nLet's craft final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: 如果 s1 與 s2 長度不相等? // 若長度不同，無法是亂碼  \n  Yes → Step 1: 返回 false // 立即結束  \n  No →  \n→ Decision: 如果 s1 與 s2 相等? // 相同字串一定是合法亂碼  \n  Yes → Step 2: 返回 true  \n  No →  \n→ Decision: 如果 s1 與 s2 的字符多重集合不同? // 排序後比較字符集是否一致  \n  Yes → Step 3: 返回 false  \n  No →  \n→ For i 取 1 到 len(s1)-1 // 嘗試每個可能的分割點  \n  → Decision: s1[0:i] 與 s2[0:i] 為亂碼 且 s1[i:] 與 s2[i:] 為亂碼? // 兩段都保持原順序  \n    Yes → Step 4: 返回 true // 找到合法分割  \n    No →  \n  → Decision: s1[0:i] 與 s2[-i:] 為亂碼 且 s1[i:] 與 s2[:-i] 為亂碼? // 兩段其中一段被交換  \n    Yes → Step 5: 返回 true // 找到合法分割  \n    No →  \n→ Step 6: 返回 false // 所有分割點均不符合亂碼條件  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def isScramble(self, s1: str, s2: str) -> bool:\n        memo = {}\n        def dfs(x, y):\n            if (x, y) in memo:\n                return memo[(x, y)]\n            if x == y:\n                memo[(x, y)] = True\n                return True\n            if sorted(x) != sorted(y):\n                memo[(x, y)] = False\n                return False\n            n = len(x)\n            for i in range(1, n):\n                if dfs(x[:i], y[:i]) and dfs(x[i:], y[i:]):\n                    memo[(x, y)] = True\n                    return True\n                if dfs(x[:i], y[-i:]) and dfs(x[i:], y[:-i]):\n                    memo[(x, y)] = True\n                    return True\n            memo[(x, y)] = False\n            return False\n        return dfs(s1, s2)\n\ndef parse_input(text: str):\n    # Try to extract quoted strings\n    quoted = re.findall(r'\"([^\"]*)\"', text)\n    if len(quoted) >= 2:\n        return quoted[0], quoted[1]\n    # Try to extract strings after s1= and s2=\n    pattern = r's1\\s*=\\s*[\"\\']?([^,\"\\']+)[\"\\']?\\s*,?\\s*s2\\s*=\\s*[\"\\']?([^,\"\\']+)[\"\\']?'\n    match = re.search(pattern, text, re.IGNORECASE)\n    if match:\n        return match.group(1), match.group(2)\n    # Fallback: split by whitespace or comma\n    parts = re.split(r',|\\n', text)\n    parts = [p.strip() for p in parts if p.strip()]\n    if len(parts) >= 2:\n        return parts[0], parts[1]\n    # As last resort, split first line by space\n    parts = text.strip().split()\n    if len(parts) >= 2:\n        return parts[0], parts[1]\n    return \"\", \"\"\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    s1, s2 = parse_input(data)\n    result = Solution().isScramble(s1, s2)\n    print(str(result).lower())",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s1 = \"great\", s2 = \"rgeat\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "s1 = \"abcde\", s2 = \"caebd\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "s1 = \"a\", s2 = \"a\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode34.json",
    "problem_index_in_file": 0,
    "title": "Find First and Last Position of Element in Sorted Array",
    "description_snippet": "Given an array of integers nums sorted in non-decreasing order, find the starting and ending positio...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code lines, step-by-step, with explanations. It's a binary search for left and right boundaries. Should be O(log n). Provide Start, End, Decision, etc. Let's produce lines. Use arrow arrows. Must not output actual code. Provide each line with \"虛擬碼步驟 // 解釋\". Let's design:\n\nStart\n→ Step 1: 設定 low = 0, high = len(nums)-1 // 初始化搜尋範圍\n→ Decision: low <= high? // 確定還有區間可搜尋\n    Yes → Step 2: mid = low + (high-low)//2 // 計算中點\n        Decision: nums[mid] == target? // 找到目標\n            Yes → Step 3: left = mid, right = mid // 暫存目標位置\n            No  → Decision: nums[mid] < target? // 判斷應往右或左\n                Yes → Step 4: low = mid + 1 // 將 low 移至右半區\n                No  → Step 5: high = mid - 1 // 將 high 移至左半區\n→ Decision: low <= high? // 繼續搜尋左/右邊界\n    Yes → Step 6: 重新進行 Step 2-5 直到 low > high\n// 以上步驟找完一次搜尋後還需要確認左、右邊界\n→ Step 7: leftBound = binarySearch(nums, target, findLeft=True) // 搜尋左邊界\n→ Step 8: rightBound = binarySearch(nums, target, findLeft=False) // 搜尋右邊界\n→ Decision: leftBound == -1? // 若左邊界為 -1 表示不存在\n    Yes → Step 9: return [-1, -1] // 目標不存在\n    No  → Step 10: return [leftBound, rightBound] // 回傳左右邊界\nEnd\n\nBut we should structure more elegantly. We can provide functions. But virtual code. Provide each line.\n\nBetter: Write binarySearch function with parameter left or right.\n\nStart\n→ Step 1: 定義函式 binarySearch(nums, target, findLeft) // 通用二分搜尋，findLeft決定搜尋左或右邊界\n    → Step 1.1: low = 0, high = len(nums)-1, ans = -1 // 初始化\n    → Decision: low <= high? \n        Yes → Step 1.2: mid = low + (high-low)//2\n            Decision: nums[mid] == target?\n                Yes → Step 1.3: ans = mid // 更新答案\n                    Decision: findLeft?\n                        Yes → Step 1.4: high = mid - 1 // 搜尋左半\n                        No  → Step 1.5: low = mid + 1 // 搜尋右半\n                No  → Decision: nums[mid] < target?\n                    Yes → Step 1.6: low = mid + 1 // 目標在右\n                    No  → Step 1.7: high = mid - 1 // 目標在左\n    → Decision: low <= high? // 循環\n        Yes → Step 1.8: 轉回 Step 1.2\n    → End of 函式 // 返回 ans\n→ Step 2: left = binarySearch(nums, target, findLeft=True) // 搜尋左邊界\n→ Step 3: right = binarySearch(nums, target, findLeft=False) // 搜尋右邊界\n→ Decision: left == -1? // 若左邊界為 -1，目標不存在\n    Yes → Step 4: return [-1, -1] // 回傳未找到\n    No  → Step 5: return [left, right] // 回傳左右邊界\nEnd\n\nNeed to ensure O(log n). Provide explanation.\n\nLet's format each line as specified: \"虛擬碼步驟 // 解釋\". Use arrow \"→\" at start for steps. For Decision use indentation. Let's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義函式 binarySearch(nums, target, findLeft) // 建立通用二分搜尋，findLeft決定搜尋左或右邊界  \n → Step 1.1: low = 0, high = len(nums)-1, ans = -1 // 初始化搜尋範圍與答案  \n → Decision: low <= high? // 若仍有區間可搜尋  \n  Yes → Step 1.2: mid = low + (high-low)//2 // 計算中點索引  \n   Decision: nums[mid] == target? // 判斷中點是否為目標值  \n    Yes → Step 1.3: ans = mid // 找到目標，暫存索引  \n     Decision: findLeft? // 若尋找左邊界  \n      Yes → Step 1.4: high = mid - 1 // 將高指標移到左半區  \n      No  → Step 1.5: low = mid + 1 // 將低指標移到右半區  \n    No  → Decision: nums[mid] < target? // 中點小於目標，目標在右半  \n     Yes → Step 1.6: low = mid + 1 // 更新低指標  \n     No  → Step 1.7: high = mid - 1 // 更新高指標  \n → Decision: low <= high? // 仍有區間可搜尋  \n  Yes → Step 1.8: 迴到 Step 1.2 // 重複搜尋過程  \n → End of 函式 // 回傳 ans，若未找到則為 -1  \n→ Step 2: left = binarySearch(nums, target, findLeft=True) // 搜尋目標的最左索引  \n→ Step 3: right = binarySearch(nums, target, findLeft=False) // 搜尋目標的最右索引  \n→ Decision: left == -1? // 若左邊界為 -1，代表目標不存在  \n Yes → Step 4: return [-1, -1] // 回傳未找到的結果  \n No  → Step 5: return [left, right] // 回傳左、右邊界  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def searchRange(self, nums, target):\n        \"\"\"返回目標值在 nums 中的最左和最右索引，若不存在則回傳 [-1, -1]。\"\"\"\n        def findLeft(nums, target):\n            left, right = 0, len(nums) - 1\n            index = -1\n            while left <= right:\n                mid = (left + right) // 2\n                if nums[mid] >= target:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n                if nums[mid] == target:\n                    index = mid\n            return index\n\n        def findRight(nums, target):\n            left, right = 0, len(nums) - 1\n            index = -1\n            while left <= right:\n                mid = (left + right) // 2\n                if nums[mid] <= target:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n                if nums[mid] == target:\n                    index = mid\n            return index\n\n        return [findLeft(nums, target), findRight(nums, target)]\n\ndef main():\n    data = sys.stdin.read()\n    # 解析輸入中的 nums 列表\n    list_match = re.search(r'nums\\s*=\\s*(\\[[^\\]]*\\])', data)\n    nums = ast.literal_eval(list_match.group(1)) if list_match else []\n\n    # 解析輸入中的 target 整數\n    target_match = re.search(r'target\\s*=\\s*(-?\\d+)', data)\n    target = int(target_match.group(1)) if target_match else 0\n\n    solution = Solution()\n    result = solution.searchRange(nums, target)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [5,7,7,8,8,10], target = 8",
          "expected_output": "[3,4]",
          "success": true,
          "output": "[3, 4]"
        },
        {
          "example_index": 1,
          "input": "nums = [5,7,7,8,8,10], target = 6",
          "expected_output": "[-1,-1]",
          "success": true,
          "output": "[-1, -1]"
        },
        {
          "example_index": 2,
          "input": "nums = [], target = 0",
          "expected_output": "[-1,-1]",
          "success": true,
          "output": "[-1, -1]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode1.json",
    "problem_index_in_file": 0,
    "title": "Two Sum",
    "description_snippet": "Given an array of integers nums and an integer target, return indices of the two numbers such that t...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for Two Sum problem in plain text lines. Provide steps. Use Start, Decision, End, arrow etc. No actual code. Just the virtual steps. Let's produce algorithm: iterate through array, maintain hash map of value to index, for each number check complement. Return indices. Provide steps with decision.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: 初始化空字典 hashMap // 用來儲存已見數值與其索引\n→ Step 2: 循環遍歷 nums，變量 i 為索引，num 為元素 // 逐個檢查每個數字\n→ Decision: 是否存在 complement = target - num 在 hashMap? // 檢查是否已經看到能配對的數字\n    Yes → Step 3: 返回 [hashMap[complement], i] // 找到答案，輸出索引\n    No  → Step 4: 將 num 與 i 存入 hashMap // 未找到，將當前數字記錄\n→ End // 迴圈結束，若未找到則無解（根據假設不會發生）\n\nBut also need to include arrow indent for Decision. Format: Use `→ Decision:` with nested arrows.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空字典 hashMap // 用來儲存已見數值與其索引  \n→ Step 2: 循環遍歷 nums，變量 i 為索引，num 為元素 // 逐個檢查每個數字  \n→ Decision: 是否存在 complement = target - num 在 hashMap? // 檢查是否已經看到能配對的數字  \n  Yes → Step 3: 返回 [hashMap[complement], i] // 找到答案，輸出索引  \n  No  → Step 4: 將 num 與 i 存入 hashMap // 未找到，將當前數字記錄  \nEnd // 迴圈結束，若未找到則無解（根據假設不會發生）",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def twoSum(self, nums, target):\n        \"\"\"\n        返回兩個數字的索引，使其相加等於目標值。\n        \"\"\"\n        d = {}\n        for i, val in enumerate(nums):\n            comp = target - val\n            if comp in d:\n                return [d[comp], i]\n            d[val] = i\n\ndef main():\n    # 從標準輸入讀取完整內容\n    data = sys.stdin.read().strip()\n\n    # 解析 nums 列表\n    nums_match = re.search(r'nums\\s*=\\s*\\[([^\\]]*)\\]', data)\n    # 解析 target 整數\n    target_match = re.search(r'target\\s*=\\s*(-?\\d+)', data)\n\n    if not nums_match or not target_match:\n        print(\"Invalid input format\")\n        return\n\n    nums_str = nums_match.group(1)\n    nums = [int(x.strip()) for x in nums_str.split(',') if x.strip() != '']\n    target = int(target_match.group(1))\n\n    sol = Solution()\n    indices = sol.twoSum(nums, target)\n\n    # 按示例輸出格式（無空格）\n    print(f'[{indices[0]},{indices[1]}]')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,7,11,15], target = 9",
          "expected_output": "[0,1]",
          "success": true,
          "output": "[0,1]"
        },
        {
          "example_index": 1,
          "input": "nums = [3,2,4], target = 6",
          "expected_output": "[1,2]",
          "success": true,
          "output": "[1,2]"
        },
        {
          "example_index": 2,
          "input": "nums = [3,3], target = 6",
          "expected_output": "[0,1]",
          "success": true,
          "output": "[0,1]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode354.json",
    "problem_index_in_file": 0,
    "title": "Russian Doll Envelopes",
    "description_snippet": "You are given a 2D array of integers envelopes where envelopes[i] = [w_i, h_i] represents the width ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step. Input: 2D array of envelopes. We want maximum number of envelopes that can be nested (Russian Doll). Classic problem: sort by width ascending, height descending for equal widths, then longest increasing subsequence on heights.\n\nWe need to output step-by-step virtual code lines with explanation.\n\nLet's produce: Start, sort, then iterate and compute LIS via patience sorting.\n\nWe will show lines: Start // program starts; → Step 1: Sort envelopes by width ascending and height descending // to avoid counting same width; → Step 2: Initialize empty array tails // store minimal ending height of LIS of each length; → Step 3: For each envelope in sorted array: extract height; → Step 4: Find position in tails via binary search (lower_bound) // to maintain increasing heights; → Step 5: If pos equals length of tails: append height; else replace tails[pos] with height; → After loop: Step 6: Result = length of tails; → End.\n\nAdd explanation comments.\n\nWe must follow format: \"Start // 程式開始執行\" etc.\n\nWe need to ensure each line is one step with comment. Use arrows. For loops, we need indentation lines? The example uses indentation for nested decisions. We can use \"→ Step 3: For each envelope in sorted array\" then sub-indentation for body. Or use indentation for body lines. In example they use indentation for nested steps. We'll follow.\n\nAlso decision: maybe binary search is decision; we can incorporate as Decision: but we can keep as simple.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: Sort envelopes by ascending width; if widths equal, sort by descending height // 先排序，方便後續 LIS\n→ Step 2: Initialize empty array tails // 用來儲存每個長度的最小結尾高度\n→ Step 3: For each envelope in sorted envelopes\n    → Step 3.1: height ← envelope.height // 取得目前信封的高度\n    → Step 3.2: pos ← BinarySearch(tails, height) // 在 tails 找第一個 ≥ height 的位置\n    → Decision: pos == length of tails? // 是否需要擴充 LIS\n        Yes → Step 3.3: Append height to tails // 新的長度\n        No  → Step 3.4: Replace tails[pos] with height // 更新更小的結尾高度\n→ Step 4: result ← length of tails // 最長遞增子序列長度即為最大信封數\nEnd // 程式執行結束\n\nBut we must adhere to format: each line must have '虛擬碼步驟' + space + comment. Indentation indicated by spaces. We'll produce exactly as example.\n\nWe also need to include \"Decision:\" lines with Yes/No arrow.\n\nWe should keep consistent arrow use. In example they used \"→ Decision: ... // comment\" then indented lines with \"Yes →\" etc. We'll mimic.\n\nThus lines:\n\nStart // 程式開始執行\n→ Step 1: Sort envelopes by width ascending, height descending // 先排序，方便後續計算\n→ Step 2: Initialize empty array tails // 用來儲存每個長度的最小結尾高度\n→ Step 3: For each envelope in sorted envelopes\n    → Step 3.1: height ← envelope.height // 取得高度\n    → Step 3.2: pos ← BinarySearch(tails, height) // 找第一個 ≥ height 的位置\n    → Decision: pos == length(tails)? // 檢查是否需要擴充 LIS\n        Yes → Step 3.3: Append height to tails // 新增一個長度\n        No  → Step 3.4: Replace tails[pos] with height // 更新更小的結尾高度\n→ Step 4: result ← length(tails) // 最長遞增子序列長度即為答案\nEnd // 程式執行結束\n\nCheck format: each line must have step text then comment. Indentation uses spaces, we must keep. Use arrow for each step: \"→\". For decisions: \"Decision: ...\". Then Yes/No arrows.\n\nAlso we might include step names like \"BinarySearch\" function but not actual code.\n\nOk produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort envelopes by width ascending, height descending // 先排序，方便後續計算  \n→ Step 2: Initialize empty array tails // 用來儲存每個長度的最小結尾高度  \n→ Step 3: For each envelope in sorted envelopes  \n  → Step 3.1: height ← envelope.height // 取得高度  \n  → Step 3.2: pos ← BinarySearch(tails, height) // 找第一個 ≥ height 的位置  \n  → Decision: pos == length(tails)? // 檢查是否需要擴充 LIS  \n   Yes → Step 3.3: Append height to tails // 新增一個長度  \n   No  → Step 3.4: Replace tails[pos] with height // 更新更小的結尾高度  \n→ Step 4: result ← length(tails) // 最長遞增子序列長度即為答案  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport bisect\n\ndef read_envelopes():\n    \"\"\"從 stdin 讀取信封列表。\"\"\"\n    raw = sys.stdin.read()\n    # 找到第一個 '[' 作為列表開頭\n    idx = raw.find('[')\n    if idx == -1:\n        return []\n    list_part = raw[idx:]\n    try:\n        return ast.literal_eval(list_part)\n    except Exception:\n        return []\n\ndef max_envelopes(envelopes):\n    \"\"\"計算最大可遞歸放入信封的數量。\"\"\"\n    if not envelopes:\n        return 0\n    # 先按寬度升序，如果寬度相同，按高度降序\n    envelopes.sort(key=lambda x: (x[0], -x[1]))\n    dp = []\n    for _, h in envelopes:\n        idx = bisect.bisect_left(dp, h)\n        if idx == len(dp):\n            dp.append(h)\n        else:\n            dp[idx] = h\n    return len(dp)\n\nif __name__ == \"__main__\":\n    envelopes = read_envelopes()\n    result = max_envelopes(envelopes)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "envelopes = [[5,4],[6,4],[6,7],[2,3]]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "envelopes = [[1,1],[1,1],[1,1]]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode233.json",
    "problem_index_in_file": 0,
    "title": "Number of Digit One",
    "description_snippet": "Given an integer n, count the total number of digit 1 appearing in all non-negative integers less th...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for counting number of digit '1' appearing in all numbers from 0 to n. That's classic problem. The algorithm: iterate through each digit position (ones, tens, hundreds). For each position, compute high, cur, low. Count accordingly. We'll produce virtual code with steps: Input n, if n<0 then error. Set count=0. For position=1; position <= n; position*=10: high = n / (position*10); cur = (n / position) %10; low = n % position. Then if cur==0: count += high * position. else if cur==1: count += high*position + low +1. else: count += (high+1)*position. After loop, output count. We'll use virtual code with arrows.\n\nWe need to provide explanation for each line.\n\nWe need to use virtual code lines, with arrow '→', and include \"Decision:\" where needed. We'll show steps like Start, Input, Decision if n<0? Then maybe error; else continue. Use loops. Use Decision for cur==0? etc.\n\nWe need \"逐行\" output, each line: Virtual Code step + space + comment.\n\nMake sure to include \"→\" arrow lines, indent decisions. Use \"Decision:\" lines with Yes → and No →. Indentation? Not specified, but sample shows indent with spaces. We'll follow similar style.\n\nLet's craft.\n\nLine 1: Start // 程式開始執行\n\nLine 2: → Step 1: 輸入整數 n // 從使用者取得整數\n\nLine 3: → Decision: n < 0? // 檢查輸入是否為負數\n\nLine 4:     Yes → Step 2: 顯示錯誤訊息並結束 // 若負數，報錯並結束\n\nLine 5:     No → Step 3: 初始化計數器 count = 0 // 先設為 0\n\nLine 6: → Step 4: 設置變數 position = 1 // 從個位開始\n\nLine 7: → Decision: position <= n? // 判斷是否還有更高位\n\nLine 8:     Yes → Step 5: 計算 high = n / (position*10) // 高位數\n\nLine 9:     → Step 6: 計算 cur = (n / position) % 10 // 當前位數\n\nLine 10:    → Step 7: 計算 low = n % position // 低位數\n\nLine 11:    → Decision: cur == 0? // 判斷當前位為 0\n\nLine 12:        Yes → Step 8: count += high * position // 加入高位個數乘位值\n\nLine 13:        No → Decision: cur == 1? // 判斷當前位為 1\n\nLine 14:            Yes → Step 9: count += high * position + low + 1 // 高位個數*位值 + 低位+1\n\nLine 15:            No → Step 10: count += (high + 1) * position // 高位+1乘位值\n\nLine 16:    → Step 11: position *= 10 // 移動到更高位\n\nLine 17:    → Decision: position <= n? // 回到第7步判斷\n\nLine 18: End // 程式結束\n\nBut need to ensure the steps are sequential; Step 11 maybe after Decision; but arrow may go back. Use loops: we can express with Decision: position <= n? Yes → Step 5 ... No → End. That could be simpler: after Step 11 update position, then loop back to Decision: position <= n? with Yes go to Step 5, No go to End. But we need \"逐行\" and each line separate.\n\nLet's restructure with a loop. Let's produce code lines with labels maybe: \"Step 5\" as loop entry, then \"Step 6\" etc. But we can keep same as above, but at line 17 we need to go back to Step 5. We can show \"Decision: position <= n? // ... Yes → Step 5: ...\" Actually we used Step 5 earlier; but we can rename Step 5 to \"Loop:\".\n\nBetter: We'll use \"Step 5: 進入迴圈\" then Step 6 etc. Then after Step 11 update position, we go to Decision: position <= n? Yes → Step 5. But we already used Step 5 as entry. It's okay.\n\nLet's write final lines accordingly.\n\nMake sure each line ends with // 解釋. Use comments in Chinese.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入整數 n // 從使用者取得整數  \n→ Decision: n < 0? // 檢查輸入是否為負數  \n Yes → Step 2: 顯示錯誤訊息並結束 // 若負數，報錯並結束  \n No  → Step 3: 初始化計數器 count = 0 // 先設為 0  \n→ Step 4: 設置變數 position = 1 // 從個位開始  \n→ Decision: position <= n? // 判斷是否還有更高位  \n Yes → Step 5: 計算 high = n / (position * 10) // 高位數  \n  → Step 6: 計算 cur = (n / position) % 10 // 當前位數  \n  → Step 7: 計算 low = n % position // 低位數  \n  → Decision: cur == 0? // 判斷當前位為 0  \n   Yes → Step 8: count += high * position // 加入高位個數乘位值  \n   No  → Decision: cur == 1? // 判斷當前位為 1  \n    Yes → Step 9: count += high * position + low + 1 // 高位個數*位值 + 低位+1  \n    No  → Step 10: count += (high + 1) * position // 高位+1乘位值  \n  → Step 11: position *= 10 // 移動到更高位  \n  → Decision: position <= n? // 回到迴圈判斷  \n   Yes → Step 5 // 進入下一位的計算  \n   No  → End // 所有位數已處理完畢  \nEnd // 程式結束。",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def countDigitOne(self, n: int) -> int:\n        if n <= 0:\n            return 0\n        count = 0\n        i = 1\n        while i <= n:\n            divider = i * 10\n            count += (n // divider) * i + min(max(n % divider - i + 1, 0), i)\n            i *= 10\n        return count\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Extract integer from input, e.g., \"n = 13\" or just \"13\"\n    match = re.search(r'-?\\d+', data)\n    if not match:\n        return\n    n = int(match.group())\n    result = Solution().countDigitOne(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 13",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "n = 0",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode299.json",
    "problem_index_in_file": 0,
    "title": "Bulls and Cows",
    "description_snippet": "You are playing the Bulls and Cows game with your friend.\n\nYou write down a secret number and ask yo...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode line by line for the Bulls and Cows problem, with comments. Use Start, Decision, Yes→, No→. We must not output real code. Just virtual steps with arrow. Should be in Traditional Chinese. Let's produce steps:\n\nStart\n→ Initialize bulls = 0, cows = 0\n→ For each index i from 0 to len(secret)-1:\n    → Decision: If secret[i] == guess[i]?\n        Yes → Increment bulls\n        No  → Add secret[i] to secret_counts map (or array), and guess[i] to guess_counts map\n→ After loop, compute cows:\n    → For each digit d in 0-9:\n        → Decision: If both secret_counts[d] and guess_counts[d] > 0?\n            Yes → cows += min(secret_counts[d], guess_counts[d])\n            No  → nothing\n→ Construct hint string as bulls + 'A' + cows + 'B'\n→ End\n\nWe need to use virtual arrow syntax exactly. Each line \"虛擬碼步驟 [空格] // 解釋\". Use arrow (→). For decisions we need indent with 4 spaces? In example indent uses spaces. Let's replicate style:\n\nStart // 程式開始執行\n→ Initialize bulls = 0, cows = 0 // 記錄老鼠數量\n→ For each index i in 0 to len(secret)-1:\n    → Decision: secret[i] == guess[i]? // 判斷是否為老鼠\n        Yes → Increment bulls // 符合位置的相同數字\n        No  → Add secret[i] to secret_counts // 收集非老鼠的數字\n        No  → Add guess[i] 到 guess_counts // 收集非老鼠的數字\n→ After loop, compute cows:\n    → For each digit d in 0 to 9:\n        → Decision: secret_counts[d] >0 AND guess_counts[d]>0?\n            Yes → cows += min(secret_counts[d], guess_counts[d]) // 計算雜種\n→ Construct hint string = bulls + 'A' + cows + 'B' // 形成輸出\n→ End // 結束\n\nNeed to be careful about indent and arrow placements. Each line after Start should have a single arrow (→). Indented blocks also have arrows. The example shows nested Decision lines indented by 4 spaces and arrow after indent. Use same style.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Initialize bulls = 0, cows = 0 // 記錄「老鼠」數量  \n→ For each index i in 0 to len(secret)-1: // 逐位比對  \n    → Decision: secret[i] == guess[i]? // 判斷此位是否為老鼠  \n        Yes → Increment bulls // 位數相同且位置正確  \n        No  → Add secret[i] to secret_counts // 收集非老鼠的秘密數字  \n        No  → Add guess[i] to guess_counts // 收集非老鼠的猜測數字  \n→ After loop, compute cows: // 計算「奶牛」數量  \n    → For each digit d in 0 to 9: // 遍歷 0~9  \n        → Decision: secret_counts[d] > 0 AND guess_counts[d] > 0? // 同時存在  \n            Yes → cows += min(secret_counts[d], guess_counts[d]) // 取最小個數  \n→ Construct hint string = bulls + 'A' + cows + 'B' // 產生輸出格式  \n→ End // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\ndef get_hint(secret: str, guess: str) -> str:\n    \"\"\"計算 bulls 與 cows 並返回 'xAyB' 格式的提示。\"\"\"\n    bulls = 0\n    cows = 0\n\n    # 先建立所有數字的頻率表\n    secret_count = Counter(secret)\n    guess_count = Counter(guess)\n\n    # 第一輪：統計老鼠 (bulls)，並把已計算的字元從頻率表中扣除\n    for s, g in zip(secret, guess):\n        if s == g:\n            bulls += 1\n            secret_count[s] -= 1\n            guess_count[g] -= 1\n\n    # 第二輪：統計奶牛 (cows)，取兩個頻率表相同數字的最小值\n    for digit in guess_count:\n        if digit in secret_count:\n            cows += min(secret_count[digit], guess_count[digit])\n\n    return f\"{bulls}A{cows}B\"\n\ndef main() -> None:\n    \"\"\"從標準輸入讀取 secret 與 guess，輸出提示。\"\"\"\n    data = sys.stdin.read()\n\n    # 以雙引號包裹的字串提取 secret 與 guess\n    values = re.findall(r'\"(.*?)\"', data)\n    if len(values) >= 2:\n        secret, guess = values[0], values[1]\n    else:\n        # 失敗時備用：解析類似 'secret = \"1807\", guess = \"7810\"' 的文字\n        secret = guess = \"\"\n        for part in data.split(','):\n            part = part.strip()\n            if part.startswith(\"secret\"):\n                secret = part.split('=')[1].strip().strip('\"')\n            elif part.startswith(\"guess\"):\n                guess = part.split('=')[1].strip().strip('\"')\n\n    # 產生並輸出結果\n    result = get_hint(secret, guess)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "secret = \"1807\", guess = \"7810\"",
          "expected_output": "\"1A3B\"",
          "success": true,
          "output": "1A3B"
        },
        {
          "example_index": 1,
          "input": "secret = \"1123\", guess = \"0111\"",
          "expected_output": "\"1A1B\"",
          "success": true,
          "output": "1A1B"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode486.json",
    "problem_index_in_file": 0,
    "title": "Predict the Winner",
    "description_snippet": "You are given an integer array nums. Two players are playing a game with this array: player 1 and pl...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps line by line with explanation. The task: determine if player1 can win given optimal play. Standard DP solution: DP[i][j] maximum difference in score that current player can achieve over opponent on subarray [i,j]. Recurrence: DP[i][j] = max(nums[i]-DP[i+1][j], nums[j]-DP[i][j-1]). If DP[0][n-1] >=0 return true.\n\nWe need virtual code steps: Start, step to compute DP table. Since need virtual code, can describe algorithm in steps, not actual code. Use arrows. Provide explanation per line.\n\nLet's produce steps:\n\nStart\n→ Step 1: Determine n = length(nums) // size\n→ Decision: If n == 0? // empty array\n    Yes → Step 2: Return true // no score difference, player1 wins by tie\n    No  → Continue\n→ Step 3: Initialize 2D array diff[n][n] // to store score differences\n→ Step 4: For i from 0 to n-1: diff[i][i] = nums[i] // single element subarray\n→ Step 5: For len from 2 to n: // subarray length\n    → For i from 0 to n-len:\n        j = i + len - 1\n        // compute diff[i][j]\n        → Step 6: pickLeft = nums[i] - diff[i+1][j]\n        → Step 7: pickRight = nums[j] - diff[i][j-1]\n        → Step 8: diff[i][j] = max(pickLeft, pickRight)\n→ Step 9: finalDiff = diff[0][n-1] // overall difference for player1\n→ Decision: If finalDiff >= 0? // player1's score >= player2\n    Yes → Step 10: Return true\n    No  → Step 11: Return false\nEnd\n\nWe should add explanations per line.\n\nMake sure format: each line: \"虛擬碼步驟 // 解釋\". Use arrow syntax: \"→\". Use indentation? Might use spaces for indentation of nested steps. Use \"Decision:\" lines for branching.\n\nLet's craft lines.\n\nAlso need to mention DP logic. Use comments.\n\nLet's output.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← length(nums) // 取得陣列長度  \n→ Decision: 如果 n 為 0? // 空陣列時直接輸贏  \n  Yes → Step 2: Return true // 沒有數字，分數相等，Player 1 勝  \n  No  → Continue  \n→ Step 3: 初始化 2D 陣列 diff[n][n] // 用於存放分數差值  \n→ Step 4: 對 i 從 0 到 n-1 進行: diff[i][i] ← nums[i] // 單一元素子陣列的差值即為該元素  \n→ Step 5: 對 subLen 從 2 到 n 進行: // 計算不同長度的子陣列  \n  → 對 i 從 0 到 n-subLen 進行: // 子陣列左端索引  \n   j ← i + subLen - 1 // 右端索引  \n   // 計算子陣列 [i, j] 的最大分數差值  \n   → Step 6: pickLeft ← nums[i] - diff[i+1][j] // 選左邊的數，之後對手的最佳差值為 diff[i+1][j]  \n   → Step 7: pickRight ← nums[j] - diff[i][j-1] // 選右邊的數，之後對手的最佳差值為 diff[i][j-1]  \n   → Step 8: diff[i][j] ← max(pickLeft, pickRight) // 取可得到最大差值的選擇  \n→ Step 9: finalDiff ← diff[0][n-1] // 整個陣列的最終分數差值  \n→ Decision: 如果 finalDiff ≥ 0? // Player 1 的分數不小於 Player 2  \n  Yes → Step 10: Return true // Player 1 贏或平手也算勝利  \n  No  → Step 11: Return false // Player 1 失敗  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def predictTheWinner(self, nums):\n        n = len(nums)\n        # dp[i][j] 表示在區間 [i, j] 內，先手玩家比後手玩家多贏的分數差\n        dp = [[0] * n for _ in range(n)]\n        \n        # 單個元素時，分數差就是該元素本身\n        for i in range(n):\n            dp[i][i] = nums[i]\n        \n        # 從長度 2 開始遞增計算\n        for length in range(2, n + 1):\n            for i in range(n - length + 1):\n                j = i + length - 1\n                # 先手可以選左邊或右邊，對手則會再次以最優策略\n                take_left  = nums[i] - dp[i + 1][j]\n                take_right = nums[j] - dp[i][j - 1]\n                dp[i][j] = max(take_left, take_right)\n        \n        # 若最終差值 >= 0，表示先手玩家分數不遜於後手\n        return dp[0][n - 1] >= 0\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    if not data:\n        sys.exit(0)\n    # 從輸入字串中提取數字列表\n    start = data.find('[')\n    end = data.rfind(']')\n    nums = ast.literal_eval(data[start:end + 1])\n    \n    sol = Solution()\n    result = sol.predictTheWinner(nums)\n    print('true' if result else 'false')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,5,2]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 1,
          "input": "nums = [1,5,233,7]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode338.json",
    "problem_index_in_file": 0,
    "title": "Counting Bits",
    "description_snippet": "Given an integer n, return an array ans of length n + 1 such that for each i (0 <= i <= n), ans[i] i...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code steps with explanations per line. Let's design algorithm: For i from 0 to n, count ones in binary of i. Use dp: ans[i] = ans[i>>1] + (i & 1). Start with ans[0]=0. So steps: Start, Input n, Allocate ans array of size n+1, ans[0]=0, For i from 1 to n: ans[i] = ans[i>>1] + (i & 1). End. Also maybe we can compute via loop and counting bits, but dp is efficient. Provide each step line with explanation. Also include decision if n < 0? maybe. We'll keep simple.\n\nLet's produce lines:\n\nStart // 程式開始執行\n\n→ Step 1: 輸入整數 n // 取得使用者輸入\n\n→ Decision: 如果 n < 0? // 檢查輸入是否合法\n\n    Yes → Step 2: 輸出錯誤訊息 // 非負數才合法\n\n    No → Step 3: 建立 ans 陣列長度 n+1 // 準備儲存結果\n\n        → Step 4: 設定 ans[0] = 0 // 0 的二進位位元 1 的數量為 0\n\n        → Step 5: 循環 i 從 1 到 n // 計算每個數字的 1 的個數\n\n            → Step 6: 計算 ans[i] = ans[i >> 1] + (i & 1) // 使用 dp 取得答案\n\n        → Step 7: 輸出 ans 陣列 // 將結果回傳給使用者\n\nEnd // 程式執行結束\n\nAdd arrow for for loop etc. Provide each line. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入整數 n // 取得使用者輸入的整數  \n→ Decision: n 是否小於 0? // 檢查輸入是否合法  \n  Yes → Step 2: 輸出錯誤訊息 // 若 n 為負數，顯示錯誤並結束  \n  No → Step 3: 建立 ans 陣列長度 n+1 // 準備儲存 0~n 的 1 的數量  \n    → Step 4: 設定 ans[0] = 0 // 0 的二進位中 1 的個數為 0  \n    → Step 5: 循環 i 從 1 到 n // 逐個計算每個數字的 1 的個數  \n      → Step 6: 計算 ans[i] = ans[i >> 1] + (i & 1) // dp：右移一位後的結果加上最低位  \n    → Step 7: 輸出 ans 陣列 // 回傳整個結果給使用者  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def countBits(self, n: int):\n        # 建立長度為 n+1 的結果陣列，初始值皆為 0\n        res = [0] * (n + 1)\n        # 從 1 開始計算，使用動態規劃公式\n        for i in range(1, n + 1):\n            # i 的右移一位（相當於除以 2）已經計算過，取其結果再加上最低位的 1\n            res[i] = res[i >> 1] + (i & 1)\n        return res\n\ndef parse_n(input_str: str) -> int:\n    \"\"\"\n    從輸入字串中抓取第一個整數，假設輸入類似於 'n = 5' 或 '5' 等。\n    \"\"\"\n    match = re.search(r'-?\\d+', input_str)\n    if not match:\n        raise ValueError(\"No integer found in input.\")\n    return int(match.group())\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個內容\n    raw_input = sys.stdin.read()\n    # 解析出整數 n\n    n = parse_n(raw_input)\n    # 呼叫解法\n    solution = Solution()\n    result = solution.countBits(n)\n    # 輸出結果至標準輸出\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 2",
          "expected_output": "[0,1,1]",
          "success": true,
          "output": "[0, 1, 1]"
        },
        {
          "example_index": 1,
          "input": "n = 5",
          "expected_output": "[0,1,1,2,1,2]",
          "success": true,
          "output": "[0, 1, 1, 2, 1, 2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode846.json",
    "problem_index_in_file": 0,
    "title": "leetcode846_problem_1",
    "description_snippet": "Alice has some number of cards and she wants to rearrange the cards into groups so that each group i...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps for solving the problem: Determine if array hand can be rearranged into groups of size groupSize, each group containing consecutive numbers. This is the Leetcode 846. Approach: sort hand, count frequencies using a map, iterate sorted keys, for each key try to use freq in consecutive blocks of groupSize. Pseudocode steps with decisions. Need to produce step-by-step. We'll include Start, End. For each step: \"Step X:\" etc.\n\nMake sure we use arrows and decisions. Provide short explanation.\n\nLet's craft steps:\n\nStart\n\n→ Step 1: Initialize frequency map from hand values // count occurrences\n\n→ Step 2: Sort unique values ascending // to process in order\n\n→ Decision: For each value in sorted list // iterate\n\n    → Step 3: Retrieve count for current value // freq\n\n    → Decision: If count == 0? // already used in previous groups\n\n        Yes → Continue to next value // skip\n\n        No → Step 4: For i = 0 to groupSize-1\n\n                → Step 5: target = current_value + i\n\n                → Decision: If freq_map[target] < count? // insufficient cards for consecutive group\n\n                    Yes → Return false // cannot form groups\n\n                    No → Continue\n\n        → Step 6: For i = 0 to groupSize-1\n\n                → Step 7: target = current_value + i\n\n                → Step 8: Decrease freq_map[target] by count // remove used cards\n\n→ End // all values processed, return true\n\nNeed to include return true at end.\n\nLet's produce lines with comments.\n\nEnsure we maintain \"Decision:\" lines only for if statements, use \"Yes →\" \"No →\". For loops, we can use \"→ For i = 0 to groupSize-1\" as a step, but need to keep within structure. We can use nested loops as separate steps.\n\nWe must keep each line with virtual code and comment. So each line will be like:\n\n→ Step 1: freq_map = count frequencies of hand // create frequency map\n\nBut we must preserve arrow. Example from example uses \"→ Step 1:\".\n\nFor decision, we must indent properly. Let's produce as:\n\n→ Decision: if groupSize == 0? // invalid case\n\nBut that's not necessary.\n\nLet's produce final.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: freq_map = count frequencies of hand // 先統計每張牌出現的次數  \n→ Step 2: unique_vals = sorted keys of freq_map // 依數值升序排列  \n\n→ Decision: 逐一檢查每個 unique_vals  \n    → Step 3: current = unique_vals[i] // 取目前處理的牌值  \n    → Step 4: count = freq_map[current] // 取得該牌目前還剩的數量  \n    → Decision: 如果 count == 0? // 這個牌值已被完全使用  \n        Yes → Continue // 跳過此牌值  \n        No → Step 5: For offset = 0 to groupSize - 1 // 檢查接續的 groupSize 張牌  \n                → Step 6: target = current + offset // 目標牌值  \n                → Decision: 如果 freq_map[target] < count? // 需要的牌不夠  \n                    Yes → End // 回傳 false，無法組成合法組合  \n                    No → Continue // 仍可使用  \n        → Step 7: For offset = 0 to groupSize - 1 // 移除已使用的牌  \n                → Step 8: target = current + offset  \n                → Step 9: freq_map[target] = freq_map[target] - count // 減少剩餘數量  \n\nEnd // 所有牌都檢查完畢，回傳 true，表示可重新排列成合法組合",
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\nclass Solution:\n    def isNStraightHand(self, hand, groupSize):\n        # 先判斷手牌數量能否被 groupSize 整除\n        if len(hand) % groupSize != 0:\n            return False\n        \n        # 用 Counter 統計每張牌的出現次數\n        count = Counter(hand)\n        \n        # 依照牌值升序處理，確保每一步都能形成連續序列\n        for card in sorted(count):\n            freq = count[card]\n            if freq == 0:\n                continue  # 這張牌已經被消耗完\n            # 檢查從 card 開始的連續 groupSize 張牌是否足夠\n            for i in range(card, card + groupSize):\n                if count[i] < freq:\n                    return False\n                count[i] -= freq  # 消耗對應數量\n        return True\n\ndef parse_input(data: str):\n    \"\"\"從輸入文字中解析 hand 與 groupSize。\"\"\"\n    # 先找 hand 的列表\n    hand_match = re.search(r'hand\\s*=\\s*\\[([^\\]]*)\\]', data)\n    if not hand_match:\n        raise ValueError(\"Cannot find hand in input.\")\n    hand_str = hand_match.group(1).strip()\n    if hand_str:\n        hand = [int(x.strip()) for x in hand_str.split(',')]\n    else:\n        hand = []\n\n    # 找 groupSize\n    gs_match = re.search(r'groupSize\\s*=\\s*(-?\\d+)', data)\n    if not gs_match:\n        raise ValueError(\"Cannot find groupSize in input.\")\n    groupSize = int(gs_match.group(1))\n    return hand, groupSize\n\nif __name__ == \"__main__\":\n    # 讀取所有輸入\n    raw_data = sys.stdin.read()\n    hand, groupSize = parse_input(raw_data)\n\n    solution = Solution()\n    result = solution.isNStraightHand(hand, groupSize)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "hand = [1,2,3,6,2,3,4,7,8], groupSize = 3",
          "expected_output": "True",
          "success": true,
          "output": "True"
        },
        {
          "example_index": 1,
          "input": "hand = [1,2,3,4,5], groupSize = 4",
          "expected_output": "False",
          "success": true,
          "output": "False"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode88.json",
    "problem_index_in_file": 0,
    "title": "Merge Sorted Array",
    "description_snippet": "You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to merge two sorted arrays in-place into nums1, using back-pointer. Must adhere to format: each line \"虛擬碼步驟 // 解釋\". Use arrow \"→\", \"Start\", \"End\", \"Decision:\".\n\nWe must be thorough: Steps: start, set pointers i=m-1, j=n-1, k=m+n-1. While i>=0 or j>=0: decision j<0? etc. Actually we need while i>=0 and j>=0: compare. After loop, if j>=0 copy remaining nums2 elements. Then End.\n\nLet's produce. Ensure each line has one step. Use arrows for decisions. Provide explanation.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 i ← m-1, j ← n-1, k ← m+n-1 // 初始化三個指標，分別指向 nums1、nums2 的最後一個有效元素與合併後陣列的最後位置  \n→ Decision: i < 0? // 檢查 nums1 是否已經處理完  \n    Yes → Decision: j < 0? // 若 nums1 先空，確認 nums2 是否也已空  \n        Yes → End // 若兩個陣列都空，合併完成  \n        No  → → Step 2: nums1[k] ← nums2[j]; k ← k-1; j ← j-1 // 把剩餘 nums2 的元素拷貝到 nums1  \n        No → Decision: i < 0? // 若 nums1 先空，直接拷貝 nums2  \n→ Decision: j < 0? // 檢查 nums2 是否已經處理完  \n    Yes → → Step 3: nums1[k] ← nums1[i]; k ← k-1; i ← i-1 // 把剩餘 nums1 的元素拷貝到 nums1（實際上不改變）  \n    No  → → Step 4: 比較 nums1[i] 與 nums2[j]  \n        → Decision: nums1[i] > nums2[j]? // 決定將哪個元素放入 nums1[k]  \n            Yes → → Step 5: nums1[k] ← nums1[i]; i ← i-1 // 把較大的 nums1 元素放到最末位  \n            No  → → Step 6: nums1[k] ← nums2[j]; j ← j-1 // 把較大的 nums2 元素放到最末位  \n        → Step 7: k ← k-1 // 移動合併指標  \n→ Step 8: 回到 Decision: i < 0? 或 j < 0? // 重複上述決策直到兩個陣列都被處理完  \nEnd // 程式執行結束，nums1 已完成合併並排序完成",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def merge(self, nums1, m, nums2, n):\n        i = m - 1\n        j = n - 1\n        k = m + n - 1\n        while i >= 0 and j >= 0:\n            if nums1[i] > nums2[j]:\n                nums1[k] = nums1[i]\n                i -= 1\n            else:\n                nums1[k] = nums2[j]\n                j -= 1\n            k -= 1\n        while j >= 0:\n            nums1[k] = nums2[j]\n            j -= 1\n            k -= 1\n\ndef parse_input(input_str):\n    # Extract nums1 list\n    nums1_match = re.search(r'nums1\\s*=\\s*(\\[[^\\]]*\\])', input_str)\n    nums1 = eval(nums1_match.group(1)) if nums1_match else []\n\n    # Extract nums2 list\n    nums2_match = re.search(r'nums2\\s*=\\s*(\\[[^\\]]*\\])', input_str)\n    nums2 = eval(nums2_match.group(1)) if nums2_match else []\n\n    # Extract m and n\n    m_match = re.search(r'm\\s*=\\s*(-?\\d+)', input_str)\n    m = int(m_match.group(1)) if m_match else 0\n\n    n_match = re.search(r'n\\s*=\\s*(-?\\d+)', input_str)\n    n = int(n_match.group(1)) if n_match else 0\n\n    return nums1, m, nums2, n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    if not data.strip():\n        sys.exit()\n    nums1, m, nums2, n = parse_input(data)\n\n    sol = Solution()\n    sol.merge(nums1, m, nums2, n)\n\n    print(nums1)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3",
          "expected_output": "[1,2,2,3,5,6]",
          "success": true,
          "output": "[1, 2, 2, 3, 5, 6]"
        },
        {
          "example_index": 1,
          "input": "nums1 = [1], m = 1, nums2 = [], n = 0",
          "expected_output": "[1]",
          "success": true,
          "output": "[1]"
        },
        {
          "example_index": 2,
          "input": "nums1 = [0], m = 0, nums2 = [1], n = 1",
          "expected_output": "[1]",
          "success": true,
          "output": "[1]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode1009.json",
    "problem_index_in_file": 0,
    "title": "Complement of Base 10 Integer",
    "description_snippet": "The complement of an integer is the integer you get when you flip all the 0's to 1's and all the 1's...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for computing complement of an integer: flipping bits in binary representation. We must produce step-by-step pseudocode. We can't output actual code, just steps. Each line: virtual code step and comment. Use Start, End, Decision:, arrows. We should produce steps: Input n, find binary length, create mask, compute complement, output. Let's outline:\n\nStart\n→ Step 1: Receive integer n\n→ Decision: If n equals 0? (special case)\n    Yes → Step 2: Output 1 (complement of 0 is 1)\n    No  → Step 3: Determine bit length L = floor(log2(n)) + 1\n    → Step 4: Create mask = (1 << L) - 1 // all 1s for L bits\n    → Step 5: Complement = mask XOR n // flip bits\n    → Step 6: Output complement\nEnd\n\nBut we need to reflect flipping bits: mask XOR n yields complement. That is simple.\n\nAlso handle negative? Not needed. Just positive integer.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: 接收整數 n // 從使用者取得數值\n→ Decision: 如果 n 為 0? // 檢查特殊情況\n    Yes → Step 2: 輸出 1 // 0 的補碼為 1\n    No  → Step 3: 計算二進位位數 L = floor(log2(n)) + 1 // 找出 n 的最高位\n        → Step 4: 產生掩碼 mask = (1 << L) - 1 // L 位全 1\n        → Step 5: 取反 complement = mask XOR n // 將 0 變 1、1 變 0\n        → Step 6: 輸出 complement // 顯示結果\nEnd // 程式執行結束\n\nNeed to ensure each line has \"→\" arrow preceding the step except for Start and End. The decision block indent? We can indent lines under Decision: with spaces. Ensure each line ends with comment.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 接收整數 n // 從使用者取得數值  \n→ Decision: 如果 n 為 0? // 檢查特殊情況  \n    Yes → Step 2: 輸出 1 // 0 的補碼為 1  \n    No  → Step 3: 計算二進位位數 L = floor(log2(n)) + 1 // 找出 n 的最高位  \n        → Step 4: 產生掩碼 mask = (1 << L) - 1 // L 位全 1  \n        → Step 5: 取反 complement = mask XOR n // 將 0 變 1、1 變 0  \n        → Step 6: 輸出 complement // 顯示結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def bitwiseComplement(self, n: int) -> int:\n        \"\"\"Return the complement of a non‑negative integer.\"\"\"\n        if n == 0:\n            return 1\n        bit_length = n.bit_length()\n        mask = (1 << bit_length) - 1\n        return n ^ mask\n\ndef main() -> None:\n    # 讀取整個輸入並從中提取第一個整數\n    data = sys.stdin.read()\n    match = re.search(r'-?\\d+', data)\n    if not match:\n        raise ValueError(\"No integer found in input.\")\n    n = int(match.group(0))\n\n    solver = Solution()\n    result = solver.bitwiseComplement(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 5",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "n = 7",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 2,
          "input": "n = 10",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode128.json",
    "problem_index_in_file": 0,
    "title": "Longest Consecutive Sequence",
    "description_snippet": "Given an unsorted array of integers nums, return the length of the longest consecutive elements sequ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for algorithm: longest consecutive sequence length in unsorted array in O(n). Use hash set. Steps: build set, iterate each num, if num-1 not in set, start new sequence, count consecutive increments. Keep max. End.\n\nWe need to output line by line with virtual code arrow and comments.\n\nFollow format: Start // start program, then arrow lines.\n\nMake sure to use arrow characters →. Decision with Yes →, No →. Use indentation with spaces maybe.\n\nLet's produce steps:\n\nStart // program start\n→ Step 1: Build set from nums // O(n) hash set\n→ Step 2: Initialize maxLen = 0 // store longest length\n→ Step 3: For each num in set // iterate over unique numbers\n    → Decision: If num-1 not in set? // start of sequence\n        Yes → Step 4: Set current = num, count = 1 // start new sequence\n            → While current+1 in set? // continue consecutive\n                Yes → current = current+1, count +=1 // extend sequence\n                No  → End While\n            → Step 5: If count > maxLen → maxLen = count // update max\n            No → End Decision\n    No → End Decision\n→ Step 6: Return maxLen // result\nEnd // program end\n\nNeed to format each line with \"//\" comments. Use indentation for nested blocks but still maintain same format.\n\nLet's craft output.\n\nCheck format: Each line must contain virtual code step + space + // explanation. Should use \"→\" before step, and \"Decision:\" for decisions.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Build set from nums // 建立一個 HashSet 以便 O(1) 查找  \n→ Step 2: Initialize maxLen = 0 // 用來記錄目前為止最長的連續序列長度  \n→ Step 3: For each num in set // 逐個遍歷所有唯一數字  \n  → Decision: 如果 num-1 不在 set? // 判斷 num 是否為某個序列的起點  \n   Yes → Step 4: current = num, count = 1 // 從起點開始計算長度  \n    → While current+1 在 set? // 檢查是否能向後延伸  \n     Yes → current = current + 1, count = count + 1 // 延長連續序列  \n     No  → End While  \n    → Step 5: 如果 count > maxLen? // 若此序列更長則更新 maxLen  \n     Yes → maxLen = count // 更新最大長度  \n     No  → End Decision  \n   No  → End Decision  \n→ Step 6: Return maxLen // 回傳最長連續序列長度  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef longest_consecutive(nums):\n    \"\"\"Return length of longest consecutive elements sequence.\"\"\"\n    if not nums:\n        return 0\n    num_set = set(nums)\n    longest = 0\n    for num in num_set:\n        # only start counting if num is the start of a sequence\n        if num - 1 not in num_set:\n            current = num\n            length = 1\n            while current + 1 in num_set:\n                current += 1\n                length += 1\n            if length > longest:\n                longest = length\n    return longest\n\ndef main():\n    # Read entire input\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Expect input like \"nums = [1,2,3]\" or just \"[1,2,3]\"\n    if '=' in data:\n        _, expr = data.split('=', 1)\n    else:\n        expr = data\n    try:\n        nums = ast.literal_eval(expr.strip())\n    except Exception:\n        nums = []\n    result = longest_consecutive(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [100,4,200,1,3,2]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "nums = [0,3,7,2,5,8,4,6,0,1]",
          "expected_output": "9",
          "success": true,
          "output": "9"
        },
        {
          "example_index": 2,
          "input": "nums = [1,0,1,2]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode56.json",
    "problem_index_in_file": 0,
    "title": "Merge Intervals",
    "description_snippet": "Given an array of intervals where intervals[i] = [start_i, end_i], merge all overlapping intervals, ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step for merging intervals. Each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision. We'll produce algorithm: sort by start, iterate merging. Provide pseudo code lines. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 檢查 intervals 是否為空或長度 ≤ 1? // 若無重疊需求  \n  Yes → Step 2: 回傳 intervals 本身 // 結束  \n  No → Step 3: 將 intervals 按照 start 升序排序 // 方便後續合併  \n→ Step 4: 初始化 merged 為空列表 // 用來儲存合併後的區間  \n→ Step 5: 將 sorted_intervals[0] 作為 current_start, current_end // 初始區間  \n→ Step 6: 從 sorted_intervals[1] 開始遍歷每個 interval // 逐一檢查  \n  → Decision: 如果 interval.start ≤ current_end? // 檢查是否重疊  \n   Yes → Step 7: current_end = max(current_end, interval.end) // 擴大結束點  \n   No → Step 8: 將 [current_start, current_end] 加入 merged // 將已合併的區間保存  \n     → Step 9: 將 current_start, current_end 更新為 interval.start, interval.end // 開始新的區間  \n→ Step 10: 迴圈結束後，將最後一個 [current_start, current_end] 加入 merged // 保存最後一段  \n→ Step 11: 回傳 merged // 輸出非重疊區間列表  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef merge_intervals(intervals):\n    \"\"\"合併重疊的區間，返回非重疊區間列表。\"\"\"\n    if not intervals:\n        return []\n\n    # 先按起始點排序，方便後續合併\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n\n    for current in intervals[1:]:\n        prev = merged[-1]\n        # 若當前區間的起點在前一個合併區間內，則合併\n        if current[0] <= prev[1]:\n            prev[1] = max(prev[1], current[1])\n        else:\n            merged.append(current)\n\n    return merged\n\ndef main():\n    # 讀取整個標準輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n\n    # 找到第一個 '['，從那裡開始解析成列表\n    start = raw_input.find('[')\n    if start == -1:\n        print(\"[]\")\n        return\n\n    try:\n        intervals = ast.literal_eval(raw_input[start:])\n    except Exception:\n        print(\"[]\")\n        return\n\n    result = merge_intervals(intervals)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "intervals = [[1,3],[2,6],[8,10],[15,18]]",
          "expected_output": "[[1,6],[8,10],[15,18]]",
          "success": true,
          "output": "[[1, 6], [8, 10], [15, 18]]"
        },
        {
          "example_index": 1,
          "input": "intervals = [[1,4],[4,5]]",
          "expected_output": "[[1,5]]",
          "success": true,
          "output": "[[1, 5]]"
        },
        {
          "example_index": 2,
          "input": "intervals = [[4,7],[1,4]]",
          "expected_output": "[[1,7]]",
          "success": true,
          "output": "[[1, 7]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode395.json",
    "problem_index_in_file": 0,
    "title": "Longest Substring with At Least K Repeating Characters",
    "description_snippet": "Given a string s and an integer k, return the length of the longest substring of s such that the fre...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line with explanation. The problem: longest substring where each char freq >= k. Classic \"longest substring with at least K repeating characters\". Use divide and conquer. Steps: Start, get s, k. Count distinct chars. If count <= k maybe return len. If not, find split indices where char freq < k, split, recursively compute max. So produce steps with decision, recursion. Must be virtual code, not actual code. Each line: \"→ Step: description // explanation\". Use arrow and decisions.\n\nLet's craft lines:\n\nStart\n→ Step 1: 接收字串 s 與整數 k // 取得輸入資料\n→ Step 2: 計算 s 中不同字元總數 uniqueCount // 需要判斷是否能滿足條件\n    Yes → Decision: 如果 uniqueCount <= k? // 如果不同字元少於等於 k，全部字元頻率至少 k\n        Yes → Step 3: 回傳 s.length // 整串即符合條件\n        No  → Step 4: 初始化 maxLen = 0 // 用於儲存分段結果\n→ Step 5: 計算每個字元在 s 中的出現頻率 freqMap // 方便分段\n→ Step 6: 建立一個空白列表 splitIndices // 存放需切割的位置\n→ Decision: 是否存在字元頻率 < k? // 若無需切割\n    Yes → Step 7: 回傳 s.length // 整串已滿足\n    No  → Step 8: 循環遍歷 s，若 freqMap[char] < k，將索引加入 splitIndices // 找出切割點\n→ Step 9: 將 s 切成若干段，段間以 splitIndices 為界 // 創建子字串列表\n→ Step 10: 對每個子字串子S 呼叫此演算法並取得長度 // 進行遞迴\n→ Decision: 是否已處理完所有子字串? // 若未完成則繼續\n    Yes → Step 11: 取得子字串長度的最大值 maxLen // 選取最長\n→ Step 12: 回傳 maxLen // 結果\nEnd\n\nNeed to format each line with arrow or start. Use \"Start\" line. Use arrow for subsequent. Use decisions as described.\n\nBut careful: We need to reflect recursive nature. Use \"→ Decision:\" lines with \"Yes →\" \"No →\". Provide explanation. Let's produce final.\n\nMake sure no actual code; only pseudocode steps. Provide explanation after each line.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 接收字串 s 與整數 k // 取得輸入資料  \n→ Step 2: 計算 s 中不同字元總數 uniqueCount // 檢查是否所有字元都至少出現 k 次  \n  Decision: 如果 uniqueCount <= k? // 如果不同字元數少於等於 k，整串一定滿足條件  \n   Yes → Step 3: 回傳 s.length // 整串即為答案  \n   No → Step 4: 初始化 maxLen = 0 // 用於儲存遞迴分段結果  \n→ Step 5: 建立字元頻率表 freqMap // 記錄每個字元在 s 中的出現次數  \n→ Step 6: 建立空列表 splitIndices // 儲存需要切割的位置  \n→ Decision: 是否存在頻率 < k 的字元? // 若無需切割  \n  Yes → Step 7: 回傳 s.length // 整串已符合要求  \n  No → Step 8: 遍歷 s，若 freqMap[字元] < k，將索引加入 splitIndices // 找出所有不符合的切割點  \n→ Step 9: 以 splitIndices 為界將 s 切成若干子字串 segments // 創建子問題  \n→ Step 10: 對 segments 中每個子字串 childS，遞迴呼叫此演算法並取得其長度 // 分段處理  \n  Decision: 是否已處理完所有子字串? // 確認遞迴結束  \n   Yes → Step 11: 取得 childS 長度中的最大值 maxLen // 選取最長符合條件的子字串  \n→ Step 12: 回傳 maxLen // 回傳結果給上一層遞迴或最終結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nfrom collections import Counter\n\nclass Solution:\n    def longestSubstring(self, s: str, k: int) -> int:\n        # 若字串長度小於 k，無法滿足要求\n        if len(s) < k:\n            return 0\n\n        # 計算字串中每個字元的頻率\n        freq = Counter(s)\n\n        # 若存在頻率小於 k 的字元，則必須以該字元為界分段\n        for ch, cnt in freq.items():\n            if cnt < k:\n                # 把字串按此字元切割，遞迴求每段長度，再取最大值\n                return max(self.longestSubstring(part, k) for part in s.split(ch))\n\n        # 以上情況均不成立，表示所有字元頻率均 >= k\n        return len(s)\n\ndef parse_input(raw: str):\n    \"\"\"\n    解析類似 `s = \"aaabb\", k = 3` 這種格式的輸入。\n    \"\"\"\n    s = \"\"\n    k = 0\n    # 先把所有空白符號除去，方便解析\n    raw = raw.replace(\"\\n\", \" \").strip()\n    parts = raw.split(',')\n    for part in parts:\n        if \"s\" in part:\n            # 取得雙引號內的字串\n            start = part.find('\"')\n            end = part.rfind('\"')\n            s = part[start+1:end]\n        elif \"k\" in part:\n            k = int(part.split('=')[1].strip())\n    return s, k\n\ndef main():\n    raw_input = sys.stdin.read()\n    s, k = parse_input(raw_input)\n    solution = Solution()\n    result = solution.longestSubstring(s, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"aaabb\", k = 3",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "s = \"ababbc\", k = 2",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode231.json",
    "problem_index_in_file": 0,
    "title": "Power of Two",
    "description_snippet": "Given an integer n, return true if it is a power of two. Otherwise, return false.\n\nAn integer n is a...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines, with each line followed by comment. The requirement: use virtual code with arrow syntax. Should handle algorithm: check if n > 0 and (n & (n-1)) == 0. Let's produce step-by-step.\n\nStart\n→ Step 1: Input n //取得輸入\n→ Decision: n <= 0? //如果小於等於0\n    No  → Step 2: Compute mask = n & (n-1) //計算 n 與 n-1 的位運算\n    Yes → Step 3: Return false //負數或0不是2的冪\n→ Decision: mask == 0? //若mask為0，則n是2的冪\n    Yes → Step 4: Return true //返回真\n    No  → Step 5: Return false //返回假\nEnd\n\nBut we should maintain \"Yes →\" and \"No →\" under Decision. Each line should be a separate line. For decision lines, we can indent sub-steps. Let's write:\n\nStart // 程式開始執行\n→ Step 1: 輸入整數 n // 取得使用者輸入\n→ Decision: n <= 0? // 檢查是否小於等於零\n    Yes → Step 2: 返回 false // 非正整數不是 2 的冪\n    No  → Step 3: 計算 mask = n & (n-1) // 位運算判斷\n→ Decision: mask == 0? // 判斷結果\n    Yes → Step 4: 返回 true // 是 2 的冪\n    No  → Step 5: 返回 false // 否則不是\nEnd // 程式結束\n\nNeed to include comments. Each line: \"虛擬碼步驟 // 解釋\". Let's craft accordingly.\n\nMake sure each line is separate, with indentation for sub-steps? The example shows indentation under Decision. We'll mimic.\n\nWe'll ensure use of 'Yes →' and 'No →'. We'll use '→ Decision: ...' and then lines indented with spaces.\n\nReturn lines as plain text.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入整數 n // 取得使用者輸入的數字  \n→ Decision: n <= 0? // 檢查數字是否小於等於零  \n    Yes → Step 2: 返回 false // 非正整數不是 2 的冪  \n    No  → Step 3: 計算 mask = n & (n-1) // 進行位運算以判斷是否為 2 的冪  \n→ Decision: mask == 0? // 判斷 mask 是否為零  \n    Yes → Step 4: 返回 true // 是 2 的冪，返回真  \n    No  → Step 5: 返回 false // 不是 2 的冪，返回假  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def isPowerOfTwo(self, n: int) -> bool:\n        \"\"\"Return True if n is a power of two, else False.\"\"\"\n        if n <= 0:\n            return False\n        return (n & (n - 1)) == 0\n\ndef main() -> None:\n    # Read the entire input from stdin\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n\n    # Parse input of the form \"n = 1\" or just \"1\"\n    if '=' in raw:\n        _, value = raw.split('=', 1)\n        n = int(value.strip())\n    else:\n        n = int(raw)\n\n    result = Solution().isPowerOfTwo(n)\n    # Output in lowercase as required\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 1",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "n = 16",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode455.json",
    "problem_index_in_file": 0,
    "title": "Assign Cookies",
    "description_snippet": "Assume you are an awesome parent and want to give your children some cookies. But, you should give e...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code lines with explanation, no actual code. Problem: classic \"Assign Cookies\" greedy. Approach: sort greed ascending, sort cookies ascending, iterate pointers. Count matched.\n\nWe'll produce steps. Use Start, Decision etc.\n\nWe should provide line by line. Let's generate:\n\nStart\n→ Step 1: sort array g ascending // 優化分配\n→ Step 2: sort array s ascending // 同上\n→ Step 3: initialize i = 0, j = 0, count = 0 // 指標\n→ Decision: 如果 i < n 且 j < m? // 有孩子且有餅乾未處理\n    Yes → Decision: 如果 s[j] >= g[i]? // 能否給予\n        Yes → Step 4: count +=1; i+=1; j+=1 // 分配成功\n        No → Step 5: j+=1 // 雖然餅乾太小，嘗試下一顆\n    No  → End // 結束\nEnd // 輸出 count\n\nAlso maybe mention output.\n\nWe need to produce each line with explanation. Use `→` arrow. Format: \"虛擬碼步驟 // 解釋\". For decisions include nested.\n\nMake sure to indent lines under Decision. Use tabs or spaces. Use `→ Decision:` lines.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: sort g ascending // 將孩子的貪婪值按小到大排列  \n→ Step 2: sort s ascending // 將餅乾的大小按小到大排列  \n→ Step 3: initialize i = 0, j = 0, count = 0 // i: 目前孩子索引, j: 目前餅乾索引, count: 已滿足孩子數  \n→ Decision: i < n 且 j < m? // 是否還有孩子和餅乾可處理  \n  Yes → Decision: s[j] >= g[i]? // 該餅乾是否能滿足目前孩子  \n   Yes → Step 4: count += 1; i += 1; j += 1 // 分配餅乾並遞增指標  \n   No  → Step 5: j += 1 // 餅乾太小，嘗試下一顆餅乾  \n  No  → End // 所有孩子或餅乾處理完畢  \nEnd // 輸出 count 為最大可滿足的孩子數量",
      "generated_code": "import sys\nimport re\nfrom typing import List\n\nclass Solution:\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\n        # 先把貪婪值和餅乾大小各自排序\n        g.sort()\n        s.sort()\n        i = j = 0\n        # 同時遍歷孩子和餅乾\n        while i < len(g) and j < len(s):\n            if s[j] >= g[i]:      # 這顆餅乾能滿足孩子\n                i += 1            # 將孩子算進已滿足數量\n            j += 1                # 無論是否分配，餅乾都要往後走\n        return i\n\ndef parse_lists(input_str: str) -> (List[int], List[int]):\n    \"\"\"從輸入字串中提取兩個整數列表 g 和 s。\"\"\"\n    # 找 g 的內容\n    g_match = re.search(r'g\\s*=\\s*\\[([^\\]]*)\\]', input_str)\n    s_match = re.search(r's\\s*=\\s*\\[([^\\]]*)\\]', input_str)\n    if not g_match or not s_match:\n        return [], []\n    # 解析列表字串\n    g_list = [int(x) for x in g_match.group(1).split(',') if x.strip()]\n    s_list = [int(x) for x in s_match.group(1).split(',') if x.strip()]\n    return g_list, s_list\n\ndef main():\n    # 讀取整個輸入\n    input_data = sys.stdin.read().strip()\n    if not input_data:\n        return\n    g, s = parse_lists(input_data)\n    solver = Solution()\n    result = solver.findContentChildren(g, s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "g = [1,2,3], s = [1,1]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "g = [1,2], s = [1,2,3]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode155.json",
    "problem_index_in_file": 0,
    "title": "Min Stack",
    "description_snippet": "Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.\n\nI...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for MinStack operations with O(1). Provide each line with comment. Use Start, End, Decision, etc. Provide code for the class initialization, push, pop, top, getMin. We'll break into steps. We need to use virtual code arrow. Provide explanation for each line. We should produce something like:\n\nStart\n→ Step: Initialize main stack and min stack\n→ Step: push(val): push val onto main stack; if min stack empty or val <= minStack.top push val else push minStack.top\n→ Step: pop(): pop main stack; pop min stack\n→ Step: top(): return mainStack.top\n→ Step: getMin(): return minStack.top\nEnd\n\nBut we need step by step with decisions.\n\nWe can detail push: decision if minStack empty or val < minStack.top? but we need to push min for equal also to maintain count. For O(1), push min value each time; minStack holds current min. So push onto minStack the min(val, minStack.top). Implementation: newMin = min(val, minStack.top). push newMin.\n\nThus algorithm: push val; compute newMin = if minStack empty then val else min(val, minStack.top). push val to mainStack, push newMin to minStack.\n\npop: pop mainStack; pop minStack.\n\ntop: return mainStack.top\n\ngetMin: return minStack.top\n\nOk.\n\nNow produce lines:\n\nStart // Program starts\n→ Step 1: Declare two stacks: mainStack and minStack // 用於儲存元素與最小值\n→ Step 2: Initialize mainStack, minStack // 空堆疊\n...\n\nWe'll create separate steps for each function maybe as sub-sections.\n\nBetter: Step for initialization. Then define push: Step for push. Step for pop. Step for top. Step for getMin. End.\n\nLet's produce.\n\nAlso need decision? For push we might need decision: If minStack empty? But we can compute newMin formula. Might show decision: If minStack empty? Yes -> push val onto minStack; else compute min. Show decision lines.\n\nOk produce.\n\nLet's produce each line with \"→\" arrow. Use \"Decision:\" for decision. Provide comments in Chinese. Use \"Start\" \"End\". Provide explanation after comment.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n\n→ Step 1: 宣告兩個堆疊 mainStack、minStack // 用於儲存元素與即時最小值  \n→ Step 2: 初始化 mainStack、minStack 為空堆疊 // 開始時兩者皆無元素  \n\n// ────── push(val) ──────  \n→ Step 3: 輸入值 val 進行 push // 使用者想將 val 放入堆疊  \n→ Decision: 若 minStack 為空? // 判斷是否為第一個元素  \n    Yes → Step 4a: push val 到 mainStack // 首個元素直接入堆疊  \n           → Step 5a: push val 到 minStack // 同時設為最小值  \n    No  → Step 4b: 計算 currentMin = min(val, minStack.top) // 取得較小值  \n           → Step 5b: push val 到 mainStack // 主堆疊入新元素  \n           → Step 6b: push currentMin 到 minStack // 更新最小值堆疊  \n\n// ────── pop() ──────  \n→ Step 7: 若 mainStack 為空? // 防止空堆疊彈出  \n    Yes → Step 8a: return // 無元素可彈出，直接返回  \n    No  → Step 8b: pop mainStack.top() // 刪除主堆疊頂部元素  \n           → Step 9b: pop minStack.top() // 同時刪除最小值堆疊頂部  \n\n// ────── top() ──────  \n→ Step 10: 若 mainStack 為空? // 檢查是否有元素  \n     Yes → Step 11a: return null // 無元素返回空  \n     No  → Step 11b: return mainStack.top() // 回傳主堆疊頂部  \n\n// ────── getMin() ──────  \n→ Step 12: 若 minStack 為空? // 檢查是否有元素  \n     Yes → Step 13a: return null // 無元素返回空  \n     No  → Step 13b: return minStack.top() // 回傳目前最小值  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass MinStack:\n    \"\"\"O(1) 時間完成 push、pop、top、getMin 的堆疊。\"\"\"\n\n    def __init__(self):\n        # 主堆疊儲存所有元素\n        self.stack = []\n        # 幫手堆疊在每個位置存儲當前最小值\n        self.min_stack = []\n\n    def push(self, val: int) -> None:\n        self.stack.append(val)\n        if not self.min_stack:\n            # 第一個元素直接成為最小值\n            self.min_stack.append(val)\n        else:\n            # 記錄目前最小值（保留舊最小值或更新為 val）\n            self.min_stack.append(min(val, self.min_stack[-1]))\n\n    def pop(self) -> None:\n        if self.stack:\n            self.stack.pop()\n            self.min_stack.pop()\n\n    def top(self) -> int | None:\n        return self.stack[-1] if self.stack else None\n\n    def getMin(self) -> int | None:\n        return self.min_stack[-1] if self.min_stack else None\n\n\ndef split_at_outer_comma(s: str):\n    \"\"\"將字串在最外層逗號處分成兩部份。\"\"\"\n    depth = 0\n    for i, ch in enumerate(s):\n        if ch == '[':\n            depth += 1\n        elif ch == ']':\n            depth -= 1\n        elif ch == ',' and depth == 0:\n            return s[:i], s[i + 1:]\n    return s, ''\n\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    ops_str, args_str = split_at_outer_comma(data)\n    ops = ast.literal_eval(ops_str)\n    args = ast.literal_eval(args_str)\n\n    stack = None\n    results = []\n\n    for op, arg in zip(ops, args):\n        if op == \"MinStack\":\n            stack = MinStack()\n            results.append(None)\n        elif op == \"push\":\n            stack.push(arg[0])\n            results.append(None)\n        elif op == \"pop\":\n            stack.pop()\n            results.append(None)\n        elif op == \"top\":\n            results.append(stack.top())\n        elif op == \"getMin\":\n            results.append(stack.getMin())\n\n    # 轉成符合題目輸出的字串（None 轉為 null）\n    out = '[' + ','.join('null' if r is None else str(r) for r in results) + ']'\n    print(out)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"],[[],[-2],[0],[-3],[],[],[],[]]",
          "expected_output": "[null,null,null,null,-3,null,0,-2]",
          "success": true,
          "output": "[null,null,null,null,-3,null,0,-2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode12.json",
    "problem_index_in_file": 0,
    "title": "Integer to Roman",
    "description_snippet": "Seven different symbols represent Roman numerals with the following values:\n\nSymbol\tValue\nI\t1\nV\t5\nX\t...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate pseudo-code step-by-step with explanations. No actual code. Must produce lines with \"虛擬碼步驟 // 解釋\". Use arrows, Start, Decision etc.\n\nGoal: convert integer to Roman numeral. Need mapping of values and subtractive pairs. Use algorithm iterative over value list sorted descending.\n\nWe produce pseudo-code:\n\nStart\n→ Step: 定義符號對照表 valueSymbols list of tuples [(1000,'M'),(900,'CM'),(500,'D'),(400,'CD'),(100,'C'),(90,'XC'),(50,'L'),(40,'XL'),(10,'X'),(9,'IX'),(5,'V'),(4,'IV'),(1,'I')] // 定義所有可用的數值和符號\n→ Step: 輸入整數 num // 從使用者或函式取得整數\n→ Step: result = 空字串 // 用於累積羅馬數字\n→ Decision: num 是否為 0? // 檢查是否需要處理零\n    No → ...\n        → For each (value,symbol) in valueSymbols:\n             → Decision: num >= value? // 是否能使用此符號\n                 Yes →\n                     → Step: num -= value // 減去對應數值\n                     → Step: result += symbol // 加上符號\n                     → Go back to Decision: num >= value? // 重複直到不符合\n                 No → Next symbol\n        → Step: 輸出 result // 顯示最終羅馬數字\nEnd\n\nAlso mention the rules implicitly satisfied by ordering.\n\nWe should provide explanation for each line.\n\nWe should include comments at end of line. Use //.\n\nAlso include arrow '→'.\n\nAlso need to mention Decision and Yes/No.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: 定義符號對照表 valueSymbols ← [(1000,'M'),(900,'CM'),(500,'D'),(400,'CD'),(100,'C'),(90,'XC'),(50,'L'),(40,'XL'),(10,'X'),(9,'IX'),(5,'V'),(4,'IV'),(1,'I')] // 包含所有可用的數值與符號，先放入可直接相減的以及減法形式  \n→ Step: 輸入整數 num // 從使用者或函式取得要轉換的十進位整數  \n→ Step: result ← 空字串 // 用於累積產生的羅馬數字  \n→ Decision: num 是否為 0? // 若為 0，無對應羅馬數字（一般情況不處理）  \n    No  →  \n        → For each (value, symbol) in valueSymbols: // 從最大到最小逐項檢查  \n            → Decision: num ≥ value? // 能否使用此符號  \n                Yes →  \n                    → Step: num ← num - value // 將對應值扣除  \n                    → Step: result ← result + symbol // 將符號加到結果  \n                    → Go back to Decision: num ≥ value? // 若仍可用同一符號，重複（最多三次）  \n                No  → // 進入下一個更小的值  \n        → Step: 輸出 result // 顯示最終轉換得到的羅馬數字  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef int_to_roman(num: int) -> str:\n    \"\"\"Convert an integer to a Roman numeral.\"\"\"\n    values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    symbols = [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"]\n    roman = []\n    for v, s in zip(values, symbols):\n        count = num // v\n        if count:\n            roman.append(s * count)\n            num -= v * count\n    return \"\".join(roman)\n\ndef main() -> None:\n    \"\"\"Read integer from stdin, convert to Roman numeral, and print.\"\"\"\n    data = sys.stdin.read()\n    match = re.search(r'\\d+', data)\n    if not match:\n        return\n    number = int(match.group())\n    result = int_to_roman(number)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num = 3749",
          "expected_output": "\"MMMDCCXLIX\"",
          "success": true,
          "output": "MMMDCCXLIX"
        },
        {
          "example_index": 1,
          "input": "num = 58",
          "expected_output": "\"LVIII\"",
          "success": true,
          "output": "LVIII"
        },
        {
          "example_index": 2,
          "input": "num = 1994",
          "expected_output": "\"MCMXCIV\"",
          "success": true,
          "output": "MCMXCIV"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode165.json",
    "problem_index_in_file": 0,
    "title": "Compare Version Numbers",
    "description_snippet": "Given two version strings, version1 and version2, compare them. A version string consists of revisio...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines following the format. No actual code. Just steps. Use Start, Decision, etc.\n\nWe need to compare two version strings. Steps: split by dot, iterate index up to max length, convert to int, compare, decide return -1,1,0.\n\nWe'll include steps: parse revisions, iterate, compare, return result. We need to include loops maybe.\n\nUse arrow notation: Start → Step 1: split, Step 2: determine max length, Step 3: loop index 0 to max-1, inside get rev1 rev2 default 0, compare, return. After loop return 0. End.\n\nWe'll use Decision: for each revision: if rev1<rev2 -> return -1, else if > return 1.\n\nAlso include conversion to int ignoring leading zeros: just integer conversion.\n\nWill produce lines with // explanation.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: 將 version1 用 '.' 分割成 list1 // 取得第一個版本的修訂列表\n→ Step 2: 將 version2 用 '.' 分割成 list2 // 取得第二個版本的修訂列表\n→ Step 3: 設定 maxLen 為 max(list1 長度, list2 長度) // 確定要比較的修訂數量\n→ Step 4: 進入 for loop i 從 0 到 maxLen-1 // 逐個比較修訂\n    → Step 4.1: 取得 rev1 = list1[i] 轉為 int 若 i < list1 長度 否則 0 // 轉換修訂為整數，缺失則為 0\n    → Step 4.2: 取得 rev2 = list2[i] 轉為 int 若 i < list2 長度 否則 0 // 同上\n    → Decision: 如果 rev1 < rev2? // 比較兩個修訂值\n        Yes → Step 4.3: Return -1 // version1 小於 version2\n        No  → Decision: 如果 rev1 > rev2? // 若不是小於，檢查是否大於\n            Yes → Step 4.4: Return 1 // version1 大於 version2\n            No  → Step 4.5: 繼續迴圈 // 修訂相等，進行下一個\n→ Step 5: Return 0 // 所有修訂相等，版本相同\nEnd // 程式執行結束\n\nMake sure each line ends with // 解釋. We'll write accordingly.\n\nUse proper arrows: Start, Step lines start with →. Decisions with indent. Use spaces.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 將 version1 用 '.' 分割成 list1 // 取得第一個版本的修訂列表  \n→ Step 2: 將 version2 用 '.' 分割成 list2 // 取得第二個版本的修訂列表  \n→ Step 3: 設定 maxLen 為 max(list1 長度, list2 長度) // 確定要比較的修訂數量  \n→ Step 4: 進入 for loop i 從 0 到 maxLen-1 // 逐個比較修訂  \n  → Step 4.1: 取得 rev1 = (i < list1 長度 ? int(list1[i]) : 0) // 轉換修訂為整數，缺失則為 0  \n  → Step 4.2: 取得 rev2 = (i < list2 長度 ? int(list2[i]) : 0) // 同上  \n  → Decision: 如果 rev1 < rev2? // 比較兩個修訂值  \n   Yes → Step 4.3: Return -1 // version1 小於 version2  \n   No → Decision: 如果 rev1 > rev2? // 若不是小於，檢查是否大於  \n    Yes → Step 4.4: Return 1 // version1 大於 version2  \n    No → Step 4.5: 繼續迴圈 // 修訂相等，進行下一個  \n→ Step 5: Return 0 // 所有修訂相等，版本相同  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def compareVersion(self, version1: str, version2: str) -> int:\n        v1 = [int(part) for part in version1.split('.')]\n        v2 = [int(part) for part in version2.split('.')]\n        n, m = len(v1), len(v2)\n        for i in range(max(n, m)):\n            num1 = v1[i] if i < n else 0\n            num2 = v2[i] if i < m else 0\n            if num1 < num2:\n                return -1\n            if num1 > num2:\n                return 1\n        return 0\n\ndef parse_input(data: str):\n    # Try to extract quoted version strings\n    matches = re.findall(r'\"([^\"]+)\"', data)\n    if len(matches) >= 2:\n        return matches[0], matches[1]\n\n    # If no quoted strings, try line by line\n    lines = [line.strip() for line in data.splitlines() if line.strip()]\n    if len(lines) >= 2:\n        return lines[0], lines[1]\n\n    # Try space separated\n    parts = data.split()\n    if len(parts) >= 2:\n        return parts[0], parts[1]\n\n    # Fallback: split by comma and remove any surrounding characters\n    parts = [p.strip().strip('\\'\"') for p in data.replace('=', '').split(',')]\n    if len(parts) >= 2:\n        return parts[0], parts[1]\n\n    # If all fails, return empty strings\n    return '', ''\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    if not data:\n        sys.exit(0)\n    version1, version2 = parse_input(data)\n    sol = Solution()\n    result = sol.compareVersion(version1, version2)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "version1 = \"1.2\", version2 = \"1.10\"",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        },
        {
          "example_index": 1,
          "input": "version1 = \"1.01\", version2 = \"1.001\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 2,
          "input": "version1 = \"1.0\", version2 = \"1.0.0.0\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode692.json",
    "problem_index_in_file": 0,
    "title": "Top K Frequent Words",
    "description_snippet": "Given an array of strings words and an integer k, return the k most frequent strings.\n\nReturn the an...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line with explanations. The requirement: given array of strings words and integer k, return k most frequent strings sorted by frequency descending, tie-breaking lexicographical order ascending.\n\nWe need to produce a step-by-step algorithm. Should not produce actual code, only virtual code steps.\n\nWe should cover steps: count frequencies, create list of pairs, sort by frequency descending then lex ascending, take first k, return.\n\nWe need to use arrow and Decision.\n\nLet's craft steps:\n\nStart\n→ Step 1: Initialize empty map freqMap // map string to count\n→ For each word in words // iterate array\n    → Step 2: If word not in freqMap, set freqMap[word] = 1 else freqMap[word] += 1 // count frequencies\n→ Step 3: Convert freqMap entries to list of (word, count) // prepare for sorting\n→ Step 4: Sort list with custom comparator: primary key count descending, secondary key word ascending // order\n→ Step 5: Initialize result array // store k words\n→ For i from 0 to k-1\n    → Step 6: Append list[i].word to result // pick top k\n→ End // return result\n\nWe can add decision steps? Might not need but can add Decision for k > list size.\n\nAdd Decision after sorting:\n\n→ Decision: If k > length of list? // ensure not exceed\n    Yes → Set k = length // adjust\n    No → continue\n\nAlso decision for empty words.\n\nBetter to add start with validation.\n\nLet's produce with arrows and decisions.\n\nWe need to use syntax: `→ Step X:` etc. Use `Decision:` lines.\n\nMake sure each line has `[space]` then comment.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Initialize empty map freqMap // 建立一個空字典，用來記錄每個字的出現次數  \n→ Decision: 如果 words 為空? // 檢查輸入是否為空  \n  Yes → Step 2: Return empty list // 若無字串，直接回傳空結果  \n  No  → Continue // 有字串才繼續  \n→ For each word in words  \n  → Step 3: If word not in freqMap, freqMap[word] = 1 else freqMap[word] += 1 // 計算每個字的頻率  \n→ Step 4: Convert freqMap entries to list of (word, count) pairs // 轉成可排序的清單  \n→ Step 5: Sort list by  \n   1. count 降序 // 先依頻率由高到低  \n   2. word 升序 // 同頻率時按字典序  \n→ Decision: 如果 k > list.length? // 檢查 k 是否超過實際可取的個數  \n  Yes → Step 6: k = list.length // 限制 k 為最大可取數量  \n  No  → Continue // 仍按原 k  \n→ Step 7: Initialize result array // 用來儲存最終回傳的字串  \n→ For i from 0 to k-1  \n  → Step 8: Append list[i].word to result // 取前 k 個字串  \n→ End // 程式執行結束，返回 result",
      "generated_code": "import sys\nimport ast\nimport json\nimport re\nfrom collections import Counter\n\nclass Solution:\n    def topKFrequent(self, words, k):\n        # Count frequencies\n        freq = Counter(words)\n        # Sort by frequency descending, then lexicographically ascending\n        sorted_words = sorted(freq.items(), key=lambda x: (-x[1], x[0]))\n        # Return top k words\n        return [word for word, _ in sorted_words[:k]]\n\nif __name__ == \"__main__\":\n    # Read all input\n    data = sys.stdin.read().strip()\n    if not data:\n        print(\"[]\")\n        sys.exit(0)\n\n    # Use regex to extract words list and k\n    pattern = r'words\\s*=\\s*(\\[[^\\]]*\\])\\s*,\\s*k\\s*=\\s*(\\d+)'\n    match = re.search(pattern, data, re.S)\n    if not match:\n        # Try alternative pattern without spaces\n        pattern_alt = r'words=([\\[\\]]+),k=(\\d+)'\n        match = re.search(pattern_alt, data)\n    if not match:\n        print(\"[]\")\n        sys.exit(0)\n\n    words_str, k_str = match.group(1), match.group(2)\n    words = ast.literal_eval(words_str)\n    k = int(k_str)\n\n    # Compute result\n    result = Solution().topKFrequent(words, k)\n\n    # Print result in JSON format\n    print(json.dumps(result))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "words = [\"i\",\"love\",\"leetcode\",\"i\",\"love\",\"coding\"], k = 2",
          "expected_output": "[\"i\",\"love\"]",
          "success": true,
          "output": "[\"i\", \"love\"]"
        },
        {
          "example_index": 1,
          "input": "words = [\"the\",\"day\",\"is\",\"sunny\",\"the\",\"the\",\"the\",\"sunny\",\"is\",\"is\"], k = 4",
          "expected_output": "[\"the\",\"is\",\"sunny\",\"day\"]",
          "success": true,
          "output": "[\"the\", \"is\", \"sunny\", \"day\"]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode1296.json",
    "problem_index_in_file": 0,
    "title": "Divide Array in Sets of K Consecutive Numbers",
    "description_snippet": "Given an array of integers nums and a positive integer k, check whether it is possible to divide thi...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code for this problem. The problem: given array nums, positive integer k, check if we can partition into sets of k consecutive numbers. This is the standard \"Split Array into Consecutive Subsequences\" problem? Actually it's LeetCode 846 \"Hand of Straights\". Approach: count frequency of each number, then iterate sorted numbers, for each number n, if freq[n] > 0, try to use freq[n] times to create sequences of length k starting at n. Need to decrement freq[n]..freq[n+k-1]. If any freq[n+i] insufficient, return false. Complexity O(n log n). Provide pseudo-code line by line.\n\nWe need to use arrows. Start, End, Decision. Each line has code and // explanation. Provide virtual steps like: Start // 程式開始.\n\nWe cannot output actual code, only pseudo steps.\n\nWe'll produce something like:\n\nStart // 程式開始\n→ Step 1: 建立頻率表 freq 以紀錄每個數字出現次數 // 計算每個數字的頻率\n→ Step 2: 將 nums 的鍵值排序為 sortedNums // 依升序排列數字以便順序處理\n→ Decision: 若 sortedNums 為空? // 檢查輸入是否為空\n    Yes → Step 3: 回傳 true // 空陣列可視為合法分組\n    No  → Step 4: 進行主迴圈\n→ Step 4: 對每個數字 n in sortedNums 執行\n    Decision: 若 freq[n] == 0? // 已經被完全分配的數字\n        Yes → Skip // 跳過\n        No  → Decision: 若 freq[n] > 0? // 需要開始新的序列\n            Yes → Step 5: 對 i 0 to k-1 進行\n                Step 5a: target = n + i // 計算本次序列的目標數字\n                Decision: 若 freq[target] >= freq[n]? // 是否有足夠個數字\n                    Yes → Step 6: 減少 freq[target] by freq[n] // 把數量分配給序列\n                    No  → Step 7: 回傳 false // 無法完成序列，直接失敗\n→ Step 8: 所有數字處理完畢，回傳 true // 所有序列成功建立\nEnd // 程式結束\n\nBut we need to be careful with formatting: each line \"虛擬碼步驟\" plus \" // 解釋\". Use arrows → etc. Indent sub-steps? Use arrows with indent.\n\nWe need to ensure each line is a separate line. Use \"Decision:\" lines.\n\nLet's craft final answer with each line. Use \"Start\" and \"End\".\n\nLet's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立頻率表 freq 以紀錄每個數字出現次數 // 先統計 nums 中每個數字的出現頻率  \n→ Step 2: 將 nums 的鍵值排序為 sortedNums // 依升序排列，方便順序處理  \n→ Decision: sortedNums 是否為空? // 判斷輸入是否為空陣列  \n Yes → Step 3: 回傳 true // 空陣列可以視為已合法分組  \n No  → Step 4: 進入主循環  \n→ Step 4: 對每個數字 n 在 sortedNums 執行  \n → Decision: freq[n] == 0? // 已被完全分配的數字  \n  Yes → Skip // 跳過此數字  \n  No  → Decision: freq[n] > 0? // 需要開始新的序列  \n   Yes → Step 5: 為 n 開始長度為 k 的序列  \n    → Step 5a: 設定 target = n + i，並重複 i 取值 0~k-1 // 計算序列中每個位置的目標數字  \n     → Decision: freq[target] >= freq[n]? // 檢查此目標數字是否足夠用於所有序列  \n      Yes → Step 6: 減少 freq[target] 之值 by freq[n] // 把數量分配給序列  \n      No  → Step 7: 回傳 false // 無法滿足需求，直接失敗  \n→ Step 8: 所有數字已成功分配，回傳 true // 所有序列均能完成  \nEnd // 程式結束執行",
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\nclass Solution:\n    def isPossibleDivide(self, nums, k):\n        if k <= 0 or len(nums) % k != 0:\n            return False\n\n        count = Counter(nums)\n        for num in sorted(count):\n            freq = count[num]\n            if freq == 0:\n                continue\n            for i in range(num, num + k):\n                if count[i] < freq:\n                    return False\n                count[i] -= freq\n        return True\n\ndef parse_input(data: str):\n    # Try to parse \"nums = [...], k = ...\"\n    nums_match = re.search(r'nums\\s*=\\s*(\\[.*?\\])', data)\n    k_match = re.search(r'k\\s*=\\s*(\\d+)', data)\n    if nums_match and k_match:\n        nums = eval(nums_match.group(1))\n        k = int(k_match.group(1))\n        return nums, k\n\n    # Fallback: first line list, second line integer\n    lines = [line.strip() for line in data.splitlines() if line.strip()]\n    if len(lines) >= 2:\n        nums = eval(lines[0])\n        k = int(lines[1])\n        return nums, k\n\n    # Default empty input\n    return [], 0\n\nif __name__ == \"__main__\":\n    raw = sys.stdin.read()\n    nums, k = parse_input(raw)\n    result = Solution().isPossibleDivide(nums, k)\n    print(str(result).lower())",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,3,4,4,5,6], k = 4",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "nums = [3,2,1,2,3,4,3,4,5,9,10,11], k = 3",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "nums = [1,2,3,4], k = 3",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode238.json",
    "problem_index_in_file": 0,
    "title": "Product of Array Except Self",
    "description_snippet": "Given an integer array nums, return an array answer such that answer[i] is equal to the product of a...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for product of array except self, O(n), no division. We produce steps: start, allocate answer array, compute left products, compute right products, etc. Each line with // explanation. Use arrows. Provide lines accordingly.\n\nLet's produce:\n\nStart\n→ Step 1: 初始化 answer 长度 n 并全部设为 1 // 用于存放结果\n→ Step 2: 初始化 leftProd = 1 // 当前左侧累乘\n→ Step 3: 遍历 i 从 0 到 n-1\n    → Step 3.1: answer[i] = leftProd // 把左侧积存入答案\n    → Step 3.2: leftProd = leftProd * nums[i] // 更新左侧积\n→ Step 4: 初始化 rightProd = 1 // 当前右侧累乘\n→ Step 5: 遍历 i 从 n-1 到 0\n    → Step 5.1: answer[i] = answer[i] * rightProd // 乘以右侧积\n    → Step 5.2: rightProd = rightProd * nums[i] // 更新右侧积\nEnd\n\nWe need each line. We might split lines: \"Step 3: 遍历 i 从 0 到 n-1\" is one line but inside decisions? We can do nested lines but must maintain structure. Use arrows.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 answer 為長度為 n 的陣列，並全部設為 1 // 用於儲存最終結果  \n→ Step 2: 設定 leftProd = 1 // 代表目前為止所有左側元素的乘積  \n→ Step 3: 從 i = 0 開始，逐個遍歷 nums  \n  → Step 3.1: answer[i] = leftProd // 把左側乘積寫入答案  \n  → Step 3.2: leftProd = leftProd * nums[i] // 更新左側乘積，加入目前元素  \n→ Step 4: 設定 rightProd = 1 // 代表目前為止所有右側元素的乘積  \n→ Step 5: 從 i = n-1 開始，倒序遍歷 nums  \n  → Step 5.1: answer[i] = answer[i] * rightProd // 乘以右側乘積，得到完整答案  \n  → Step 5.2: rightProd = rightProd * nums[i] // 更新右側乘積，加入目前元素  \nEnd // 程式執行結束，answer 已是所有索引的乘積除自身結果",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def productExceptSelf(self, nums):\n        n = len(nums)\n        res = [1] * n\n        left = 1\n        for i in range(n):\n            res[i] = left\n            left *= nums[i]\n        right = 1\n        for i in range(n - 1, -1, -1):\n            res[i] *= right\n            right *= nums[i]\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    # Expect format like: nums = [1,2,3,4]\n    if '=' in data:\n        _, list_str = data.split('=', 1)\n    else:\n        list_str = data\n    nums = ast.literal_eval(list_str.strip())\n    sol = Solution()\n    answer = sol.productExceptSelf(nums)\n    # Print without spaces after commas to match examples\n    print('[' + ','.join(map(str, answer)) + ']')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,4]",
          "expected_output": "[24,12,8,6]",
          "success": true,
          "output": "[24,12,8,6]"
        },
        {
          "example_index": 1,
          "input": "nums = [-1,1,0,-3,3]",
          "expected_output": "[0,0,9,0,0]",
          "success": true,
          "output": "[0,0,9,0,0]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode321.json",
    "problem_index_in_file": 0,
    "title": "Create Maximum Number",
    "description_snippet": "You are given two integer arrays nums1 and nums2 of lengths m and n respectively. nums1 and nums2 re...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output pseudo-code steps line by line with explanations. The algorithm is known: find maximum number of length k from two arrays preserving relative order. Use stack to pick best digits from each subarray and then merge. The pseudocode should include high-level steps: function maxNumber(nums1, nums2, k). We'll need helper functions: selectMax(nums, len) to choose best subsequence of length len; merge to combine two subsequences; compare to choose best.\n\nWe should produce stepwise pseudocode with arrow notation. No real code. Use Chinese comments. Provide explanation after each line. Let's produce steps.\n\nWe need to maintain structure: Start, End, Decision. Use arrow lines. We'll write high-level algorithm: iterate i from max(0, k-n) to min(k, m), pick subseq from nums1 of length i and from nums2 of length k-i, merge, compare with best. Helper functions: selectMax(seq, t) using stack. merge(a,b) using lexicographic comparison. compare(a,b,startIndex?) but we can just compare whole.\n\nWe need to output each step line by line. Let's start:\n\nStart // begin algorithm\n→ Function: maxNumber(nums1, nums2, k) // main function\n→ Let m = len(nums1) // length of first array\n→ Let n = len(nums2) // length of second array\n→ Let result = empty array of length k // store best result\n→ For i from max(0, k-n) to min(k, m) inclusive // choose how many digits taken from nums1\n    → Let sub1 = selectMax(nums1, i) // best subsequence of length i from nums1\n    → Let sub2 = selectMax(nums2, k-i) // best subsequence of length k-i from nums2\n    → Let candidate = merge(sub1, sub2) // merge two subsequences into max number\n    → If candidate > result // lexicographic comparison\n        → result = candidate // update best\n→ Return result // output answer\nEnd // algorithm ends\n\nNow we need to define helper functions selectMax and merge. Let's write separate sections:\n\nFunction: selectMax(nums, t) // select best subsequence of length t\n→ Let stack = empty // stack to build subsequence\n→ Let drop = len(nums) - t // number of digits we can discard\n→ For each num in nums\n    → While drop > 0 and stack not empty and stack.top < num\n        → stack.pop() // remove smaller digit\n        → drop = drop - 1\n    → stack.push(num) // add current digit\n→ Return first t elements of stack // final subsequence\n\nFunction: merge(a,b) // merge two subsequences into maximum number\n→ Let merged = empty\n→ While a not empty or b not empty\n    → If compare(a,b) // if a is lexicographically larger\n        → merged.append(a[0]); a = a[1:]\n    → Else\n        → merged.append(b[0]); b = b[1:]\n→ Return merged\n\nFunction: compare(a,b) // compare two sequences lexicographically\n→ For i from 0 to max(len(a),len(b))\n    → If i>=len(a) return False // a shorter, so not larger\n    → If i>=len(b) return True // b shorter, a larger\n    → If a[i] > b[i] return True\n    → If a[i] < b[i] return False\n→ Return False // equal\n\nWe also need to express comparison steps within the for loop: candidate > result // lexicographic comparison. In pseudocode we can call compare.\n\nWe must use the arrow notation. For loops and decisions.\n\nLet's output all steps sequentially. Each line with comment. Use arrow \"→\" for each line after Start and before End. Indentation not necessary but can use indentation in comment.\n\nLet's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Function: maxNumber(nums1, nums2, k) // 主函式，輸出長度為 k 的最大數  \n→ Let m = len(nums1) // 取得 nums1 的長度  \n→ Let n = len(nums2) // 取得 nums2 的長度  \n→ Let result = empty array of length k // 儲存目前最佳答案  \n→ For i from max(0, k-n) to min(k, m) // 決定從 nums1 取多少位  \n    → Let sub1 = selectMax(nums1, i) // 從 nums1 取最佳長度為 i 的子序列  \n    → Let sub2 = selectMax(nums2, k-i) // 從 nums2 取最佳長度為 k-i 的子序列  \n    → Let candidate = merge(sub1, sub2) // 合併兩個子序列得到候選答案  \n    → If compare(candidate, result) // 若候選答案比目前最佳更大  \n        → result = candidate // 更新最佳答案  \n→ Return result // 回傳最終答案  \nEnd // 程式執行結束  \n\n---  \n\nFunction: selectMax(nums, t) // 取得長度為 t 的最佳子序列  \n→ Let stack = empty list // 用來構建子序列  \n→ Let drop = len(nums) - t // 可丟棄的位數  \n→ For each num in nums  \n    → While drop > 0 and stack not empty and stack.top < num  \n        → stack.pop() // 移除較小的數字以保留更大的  \n        → drop = drop - 1  \n    → stack.push(num) // 加入當前數字  \n→ Return first t elements of stack // 取得最終子序列  \n\n---  \n\nFunction: merge(a, b) // 將兩個子序列合併成最大數  \n→ Let merged = empty list // 儲存合併結果  \n→ While a not empty or b not empty  \n    → If compare(a, b) // a 在字典序上更大  \n        → merged.append(a[0]); a = a[1:] // 取 a 的首位  \n    → Else  \n        → merged.append(b[0]); b = b[1:] // 取 b 的首位  \n→ Return merged // 合併完成  \n\n---  \n\nFunction: compare(a, b) // 字典序比較兩個序列，返回 a 是否更大  \n→ For i from 0 to max(len(a), len(b))  \n    → If i >= len(a) return False // a 已結束，故不大  \n    → If i >= len(b) return True // b 已結束，a 更大  \n    → If a[i] > b[i] return True // 直接比較位數  \n    → If a[i] < b[i] return False  \n→ Return False // 完全相等，視為不大\n\n---",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def maxNumber(self, nums1, nums2, k):\n        # Helper to pick the best subsequence of length t\n        def pick_max(nums, t):\n            drop = len(nums) - t\n            stack = []\n            for num in nums:\n                while drop and stack and stack[-1] < num:\n                    stack.pop()\n                    drop -= 1\n                stack.append(num)\n            return stack[:t]\n\n        # Helper to merge two subsequences into the largest possible number\n        def merge(a, b):\n            res = []\n            i = j = 0\n            while i < len(a) or j < len(b):\n                if a[i:] > b[j:]:\n                    res.append(a[i])\n                    i += 1\n                else:\n                    res.append(b[j])\n                    j += 1\n            return res\n\n        max_res = []\n        m, n = len(nums1), len(nums2)\n        # i = number of digits taken from nums1\n        start = max(0, k - n)\n        end = min(k, m)\n        for i in range(start, end + 1):\n            a = pick_max(nums1, i)\n            b = pick_max(nums2, k - i)\n            candidate = merge(a, b)\n            if candidate > max_res:\n                max_res = candidate\n        return max_res\n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    # Extract nums1, nums2 and k from the input string\n    nums1_match = re.search(r'nums1\\s*=\\s*(\\[[^\\]]*\\])', data)\n    nums2_match = re.search(r'nums2\\s*=\\s*(\\[[^\\]]*\\])', data)\n    k_match = re.search(r'k\\s*=\\s*(-?\\d+)', data)\n\n    if not nums1_match or not nums2_match or not k_match:\n        print(\"Invalid input\")\n        sys.exit(1)\n\n    nums1 = eval(nums1_match.group(1))\n    nums2 = eval(nums2_match.group(1))\n    k = int(k_match.group(1))\n\n    solution = Solution()\n    result = solution.maxNumber(nums1, nums2, k)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums1 = [3,4,6,5], nums2 = [9,1,2,5,8,3], k = 5",
          "expected_output": "[9,8,6,5,3]",
          "success": true,
          "output": "[9, 8, 6, 5, 3]"
        },
        {
          "example_index": 1,
          "input": "nums1 = [6,7], nums2 = [6,0,4], k = 5",
          "expected_output": "[6,7,6,0,4]",
          "success": true,
          "output": "[6, 7, 6, 0, 4]"
        },
        {
          "example_index": 2,
          "input": "nums1 = [3,9], nums2 = [8,9], k = 3",
          "expected_output": "[9,8,9]",
          "success": true,
          "output": "[9, 8, 9]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode343.json",
    "problem_index_in_file": 0,
    "title": "Integer Break",
    "description_snippet": "Given an integer n, break it into the sum of k positive integers, where k >= 2, and maximize the pro...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines, explaining steps for algorithm. Problem: integer break maximize product. Standard solution: For n >= 4, best is to split into 3s. Use greedy. For small n handle base cases. So virtual code: Start, input n, if n==2 return 1, if n==3 return 2. Else product=1, while n>4: multiply product by 3, n-=3. Finally product*=n. Output product. We'll produce step-by-step virtual code lines.\n\nNeed to output each line as: \"虛擬碼步驟 // 解釋\". Use arrows. Format: \"Start // 程式開始執行\". Use \"→\" for steps. Also \"Decision:\" lines. Use indentation? They didn't specify indentation but examples use indentation. We'll mimic.\n\nLet's craft:\n\nStart\n→ Input n // 取得要分拆的整數\n→ Decision: 如果 n < 2? // 檢查最小有效值\n    Yes → Return 0 // n 小於 2 無法拆分成至少兩正整數\n    No  → Decision: 如果 n==2? // n=2 唯一拆分 1+1\n        Yes → Return 1 // 1*1 =1\n        No  → Decision: 如果 n==3? // n=3 唯一最佳拆分 2+1\n            Yes → Return 2 // 2*1 =2\n            No  → Step 1: product = 1 // 初始化乘積\n→ Step 2: While n > 4: // 用 3 進行分拆\n        product = product * 3\n        n = n - 3\n→ Step 3: product = product * n // 將剩餘值相乘\n→ Step 4: Return product // 回傳最大乘積\nEnd\n\nBut we need each line with virtual code step and explanation separated by space. Need to include arrow and decision etc. Let's format each line as: \"Start // ...\", \"→ Input n // ...\" etc. Also indentation may not be required but we can indent Decision branches.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input n // 取得要分拆的整數  \n→ Decision: 如果 n < 2? // 檢查最小有效值  \n    Yes → Return 0 // n 小於 2 無法拆分成至少兩正整數  \n    No  → Decision: 如果 n==2? // n=2 唯一拆分 1+1  \n        Yes → Return 1 // 1*1 =1  \n        No  → Decision: 如果 n==3? // n=3 唯一最佳拆分 2+1  \n            Yes → Return 2 // 2*1 =2  \n            No  → Step 1: product = 1 // 初始化乘積  \n→ Decision: 如果 n > 4? // 若 n 大於 4 需要進行 3 的拆分  \n    Yes → While n > 4: // 依次取 3，直到 n <= 4  \n            product = product * 3 // 乘上 3  \n            n = n - 3 // n 減去 3  \n    No → // n 已經 <= 4，直接結束循環  \n→ Step 2: product = product * n // 將剩餘值相乘得到最終乘積  \n→ Step 3: Return product // 回傳最大乘積  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def integerBreak(self, n: int) -> int:\n        \"\"\"Return the maximum product of at least two positive integers that sum to n.\"\"\"\n        if n == 2:\n            return 1          # 1 + 1\n        if n == 3:\n            return 2          # 2 + 1\n        res = 1\n        # Greedily use as many 3's as possible\n        while n > 4:\n            res *= 3\n            n -= 3\n        return res * n       # multiply the remaining part\n\ndef main() -> None:\n    # Read all input from stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Extract integers from the input (handles \"n = 10\" or just \"10\")\n    numbers = re.findall(r'-?\\d+', data)\n    if not numbers:\n        return\n    n = int(numbers[0])\n\n    solution = Solution()\n    result = solution.integerBreak(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 2",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "n = 10",
          "expected_output": "36",
          "success": true,
          "output": "36"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode438.json",
    "problem_index_in_file": 0,
    "title": "Find All Anagrams in a String",
    "description_snippet": "Given two strings s and p, return an array of all the start indices of p's anagrams in s. You may re...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for algorithm: find all start indices of anagrams of p in s. Classic sliding window with frequency count. Provide steps: Start, input strings, initialize variables, create freq arrays, slide window, compare. Also handle case p longer than s. Return indices.\n\nWe need to produce step lines with arrow or start, decision etc. Each line: \"虛擬碼步驟 // 解釋\". Use arrow '→', decisions 'Decision:'. Provide in Traditional Chinese. Let's produce concise steps. Let's include array of length 26 for lowercase letters. Might mention mapping. Let's produce steps:\n\nStart\n→ Step 1: 設定變數: n = len(s), m = len(p) // s、p長度\n→ Decision: 如果 m > n? // p長度超過 s\n    Yes → Step 2: 返回空陣列 // 無可能的子串\n    No → Step 3: 初始化 freq[26] 為 0，窗口 freq2[26] 為 0 // 字母頻率表\n→ Step 4: 依序計算 p 的頻率 freq // p 的字符統計\n→ Step 5: 以滑動窗口遍歷 s\n    → Decision: 目前窗口長度 < m? // 前 m 個字元\n        Yes → Step 6: 加入 s[i] 至 freq2\n        No → Step 7: 窗口已達 m，進行比較\n            → Decision: freq2 與 freq 相同? // 檢查是否為字母排列\n                Yes → Step 8: 將起始位置 i-m+1 加入答案\n                No → 不做\n            → Step 9: 移除窗口左端字符 s[i-m+1] 從 freq2 // 更新窗口\n→ Step 10: 回傳答案陣列 // 所有起始索引\nEnd\n\nBut need to use arrow and decisions properly. Use \"→ Decision: ...\". Indent decisions.\n\nLet's format each line. Ensure each line ends with // explanation. Provide arrow before each step. For decisions, use \"Decision:\" and then nested indents.\n\nMake sure to keep each line as separate.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定變數 n = s.length, m = p.length // 取得兩個字串長度  \n→ Decision: 如果 m > n? // p 長度超過 s，無法找到任何字母排列  \n  Yes → Step 2: 回傳空陣列 [] // 直接結束  \n  No  → Step 3: 初始化 freq[26] 為 0，window[26] 為 0 // 兩個字母頻率表  \n→ Step 4: 迭代 i 從 0 到 m-1，將 p[i] 的頻率加至 freq // 先計算 p 的字母統計  \n→ Step 5: 以滑動窗口遍歷 s  \n  → Decision: i < m? // 前 m 個字元仍在窗口中  \n   Yes → Step 6: 加入 s[i] 的頻率至 window // 更新窗口頻率  \n   No  → Step 7: 比較 window 與 freq 是否相同  \n    → Decision: window == freq? // 判斷是否為字母排列  \n     Yes → Step 8: 將起始位置 i-m+1 加入答案陣列 // 紀錄有效索引  \n     No  → Step 9: 不操作 // 窗口不符合條件  \n    → Step 10: 移除窗口左端字符 s[i-m+1] 的頻率，維持窗口長度 m  \n→ Step 11: 回傳答案陣列 // 所有符合條件的起始索引  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def findAnagrams(self, s: str, p: str) -> list[int]:\n        ns, np = len(s), len(p)\n        if ns < np:\n            return []\n\n        # 用 26 個整數表示字母頻率，假設只包含小寫英文字母\n        target = [0] * 26\n        window = [0] * 26\n        for ch in p:\n            target[ord(ch) - 97] += 1\n        for ch in s[:np]:\n            window[ord(ch) - 97] += 1\n\n        res = []\n        if window == target:\n            res.append(0)\n\n        for i in range(1, ns - np + 1):\n            # 移除最左端字元\n            left_idx = ord(s[i - 1]) - 97\n            window[left_idx] -= 1\n            # 加入新字元\n            right_idx = ord(s[i + np - 1]) - 97\n            window[right_idx] += 1\n            if window == target:\n                res.append(i)\n\n        return res\n\ndef parse_input(data: str) -> tuple[str, str]:\n    \"\"\"\n    從輸入文字中提取 s 與 p 的值。支援「s = \"...\" , p = \"...\"」或兩行分別給定的格式。\n    \"\"\"\n    s_match = re.search(r's\\s*=\\s*[\\'\"]([^\\'\"]+)[\\'\"]', data)\n    p_match = re.search(r'p\\s*=\\s*[\\'\"]([^\\'\"]+)[\\'\"]', data)\n    if s_match and p_match:\n        return s_match.group(1), p_match.group(1)\n\n    # 如果格式不符合，嘗試兩行分別給定\n    lines = data.strip().splitlines()\n    if len(lines) >= 2:\n        def clean(line: str) -> str:\n            line = line.strip()\n            if line.lower().startswith('s') or line.lower().startswith('p'):\n                line = line.split('=', 1)[1].strip()\n            return line.strip('\\'\"')\n        return clean(lines[0]), clean(lines[1])\n\n    # 無法解析，回傳空字串\n    return \"\", \"\"\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    s, p = parse_input(data)\n    solution = Solution()\n    result = solution.findAnagrams(s, p)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"cbaebabacd\", p = \"abc\"",
          "expected_output": "[0,6]",
          "success": true,
          "output": "[0, 6]"
        },
        {
          "example_index": 1,
          "input": "s = \"abab\", p = \"ab\"",
          "expected_output": "[0,1,2]",
          "success": true,
          "output": "[0, 1, 2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode467.json",
    "problem_index_in_file": 0,
    "title": "Unique Substrings in Wraparound String",
    "description_snippet": "We define the string base to be the infinite wraparound string of \"abcdefghijklmnopqrstuvwxyz\", so b...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the problem: count unique non-empty substrings of s that appear in the infinite wraparound string of alphabet. Known solution: track longest suffix ending with each letter, then sum lengths.\n\nSo produce steps: initialize array of 26 zeros. For i over s: track current streak length if current char is consecutive to previous in alphabet (including wrap). Update max for current char. After loop sum.\n\nWe need to produce line-by-line virtual code with comments. Use Start, End, Decision. Provide step labels. Use arrow notation.\n\nLet's draft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化字母表長度陣列 maxLen[26] 為 0 // 用於存儲以每個字母結尾的最大子字串長度  \n→ Step 2: 設定 prevChar ← '' // 上一個字母，初始為空  \n→ Step 3: 設定 currentLen ← 0 // 當前連續子字串長度  \n→ Decision: 是否還有字母 s[i] 在字符串 s ？ // 開始遍歷 s  \n Yes → Step 4: 取當前字母 curChar ← s[i] // 取得 s 的第 i 個字母  \n  Decision: 是否 prevChar 為空 或 curChar 與 prevChar 是字母表順序相鄰？ // 檢查是否可延續  \n   Yes → Step 5: currentLen ← currentLen + 1 // 連續長度加一  \n   No  → Step 6: currentLen ← 1 // 重新開始長度  \n  Step 7: 更新 maxLen[curChar] ← max(maxLen[curChar], currentLen) // 保存以 curChar 結尾的最大長度  \n  Step 8: prevChar ← curChar // 更新上一個字母  \n  → Decision: 是否已到 s 的結尾？  \n   Yes → Step 9: sum ← 0 // 用於累加答案  \n    → For 每個字母 idx 在 0..25  \n      sum ← sum + maxLen[idx] // 加總所有最大長度  \n      → End For  \n     → Step 10: 輸出 sum // 結果即為唯一非空子字串個數  \n     → End // 結束流程  \n    No  → 回到 Decision: 是否還有字母 s[i] 在字符串 s ？ // 繼續遍歷  \n  No  → End // 若第一次迴圈結束，直接結束  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef count_unique_wraparound_substrings(s: str) -> int:\n    \"\"\"\n    計算字串 s 中所有在無限環繞字母表「abcdefghijklmnopqrstuvwxyz」中出現\n    的非空子字串的個數。只需要考慮以每個字母結尾的最大連續子字串長度，\n    然後將這些長度相加即可得到唯一子字串總數。\n    \"\"\"\n    # dp[i] 代表以 chr(i + ord('a')) 結尾的最大連續子字串長度\n    dp = [0] * 26\n    cur_len = 0  # 當前連續子字串長度\n\n    for i, ch in enumerate(s):\n        # 如果是第一個字母或與前一個字母不是連續的，就重置長度\n        if i > 0 and (ord(ch) - ord(s[i - 1])) % 26 == 1:\n            cur_len += 1\n        else:\n            cur_len = 1\n        idx = ord(ch) - ord('a')\n        dp[idx] = max(dp[idx], cur_len)\n\n    return sum(dp)\n\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取資料，假設輸入形如：s = \"cac\"\n    raw_input = sys.stdin.read()\n    # 只提取小寫英文字母，忽略其他字符\n    s = ''.join(re.findall('[a-z]', raw_input))\n    result = count_unique_wraparound_substrings(s)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"a\"",
          "expected_output": "1",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '1'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: '1'\nRaw Got:      '2'"
        },
        {
          "example_index": 1,
          "input": "s = \"cac\"",
          "expected_output": "2",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '3'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '3'"
        },
        {
          "example_index": 2,
          "input": "s = \"zab\"",
          "expected_output": "6",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '6'\nGot (Norm):      '7'\n--- (Raw) ---\nRaw Expected: '6'\nRaw Got:      '7'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode219.json",
    "problem_index_in_file": 0,
    "title": "Contains Duplicate II",
    "description_snippet": "Given an integer array nums and an integer k, return true if there are two distinct indices i and j ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code, line by line, with arrow and explanation. Use Start, End, Decision, etc. The problem: Given an array nums and integer k, return true if there are two distinct indices i and j such that nums[i]==nums[j] and abs(i-j)<=k. This is LeetCode 219 Contains Duplicate II. We can solve with sliding window set or hash map.\n\nWe need to produce virtual code, each line with explanation. Use arrow \"→\". Use Decision, Yes→, No→. Use Start, End. Provide explanation after //.\n\nWe should include initial step: Start // 程式開始執行. Then Step 1: Initialize empty set or map. Or use dictionary mapping number to index? Actually typical sliding window uses set: keep window of size k+1. For each index i, if number already in set, return true; else add number to set; if set size > k, remove nums[i-k]. End: return false.\n\nLet's produce that.\n\nLines:\n\nStart // 程式開始執行\n\n→ Step 1: 初始化空集合 window // 建立用於保存窗口內數字的集合\n\n→ Step 2: 循環遍歷索引 i 從 0 到 nums.length-1 // 檢查每個元素\n\n→ Decision: 若 nums[i] 已存在於 window? // 判斷是否有重複\n\nYes → Step 3: 返回 true // 發現符合條件的重複元素，結束\n\nNo → Step 4: 將 nums[i] 加入 window // 將新元素放入窗口\n\n→ Decision: 若 window 大小 > k? // 確保窗口長度不超過 k+1\n\nYes → Step 5: 從 window 移除 nums[i-k] // 把最舊的元素移除\n\nNo  → Step 6: // 無需移除，繼續\n\nEnd // 所有元素已檢查，返回 false\n\nBut we need to add \"return false\" line before End.\n\nSo Step 7: 返回 false // 如果循環結束仍未找到符合條件，返回假\n\nEnd // 程式執行結束\n\nNeed arrow \"→\" for each step, including return false. Should include arrow from Step 6 to Step 7? After Step 6, loop continues. Could incorporate that Step 6 as no action, just continue.\n\nLet's structure with \"→\" lines. Might use \"→\" for each action, indent decisions accordingly.\n\nOk produce final output.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空集合 window // 建立用於保存窗口內數字的集合  \n→ Step 2: 循環遍歷索引 i 從 0 到 nums.length-1 // 檢查每個元素  \n→ Decision: 若 nums[i] 已存在於 window? // 判斷是否有重複  \n Yes → Step 3: 返回 true // 發現符合條件的重複元素，結束  \n No  → Step 4: 將 nums[i] 加入 window // 將新元素放入窗口  \n→ Decision: 若 window 大小 > k? // 確保窗口長度不超過 k+1  \n Yes → Step 5: 從 window 移除 nums[i-k] // 把最舊的元素移除  \n No  → Step 6: // 無需移除，繼續  \n→ Step 7: 返回 false // 如果循環結束仍未找到符合條件，返回假  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"返回是否存在兩個索引 i, j 滿足 nums[i]==nums[j] 且 |i-j| <= k\"\"\"\n        index_map = {}\n        for i, num in enumerate(nums):\n            if num in index_map and i - index_map[num] <= k:\n                return True\n            index_map[num] = i\n        return False\n\ndef parse_input(data: str):\n    \"\"\"\n    解析輸入字串，取得 nums 列表與 k 整數。\n    例：'nums = [1,2,3,1], k = 3' -> ([1,2,3,1], 3)\n    \"\"\"\n    # 取得 nums 的字串部分\n    nums_match = re.search(r'nums\\s*=\\s*(\\[[^\\]]*\\])', data)\n    if not nums_match:\n        raise ValueError(\"Cannot find nums in input.\")\n    nums_str = nums_match.group(1)\n    nums = ast.literal_eval(nums_str)\n\n    # 取得 k 的字串部分\n    k_match = re.search(r'k\\s*=\\s*(-?\\d+)', data)\n    if not k_match:\n        raise ValueError(\"Cannot find k in input.\")\n    k = int(k_match.group(1))\n\n    return nums, k\n\nif __name__ == \"__main__\":\n    # 讀取所有輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    try:\n        nums, k = parse_input(raw_input)\n    except Exception as e:\n        print(f\"Error parsing input: {e}\", file=sys.stderr)\n        sys.exit(1)\n\n    solution = Solution()\n    result = solution.containsNearbyDuplicate(nums, k)\n    # 按題目要求輸出小寫 true/false\n    print(str(result).lower())",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,1], k = 3",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "nums = [1,0,1,1], k = 1",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "nums = [1,2,3,1,2,3], k = 2",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode135.json",
    "problem_index_in_file": 0,
    "title": "Candy",
    "description_snippet": "There are n children standing in a line. Each child is assigned a rating value given in the integer ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a step-by-step virtual code for solving the candy distribution problem. Use the format described: each line has \"虛擬碼步驟\" + space + \"// 解釋\". Use arrows, Start, End, Decision. The algorithm: typical solution: two-pass. Steps: input ratings array, n. Create candies array of size n all 1. Left to right pass: if ratings[i] > ratings[i-1], candies[i] = candies[i-1] + 1. Right to left pass: if ratings[i] > ratings[i+1], candies[i] = max(candies[i], candies[i+1] + 1). Sum candies.\n\nWe should show each step as virtual code. Provide decision statements. Use \"Start\", \"End\". Use arrow \"→\" for steps. Use indentation for decisions.\n\nLet's produce: Start // 程式開始執行\n→ Step 1: Read integer n // 取得小孩數量\n→ Step 2: Read array ratings[0…n-1] // 取得每個孩子的評分\n→ Step 3: Create array candies[0…n-1] and set all to 1 // 每個孩子至少一顆糖果\n→ Step 4: // 左到右遍歷\n    → Decision: 是否還有下一個孩子 i < n-1? // 檢查是否已到最後\n        Yes → Step 5: 如果 ratings[i+1] > ratings[i]? // 檢查右鄰評分\n            Yes → candies[i+1] = candies[i] + 1 // 右鄰評分較高，給更多糖果\n            No  → // 不變\n        No  → // 結束左到右遍歷\n→ Step 6: // 右到左遍歷\n    → Decision: 是否還有上一個孩子 i > 0? // 檢查是否已到第一個\n        Yes → Step 7: 如果 ratings[i-1] > ratings[i]? // 檢查左鄰評分\n            Yes → candies[i-1] = max(candies[i-1], candies[i] + 1) // 左鄰評分較高，調整糖果\n            No  → // 不變\n        No  → // 結束右到左遍歷\n→ Step 8: sum = 0 // 初始化總糖果數\n→ Decision: i < n? // 計算總和\n    Yes → Step 9: sum = sum + candies[i] // 加總\n    No  → // 完成求和\n→ Step 10: Output sum // 回傳最小糖果數\nEnd // 程式執行結束\n\nNeed to ensure each line is \"虛擬碼步驟 // 解釋\" with arrow. For decisions use indentation and \"Yes →\" etc. The format may include colon and indentation. We'll produce with proper indent.\n\nLet's format:\n\nStart // 程式開始執行\n→ Step 1: Read integer n // 取得小孩數量\n→ Step 2: Read array ratings[0…n-1] // 取得每個孩子的評分\n→ Step 3: Create array candies[0…n-1] and set all to 1 // 每個孩子至少一顆糖果\n→ Step 4: // 左到右遍歷\n    → Decision: i < n-1? // 檢查是否已到最後\n        Yes → Step 5: If ratings[i+1] > ratings[i]? // 檢查右鄰評分\n            Yes → candies[i+1] = candies[i] + 1 // 右鄰評分較高，給更多糖果\n            No  → // 不變\n        No  → // 結束左到右遍歷\n→ Step 6: // 右到左遍歷\n    → Decision: i > 0? // 檢查是否已到第一個\n        Yes → Step 7: If ratings[i-1] > ratings[i]? // 檢查左鄰評分\n            Yes → candies[i-1] = max(candies[i-1], candies[i] + 1) // 左鄰評分較高，調整糖果\n            No  → // 不變\n        No  → // 結束右到左遍歷\n→ Step 8: sum = 0 // 初始化總糖果數\n→ Decision: i < n? // 計算總和\n    Yes → Step 9: sum = sum + candies[i] // 加總\n    No  → // 完成求和\n→ Step 10: Output sum // 回傳最小糖果數\nEnd // 程式執行結束\n\nMake sure each line contains \"// 解釋\". Yes.\n\nAlso \"Step 4:\" we have comment inside? Should separate? The format says each line must have \"虛擬碼步驟\" then space then comment. For comments inside decision, we need to put comment at end of line. Eg: \"→ Decision: i < n-1? // 檢查是否已到最後\". Good. Indentation for decisions: we might indent with spaces but keep the line as separate.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Read integer n // 取得小孩數量  \n→ Step 2: Read array ratings[0…n-1] // 取得每個孩子的評分  \n→ Step 3: Create array candies[0…n-1] and set all to 1 // 每個孩子至少一顆糖果  \n→ Step 4: // 左到右遍歷  \n    → Decision: i < n-1? // 檢查是否已到最後  \n        Yes → Step 5: If ratings[i+1] > ratings[i]? // 檢查右鄰評分  \n            Yes → candies[i+1] = candies[i] + 1 // 右鄰評分較高，給更多糖果  \n            No  → // 不變  \n        No  → // 結束左到右遍歷  \n→ Step 6: // 右到左遍歷  \n    → Decision: i > 0? // 檢查是否已到第一個  \n        Yes → Step 7: If ratings[i-1] > ratings[i]? // 檢查左鄰評分  \n            Yes → candies[i-1] = max(candies[i-1], candies[i] + 1) // 左鄰評分較高，調整糖果  \n            No  → // 不變  \n        No  → // 結束右到左遍歷  \n→ Step 8: sum = 0 // 初始化總糖果數  \n→ Decision: i < n? // 計算總和  \n    Yes → Step 9: sum = sum + candies[i] // 加總  \n    No  → // 完成求和  \n→ Step 10: Output sum // 回傳最小糖果數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nfrom typing import List\n\nclass Solution:\n    def candy(self, ratings: List[int]) -> int:\n        n = len(ratings)\n        if n == 0:\n            return 0\n        candies = [1] * n\n\n        # Left to right pass\n        for i in range(1, n):\n            if ratings[i] > ratings[i - 1]:\n                candies[i] = candies[i - 1] + 1\n\n        # Right to left pass\n        for i in range(n - 2, -1, -1):\n            if ratings[i] > ratings[i + 1]:\n                candies[i] = max(candies[i], candies[i + 1] + 1)\n\n        return sum(candies)\n\nif __name__ == \"__main__\":\n    # Read entire stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # Extract the list part after 'ratings ='\n    if '=' in data:\n        _, ratings_part = data.split('=', 1)\n    else:\n        ratings_part = data\n    ratings_part = ratings_part.strip()\n\n    # Safely evaluate the list\n    try:\n        ratings = ast.literal_eval(ratings_part)\n    except Exception as e:\n        print(f\"Error parsing input: {e}\", file=sys.stderr)\n        sys.exit(1)\n\n    # Ensure ratings is a list of integers\n    if not isinstance(ratings, list):\n        print(\"Input must be a list of integers.\", file=sys.stderr)\n        sys.exit(1)\n\n    result = Solution().candy(ratings)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "ratings = [1,0,2]",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "ratings = [1,2,2]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode127.json",
    "problem_index_in_file": 0,
    "title": "Word Ladder",
    "description_snippet": "A transformation sequence from word beginWord to word endWord using a dictionary wordList is a seque...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps. Problem: Word Ladder. Return number of words in shortest transformation sequence. If no path, 0.\n\nWe need to produce virtual code step-by-step, with arrow, decisions, etc.\n\nWe should include BFS search, adjacency via one letter difference, etc.\n\nWe need to produce steps with explanation after comment. Format: \"虛擬碼步驟 // 解釋\". Each line includes arrow (→) etc.\n\nWe need to cover reading inputs, building set, BFS queue, visited, level, etc. Let's design:\n\nStart\n→ Input beginWord, endWord, wordList\n→ Convert wordList to Set for O(1)\n→ If endWord not in set, return 0\n→ Initialize Queue with beginWord\n→ Initialize visited set with beginWord\n→ Initialize level = 1 (count words)\n→ While Queue not empty\n    → For loop size of queue (current level)\n        → Dequeue word\n        → If word == endWord, return level\n        → For each char position i in word\n            → For each letter a-z\n                → Generate newWord by replacing char at i\n                → If newWord in set and not visited\n                    → Add to visited\n                    → Enqueue newWord\n    → Increment level\n→ Return 0\n\nBut we need to be very explicit line by line with virtual code. Use decision arrows for if statements.\n\nLet's output accordingly. Use \"Start // 程式開始執行\". Use arrows \"→\".\n\nWe need to label steps like \"Step 1\". We'll produce steps like \"→ Step 1: 輸入 beginWord, endWord, wordList\". Provide explanation.\n\nWe should include decisions: \"Decision: endWord 是否在字典中?\" etc.\n\nWe should also handle the queue loop.\n\nLet's produce the virtual code.\n\nImportant: Use 虛擬碼 arrow. Use \"Start\", \"End\". Use \"Decision:\" lines. Use \"Yes →\" \"No →\".\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: 輸入 beginWord, endWord, wordList // 從輸入取得三個參數\n→ Step 2: 建立 wordSet ← Set(wordList) // 轉成集合以 O(1) 搜尋\n→ Decision: endWord 是否在 wordSet? // 確認目標單字可達\n    Yes → Step 3: 初始化 queue ← [beginWord] // BFS 隊列\n    Yes → Step 4: 初始化 visited ← {beginWord} // 已訪問集合\n    Yes → Step 5: 初始化 level ← 1 // 目前層級即單字數\n    No  → Step 6: 回傳 0 // 目標單字不在字典，無法轉換\n→ Decision: queue 是否為空? // 判斷是否還有單字要探索\n    No → Step 7: 取 queue 首元素 currentWord // 取出 BFS 的下一個單字\n    No → Step 8: 若 currentWord == endWord? // 是否到達終點\n        Yes → Step 9: 回傳 level // 找到最短路徑長度\n        No  → Step 10: 對每個位置 i 於 currentWord\n            → For letter in 'a' to 'z'\n                → Step 11: 生成 newWord 以 letter 取代位置 i // 嘗試所有單字變化\n                → Decision: newWord 在 wordSet 且 未被 visited? // 是否有效且未訪問\n                    Yes → Step 12: 加入 visited ← visited ∪ {newWord}\n                    Yes → Step 13: 加入 queue ← queue ∪ {newWord} // 新單字進入 BFS\n    No  → Step 14: level ← level + 1 // 完成當前層級，進入下一層\n    No  → Step 15: 回傳 0 // queue 空，仍未找到 endWord\nEnd // 程式執行結束\n\nBut need to reflect while loop properly. The Decision: queue 是否為空? might need to be part of loop. We need to express loop.\n\nBetter:\n\n→ Step 7: Decision: queue 是否為空? // 開始 BFS 迴圈\n    No → Step 8: 取 queue 首元素 currentWord\n    No → Step 9: 若 currentWord == endWord? // 判斷是否到達\n        Yes → Step 10: 回傳 level\n        No  → Step 11: 對 i 從 0 到 len-1\n            → Step 12: 對 letter 從 'a' 到 'z'\n                → Step 13: newWord ← currentWord with letter at i\n                → Decision: newWord 在 wordSet 且 未訪問?\n                    Yes → Step 14: visited 加 newWord\n                    Yes → Step 15: queue 加 newWord\n    No → Step 16: queue 移除已處理的 currentWord\n    No → Step 17: 判斷是否已處理完本層級? // 這可用計數或另設變數\n        Yes → Step 18: level ← level + 1\n    No → 循環回 Step 7\n\nBut maybe we can express BFS as for each level: queueSize = len(queue); for i in range(queueSize) ... then after loop level++.\n\nSimplify.\n\nBetter produce:\n\n→ Step 7: while queue not empty // BFS 主迴圈\n    → Step 8: size ← len(queue) // 當前層級單字數\n    → Step 9: for i from 1 to size\n        → Step 10: currentWord ← queue.pop_front()\n        → Step 11: if currentWord == endWord\n            → Step 12: return level\n        → Step 13: for pos from 0 to len(currentWord)-1\n            → Step 14: for letter in 'a' to 'z'\n                → Step 15: newWord ← replace currentWord[pos] with letter\n                → Step 16: if newWord in wordSet and newWord not in visited\n                    → Step 17: visited add newWord\n                    → Step 18: queue push newWord\n    → Step 19: level ← level + 1\n→ Step 20: return 0\n\nThat's clearer.\n\nWe need to format with arrows.\n\nLet's produce final answer accordingly. Use \"Start\", \"End\".\n\nWe should include decisions lines with \"Decision:\".\n\nAlso add \"Yes →\" and \"No →\" for if conditions.\n\nBut the \"if\" inside loops can be represented as Decision lines.\n\nLet's craft final output accordingly.\n\nEnsure each line ends with comment after //.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: 輸入 beginWord, endWord, wordList // 取得輸入\n→ Step 2: 建立 wordSet ← Set(wordList) // 將字典轉成集合\n→ Decision: endWord 是否在 wordSet? // 檢查目標單字是否存在\n    Yes → Step 3: 初始化 queue ← [beginWord] // BFS 隊列\n    Yes → Step 4: 初始化 visited ← {beginWord} // 記錄已訪問\n    Yes → Step 5: 初始化 level ← 1 // 記錄目前層級\n    No  → Step 6: 回傳 0 // 無法到達目標\n→ Decision: queue 是否為空? // 判斷是否還有單字要探索\n    No  → Step 7: while queue not empty // 開始 BFS 迴圈\n        → Step 8: size ← len(queue) // 本層級單字數\n        → Step 9: for i from 1 to size\n            → Step 10: currentWord ← queue.pop_front() // 取出隊首單字\n            → Decision: currentWord == endWord? // 判斷是否到達終點\n                Yes → Step 11: 回傳 level // 找到最短序列長度\n                No  → Step 12: for pos from 0 to len(currentWord)-1\n                    → Step 13: for letter in 'a' to 'z'\n                        → Step 14: newWord ← currentWord with letter at pos // 產生新單字\n                        → Decision: newWord in wordSet 且 newWord 未在 visited? // 是否有效且未訪問\n                            Yes → Step 15: visited add newWord\n                            Yes → Step 16: queue push newWord // 新單字進入下一層\n        → Step 17: level ← level + 1 // 完成當前層級，進入下一層\n    Yes  → Step 18: 回傳 0 // queue 為空仍未找到 endWord\nEnd // 程式執行結束\n\nBut we used \"Decision: queue 是否為空?\" then Yes/No but we need to produce loop inside. Might produce \"Decision: queue 是否為空?\" but if No then we go to while; if Yes then return 0. That's fine.\n\nBut we need to use Yes→ for not empty: Yes → while loop; No → return 0.\n\nLet's adjust.\n\nAlso inside while loop, we need to maintain \"Decision: currentWord == endWord?\" etc.\n\nLet's rewrite properly:\n\nStart // 程式開始執行\n→ Step 1: 輸入 beginWord, endWord, wordList // 取得輸入\n→ Step 2: 建立 wordSet ← Set(wordList) // 轉成集合\n→ Decision: endWord 是否在 wordSet? // 檢查目標單字是否存在\n    Yes → Step 3: 初始化 queue ← [beginWord] // BFS 隊列\n    Yes → Step 4: 初始化 visited ← {beginWord} // 記錄已訪問\n    Yes → Step 5: 初始化 level ← 1 // 目前層級\n    No  → Step 6: 回傳 0 // 目標單字不在字典\n→ Decision: queue 是否為空? // 檢查是否還有單字可探索\n    Yes → Step 7: while queue not empty // 開始 BFS 迴圈\n        → Step 8: size ← len(queue) // 本層級單字數\n        → Step 9: for i from 1 to size\n            → Step 10: currentWord ← queue.pop_front() // 取出隊首單字\n            → Decision: currentWord == endWord? // 判斷是否到達終點\n                Yes → Step 11: 回傳 level // 找到最短序列長度\n                No  → Step 12: for pos from 0 to len(currentWord)-1\n                    → Step 13: for letter in 'a' to 'z'\n                        → Step 14: newWord ← currentWord with letter at pos // 產生新單字\n                        → Decision: newWord in wordSet 且 newWord 未在 visited? // 有效且未訪問\n                            Yes → Step 15: visited add newWord\n                            Yes → Step 16: queue push newWord // 新單字進入下一層\n        → Step 17: level ← level + 1 // 完成本層級，進入下一層\n    No  → Step 18: 回傳 0 // queue 為空仍未找到 endWord\nEnd // 程式執行結束\n\nCheck that each line ends with // comment.\n\nWe used \"Yes →\" inside decisions; we didn't include \"No →\" for decisions inside loops. For \"Decision: newWord in wordSet 且 newWord 未在 visited?\" we provided Yes path, but not No path. Should we include No path? It's optional maybe. But we can include \"No →\" path skip. But we can simply not include.\n\nLet's add for completeness.\n\nDecision: newWord in wordSet 且 newWord 未在 visited?\n    Yes → ...\n    No  → Step 14: // 跳過此 newWord\n\nBut that may clutter. The requirement: each line must have step. But we can include No path with comment that nothing to do.\n\nLet's keep simple.\n\nAlso after while loop, we may need to consider after loop ends, if queue becomes empty, we return 0. That's Step 18.\n\nOk.\n\nNow final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入 beginWord, endWord, wordList // 取得輸入  \n→ Step 2: 建立 wordSet ← Set(wordList) // 轉成集合  \n→ Decision: endWord 是否在 wordSet? // 檢查目標單字是否存在  \n Yes → Step 3: 初始化 queue ← [beginWord] // BFS 隊列  \n Yes → Step 4: 初始化 visited ← {beginWord} // 記錄已訪問  \n Yes → Step 5: 初始化 level ← 1 // 目前層級  \n No  → Step 6: 回傳 0 // 目標單字不在字典  \n→ Decision: queue 是否為空? // 檢查是否還有單字可探索  \n Yes → Step 7: while queue not empty // 開始 BFS 迴圈  \n  → Step 8: size ← len(queue) // 本層級單字數  \n  → Step 9: for i from 1 to size  \n   → Step 10: currentWord ← queue.pop_front() // 取出隊首單字  \n   → Decision: currentWord == endWord? // 判斷是否到達終點  \n    Yes → Step 11: 回傳 level // 找到最短序列長度  \n    No  → Step 12: for pos from 0 to len(currentWord)-1  \n     → Step 13: for letter in 'a' to 'z'  \n      → Step 14: newWord ← currentWord with letter at pos // 產生新單字  \n      → Decision: newWord in wordSet 且 newWord 未在 visited? // 有效且未訪問  \n       Yes → Step 15: visited add newWord  \n       Yes → Step 16: queue push newWord // 新單字進入下一層  \n   → Step 17: level ← level + 1 // 完成本層級，進入下一層  \n No  → Step 18: 回傳 0 // queue 為空仍未找到 endWord  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom collections import deque\n\nclass Solution:\n    def ladderLength(self, beginWord: str, endWord: str, wordList: list) -> int:\n        wordSet = set(wordList)\n        if endWord not in wordSet:\n            return 0\n\n        queue = deque([(beginWord, 1)])  # (current word, current length)\n\n        while queue:\n            word, length = queue.popleft()\n            if word == endWord:\n                return length\n            for i in range(len(word)):\n                for c in 'abcdefghijklmnopqrstuvwxyz':\n                    new_word = word[:i] + c + word[i + 1:]\n                    if new_word in wordSet:\n                        wordSet.remove(new_word)          # mark as visited\n                        queue.append((new_word, length + 1))\n        return 0\n\n\ndef parse_input(data: str):\n    \"\"\"\n    將輸入字串轉成 beginWord、endWord 與 wordList。\n    支援格式：\n    beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\n    或者三行簡單輸入：beginWord\\nendWord\\nword1 word2 ...\n    \"\"\"\n    # 先嘗試完整格式\n    pattern = re.compile(\n        r'beginWord\\s*=\\s*\"([^\"]+)\"\\s*,\\s*endWord\\s*=\\s*\"([^\"]+)\"\\s*,\\s*wordList\\s*=\\s*\\[(.*?)\\]',\n        re.S\n    )\n    m = pattern.search(data)\n    if m:\n        beginWord = m.group(1)\n        endWord = m.group(2)\n        words_str = m.group(3)\n        # 把每個字串取出，忽略空格與引號\n        wordList = [w.strip().strip('\"').strip(\"'\") for w in words_str.split(',') if w.strip()]\n        return beginWord, endWord, wordList\n\n    # 若不是上述格式，嘗試逐行解析\n    lines = [line.strip() for line in data.strip().splitlines() if line.strip()]\n    if len(lines) >= 3:\n        beginWord = lines[0]\n        endWord = lines[1]\n        # 第三行以逗號或空格分隔單字\n        wordList = [w.strip().strip('\"').strip(\"'\") for w in re.split(r'[,\\s]+', lines[2]) if w]\n        return beginWord, endWord, wordList\n\n    # 最後兜底：用空格分割整個輸入\n    tokens = data.strip().split()\n    if len(tokens) >= 3:\n        beginWord = tokens[0]\n        endWord = tokens[1]\n        wordList = tokens[2:]\n        return beginWord, endWord, wordList\n\n    # 若無法解析，回傳空值\n    return \"\", \"\", []\n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    beginWord, endWord, wordList = parse_input(data)\n    if not beginWord or not endWord:\n        print(0)\n    else:\n        sol = Solution()\n        result = sol.ladderLength(beginWord, endWord, wordList)\n        print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode76.json",
    "problem_index_in_file": 0,
    "title": "Minimum Window Substring",
    "description_snippet": "Given two strings s and t of lengths m and n respectively, return the minimum window substring of s ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for minimum window substring problem. Provide line by line with comments. Use arrow syntax. Ensure we cover algorithm: sliding window with hashmap counts, maintain required characters, form window. Provide steps. Use \"Start\", \"End\". Provide Decision, etc. Let's produce pseudo code.\n\nWe need to ensure we follow the exact format: each line \"虛擬碼步驟 [space] // 解釋\". Use Chinese. Provide explanation after space, not after arrow? The format example: \"→ Step 1: 輸入使用者數字 // 從使用者處取得一個數值\". So arrow then step. Use \"→ Decision: ...\" etc. Let's produce lines:\n\nStart // 開始執行\n→ Step 1: 初始化字典 needCount 以存 t 中每個字符的需求數量 // 收集 t 的字符頻率\n→ Step 2: 初始化變數 haveCount, satisfied, left = 0, right = 0 // left, right 為滑動窗口左右指標\n→ Step 3: 設定最小窗口大小 minLen = ∞, minLeft = 0 // 用於記錄最小窗口\n→ Decision: 若 t 為空字串? // t 為空時直接返回空字符串\n    Yes → Step 4: Return \"\" // 回傳空結果\n    No  →\n→ Step 5: While right < length(s) // 移動右指標掃描 s\n    → Step 5a: char = s[right] // 取右指標字符\n    → Step 5b: If char 在 needCount 中 // 只處理 t 中需要的字符\n        → Step 5b1: 增加窗口字典 haveCount[char] 的計數\n        → Step 5b2: 如果 haveCount[char] 等於 needCount[char] // 符合需求的字符已滿\n            → Step 5b3: satisfied += 1 // 有一個需求字符已滿\n    → Step 5c: right += 1 // 右指標右移\n    → Decision: 如果 satisfied 等於需要字符的種類數? // 所有需求字符均已滿\n        Yes → \n            → Step 6: While satisfied 等於需要字符的種類數\n                → Step 6a: Update min window if (right-left) < minLen // 更新最小窗口\n                    → Step 6a1: minLen = right-left\n                    → Step 6a2: minLeft = left\n                → Step 6b: leftChar = s[left] // 右收縮窗口\n                → Step 6c: If leftChar 在 needCount 中\n                    → Step 6c1: 有 decrement window count\n                    → Step 6c2: 如果 haveCount[leftChar] < needCount[leftChar] // 需求不再滿足\n                        → Step 6c3: satisfied -= 1 // 需求字符減少\n                → Step 6d: left += 1 // 左指標右移\n        No  → // 從這一步繼續往右移動\n→ Step 7: 如果 minLen 為 ∞ // 沒有找到合法窗口\n    → Step 7a: Return \"\"\n→ Step 8: Return s.substring(minLeft, minLeft+minLen) // 返回最小窗口子串\nEnd // 程式結束\n\nNeed to ensure each line has \"虛擬碼步驟\" plus comment. Use \"→\" arrow at start. For decision blocks we indent maybe using tab? In example, indentation is spaces. Use tabs or 4 spaces? Use \"    \" for inner lines. Use \"→ Decision:\" etc. Provide comments after space.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立字典 needCount，將 t 的每個字元及其出現次數存入 // 收集 t 的字符頻率  \n→ Step 2: 初始化 left = 0, right = 0, haveCount = 空字典, satisfied = 0 // 滑動窗口左右指標與已滿足字符類別數  \n→ Step 3: 初始化 minLen = ∞, minLeft = 0 // 用於記錄最小窗口長度與起始位置  \n→ Step 4: Decision: 如果 t 為空字串？ // 特殊情況處理  \n  Yes → Step 5: Return \"\" // t 為空時直接回傳空字串  \n  No →  \n→ Step 6: While right < len(s) // 右指標掃描 s 的過程  \n  → Step 6a: char = s[right] // 取得當前右指標字符  \n  → Step 6b: Decision: 如果 char 在 needCount 中？ // 只關注 t 中需要的字符  \n    Yes →  \n     → Step 6b1: haveCount[char] = haveCount.get(char, 0) + 1 // 更新窗口中該字符計數  \n     Decision: 如果 haveCount[char] == needCount[char]？ // 需求字符已滿足一次  \n       Yes → Step 6b2: satisfied += 1 // 進一步增加已滿足類別數  \n       No → // 無變化  \n    No → // 忽略，t 中不需要的字符  \n  → Step 6c: right += 1 // 右指標右移  \n  → Decision: 如果 satisfied == len(needCount)？ // 所有需求字符均已滿足  \n    Yes →  \n     → Step 7: While satisfied == len(needCount) // 嘗試收縮左指標以獲得更小窗口  \n      → Step 7a: Decision: 如果 right - left < minLen？ // 新窗口更小  \n        Yes →  \n         → Step 7a1: minLen = right - left  \n         → Step 7a2: minLeft = left  \n        No → // 無更新  \n      → Step 7b: leftChar = s[left] // 準備收縮左指標  \n      → Step 7c: Decision: 如果 leftChar 在 needCount 中？ // 只處理需求字符  \n        Yes →  \n         → Step 7c1: haveCount[leftChar] -= 1 // 窗口中該字符計數減一  \n         Decision: 如果 haveCount[leftChar] < needCount[leftChar]？ // 需求不再滿足  \n          Yes → Step 7c2: satisfied -= 1 // 已滿足類別數減一  \n         No → // 無變化  \n       No → // 忽略，非需求字符  \n      → Step 7d: left += 1 // 左指標右移  \n    No → // 需求字符未全部滿足，繼續右移  \n→ Step 8: Decision: 如果 minLen == ∞？ // 沒有合法窗口  \n  Yes → Step 9: Return \"\" // 回傳空字串  \n  No →  \n→ Step 10: Return s.substring(minLeft, minLeft + minLen) // 回傳最小窗口子串  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\nclass Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        if not s or not t:\n            return \"\"\n\n        dict_t = Counter(t)\n        required = len(dict_t)\n        l = r = 0\n        formed = 0\n        window_counts = {}\n        ans = float(\"inf\"), None, None  # (window length, left, right)\n\n        while r < len(s):\n            character = s[r]\n            window_counts[character] = window_counts.get(character, 0) + 1\n\n            if character in dict_t and window_counts[character] == dict_t[character]:\n                formed += 1\n\n            while l <= r and formed == required:\n                character = s[l]\n                if r - l + 1 < ans[0]:\n                    ans = (r - l + 1, l, r)\n\n                window_counts[character] -= 1\n                if character in dict_t and window_counts[character] < dict_t[character]:\n                    formed -= 1\n\n                l += 1\n\n            r += 1\n\n        if ans[0] == float(\"inf\"):\n            return \"\"\n        return s[ans[1]:ans[2] + 1]\n\ndef parse_input(data: str):\n    # Try to find quoted strings first\n    quoted = re.findall(r'\"([^\"]*)\"', data)\n    if len(quoted) >= 2:\n        return quoted[0], quoted[1]\n    # Fallback: split by comma and extract after '='\n    parts = data.split(',')\n    s = t = \"\"\n    for part in parts:\n        if '=' in part:\n            key, val = part.split('=', 1)\n            val = val.strip().strip('\"').strip(\"'\")\n            if key.strip() == 's':\n                s = val\n            elif key.strip() == 't':\n                t = val\n    return s, t\n\nif __name__ == \"__main__\":\n    raw = sys.stdin.read()\n    s, t = parse_input(raw)\n    solution = Solution()\n    result = solution.minWindow(s, t)\n    print(f'\"{result}\"')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"ADOBECODEBANC\", t = \"ABC\"",
          "expected_output": "\"BANC\"",
          "success": true,
          "output": "\"BANC\""
        },
        {
          "example_index": 1,
          "input": "s = \"a\", t = \"a\"",
          "expected_output": "\"a\"",
          "success": true,
          "output": "\"a\""
        },
        {
          "example_index": 2,
          "input": "s = \"a\", t = \"aa\"",
          "expected_output": "\"\"",
          "success": true,
          "output": "\"\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode420.json",
    "problem_index_in_file": 0,
    "title": "Strong Password Checker",
    "description_snippet": "A password is considered strong if the below conditions are all met:\n\nIt has at least 6 characters a...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output a step-by-step virtual code for algorithm to compute minimal modifications to make password strong. Use pseudocode with decisions, loops, etc. Provide explanation after each line.\n\nWe need to produce lines like \"Start // ...\", etc. Let's design algorithm.\n\nStandard solution: count missing types, find repeats of length >=3, track replacements needed = sum(len//3). For length <6, we need to insert, but we also need to cover missing types. For length >20, deletions needed: reduce repeats accordingly. Compute steps = max(missing, replacements) + deletions etc. Standard Leetcode 420.\n\nSo pseudocode:\n\nStart\n→ Input password\n→ n ← length(password)\n→ missing ← count missing categories (lower, upper, digit)\n→ repeats ← list of lengths of consecutive identical characters\n→ replace ← sum over each len // 3\n\n→ if n < 6:\n    → insert ← 6 - n\n    → steps ← max(missing, replace, insert)\n    → Output steps\n    → End\n\n→ else if n <= 20:\n    → steps ← max(missing, replace)\n    → Output steps\n    → End\n\n→ else // n > 20\n    → deleteCount ← n - 20\n    → // Reduce repeats by deletions\n    → For each repeat length l in repeats:\n        → if deleteCount <= 0: break\n        → if l % 3 == 0:\n            → deletionsNeeded ← min(deleteCount, 1)\n            → l ← l - deletionsNeeded\n            → deleteCount ← deleteCount - deletionsNeeded\n        → // after handling l%3==0, adjust l\n    → // Repeat for l%3==1 with deletions 2\n    → // Then l%3==2 with deletions 3\n    → After deletions, recompute replace = sum(l // 3) over updated lengths\n    → steps ← deleteCount + max(missing, replace)\n    → Output steps\n    → End\n\nBut we must structure decision steps: loops, conditions, etc. Provide simple virtual code.\n\nWe should avoid too many lines but still illustrate each step.\n\nLet's produce pseudocode:\n\nStart // 程式開始執行\n→ Step 1: password ← input string // 取得輸入密碼\n→ Step 2: n ← length(password) // 計算長度\n→ Step 3: missing ← 0 // 缺失類型計數\n→ Step 4: if not contains lowercase → missing ← missing + 1\n→ Step 5: if not contains uppercase → missing ← missing + 1\n→ Step 6: if not contains digit → missing ← missing + 1\n→ Step 7: repeats ← empty list // 存放重複字串長度\n→ Step 8: i ← 0\n→ Decision: while i < n? // 遍歷字串\n    Yes → j ← i\n    → while j < n and password[j] == password[i] → j ← j + 1 // 找到相同段\n    → len ← j - i\n    → if len ≥ 3 → repeats.append(len)\n    → i ← j // 移至下個段\n    No  → // loop end\n\n→ Step 9: replace ← 0\n→ Decision: for each len in repeats?\n    Yes → replace ← replace + floor(len / 3)\n    No  → // end\n\n→ Decision: if n < 6? // 短於最小長度\n    Yes → insert ← 6 - n\n    → steps ← max(missing, replace, insert)\n    → Output steps\n    → End\n    No  → Decision: if n ≤ 20? // 合理長度\n        Yes → steps ← max(missing, replace)\n        → Output steps\n        → End\n        No  → // n > 20\n            → deleteCount ← n - 20\n            → // 將刪除應用於重複段\n            → For each len in repeats (按 len%3 ascending):\n                // 處理 len%3==0,1,2\n                → While deleteCount > 0 and len ≥ 3 and len % 3 == 0:\n                    → len ← len - 1\n                    → deleteCount ← deleteCount - 1\n                    → replace ← replace - 1 // 由於長度減 1，重複需求減 1\n                → // similar for len%3==1 with 2 deletions\n            → // After deletions, recompute replace if needed\n            → steps ← (n - 20) + max(missing, replace)\n            → Output steps\n            → End\n\nWe need to structure with Decision blocks, etc. Provide explanation after each line.\n\nWe must keep the number of lines moderate but show logic.\n\nWe can condense repeated code lines: For repeats handling, we may show as \"For each repeat length l in repeats:\" block with decisions.\n\nWe also need to keep arrows and decisions.\n\nLet's craft final answer accordingly. Use proper arrow and indentation.\n\nMake sure to include \"[空格] // 解釋\" after each line.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: password ← input string // 取得使用者輸入的密碼  \n→ Step 2: n ← length(password) // 計算密碼長度  \n→ Step 3: missing ← 0 // 初始缺失類型計數  \n→ Decision: 是否存在小寫字母? // 檢查是否缺少小寫  \n    Yes → // 已有小寫，無變動  \n    No  → missing ← missing + 1 // 缺少小寫，計數 +1  \n→ Decision: 是否存在大寫字母? // 檢查是否缺少大寫  \n    Yes → // 已有大寫，無變動  \n    No  → missing ← missing + 1 // 缺少大寫，計數 +1  \n→ Decision: 是否存在數字? // 檢查是否缺少數字  \n    Yes → // 已有數字，無變動  \n    No  → missing ← missing + 1 // 缺少數字，計數 +1  \n→ Step 4: repeats ← empty list // 用於儲存連續重複字符段長度  \n→ Step 5: i ← 0 // 初始化遍歷指標  \n→ Decision: i < n? // 循環遍歷整個字串  \n    Yes →  \n        → j ← i // j 為段結束指標  \n        → Decision: j < n and password[j] == password[i]? // 擴展同一字符段  \n            Yes → j ← j + 1  \n            No  → // 確定一段長度  \n        → len ← j - i // 段長度  \n        → Decision: len ≥ 3? // 是否為可影響重複問題的段  \n            Yes → repeats.append(len) // 加入重複列表  \n            No  → // 非重複段，忽略  \n        → i ← j // 移至下一段起點  \n    No  → // 完成遍歷  \n→ Step 6: replace ← 0 // 初始化需要替換次數  \n→ Decision: for each len in repeats? // 依次計算替換需求  \n    Yes → replace ← replace + floor(len / 3) // 每三個相同字符需要一次替換  \n    No  → // 完成計算  \n→ Decision: n < 6? // 密碼太短  \n    Yes →  \n        → insert ← 6 - n // 需要插入的字符數  \n        → steps ← max(missing, replace, insert) // 步驟數取最大值  \n        → Output steps // 回傳結果  \n        → End // 程式結束  \n    No  → Decision: n ≤ 20? // 長度在合法範圍內  \n        Yes →  \n            → steps ← max(missing, replace) // 只需替換或補充類型  \n            → Output steps  \n            → End  \n        No  → // 密碼太長，需要刪除  \n            → deleteCount ← n - 20 // 需刪除的字符數  \n            → // 將刪除用於減少重複段的替換需求  \n            → Decision: for each len in repeats? // 先處理 len%3==0 的段  \n                Yes →  \n                    → Decision: len % 3 == 0?  \n                        Yes →  \n                            → delUse ← min(deleteCount, 1) // 每刪一次可減 1 個替換需求  \n                            → len ← len - delUse  \n                            → deleteCount ← deleteCount - delUse  \n                            → replace ← replace - delUse // 替換需求相應減少  \n                        No  → // 其他情況稍後處理  \n                No  → // 下一個段  \n            → Decision: for each len in repeats? // 處理 len%3==1 的段（每刪 2 次）  \n                Yes →  \n                    → Decision: len % 3 == 1?  \n                        Yes →  \n                            → delUse ← min(deleteCount, 2)  \n                            → len ← len - delUse  \n                            → deleteCount ← deleteCount - delUse  \n                            → replace ← replace - floor(delUse / 3) // 可能減 1 個替換  \n                        No  →  \n                No  →  \n            → Decision: for each len in repeats? // 處理 len%3==2 的段（每刪 3 次）  \n                Yes →  \n                    → Decision: len % 3 == 2?  \n                        Yes →  \n                            → delUse ← min(deleteCount, 3)  \n                            → len ← len - delUse  \n                            → deleteCount ← deleteCount - delUse  \n                            → replace ← replace - floor(delUse / 3)  \n                        No  →  \n                No  →  \n            → // 若仍有剩餘刪除，直接減去 replace 以防負值  \n            → replace ← max(0, replace)  \n            → steps ← (n - 20) + max(missing, replace) // 刪除 + 其餘必要步驟  \n            → Output steps  \n            → End\n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def strongPasswordChecker(self, s: str) -> int:\n        n = len(s)\n        has_lower = has_upper = has_digit = 0\n        for c in s:\n            if c.islower():\n                has_lower = 1\n            elif c.isupper():\n                has_upper = 1\n            elif c.isdigit():\n                has_digit = 1\n        missing_types = 3 - (has_lower + has_upper + has_digit)\n\n        replace = 0\n        one_mod = two_mod = 0\n        i = 2\n        while i < n:\n            if s[i] == s[i-1] == s[i-2]:\n                length = 2\n                while i < n and s[i] == s[i-1]:\n                    length += 1\n                    i += 1\n                replace += length // 3\n                if length % 3 == 0:\n                    one_mod += 1\n                elif length % 3 == 1:\n                    two_mod += 1\n            else:\n                i += 1\n\n        if n < 6:\n            return max(6 - n, missing_types)\n        elif n <= 20:\n            return max(replace, missing_types)\n        else:\n            delete = n - 20\n            reduce = min(delete, one_mod)\n            replace -= reduce\n            delete -= reduce\n\n            reduce = min(max(delete, 0), two_mod * 2) // 2\n            replace -= reduce\n            delete -= reduce * 2\n\n            replace -= max(delete, 0) // 3\n\n            return (n - 20) + max(missing_types, replace)\n\ndef extract_password(raw_input: str) -> str:\n    # 尋找第一對雙引號中的內容\n    match = re.search(r'\"([^\"]*)\"', raw_input)\n    if match:\n        return match.group(1)\n    # 如果沒有雙引號，直接移除前後空白\n    return raw_input.strip()\n\ndef main():\n    raw = sys.stdin.read()\n    if not raw:\n        return\n    password = extract_password(raw)\n    result = Solution().strongPasswordChecker(password)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "password = \"a\"",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "password = \"aA1\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 2,
          "input": "password = \"1337C0d3\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode258.json",
    "problem_index_in_file": 0,
    "title": "Add Digits",
    "description_snippet": "Given an integer num, repeatedly add all its digits until the result has only one digit, and return ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nThe user wants virtual code for the problem: given integer num, repeatedly add all its digits until result has one digit, return it. That is digital root. Need to produce step-by-step virtual code, line by line with explanation. Use Start, End, Decision, arrow etc.\n\nWe need to produce virtual code only, not actual code. Each line: \"虛擬碼步驟 // 解釋\". The format should include the arrow \"→\", \"Decision:\" etc.\n\nWe can produce a simple algorithm: Input num, While num >= 10: sum digits; set num = sum; End while; Return num. Or use digital root formula. But virtual code likely uses loops.\n\nWe should produce the code lines like:\n\nStart // 程式開始執行\n→ Step 1: num = input integer // 取得使用者輸入的整數\n→ Decision: num >= 10? // 判斷是否已是一位數\n    Yes → Step 2: sum = 0 // 初始化累加變數\n    Yes → Step 3: temp = num // 用 temp 進行拆分\n    Yes → Step 4: Decision: temp > 0? // 仍有數字可拆分\n        Yes → Step 5: sum = sum + (temp mod 10) // 加上最低位數\n        Yes → Step 6: temp = temp / 10 // 去掉最低位數\n        Yes → Step 4 // 重新檢查 temp\n    Yes → Step 7: num = sum // 將求和結果存回 num\n    Yes → Step 1 // 重新開始判斷\n    No  → Step 8: return num // 已是一位數，返回結果\nEnd // 程式結束\n\nBut we need arrow for steps: Use \"→ Step X: ...\" maybe.\n\nBut we also need to ensure we follow the format: each line has \"虛擬碼步驟 // 解釋\". The arrow can be at beginning: \"→ Step 1: ...\" or \"Start\".\n\nWe should maintain indentation for nested decisions maybe.\n\nLet's produce final answer accordingly. Use Chinese commentary.\n\nAlso ensure to mention \"Start\" and \"End\".\n\nWe also might include \"Repeat\" or \"Loop\".\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: num ← InputInteger() // 取得使用者輸入的整數  \n→ Decision: num ≥ 10? // 檢查是否已是一位數  \n Yes → Step 2: sum ← 0 // 初始化數字總和  \n Yes → Step 3: temp ← num // 用 temp 進行拆分  \n Yes → Decision: temp > 0? // 是否還有數位未處理  \n  Yes → Step 4: sum ← sum + (temp mod 10) // 加上最低位數  \n  Yes → Step 5: temp ← temp ÷ 10 // 去掉最低位數  \n  Yes → Decision: temp > 0? // 重新檢查 temp 是否還有數位  \n   Yes → Step 4 // 回到加最低位數的步驟  \n   No → Step 6: num ← sum // 把求和結果存回 num  \n   No → Step 1 // 從頭開始判斷 num 是否已為一位數  \n No → Step 7: Return num // num 已是一位數，輸出結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def addDigits(self, num: int) -> int:\n        \"\"\"Repeatedly sum the digits of num until a single digit remains.\"\"\"\n        while num >= 10:\n            num = sum(int(digit) for digit in str(num))\n        return num\n\ndef main() -> None:\n    # 讀取整個輸入並嘗試從中找出第一個整數\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    match = re.search(r'-?\\d+', data)\n    if not match:\n        return\n    num = int(match.group())\n    \n    solution = Solution()\n    result = solution.addDigits(num)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num = 38",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "num = 0",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode205.json",
    "problem_index_in_file": 0,
    "title": "Isomorphic Strings",
    "description_snippet": "Given two strings s and t, determine if they are isomorphic.\n\nTwo strings s and t are isomorphic if ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. We need to handle mapping of characters, check conditions. Provide step by step.\n\nWe should produce Start, then steps.\n\nUse arrow → for each step.\n\nWe need to maintain mapping from s to t, and also reverse mapping to ensure no two map to same.\n\nWe need to check lengths equal, else false.\n\nWe'll produce steps:\n\nStart\n\n→ Step 1: 如果 s.length ≠ t.length, return false // length mismatch\n\n→ Step 2: 初始化映射 Map<Char, Char> mapST\n\n→ Step 3: 初始化反向映射 Map<Char, Char> mapTS\n\n→ Step 4: For i from 0 to s.length-1\n\n   → Step 4.1: char cs = s[i], ct = t[i]\n\n   → Decision: cs 是否已映射? // check if cs in mapST\n\n      Yes → Decision: mapST[cs] 是否等于 ct? // consistency\n\n          Yes → Continue\n\n          No  → Return false\n\n      No → Decision: ct 是否已被其他字元映射? // check if ct in mapTS\n\n          Yes → Return false\n\n          No → 添加映射 cs->ct 以及 ct->cs\n\n→ Step 5: 返回 true // 所有檢查通過\n\nEnd\n\nAlso include explanation after each line.\n\nWe need to use \"虛擬碼步驟\" before explanation.\n\nWe should follow example format.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Decision: 若 s 的長度不等於 t? // 檢查長度是否相同\n    Yes → Step: 回傳 false // 長度不同，非同構\n    No  →  // 繼續\n→ Step: 建立空映射 MapST // 從 s 到 t 的字符映射\n→ Step: 建立空反向映射 MapTS // 從 t 到 s 的字符映射\n→ Step: For i = 0 到 s.length-1 // 逐位檢查\n    → Step: cs = s[i], ct = t[i] // 取得對應字符\n    → Decision: cs 是否已存在於 MapST? // 已經有映射嗎\n        Yes → Decision: MapST[cs] ≠ ct? // 是否一致\n            Yes → Step: 回傳 false // 不一致，非同構\n            No  → Step: 繼續 // 一致，檢查下一對\n        No  → Decision: ct 是否已被其他字符映射? // 反向檢查\n            Yes → Step: 回傳 false // ct 已被映射，違反唯一性\n            No  → Step: MapST[cs] = ct // 添加映射\n            → Step: MapTS[ct] = cs // 添加反向映射\n→ Step: 回傳 true // 所有字符都符合規則\nEnd // 程式結束\n\nBut we need to be careful: each line separate, with arrow and explanation. For nested steps, we need indent? In example, they indent lines inside decision. We can use similar indentation.\n\nLet's craft final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: 若 s 的長度不等於 t? // 檢查兩字串長度是否相同  \n  Yes → Step: 回傳 false // 長度不同，非同構  \n  No  →  // 繼續執行  \n→ Step: 建立空映射 MapST // s → t 的字符對應表  \n→ Step: 建立空反向映射 MapTS // t → s 的字符對應表  \n→ Step: For i = 0 到 s.length-1 // 逐位檢查  \n  → Step: cs = s[i], ct = t[i] // 取得對應字符  \n  → Decision: cs 是否已存在於 MapST? // 已經有映射嗎  \n    Yes → Decision: MapST[cs] ≠ ct? // 映射是否一致  \n      Yes → Step: 回傳 false // 不一致，非同構  \n      No  → Step: 繼續 // 一致，檢查下一對  \n    No  → Decision: ct 是否已被其他字符映射? // 反向唯一性檢查  \n      Yes → Step: 回傳 false // ct 已被映射，違反唯一性  \n      No  → Step: MapST[cs] = ct // 添加 s→t 的映射  \n       → Step: MapTS[ct] = cs // 添加 t→s 的反向映射  \n→ Step: 回傳 true // 所有字符對應符合同構規則  \nEnd // 程式結束執行",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def isIsomorphic(self, s: str, t: str) -> bool:\n        if len(s) != len(t):\n            return False\n        mapping_s_t = {}\n        mapping_t_s = {}\n        for c1, c2 in zip(s, t):\n            if c1 in mapping_s_t and mapping_s_t[c1] != c2:\n                return False\n            if c2 in mapping_t_s and mapping_t_s[c2] != c1:\n                return False\n            mapping_s_t[c1] = c2\n            mapping_t_s[c2] = c1\n        return True\n\ndef main():\n    data = sys.stdin.read()\n    # 提取所有被雙引號包住的字串\n    strings = re.findall(r'\"([^\"]*)\"', data)\n    if len(strings) < 2:\n        # 若未能提取到兩個字串，嘗試以空格或逗號分隔\n        parts = re.split(r'[,\\s]+', data)\n        # 去除可能的空字串與引號\n        strings = [p.strip('\"') for p in parts if p.strip('\"')]\n    if len(strings) < 2:\n        # 若仍不足，直接輸出 false\n        print('false')\n        return\n    s, t = strings[0], strings[1]\n    solution = Solution()\n    result = solution.isIsomorphic(s, t)\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"egg\", t = \"add\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "s = \"foo\", t = \"bar\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "s = \"paper\", t = \"title\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode412.json",
    "problem_index_in_file": 0,
    "title": "Fizz Buzz",
    "description_snippet": "Given an integer n, return a string array answer (1-indexed) where:\n\nanswer[i] == \"FizzBuzz\" if i is...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nThe user wants virtual code for FizzBuzz problem. We need to output line by line steps with arrow syntax. Use Start, Decision, Yes →, No →. Should not produce actual code, just virtual code. Provide explanation after each line. Ensure 1-indexed array. We must include Steps: initialize array, loop from 1 to n, decisions inside, assign string. Let's craft.\n\nWe need Start, then Step 1: initialize answer array length n, maybe zero-based but conceptually 1-indexed. Then loop i from 1 to n. Inside loop, Decision: if i divisible by 15? then assign FizzBuzz. else Decision: if i divisible by 3? assign Fizz. else Decision: if i divisible by 5? assign Buzz. else assign string of i. Then End.\n\nLet's produce. Use `→` arrow. Indent decisions. Provide explanation comments after //.\n\nNeed to be careful to use consistent arrow style. For decisions, use `Decision:` line. For Yes/No branches use indentation. For each line, explanation.\n\nLet's write:\n\n```\nStart // 程式開始執行\n→ Step 1: 建立長度為 n 的答案陣列 answer // 產生 1-indexed 陣列存放結果\n→ Step 2: 從 1 到 n 迴圈 i // 逐一檢查每個整數\n    → Decision: i 可被 15 整除? // 同時 divisible by 3 and 5\n        Yes → Step 3: answer[i] = \"FizzBuzz\" // 當同時符合時，存入 FizzBuzz\n        No  → Decision: i 可被 3 整除? // 只檢查 3\n            Yes → Step 4: answer[i] = \"Fizz\" // 只符合 3 時\n            No  → Decision: i 可被 5 整除? // 只檢查 5\n                Yes → Step 5: answer[i] = \"Buzz\" // 只符合 5 時\n                No  → Step 6: answer[i] = i 的字串 // 兩條件都不符合時，轉成字串\n→ End // 程式結束，返回 answer\n```\n\nMake sure each line has explanation. Also use // after each line. Provide final.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立長度為 n 的答案陣列 answer // 產生 1-indexed 陣列存放結果\n→ Step 2: 從 1 到 n 迴圈 i // 逐一檢查每個整數\n    → Decision: i 可被 15 整除? // 同時 divisible by 3 and 5\n        Yes → Step 3: answer[i] = \"FizzBuzz\" // 當同時符合時，存入 FizzBuzz\n        No  → Decision: i 可被 3 整除? // 只檢查 3\n            Yes → Step 4: answer[i] = \"Fizz\" // 只符合 3 時\n            No  → Decision: i 可被 5 整除? // 只檢查 5\n                Yes → Step 5: answer[i] = \"Buzz\" // 只符合 5 時\n                No  → Step 6: answer[i] = i 的字串 // 兩條件都不符合時，轉成字串\n→ End // 程式結束，返回 answer",
      "generated_code": "import sys\nimport json\n\nclass Solution:\n    def fizzBuzz(self, n):\n        \"\"\"\n        產生 1-indexed FizzBuzz 陣列\n        \"\"\"\n        res = []\n        for i in range(1, n + 1):\n            if i % 15 == 0:            # 同時 divisible by 3 and 5\n                res.append(\"FizzBuzz\")\n            elif i % 3 == 0:           # only divisible by 3\n                res.append(\"Fizz\")\n            elif i % 5 == 0:           # only divisible by 5\n                res.append(\"Buzz\")\n            else:                      # none of the above\n                res.append(str(i))\n        return res\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    # 若輸入格式為 'n = 3' 等，取等號右側為數字\n    if '=' in data:\n        n_str = data.split('=')[-1].strip()\n    else:\n        n_str = data\n    n = int(n_str)\n\n    # 呼叫解法並輸出 JSON 格式的結果，使用雙引號\n    result = Solution().fizzBuzz(n)\n    print(json.dumps(result))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 3",
          "expected_output": "[\"1\",\"2\",\"Fizz\"]",
          "success": true,
          "output": "[\"1\", \"2\", \"Fizz\"]"
        },
        {
          "example_index": 1,
          "input": "n = 5",
          "expected_output": "[\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\"]",
          "success": true,
          "output": "[\"1\", \"2\", \"Fizz\", \"4\", \"Buzz\"]"
        },
        {
          "example_index": 2,
          "input": "n = 15",
          "expected_output": "[\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\",\"Fizz\",\"7\",\"8\",\"Fizz\",\"Buzz\",\"11\",\"Fizz\",\"13\",\"14\",\"FizzBuzz\"]",
          "success": true,
          "output": "[\"1\", \"2\", \"Fizz\", \"4\", \"Buzz\", \"Fizz\", \"7\", \"8\", \"Fizz\", \"Buzz\", \"11\", \"Fizz\", \"13\", \"14\", \"FizzBuzz\"]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode150.json",
    "problem_index_in_file": 0,
    "title": "Evaluate Reverse Polish Notation",
    "description_snippet": "You are given an array of strings tokens that represents an arithmetic expression in a Reverse Polis...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for evaluating RPN tokens array. Need to output line by line. Use virtual code steps: Start, arrow, etc. Provide explanation comment after //.\n\nWe must not output actual code. Just steps. Should include stack operations.\n\nWe'll produce:\n\nStart // begin\n→ Step 1: Initialize empty stack // create stack to hold operands\n→ Step 2: For each token in tokens array // iterate tokens\n   → Decision: token is operator? // check if token is + - * /\n      Yes → Step 3: Pop operand2 from stack // second operand\n      → Step 4: Pop operand1 from stack // first operand\n      → Step 5: Compute result = operand1 operator operand2 // perform operation\n      → Step 6: Push result onto stack // push back\n      No  → Step 7: Convert token to integer // parse number\n      → Step 8: Push integer onto stack // push operand\n→ Step 9: After loop, stack top is result // final value\n→ Decision: stack size 1? // ensure only result left\n   Yes → Step 10: Return stack top // output result\n   No  → Step 11: Handle error // not needed as input valid\nEnd // finished\n\nNeed to include indentation? The example used indentation with Decision lines inside. We'll use similar style.\n\nAlso note division truncating toward zero: we need to note that.\n\nWe must use virtual code arrows: →, Yes →, No →. Use Decision lines.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化空堆疊 // 建立一個空棧用來儲存操作數\n→ Step 2: 針對 tokens 陣列中的每一個 token 進行迴圈 // 逐個處理 RPN 表達式\n   → Decision: token 是運算子 (+, -, *, /)？ // 判斷 token 是否為運算符\n      Yes → Step 3: 從堆疊中彈出 operand2 // 第二個操作數（右側）\n      → Step 4: 從堆疊中彈出 operand1 // 第一個操作數（左側）\n      → Step 5: 計算 result = operand1 [operator] operand2 // 執行對應運算\n      → Step 6: 將 result 推回堆疊 // 把計算結果再次存回堆疊\n      No  → Step 7: 將 token 轉換為整數 // 解析數字字串\n      → Step 8: 將整數推入堆疊 // 把操作數存進堆疊\n→ Step 9: 迴圈結束後，堆疊頂端即為最終結果 // 堆疊中剩下的唯一值是答案\n→ Decision: 堆疊大小為 1？ // 確認只有一個結果\n   Yes → Step 10: 返回堆疊頂端值 // 輸出 RPN 表達式的計算結果\n   No  → Step 11: 處理錯誤（此情況不會發生，因為輸入有效） // 當堆疊非單一值時\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def evalRPN(self, tokens):\n        stack = []\n        for token in tokens:\n            if token in '+-*/':\n                b = stack.pop()\n                a = stack.pop()\n                if token == '+':\n                    stack.append(a + b)\n                elif token == '-':\n                    stack.append(a - b)\n                elif token == '*':\n                    stack.append(a * b)\n                elif token == '/':\n                    # 兩數相除，結果向零取整\n                    stack.append(int(a / b))\n            else:\n                stack.append(int(token))\n        return stack[0]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 只取方括號之間的字串，再用 ast.literal_eval 解析成 list\n    idx = data.find('[')\n    if idx == -1:\n        # 若輸入本身就是 list，直接解析\n        tokens = ast.literal_eval(data)\n    else:\n        tokens = ast.literal_eval(data[idx:])\n    solution = Solution()\n    result = solution.evalRPN(tokens)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "tokens = [\"2\",\"1\",\"+\",\"3\",\"*\"]",
          "expected_output": "9",
          "success": true,
          "output": "9"
        },
        {
          "example_index": 1,
          "input": "tokens = [\"4\",\"13\",\"5\",\"/\",\"+\"]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 2,
          "input": "tokens = [\"10\",\"6\",\"9\",\"3\",\"+\",\"-11\",\"*\",\"/\",\"*\",\"17\",\"+\",\"5\",\"+\"]",
          "expected_output": "22",
          "success": true,
          "output": "22"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode90.json",
    "problem_index_in_file": 0,
    "title": "Subsets II",
    "description_snippet": "Given an integer array nums that may contain duplicates, return all possible subsets (the power set)...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code step-by-step for generating all subsets of a multiset (array may contain duplicates) with no duplicate subsets. Classic approach: sort array, backtracking, skip duplicates. Provide lines with \"Start\", \"→ Step\", \"Decision:\" etc.\n\nWe need to output each line as \"虛擬碼步驟 // 解釋/說明\". Use arrow etc. Ensure step by step. Use Start and End. No actual code.\n\nWe produce lines like:\n\nStart // 程式開始執行\n→ Step 1: Sort nums ascending // 先排序以便於跳過重複元素\n→ Step 2: Initialize result list with empty subset // 開始時包含空集\n→ Step 3: Define recursive function backtrack(index, current) // 回溯函數\n    → Decision: 是否已到達陣列末尾? // 判斷是否完成一個子集\n        Yes → Step 4: 複製 current 並加入 result // 將子集加入結果\n        No  → Decision: 先不選取 nums[index]?\n            Yes → Step 5: Call backtrack(index+1, current) // 跳過該元素\n            No  → Step 6: 添加 nums[index] 至 current\n                → Step 7: Call backtrack(index+1, current) // 選取該元素\n                → Step 8: 移除最後一個元素從 current // 回溯\n                → Decision: 若 index>0 且 nums[index]==nums[index-1]?\n                    Yes → Step 9: 回傳 (skip following duplicates) // 跳過重複選取\n                    No  → // 继续\nWait, need proper handling: typical algorithm: for each i from start to end: if i>start and nums[i]==nums[i-1] skip; else add nums[i] and rec backtrack(i+1). So maybe better to implement iteration inside backtrack rather than two decisions.\n\nSimplify: Use iterative approach: For each index, decide to include or skip, but skip duplicates by checking if current index>start and same as previous and not included before? Another typical approach: At each recursion, iterate i from start to n-1: if i>start && nums[i]==nums[i-1] continue; choose nums[i], add to path, backtrack(i+1), backtrack ends, pop.\n\nThus we produce pseudo-code accordingly.\n\nWe need to show each line of pseudo-code with explanation. Use arrows.\n\nLet's produce:\n\nStart\n→ Step 1: Sort nums ascending // 先排序方便跳過重複\n→ Step 2: Initialize result as list containing empty list // 空集始終是子集\n→ Step 3: Call DFS(startIndex=0, currentPath=[]) // 開始回溯\n    → Step 4: Append copy of currentPath to result // 將當前子集加入結果\n    → Step 5: For i from startIndex to length(nums)-1\n        → Decision: 是否已處理完所有元素? // 迴圈控制\n            No → Step 6: Decision: i>startIndex 且 nums[i]==nums[i-1]?\n                Yes → Step 7: Continue // 跳過重複元素，避免重複子集\n                No  → Step 8: Append nums[i] to currentPath // 選取此元素\n                    → Step 9: Call DFS(i+1, currentPath) // 進入下一層\n                    → Step 10: Remove last element from currentPath // 回溯\nEnd\n\nNeed to ensure each line is \"虛擬碼步驟 // 解釋\". Use \"→\" for steps and decisions. Indent inside recursion but just plain lines. The indentation can be shown by indentation spaces. The decisions use \"Decision:\".\n\nLet's write accordingly.\n\nMake sure no actual code but pseudo steps.\n\nWill produce final answer in Chinese.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort nums ascending // 先將輸入陣列排序，方便後續跳過重複元素  \n→ Step 2: Initialize result as list containing empty list // 空集始終是合法子集，先加入結果集合  \n→ Step 3: Call DFS(startIndex = 0, currentPath = []) // 開始遞迴回溯  \n    → Step 4: Append copy of currentPath to result // 把目前路徑的子集加入結果  \n    → Step 5: For i from startIndex to length(nums) - 1 // 逐個嘗試把每個元素加入子集  \n        → Decision: i > startIndex AND nums[i] == nums[i-1]? // 檢查是否為重複元素且不在本層首次選擇  \n            Yes → Step 6: Continue // 跳過重複的選擇，避免產生重複子集  \n            No  → Step 7: Append nums[i] to currentPath // 選取該元素，擴展目前子集  \n                → Step 8: Call DFS(i + 1, currentPath) // 進一步探討更深層的子集  \n                → Step 9: Remove last element from currentPath // 回溯，移除剛才加入的元素  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def subsetsWithDup(self, nums):\n        \"\"\"Return all unique subsets of nums (nums may contain duplicates).\"\"\"\n        nums.sort()                # Sort to group duplicates together\n        res = [[]]                 # Start with the empty subset\n\n        for num in nums:\n            # For each existing subset, create a new subset that includes num\n            new_subsets = [subset + [num] for subset in res]\n            res += new_subsets    # Append new subsets to the result list\n\n        # Remove duplicate subsets that might have been created when nums had duplicates\n        unique_res = []\n        seen = set()\n        for subset in res:\n            t = tuple(subset)\n            if t not in seen:\n                seen.add(t)\n                unique_res.append(subset)\n\n        return unique_res\n\n\ndef parse_input(data: str):\n    \"\"\"\n    Extract the list of integers from a string like 'nums = [1,2,2]'.\n    \"\"\"\n    # Find the first '[' and the matching ']'\n    start = data.find('[')\n    if start == -1:\n        raise ValueError(\"Input does not contain a list.\")\n    end = data.rfind(']')\n    if end == -1:\n        raise ValueError(\"Input does not contain a closing ']'.\")\n\n    list_str = data[start:end+1]\n    # Use ast.literal_eval for safe evaluation\n    return ast.literal_eval(list_str)\n\n\nif __name__ == \"__main__\":\n    # Read entire stdin\n    raw_input = sys.stdin.read()\n    if not raw_input.strip():\n        sys.exit(0)\n\n    try:\n        nums = parse_input(raw_input)\n    except Exception as e:\n        print(f\"Error parsing input: {e}\", file=sys.stderr)\n        sys.exit(1)\n\n    solution = Solution()\n    result = solution.subsetsWithDup(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,2]",
          "expected_output": "[[],[1],[1,2],[1,2,2],[2],[2,2]]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[1,2],[1,2,2],[2],[2,2]]'\nGot (Norm):      '[[],[1],[2],[1,2],[2,2],[1,2,2]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[1,2],[1,2,2],[2],[2,2]]'\nRaw Got:      '[[], [1], [2], [1, 2], [2, 2], [1, 2, 2]]'"
        },
        {
          "example_index": 1,
          "input": "nums = [0]",
          "expected_output": "[[],[0]]",
          "success": true,
          "output": "[[], [0]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode415.json",
    "problem_index_in_file": 0,
    "title": "Add Strings",
    "description_snippet": "Given two non-negative integers, num1 and num2 represented as string, return the sum of num1 and num...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code solution for adding two large numbers represented as strings without converting to integers or using big integer library. Need to produce line-by-line pseudocode with explanation. Format: each line: \"虛擬碼步驟 // 解釋\". Use arrows →, Decision:, Start, End. Should include steps: start, initialize indices at end of strings, carry=0, result string builder, loop while any index>=0 or carry>0, get digit1/digit2 else 0, sum = digit1+digit2+carry, digit = sum%10, carry=sum/10, prepend or append to result, after loop reverse if appended or use prepend. In virtual code, we can use append to a string builder then reverse at end. Or build result in reverse order and reverse at the end. Provide steps accordingly.\n\nWe need to adhere to \"虛擬碼步驟\" + space + \"// 解釋\". Use Chinese. Ensure use of arrow. We'll produce something like:\n\nStart // 程式開始\n→ Step 1: 設定 i = len(num1)-1, j = len(num2)-1, carry = 0, result = \"\" // 初始化指標與輸出\n→ Step 2: 開始迴圈 While i>=0 或 j>=0 或 carry>0 // 進行加法\n    → Step 3: digit1 = i>=0 ? num1[i]-'0' : 0 // 取 num1 當前位數字\n    → Step 4: digit2 = j>=0 ? num2[j]-'0' : 0 // 取 num2 當前位數字\n    → Step 5: sum = digit1 + digit2 + carry // 計算總和\n    → Step 6: result = (sum%10) + result // 將單位數加到前面\n    → Step 7: carry = sum / 10 // 更新進位\n    → Step 8: i--, j-- // 移動指標\n→ End While\n→ Step 9: 回傳 result // 輸出相加結果\nEnd // 程式結束\n\nBut need to use arrows for each step. Provide indentation. Use \"Yes →\", \"No →\" for decisions but there is only a while loop and no branching with Yes/No. We can still use Decision: If i>=0 or j>=0 or carry>0? Yes → loop body, No → exit.\n\nAlso need to show Step 2 as Decision. So:\n\n→ Decision: i>=0 or j>=0 or carry>0? // 判斷是否還有位數或進位\n    Yes → Step 3: digit1 = ...\n    ...\n    No → Step 9: 回傳 result\n\nYes we can structure like that.\n\nAlso note that we must not convert the whole string to integer directly; using char - '0' is allowed.\n\nMake sure each line uses `虛擬碼步驟 // 解釋`. Include `Start` and `End`.\n\nOk produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: i ← len(num1) - 1, j ← len(num2) - 1, carry ← 0, result ← \"\" // 初始化指標、進位及結果字串\n→ Decision: i ≥ 0 或 j ≥ 0 或 carry > 0? // 判斷是否還有位數或進位需要處理\n    Yes → Step 2: digit1 ← (i ≥ 0) ? num1[i] - '0' : 0 // 取得 num1 當前位數字，若指標已越界則為 0\n    Yes → Step 3: digit2 ← (j ≥ 0) ? num2[j] - '0' : 0 // 取得 num2 當前位數字，若指標已越界則為 0\n    Yes → Step 4: sum ← digit1 + digit2 + carry // 計算兩位數字及進位之和\n    Yes → Step 5: result ← char('0' + (sum % 10)) + result // 將單位數加到結果前面\n    Yes → Step 6: carry ← sum / 10 // 更新進位\n    Yes → Step 7: i ← i - 1, j ← j - 1 // 移動到下一位\n    Yes → Decision: i ≥ 0 或 j ≥ 0 或 carry > 0? // 回到判斷條件，若仍有位數或進位則重複迴圈\n        Yes → (回到 Step 2) // 迴圈繼續\n        No  → Step 8: 回傳 result // 所有位數已處理完畢，返回加總結果\n    No  → Step 8: 回傳 result // 初始條件即為終止（雙字串皆為空），直接返回空字串\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def addStrings(self, num1: str, num2: str) -> str:\n        i, j = len(num1) - 1, len(num2) - 1\n        carry = 0\n        res = []\n\n        while i >= 0 or j >= 0 or carry:\n            x = int(num1[i]) if i >= 0 else 0\n            y = int(num2[j]) if j >= 0 else 0\n            total = x + y + carry\n            res.append(str(total % 10))\n            carry = total // 10\n            i -= 1\n            j -= 1\n\n        return ''.join(reversed(res))\n\ndef parse_input(data: str):\n    \"\"\"\n    Parses input of the form: num1 = \"value1\", num2 = \"value2\"\n    \"\"\"\n    pattern = r'num1\\s*=\\s*\"([^\"]*)\"\\s*,\\s*num2\\s*=\\s*\"([^\"]*)\"'\n    match = re.search(pattern, data)\n    if match:\n        return match.group(1), match.group(2)\n    # Fallback: try to split by whitespace or newline\n    parts = data.replace(',', ' ').split()\n    if len(parts) >= 4:\n        return parts[2].strip('\"'), parts[4].strip('\"')\n    raise ValueError(\"Input format not recognized\")\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    try:\n        num1, num2 = parse_input(raw_input)\n    except Exception:\n        # If parsing fails, assume the entire input consists of two lines\n        lines = raw_input.strip().splitlines()\n        if len(lines) >= 2:\n            num1, num2 = lines[0].strip(), lines[1].strip()\n        else:\n            # Last resort: split by space\n            parts = raw_input.strip().split()\n            num1, num2 = parts[0], parts[1]\n\n    solution = Solution()\n    result = solution.addStrings(num1, num2)\n    print(f'\"{result}\"')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num1 = \"11\", num2 = \"123\"",
          "expected_output": "\"134\"",
          "success": true,
          "output": "\"134\""
        },
        {
          "example_index": 1,
          "input": "num1 = \"456\", num2 = \"77\"",
          "expected_output": "\"533\"",
          "success": true,
          "output": "\"533\""
        },
        {
          "example_index": 2,
          "input": "num1 = \"0\", num2 = \"0\"",
          "expected_output": "\"0\"",
          "success": true,
          "output": "\"0\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode440.json",
    "problem_index_in_file": 0,
    "title": "K-th Smallest in Lexicographical Order",
    "description_snippet": "Given two integers n and k, return the kth lexicographically smallest integer in the range [1, n]....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines. Problem: find k-th lexicographically smallest integer in [1,n]. This is typical lexicographic order problem. We can use DFS or counting approach: count numbers with given prefix. Steps: start with prefix=0, count numbers between 1 and n starting with current prefix. Decrease k accordingly. Or we can build result iteratively: while k>0, move to next prefix. Use method: count= countNumbers(n, prefix, prefix+1). Decrement k by count if k > count, then prefix++. Else, append prefix to result and go deeper: prefix*=10; k-- (since we count the prefix itself). This is common. We need virtual code step-by-step.\n\nWe output each line as \"Step X: ...\" with explanation.\n\nWe must not output actual code, only virtual steps.\n\nWe need to use virtual code syntax: \"Start\", \"→ Step: ...\", \"Decision:\" with Yes/No, \"End\".\n\nWe need to produce lines in order.\n\nLet's design algorithm:\n\n1. Start\n2. Step 1: Initialize prefix=0, result=\"\"\n3. Step 2: While k > 0\n   Decision: If prefix == 0? Actually we need to find next prefix. We'll use loop to find next number.\n   Maybe we can do nested decisions: we need to determine whether to go deeper or to increment.\n\nBetter to follow typical algorithm:\n\n```\nprefix = 0\nwhile k > 0:\n    # Count numbers between prefix and prefix+1\n    count = countSteps(n, prefix, prefix+1)\n    if k > count:\n        k -= count\n        prefix += 1\n    else:\n        prefix *= 10\n        k -= 1\n```\n\nFinally, return prefix.\n\nWe need to provide explanation.\n\nAlso need to explain countSteps: function that counts numbers in [prefix, prefix+1) up to n. That counts all numbers with given prefix.\n\nWe can include a Step for countSteps definition.\n\nThus produce virtual code lines for algorithm.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: 定義函式 countSteps(n, low, high) // 計算在 [1, n] 內以 low 為前綴且小於 high 的數量\n→ Step 1a: steps = 0 // 累計數量\n→ Step 1b: while low <= n\n    → Decision: low < high? // 判斷 low 與 high 之間的範圍\n        Yes → steps += min(n+1, high) - low // 加上低到高之間合法數量\n        No  → steps += 0\n    → Step 1c: low *= 10; high *= 10 // 進入下一位數\n→ Step 1d: return steps // 回傳計算結果\n→ Step 2: prefix = 0 // 初始化前綴\n→ Step 3: while k > 0 // 重複直到找到第 k 個數\n    → Decision: k > 0? // 繼續\n        Yes → Step 4: count = countSteps(n, prefix, prefix+1) // 計算以 prefix 為前綴的數量\n        → Decision: k > count? // 是否跳過整個前綴區塊\n            Yes → Step 5: k -= count // 減去已跳過的數量\n                  Step 6: prefix += 1 // 移動到下一個同階層前綴\n            No  → Step 7: prefix *= 10 // 進入下一位數\n                  Step 8: k -= 1 // 數字自身已計算\n→ End // 返回 prefix 為答案\n\nBut we need to include returning prefix. Maybe Step 9: return prefix // k-th lexicographic number\n\nBut we also need to include final return after loop ends. Maybe add a step after loop: Step 9: return prefix // 輸出結果\n\nAlso need to consider that when prefix is 0 we skip? Actually algorithm uses prefix starting from 0; but typical algorithm uses prefix starting from 0 and then inside loop we use prefix +=1 after count? Wait typical algorithm starts with prefix=0 and then uses while k>0: count=countSteps(n, prefix, prefix+1); if k>count: k-=count; prefix+=1; else: prefix*=10; k-=1. After loop return prefix.\n\nThus above is fine.\n\nNeed to add explanation for each step. Must ensure each line uses \"→\" at beginning or \"Start\"/\"End\". Use \"→ Step X:\" pattern.\n\nAlso use \"Decision:\" with Yes →, No → lines.\n\nMake sure each line has one virtual code step and comment.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義函式 countSteps(n, low, high) // 計算在 [1, n] 內以 low 為前綴且小於 high 的數量  \n→ Step 1a: steps = 0 // 初始累計數量  \n→ Step 1b: while low <= n // 只要前綴在範圍內就繼續  \n→ Decision: low < high? // 判斷 low 與 high 之間的有效區間  \n  Yes → steps += min(n+1, high) - low // 加入 low 到 high 之間合法數量  \n  No  → steps += 0 // 無效區間不做累加  \n→ Step 1c: low *= 10; high *= 10 // 進入下一位數（前綴擴展）  \n→ Step 1d: return steps // 回傳計算結果  \n→ Step 2: prefix = 0 // 初始化前綴為 0，準備從 1 開始  \n→ Step 3: while k > 0 // 重複直到找到第 k 個數  \n  Decision: k > 0? // 繼續搜尋  \n   Yes → Step 4: count = countSteps(n, prefix, prefix+1) // 計算以 prefix 為前綴的所有數量  \n   Decision: k > count? // 是否跳過整個前綴區塊  \n    Yes → Step 5: k -= count // 減去已跳過的數量  \n     Step 6: prefix += 1 // 移動到下一個同階層前綴  \n    No  → Step 7: prefix *= 10 // 進入下一位數（前綴加深）  \n     Step 8: k -= 1 // 數字自身已計算，將 k 減 1  \n→ Step 9: return prefix // k‑th lexicographically smallest integer  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef count_prefix(prefix: int, n: int) -> int:\n    \"\"\"計算在 [1, n] 內，以 prefix 為前綴的所有數字個數。\"\"\"\n    cur, nxt = prefix, prefix + 1\n    cnt = 0\n    while cur <= n:\n        cnt += min(n + 1, nxt) - cur\n        cur *= 10\n        nxt *= 10\n    return cnt\n\ndef find_kth_number(n: int, k: int) -> int:\n    \"\"\"返回 [1, n] 中第 k 個字典序最小的數。\"\"\"\n    curr = 1          # 目前正在考慮的前綴\n    k -= 1            # 因為我們已經把 curr 本身算進去\n    while k > 0:\n        cnt = count_prefix(curr, n)\n        if k >= cnt:      # 整個前綴區塊都要跳過\n            k -= cnt\n            curr += 1\n        else:             # 進入前綴的下一位\n            k -= 1\n            curr *= 10\n    return curr\n\ndef main() -> None:\n    # 從標準輸入讀取所有整數，支持「n = 13, k = 2」或「13 2」等格式\n    data = sys.stdin.read()\n    nums = list(map(int, re.findall(r'\\d+', data)))\n    if len(nums) < 2:\n        return\n    n, k = nums[0], nums[1]\n    print(find_kth_number(n, k))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 13, k = 2",
          "expected_output": "10",
          "success": true,
          "output": "10"
        },
        {
          "example_index": 1,
          "input": "n = 1, k = 1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode40.json",
    "problem_index_in_file": 0,
    "title": "Combination Sum II",
    "description_snippet": "Given a collection of candidate numbers (candidates) and a target number (target), find all unique c...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line, using arrows, Start, End, Decision. It's backtracking combination sum with unique combinations, each number used at most once. The candidate list may have duplicates. We need to avoid duplicate combos.\n\nSo steps: sort candidates, define backtracking function with start index and current combination and remaining target. In function, if remaining target==0, add combination. Else iterate i from start to len-1; skip if i>start and candidates[i]==candidates[i-1] to avoid duplicates; if candidates[i]>remaining target, break; else choose candidate[i], recurse with i+1. After recursion, pop.\n\nSo output lines accordingly. Use \"Step X\" etc. We'll produce virtual code with arrows. Let's produce each line as \"→ Step 1: ... // explanation\". Use \"Decision:\" for checks. Use \"Yes →\", \"No →\" for branches. Use \"Start\" \"End\".\n\nLet's do. We'll need to decide naming. Let's produce:\n\nStart // program starts\n→ Step 1: Sort candidates in ascending order // for duplicate handling\n→ Step 2: Initialize result list // store combos\n→ Step 3: Call backtrack(startIndex=0, currentCombo=[], remaining=target) // start recursion\n→ Step 4: Output result // show all combos\nEnd\n\nThen define backtrack:\n\nBacktrack // function definition\n→ Decision: remaining == 0? // check if target reached\n    Yes → Step 5: Add copy of currentCombo to result // found combination\n    No  → Decision: startIndex == len(candidates)? // no more candidates\n        Yes → Step 6: Return // backtrack\n        No  → Step 7: For i from startIndex to len(candidates)-1: // iterate candidates\n            → Decision: i>startIndex and candidates[i]==candidates[i-1]? // skip duplicates\n                Yes → Step 8: Continue // skip this i\n                No  → Decision: candidates[i] > remaining? // early termination\n                    Yes → Step 9: Break // remaining cannot be satisfied\n                    No  → Step 10: Append candidates[i] to currentCombo // choose\n                    → Step 11: Call backtrack(i+1, currentCombo, remaining-candidates[i]) // recurse\n                    → Step 12: Pop last from currentCombo // backtrack\n\nWe'll need to structure the \"For\" loop as a step. We can combine Step 7 as a loop. Use arrow \"→ For i...\" etc.\n\nLet's output accordingly. Ensure each line ends with // 解釋.\n\nAlso need \"Start\" and \"End\". And include \"Backtrack\" maybe as \"Step X: 定義遞迴函式 backtrack\". But we can just include as a step. Let's produce as:\n\nStart // 程式開始\n→ Step 1: Sort candidates ascending // 方便去重\n→ Step 2: Initialize results list // 存放所有組合\n→ Step 3: Define recursive function backtrack(startIndex, currentCombo, remaining) // 進行回溯\n→ Step 4: Call backtrack(0, [], target) // 開始搜尋\n→ Step 5: Output results // 顯示所有獨特組合\nEnd // 程式結束\n\nBut we need the function body. We can include as separate block after definition. But requirement: every line must include virtual code step. So maybe we put backtrack definition as a block. Let's structure:\n\nStep 3: Define function backtrack(startIndex, currentCombo, remaining) // start recursion\n→ Decision: remaining == 0? // 是否達到目標\n    Yes → Step 6: Add copy of currentCombo to results // 儲存成功組合\n    No  → Decision: startIndex == len(candidates)? // 沒有更多候選\n        Yes → Step 7: Return // 回到上一層\n        No  → Step 8: For i from startIndex to len(candidates)-1 // 遍歷候選\n            → Decision: i > startIndex and candidates[i] == candidates[i-1]? // 跳過重複\n                Yes → Step 9: Continue // 跳過此 i\n                No  → Decision: candidates[i] > remaining? // 太大，提前結束\n                    Yes → Step 10: Break // 無法再匹配\n                    No  → Step 11: Append candidates[i] to currentCombo // 選取\n                    → Step 12: Call backtrack(i+1, currentCombo, remaining-candidates[i]) // 進一步遞迴\n                    → Step 13: Pop last from currentCombo // 回溯\n\nOk. Ensure each line has \"→\" or \"Start\". The \"Step 3:\" line maybe not preceded by arrow because it's part of main. But we can keep consistent. Use \"→ Step 3:\" after previous step. Good.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort candidates in ascending order // 先排序，方便後續去重  \n→ Step 2: Initialize result list // 用於儲存所有獨特組合  \n→ Step 3: Define function backtrack(startIndex, currentCombo, remaining) // 進行回溯搜尋  \n  → Decision: remaining == 0? // 是否已達到目標總和  \n   Yes → Step 4: Add copy of currentCombo to result // 找到合法組合，加入結果  \n   No  → Decision: startIndex == len(candidates)? // 是否已遍歷完所有候選數  \n    Yes → Step 5: Return // 無更多候選，回到上一層  \n    No  → Step 6: For i from startIndex to len(candidates)-1 // 從當前索引開始遍歷  \n      → Decision: i > startIndex and candidates[i] == candidates[i-1]? // 跳過重複的數字  \n       Yes → Step 7: Continue // 直接忽略這個 i  \n       No  → Decision: candidates[i] > remaining? // 目前數字已超過剩餘和  \n        Yes → Step 8: Break // 後續數字更大，結束迴圈  \n        No  → Step 9: Append candidates[i] to currentCombo // 選取此數字  \n         → Step 10: Call backtrack(i+1, currentCombo, remaining - candidates[i]) // 進一步遞迴  \n         → Step 11: Pop last from currentCombo // 回溯，移除剛才加入的數字  \n→ Step 12: Call backtrack(0, [], target) // 從最開始的索引 0 開始搜尋  \n→ Step 13: Output result // 顯示所有獨特組合  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef combination_sum2(candidates, target):\n    candidates.sort()\n    res = []\n\n    def backtrack(start, path, total):\n        if total == target:\n            res.append(list(path))\n            return\n        if total > target:\n            return\n        prev = -1\n        for i in range(start, len(candidates)):\n            if candidates[i] == prev:\n                continue\n            path.append(candidates[i])\n            backtrack(i + 1, path, total + candidates[i])\n            path.pop()\n            prev = candidates[i]\n\n    backtrack(0, [], 0)\n    return res\n\ndef parse_input(data):\n    # Find list of integers\n    list_match = re.search(r'\\[([^\\]]*)\\]', data)\n    if not list_match:\n        raise ValueError(\"No list found in input.\")\n    list_str = list_match.group(1)\n    candidates = list(map(int, re.findall(r'-?\\d+', list_str)))\n    # Find target integer\n    target_match = re.search(r'target\\s*=\\s*(-?\\d+)', data)\n    if not target_match:\n        raise ValueError(\"No target found in input.\")\n    target = int(target_match.group(1))\n    return candidates, target\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    candidates, target = parse_input(raw_input)\n    result = combination_sum2(candidates, target)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "candidates = [10,1,2,7,6,1,5], target = 8",
          "expected_output": "[[1,1,6],[1,2,5],[1,7],[2,6]]",
          "success": true,
          "output": "[[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]]"
        },
        {
          "example_index": 1,
          "input": "candidates = [2,5,2,1,2], target = 5",
          "expected_output": "[[1,2,2],[5]]",
          "success": true,
          "output": "[[1, 2, 2], [5]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode449.json",
    "problem_index_in_file": 0,
    "title": "Serialize and Deserialize BST",
    "description_snippet": "Serialization is converting a data structure or object into a sequence of bits so that it can be sto...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for algorithm to serialize/deserialize BST with compact representation. Steps: Use preorder traversal, output values separated by delimiter, maybe use commas. For deserialization, parse values and build BST using bounds. Provide algorithm pseudocode. Need to produce each line with explanation. Use Start/End/Decision arrows. Should be concise. We'll produce algorithm:\n\n- Start\n- Step 1: Preorder traversal to build string with delimiter\n- Step 2: During serialization, skip null nodes to keep compact\n- Step 3: For deserialization: parse string into list of integers\n- Step 4: Build BST using recursive helper with min/max bounds\n- End\n\nNeed to include decisions: e.g., if empty string -> return null\n\nAlso decision for building: if next value > max or < min skip.\n\nAlso need to handle reading from list index pointer.\n\nLet's produce each line accordingly.\n\nWe'll include arrow syntax:\n\nStart // 開始\n→ Step 1: ... // explanation\n→ Step 2: ... etc.\n\nBut need to use arrows? The requirement: Use 虛擬碼的箭頭 (→, Yes →, No →) and structure (Start, End, Decision:). So we may show steps using arrows. For decisions, we use Decision: if ...?.\n\nSo each line: \"→ Step X: ... // explanation\" or \"Decision: ...\".\n\nOk.\n\nWe'll create step numbering.\n\nLet's write.\n\nAlso include that delimiter is comma.\n\nAlso include parse step.\n\nOk. Let's craft.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空字串 `serialized` 以儲存序列化結果 // 準備儲存結果  \n→ Step 2: 定義遞迴函式 `serializePreorder(node)`  \n→     → If `node` 為 null, return // 空節點不輸出，保持字串緊湊  \n→     → Append `node.val` 到 `serialized`，後接逗號 // 先序序列化值  \n→     → `serializePreorder(node.left)` // 處理左子樹  \n→     → `serializePreorder(node.right)` // 處理右子樹  \n→ Step 3: 呼叫 `serializePreorder(root)` 完成序列化 // 生成完整字串  \n→ Step 4: 若 `serialized` 為空，返回空字串，否則去除最後一個逗號並返回 // 去除尾部逗號  \n\nDecision: 是否需要反序列化？  \nYes → Step 5: 以逗號分隔 `serialized` 成 `values` 陣列，轉為整數 // 解析字串為數值序列  \n→ Step 6: 初始化全域變數 `index = 0` 以追蹤當前解析位置  \n\n→ Step 7: 定義遞迴函式 `buildBST(min, max)`  \n→     → Decision: 若 `index` 等於 `values` 長度，回傳 null // 所有節點已處理  \nYes →     → Decision: 若 `values[index]` 小於 `min` 或大於 `max`，回傳 null // 不屬於此子樹範圍  \nYes →         → 建立新節點 `node = TreeNode(values[index])` // 創建節點  \n→         → `index += 1` // 移至下一個值  \n→         → `node.left = buildBST(min, node.val)` // 建立左子樹  \n→         → `node.right = buildBST(node.val, max)` // 建立右子樹  \n→         → Return `node` // 回傳已完成的子樹  \n→ End // 程式執行結束，已得到原始 BST 結構\n\n這份虛擬碼示範了如何用先序遍歷產生最小佔用空間的序列化字串，並利用極值範圍遞迴快速重建同一棵二元搜尋樹。",
      "generated_code": "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Codec:\n    def serialize(self, root):\n        \"\"\"Encode a BST to a compact string using preorder traversal.\"\"\"\n        res = []\n\n        def preorder(node):\n            if not node:\n                return\n            res.append(str(node.val))\n            preorder(node.left)\n            preorder(node.right)\n\n        preorder(root)\n        return ','.join(res)\n\n    def deserialize(self, data):\n        \"\"\"Decode the compact string back to a BST.\"\"\"\n        if not data:\n            return None\n        preorder = list(map(int, data.split(',')))\n\n        def build(min_val, max_val):\n            if preorder and min_val < preorder[0] < max_val:\n                val = preorder.pop(0)\n                node = TreeNode(val)\n                node.left = build(min_val, val)\n                node.right = build(val, max_val)\n                return node\n            return None\n\n        return build(float('-inf'), float('inf'))\n\ndef build_tree_from_array(arr, idx=0):\n    \"\"\"Build a binary tree from a level‑order array representation.\"\"\"\n    if idx >= len(arr):\n        return None\n    node = TreeNode(arr[idx])\n    node.left = build_tree_from_array(arr, 2 * idx + 1)\n    node.right = build_tree_from_array(arr, 2 * idx + 2)\n    return node\n\ndef parse_input(input_str):\n    \"\"\"Parse input like 'root = [2,1,3]' into a list of integers.\"\"\"\n    start = input_str.find('[')\n    end = input_str.find(']')\n    if start == -1 or end == -1 or start >= end:\n        return []\n    content = input_str[start + 1:end].strip()\n    if not content:\n        return []\n    return [int(x.strip()) for x in content.split(',')]\n\nif __name__ == \"__main__\":\n    import sys\n\n    # Read the whole input\n    raw_input = sys.stdin.read().strip()\n    # If input is empty, just output empty list\n    if not raw_input:\n        print(\"[]\")\n        sys.exit(0)\n\n    # Parse the input list\n    values = parse_input(raw_input)\n\n    # Build the tree from the array representation\n    root = build_tree_from_array(values)\n\n    # Serialize the BST\n    codec = Codec()\n    serialized = codec.serialize(root)\n\n    # Output in the same list format as input\n    if not serialized:\n        print(\"[]\")\n    else:\n        print(f'[{serialized}]')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "root = [2,1,3]",
          "expected_output": "[2,1,3]",
          "success": true,
          "output": "[2,1,3]"
        },
        {
          "example_index": 1,
          "input": "root = []",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode349.json",
    "problem_index_in_file": 0,
    "title": "Intersection of Two Arrays",
    "description_snippet": "Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation. We need to process intersection of two integer arrays, unique elements, order arbitrary. Approach: convert arrays to sets, compute intersection. Steps: Start, Step1 convert nums1 to set1, Step2 convert nums2 to set2, Step3 compute intersectionSet = set1 ∩ set2, Step4 convert to list or array, Step5 return result. Use virtual code style with arrow.\n\nLet's produce:\n\nStart\n→ Step 1: Initialize SetA with elements from nums1 // Build set from first array\n→ Step 2: Initialize SetB with elements from nums2 // Build set from second array\n→ Step 3: Initialize ResultSet as empty set // Prepare container for intersection\n→ Decision: For each element x in SetA // Iterate over first set\n    → Step 4: If x exists in SetB // Check presence in second set\n        Yes → Step 5: Add x to ResultSet // Add to intersection set\n        No → // Do nothing\nEnd // Done\n→ Step 6: Convert ResultSet to array // Prepare output\n→ Step 7: Return the array // Provide final intersection\n\nBut we must keep structure with arrows. Use arrow style: \"→ Step 1:\" etc. And include decision lines. Use Yes/No arrows. Use Start and End. Let's format.\n\nMake sure each line includes explanation after //.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 SetA，將 nums1 之所有元素加入 // 建立第一個集合  \n→ Step 2: 建立 SetB，將 nums2 之所有元素加入 // 建立第二個集合  \n→ Step 3: 建立空集合 ResultSet // 用於存放交集元素  \n→ Decision: 針對 SetA 中每個元素 x // 循環遍歷第一集合  \n  Yes → Step 4: 若 x 存在於 SetB // 檢查第二集合是否包含該元素  \n   Yes → Step 5: 將 x 加入 ResultSet // 將交集元素加入結果集合  \n   No  → // 不執行任何操作  \nEnd // 迴圈結束  \n→ Step 6: 將 ResultSet 轉換成陣列 // 準備輸出資料結構  \n→ Step 7: 回傳陣列 // 返回唯一交集元素的結果",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def intersection(self, nums1, nums2):\n        # 將兩個陣列轉成集合，再取交集，最後轉成 list\n        return list(set(nums1) & set(nums2))\n\ndef main():\n    # 讀取整個標準輸入\n    data = sys.stdin.read()\n    # 先找出所有中括號內的字串（假設第一個是 nums1，第二個是 nums2）\n    brackets = re.findall(r'\\[.*?\\]', data)\n    if len(brackets) >= 2:\n        nums1 = ast.literal_eval(brackets[0])\n        nums2 = ast.literal_eval(brackets[1])\n    else:\n        nums1, nums2 = [], []\n\n    sol = Solution()\n    res = sol.intersection(nums1, nums2)\n    # 為了輸出結果順序可預測，先排序\n    res.sort()\n    # 自訂輸出格式，避免 Python print 之間有空格\n    output = '[' + ','.join(map(str, res)) + ']'\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums1 = [1,2,2,1], nums2 = [2,2]",
          "expected_output": "[2]",
          "success": true,
          "output": "[2]"
        },
        {
          "example_index": 1,
          "input": "nums1 = [4,9,5], nums2 = [9,4,9,8,4]",
          "expected_output": "[9,4]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[9,4]'\nGot (Norm):      '[4,9]'\n--- (Raw) ---\nRaw Expected: '[9,4]'\nRaw Got:      '[4,9]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode416.json",
    "problem_index_in_file": 0,
    "title": "Partition Equal Subset Sum",
    "description_snippet": "Given an integer array nums, return true if you can partition the array into two subsets such that t...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for subset sum partition problem. Use dynamic programming. Steps: compute total sum, if odd return false, target = sum/2. Use DP array bool dp[target+1] set dp[0]=true. Iterate numbers, for each num reverse iterate j from target down to num: dp[j] = dp[j] or dp[j-num]. After loop, return dp[target]. Also include start end etc. Provide line-by-line with explanation. Use arrow notation. We'll do \"Start\", \"Step 1: Calculate total sum\", etc. Provide decisions: if total odd. Then DP steps. Provide final decision.\n\nLet's produce lines. Use proper indentation and arrows.\n\nMake sure to include \"End\" at end. Use \"Decision:\" lines with Yes/No.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算陣列 nums 的總和 totalSum // 取得所有元素之和  \n→ Decision: 如果 totalSum 為奇數? // 若總和無法被 2 整除，則不可能分成兩個相等子集  \n  Yes → Step 2: 回傳 false // 總和為奇數，直接返回不可能  \n  No  → Step 3: 設定目標 target = totalSum / 2 // 目標為兩個子集之和之一  \n→ Step 4: 建立布林陣列 dp[0 … target] 並初始化 dp[0] = true，其他為 false // dp[j] 代表是否能用已處理的元素得到和 j  \n→ Decision: 迭代每個元素 num in nums? // 開始動態規劃  \n  Yes → Step 5: 內層迴圈 j 從 target 降至 num  \n    → Decision: j >= num? // 確保能減去 num  \n     Yes → Step 6: 更新 dp[j] = dp[j] 或 dp[j - num] // 若之前能得到 j-num，則現在也能得到 j  \n     No  → // j < num 時不做更新",
      "generated_code": "import sys\nimport ast\nimport re\n\nclass Solution:\n    def canPartition(self, nums):\n        total = sum(nums)\n        if total % 2 != 0:\n            return False\n        target = total // 2\n\n        dp = [False] * (target + 1)\n        dp[0] = True\n\n        for num in nums:\n            for j in range(target, num - 1, -1):\n                dp[j] = dp[j] or dp[j - num]\n\n        return dp[target]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # Extract the list literal from input (e.g., \"nums = [1,5,11,5]\" or \"[1,5,11,5]\")\n    match = re.search(r'\\[.*?\\]', data, re.DOTALL)\n    if match:\n        list_str = match.group()\n    else:\n        list_str = data\n\n    try:\n        nums = ast.literal_eval(list_str)\n    except Exception:\n        print(\"false\")\n        sys.exit()\n\n    result = Solution().canPartition(nums)\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,5,11,5]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3,5]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode398.json",
    "problem_index_in_file": 0,
    "title": "Random Pick Index",
    "description_snippet": "Given an integer array nums with possible duplicates, randomly output the index of a given target nu...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps with explanation, no actual code, just step-by-step logic. The requirements: implement Solution class with constructor and pick method, need to store mapping from target to list of indices, or use reservoir sampling? Since we want equal probability. Approach: In constructor, build hash map from value to list of indices. In pick, retrieve list, pick random index from list. Provide steps.\n\nSo virtual code: Start, Step1: Initialize Solution(nums): Build dictionary mapping number to list of indices. End of constructor. Then pick method: Input target. Retrieve list. Determine length. Generate random integer in [0, len-1]. Return list[randomIndex].\n\nWe need to use virtual code with arrows and decisions. But simple steps. Could also incorporate Decision: If target not in map? but assumption it's present.\n\nLet's craft steps.\n\nUse arrow to show method entry, etc. Provide explanation after each line.\n\nAlso need to show Start/End for entire process? We can show separate flows for constructor and pick. Maybe overall flow Start, → Step: Define class Solution, etc.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 定義 class Solution // 宣告 Solution 類別\n→ Step 2: 在 constructor 內宣告 map<value, list<indices>> // 建立映射表\n→ Step 3: 循環遍歷 nums, 將索引加入對應 value 的 list // 將每個數字的索引儲存\n→ Step 4: 結束 constructor // 構造完成\n→ Step 5: 定義 pick(target) 方法 // pick 方法入口\n→ Decision: target 是否在 map? // 檢查 target 是否存在\n    Yes → Step 6: 取出 indices list // 取得該目標數字的索引列表\n    No  → Step 7: 直接返回 -1 // (根據假設此分支不會執行)\n→ Step 8: 計算 list 長度 n // 取得有效索引數\n→ Step 9: 生成隨機整數 r 在 [0, n-1] // 隨機選取\n→ Step 10: 回傳 indices[r] // 返回隨機索引\nEnd // 程式執行結束\n\nBut we need \"逐行\" with \"虛擬碼步驟\" + \" // 解釋\". Use arrow or Decision. Also maybe use Step numbers. Provide explanation.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 class Solution // 宣告 Solution 類別  \n→ Step 2: 在 constructor 內宣告 map<value, list<indices>> // 建立數值到索引列表的映射表  \n→ Step 3: 循環遍歷 nums, 將每個索引 i 加入 map[nums[i]] 的 list // 把所有索引按數值分類  \n→ Step 4: 結束 constructor // 物件初始化完成  \n\n→ Step 5: 定義 pick(target) 方法 // Pick 方法入口  \n→ Decision: target 是否在 map? // 確認目標值已存在（根據假設此分支永遠為 Yes）  \n  Yes → Step 6: 取出 indices list = map[target] // 取得對應目標的所有索引  \n  No  → Step 7: 回傳 -1 // 當 target 未找到時的備用回傳值（理論上不會執行）  \n\n→ Step 8: 計算 n = indices.length // 獲取列表長度  \n→ Step 9: 生成隨機整數 r 在 [0, n-1] // 隨機選擇一個位置  \n→ Step 10: 回傳 indices[r] // 返回被隨機選中的索引  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\nimport random\nfrom collections import defaultdict\n\nclass Solution:\n    \"\"\"\n    Solution class for random picking of indices.\n    \"\"\"\n    def __init__(self, nums):\n        \"\"\"\n        初始化，將每個數值對應到其所有索引的位置。\n        \"\"\"\n        self.num_indices = defaultdict(list)\n        for i, num in enumerate(nums):\n            self.num_indices[num].append(i)\n\n    def pick(self, target):\n        \"\"\"\n        從 nums 中所有等於 target 的索引中隨機挑選一個返回。\n        \"\"\"\n        return random.choice(self.num_indices[target])\n\ndef main():\n    \"\"\"\n    讀取標準輸入，解析方法調用序列，執行並輸出結果。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 將輸入包裝成 JSON 數組，方便解析\n    wrapped = f'[{data}]'\n    try:\n        methods, args_list = json.loads(wrapped)\n    except json.JSONDecodeError:\n        # 若已經是合法 JSON，直接解析\n        methods, args_list = json.loads(data)\n\n    outputs = []\n    obj = None\n\n    for method, args in zip(methods, args_list):\n        if method == \"Solution\":\n            # args 形如 [[1, 2, 3]]，取第一個元素作為 nums\n            obj = Solution(args[0])\n            outputs.append(None)\n        elif method == \"pick\":\n            # args 形如 [3]，取第一個元素作為 target\n            result = obj.pick(args[0])\n            outputs.append(result)\n\n    # 輸出結果為 JSON 數組\n    print(json.dumps(outputs))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\"], [[[1, 2, 3, 3, 3]], [3], [1], [3]]",
          "expected_output": "[null, 4, 0, 2]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,4,0,2]'\nGot (Norm):      '[null,4,0,4]'\n--- (Raw) ---\nRaw Expected: '[null, 4, 0, 2]'\nRaw Got:      '[null, 4, 0, 4]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode139.json",
    "problem_index_in_file": 0,
    "title": "Word Break",
    "description_snippet": "Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a spac...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for Word Break problem. Use DP. Steps: Start, input s, wordDict, DP array length n+1, dp[0]=True. Loop i from 1 to n, inner j from 0 to i, if dp[j] and s[j:i] in wordDict set dp[i]=True break. End. Return dp[n].\n\nWe need each line with explanation.\n\nLet's format.\n\nUse arrows: → Step 1: 取字串長度 n // get length\n\n→ Step 2: 初始化 dp[0..n] 為 False // bool array\n\n→ Step 3: dp[0] = True // 空字串可分割\n\n→ Step 4: For i = 1 to n // 外層迴圈\n\n→ Step 5: For j = 0 to i // 內層迴圈\n\n→ Step 6: If dp[j] == True AND s[j:i] in wordDict\n\n→ Step 7: dp[i] = True // 設定可分割\n\n→ Step 8: 跳出內層迴圈 // continue\n\n→ Step 9: End of inner loop\n\n→ Step 10: End of outer loop\n\n→ Step 11: 回傳 dp[n] // 判斷是否可分割\n\nWrap Start and End. Also include Decision arrow? It's not decision. We can use Decision: but not needed.\n\nWe'll keep Step labels.\n\nAdd comments.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 取字串長度 n = s.Length // 取得輸入字串長度\n→ Step 2: 初始化布林陣列 dp[0..n] 為 False // dp[i] 代表前 i 個字可否分割\n→ Step 3: 設定 dp[0] = True // 空字串視為可分割\n→ Step 4: For i = 1 to n // 逐字檢查\n    → Step 5: For j = 0 to i-1 // 逐個可能的切分點\n        → Step 6: Decision: 如果 dp[j] 為 True 且 s.Substring(j, i-j) 在 wordDict? // 檢查前 j 是否可分且後段是否為字典單字\n            Yes → Step 7: dp[i] = True // 這個長度可分割\n            Yes → Step 8: 跳出內層迴圈 // 已確定 dp[i]，無需再查\n            No  → // 继续检查下一个 j\n        → Step 9: End Decision\n    → Step 10: End For j\n→ Step 11: End For i\n→ Step 12: 回傳 dp[n] // 若最後一個位置可分割則為 true\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def wordBreak(self, s: str, wordDict: list[str]) -> bool:\n        # 轉成 set 方便 O(1) 判斷\n        word_set = set(wordDict)\n        # dp[i] 代表 s[:i] 能否被切分為字典詞\n        dp = [False] * (len(s) + 1)\n        dp[0] = True  # 空字串可以視為可切分\n\n        # 外層從 1 到 n\n        for i in range(1, len(s) + 1):\n            # 內層嘗試所有可能的切分點 j\n            for j in range(i):\n                # 若前面可切分且子字串在字典中\n                if dp[j] and s[j:i] in word_set:\n                    dp[i] = True\n                    break  # 找到一種切分即可\n        return dp[len(s)]\n\ndef parse_input(data: str):\n    \"\"\"\n    從形如\n        s = \"leetcode\", wordDict = [\"leet\",\"code\"]\n    的字串中擷取 s 與 wordDict。\n    \"\"\"\n    # 抓取 s 的內容\n    s_match = re.search(r's\\s*=\\s*\"([^\"]*)\"', data)\n    s = s_match.group(1) if s_match else \"\"\n\n    # 抓取 wordDict 內部的字串\n    dict_match = re.search(r'wordDict\\s*=\\s*\\[(.*?)\\]', data, re.S)\n    raw = dict_match.group(1) if dict_match else \"\"\n\n    # 將每個單字去除前後空白與引號\n    word_dict = []\n    for part in raw.split(','):\n        part = part.strip()\n        if not part:\n            continue\n        # 允許單引號或雙引號\n        word = part.strip('\"\\'')\n        if word:\n            word_dict.append(word)\n    return s, word_dict\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    raw_input = sys.stdin.read().strip()\n    s, word_dict = parse_input(raw_input)\n\n    # 建立解題物件並執行\n    sol = Solution()\n    result = sol.wordBreak(s, word_dict)\n\n    # 輸出小寫字串符合題目要求\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"leetcode\", wordDict = [\"leet\",\"code\"]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "s = \"applepenapple\", wordDict = [\"apple\",\"pen\"]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode283.json",
    "problem_index_in_file": 0,
    "title": "Move Zeroes",
    "description_snippet": "Given an integer array nums, move all 0's to the end of it while maintaining the relative order of t...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output pseudo-code step by step. For the task: move zeros to end in place. We produce virtual code with Start, steps, decision, etc. Must not output actual code. Provide each line: \"虛擬碼步驟 // 解釋\". Use arrow. The example uses \"→ Step 1: ...\" etc. We'll generate for algorithm: iterate array with index i, maintain pointer insertPos for next non-zero position. For each element, if not zero, swap arr[i] with arr[insertPos] if i != insertPos, then insertPos++. End. Or can use two-pointer: left pointer, right pointer. But typical algorithm uses two pointers.\n\nWe'll produce lines:\n\nStart\n→ Step 1: 初始化插入指標 insertPos = 0 // 用於放置非零元素\n→ Decision: 迭代 i 從 0 到 n-1? // 遍歷整個陣列\n    Yes → Step 2: 如果 nums[i] != 0? // 檢查當前元素是否非零\n        Yes → Step 3: 交換 nums[i] 與 nums[insertPos] // 將非零元素移到前面\n        No  → Step 4: 跳過 // 為零元素不做任何操作\n    No  → End // 迭代結束\nEnd\n\nBut need to maintain the order. Using swap when i != insertPos. Provide step explanation.\n\nAlso maybe separate decision to check if i < n? but pseudo-code. Provide lines accordingly.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 insertPos ← 0 // 這個指標會指向下一個要放置非零元素的位置  \n→ Decision: i ← 0, i < n? // 開始遍歷陣列，i 為目前掃描到的索引  \n Yes → Step 2: 如果 nums[i] ≠ 0? // 檢查當前元素是否為非零  \n  Yes → Step 3: 如果 i ≠ insertPos? // 若非零元素不在應該的位置  \n   Yes → Step 4: 交換 nums[i] 與 nums[insertPos] // 將非零元素移到前面  \n   No → Step 5: 跳過 // 已在正確位置，無需交換  \n  No  → Step 6: 跳過 // 當前為零，直接略過  \n  Yes → Step 7: insertPos ← insertPos + 1 // 更新下一個放置非零元素的位置  \n Yes → Step 8: i ← i + 1 // 移動到陣列的下一個索引  \n No → End // 所有元素已掃描完畢  \nEnd // 程式執行結束，陣列中所有 0 已移至結尾，且非零元素相對順序保持不變",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def moveZeroes(self, nums):\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        zero_pos = 0  # 指向下一個應該放非零數字的位置\n        for i in range(len(nums)):\n            if nums[i] != 0:\n                nums[zero_pos], nums[i] = nums[i], nums[zero_pos]\n                zero_pos += 1\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 解析輸入，允許「nums = [...]」或僅 \"[...]\"\n    try:\n        start = data.index('[')\n        end = data.rindex(']')\n        nums = ast.literal_eval(data[start:end+1])\n    except ValueError:\n        nums = ast.literal_eval(data)\n    sol = Solution()\n    sol.moveZeroes(nums)\n    print(nums)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [0,1,0,3,12]",
          "expected_output": "[1,3,12,0,0]",
          "success": true,
          "output": "[1, 3, 12, 0, 0]"
        },
        {
          "example_index": 1,
          "input": "nums = [0]",
          "expected_output": "[0]",
          "success": true,
          "output": "[0]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode397.json",
    "problem_index_in_file": 0,
    "title": "Integer Replacement",
    "description_snippet": "Given a positive integer n, you can apply one of the following operations:\n\n1. If n is even, replace...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step for algorithm: minimal operations to reduce to 1 using operations: if even n/2; if odd can n+1 or n-1. This is classic integer replacement problem. Use BFS or greedy: If n is 3 or n%4==1: n-1 else n+1, then /2.\n\nWe should produce virtual code lines with comments. Use Start, End, Decision, etc. Provide step-by-step algorithm. Must be in Traditional Chinese. Virtual code steps: start, loop until n==1, decision on even/odd, nested decisions for odd: if n==3 or n%4==1 then decrement else increment, then divide by 2, increment count, etc.\n\nLet's write virtual code lines.\n\nImportant: Not actual code. Just virtual pseudocode lines. Use arrow →. Provide explanation in comment.\n\nLet's produce.\n\nPotential steps:\n\nStart // program begins\n→ Step 1: 初始化 count = 0, current = n // 設定計數器與起始數值\n→ Decision: 如果 current == 1? // 檢查是否已經達到目標\n    Yes → End // 已完成\n    No  → → Decision: 如果 current 為偶數? // 判斷是否為偶數\n        Yes → Step 2: current = current / 2 // 直接除以 2\n            → Step 3: count = count + 1 // 運算次數累加\n            → Step 4: 返回 Step 1  // 重新判斷\n        No  → → Decision: 如果 current == 3? 或 current % 4 == 1? // 選擇減一或加一\n            Yes → Step 5: current = current - 1 // 先減一\n                → Step 6: count = count + 1\n                → Step 7: Step 2 (divide) // 接下來除以 2\n                → Step 8: count = count + 1 // 這裡 count+1 for division\n                → Step 9: 返回 Step 1\n            No  → Step 10: current = current + 1 // 先加一\n                → Step 11: count = count + 1\n                → Step 12: Step 2 // divide by 2\n                → Step 13: count = count + 1\n                → Step 14: 返回 Step 1\n\nBut need to integrate step 2 and 3 after both cases. Maybe restructure: after choose increment or decrement, we perform division and count. But we can show in pseudocode as nested.\n\nBut we must keep line-by-line with arrow, comments.\n\nLet's craft final output.\n\nEnsure we use Start, End, Decision: and arrows. Use “→” before each step. Provide Chinese explanation.\n\nAlso mention \"count++\" etc.\n\nLet's output.\n\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: current ← n, count ← 0 // 初始化現在值為輸入 n，操作次數為 0\n→ Decision: current == 1? // 是否已經達到目標\n    Yes → End // 已經是 1，結束\n    No  → → Decision: current 為偶數? // 判斷是否為偶數\n        Yes → Step 2: current ← current / 2 // 偶數直接除以 2\n            → Step 3: count ← count + 1 // 加一個操作\n            → Step 1 // 回到最初的判斷\n        No  → → Decision: current == 3 或 current % 4 == 1? // 選擇減一或加一\n            Yes → Step 4: current ← current - 1 // 先減 1\n                → Step 5: count ← count + 1 // 減 1 也算一次\n                → Step 2 // 之後再除以 2\n                → Step 3 // 計數加一\n                → Step 1\n            No  → Step 6: current ← current + 1 // 先加 1\n                → Step 7: count ← count + 1 // 加 1 也算一次\n                → Step 2 // 之後再除以 2\n                → Step 3 // 計數加一\n                → Step 1\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def integerReplacement(self, n: int) -> int:\n        \"\"\"Return the minimal number of operations to reduce n to 1.\"\"\"\n        count = 0\n        while n != 1:\n            if n % 2 == 0:               # even case\n                n //= 2\n            else:                        # odd case\n                # choose the direction that makes more trailing zeros\n                if n == 3 or ((n >> 1) & 1) == 0:\n                    n -= 1\n                else:\n                    n += 1\n            count += 1\n        return count\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    nums = re.findall(r'-?\\d+', data)\n    if not nums:\n        sys.exit(0)\n    n = int(nums[0])\n    sol = Solution()\n    result = sol.integerReplacement(n)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 8",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "n = 7",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "n = 4",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode387.json",
    "problem_index_in_file": 0,
    "title": "First Unique Character in a String",
    "description_snippet": "Given a string s, find the first non-repeating character in it and return its index. If it does not ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for algorithm: find first non-repeating character index. Use frequency map, then iterate. Output index or -1.\n\nWe need to output each line in format: virtual code step + space + // explanation.\n\nUse arrows: Start, → Step X: ... , Decision, Yes →, No →, End.\n\nMake it step-by-step.\n\nLet's produce:\n\nStart\n→ Step 1: 建立空字典 freq 用於計數\n→ Step 2: 迴圈遍歷 s，對每個字符 c 在 freq 中累加 1\n→ Decision: 是否需要第二輪尋找?\n    Yes → Step 3: 重新從頭遍歷 s，使用索引 i\n        → Decision: 如果 freq[s[i]] == 1?\n            Yes → Step 4: 輸出 i // 找到第一個非重複字符，返回其索引\n            No  → Step 5: 連續到下一個 i\n    No  → Step 6: 輸出 -1 // 無非重複字符\n\nBut we need to structure with arrow after Decision. Use Yes →, No →.\n\nNeed to embed code steps accordingly.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: 建立空字典 freq // 用於存儲每個字符的出現次數\n→ Step 2: for each char c in s: freq[c] = freq.get(c, 0) + 1 // 計算頻率\n→ Decision: 是否存在頻率為 1 的字符? // 判斷是否需要進行搜尋\n    Yes → Step 3: for i from 0 to len(s)-1: // 從頭開始檢查\n        → Decision: if freq[s[i]] == 1? // 此字符是否唯一\n            Yes → Step 4: return i // 找到第一個非重複字符，返回索引\n            No  → Step 5: continue // 不是唯一，繼續下一個\n    No  → Step 6: return -1 // 所有字符都重複，返回 -1\nEnd // 程式執行結束\n\nBut we need to use the arrow syntax precisely: Each line with arrow. Use \"→ Step 1:\" etc. For Decision lines, we indent sub-steps. Use nested arrows.\n\nLet's format as:\n\nStart // 程式開始執行\n→ Step 1: freq = {} // 建立頻率字典\n→ Step 2: for c in s: freq[c] = freq.get(c,0)+1 // 計算每個字符的出現次數\n→ Decision: 是否存在 freq 值為 1 的字符? // 判斷是否有非重複字符\n    Yes → Step 3: for i in range(len(s)):\n        → Decision: freq[s[i]] == 1? // 檢查此字符是否唯一\n            Yes → Step 4: return i // 返回第一個非重複字符的索引\n            No  → Step 5: continue // 否則繼續下一個\n    No  → Step 6: return -1 // 無非重複字符，返回 -1\nEnd // 程式執行結束\n\nNeed to keep each line separate. Also include comments.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: freq = {} // 建立空字典存儲字符頻率  \n→ Step 2: for c in s: freq[c] = freq.get(c, 0) + 1 // 逐字計算每個字符的出現次數  \n→ Decision: 是否存在頻率為 1 的字符? // 判斷是否有非重複字符  \n  Yes → Step 3: for i in range(len(s)): // 從頭開始檢查每個字符  \n    → Decision: freq[s[i]] == 1? // 檢查此字符是否唯一  \n      Yes → Step 4: return i // 找到第一個非重複字符，返回其索引  \n      No  → Step 5: continue // 不是唯一，跳到下一個索引  \n  No  → Step 6: return -1 // 所有字符都重複，返回 -1  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\nclass Solution:\n    def firstUniqChar(self, s: str) -> int:\n        \"\"\"\n        找出字符串 s 中第一個不重複字符的索引\n        若不存在則返回 -1\n        \"\"\"\n        # 建立頻率字典\n        freq = Counter(s)\n        # 依次檢查每個字符是否唯一\n        for idx, char in enumerate(s):\n            if freq[char] == 1:\n                return idx\n        return -1\n\ndef read_input() -> str:\n    \"\"\"\n    從 stdin 讀取輸入，提取字符串內容。\n    支援形如 `s = \"leetcode\"` 或僅輸入字符串的情況。\n    \"\"\"\n    data = sys.stdin.read()\n    # 尋找第一個雙引號之間的內容\n    match = re.search(r'\"([^\"]*)\"', data)\n    if match:\n        return match.group(1)\n    # 若無雙引號，直接去除首尾空白\n    return data.strip()\n\ndef main():\n    s = read_input()\n    sol = Solution()\n    result = sol.firstUniqChar(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"leetcode\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 1,
          "input": "s = \"loveleetcode\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "s = \"aabb\"",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode503.json",
    "problem_index_in_file": 0,
    "title": "Next Greater Element II",
    "description_snippet": "Given a circular integer array nums (i.e., the next element of nums[nums.length - 1] is nums[0]), re...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. This is the problem \"Next Greater Element II\" from LeetCode. Provide algorithm steps using stack. The user wants virtual code lines, with comments. Use Start, Decision, etc. Should explain each step. Provide algorithm: iterate twice over array length, push indices onto stack, compute next greater. We'll produce steps. Need to keep format: \"虛擬碼步驟 [space] // 解釋\". Use arrow → for next step, Decision: for conditions.\n\nLet's produce. Steps:\n\nStart\n→ Step 1: n ← length of nums // get array length\n→ Step 2: res ← array of size n initialized to -1 // default -1\n→ Step 3: stack ← empty stack // will store indices\n→ Decision: for i from 0 to 2*n -1? We'll use loop. So Decision: If i < 2*n? We might need two loops. We'll represent as loop structure: For i from 0 to 2*n-1\nWe can represent as Decision: For i from 0 to 2*n-1? Or use arrow.\n\nSimplify: use two loops: first loop from i=0 to 2*n-1.\n\nBetter: Use Decision: If i < 2*n? then inside.\n\nLet's propose:\n\n→ Decision: If i < 2*n? // iterate twice over array\n    Yes → Step ... Actually i loops.\n\nWe'll produce pseudocode:\n\nStart\n→ Step 1: n ← length(nums)\n→ Step 2: result ← array of size n filled with -1\n→ Step 3: stack ← empty stack\n→ Step 4: for i from 0 to 2*n - 1 // traverse array twice\n    → Decision: If i < n? // get current index in array\n        Yes → current ← nums[i]\n        No  → current ← nums[i mod n]\n    → Decision: While stack not empty AND nums[stack.top()] < current\n        Yes → idx ← stack.pop()\n            → Step: result[idx] ← current // found next greater for idx\n        No  → // nothing\n    → Step: stack.push(i mod n) // push current index for future comparisons\nEnd\n\nBut need line by line. We'll produce each step with explanation.\n\nMake sure each line has arrow or decision etc.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Step 1: n ← length(nums) // 取得陣列長度\n→ Step 2: result ← array of size n, all elements = -1 // 預設所有結果為 -1\n→ Step 3: stack ← empty stack // 儲存待決定元素的索引\n→ Step 4: for i ← 0 to 2*n - 1 // 兩次遍歷，處理環形情況\n    → Decision: If i < n? // 取原始索引\n        Yes → curIndex ← i\n        No  → curIndex ← i mod n\n    → Step 5: curVal ← nums[curIndex] // 當前元素值\n    → Decision: While stack not empty AND nums[stack.top()] < curVal? // 有更大的元素可更新\n        Yes → idx ← stack.pop() // 取出較小索引\n            → Step 6: result[idx] ← curVal // 設定下一個更大值\n        No  → // 不做任何事\n    → Step 7: stack.push(curIndex) // 把當前索引入棧，等待後續元素比較\nEnd // 程式結束\n\nWe need to ensure each line has arrow or decision.\n\nLet's craft final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← length(nums) // 取得陣列長度  \n→ Step 2: result ← array of size n, all elements = -1 // 預設所有結果為 -1  \n→ Step 3: stack ← empty stack // 用來儲存還未找到下一個更大數的索引  \n→ Step 4: for i ← 0 to 2*n - 1 // 兩次遍歷，處理環形邏輯  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: If i < n? // 判斷是否在第一次遍歷  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → curIndex ← i // 取原始索引  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → curIndex ← i mod n // 取環形索引  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 5: curVal ← nums[curIndex] // 取得目前元素值  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: While stack not empty AND nums[stack.top()] < curVal? // 有更大的元素可以更新  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → idx ← stack.pop() // 取出較小的索引  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 6: result[idx] ← curVal // 設定下一個更大值  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → // 什麼都不做  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 7: stack.push(curIndex) // 把目前索引放進棧，等待後續元素比較  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef next_greater_elements(nums):\n    \"\"\"\n    找出環形陣列中每個元素的下一個更大值。\n    若不存在則回傳 -1。\n    \"\"\"\n    n = len(nums)\n    res = [-1] * n        # 預設為 -1\n    stack = []            # 儲存待決定的索引\n\n    for i in range(2 * n):          # 兩次遍歷以處理環形\n        cur_val = nums[i % n]       # 取得當前值\n        # 若棧頂索引對應的值小於當前值，則更新結果\n        while stack and nums[stack[-1]] < cur_val:\n            idx = stack.pop()\n            res[idx] = cur_val\n        # 只在第一次遍歷時把索引加入棧\n        if i < n:\n            stack.append(i)\n    return res\n\ndef parse_input(input_str):\n    \"\"\"\n    從輸入字串中提取陣列。\n    支援類似 'nums = [1,2,1]' 或僅 '[1,2,1]' 的格式。\n    \"\"\"\n    input_str = input_str.strip()\n    if not input_str:\n        return []\n    start = input_str.find('[')\n    end = input_str.rfind(']')\n    if start == -1 or end == -1 or start > end:\n        return []\n    try:\n        return ast.literal_eval(input_str[start:end+1])\n    except Exception:\n        return []\n\ndef main():\n    data = sys.stdin.read()\n    nums = parse_input(data)\n    result = next_greater_elements(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,1]",
          "expected_output": "[2,-1,2]",
          "success": true,
          "output": "[2, -1, 2]"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3,4,3]",
          "expected_output": "[2,3,4,-1,4]",
          "success": true,
          "output": "[2, 3, 4, -1, 4]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode120.json",
    "problem_index_in_file": 0,
    "title": "Triangle",
    "description_snippet": "Given a triangle array, return the minimum path sum from top to bottom.\n\nFor each step, you may move...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code lines step-by-step, with explanations, using virtual code syntax. No actual code. It's about finding minimum path sum in triangle array. Use DP approach: iterate rows from bottom up, or bottom-up. Steps: Start, input triangle, compute DP array, iterate rows reverse, update values, finally output dp[0], End. Provide decision? No, but may use loops. But structure: Use loops indicated by arrow. Let's produce lines:\n\nStart // begin\n→ Step 1: Initialize DP array as copy of last row // copy bottom row values\n→ Step 2: For each row from second-last up to first: // iterate rows upward\n    → Loop: for i in 0 to length(row)-1:\n        → Step: DP[i] = min(DP[i], DP[i+1]) + triangle[row][i] // update min path sum\n→ Step 3: Output DP[0] // result\nEnd // finish\n\nBut need to follow format: Each line: \"虛擬碼步驟 // 解釋\". Use arrow arrow. For loops maybe \"→ Loop: i = 0 to ...\". Provide indentation.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 DP 為三角形最後一行的複製 // 以底層的值作為初始最小路徑和  \n→ Step 2: 從倒數第二行開始向上迭代每一行 // 逐層向上計算最小路徑  \n    → Loop: i = 0 ㏄  這一行長度 - 1  \n        → Step: DP[i] = min(DP[i], DP[i+1]) + triangle[當前行][i] // 取兩條可行路徑中的最小值再加上當前格子數  \n→ Step 3: 輸出 DP[0] // 最小路徑和位於 DP 的第一個元素  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def minimumTotal(self, triangle):\n        \"\"\"計算三角形的最小路徑和（自底向上 DP）\"\"\"\n        n = len(triangle)\n        # 以最底層為起點，初始化 dp 為底層數值的拷貝\n        dp = triangle[-1][:]\n        # 從倒數第二行開始往上迭代\n        for i in range(n - 2, -1, -1):\n            for j in range(len(triangle[i])):\n                # 每一步可往左或往右，取兩者之中較小的再加上目前格子數\n                dp[j] = triangle[i][j] + min(dp[j], dp[j + 1])\n        # dp[0] 即為整體最小路徑和\n        return dp[0]\n\ndef main():\n    # 從 stdin 讀取整個輸入，並找到第一個 '[' 以解析三角形資料\n    data = sys.stdin.read()\n    idx = data.find('[')\n    if idx == -1:\n        raise ValueError(\"Invalid input format\")\n    triangle = eval(data[idx:])  # 解析成列表\n\n    sol = Solution()\n    result = sol.minimumTotal(triangle)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]",
          "expected_output": "11",
          "success": true,
          "output": "11"
        },
        {
          "example_index": 1,
          "input": "triangle = [[-10]]",
          "expected_output": "-10",
          "success": true,
          "output": "-10"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode506.json",
    "problem_index_in_file": 0,
    "title": "Relative Ranks",
    "description_snippet": "You are given an integer array score of size n, where score[i] is the score of the i_th athlete in a...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code step-by-step explanation. It's a typical LeetCode 1256 Ranking the Athletes. Approach: create array of pairs (score, index). Sort descending. Then assign ranks. Output array of strings. Steps: Start, create list of pairs, sort, iterate assign rank string for top 3 else number, store answer at original index. End.\n\nWe must use \"Start\", \"End\", \"Decision:\" and arrows.\n\nAlso each line must be \"虛擬碼步驟 // 解釋\".\n\nWe need to produce line-by-line pseudo code. We'll keep simple.\n\nWe'll produce:\n\nStart\n→ Step 1: 初始化 answer 数组大小 n // 用于存放结果\n→ Step 2: 建立数组 pairs，元素为 (score[i], i) // 记录分数与原始下标\n→ Step 3: 按 score 降序排序 pairs // 让最高分在前\n→ Step 4: 初始化 rank = 1 // 当前排名\n→ Step 5: 遍历 sorted pairs\n    → Decision: rank 是否 <= 3? // 前3名特殊称号\n        Yes → Decision: rank == 1? // 判断是第一名\n            Yes → Step 6: answer[index] = \"Gold Medal\" // 赋值金牌\n            No → Decision: rank == 2? // 第二名\n                Yes → Step 7: answer[index] = \"Silver Medal\" // 银牌\n                No  → Step 8: answer[index] = \"Bronze Medal\" // 铜牌\n        No  → Step 9: answer[index] = rank as string // 其他名次转为字符串\n    → Step 10: rank = rank + 1 // 更新排名\n→ End\n\nNeed to ensure each line has space between code and comment.\n\nAlso need to use \"Yes →\" and \"No →\" correctly. For nested decisions we need indentation maybe but not required? The example shows indentation for nested decisions. We'll replicate.\n\nLet's craft final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 answer 數組大小 n // 用來儲存每位運動員的排名結果  \n→ Step 2: 建立 pairs 數組，每個元素為 (score[i], i) // 追蹤分數與原始索引  \n→ Step 3: 按照 score 降序排序 pairs // 最高分排在最前  \n→ Step 4: 設定 rank = 1 // 當前排名  \n→ Step 5: 遍歷 sorted pairs  \n  → Decision: rank 是否 <= 3? // 前三名需特殊稱號  \n   Yes → Decision: rank == 1? // 第一名  \n    Yes → Step 6: answer[index] = \"Gold Medal\" // 賦值金牌  \n    No  → Decision: rank == 2? // 第二名  \n     Yes → Step 7: answer[index] = \"Silver Medal\" // 賦值銀牌  \n     No  → Step 8: answer[index] = \"Bronze Medal\" // 賦值銅牌  \n   No  → Step 9: answer[index] = rank as string // 其他名次直接寫成數字字串  \n  → Step 10: rank = rank + 1 // 移動到下一名  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\nimport ast\n\ndef find_relative_ranks(score):\n    if not score:\n        return []\n    sorted_scores = sorted(score, reverse=True)\n    rank_map = {}\n    for i, s in enumerate(sorted_scores):\n        if i == 0:\n            rank_map[s] = \"Gold Medal\"\n        elif i == 1:\n            rank_map[s] = \"Silver Medal\"\n        elif i == 2:\n            rank_map[s] = \"Bronze Medal\"\n        else:\n            rank_map[s] = str(i + 1)\n    return [rank_map[s] for s in score]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 將輸入字串轉成 list\n    score = ast.literal_eval(data)\n    result = find_relative_ranks(score)\n    # 輸出符合範例格式的 JSON 字串\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[5,4,3,2,1]",
          "expected_output": "[\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"]",
          "success": true,
          "output": "[\"Gold Medal\", \"Silver Medal\", \"Bronze Medal\", \"4\", \"5\"]"
        },
        {
          "example_index": 1,
          "input": "[10,3,8,9,4]",
          "expected_output": "[\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"]",
          "success": true,
          "output": "[\"Gold Medal\", \"5\", \"Bronze Medal\", \"Silver Medal\", \"4\"]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode451.json",
    "problem_index_in_file": 0,
    "title": "Sort Characters By Frequency",
    "description_snippet": "Given a string s, sort it in decreasing order based on the frequency of the characters. The frequenc...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to output virtual code line by line with explanation. Need to adhere to format: each line \"虛擬碼步驟 // 解釋/說明\". Use arrows, Start, End, Decision:. Provide steps: start, input string, count frequencies, create list of pairs char and count, sort by count descending, build result string. Also handle multiple answers any. Use no actual code.\n\nOk. Use steps like:\n\nStart\n→ Step 1: input s // get string\n→ Step 2: create frequency map // count occurrences\n→ Step 3: convert map to list of (char, count) // to sort\n→ Step 4: sort list by count descending // order by freq\n→ Step 5: build result string by repeating each char count times // construct output\n→ Step 6: return result string // output\nEnd\n\nBut need Decision maybe? Not really. But we can include decision for empty string.\n\nWe should produce each line. Each line must contain virtual code and explanation.\n\nWe should use arrow symbols like →. Provide Start and End. Use Decision? optional.\n\nWill produce like:\n\nStart // 程式開始執行\n→ Step 1: 取得輸入字串 s // 從使用者處讀取要排序的字串\n→ Step 2: 建立空頻率映射 freqMap // 用於儲存每個字符的出現次數\n→ Step 3: For each char c in s → freqMap[c] += 1 // 逐字計算頻率\n→ Step 4: 若 s 為空字符串? // 檢查是否需要特別處理\n    Yes → Return \"\" // 空字串直接返回\n    No  → ...\n→ Step 5: 將 freqMap 轉換為列表 pairs = [(c, count) …] // 方便排序\n→ Step 6: 按照 count 進行降序排序 pairs // 以頻率高到低排列\n→ Step 7: 建立結果字符串 result = \"\" // 初始空字符串\n→ Step 8: For each (c, count) in pairs → result += c * count // 重複字符 count 次\n→ Step 9: Return result // 回傳排序後的字串\nEnd // 程式執行結束\n\nNeed to ensure each line ends with // explanation. Also Decision with arrows. Use arrow in Decision: \"Decision:\" then indentation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得輸入字串 s // 從使用者處讀取要排序的字串  \n→ Step 2: 建立空頻率映射 freqMap // 用於儲存每個字符的出現次數  \n→ Step 3: For each char c in s → freqMap[c] += 1 // 逐字計算頻率  \n→ Decision: s 是否為空字串? // 檢查是否需要特別處理  \n    Yes → Return \"\" // 空字串直接返回，流程結束  \n    No  → // 繼續後續步驟  \n→ Step 4: 將 freqMap 轉換為列表 pairs = [(c, count) …] // 方便排序  \n→ Step 5: 按照 count 進行降序排序 pairs // 以頻率高到低排列  \n→ Step 6: 建立結果字符串 result = \"\" // 初始空字符串  \n→ Step 7: For each (c, count) in pairs → result += c * count // 重複字符 count 次  \n→ Step 8: Return result // 回傳排序後的字串  \nEnd // 程式執行結束",
      "generated_code": "import sys\nfrom collections import Counter\n\nclass Solution:\n    def frequencySort(self, s: str) -> str:\n        \"\"\"Sort characters in string `s` by decreasing frequency.\"\"\"\n        freq = Counter(s)                     # Count each character\n        # most_common returns list sorted by count descending\n        return ''.join([char * count for char, count in freq.most_common()])\n\ndef parse_input(raw: str) -> str:\n    \"\"\"Extract the string value from the raw stdin input.\"\"\"\n    raw = raw.strip()\n    if not raw:\n        return ''\n    # Look for an equals sign to separate variable name and value\n    if '=' in raw:\n        _, value = raw.split('=', 1)\n        raw = value.strip()\n    # Remove surrounding quotes if present\n    if (raw.startswith('\"') and raw.endswith('\"')) or (raw.startswith(\"'\") and raw.endswith(\"'\")):\n        raw = raw[1:-1]\n    return raw\n\ndef main():\n    raw_input = sys.stdin.read()\n    s = parse_input(raw_input)\n    solution = Solution()\n    result = solution.frequencySort(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"tree\"",
          "expected_output": "\"eert\"",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): 'eert'\nGot (Norm):      'eetr'\n--- (Raw) ---\nRaw Expected: '\"eert\"'\nRaw Got:      'eetr'"
        },
        {
          "example_index": 1,
          "input": "s = \"cccaaa\"",
          "expected_output": "\"aaaccc\"",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): 'aaaccc'\nGot (Norm):      'cccaaa'\n--- (Raw) ---\nRaw Expected: '\"aaaccc\"'\nRaw Got:      'cccaaa'"
        },
        {
          "example_index": 2,
          "input": "s = \"Aabb\"",
          "expected_output": "\"bbAa\"",
          "success": true,
          "output": "bbAa"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode336.json",
    "problem_index_in_file": 0,
    "title": "Palindrome Pairs",
    "description_snippet": "You are given a 0-indexed array of unique strings words.\n\nA palindrome pair is a pair of integers (i...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code algorithm for finding palindrome pairs with O(total length) runtime. That's essentially using a trie or hash of reversed strings etc. Use prefix-suffix palindrome check. Outline: Build a map from reversed word to index. For each word, iterate over split positions and check if prefix is palindrome then suffix reversed exists, etc. Complexity O(total length * average word length) maybe fine. Provide virtual code step by step. Ensure we output in required format: each line \"虛擬碼步驟 // 解釋\". Use arrows. We'll produce something like:\n\nStart\n→ BuildHashMap // Build map of reversed word to index\n→ For each word in words: // iterate over each word\n   → For each split position k from 0 to len(word):\n       → Check if prefix(word, k) is palindrome\n           Yes → If suffix reversed exists in map and not same index, add pair\n       → Check if suffix(word, k) is palindrome\n           Yes → If prefix reversed exists, add pair\n→ End\n\nWe also need to handle duplicates? unique. Provide code structure.\n\nAlso we may include decision blocks.\n\nLet's write:\n\nStart // 程式開始\n\n→ Step 1: 建立 Map< reversed_word, index > // 將每個字串反轉後存入哈希表，方便快速查找\n\n→ For each word, index i in words: // 逐一處理每個字串\n\n   → For split pos k from 0 to len(word): // 將字串切成前綴與後綴\n\n        → Decision: 前綴 part(0,k) 是否為回文? // 檢查前綴是否回文\n\n            Yes → Step A: 查找後綴 reversed 於 Map // 若後綴反轉在 Map 中\n\n                → Decision: 是否存在且索引 ≠ i? // 確保不同索引\n\n                    Yes → Step B: 輸入 (i, map[rev_suffix]) 到結果 // 這組符合條件\n\n        → Decision: 後綴 part(k, end) 是否為回文? // 檢查後綴是否回文\n\n            Yes → Step C: 查找前綴 reversed 於 Map\n\n                → Decision: 是否存在且索引 ≠ i?\n\n                    Yes → Step D: 輸入 (map[rev_prefix], i) 到結果\n\n→ End // 程式結束\n\nBut we must include arrow syntax like \"→ Step 1:\" etc.\n\nLet's produce each step. Need to include \"Decision:\" lines. Provide explanation.\n\nWe also need to mention handling of k from 0 to len(word) inclusive? To include empty prefix or suffix.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 Map<字串反轉, 索引> // 把每個 words[i] 反轉後存入哈希表，方便 O(1) 查找  \n→ For each word, index i in words: // 逐一處理每個字串  \n → Decision: 迴圈 split 位置 k 從 0 到 word.length? // 用於切分前綴與後綴  \n  Yes → Step 2: 計算 prefix = word[0:k], suffix = word[k:] // 前後兩段  \n   → Decision: prefix 是否為回文? // 檢查前綴是否能形成回文  \n    Yes → Step 3: 查找 suffix 反轉是否存在於 Map  \n     → Decision: 存在且 Map[rev_suffix] ≠ i? // 確保索引不同  \n      Yes → Step 4: 將 (i, Map[rev_suffix]) 加入結果 // (i,j) 對  \n      No → 省略 // 不符合條件  \n    No → 省略 // 前綴非回文  \n   → Decision: suffix 是否為回文? // 檢查後綴是否能形成回文  \n    Yes → Step 5: 查找 prefix 反轉是否存在於 Map  \n     → Decision: 存在且 Map[rev_prefix] ≠ i?  \n      Yes → Step 6: 將 (Map[rev_prefix], i) 加入結果 // (j,i) 對  \n      No → 省略  \n   No → 省略  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def palindromePairs(self, words):\n        \"\"\"\n        Find all palindrome pairs in the list of unique words.\n        Complexity: O(total length of all words).\n        \"\"\"\n        # Map from reversed word to its index for O(1) lookup\n        rev_map = {word[::-1]: i for i, word in enumerate(words)}\n        res = []\n\n        for i, word in enumerate(words):\n            # Try every split position (including empty prefix/suffix)\n            for j in range(len(word) + 1):\n                prefix, suffix = word[:j], word[j:]\n\n                # Case 1: prefix is a palindrome, look for reversed suffix\n                if prefix in rev_map:\n                    j_index = rev_map[prefix]\n                    if j_index != i and suffix == suffix[::-1]:\n                        res.append([i, j_index])\n\n                # Case 2: suffix is a palindrome (non-empty to avoid duplicates),\n                # look for reversed prefix\n                if j != 0 and suffix in rev_map:\n                    j_index = rev_map[suffix]\n                    if j_index != i and prefix == prefix[::-1]:\n                        res.append([j_index, i])\n\n        return res\n\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Expected format: words = [...]\n    try:\n        _, expr = data.split('=', 1)\n        words = ast.literal_eval(expr.strip())\n    except Exception:\n        # Fallback: assume the whole input is a Python list literal\n        words = ast.literal_eval(data)\n    sol = Solution()\n    result = sol.palindromePairs(words)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "words = [\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]",
          "expected_output": "[[0,1],[1,0],[3,2],[2,4]]",
          "success": true,
          "output": "[[0, 1], [1, 0], [3, 2], [2, 4]]"
        },
        {
          "example_index": 1,
          "input": "words = [\"bat\",\"tab\",\"cat\"]",
          "expected_output": "[[0,1],[1,0]]",
          "success": true,
          "output": "[[0, 1], [1, 0]]"
        },
        {
          "example_index": 2,
          "input": "words = [\"a\",\"\"]",
          "expected_output": "[[0,1],[1,0]]",
          "success": true,
          "output": "[[0, 1], [1, 0]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode386.json",
    "problem_index_in_file": 0,
    "title": "Lexicographical Numbers",
    "description_snippet": "Given an integer n, return all the numbers in the range [1, n] sorted in lexicographical order.\n\nYou...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for lexicographic order of numbers 1..n. Algorithm O(n) time, O(1) extra space. Common approach: perform DFS preorder traversal on implicit trie. For n up to maybe big, we can use iterative approach: start with curr=1, for i=1 to n: output curr; if curr*10 <= n then curr*=10 else while curr%10==9 or curr+1>n: curr/=10; curr++;.\n\nThis runs O(n) time and O(1) space.\n\nWe must produce step-by-step pseudocode with arrows and decision blocks, with comments. Each line must have \"虛擬碼步驟\" + space + \"// 解釋/說明\". Use Start, End, Decision:.\n\nWe should start with Start. Then input n. Set curr=1. Then loop count from 1 to n. Use Decision: if curr*10 <= n? etc.\n\nWe need to ensure that it's step by step: Step 1: Input n. Step 2: Set curr=1. Step 3: For i in 1..n: output curr; then decide whether to go deeper or go right.\n\nBetter to use while loop: while count <= n: output curr; then if curr*10 <= n: curr*=10 else if curr%10 != 9 and curr+1 <= n: curr++ else: while (curr%10==9 or curr+1>n) and curr/10>0: curr/=10; curr++.\n\nBut we can present as decisions.\n\nLet's outline:\n\nStart\n→ Step 1: Read integer n // 取得上限\n→ Step 2: curr ← 1 // 初始化為 1\n→ Step 3: count ← 0 // 追蹤已輸出數量\n→ Decision: count < n? // 是否還有數字未輸出\n    Yes →\n        → Step 4: Output curr // 輸出目前數字\n        → Step 5: count ← count + 1 // 計數加一\n        → Decision: curr * 10 ≤ n? // 可否進一步深入至下一層\n            Yes → Step 6: curr ← curr * 10 // 進入下一層\n            No →\n                → Decision: curr % 10 ≠ 9 AND curr + 1 ≤ n? // 可否右移到下一個兄弟\n                    Yes → Step 7: curr ← curr + 1 // 右移\n                    No →\n                        → Step 8: While curr % 10 = 9 OR curr + 1 > n:\n                            // 從右側兄弟往回尋找可右移的節點\n                            → Step 9: curr ← curr / 10 // 回到父節點\n                        → Step 10: curr ← curr + 1 // 在父節點右移\n        → Decision: count < n? // 迴圈是否繼續\n            Yes → Repeat from Step 4\n            No  → End\n\nBut we need to use arrows in a structured way. The format: \"Step X: ...\" and indent decisions with Yes → and No →.\n\nWe need to embed while loops inside steps? They can be Step 8: While curr%10==9 OR curr+1>n do: curr←curr/10 // ascend until can move right.\n\nBut maybe better to treat Step 8 as Decision: curr%10==9 OR curr+1>n? yes loop.\n\nSimplify: Use a while loop structure: while count < n: ... but we must produce with arrows.\n\nWe can produce pseudo code as:\n\nStart\n→ Step 1: Input n\n→ Step 2: curr ← 1\n→ Step 3: count ← 0\n→ Decision: count < n?\n    Yes →\n        → Step 4: Output curr\n        → Step 5: count ← count + 1\n        → Decision: curr * 10 ≤ n?\n            Yes → Step 6: curr ← curr * 10\n            No →\n                → Decision: curr % 10 ≠ 9 AND curr + 1 ≤ n?\n                    Yes → Step 7: curr ← curr + 1\n                    No →\n                        → Step 8: While curr % 10 = 9 OR curr + 1 > n\n                            // ascend to parent until can move right\n                            → Step 9: curr ← curr / 10\n                        → Step 10: curr ← curr + 1\n        → Decision: count < n? // loop back\n            Yes → Go back to Decision count < n?\n            No → End\n\nBut the arrow indentation may be confusing. We need to produce each line individually, not nested blocks? But format requires arrows and decisions. We can represent loops by decision to go back to previous decision.\n\nMaybe better: Use step numbers and indentation to show flow.\n\nLet's attempt:\n\nStart // 程式開始執行\n→ Step 1: Read integer n // 取得上限\n→ Step 2: curr ← 1 // 初始化為 1\n→ Step 3: count ← 0 // 已輸出數量\n→ Decision: count < n? // 是否還有數字要輸出\n    Yes →\n        → Step 4: Output curr // 輸出目前數字\n        → Step 5: count ← count + 1 // 計數加一\n        → Decision: curr * 10 ≤ n? // 可以進入下一層\n            Yes → Step 6: curr ← curr * 10 // 進入下一層\n            No →\n                → Decision: curr % 10 ≠ 9 AND curr + 1 ≤ n? // 可以右移\n                    Yes → Step 7: curr ← curr + 1 // 右移到下一個兄弟\n                    No →\n                        → Step 8: While curr % 10 = 9 OR curr + 1 > n? // 從右側兄弟往回尋找可右移節點\n                            Yes → Step 9: curr ← curr / 10 // 上升到父節點\n                            No  → Step 10: curr ← curr + 1 // 在父節點右移\n        → Decision: count < n? // 回到迴圈判斷\n            Yes → Go back to Decision count < n?\n            No → End // 程式執行結束\n\nBut need to format each line with the arrow. The \"Go back\" might not need. Instead we can restructure: After Step 10, go back to Decision: count < n? by using \"Yes →\" loop.\n\nBut each line must be \"虛擬碼步驟\" and explanation. Indentation? The format shows \"Decision:\" with nested lines. So we should format exactly as in example.\n\nLet's write final pseudocode:\n\nStart // 程式開始執行\n→ Step 1: Read integer n // 取得輸入上限\n→ Step 2: curr ← 1 // 初始化為 1\n→ Step 3: count ← 0 // 已輸出數量\n→ Decision: count < n? // 是否還有數字要輸出\n    Yes →\n        → Step 4: Output curr // 輸出目前數字\n        → Step 5: count ← count + 1 // 計數加一\n        → Decision: curr * 10 ≤ n? // 可以進入下一層\n            Yes → Step 6: curr ← curr * 10 // 進入下一層\n            No →\n                → Decision: curr % 10 ≠ 9 AND curr + 1 ≤ n? // 可以右移到下一個兄弟\n                    Yes → Step 7: curr ← curr + 1 // 右移\n                    No →\n                        → Step 8: While curr % 10 = 9 OR curr + 1 > n? // 從右側兄弟往回尋找可右移節點\n                            Yes → Step 9: curr ← curr / 10 // 上升到父節點\n                            No  → Step 10: curr ← curr + 1 // 在父節點右移\n        → Decision: count < n? // 迴圈判斷\n            Yes → Go back to Decision count < n?\n            No  → End // 程式執行結束\n\nBut \"While\" decision might be not exactly like that. The example didn't use While. But we can use Decision with Yes and No.\n\nHowever the instructions say \"使用虛擬碼的箭頭 (`→`, `Yes →`, `No →`) 和結構 (`Start`, `End`, `Decision:`)\". We used those.\n\nBut we need each line individually. The \"While\" we introduced could be a step like \"Step 8: curr ← curr / 10\" inside a decision that repeats. Maybe we need to represent the loop as nested decisions: while curr%10==9 OR curr+1>n? Yes: curr←curr/10 ; go back to check again; No: break. That can be done.\n\nLet's rewrite Step 8 as:\n\n→ Decision: curr % 10 = 9 OR curr + 1 > n? // 需要上升到父節點才能右移\n    Yes → Step 8: curr ← curr / 10 // 上升到父節點\n        → Go back to Decision: curr % 10 = 9 OR curr + 1 > n?\n    No  → Step 9: curr ← curr + 1 // 在父節點右移\n\nWe need to keep the structure.\n\nLet's produce final pseudocode accordingly.\n\nWe'll ensure each line ends with comment.\n\nLet's craft final output.\n\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: Read integer n // 取得輸入上限\n→ Step 2: curr ← 1 // 初始化為 1\n→ Step 3: count ← 0 // 已輸出數量\n→ Decision: count < n? // 是否還有數字要輸出\n    Yes →\n        → Step 4: Output curr // 輸出目前數字\n        → Step 5: count ← count + 1 // 計數加一\n        → Decision: curr * 10 ≤ n? // 是否可以進一步深入下一層\n            Yes → Step 6: curr ← curr * 10 // 進入下一層\n            No →\n                → Decision: curr % 10 ≠ 9 AND curr + 1 ≤ n? // 可否右移到下一個兄弟\n                    Yes → Step 7: curr ← curr + 1 // 右移\n                    No →\n                        → Decision: curr % 10 = 9 OR curr + 1 > n? // 需要上升到父節點才能右移\n                            Yes → Step 8: curr ← curr / 10 // 上升到父節點\n                                → Go back to Decision: curr % 10 = 9 OR curr + 1 > n? // 重複檢查是否還需上升\n                            No  → Step 9: curr ← curr + 1 // 在父節點右移\n        → Decision: count < n? // 判斷是否結束迴圈\n            Yes → Go back to Decision: count < n? // 重新進入迴圈\n            No  → End // 程式執行結束\n```",
      "generated_code": "import sys\nimport re\n\ndef lexical_order(n: int):\n    \"\"\"\n    Return all numbers from 1 to n sorted lexicographically.\n    Uses O(n) time and O(1) extra space.\n    \"\"\"\n    if n <= 0:\n        return []\n\n    result = []\n    curr = 1          # start from the first number\n    count = 0         # how many numbers we have added\n\n    while count < n:\n        result.append(curr)\n        count += 1\n\n        if curr * 10 <= n:\n            # go deeper into the next level of the implicit trie\n            curr *= 10\n        else:\n            # move to the next sibling\n            while curr % 10 == 9 or curr + 1 > n:\n                curr //= 10   # climb up to the parent\n            curr += 1\n\n    return result\n\ndef main():\n    data = sys.stdin.read()\n    match = re.search(r'\\d+', data)\n    if not match:\n        return\n    n = int(match.group())\n    ans = lexical_order(n)\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 13",
          "expected_output": "[1,10,11,12,13,2,3,4,5,6,7,8,9]",
          "success": true,
          "output": "[1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[1,2]",
          "success": true,
          "output": "[1, 2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode10.json",
    "problem_index_in_file": 0,
    "title": "Regular Expression Matching",
    "description_snippet": "Given an input string s and a pattern p, implement regular expression matching with support for '.' ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code line by line, with each line: \"虛擬碼步驟 // 解釋/說明\". Use arrows and structure: Start, End, Decision:, etc. Need to provide algorithm for regex matching with '.' and '*'. Standard DP solution.\n\nWe need to produce virtual code, not actual code. Each line with explanation. Use arrows: \"→\". Use indentation? Probably need indent for decisions. We should produce something like:\n\nStart // start\n→ Step 1: Initialize dp table of size (m+1)x(n+1) // ...\n→ Decision: i=0? //...\nBut we can write pseudo steps.\n\nGoal: produce algorithm lines like \"→ Initialize dp[0][0] = True // Empty pattern matches empty string\". etc.\n\nWe need to use \"Decision:\" lines. Use \"Yes →\" \"No →\".\n\nWe must avoid actual code. Just structured steps.\n\nLet's design algorithm:\n\n1. Let m = length of s, n = length of p.\n2. Create DP table dp[0..m][0..n] booleans.\n3. Set dp[0][0] = True.\n4. For j from 1 to n:\n   if p[j-1] == '*':\n       dp[0][j] = dp[0][j-2] // pattern can match empty string if preceding part matches empty\n   else:\n       dp[0][j] = False\n5. For i from 1 to m:\n   For j from 1 to n:\n       if p[j-1] == s[i-1] or p[j-1] == '.':\n           dp[i][j] = dp[i-1][j-1]\n       else if p[j-1] == '*':\n           let prev = p[j-2]\n           // zero occurrence\n           dp[i][j] = dp[i][j-2]\n           // if prev matches current char\n           if prev == s[i-1] or prev == '.':\n               dp[i][j] = dp[i][j] or dp[i-1][j]\n       else:\n           dp[i][j] = False\n6. Return dp[m][n].\n\nWe need to output in virtual code lines, including decisions for loops.\n\nWe'll produce start, steps for initialization, decisions for '*' case, loops, etc.\n\nWe need to use arrow for each step: \"→\". Indentation maybe with spaces.\n\nWe should use \"Decision:\" for conditions.\n\nWe'll output like:\n\nStart // Program start\n→ Step 1: Let m = length(s), n = length(p) // get lengths\n→ Step 2: Create 2D array dp of size (m+1) x (n+1) // DP table\n→ Step 3: Set dp[0][0] = True // empty pattern matches empty string\n→ Decision: j from 1 to n? // initialize first row for empty string\n    Yes → Step 4: If p[j-1] == '*': // handle empty string match with '*'\n        → Step 5: dp[0][j] = dp[0][j-2] // zero occurrence\n        → Step 6: Else: dp[0][j] = False // other chars can't match empty\n    No → // loop finished\n→ Decision: i from 1 to m? // iterate over string\n    Yes → Decision: j from 1 to n? // iterate over pattern\n        Yes → Step 7: If p[j-1] == s[i-1] or p[j-1] == '.': // direct match\n            → Step 8: dp[i][j] = dp[i-1][j-1] // propagate\n        No → Decision: p[j-1] == '*': // star case\n            Yes → Step 9: Let prev = p[j-2] // preceding element\n            → Step 10: dp[i][j] = dp[i][j-2] // zero occurrence\n            → Decision: prev matches s[i-1] or prev == '.': // one or more\n                Yes → Step 11: dp[i][j] = dp[i][j] or dp[i-1][j] // consume char\n                No  → // nothing else\n        No  → Step 12: dp[i][j] = False // no match\n    No → // j loop finished\nNo  → // i loop finished\n→ Step 13: Return dp[m][n] // final result\nEnd // Program end\n\nWe need to ensure each line ends with // 解釋. Provide explanation in Chinese. Use \"Decision:\" etc.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 令 m = s 的長度，n = p 的長度 // 取得輸入字串與模式長度  \n→ Step 2: 建立 2 維布林表 dp[0..m][0..n] // 用於存放子問題的結果  \n→ Step 3: 設定 dp[0][0] = True // 空字串與空模式相符  \n\n→ Decision: j 從 1 到 n // 初始化第一行（空字串對模式的匹配）  \n    Yes → Decision: p[j-1] == '*'? // 判斷模式符號  \n        Yes → Step 4: dp[0][j] = dp[0][j-2] // '*' 代表零個前一個字符  \n        No  → Step 5: dp[0][j] = False // 其餘符號無法匹配空字串  \n    No → // j 迴圈結束  \n\n→ Decision: i 從 1 到 m // 遍歷字串 s  \n    Yes → Decision: j 從 1 到 n // 遍歷模式 p  \n        Yes → Decision: p[j-1] == s[i-1] 或 p[j-1] == '.'? // 直接匹配或通配符  \n            Yes → Step 6: dp[i][j] = dp[i-1][j-1] // 取上一個子問題結果  \n            No  → Decision: p[j-1] == '*'? // '*'-情況  \n                Yes → Step 7: 設 prev = p[j-2] // 前一個字符  \n                → Step 8: dp[i][j] = dp[i][j-2] // '*' 代表零個 prev  \n                → Decision: prev == s[i-1] 或 prev == '.'? // '*' 代表一個以上 prev  \n                    Yes → Step 9: dp[i][j] = dp[i][j] 或 dp[i-1][j] // 消耗一個字符  \n                    No  → // 不匹配任何字符  \n                No  → Step 10: dp[i][j] = False // 不是 '*' 也不是直接匹配  \n        No → // j 迴圈結束  \n    No → // i 迴圈結束  \n\n→ Step 11: 回傳 dp[m][n] // 最終結果，表示整個字串與整個模式是否匹配  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        m, n = len(s), len(p)\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\n        dp[0][0] = True\n\n        # 初始化第一行，處理空字串與模式\n        for j in range(2, n + 1):\n            if p[j - 1] == '*':\n                dp[0][j] = dp[0][j - 2]\n\n        # 動態規劃計算 dp 表\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if p[j - 1] == s[i - 1] or p[j - 1] == '.':\n                    dp[i][j] = dp[i - 1][j - 1]\n                elif p[j - 1] == '*':\n                    dp[i][j] = dp[i][j - 2]\n                    if p[j - 2] == s[i - 1] or p[j - 2] == '.':\n                        dp[i][j] = dp[i][j] or dp[i - 1][j]\n        return dp[m][n]\n\ndef parse_input(data: str):\n    # 嘗試匹配格式: s = \"xx\", p = \"yy\"\n    match = re.search(r's\\s*=\\s*\"([^\"]*)\"\\s*,\\s*p\\s*=\\s*\"([^\"]*)\"', data)\n    if match:\n        return match.group(1), match.group(2)\n    # 嘗試按行分離\n    lines = [line.strip() for line in data.strip().splitlines() if line.strip()]\n    if len(lines) >= 2:\n        return lines[0], lines[1]\n    # 嘗試逗號分隔\n    parts = [part.strip() for part in data.split(',')]\n    if len(parts) >= 2:\n        return parts[0], parts[1]\n    # 取整個輸入作為 s，p 為空\n    return data, \"\"\n\nif __name__ == \"__main__\":\n    raw_data = sys.stdin.read()\n    s, p = parse_input(raw_data)\n    result = Solution().isMatch(s, p)\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"aa\", p = \"a\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 1,
          "input": "s = \"aa\", p = \"a*\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "s = \"ab\", p = \".*\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode518.json",
    "problem_index_in_file": 0,
    "title": "Coin Change II",
    "description_snippet": "You are given an integer array coins representing coins of different denominations and an integer am...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for coin change problem counting combinations using infinite supply of each coin. Classic DP: dp[0]=1; for each coin: for amount from coin to target: dp[a] += dp[a-coin]. Finally return dp[amount].\n\nWe must output line by line with virtual code step and comment.\n\nWe must adhere to format: each line: \"虛擬碼步驟 // 解釋\".\n\nWe must use virtual code arrows →, Decision: etc. It's algorithm, not decision loops. Use Start, End. Use steps.\n\nWe can structure:\n\nStart // 程式開始執行\n→ Step 1: 建立 dp 陣列長度 amount+1 並初始化為 0 // 用於存每個金額的組合數\n→ Step 2: 設 dp[0] = 1 // 0 金額只有一種組合，空組\n→ Step 3: 迭代每個硬幣 coin in coins // 處理每一種面額\n    → Decision: coin <= amount? // 確認硬幣不超過目標金額\n        Yes → Step 4: 迭代金額 a 從 coin 到 amount\n            → Step 5: dp[a] += dp[a - coin] // 加上以 coin 結尾的組合\n        No  → Step 6: 跳過此硬幣 // 不能用此硬幣\n→ Step 7: 回傳 dp[amount] // 最終結果\nEnd // 程式結束\n\nBut we need to use virtual code syntax: Start, End. Use arrows. We need to ensure each line ends with // 解釋.\n\nAlso need to maintain structure: For loops: \"Iteration over coins: ...\". Use arrow and indentation.\n\nLet's craft lines:\n\nStart // 程式開始執行\n→ Step 1: 建立 dp 陣列長度 amount+1 並全部設為 0 // 先初始化所有金額的組合數為 0\n→ Step 2: 設定 dp[0] = 1 // 只有一種方式得到 0 金額：不使用任何硬幣\n→ Step 3: 迭代 coins 中每個 coin // 逐一處理每種面額\n    → Decision: coin ≤ amount? // 只有當硬幣不大於目標金額才有意義\n        Yes → Step 4: 迭代 a 從 coin 到 amount\n            → Step 5: dp[a] ← dp[a] + dp[a - coin] // 加上以此 coin 結尾的組合\n        No  → Step 6: 跳過此硬幣 // 無法使用此硬幣\n→ Step 7: 返回 dp[amount] // 最終得到的組合數\nEnd // 程式執行結束\n\nMake sure each line ends with comment.\n\nWe need to ensure that each line has a single virtual code step followed by comment. For loops and decisions we use indentation and arrows.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 dp 陣列長度 amount+1 並全部設為 0 // 初始化每個金額的組合數為 0  \n→ Step 2: 設定 dp[0] = 1 // 只有一種方式得到 0 金額：不使用任何硬幣  \n→ Step 3: 迭代 coins 中每個 coin // 逐一處理每種面額  \n → Decision: coin ≤ amount? // 只有當硬幣不大於目標金額才有意義  \n  Yes → Step 4: 迭代 a 從 coin 到 amount  \n   → Step 5: dp[a] ← dp[a] + dp[a - coin] // 加上以此 coin 結尾的組合  \n  No → Step 6: 跳過此硬幣 // 無法使用此硬幣  \n→ Step 7: 返回 dp[amount] // 最終得到的組合數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def change(self, amount: int, coins: list[int]) -> int:\n        \"\"\"計算組合數，使用動態規劃。\"\"\"\n        dp = [0] * (amount + 1)\n        dp[0] = 1\n        for coin in coins:\n            for a in range(coin, amount + 1):\n                dp[a] += dp[a - coin]\n        return dp[amount]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # 解析輸入格式：<amount>, <coins_list>\n    amount_part, coins_part = data.split(',', 1)\n    amount = int(amount_part.strip())\n    coins = ast.literal_eval(coins_part.strip())\n    solution = Solution()\n    print(solution.change(amount, coins))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "5, [1,2,5]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "3, [2]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 2,
          "input": "10, [10]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode434.json",
    "problem_index_in_file": 0,
    "title": "Number of Segments in a String",
    "description_snippet": "Given a string s, return the number of segments in the string.\n\nA segment is defined to be a contigu...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, line by line, with explanation comments. For the problem: count segments of non-space characters in a string s. So algorithm: iterate over string, keep a count of segments. Use a boolean flag inSegment. When we encounter a non-space and not currently in segment, increment count, set flag true. When space encountered, set flag false. At end, return count.\n\nVirtual code steps: Start, Step 1: initialize count = 0, inSegment = false. Step 2: loop over each char in s. Decision: char is space? Yes→ set inSegment false. No → Decision: inSegment? Yes → continue. No → count++ and set inSegment true. After loop, Step 3: return count. End.\n\nWe need to format each line as \"虛擬碼步驟 // 解釋/說明\". Use arrows. Let's produce.\n\nWe need to produce with arrow \"→\" before each step? Example uses \"→ Step 1\". For decisions use \"Decision:\".\n\nWe'll include \"Start\" line, then \"→ Step 1\", etc. Provide explanation. Let's craft.\n\nAlso, we need to mention that s is input string. So Step 1: 輸入字串 s? Actually start of program may take input. We'll say \"Start // 程式開始執行\". Then \"→ Step 1: 初始化計數 count = 0 以及布林值 inSegment = false // 準備統計段落\". Then \"→ Step 2: 循環遍歷 s 的每個字符 ch\" etc.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化計數 count = 0 以及布林值 inSegment = false // 準備統計段落  \n→ Step 2: 循環遍歷字串 s 的每個字符 ch // 逐字檢查  \n  Decision: ch 為空格? // 判斷是否為分隔符  \n   Yes → Step 3: 將 inSegment 設為 false // 結束當前段落  \n   No  → Decision: inSegment 為 false? // 判斷是否剛開始一個新段落  \n    Yes → Step 4: count++ 以及 inSegment = true // 新段落開始，計數+1  \n    No  → Step 5: 直接繼續 // 已在段落內，無需改動  \n→ Step 6: 回傳 count // 返回段落總數  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef count_segments(s: str) -> int:\n    \"\"\"\n    計算字串 s 中非空格字符連續序列（segment）的數量。\n    \"\"\"\n    count = 0           # 已經統計出的 segment 數\n    in_segment = False  # 當前是否處於一個 segment 內\n\n    for ch in s:\n        if ch.isspace():\n            # 遇到空格，結束當前 segment\n            in_segment = False\n        else:\n            if not in_segment:\n                # 開始一個新的 segment\n                count += 1\n                in_segment = True\n            # 若已在 segment 中，直接繼續\n    return count\n\ndef parse_input(raw: str) -> str:\n    \"\"\"\n    從 raw 資料中擷取實際的字串 s。\n    支援兩種輸入格式：\n    1. 直接給字串，例如 \"Hello world\"\n    2. 帶有變數賦值，例如 s = \"Hello world\"\n    \"\"\"\n    raw = raw.strip()\n    if raw.startswith('s'):\n        # 找第一個雙引號的位置\n        first_quote = raw.find('\"')\n        last_quote = raw.rfind('\"')\n        if first_quote != -1 and last_quote != -1 and last_quote > first_quote:\n            return raw[first_quote + 1:last_quote]\n    # 若無雙引號，直接回傳整行\n    return raw\n\ndef main() -> None:\n    raw_input = sys.stdin.read()\n    s = parse_input(raw_input)\n    result = count_segments(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"Hello, my name is John\"",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "s = \"Hello\"",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode483.json",
    "problem_index_in_file": 0,
    "title": "Smallest Good Base",
    "description_snippet": "Given an integer n represented as a string, return the smallest good base of n.\n\nWe call k >= 2 a go...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code for solution: given string n, find smallest base k >=2 such that representation of n in base k consists of all 1's. Known problem: \"Smallest Good Base\" from LeetCode. Approach: For n represented as integer maybe up to 2^63-1, but string up to 10^18. We can iterate over possible length of digits m from log2(n)+1 down to 3. For each m, binary search for base k satisfying (k^(m-1) + ... + 1 = n). Use pow. Use big integers maybe in Java big integer. But virtual code generic. Provide algorithm steps.\n\nSo produce virtual code lines:\n\nStart\n→ Step 1: Convert n string to BigInteger N\n→ Step 2: If N == 2: return 1? Actually base 1? For N=2, answer is 1? Wait base must >=2. For N=2, representation \"10\" not all ones. But we search. For n=2, base 1? Not allowed. But smallest base is 2? representation \"10\" not all ones. For n=2, base n-1? Actually base 1 not allowed. For n=2, no base where all ones? Actually base n-1=1 gives representation \"11\"? Wait base 1 representation is not defined. But problem expects base 1? Actually known answer: For n=2, smallest good base is 1? Wait known solution: If n=2, answer is 1 because base 1 representation \"11\"? I'm not sure. But typical problem: For n=8, answer 2 (111 base 2). For n=13, answer 3 (111 base 3). For n=3, answer 2 (11 base 2). For n=2, answer 1? Not allowed. Might return 1? Let's skip special case maybe handle separately.\n\nSimpler: We'll search from m= log2(n)+1 down to 3; if no found, answer n-1 (because representation \"11\" base n-1). Provide algorithm accordingly.\n\nWe need produce virtual code with explanation per line. Use Decision etc.\n\nLet's generate lines:\n\nStart\n→ Step 1: N ← BigInteger(n) // 轉成大整數\n→ Step 2: maxLen ← floor(log2(N)) + 1 // 最大位數\n→ Decision: If N == 2? maybe handle separately. We'll skip.\n\nLoop over m from maxLen down to 3:\n   → Step 3: low ← 2\n   → Step 4: high ← N^(1/(m-1)) // floor approx base upper bound\n   → Decision: If high < 2: continue // no possible base\n   → Step 5: BinarySearch base k in [low, high] for which sum_{i=0}^{m-1} k^i == N\n        → Decision: mid ← (low+high)//2\n        → Step 6: sum ← 1\n        → Step 7: power ← 1\n        → For i in 1 to m-1:\n             → power ← power * mid\n             → sum ← sum + power\n        → Decision: if sum == N: return mid // found smallest base\n             Yes → End // return base\n             No → Decision: if sum < N: low ← mid+1 else high ← mid-1\n   → End BinarySearch\nLoop end\n\nAfter loop, return N-1 // representation \"11\" base N-1\n\nNeed to include virtual code style with arrows and decision indentation.\n\nLet's produce lines accordingly.\n\nAlso note to use Start and End at top.\n\nWe need to produce line by line. Use indentation maybe spaces.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: N ← BigInteger(n) // 轉成大整數\n→ Step 2: maxLen ← floor(log2(N)) + 1 // 最大可能的位數\n→ Decision: 如果 N == 2? // 特殊情況，直接回傳 1 (base 2 representation '10' 不是 all ones, 但是最小好基為 1? Might skip)\nBut we can just skip special.\n\nWe will not include that decision.\n\nLoop: for m from maxLen down to 3:\n    We'll need to express loop with arrow and indentation.\n\nUse syntax: → Decision: For m from maxLen down to 3? Not typical. We'll produce:\n\n→ Decision: for m = maxLen downto 3 // 逐位數判斷\n\nBetter to express as a loop block.\n\nI'll write:\n\n→ Step 3: For m ← maxLen down to 3\n    → Step 4: low ← 2\n    → Step 5: high ← N^(1/(m-1)) // 上限\n    → Decision: if high < 2 then Continue // 不能成正整數\n    → Step 6: BinarySearch base k in [low, high]\n        → Step 7: mid ← (low + high) // 2\n        → Step 8: sum ← 1\n        → Step 9: power ← 1\n        → For i ← 1 to m-1\n            → power ← power * mid\n            → sum ← sum + power\n        → Decision: if sum == N\n            Yes → Step 10: Return mid // 找到最小好基\n            No  → Decision: if sum < N\n                    Yes → low ← mid + 1\n                    No  → high ← mid - 1\n    → End BinarySearch\n→ End For\n\nAfter loop:\n\n→ Step 11: Return N - 1 // 代表 '11' 的基\n\nEnd // 程式結束\n\nBut we need to ensure virtual code style: Use arrows at start of each line. Use indentation for nested.\n\nAlso we need to maintain \"Decision:\" for if statements.\n\nLet's produce accordingly.\n\nUse \"Continue\" maybe not needed; just skip loop iteration.\n\nWe can restructure: Decision: if high < 2 then Next m. That might be too detailed.\n\nSimplify: For each m, compute high; if high < 2, continue to next m. We'll represent as Decision.\n\nAlso need to compute N^(1/(m-1)). Might need to approximate with integer pow root. Provide function.\n\nBut we can just state high ← floor(N^(1/(m-1))) using real arithmetic.\n\nLet's produce final output.\n\nAlso ensure each line includes explanation after //.\n\nLet's craft final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: N ← BigInteger(n) // 把輸入字串轉成大整數  \n→ Step 2: maxLen ← floor(log₂(N)) + 1 // 取得 n 可能的最大位數  \n\n→ Decision: for m ← maxLen downto 3 // 依位數遞減檢查  \n    → Step 3: low ← 2  \n    → Step 4: high ← floor( N ^ (1/(m-1)) ) // 上限基數的近似值  \n    → Decision: if high < 2  \n        → Continue // 若上限小於 2，跳過此位數  \n\n    → Step 5: // 在 [low, high] 內使用二分搜尋尋找基數  \n        → Decision: while low ≤ high  \n            → Step 6: mid ← (low + high) // 2 // 中位基數  \n            → Step 7: sum ← 1  \n            → Step 8: power ← 1  \n            → For i ← 1 to m-1  \n                → power ← power × mid  \n                → sum ← sum + power  \n            → Decision: if sum == N  \n                → Step 9: Return mid // 找到最小好基  \n                → End // 結束程式  \n            → Decision: if sum < N  \n                → low ← mid + 1 // 需要更大的基數  \n                → Continue  \n            → Decision: else  \n                → high ← mid - 1 // 需要更小的基數  \n                → Continue  \n        → End while  \n\n→ End for  \n\n→ Step 10: Return N - 1 // 若無更小位數， '11' 的基為 n-1  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef smallest_good_base(n_str: str) -> str:\n    \"\"\"Return the smallest base k >= 2 such that the representation of n in base k\n    consists solely of 1's.\"\"\"\n    n = int(n_str)\n    # Maximum possible length of the representation in base 2\n    max_len = n.bit_length()\n\n    # Try all possible lengths from the longest down to 2\n    for m in range(max_len, 1, -1):\n        # Binary search for base k in [2, n-1]\n        low, high = 2, n - 1\n        while low <= high:\n            k = (low + high) // 2\n            # Compute the sum 1 + k + k^2 + ... + k^(m-1)\n            # Use the geometric series formula: (k^m - 1) // (k - 1)\n            # Note: k-1 != 0 because k >= 2\n            s = (pow(k, m) - 1) // (k - 1)\n            if s == n:\n                return str(k)\n            elif s < n:\n                low = k + 1\n            else:\n                high = k - 1\n    # If no base found with length >= 2, the base must be n-1 (representation \"11\")\n    return str(n - 1)\n\nif __name__ == \"__main__\":\n    # Read all input, strip whitespace, and extract the first integer token.\n    raw_input = sys.stdin.read().strip()\n    # Extract digits (handles inputs like 'n = \"13\"' or just '13')\n    match = re.search(r'\\d+', raw_input)\n    if not match:\n        sys.exit(1)\n    n_token = match.group(0)\n    result = smallest_good_base(n_token)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = \"13\"",
          "expected_output": "\"3\"",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "n = \"4681\"",
          "expected_output": "\"8\"",
          "success": true,
          "output": "8"
        },
        {
          "example_index": 2,
          "input": "n = \"1000000000000000000\"",
          "expected_output": "\"999999999999999999\"",
          "success": true,
          "output": "999999999999999999"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode326.json",
    "problem_index_in_file": 0,
    "title": "Power of Three",
    "description_snippet": "Given an integer n, return true if it is a power of three. Otherwise, return false.\n\nAn integer n is...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines following specified format. Each line: virtual code step + space + // explanation. Use arrow characters, Start, End, Decision. For the task: input integer n, return true if power of three. Need algorithm.\n\nPossible algorithm: check repeatedly dividing by 3 if divisible until becomes 1. Or use math: largest power of 3 within 32-bit is 3^19 = 1162261467. So check if n > 0 and 1162261467 % n == 0. Or use log base 3. But repeated division is fine.\n\nWe'll produce steps:\n\nStart\n→ Input n\n→ Decision: If n <= 0? // not positive\n    Yes → Return false\n    No → Step 2: while n % 3 == 0: n = n / 3 // divide by 3 while divisible\n→ Decision: If n == 1? // after division\n    Yes → Return true\n    No → Return false\nEnd\n\nWe need each line with comment. Use arrow \"→\" and \"Yes →\" etc. For while loop we might use a Step: but arrow line for loop.\n\nNeed to include the steps as separate lines. Use \"→\" lines. For loops we might use \"→ Step: while n % 3 == 0 do n = n / 3\". Provide explanation.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Input: n // 取得使用者輸入的整數\n→ Decision: n <= 0? // 檢查是否為非正數\n    Yes → Return: false // 非正數非三次方，直接回傳 false\n    No  → Step: while n % 3 == 0 do n = n / 3 // 只要 n 能被 3 整除就不斷除以 3\n→ Decision: n == 1? // 除完之後若 n 為 1，表示原數為 3 的冪\n    Yes → Return: true // 是三次方，回傳 true\n    No  → Return: false // 不是三次方，回傳 false\nEnd // 程式執行結束\n\nBut we need to maintain proper indentation. For decision branches, we show indentation. Provide each line separately.\n\nAlso maybe use \"→ Decision:\" lines with nested. Use same formatting as example.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Input: n // 取得使用者輸入的整數\n→ Decision: n <= 0? // 檢查是否為非正數\n    Yes → Return: false // 非正數非三次方，直接回傳 false\n    No  → Step: while n % 3 == 0 do n = n / 3 // 只要 n 能被 3 整除就不斷除以 3\n→ Decision: n == 1? // 除完之後若 n 為 1，表示原數為 3 的冪\n    Yes → Return: true // 是三次方，回傳 true\n    No  → Return: false // 不是三次方，回傳 false\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def isPowerOfThree(self, n: int) -> bool:\n        if n <= 0:\n            return False\n        while n % 3 == 0:\n            n //= 3\n        return n == 1\n\ndef main():\n    data = sys.stdin.read()\n    match = re.search(r'-?\\d+', data)\n    if not match:\n        print('false')\n        return\n    n = int(match.group())\n    result = Solution().isPowerOfThree(n)\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 27",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "n = 0",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "n = -1",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode179.json",
    "problem_index_in_file": 0,
    "title": "Largest Number",
    "description_snippet": "Given a list of non-negative integers nums, arrange them such that they form the largest number and ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps. Use arrows and structure. Steps: start, input nums, convert to string array, sort with custom comparator that compares a+b vs b+a, then join, remove leading zeros, if empty return \"0\", else return result. Use virtual code lines.\n\nWe must not output real code, just pseudo steps. Provide explanation per line.\n\nLet's craft steps:\n\nStart\n→ Step 1: Receive nums // get list of numbers\n→ Step 2: Convert each number to string // for string comparison\n→ Step 3: Sort strings with comparator (a+b > b+a) // define order\n→ Step 4: Concatenate sorted strings into result // join\n→ Step 5: If result starts with '0' then return \"0\" // handle all zeros\n→ Decision: If result[0] == '0'? // check\n    Yes → Step 6: Set result = \"0\" // set single zero\n    No  → // keep result\n→ End // output result\n\nBut we need more explicit steps. Use Decision blocks etc.\n\nAdd comments.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 接收輸入列表 nums // 取得非負整數列表  \n→ Step 2: 把每個數字轉成字串 arr // 方便字串比較  \n→ Step 3: 用自訂比較函式對 arr 進行排序 // 使 a+b 大於 b+a 時排前  \n    Decision: 兩字串 a, b 的 a+b 是否大於 b+a?  \n        Yes → 排序時把 a 放在前面  \n        No  → 排序時把 b 放在前面  \n→ Step 4: 把排序後的字串連結成一個長字串 result // 組成最長數字  \n→ Decision: result 的第一個字元是否為 '0'? // 檢查是否全為零  \n    Yes → Step 5: result = \"0\" // 若全零，輸出單一 '0'  \n    No  → // 保留 result  \n→ End // 程式執行結束，輸出 result (字串)",
      "generated_code": "import sys\nimport ast\nfrom functools import cmp_to_key\n\ndef largestNumber(nums):\n    \"\"\"Return the largest number that can be formed by concatenating the list of non‑negative integers.\"\"\"\n    nums_str = list(map(str, nums))\n\n    def compare(x, y):\n        # If x+y is greater, x should come before y\n        if x + y > y + x:\n            return -1\n        elif x + y < y + x:\n            return 1\n        else:\n            return 0\n\n    nums_str.sort(key=cmp_to_key(compare))\n    result = ''.join(nums_str)\n    return '0' if result[0] == '0' else result\n\ndef parse_input(data: str):\n    \"\"\"\n    Extract a list of integers from a string that may look like:\n        'nums = [10, 2]'\n    or simply\n        '[10, 2]'\n    \"\"\"\n    data = data.strip()\n    if not data:\n        return []\n\n    # Find the first '[' and the last ']'\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1 or end <= start:\n        raise ValueError(\"Input does not contain a list\")\n\n    list_str = data[start:end+1]\n    return ast.literal_eval(list_str)\n\nif __name__ == \"__main__\":\n    # Read all input from stdin\n    raw_input = sys.stdin.read()\n    try:\n        nums = parse_input(raw_input)\n    except Exception:\n        # If parsing fails, assume input is just a comma‑separated list of numbers\n        nums = [int(x) for x in raw_input.strip().split(',') if x.strip()]\n\n    result = largestNumber(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [10,2]",
          "expected_output": "\"210\"",
          "success": true,
          "output": "210"
        },
        {
          "example_index": 1,
          "input": "nums = [3,30,34,5,9]",
          "expected_output": "\"9534330\"",
          "success": true,
          "output": "9534330"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode232.json",
    "problem_index_in_file": 0,
    "title": "Implement Queue using Stacks",
    "description_snippet": "Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should supp...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step with explanations, following format. Must be in Traditional Chinese. Use Start, End, Decision:, arrow. Implement FIFO queue using two stacks. Provide steps of operations push, pop, peek, empty. Probably outline algorithm: stack1 for input, stack2 for output. For push: push onto stack1. For pop/peek: if stack2 empty, transfer all from stack1 to stack2. Then pop/peek from stack2. Empty: return true if both stacks empty.\n\nWe should provide virtual steps for each function, maybe as separate sections. Or maybe show entire class flow? The user asked \"Implement the MyQueue class\" with methods. We can give virtual code for class definition and each method. Use line-by-line approach.\n\nLet's create:\n\nStart // 程式開始執行\n→ Step 1: 定義 MyQueue 類別 // 建立 Queue 類\n→ Step 2: 初始化兩個空堆疊 inStack, outStack // 用於進入與輸出\n\nThen methods:\n\nPush: \n→ Step 3: push(x) // 將元素推入 inStack\n\nPop:\n→ Step 4: pop() // 若 outStack 為空，將 inStack 所有元素移至 outStack\n    → Decision: outStack.isEmpty()?\n        Yes → Step 5: While inStack not empty, pop from inStack and push to outStack // 轉移\n    → Step 6: Return outStack.pop() // 取出前端元素\n\nPeek:\n→ Step 7: peek() // 同 pop 但不移除\n    → Decision: outStack.isEmpty()?\n        Yes → Step 8: Transfer as in pop\n    → Step 9: Return outStack.peek() // 取得前端元素\n\nEmpty:\n→ Step 10: empty() // 檢查兩個堆疊是否皆空\n    → Decision: inStack.isEmpty() AND outStack.isEmpty()?\n        Yes → Step 11: Return true\n        No  → Step 12: Return false\n\nEnd // 程式執行結束\n\nWe need to keep each line with explanation.\n\nAlso might include internal details of transfer in separate steps.\n\nUse \"Step\" numbering? Use \"Step X:\" but can include. The format sample uses \"Step 1:\" etc. We'll follow.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 MyQueue 類別 // 建立一個新的 Queue 類型  \n→ Step 2: 初始化兩個空堆疊 inStack 與 outStack // 用於存放進入與輸出的元素  \n\n// ---------------------- Push ----------------------  \n→ Step 3: push(x) // 進行 push 操作  \n    → Step 4: inStack.push(x) // 直接將 x 放入 inStack 的頂端  \n\n// ---------------------- Pop ----------------------  \n→ Step 5: pop() // 進行 pop 操作  \n    → Decision: outStack.isEmpty()? // 檢查輸出堆疊是否為空  \n        Yes → Step 6: While inStack.isEmpty() is False:  \n            → Step 7: temp = inStack.pop() // 從 inStack 取出頂端元素  \n            → Step 8: outStack.push(temp) // 將其推入 outStack  \n    → Step 9: return outStack.pop() // 從 outStack 取出並返回前端元素  \n\n// ---------------------- Peek ----------------------  \n→ Step 10: peek() // 進行 peek 操作  \n    → Decision: outStack.isEmpty()? // 檢查輸出堆疊是否為空  \n        Yes → Step 11: While inStack.isEmpty() is False:  \n            → Step 12: temp = inStack.pop() // 從 inStack 取出頂端元素  \n            → Step 13: outStack.push(temp) // 推入 outStack  \n    → Step 14: return outStack.peek() // 回傳 outStack 頂端元素（不移除）  \n\n// ---------------------- Empty ----------------------  \n→ Step 15: empty() // 檢查是否為空  \n    → Decision: inStack.isEmpty() AND outStack.isEmpty()? // 兩個堆疊皆空即為空  \n        Yes → Step 16: return True // Queue 為空  \n        No  → Step 17: return False // Queue 非空  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\n\n# ========================= MyQueue =========================\nclass MyQueue:\n    \"\"\"\n    用兩個堆疊來實作 FIFO 隊列\n    stack_in  : 用於 push 新元素\n    stack_out : 用於 pop / peek 取前端元素\n    \"\"\"\n    def __init__(self):\n        # 兩個空堆疊\n        self.stack_in = []\n        self.stack_out = []\n\n    def push(self, x: int) -> None:\n        \"\"\"\n        把元素 x 推到後端\n        \"\"\"\n        self.stack_in.append(x)\n\n    def _transfer(self) -> None:\n        \"\"\"\n        若 stack_out 為空，將 stack_in 內的所有元素倒序推入 stack_out，\n        使最新進入的元素位於 stack_out 的底部，符合 FIFO\n        \"\"\"\n        while self.stack_in:\n            self.stack_out.append(self.stack_in.pop())\n\n    def pop(self) -> int:\n        \"\"\"\n        移除並回傳前端元素\n        \"\"\"\n        if not self.stack_out:\n            self._transfer()\n        return self.stack_out.pop()\n\n    def peek(self) -> int:\n        \"\"\"\n        回傳前端元素但不移除\n        \"\"\"\n        if not self.stack_out:\n            self._transfer()\n        return self.stack_out[-1]\n\n    def empty(self) -> bool:\n        \"\"\"\n        判斷隊列是否為空\n        \"\"\"\n        return not self.stack_in and not self.stack_out\n\n\n# ========================= Main =========================\nif __name__ == \"__main__\":\n    # 讀取所有非空行\n    raw_lines = [line.strip() for line in sys.stdin if line.strip() != \"\"]\n\n    # 有時第一行會是 \"Input\" 等文字，若不是 JSON 就跳過\n    if raw_lines[0].startswith('['):\n        ops_line = raw_lines[0]\n        args_line = raw_lines[1]\n    else:\n        ops_line = raw_lines[1]\n        args_line = raw_lines[2]\n\n    # 解析 JSON\n    ops = json.loads(ops_line)\n    args = json.loads(args_line)\n\n    results = []\n    obj = None\n\n    for op, arg in zip(ops, args):\n        if op == \"MyQueue\":\n            obj = MyQueue()\n            results.append(None)          # 建構子回傳 null\n        elif op == \"push\":\n            obj.push(arg[0])\n            results.append(None)          # push 不回傳值\n        elif op == \"pop\":\n            results.append(obj.pop())\n        elif op == \"peek\":\n            results.append(obj.peek())\n        elif op == \"empty\":\n            results.append(obj.empty())\n\n    # 輸出結果，使用 json.dumps 讓 true/false/null 正確顯示\n    print(json.dumps(results))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "Input\n[\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]\n[[], [1], [2], [], [], []]",
          "expected_output": "[null, null, null, 1, 1, false]",
          "success": true,
          "output": "[null, null, null, 1, 1, false]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode493.json",
    "problem_index_in_file": 0,
    "title": "Reverse Pairs",
    "description_snippet": "Given an integer array nums, return the number of reverse pairs in the array.\n\nA reverse pair is a p...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code step-by-step, not actual code. It should be structured with Start, End, Decision, arrows, etc. Provide each line with explanation.\n\nWe need to solve reverse pairs count: typical solution uses merge sort or BIT. For pseudo-code, can outline algorithm: divide array, count cross pairs, etc.\n\nWe need to include \"逐行\" output, each line: \"虛擬碼步驟 // 解釋\".\n\nUse arrow lines: \"→ Step ...\". Use Decision.\n\nShould incorporate recursion? Use merge sort recursion.\n\nWe need to output pseudo-code lines that cover:\n\n- Start\n- Input array\n- Call function to count reverse pairs\n- In function: base case\n- Divide\n- Recursively count left and right\n- Merge step: count cross pairs\n- Merge arrays\n- Return total\n\nAdd explanation for each step.\n\nLet's write pseudo-code lines.\n\nWe also need to ensure \"逐行輸出\" means each line separate. Use spaces appropriately.\n\nOk produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入整數陣列 nums // 從使用者處取得待處理的整數陣列  \n→ Step 2: 計算 reverse pair 數量 = CountReversePairs(nums, 0, nums.length-1) // 呼叫遞迴函式進行統計  \n→ End // 程式執行結束  \n\n// --------------------------------------------------------------  \n// 逆序對統計遞迴函式  \n// --------------------------------------------------------------  \n→ Function CountReversePairs(arr, left, right) // 定義遞迴函式  \n    → Decision: 如果 left >= right? // 檢查子陣列是否只有一個或零個元素  \n        Yes → Return 0 // 單一元素無法形成逆序對  \n        No  → Step 3: mid = (left + right) / 2 // 找到中點，分割陣列  \n    → Step 4: leftCount = CountReversePairs(arr, left, mid) // 遞迴計算左半邊逆序對  \n    → Step 5: rightCount = CountReversePairs(arr, mid+1, right) // 遞迴計算右半邊逆序對  \n    → Step 6: crossCount = CountCrossPairs(arr, left, mid, right) // 計算跨越左右兩半的逆序對  \n    → Step 7: MergeSorted(arr, left, mid, right) // 合併左右兩半為排序後陣列  \n    → Return leftCount + rightCount + crossCount // 回傳總逆序對數  \n\n// --------------------------------------------------------------  \n// 計算跨越左右兩半的逆序對  \n// --------------------------------------------------------------  \n→ Function CountCrossPairs(arr, left, mid, right)  \n    → Step 8: count = 0  \n    → Step 9: i = left  \n    → Step 10: j = mid + 1  \n    → Decision: 如果 j > right? // 若右半已經到尾，結束循環  \n        Yes → Return count  \n        No  →  \n            → Decision: 如果 arr[i] > 2 * arr[j]? // 檢查是否為逆序對  \n                Yes → count += (mid - i + 1) // 所有從 i 到 mid 的元素皆與 arr[j] 成逆序對  \n                        j++ // 移動右半指標  \n                No  → i++ // 移動左半指標  \n            → 回到 Decision: j > right? // 重複檢查  \n    → End // 函式結束  \n\n// --------------------------------------------------------------  \n// 合併兩個已排序子陣列  \n// --------------------------------------------------------------  \n→ Function MergeSorted(arr, left, mid, right)  \n    → Step 11: temp = empty list  \n    → Step 12: i = left, j = mid+1  \n    → Decision: 如果 i <= mid AND j <= right?  \n        Yes →  \n            → Decision: 如果 arr[i] <= arr[j]?  \n                Yes → temp.append(arr[i]); i++  \n                No  → temp.append(arr[j]); j++  \n            → 回到 Decision  \n        No  →  \n            → Decision: 如果 i <= mid?  \n                Yes → temp.append(arr[i]); i++  \n                No  → temp.append(arr[j]); j++  \n            → 回到 Decision  \n    → Step 13: 把 temp 中元素複製回 arr[left...right] // 更新主陣列  \n    → End // 函式結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def reversePairs(self, nums):\n        def merge_sort(start, end):\n            if start >= end:\n                return 0\n            mid = (start + end) // 2\n            count = merge_sort(start, mid) + merge_sort(mid + 1, end)\n            j = mid + 1\n            for i in range(start, mid + 1):\n                while j <= end and nums[i] > 2 * nums[j]:\n                    j += 1\n                count += j - (mid + 1)\n            temp = []\n            left, right = start, mid + 1\n            while left <= mid and right <= end:\n                if nums[left] <= nums[right]:\n                    temp.append(nums[left])\n                    left += 1\n                else:\n                    temp.append(nums[right])\n                    right += 1\n            while left <= mid:\n                temp.append(nums[left])\n                left += 1\n            while right <= end:\n                temp.append(nums[right])\n                right += 1\n            nums[start:end + 1] = temp\n            return count\n        return merge_sort(0, len(nums) - 1)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    if '=' in data:\n        _, list_part = data.split('=', 1)\n        list_part = list_part.strip()\n    else:\n        list_part = data\n    try:\n        nums = ast.literal_eval(list_part)\n    except Exception:\n        nums = []\n    result = Solution().reversePairs(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,3,2,3,1]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "nums = [2,4,3,5,1]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode443.json",
    "problem_index_in_file": 0,
    "title": "String Compression",
    "description_snippet": "Given an array of characters chars, compress it using the following algorithm:\n\nBegin with an empty ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line with explanation. The requirement: given array of chars, compress in place with constant extra space, return new length. So typical algorithm: two pointers, write index and read index. Count repeated groups.\n\nLet's produce pseudo-code:\n\nStart\n→ Step 1: Initialize writeIndex = 0 // write position\n→ Step 2: Initialize readIndex = 0 // read position\n→ Decision: If readIndex >= len(chars) -> End? Actually loop.\n\nWe iterate over chars until readIndex < len(chars):\nWithin loop:\n- Set currentChar = chars[readIndex]\n- Set count = 0\n- While readIndex < len(chars) && chars[readIndex] == currentChar:\n    readIndex++\n    count++\n- Write currentChar at writeIndex, writeIndex++\n- If count > 1:\n    Convert count to string, iterate digits:\n        Write each digit char to chars[writeIndex], writeIndex++\n\nAfter loop, return writeIndex\n\nSo produce virtual code lines accordingly. Must use arrow \"→\". Provide explanation comment after //.\n\nWe should also include decisions and loops. Use \"Decision:\" for conditions.\n\nNeed to maintain constant extra space: we use only local variables, no additional arrays.\n\nLet's produce line by line.\n\nBe careful about syntax of pseudo-code: Use \"Start\", \"End\". Use \"Decision:\" for if statements, loops? In example they used \"Decision:\" with indentation. For loops we can just represent as \"While\" or \"Decision: If\". We'll use \"Decision:\" for if, \"While:\" for loops maybe.\n\nBut the format uses \"→\" for steps. We'll do:\n\nStart // 程式開始執行\n→ Step 1: writeIndex ← 0 // 初始化寫入指標\n→ Step 2: readIndex ← 0 // 初始化讀取指標\n→ While readIndex < len(chars) // 遍歷整個陣列\n    → Step 3: currentChar ← chars[readIndex] // 取得目前字元\n    → Step 4: count ← 0 // 計數器清零\n    → While readIndex < len(chars) AND chars[readIndex] == currentChar // 計算連續重複數量\n        → Step 5: readIndex ← readIndex + 1 // 移動到下一個\n        → Step 6: count ← count + 1 // 增加計數\n    → Step 7: chars[writeIndex] ← currentChar // 將字元寫入\n        → writeIndex ← writeIndex + 1\n    → Decision: if count > 1 // 有多個重複\n        → Yes → Step 8: numStr ← toString(count) // 轉成字串\n            → For each digit in numStr\n                → Step 9: chars[writeIndex] ← digit\n                → writeIndex ← writeIndex + 1\n        → No → // 不寫入數字\n    → // loop continues\n→ End // 循環結束\n→ Step 10: return writeIndex // 回傳壓縮後的長度\n\nWe need to use \"→\" arrow before each step, with indentation for nested steps. Use \"Decision:\" for if.\n\nAlso inside loops we might need \"While\" representation. Use \"→ While ...\" etc.\n\nMake sure to add explanation comments after // for each line. Use concise explanation in Chinese.\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: writeIndex ← 0 // 初始化寫入指標（寫入位置）\n→ Step 2: readIndex ← 0 // 初始化讀取指標（讀取位置）\n→ While readIndex < len(chars) // 遍歷整個字元陣列\n    → Step 3: currentChar ← chars[readIndex] // 取得當前字元\n    → Step 4: count ← 0 // 初始化重複計數\n    → While readIndex < len(chars) AND chars[readIndex] == currentChar // 計算同一字元連續個數\n        → Step 5: readIndex ← readIndex + 1 // 移至下一個字元\n        → Step 6: count ← count + 1 // 累加計數\n    → Step 7: chars[writeIndex] ← currentChar // 把字元寫入結果位置\n        → writeIndex ← writeIndex + 1 // 更新寫入位置\n    → Decision: if count > 1 // 有重複的情況\n        → Yes → Step 8: numStr ← toString(count) // 把計數轉成字串\n            → For each digit in numStr // 把每個數字字元寫入\n                → Step 9: chars[writeIndex] ← digit // 寫入數字字元\n                → writeIndex ← writeIndex + 1 // 更新寫入位置\n        → No → // 不寫入任何數字，單個字元已寫入\n    → // 進入下一組字元\n→ End // 完成整個陣列的遍歷\n→ Step 10: return writeIndex // 回傳壓縮後的長度\n```",
      "generated_code": "import sys\nimport ast\nimport re\n\nclass Solution:\n    def compress(self, chars):\n        write = 0          # 寫入指標\n        left = 0           # 讀取指標起點\n        n = len(chars)\n\n        while left < n:\n            right = left\n            # 找到相同字元的結束位置\n            while right < n and chars[right] == chars[left]:\n                right += 1\n\n            # 寫入字元\n            chars[write] = chars[left]\n            write += 1\n\n            count = right - left\n            # 若有多個重複，將數字寫入\n            if count > 1:\n                for c in str(count):\n                    chars[write] = c\n                    write += 1\n\n            # 移至下一個字元組\n            left = right\n\n        return write\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 從輸入中擷取字元列表\n    match = re.search(r'\\[.*\\]', data, re.S)\n    if match:\n        chars = ast.literal_eval(match.group())\n    else:\n        chars = ast.literal_eval(data)\n\n    solution = Solution()\n    new_length = solution.compress(chars)\n    print(new_length)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "chars = [\"a\",\"a\",\"b\",\"b\",\"c\",\"c\",\"c\"]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "chars = [\"a\"]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "chars = [\"a\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\"]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode541.json",
    "problem_index_in_file": 0,
    "title": "Reverse String II",
    "description_snippet": "Given a string s and an integer k, reverse the first k characters for every 2k characters counting f...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code lines following format: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision:, arrow notation.\n\nThe algorithm: iterate index i from 0 to n in steps of 2k. For each segment: compute subStart=i, subEnd=min(i+k-1, n-1). Reverse substring from subStart to subEnd. Then keep rest untouched. Implementation details: loop, compute segment size.\n\nVirtual code: Start. Set n=len(s). Set i=0. Decision: while i < n? Then within loop. Steps: compute subStart, subEnd, reverse. Then i += 2k. End.\n\nAlso include case of fewer than k characters left: handled by min. Provide explanation each line.\n\nLet's craft. Use 虛擬碼 step names like \"Step 1: 初始化變數\". Provide arrow lines. Use indentation for decisions.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 n ← length(s) // 取得字串長度  \n→ Step 2: 設定 i ← 0 // 初始化區段起始位置  \n→ Decision: i < n? // 若還有未處理的字元  \n Yes → Step 3: 計算 segmentEnd ← min(i + k, n) // 第 k 個字元或到結束  \n    Step 4: 反轉子字串 s[i : segmentEnd] // 只翻轉前 k 個字元  \n    Step 5: i ← i + 2k // 移動到下一個 2k 區段的起點  \n    Go back to Decision // 重複處理剩餘字元  \n No  → End // 所有字元已處理  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def reverseStr(self, s: str, k: int) -> str:\n        \"\"\"將字串中每 2k 個字元的前 k 個字元反轉。\"\"\"\n        chars = list(s)\n        for i in range(0, len(chars), 2 * k):\n            # 只反轉從 i 到 i+k-1（或到結尾）的區段\n            chars[i:i + k] = reversed(chars[i:i + k])\n        return \"\".join(chars)\n\ndef main() -> None:\n    # 從 stdin 讀取輸入，格式為:  \"string\", k\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 依照第一個逗號分割成字串部分與整數部分\n    parts = data.split(',', 1)\n    s_part = parts[0].strip()\n    k_part = parts[1].strip()\n\n    # 去除字串左右的引號\n    if (s_part.startswith('\"') and s_part.endswith('\"')) or \\\n       (s_part.startswith(\"'\") and s_part.endswith(\"'\")):\n        s = s_part[1:-1]\n    else:\n        s = s_part\n\n    k = int(k_part)\n\n    solution = Solution()\n    result = solution.reverseStr(s, k)\n\n    # 按題目格式輸出，結果前後帶雙引號\n    print(f'\"{result}\"')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "\"abcdefg\", 2",
          "expected_output": "\"bacdfeg\"",
          "success": true,
          "output": "\"bacdfeg\""
        },
        {
          "example_index": 1,
          "input": "\"abcd\", 2",
          "expected_output": "\"bacd\"",
          "success": true,
          "output": "\"bacd\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode188.json",
    "problem_index_in_file": 0,
    "title": "Best Time to Buy and Sell Stock IV",
    "description_snippet": "You are given an integer array prices where prices[i] is the price of a given stock on the ith day, ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code for solving stock profit with at most k transactions. It's typical DP: dp[transaction][day] for max profit up to day with at most transaction transactions. We can use two loops. Pseudocode. Must produce step-by-step lines with explanations.\n\nWe output each line as \"虛擬碼步驟 // 解釋\". Use Start, End, Decision. Provide loops.\n\nLet's produce:\n\nStart\n→ Initialize dp array size (k+1) × n with 0 // set base profits\n→ For transaction from 1 to k:\n    → maxDiff = -prices[0] // best value of buy - profit so far\n    → For day from 1 to n-1:\n        → dp[transaction][day] = max(dp[transaction][day-1], prices[day] + maxDiff) // either keep previous profit or sell today\n        → maxDiff = max(maxDiff, dp[transaction-1][day] - prices[day]) // update best buy value\n→ Result = dp[k][n-1] // maximum profit\nEnd\n\nBut need line-by-line with arrow and decision. Not many decisions. Could add a decision to handle empty array.\n\nWe'll produce each line with explanation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Decision: 如果 prices 為空或 k = 0? // 檢查輸入是否可進行交易\n    Yes → Step: 返回 0 // 無價格或無交易，直接結束\n    No  → \n→ Step: n ← length(prices) // 取得價格長度\n→ Step: 建立 dp 陣列 (k+1) × n，並全部設為 0 // dp[t][d] 表示在第 d 天完成 t 交易時的最大利潤\n→ Decision: 從 1 到 k 迭代? // 逐步處理每一筆交易\n    Yes →\n        → Step: maxDiff ← -prices[0] // 代表「買入」後的剩餘利潤（即賣價減買價）\n        → Decision: 從 1 到 n-1 迭代? // 逐天更新\n            Yes →\n                → Step: dp[t][d] ← max(dp[t][d-1], prices[d] + maxDiff) // 保留前一日利潤或今天賣出\n                → Step: maxDiff ← max(maxDiff, dp[t-1][d] - prices[d]) // 更新最佳買入時機\n            No →\n        → \n    No →\n→ Step: result ← dp[k][n-1] // 取得完成 k 次交易後的最大利潤\n→ Step: 輸出 result // 顯示結果\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def maxProfit(self, k, prices):\n        n = len(prices)\n        if n == 0:\n            return 0\n        # If k is large enough, it is equivalent to unlimited transactions\n        if k >= n // 2:\n            profit = 0\n            for i in range(1, n):\n                if prices[i] > prices[i - 1]:\n                    profit += prices[i] - prices[i - 1]\n            return profit\n        # DP approach for limited transactions\n        dp = [[0] * n for _ in range(k + 1)]\n        for t in range(1, k + 1):\n            max_diff = -prices[0]  # best value of (profit from previous transaction - price)\n            for d in range(1, n):\n                dp[t][d] = max(dp[t][d - 1], prices[d] + max_diff)\n                max_diff = max(max_diff, dp[t - 1][d] - prices[d])\n        return dp[k][n - 1]\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n    # Normalize the input string\n    normalized = raw_input.replace('k =', '').replace('prices =', '').replace(' ', '')\n    parts = normalized.split(',')\n    k = int(parts[0])\n    prices = ast.literal_eval(parts[1])\n    result = Solution().maxProfit(k, prices)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "k = 2, prices = [2,4,1]",
          "expected_output": "2",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpjlkmybis.py\", line 33, in <module>\n    prices = ast.literal_eval(parts[1])\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [2\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "k = 2, prices = [3,2,6,5,0,3]",
          "expected_output": "7",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpbcqnop35.py\", line 33, in <module>\n    prices = ast.literal_eval(parts[1])\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [3\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode522.json",
    "problem_index_in_file": 0,
    "title": "Longest Uncommon Subsequence II",
    "description_snippet": "Given an array of strings strs, return the length of the longest uncommon subsequence between them. ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code step-by-step explanation for algorithm to find longest uncommon subsequence length. Known solution: If all strings identical, return -1. Else, longest uncommon subsequence is the maximum length among strings that are not duplicate of another string. Actually if any string appears only once and its length is greater than any other string length, answer is that length. But if duplicates, the longer string may be same as shorter? Wait: known solution: If any string is unique (occurs once) then answer is its length; else return -1. Because if all strings are identical, no uncommon subsequence exists. If there are duplicates, the unique string that is longer than all others is answer? Actually consider [a,b]. \"a\" and \"b\" are unique. Longest uncommon subsequence is length 1. For [aa,ab]. \"aa\" occurs once, \"ab\" occurs once; longest length 2. But check if one string is a subsequence of another? Problem says subsequence of one string but not others. If two unique strings, any string itself is subsequence of itself and not others? But \"aa\" is not a subsequence of \"ab\" or vice versa. So length 2. But algorithm: find longest string that is not a subsequence of any other string? But known solution from Leetcode 955: if there exists string that is unique (no duplicate), answer is its length; otherwise -1. Wait but if there are two unique strings of same length, answer is that length. That works.\n\nSo implement virtual steps: Count frequencies, find longest length among strings with freq=1; if none, return -1. That's the solution.\n\nThus produce steps:\n\nStart\n→ Step 1: Create frequency map for each string\n→ Step 2: Initialize maxLen = -1\n→ Step 3: For each string in strs:\n→ Decision: if freq of string == 1? // unique string\n→ Yes → Update maxLen = max(maxLen, length of string) // track longest unique\n→ End for loop\n→ Decision: if maxLen == -1? // no unique string\n→ Yes → Return -1\n→ No  → Return maxLen\nEnd\n\nAdd comments.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立字串頻率表 freq[字串] = 次數 // 先統計每個字串出現的次數\n→ Step 2: 設定 maxLen = -1 // 用來存放最長的唯一字串長度，初始為 -1 表示尚未找到\n→ Step 3: 逐一遍歷每個字串 s in strs // 遍歷輸入陣列\n    → Decision: 若 freq[s] == 1? // 判斷該字串是否只出現一次\n        Yes → Step 4: 更新 maxLen = max(maxLen, len(s)) // 若唯一，更新最長長度\n        No  → // 不是唯一字串，跳過\n→ Decision: 若 maxLen == -1? // 是否還沒有任何唯一字串\n    Yes → Step 5: 回傳 -1 // 沒有長度可用，回傳 -1\n    No  → Step 6: 回傳 maxLen // 回傳最長的唯一字串長度\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\n\nclass Solution:\n    def findLUSlength(self, strs):\n        # Sort strings by descending length to try longest first\n        strs.sort(key=lambda x: -len(x))\n        for i, s in enumerate(strs):\n            # Check if s is not a subsequence of any other string\n            if all(not self.is_subsequence(s, t) for j, t in enumerate(strs) if i != j):\n                return len(s)\n        return -1\n\n    @staticmethod\n    def is_subsequence(s, t):\n        \"\"\"\n        Return True if s is a subsequence of t.\n        \"\"\"\n        it = iter(t)\n        return all(c in it for c in s)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Parse input like '[\"aba\",\"cdc\",\"eae\"]'\n    try:\n        strs = json.loads(data)\n    except json.JSONDecodeError:\n        # If input is not valid JSON, exit gracefully\n        print(-1)\n        return\n    result = Solution().findLUSlength(strs)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"aba\",\"cdc\",\"eae\"]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "[\"aaa\",\"aaa\",\"aa\"]",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode413.json",
    "problem_index_in_file": 0,
    "title": "Arithmetic Slices",
    "description_snippet": "An integer array is called arithmetic if it consists of at least three elements and if the differenc...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code solution for counting arithmetic subarrays. Provide step by step.\n\nWe need to generate algorithm: iterate over array, maintain length of current arithmetic sequence, count contributions. Use sliding window. The known solution: For each index i>=2, if nums[i]-nums[i-1]==nums[i-1]-nums[i-2] then current_len++ else current_len=2. And add max(current_len-2,0) to answer. Because each arithmetic subarray of length L>=3 contributes L-2 subarrays.\n\nThus produce virtual code lines with arrows.\n\nLet's produce lines:\n\nStart\n→ Initialize ans = 0 // 儲存總數\n→ Initialize current_len = 2 // 最少兩個元素的序列長度\n→ For i from 2 to n-1: // 從第三個元素開始檢查\n    → If nums[i]-nums[i-1] == nums[i-1]-nums[i-2]: // 差相等\n        → current_len = current_len + 1 // 延長序列\n        → ans = ans + current_len - 2 // 加入新的子序列\n    → Else:\n        → current_len = 2 // 重置長度\nEnd // 返回 ans\n\nMake sure each line has format. Add explanatory comments. Use \"Decision:\" for if. Use arrow. Let's produce.\n\nUse \"Decision:\" line: \nDecision: 差相等? // 判斷是否能延長算術子陣列\n\nThen Yes → ... No → ... We'll put steps.\n\nSo produce:\n\nStart // 程式開始\n→ Step 1: 設定 ans = 0 // 總算術子陣列數\n→ Step 2: 設定 current_len = 2 // 初始兩個元素可形成序列\n→ Step 3: 對 i 從 2 到 n-1 做迴圈 // 從第三個元素開始檢查\n    → Decision: nums[i]-nums[i-1] == nums[i-1]-nums[i-2]？ // 判斷差是否相等\n        Yes → current_len = current_len + 1 // 延長序列長度\n        Yes → ans = ans + current_len - 2 // 新增此長度所能得到的子陣列\n        No  → current_len = 2 // 重置序列長度為兩個元素\nEnd // 程式結束，返回 ans\n\nBut we need each line to be \"虛擬碼步驟 [space] // 解釋\". Use arrows for indentation. Should we use indent? They used arrow for each line. Eg \"→ Step 1: ...\" Good.\n\nNeed to include Start and End.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: ans = 0 // 用來累加所有算術子陣列的數量\n→ Step 2: current_len = 2 // 任何兩個元素都能形成長度至少 2 的序列，作為初始長度\n→ Step 3: For i from 2 to n-1 // 從第三個元素開始，逐個檢查連續差值\n    → Decision: nums[i]-nums[i-1] == nums[i-1]-nums[i-2] ? // 判斷是否能延長現有算術序列\n        Yes → current_len = current_len + 1 // 差值相等，序列長度增加 1\n        Yes → ans = ans + current_len - 2 // 這個長度的新算術子陣列數 = current_len-2\n        No  → current_len = 2 // 差值不等，重置為僅包含最近兩個元素\nEnd // 程式結束，返回 ans 為所有算術子陣列的總數",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def numberOfArithmeticSlices(self, nums):\n        n = len(nums)\n        if n < 3:\n            return 0\n        total = 0\n        curr = 0\n        for i in range(2, n):\n            if nums[i] - nums[i-1] == nums[i-1] - nums[i-2]:\n                curr += 1\n                total += curr\n            else:\n                curr = 0\n        return total\n\ndef main():\n    data = sys.stdin.read()\n    if not data:\n        print(0)\n        return\n    # 找出所有整數，支持負號\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    solution = Solution()\n    result = solution.numberOfArithmeticSlices(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,4]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode345.json",
    "problem_index_in_file": 0,
    "title": "Reverse Vowels of a String",
    "description_snippet": "Given a string s, reverse only all the vowels in the string and return it.\n\nThe vowels are 'a', 'e',...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code lines with explanations. Must not output actual code. Use Start, End, Decision: arrows.\n\nSo we need steps: convert string to array or use two pointers. Steps: set vowels set. left =0, right = len-1. While left<right: move left until vowel; move right until vowel; if left<right swap; left++; right--; After loop join array to string. Return.\n\nLet's produce lines accordingly. Use arrows. Provide explanation per line.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 vowels 集合包含 a, e, i, o, u (不分大小寫) // 準備判斷元音的工具  \n→ Step 2: 將輸入字串 s 轉成可編輯的字元陣列 chars // 方便雙指針交換  \n→ Step 3: 設定 left = 0, right = chars.length - 1 // 左右指針初始化  \n→ Decision: while left < right? // 判斷是否還有字元需要交換  \n    Yes → Step 4: Decision: chars[left] 是否為元音?  \n        Yes → 進入下一步  \n        No  → left++ // 左指針向右移動，尋找元音  \n    Yes → Step 5: Decision: chars[right] 是否為元音?  \n        Yes → 進入下一步  \n        No  → right-- // 右指針向左移動，尋找元音  \n    Yes → Step 6: Swap chars[left] 與 chars[right] // 兩側皆為元音，交換它們  \n    Yes → left++ // 交換後左指針往右移動  \n    Yes → right-- // 交換後右指針往左移動  \n    No  → 跳出迴圈 // left >= right，結束交換  \n→ Step 7: 將 chars 陣列重新組成字串 newString // 生成最終結果  \n→ Step 8: 回傳 newString // 完成功能  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def reverseVowels(self, s: str) -> str:\n        vowels = set('aeiouAEIOU')\n        chars = list(s)\n        left, right = 0, len(chars) - 1\n        while left < right:\n            while left < right and chars[left] not in vowels:\n                left += 1\n            while left < right and chars[right] not in vowels:\n                right -= 1\n            if left < right:\n                chars[left], chars[right] = chars[right], chars[left]\n                left += 1\n                right -= 1\n        return ''.join(chars)\n\ndef main() -> None:\n    input_text = sys.stdin.read().strip()\n    match = re.search(r'\"([^\"]*)\"', input_text)\n    if match:\n        s = match.group(1)\n    else:\n        s = input_text  # fallback: entire input is the string\n    result = Solution().reverseVowels(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"IceCreAm\"",
          "expected_output": "\"AceCreIm\"",
          "success": true,
          "output": "AceCreIm"
        },
        {
          "example_index": 1,
          "input": "s = \"leetcode\"",
          "expected_output": "\"leotcede\"",
          "success": true,
          "output": "leotcede"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode464.json",
    "problem_index_in_file": 0,
    "title": "Can I Win",
    "description_snippet": "In the \"100 game\" two players take turns adding, to a running total, any integer from 1 to 10. The p...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code, line by line, with explanation. We need to describe algorithm: recursion with memoization, bitmask to represent used numbers. Since maxChoosableInteger up to maybe 20, use bitmask. If desiredTotal <= 0 return true. If sum of all numbers < desiredTotal return false. Then DFS: for each unused number i from 1..max, if i >= desiredTotal => win; else if dfs(desiredTotal-i, mask|bit(i)) is false => win. else continue. Memoize mask. Return false at end.\n\nWe need to produce virtual code with arrows. Use Start, Decision, Step, etc.\n\nWe should include explanation after each line. Provide a line per step, but need multiple lines. We need to capture recursion and memo.\n\nAlso include base cases. Use \"Decision\" lines for condition checks.\n\nLet's produce:\n\nStart\n→ Step 1: Check if desiredTotal <= 0 // If target already met, first player wins\n→ Decision: desiredTotal <= 0?\n    Yes → Step 2: Return true // Already won\n    No  → Next step\n→ Step 3: Compute totalSum = maxChoosableInteger * (maxChoosableInteger + 1) / 2 // Sum of all numbers\n→ Decision: totalSum < desiredTotal?\n    Yes → Step 4: Return false // Even all numbers can't reach target\n    No  → Next step\n→ Step 5: Initialize memo map // cache mask->win\n→ Step 6: Define recursive function dfs(remaining, usedMask)\n    // ...\nWithin dfs:\n    → Decision: remaining <= 0?\n        Yes → Step: Return true // current player wins\n        No → Next\n    → Decision: usedMask in memo?\n        Yes → Step: Return memo[usedMask] // cached result\n        No → Next\n    → For i from 1 to maxChoosableInteger:\n        → Decision: bit i not set in usedMask?\n            Yes → Step: If i >= remaining then\n                → Step: Return true and store in memo\n            No → Continue\n            → Step: If dfs(remaining - i, usedMask | (1 << (i-1))) == false then\n                → Step: Return true and store in memo\n        → End For\n    → Step: Store false in memo[usedMask]\n    → Step: Return false\n→ End of dfs\n→ Step 7: Return dfs(desiredTotal, 0) // start recursion\n\nBut need to format each line: \"虛擬碼步驟 // 解釋\"\n\nUse arrow '→' before steps, indent? Provide indentation with tabs? Format uses indentation with spaces? In example they used spaces.\n\nWe'll produce with indentation for nested blocks using tabs or spaces.\n\nWe'll keep each line a single step.\n\nLet's produce lines accordingly.\n\nUse \"Start\", \"End\". We'll use \"Decision:\" lines with nested Yes / No arrows.\n\nWe'll represent recursion function as a block. Might be long; but we can compress.\n\nBut instructions: each line must be a step, cannot be multiline? Example shows nested blocks with indentation. So we can have lines like:\n\n→ Step 1: ...\n\n→ Decision: ... ?\n\n    Yes → Step...\n\n    No  → Step...\n\nBut for recursion we might need to show function body steps. We'll keep each line separate.\n\nLet's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算總可用數字總和 totalSum = maxChoosableInteger * (maxChoosableInteger + 1) / 2 // 求 1~maxChoosableInteger 的和  \n→ Decision: totalSum < desiredTotal? // 檢查所有數字加起來是否還無法達到目標  \n    Yes → Step 2: Return false // 兩位玩家無法贏，直接返回  \n    No  → Next // 繼續進行以下判斷  \n→ Decision: desiredTotal <= 0? // 目標已經達成  \n    Yes → Step 3: Return true // 第一個玩家已經勝利  \n    No  → Next // 進行遞迴判斷  \n→ Step 4: 初始化 memo = {} // 用於記錄已計算過的狀態  \n→ Step 5: 定義遞迴函式 dfs(remaining, usedMask) // 參數: 剩餘目標, 已使用數字的位元組  \n    // ----------------- 函式內部 -----------------  \n    → Decision: remaining <= 0? // 若剩餘目標為 0 或負  \n        Yes → Step 6: Return true // 當前玩家立即勝利  \n        No  → Next  \n    → Decision: memo.hasOwnProperty(usedMask)? // 是否已經計算過此狀態  \n        Yes → Step 7: Return memo[usedMask] // 直接回傳快取結果  \n        No  → Next  \n    → For i from 1 to maxChoosableInteger: // 嘗試每個未被使用的數字  \n        → Decision: (usedMask & (1 << (i-1))) === 0? // 檢查數字 i 是否未被選用  \n            Yes → Step 8: If i >= remaining then  \n                → Step 9: memo[usedMask] = true // 立即贏  \n                → Step 10: Return true  \n                → Step 11: End If  \n            No  → Next  \n            → Step 12: If dfs(remaining - i, usedMask | (1 << (i-1))) === false then  \n                → Step 13: memo[usedMask] = true // 可以逼迫對手輸  \n                → Step 14: Return true  \n                → Step 15: End If  \n    → Step 16: memo[usedMask] = false // 以上選擇皆無法贏  \n    → Step 17: Return false // 返回失敗結果  \n    // ----------------- 函式結束 -----------------  \n→ Step 18: Return dfs(desiredTotal, 0) // 從空白狀態開始遞迴判斷  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\n        # 目標已經滿足\n        if desiredTotal <= 0:\n            return True\n        # 所有數字加起來還不足以達到目標\n        total_sum = maxChoosableInteger * (maxChoosableInteger + 1) // 2\n        if total_sum < desiredTotal:\n            return False\n\n        memo = {}\n\n        def can_win(used: int, remaining: int) -> bool:\n            # 如果已經計算過這個狀態就直接回傳\n            if used in memo:\n                return memo[used]\n\n            # 嘗試每個未被使用的數字\n            for i in range(maxChoosableInteger):\n                bit = 1 << i\n                if not (used & bit):\n                    num = i + 1\n                    # 如果本輪選取這個數字就能達到目標\n                    if num >= remaining:\n                        memo[used] = True\n                        return True\n                    # 否則看對手是否會輸\n                    if not can_win(used | bit, remaining - num):\n                        memo[used] = True\n                        return True\n\n            # 所有選擇都無法勝利\n            memo[used] = False\n            return False\n\n        return can_win(0, desiredTotal)\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取資料\n    data = sys.stdin.read()\n    # 取得所有整數（不管格式如何）\n    nums = list(map(int, re.findall(r\"-?\\d+\", data)))\n    if len(nums) >= 2:\n        maxChoosableInteger, desiredTotal = nums[0], nums[1]\n    else:\n        # 若輸入不足兩個數字，視為預設值\n        maxChoosableInteger, desiredTotal = 0, 0\n\n    result = Solution().canIWin(maxChoosableInteger, desiredTotal)\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "maxChoosableInteger = 10, desiredTotal = 11",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 1,
          "input": "maxChoosableInteger = 10, desiredTotal = 0",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "maxChoosableInteger = 10, desiredTotal = 1",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode122.json",
    "problem_index_in_file": 0,
    "title": "Best Time to Buy and Sell Stock II",
    "description_snippet": "You are given an integer array prices where prices[i] is the price of a given stock on the i^th day....",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nThe user requests a virtual code solution for the stock profit problem (best time to buy and sell multiple times, unlimited transactions). They want each line with arrow and explanation. Use Start, End, Decision. Should not output actual code, just steps. Provide the algorithm: keep cash and hold. For each price: if cash < hold + price? Actually the standard solution: hold = max(hold, cash - price); cash = max(cash, hold + price). Start with cash = 0, hold = -inf or -price? Actually we can initialize hold = -prices[0] or -inf. But we can do simpler: iterate each price, compute new cash and hold. So produce virtual steps.\n\nWe need to produce a step-by-step pseudocode. Use arrow to denote following steps. Use Decision: to decide update. Provide each step.\n\nWe must ensure to use proper structure with arrows.\n\nWe'll produce:\n\nStart\n→ Step 1: 設定 cash = 0 // 初始現金\n→ Step 2: 設定 hold = -∞ // 初始持股成本為負無限\n→ Step 3: 從頭到尾遍歷 prices // 逐天處理\n    → Decision: 是否需要更新 hold? // 根據今天價格\n        Yes → Step 4: hold = max(hold, cash - price) // 可能以更低價格買進\n        No  →  // 無變動\n    → Decision: 是否需要更新 cash? // 根據今天價格\n        Yes → Step 5: cash = max(cash, hold + price) // 可能以更高價格賣出\n        No  →  // 無變動\n→ Step 6: 返回 cash // 最大利潤\nEnd\n\nBut need to incorporate nested loops properly. Use arrow indentation. Provide explanation comments. Should use `→` for each step. Decision lines with indentation. Use `Yes →`, `No →`. Provide comments after each line.\n\nLet's format accordingly.\n\nNeed to ensure each line ends with comment after //.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 設定 cash = 0 // 初始化現金為 0，代表未持股\n→ Step 2: 設定 hold = -∞ // 初始化持股成本為負無限，代表尚未買進\n→ Step 3: 從頭到尾遍歷 prices // 逐天處理每個價格\n    → Decision: 是否需要更新 hold? // 判斷今天是否以更低價格買進\n        Yes → Step 4: hold = max(hold, cash - price) // 用今天價格更新持股成本\n        No  → // 無需更新持股成本\n    → Decision: 是否需要更新 cash? // 判斷今天是否以更高價格賣出\n        Yes → Step 5: cash = max(cash, hold + price) // 用今天價格更新現金\n        No  → // 無需更新現金\n→ Step 6: 返回 cash // 最終現金即最大利潤\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def maxProfit(self, prices):\n        \"\"\"Return maximum profit with unlimited transactions.\"\"\"\n        if not prices:\n            return 0\n        profit = 0\n        for i in range(1, len(prices)):\n            if prices[i] > prices[i - 1]:\n                profit += prices[i] - prices[i - 1]\n        return profit\n\ndef parse_input(raw):\n    \"\"\"Parse input like 'prices = [7,1,5,3,6,4]' or just '[7,1,5,3,6,4]'.\"\"\"\n    raw = raw.strip()\n    if '=' in raw:\n        # take part after '='\n        _, list_part = raw.split('=', 1)\n        raw = list_part.strip()\n    # use literal_eval to safely parse the list\n    try:\n        return ast.literal_eval(raw)\n    except Exception:\n        # fallback: try to extract numbers manually\n        nums = []\n        for part in raw.replace('[', '').replace(']', '').split(','):\n            part = part.strip()\n            if part:\n                nums.append(int(part))\n        return nums\n\ndef main():\n    raw_input = sys.stdin.read()\n    prices = parse_input(raw_input)\n    result = Solution().maxProfit(prices)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "prices = [7,1,5,3,6,4]",
          "expected_output": "7",
          "success": true,
          "output": "7"
        },
        {
          "example_index": 1,
          "input": "prices = [1,2,3,4,5]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "prices = [7,6,4,3,1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode214.json",
    "problem_index_in_file": 0,
    "title": "Shortest Palindrome",
    "description_snippet": "You are given a string s. You can convert s to a palindrome by adding characters in front of it.\n\nRe...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code, line by line with explanation, for the problem: given string s, return the shortest palindrome by adding characters in front. Classic: find longest palindromic prefix. Approach: compute longest prefix of s that is palindrome. Equivalent to longest palindrome prefix of s. Then take the suffix after that prefix, reverse it, prepend to s.\n\nWe need virtual code lines. Should include steps: compute prefix length, reverse suffix, build result.\n\nAlso maybe use KMP to find longest palindrome prefix efficiently. But simpler algorithm: use two-pointer to find longest prefix that is palindrome? For shortest palindrome, we need longest palindromic prefix. We can check from end: for i from len-1 down to 0, if s[0:i+1] is palindrome, break. Then add reverse(s[i+1:]) to front.\n\nSimplify: find longest palindromic prefix by scanning. Use reverse and KMP: t = s + \"#\" + reverse(s), compute lps array, the last value gives longest palindromic prefix.\n\nBut we can present virtual code with KMP approach.\n\nWe must output virtual code lines with explanation, using arrow. Use Start, End.\n\nOk. Let's produce:\n\nStart\n→ Step 1: 計算 s 的長度 n // 獲取輸入字串長度\n→ Step 2: 建立反轉字串 rev_s = reverse(s) // 反轉字串\n→ Step 3: 建立串 concat = s + \"#\" + rev_s // 連接原字串、分隔符與反轉字串\n→ Step 4: 初始化 lps 陣列長度 len(concat) // 用於 KMP 前綴函數\n→ Decision: 需要計算 lps? // 判斷是否需要 KMP 前綴函數\n    Yes → Step 5: 迭代 i 從 1 到 len(concat)-1 // 逐字符計算 lps\n        → Step 5a: 設置 length = lps[i-1] // 前一個長度\n        → Decision: 是否有匹配? // 判斷當前字符是否匹配\n            Yes → Step 5b: while length > 0 且 concat[i] ≠ concat[length] → length = lps[length-1] // 復原長度\n            No  → // 跳過\n        → Decision: concat[i] == concat[length]? // 判斷是否匹配\n            Yes → length += 1 // 增長長度\n            No  → // 不變\n        → Step 5c: lps[i] = length // 記錄當前長度\n→ Step 6: 取得 longest_prefix_len = lps[-1] // 最長回文前綴長度\n→ Step 7: 需要前綴的字符 = rev_s[0:n-longest_prefix_len] // 取反轉字串前面部分\n→ Step 8: 結果 = 需要前綴的字符 + s // 拼接前綴和原字串\nEnd\n\nBut we should keep each line with \"虛擬碼步驟\" and explanation. Use arrow symbols for decisions. Should not use actual code. Let's produce with lines:\n\nStart // 程式開始\n\n→ Step 1: n ← length(s) // 取得字串長度\n\n→ Step 2: rev_s ← reverse(s) // 反轉原字串\n\n→ Step 3: concat ← s + \"#\" + rev_s // 組合字串以便 KMP\n\n→ Step 4: lps ← array of zeros with size length(concat) // 初始化前綴函數陣列\n\n→ Decision: 是否需要計算 lps? // KMP 前綴函數計算\n\n    Yes → Step 5: for i from 1 to length(concat)-1 // 逐個字元計算 lps\n\n        → Step 5a: len ← lps[i-1] // 取得上一個長度\n\n        → Decision: concat[i] == concat[len]? // 判斷是否匹配\n\n            Yes → Step 5b: len ← len + 1 // 匹配成功，長度加一\n\n            No  → Step 5c: while len > 0 and concat[i] ≠ concat[len] // 失配時回退\n\n                → Step 5c1: len ← lps[len-1] // 取得較短前綴\n\n            → Decision: concat[i] == concat[len]? // 再次判斷\n\n                Yes → Step 5d: len ← len + 1\n\n                No  → // 不變\n\n        → Step 5e: lps[i] ← len // 記錄當前位置的長度\n\n→ Step 6: longest ← lps[-1] // 最長回文前綴長度\n\n→ Step 7: add_front ← rev_s[0 : n - longest] // 從反轉字串取要加的部分\n\n→ Step 8: result ← add_front + s // 拼接得到最短回文\n\nEnd // 程式結束\n\nWe need to be careful with \"虛擬碼步驟\". Use maybe \"Step\" as description. Each line: \"Step 1: ...\" or \"Decision:\".\n\nWe should ensure arrow format. Each line starts with arrow \"→\" except start and end.\n\nBut earlier example had \"→ Step 1: 輸入使用者數字 // ...\" The arrow goes before \"Step\". For decision, \"Decision: ...\", then indent lines with \"Yes →\" etc.\n\nLet's produce accordingly.\n\nWe need to incorporate indentation with spaces or maybe just plain.\n\nWill produce:\n\nStart // 程式開始執行\n\n→ Step 1: n ← length(s) // 取得輸入字串長度\n\n→ Step 2: rev_s ← reverse(s) // 反轉字串\n\n→ Step 3: concat ← s + \"#\" + rev_s // 建立連接字串供 KMP 使用\n\n→ Step 4: lps ← array of zeros with size length(concat) // 初始化前綴函數陣列\n\n→ Decision: 需要計算前綴函數? // 進行 KMP 前綴函數計算\n\n    Yes → Step 5: for i ← 1 to length(concat)-1 // 逐個字元計算 lps\n\n        → Step 5a: len ← lps[i-1] // 取得上一位置的長度\n\n        → Decision: concat[i] == concat[len]? // 判斷是否匹配\n\n            Yes → Step 5b: len ← len + 1 // 匹配成功，長度加一\n\n            No  → Step 5c: while len > 0 and concat[i] ≠ concat[len] // 失配時回退到更短前綴\n\n                → Step 5c1: len ← lps[len-1] // 更新長度\n\n        → Decision: concat[i] == concat[len]? // 再次判斷是否匹配\n\n            Yes → Step 5d: len ← len + 1\n\n            No  → // 無變化\n\n        → Step 5e: lps[i] ← len // 記錄當前長度\n\n→ Step 6: longest ← lps[-1] // 獲取最長回文前綴長度\n\n→ Step 7: add_front ← rev_s[0 : n - longest] // 從反轉字串取得要加的字符\n\n→ Step 8: result ← add_front + s // 拼接得到最短回文\n\nEnd // 程式執行結束\n\nMake sure no code. Use short explanations. Ok.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: n ← length(s) // 取得輸入字串長度\n→ Step 2: rev_s ← reverse(s) // 反轉字串\n→ Step 3: concat ← s + \"#\" + rev_s // 建立連接字串供 KMP 使用\n→ Step 4: lps ← array of zeros with size length(concat) // 初始化前綴函數陣列\n→ Decision: 需要計算前綴函數? // 進行 KMP 前綴函數計算\n    Yes → Step 5: for i ← 1 to length(concat)-1 // 逐個字元計算 lps\n        → Step 5a: len ← lps[i-1] // 取得上一位置的長度\n        → Decision: concat[i] == concat[len]? // 判斷是否匹配\n            Yes → Step 5b: len ← len + 1 // 匹配成功，長度加一\n            No  → Step 5c: while len > 0 and concat[i] ≠ concat[len] // 失配時回退到更短前綴\n                → Step 5c1: len ← lps[len-1] // 更新長度\n        → Decision: concat[i] == concat[len]? // 再次判斷是否匹配\n            Yes → Step 5d: len ← len + 1\n            No  → // 無變化\n        → Step 5e: lps[i] ← len // 記錄當前長度\n→ Step 6: longest ← lps[-1] // 獲取最長回文前綴長度\n→ Step 7: add_front ← rev_s[0 : n - longest] // 從反轉字串取得要加的字符\n→ Step 8: result ← add_front + s // 拼接得到最短回文\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def shortestPalindrome(self, s: str) -> str:\n        if not s:\n            return \"\"\n        temp = s + \"#\" + s[::-1]\n        lps = [0] * len(temp)\n        for i in range(1, len(temp)):\n            length = lps[i - 1]\n            while length > 0 and temp[i] != temp[length]:\n                length = lps[length - 1]\n            if temp[i] == temp[length]:\n                length += 1\n            lps[i] = length\n        to_add = s[lps[-1]:][::-1]\n        return to_add + s\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # Extract the string inside single or double quotes\n    match = re.search(r\"'([^']*)'\", data)\n    if not match:\n        match = re.search(r'\"([^\"]*)\"', data)\n    s = match.group(1) if match else data\n    sol = Solution()\n    print(sol.shortestPalindrome(s))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = 'aacecaaa'",
          "expected_output": "'aaacecaaa'",
          "success": true,
          "output": "aaacecaaa"
        },
        {
          "example_index": 1,
          "input": "s = 'abcd'",
          "expected_output": "'dcbabcd'",
          "success": true,
          "output": "dcbabcd"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode187.json",
    "problem_index_in_file": 0,
    "title": "Repeated DNA Sequences",
    "description_snippet": "The DNA sequence is composed of a series of nucleotides abbreviated as 'A', 'C', 'G', and 'T'. For e...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to output virtual code lines with explanation. Problem: find repeated 10-letter-long substrings. Approach: sliding window, hash set and result set. We'll produce algorithm: use set seen, set repeated, iterate i from 0 to len(s)-10. substring s[i:i+10]. If in seen, add to repeated; else add to seen. Then output repeated list. Use data structures. Provide start, end. We'll output lines. Each line: \"虛擬碼步驟 // 解釋\". Use arrow and Decision. We'll produce Start, steps. Ensure not actual code, just virtual. Use bullet: Start // ... etc. Use →. Provide maybe Decision? But algorithm simple. But include Decision step for checking if substring seen. So include Decision. Use Yes/No arrow.\n\nLet's produce.\n\nAlso need End.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義空集合 seen 以存放已見到的 10 字母子字串 // 建立已觀察過的集合  \n→ Step 2: 定義空集合 repeated 以存放重複出現的 10 字母子字串 // 建立重複集合  \n→ Step 3: 取得 DNA 字串長度 n // 需要用於迴圈範圍  \n→ Decision: 是否有足夠長度的子字串? // 檢查 n 是否大於等於 10  \n  Yes → Step 4: 循環從 i = 0 到 i = n - 10 // 準備滑動視窗  \n    → Step 5: 提取子字串 current = s[i : i+10] // 取得當前 10 字母序列  \n    → Decision: current 是否已存在於 seen? // 判斷是否已見過  \n      Yes → Step 6: 將 current 加入 repeated // 重複出現，加入結果集合  \n      No → Step 7: 將 current 加入 seen // 新出現，加入已見集合  \n    → End // 迴圈結束  \n  No → Step 8: 重複集合仍為空，無需進一步處理 // 字串長度不足以形成 10 字母序列  \n→ Step 9: 轉換 repeated 集合為列表並返回 // 將結果輸出  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport json\n\nclass Solution:\n    def findRepeatedDnaSequences(self, s: str):\n        \"\"\"\n        找出 DNA 字串中所有長度為 10 且重複出現的子字串。\n        使用兩個集合：seen 儲存已經遇到過的子字串，repeated 儲存已被重複的子字串。\n        \"\"\"\n        seen = set()\n        repeated = set()\n        # 迭代所有可能的長度為 10 的子字串\n        for i in range(len(s) - 9):\n            seq = s[i:i+10]\n            if seq in seen:\n                repeated.add(seq)\n            else:\n                seen.add(seq)\n        return list(repeated)\n\ndef main():\n    \"\"\"\n    主程式入口：從標準輸入讀取資料、處理並輸出結果。\n    \"\"\"\n    # 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n\n    # 從輸入中提取字串 's = 'AAAA...' 的內容\n    # 支援單引號或雙引號包圍的字串\n    match = re.search(r\"['\\\"](.*?)['\\\"]\", raw_input)\n    if not match:\n        # 若找不到符合格式，視為空字串\n        s = \"\"\n    else:\n        s = match.group(1)\n\n    solution = Solution()\n    result = solution.findRepeatedDnaSequences(s)\n\n    # 以 JSON 格式輸出結果，符合範例要求的雙引號風格\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = 'AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT'",
          "expected_output": "[\"AAAAACCCCC\",\"CCCCCAAAAA\"]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"AAAAACCCCC\",\"CCCCCAAAAA\"]'\nGot (Norm):      '[\"CCCCCAAAAA\",\"AAAAACCCCC\"]'\n--- (Raw) ---\nRaw Expected: '[\"AAAAACCCCC\",\"CCCCCAAAAA\"]'\nRaw Got:      '[\"CCCCCAAAAA\", \"AAAAACCCCC\"]'"
        },
        {
          "example_index": 1,
          "input": "s = 'AAAAAAAAAAAAA'",
          "expected_output": "[\"AAAAAAAAAA\"]",
          "success": true,
          "output": "[\"AAAAAAAAAA\"]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode300.json",
    "problem_index_in_file": 0,
    "title": "Longest Increasing Subsequence",
    "description_snippet": "Given an integer array nums, return the length of the longest strictly increasing subsequence....",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the problem: given integer array nums, return length of longest strictly increasing subsequence (LIS). Classic DP O(n^2) or patience sorting O(n log n). Provide virtual code, line by line with comments. Use arrows and decision. Provide step-by-step.\n\nWe need to not output actual code, just virtual code lines.\n\nLet's produce algorithm using patience sorting O(n log n) for LIS length. Outline steps:\n\nStart\n→ Step 1: Initialize empty array tails // tails[i] holds smallest tail of increasing subsequence of length i+1\n→ For each num in nums\n    → Decision: if tails empty or num > last tail?\n        Yes → Append num to tails // extend longest subsequence\n        No → Find position idx in tails where tails[idx-1] < num <= tails[idx] // binary search\n            → Replace tails[idx] with num // update smaller tail\n→ Step end: Return length of tails // LIS length\nEnd\n\nBut must include virtual code with steps like \"Step 1: ...\", \"Decision:\" etc. Use arrow arrow \"→\".\n\nMake sure each line has comment.\n\nAlso maybe include binary search step detail.\n\nWe'll generate lines:\n\nStart\n→ Step 1: tails ← [] // initialise empty array to store tails of LIS\n→ Step 2: For each num in nums // iterate through each element\n    → Decision: tails is empty or num > tails[-1]? // check if can extend\n        Yes → tails.append(num) // extend tails, new longer LIS\n        No → idx ← binarySearch(tails, num) // find first tail >= num\n            → tails[idx] ← num // replace with smaller tail\n→ Step 3: Return len(tails) // length of longest increasing subsequence\nEnd\n\nBut also need to show binary search as separate step? Use Decision inside.\n\nBetter:\n\nStart\n→ Step 1: tails ← [] // initialise tails\n→ For each num in nums\n    → Decision: tails is empty or num > tails[-1]?\n        Yes → tails.append(num) // extend\n        No → idx ← binarySearch(tails, num) // find position\n            → tails[idx] ← num // update\n→ Step 2: Return len(tails) // length\nEnd\n\nBut we need each line as virtual code step + comment. For \"binarySearch\" maybe a step: \"Step X: idx ← binarySearch(tails, num)\" etc.\n\nAlso maybe include details of binarySearch as pseudo.\n\nLet's produce 8-10 lines.\n\nWe must ensure arrow formatting: \"→\". For indentation, use spaces? Example given uses 4 spaces for indented lines. We'll mimic.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: tails ← [] // 初始化空陣列，儲存每一長度的最小尾部  \n→ For each num in nums // 逐個遍歷輸入陣列  \n    → Decision: tails 為空或 num > tails[-1]? // 判斷是否可延長目前已知的最長遞增子序列  \n        Yes → tails.append(num) // 若可延長，將 num 加入尾部，增加子序列長度  \n        No → idx ← binarySearch(tails, num) // 找到第一個不小於 num 的位置  \n            → tails[idx] ← num // 用更小的尾部更新，保留最優解  \n→ Step 2: Return len(tails) // 回傳 tails 的長度，即最長嚴格遞增子序列的長度  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport bisect\nimport ast\n\ndef length_of_lis(nums):\n    \"\"\"\n    回傳 nums 中最長嚴格遞增子序列的長度。\n    使用「耐心排序」法（O(n log n)）。\n    \"\"\"\n    tails = []                       # tails[i] 為長度 i+1 的子序列的最小尾端\n    for num in nums:\n        idx = bisect.bisect_left(tails, num)\n        if idx == len(tails):\n            tails.append(num)         # 可以延長子序列\n        else:\n            tails[idx] = num          # 用更小的尾端替換，保持優化\n    return len(tails)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 讀取輸入，格式類似 \"nums = [10,9,2,5,3,7,101,18]\"\n    # 只取中括號內的內容，再用 literal_eval 轉成列表\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1 or start > end:\n        # 若無中括號，直接 eval 整個輸入\n        nums = ast.literal_eval(data)\n    else:\n        nums = ast.literal_eval(data[start:end+1])\n\n    result = length_of_lis(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [10,9,2,5,3,7,101,18]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "nums = [0,1,0,3,2,3]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "nums = [7,7,7,7,7,7,7]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode46.json",
    "problem_index_in_file": 0,
    "title": "Permutations",
    "description_snippet": "Given an array nums of distinct integers, return all the possible permutations. You can return the a...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm generating all permutations of distinct integers array. Provide each line with explanation comment. Use Start, End, Decision, arrows. Provide virtual code, not real code. Use each step: input array, recursion/backtracking, building permutations. Use arrow and decisions. Each line separate. Provide explanation. Should be clear. Use Chinese.\n\nLet's craft.\n\nStart // start program\n→ Step 1: Initialize result list // create empty list to store permutations\n→ Step 2: Call backtrack with empty path and visited array // start recursion\nBacktrack Function definition:\n    → Decision: 如果 visited 全部 True? // if all numbers used\n        Yes → Append copy of path to result // add current permutation\n        No  → For each index i in range len(nums)\n               → Decision: 如果 visited[i] 為 False? // if number not used\n                   Yes → Mark visited[i] = True // select number\n                      → Append nums[i] to path // add to current permutation\n                      → Call backtrack recursively\n                      → Remove last element from path // backtrack path\n                      → Mark visited[i] = False // backtrack visited\nEnd // finish\n\nWe need to produce lines as in example. Use arrows. Each line: 虛擬碼步驟 + space + // 解釋\n\nLet's produce step by step. Use Start, End. Indentation maybe. But each line must be separate. For nested structure, we can indent with spaces. For decisions, show Yes → etc.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Initialize result list // 建立空列表以儲存所有排列  \n→ Step 2: Call backtrack with empty path 和 visited flags set 為 False // 啟動遞迴搜尋  \nBacktrack // 定義遞迴函式  \n → Decision: 所有 visited 為 True? // 判斷是否已選完所有數字  \n  Yes → Append copy of path to result // 完成一組排列，加入結果  \n  No → For each index i from 0 to len(nums)-1 // 逐一嘗試每個未使用的數字  \n   → Decision: visited[i] 為 False? // 檢查此數字是否已被選取  \n    Yes → Mark visited[i] = True // 標記為已選  \n     → Append nums[i] to path // 加入到目前的排列中  \n     → Call backtrack recursively // 深入下一層遞迴  \n     → Remove last element from path // 回溯，移除已選數字  \n     → Mark visited[i] = False // 回溯，恢復未選狀態  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def permute(self, nums):\n        \"\"\"\n        產生 nums 的所有排列\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        res = []\n\n        def backtrack(start):\n            if start == len(nums):\n                res.append(nums[:])  # 將目前排列加入結果\n                return\n            for i in range(start, len(nums)):\n                nums[start], nums[i] = nums[i], nums[start]  # 交換\n                backtrack(start + 1)\n                nums[start], nums[i] = nums[i], nums[start]  # 回溯交換回原位\n\n        backtrack(0)\n        return res\n\n\ndef main():\n    # 從標準輸入讀取整個內容\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 期望的輸入格式類似 \"nums = [1,2,3]\"\n    if '=' in data:\n        _, expr = data.split('=', 1)\n    else:\n        expr = data\n\n    # 以安全方式解析列表\n    try:\n        nums = ast.literal_eval(expr.strip())\n    except Exception:\n        nums = eval(expr.strip())  # 失敗時使用 eval\n\n    sol = Solution()\n    result = sol.permute(nums)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nGot (Norm):      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nRaw Got:      '[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 2, 1], [3, 1, 2]]'"
        },
        {
          "example_index": 1,
          "input": "nums = [0,1]",
          "expected_output": "[[0,1],[1,0]]",
          "success": true,
          "output": "[[0, 1], [1, 0]]"
        },
        {
          "example_index": 2,
          "input": "nums = [1]",
          "expected_output": "[[1]]",
          "success": true,
          "output": "[[1]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode829.json",
    "problem_index_in_file": 0,
    "title": "Consecutive Numbers Sum",
    "description_snippet": "Given an integer n, return the number of ways you can write n as the sum of consecutive positive int...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line. Problem: count number of ways to express integer n as sum of consecutive positive integers. Standard solution: number of odd divisors of n greater than 1? Actually number of ways equals number of odd divisors of n. Actually representation count equals number of odd factors of n. Or number of ways equal number of ways to write n as k*m with k odd, etc. We'll produce algorithm: iterate k from 1 to sqrt(2n)? But we can do simple: count odd divisors. So steps: compute n, factorization of n to find odd part, count divisors of odd part. We'll produce virtual steps: Start, Input n, Compute odd part m = n while divisible by 2 remove factor 2, then compute divisor count of m by iterating i from 1 to sqrt(m), if i divides m, count increments appropriately, handle squares. Output count. End.\n\nLet's craft virtual code lines accordingly. Use arrows and decisions. We need to ensure each line has \"虛擬碼步驟 [space] // 解釋\". Use Start, End, Decision. Also for loops: we might denote \"→ Loop i from 1 to √m:\". Might use \"Decision:\" lines for conditions.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: 讀入整數 n // 從使用者取得目標數\n→ Step 2: 設變數 oddPart = n // 用於儲存去除所有 2 的因子後的數\n→ Decision: 若 oddPart 為偶數? // 檢查是否仍有 2 的因子\n    Yes → Step 3: oddPart ← oddPart ÷ 2 // 移除一個 2 的因子\n    No  → Continue // 已無 2 的因子，繼續下一步\n→ Decision: 重複上一步直到 oddPart 為奇數? // 迭代去除所有 2\n    Yes → Step 4: oddPart ← oddPart ÷ 2\n    No  → 進行下一步\n→ Step 5: 設計變數 divisorCount = 0 // 用於統計奇數因數個數\n→ Step 6: 設計變數 i = 1 // 循環指標\n→ Decision: i * i ≤ oddPart? // 判斷是否還有未檢查的因子\n    Yes → Decision: oddPart mod i = 0? // 檢查 i 是否為因子\n        Yes → Decision: i = oddPart ÷ i? // i 為平方根\n            Yes → divisorCount ← divisorCount + 1 // 只算一次\n            No  → divisorCount ← divisorCount + 2 // i 與配對因子兩個\n        No  → Continue // i 不是因子，跳過\n    No  → 進行下一步\n→ Step 7: i ← i + 1 // 進行下一個候選因子\n→ Step 8: 輸出 divisorCount // 結果即為表示方式數量\nEnd // 程式執行結束\n\nBut we need \"逐行\" with arrow and decision etc. Also \"Decision:\" lines need indent? In example, they show indentation with spaces. We can emulate same. Use indent like:\n\n→ Decision: 若 oddPart 為偶數? // ...\n    Yes → Step 3: ...\n    No  → ...\n\nSimilarly for loops.\n\nLet's produce final. Use consistent \"Step\" numbering. Might include \"Loop\" lines? The spec didn't mention loop syntax but we can use Decision to mimic loop. Provide steps.\n\nWe need to ensure each line ends with \"// 解釋\". Provide short explanation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀入整數 n // 從使用者取得目標數  \n→ Step 2: 設定變數 oddPart = n // 用於儲存去除所有 2 的因子後的數  \n→ Decision: 若 oddPart 為偶數? // 檢查是否仍有 2 的因子  \n    Yes → Step 3: oddPart ← oddPart ÷ 2 // 移除一個 2 的因子  \n    No  → Continue // 已無 2 的因子，繼續下一步  \n→ Decision: 還有 2 的因子嗎? // 迭代去除所有 2  \n    Yes → Step 4: oddPart ← oddPart ÷ 2  \n    No  → Continue  \n→ Step 5: 設定變數 divisorCount = 0 // 用於統計 oddPart 的因數個數  \n→ Step 6: 設定變數 i = 1 // 循環指標  \n→ Decision: i × i ≤ oddPart? // 判斷是否還有未檢查的因子  \n    Yes → Decision: oddPart mod i = 0? // 檢查 i 是否為因子  \n        Yes → Decision: i = oddPart ÷ i? // i 為平方根（配對因子相同）  \n            Yes → divisorCount ← divisorCount + 1 // 只算一次  \n            No  → divisorCount ← divisorCount + 2 // i 與配對因子各算一次  \n        No  → Continue // i 不是因子，跳過  \n    No  → 進行下一步  \n→ Step 7: i ← i + 1 // 進行下一個候選因子  \n→ Step 8: 輸出 divisorCount // 結果即為 n 以連續正整數相加的表示方式數量  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef count_consecutive_sums(n: int) -> int:\n    \"\"\"\n    Count the number of ways to express n as a sum of consecutive positive integers.\n    Equivalent to the number of odd divisors of n.\n    \"\"\"\n    # Remove all factors of 2 to obtain the odd part of n\n    odd_part = n\n    while odd_part % 2 == 0:\n        odd_part //= 2\n\n    # Count divisors of the odd part\n    divisor_count = 1\n    i = 3\n    while i * i <= odd_part:\n        exp = 0\n        while odd_part % i == 0:\n            odd_part //= i\n            exp += 1\n        if exp:\n            divisor_count *= (exp + 1)\n        i += 2\n\n    # If a prime factor larger than sqrt remains\n    if odd_part > 1:\n        divisor_count *= 2\n\n    return divisor_count\n\ndef main():\n    # Read all input, extract the integer n\n    data = sys.stdin.read().strip()\n    match = re.search(r'\\d+', data)\n    if not match:\n        return\n    n = int(match.group())\n\n    result = count_consecutive_sums(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 5",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "n = 9",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 2,
          "input": "n = 15",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode202.json",
    "problem_index_in_file": 0,
    "title": "Happy Number",
    "description_snippet": "Write an algorithm to determine if a number n is happy.\n\nA happy number is a number defined by the f...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code line by line, with \"虛擬碼步驟 // 解釋\". Use arrows, decisions. Need to describe algorithm to determine happy number.\n\nWe'll write steps: Start, define function IsHappy(n), maybe use a set to store seen numbers to detect cycle. Steps: Compute sum of squares of digits; check if equals 1; if seen before => false; else continue. We'll produce pseudocode lines.\n\nEnsure each line has arrow or structure.\n\nLet's design:\n\nStart\n→ Step 1: 定義函式 IsHappy(n) // 建立判斷是否快樂數的函式\n→ Step 2: 創建空集合 seen // 用於儲存已出現的數字，偵測循環\n→ Decision: 如果 n 為 1? // 若初始即為 1，直接回傳 true\n    Yes → Step 3: Return true // 初始即快樂數\n    No  → Step 4: While True // 開始迴圈處理\n→ Step 5: 計算 sum = 0 // 初始化當前數字各位平方和\n→ Step 6: 對每個 digit in n 的位數 // 逐位處理\n    → Step 7: sum += digit^2 // 加入平方\n→ Step 8: n = sum // 更新 n 為平方和\n→ Decision: 如果 n 為 1? // 判斷是否快樂\n    Yes → Step 9: Return true // 成功達到 1\n    No  → Decision: n 在 seen? // 判斷是否已出現\n        Yes → Step 10: Return false // 出現循環，非快樂\n        No  → Step 11: seen.add(n) // 記錄新數字\n→ End // 迴圈結束\n\nWe need to include arrow notation, indentation. Use \"Decision:\" etc. Use \"→\" for steps.\n\nWe must maintain line formatting: each line is separate. Provide explanation after //.\n\nWe must not output actual code. Just virtual steps.\n\nOk. Let's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義函式 IsHappy(n) // 建立判斷是否快樂數的函式  \n→ Step 2: 創建空集合 seen // 用於儲存已出現的數字，偵測循環  \n→ Decision: 如果 n 為 1? // 若初始即為 1，直接回傳 true  \n    Yes → Step 3: Return true // 初始即快樂數  \n    No  → Step 4: While True // 開始迴圈處理  \n→ Step 5: 計算 sum = 0 // 初始化當前數字各位平方和  \n→ Step 6: 對每個 digit in n 的位數 // 逐位處理  \n    → Step 7: sum += digit^2 // 加入平方  \n→ Step 8: n = sum // 更新 n 為平方和  \n→ Decision: 如果 n 為 1? // 判斷是否快樂  \n    Yes → Step 9: Return true // 成功達到 1  \n    No  → Decision: n 在 seen? // 判斷是否已出現  \n        Yes → Step 10: Return false // 出現循環，非快樂  \n        No  → Step 11: seen.add(n) // 記錄新數字  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def isHappy(self, n: int) -> bool:\n        def get_next(number: int) -> int:\n            total = 0\n            while number > 0:\n                digit = number % 10\n                total += digit * digit\n                number //= 10\n            return total\n\n        seen = set()\n        while n != 1 and n not in seen:\n            seen.add(n)\n            n = get_next(n)\n        return n == 1\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    if '=' in data:\n        try:\n            n_str = data.split('=')[1]\n            n = int(n_str.strip())\n        except ValueError:\n            # fallback if parsing fails\n            n = int(data.strip())\n    else:\n        n = int(data.strip())\n    sol = Solution()\n    result = sol.isHappy(n)\n    print(str(result).lower())",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 19",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode189.json",
    "problem_index_in_file": 0,
    "title": "Rotate Array",
    "description_snippet": "Given an integer array nums, rotate the array to the right by k steps, where k is non-negative....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce step-by-step pseudocode for rotating array right by k steps. Use virtual code with arrow. Use Start End Decision. Also need to compute k = k % len to reduce steps. Steps: find n, adjust k, reverse entire array, reverse first k, reverse rest. Provide explanation each line.\n\nWe need to produce each line: \"虛擬碼步驟 // 解釋\". Include arrow lines. Use Start, End. Use Decision: if k==0? etc. We'll produce:\n\nStart\n→ Step 1: Set n = length(nums) // get array length\n→ Step 2: Set k = k mod n // normalize steps\n→ Decision: If k == 0? // no rotation needed\n    Yes → End // end\n    No  → Step 3: Reverse entire array // reverse all elements\n→ Step 4: Reverse first k elements // bring first part to correct order\n→ Step 5: Reverse elements from k to n-1 // reverse remaining part\nEnd\n\nAdd explanations. Let's produce.\n\nAlso we might need to check n==0? But not necessary. Keep simple.\n\nAdd arrow with spaces: \"→\". For decisions, indent with 4 spaces.\n\nMake sure each line has \"//\".\n\nLet's craft.\n\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Set n = length(nums) // 取得陣列長度\n→ Step 2: Set k = k mod n // 將步數調整至 0~n-1 範圍\n→ Decision: k == 0? // 若步數為 0，則無需旋轉\n    Yes → End // 直接結束\n    No  → Step 3: Reverse(nums, 0, n-1) // 先將整個陣列反轉\n→ Step 4: Reverse(nums, 0, k-1) // 反轉前 k 個元素，恢復正確順序\n→ Step 5: Reverse(nums, k, n-1) // 反轉剩餘的 n-k 個元素\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def rotate(self, nums, k):\n        n = len(nums)\n        if n == 0:\n            return\n        k %= n\n        if k == 0:\n            return\n        # Helper to reverse a portion of the list in place\n        def reverse(arr, start, end):\n            while start < end:\n                arr[start], arr[end] = arr[end], arr[start]\n                start += 1\n                end -= 1\n        # Reverse the whole array\n        reverse(nums, 0, n - 1)\n        # Reverse the first k elements\n        reverse(nums, 0, k - 1)\n        # Reverse the remaining n - k elements\n        reverse(nums, k, n - 1)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Extract the list of numbers\n    list_match = re.search(r'\\[([^\\]]*)\\]', data)\n    if not list_match:\n        raise ValueError(\"Invalid input format: list not found\")\n    nums_str = list_match.group(1).strip()\n    nums = [int(x) for x in nums_str.split(',')] if nums_str else []\n    # Extract k\n    k_match = re.search(r'k\\s*=\\s*(-?\\d+)', data)\n    if not k_match:\n        raise ValueError(\"Invalid input format: k not found\")\n    k = int(k_match.group(1))\n    # Perform rotation\n    Solution().rotate(nums, k)\n    # Print result without spaces after commas\n    print('[' + ','.join(map(str, nums)) + ']')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,4,5,6,7], k = 3",
          "expected_output": "[5,6,7,1,2,3,4]",
          "success": true,
          "output": "[5,6,7,1,2,3,4]"
        },
        {
          "example_index": 1,
          "input": "nums = [-1,-100,3,99], k = 2",
          "expected_output": "[3,99,-1,-100]",
          "success": true,
          "output": "[3,99,-1,-100]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode492.json",
    "problem_index_in_file": 0,
    "title": "Construct the Rectangle",
    "description_snippet": "A web developer needs to know how to design a web page's size. So, given a specific rectangular web ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step. The problem: given area A, find L,W such that L*W = A, L>=W, minimize L-W. Essentially find integer factor pair closest to sqrt. Virtual code steps: Start, Input area, Initialize L=W=1, Loop from sqrt down to 1, find divisor, set W=divisor, L=A/divisor, break. Then output. Provide explanation comments. Use virtual code syntax: Start, → Step: etc. Provide decision branches.\n\nLet's craft steps:\n\nStart\n→ Input: A\n→ Compute: sqrtA = floor(sqrt(A))\n→ Decision: Loop i from sqrtA downto 1? Maybe use while loop.\n\nWe need a loop structure: Decision: If i > 0? Use while. But easier: For i from sqrtA down to 1: Decision: If A mod i == 0? Yes => set W=i, L=A/i, Break loop. No continue.\n\nAfter loop, Return [L,W].\n\nAdd End.\n\nWe need to provide each line with explanation. Use arrow \"→\" for sequential steps. Use \"Decision:\" for if conditions. Use \"Yes →\" and \"No →\" for branches.\n\nMake sure each line has code + comment separated by space. Use Chinese comments.\n\nLet's produce lines.\n\nStart // 程式開始執行\n→ Input: A // 取得目標面積\n→ Compute: sqrtA = floor(sqrt(A)) // 計算面積平方根作為起點\n→ Set: i = sqrtA // 從最大可能的寬度開始嘗試\n→ Decision: i > 0? // 檢查迴圈是否還有值\n    Yes → Decision: A mod i == 0? // 判斷 i 是否為 A 的因數\n        Yes → Set: W = i // 找到符合條件的寬度\n        → Set: L = A / i // 計算相對應的長度\n        → Break // 已找到最小差距，結束搜尋\n        No  → Decrement: i = i - 1 // i 不是因數，嘗試更小的寬度\n        → Go to: Decision: i > 0? // 繼續迴圈\n    No  → // i 已經小於等於 0，結束迴圈\n→ Return: [L, W] // 回傳結果陣列\nEnd // 程式執行結束\n\nBut we need to ensure syntax is consistent. For Break we can use \"→ End\" or \"→ Break\". Virtual code maybe use \"→ Break\" as terminator.\n\nWe need to use arrows appropriately.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input: A // 取得目標面積  \n→ Compute: sqrtA = floor(sqrt(A)) // 先算出面積的平方根作為開始點  \n→ Set: i = sqrtA // 從最大的可能寬度開始搜尋  \n→ Decision: i > 0? // 判斷是否還有寬度可嘗試  \n    Yes → Decision: A mod i == 0? // 檢查 i 是否是 A 的因數  \n        Yes → Set: W = i // 找到符合條件的寬度  \n        → Set: L = A / i // 由面積算出相對應的長度  \n        → Break // 找到最小差距，結束搜尋  \n        No  → Set: i = i - 1 // i 不是因數，嘗試更小的寬度  \n        → Go to: Decision: i > 0? // 繼續檢查下一個寬度  \n    No  → // i 已經小於等於 0，結束迴圈  \n→ Return: [L, W] // 回傳長度與寬度的陣列  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport math\nimport re\n\nclass Solution:\n    def constructRectangle(self, area: int):\n        \"\"\"Find L and W such that L*W=area, L>=W, and L-W is minimal.\"\"\"\n        w = int(math.isqrt(area))          # start from floor(sqrt(area))\n        while area % w != 0:                # find the largest divisor <= sqrt(area)\n            w -= 1\n        return [area // w, w]              # [L, W]\n\ndef main():\n    data = sys.stdin.read()\n    # Extract the integer value from the input (handles formats like \"area = 4\")\n    match = re.search(r'(\\d+)', data)\n    if not match:\n        return\n    area = int(match.group(1))\n\n    sol = Solution()\n    L, W = sol.constructRectangle(area)\n    # Output without spaces after comma to match the required format\n    print(f'[{L},{W}]')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "area = 4",
          "expected_output": "[2,2]",
          "success": true,
          "output": "[2,2]"
        },
        {
          "example_index": 1,
          "input": "area = 37",
          "expected_output": "[37,1]",
          "success": true,
          "output": "[37,1]"
        },
        {
          "example_index": 2,
          "input": "area = 122122",
          "expected_output": "[427,286]",
          "success": true,
          "output": "[427,286]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode383.json",
    "problem_index_in_file": 0,
    "title": "Ransom Note",
    "description_snippet": "Given two strings ransomNote and magazine, return true if ransomNote can be constructed by using the...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps with explanation, no actual code. The problem: Given ransomNote and magazine, determine if ransomNote can be constructed from magazine letters, each letter used once. Classic. Steps: Start, count letters in magazine, iterate ransomNote letters, check counts, decrement, if any missing return false, else true, End. We'll produce steps.\n\nWe need to use arrows, Start, Decision. We'll structure.\n\nExample:\n\nStart\n→ Step 1: Initialize frequency map for magazine letters\n→ Step 2: Iterate over each character in magazine and update frequency map\n→ Step 3: Iterate over each character in ransomNote\n    → Decision: Is current character present in frequency map with count > 0?\n        Yes → Step 4: Decrement the count for that character\n        No  → Step 5: Return false // 缺少字母\n→ Step 6: Return true // 所有字母都可用\nEnd\n\nBut we need to provide each line with explanation, and use arrows. The example used `→` before each step. We should also use `Decision:` line with indentation. Each decision line has Yes and No. For the decision, we can indent. The explanation must come after `//`. Use Chinese.\n\nWe must not produce actual code. Just virtual steps. So we can write like:\n\nStart // 程式開始執行\n→ Step 1: 建立空的字頻表 // 用於儲存雜誌中每個字母的出現次數\n→ Step 2: 遍歷雜誌字串，對每個字母更新頻率表 // 统计每个字母出现的次数\n→ Step 3: 遍歷要寫的字串，對每個字母進行檢查\n    → Decision: 該字母在頻率表中且數量 > 0? // 判断是否还有可用的该字母\n        Yes → Step 4: 把頻率表中該字母的數量減 1 // 用掉一個字母\n        No  → Step 5: 返回 false // 缺少字母，無法拼寫\n→ Step 6: 返回 true // 所有字母都有足夠的數量\nEnd // 程式執行結束\n\nWe should ensure each line ends with `// explanation`. For indented lines maybe maintain arrow and indent. The example uses indentation for Decision and Yes/No. We'll mimic.\n\nMake sure each line includes \"虛擬碼步驟\" and explanation after //.\n\nThus final output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立空的字頻表 // 用於儲存雜誌中每個字母的出現次數\n→ Step 2: 遍歷雜誌字串，對每個字母更新頻率表 // 統計每個字母出現的次數\n→ Step 3: 遍歷要寫的字串，對每個字母進行檢查\n    → Decision: 該字母在頻率表中且數量 > 0? // 判斷雜誌中是否還有可用的該字母\n        Yes → Step 4: 把頻率表中該字母的數量減 1 // 用掉一個字母\n        No  → Step 5: 返回 false // 缺少字母，無法拼寫\n→ Step 6: 返回 true // 所有字母都有足夠的數量\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport collections\n\nclass Solution:\n    def canConstruct(self, ransomNote: str, magazine: str) -> bool:\n        # 計算 ransomNote 與 magazine 中每個字母的出現次數\n        ransom_count = collections.Counter(ransomNote)\n        magazine_count = collections.Counter(magazine)\n        # 檢查 ransomNote 每個字母是否在 magazine 中足夠\n        for char, cnt in ransom_count.items():\n            if cnt > magazine_count.get(char, 0):\n                return False\n        return True\n\ndef main() -> None:\n    # 讀取整個標準輸入\n    data = sys.stdin.read()\n    if not data.strip():\n        return\n\n    # 從輸入中提取雙引號內的字串\n    parts = re.findall(r'\"([^\"]*)\"', data)\n    if len(parts) >= 2:\n        ransomNote, magazine = parts[0], parts[1]\n    else:\n        # 若輸入格式不符合，做簡易解析\n        parts = [p.strip() for p in data.replace('\\n', ' ').split(',')]\n        ransomNote = parts[0].split('=')[1].strip().strip('\"')\n        magazine = parts[1].split('=')[1].strip().strip('\"')\n\n    sol = Solution()\n    result = sol.canConstruct(ransomNote, magazine)\n    # 輸出結果，使用小寫字母\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "ransomNote = \"a\", magazine = \"b\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 1,
          "input": "ransomNote = \"aa\", magazine = \"ab\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "ransomNote = \"aa\", magazine = \"aab\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode376.json",
    "problem_index_in_file": 0,
    "title": "Wiggle Subsequence",
    "description_snippet": "A wiggle sequence is a sequence where the differences between successive numbers strictly alternate ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm: longest wiggle subsequence length. Classic DP O(n) using up/down arrays. Steps: read array, if length <2 return n, init up=1 down=1. Iterate i from1 to n-1: diff = nums[i]-nums[i-1]; if diff>0 up=down+1; else if diff<0 down=up+1. At end return max(up,down). Provide virtual code with arrows, decision points.\n\nWe need each line of virtual code followed by comment.\n\nLet's craft:\n\nStart // start\n→ Step 1: 輸入 nums // read input array\n→ Decision: nums 長度 < 2? // check trivial case\n    Yes → Step 2: 回傳 nums 長度 // return length\n    No  → Step 3: 初始化 up = 1, down = 1 // start lengths\n→ For i = 1 到 nums 長度 - 1: // iterate\n    → Step 4: 計算 diff = nums[i] - nums[i-1] // difference\n    → Decision: diff > 0? // positive difference\n        Yes → Step 5: up = down + 1 // increase up\n        No  → Decision: diff < 0? // negative\n            Yes → Step 6: down = up + 1 // increase down\n            No  → Step 7: // diff == 0，無變化，跳過\n→ Step 8: 回傳 max(up, down) // 最長 wiggle 長度\nEnd // 結束\n\nNeed arrow formatting with → and Decision: Yes → etc. Provide comments after //.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入 nums // 取得整數陣列  \n→ Decision: 如果 nums 長度 < 2? // 判斷是否為簡單情況  \n  Yes → Step 2: 回傳 nums 長度 // 一個或兩個不同元素時即為 Wiggle  \n  No  → Step 3: 初始化 up = 1, down = 1 // 上升序列長度與下降序列長度皆為 1  \n→ For i = 1 到 nums 長度 - 1: // 從第二個元素開始遍歷  \n  → Step 4: 計算 diff = nums[i] - nums[i-1] // 當前差值  \n  → Decision: 如果 diff > 0? // 差值為正  \n    Yes → Step 5: up = down + 1 // 上升序列可延伸  \n    No  → Decision: 如果 diff < 0? // 差值為負  \n      Yes → Step 6: down = up + 1 // 下降序列可延伸  \n      No → Step 7: // diff 為 0，忽略不改變 up/down  \n→ Step 8: 回傳 max(up, down) // 最長 Wiggle 子序列長度  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def wiggleMaxLength(self, nums):\n        if not nums:\n            return 0\n        up = down = 1\n        for i in range(1, len(nums)):\n            if nums[i] > nums[i - 1]:\n                up = down + 1\n            elif nums[i] < nums[i - 1]:\n                down = up + 1\n        return max(up, down)\n\ndef parse_input(data: str):\n    # 取出方括號內的數列，如果找不到則直接 eval 整段文字\n    match = re.search(r'\\[.*?\\]', data, re.S)\n    if match:\n        return eval(match.group())\n    try:\n        return eval(data)\n    except Exception:\n        return []\n\nif __name__ == \"__main__\":\n    raw = sys.stdin.read().strip()\n    nums = parse_input(raw)\n    result = Solution().wiggleMaxLength(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,7,4,9,2,5]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "nums = [1,17,5,10,13,15,10,5,16,8]",
          "expected_output": "7",
          "success": true,
          "output": "7"
        },
        {
          "example_index": 2,
          "input": "nums = [1,2,3,4,5,6,7,8,9]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode1249.json",
    "problem_index_in_file": 0,
    "title": "Minimum Remove to Make Valid Parentheses",
    "description_snippet": "Given a string s of '(' , ')' and lowercase English characters.\n\nYour task is to remove the minimum ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines. This is a classic problem: Remove Invalid Parentheses minimal. Approach: use two passes to find left and right removals. Or use stack. Use a count variable. We can first compute left to right count of surplus ')', then right to left count of surplus '('.\n\nAlgorithm:\n\n1. Count = 0\n2. First pass left->right: For each char c:\n   if c == '(' -> count++\n   else if c == ')' -> if count > 0: count-- else mark c as removed\n3. Second pass right->left: Count = 0\n   For each char c reversed:\n     if c == ')' -> count++\n     else if c == '(' -> if count > 0: count-- else mark c as removed\n4. Build result from original string but skipping marked.\n\nWe need virtual code lines. We'll use Start, End, Decision. We'll represent array of booleans to mark removal. But we can use string builder.\n\nLet's produce steps.\n\nWe must output virtual code line by line, each with explanation.\n\nUse arrow `→` to show sequence. Decision with Yes/No.\n\nLet's craft.\n\nNote: we need to \"remove the minimum number of parentheses\" => algorithm ensures minimal removal.\n\nLet's produce lines:\n\nStart\n→ Step 1: Initialize an empty array remove_flags of length s.length, all false // 用於標記哪些字符需要刪除\n→ Step 2: Set balance = 0 // 追蹤左括號的餘額\n→ Step 3: For i from 0 to s.length-1 // 左到右掃描\n   → Decision: 如果 s[i] == '('? // 判斷是否為左括號\n       Yes → balance = balance + 1 // 右括號未匹配，餘額加 1\n       No  → Decision: s[i] == ')'?\n           Yes → Decision: balance > 0?\n               Yes → balance = balance - 1 // 匹配成功，餘額減 1\n               No  → remove_flags[i] = true // 沒有左括號匹配，標記刪除\n           No  → // 其他字元，無操作\n→ Step 4: Set balance = 0 // 重置餘額，用於右到左掃描\n→ Step 5: For i from s.length-1 downto 0 // 右到左掃描\n   → Decision: 如果 s[i] == ')'?\n       Yes → balance = balance + 1 // 追蹤右括號\n       No  → Decision: s[i] == '('?\n           Yes → Decision: balance > 0?\n               Yes → balance = balance - 1 // 匹配成功，餘額減 1\n               No  → remove_flags[i] = true // 沒有右括號匹配，標記刪除\n           No  → // 其他字元，無操作\n→ Step 6: Initialize result as empty string // 儲存最終合法字串\n→ Step 7: For i from 0 to s.length-1\n   → Decision: remove_flags[i]?\n       Yes → // 跳過此字元\n       No  → Append s[i] to result // 保留合法字元\n→ End // 完成輸出合法字串\n\nWe need to keep each line separate, with arrow etc.\n\nBe careful about indentation: we need each line start with arrow `→` or `Start`. Indentation of nested blocks should be with spaces? In example, they used indent for nested Decision lines. We'll follow same style: Indent 4 spaces for nested lines? Example: They had indentation like:\n\n→ Decision: 如果數字大於 0? // ...\n    Yes → Step 2: 輸出 '正數'\n    No  → Decision: 如果數字等於 0?\n\nSo we can indent nested lines with 4 spaces. Use spaces before \"Yes →\" and \"No  →\".\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 remove_flags 為長度 s.length 的布林陣列，全部設為 false // 用於標記哪些字符需要刪除  \n→ Step 2: 設置 balance = 0 // 用於追蹤左括號的餘額  \n→ Step 3: 從左到右掃描 s，索引 i 從 0 到 s.length-1  \n    → Decision: 如果 s[i] == '('? // 判斷是否為左括號  \n        Yes → balance = balance + 1 // 左括號未匹配，餘額加 1  \n        No  → Decision: s[i] == ')'？  \n            Yes → Decision: balance > 0? // 是否有未匹配的左括號  \n                Yes → balance = balance - 1 // 匹配成功，餘額減 1  \n                No  → remove_flags[i] = true // 沒有左括號匹配，標記刪除  \n            No  → // 不是括號，無操作  \n→ Step 4: 設置 balance = 0 // 重置餘額，用於右到左掃描  \n→ Step 5: 從右到左掃描 s，索引 i 從 s.length-1 到 0  \n    → Decision: 如果 s[i] == ')'？ // 判斷是否為右括號  \n        Yes → balance = balance + 1 // 追蹤右括號  \n        No  → Decision: s[i] == '('？  \n            Yes → Decision: balance > 0? // 是否有未匹配的右括號  \n                Yes → balance = balance - 1 // 匹配成功，餘額減 1  \n                No  → remove_flags[i] = true // 沒有右括號匹配，標記刪除  \n            No  → // 不是括號，無操作  \n→ Step 6: 初始化 result 為空字符串 // 用於儲存最終合法字串  \n→ Step 7: 從左到右遍歷 s，索引 i 從 0 到 s.length-1  \n    → Decision: remove_flags[i]？ // 是否需要刪除  \n        Yes → // 跳過此字元  \n        No  → Append s[i] 到 result // 保留合法字元  \nEnd // 程式執行結束，result 為符合要求的合法字符串",
      "generated_code": "import sys\n\nclass Solution:\n    def minRemoveToMakeValid(self, s: str) -> str:\n        \"\"\"\n        移除最少數量的括號，使得字符串合法。\n        使用棧來跟踪未匹配的左括號索引。\n        \"\"\"\n        s_list = list(s)\n        stack = []\n\n        # 第一遍：找出未匹配的右括號\n        for i, ch in enumerate(s_list):\n            if ch == '(':\n                stack.append(i)\n            elif ch == ')':\n                if stack:\n                    stack.pop()\n                else:\n                    s_list[i] = ''  # 直接刪除不匹配的右括號\n\n        # 第二遍：刪除剩餘未匹配的左括號\n        for i in stack:\n            s_list[i] = ''\n\n        return ''.join(s_list)\n\ndef parse_input(raw: str) -> str:\n    \"\"\"\n    從輸入中提取實際的字符串值。\n    支援如下兩種輸入格式：\n        s = \"abc(de)\"\n        abc(de)\n    \"\"\"\n    raw = raw.strip()\n    if '=' in raw:\n        _, rhs = raw.split('=', 1)\n        s = rhs.strip()\n    else:\n        s = raw\n    # 去除外層引號（單引號或雙引號）\n    if (s.startswith('\"') and s.endswith('\"')) or (s.startswith(\"'\") and s.endswith(\"'\")):\n        s = s[1:-1]\n    return s\n\ndef main() -> None:\n    raw_input = sys.stdin.read()\n    s = parse_input(raw_input)\n    solution = Solution()\n    result = solution.minRemoveToMakeValid(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"lee(t(c)o)de)\"",
          "expected_output": "\"lee(t(c)o)de\"",
          "success": true,
          "output": "lee(t(c)o)de"
        },
        {
          "example_index": 1,
          "input": "s = \"a)b(c)d\"",
          "expected_output": "\"ab(c)d\"",
          "success": true,
          "output": "ab(c)d"
        },
        {
          "example_index": 2,
          "input": "s = \"))((\"",
          "expected_output": "\"\"",
          "success": true,
          "output": ""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode239.json",
    "problem_index_in_file": 0,
    "title": "Sliding Window Maximum",
    "description_snippet": "You are given an array of integers nums, there is a sliding window of size k which is moving from th...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for sliding window maximum. Provide step-by-step explanation. Use arrow, Start, End, Decision. Must be in Traditional Chinese. Provide each line: \"虛擬碼步驟 // 解釋\". So for algorithm: Use deque to store indices of useful elements in decreasing order. Iterate through array. For each i, remove indices out of window. Add current index while removing smaller elements. Output max at each window.\n\nWe need to produce pseudo-code line by line. Each line: \"Start // 程式開始執行\" etc. Use arrow lines: \"→ Step ...\". We can structure as:\n\nStart\n→ Initialize deque D // store indices\n→ Initialize result list R // store max values\n→ For i from 0 to n-1:\n   → If deque not empty and D.front <= i-k: // remove out-of-window\n      → Remove front\n   → While deque not empty and nums[D.back] <= nums[i]:\n      → Remove back\n   → Append i to D\n   → If i >= k-1:\n      → Append nums[D.front] to R\nEnd // 程式執行結束\n\nAdd explanation after each. Use decision structure? For conditionals we can show Decision lines. Eg Decision: If i >= k-1? etc.\n\nLet's produce final. Use Traditional Chinese comments. Use arrow for lines inside loops? Might use indentation.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Step 1: 定義空的雙端佇列 D // 用來儲存可能成為最大值的索引\n→ Step 2: 定義空的結果陣列 R // 儲存每個滑動視窗的最大值\n→ Step 3: 取得陣列長度 n = nums.length // 方便後續迴圈\n→ Decision: 若 n == 0? // 檢查陣列是否為空\n   Yes → Step 4: 回傳空陣列 // 若為空直接返回\n   No  →\n→ Step 5: 從 0 到 n-1 進行迴圈\n   → For i = 0 … n-1\n       → Decision: D 之首是否離開視窗? // 檢查是否需要移除超出範圍的索引\n           Yes → Step 6: 移除 D 的首元素 // 使索引始終在視窗內\n           No  →\n       → Decision: D 之尾是否對應的值小於等於 nums[i]? // 保持遞減順序\n           While D 之尾值 <= nums[i]\n               → Step 7: 移除 D 的尾元素 // 去除不可能成為最大值的索引\n           // 這個 While 可以用 Decision-Yes/No 迴圈表示\n       → Step 8: 將 i 加入 D 的尾部 // 把當前索引加入佇列\n       → Decision: i >= k-1? // 判斷是否已經形成完整滑動視窗\n           Yes → Step 9: 把 nums[D.首] 加入 R // 取目前視窗最大值\n           No  →\n→ End // 程式執行結束\n\nBut need to follow format precisely: each line must be \"虛擬碼步驟 [space] // 解釋\". Indentation not necessary but we can use nested arrows. Use arrow for each step: \"→ Step ...\". For Decision we need to show arrow lines inside. But to keep simple, produce lines accordingly.\n\nLet's craft final answer.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空的雙端佇列 D // 用來儲存可能成為最大值的索引  \n→ Step 2: 建立空的結果陣列 R // 儲存每個滑動視窗的最大值  \n→ Step 3: 取得陣列長度 n = nums.length // 方便後續迴圈  \n→ Decision: 若 n == 0? // 檢查陣列是否為空  \n  Yes → Step 4: 回傳空陣列 // 若為空直接返回  \n  No →  \n→ Step 5: 進行迴圈 i 從 0 到 n-1  \n  → Decision: D 的首元素索引是否 <= i-k? // 判斷是否已離開視窗  \n   Yes → Step 6: 移除 D 的首元素 // 使索引始終在視窗內  \n   No →  \n  → Decision: D 的尾元素對應值 <= nums[i]? // 保持遞減順序  \n   While D 的尾元素值 <= nums[i]  \n    → Step 7: 移除 D 的尾元素 // 去除不可能成為最大值的索引  \n  → Step 8: 將 i 加入 D 的尾部 // 把當前索引加入佇列  \n  → Decision: i >= k-1? // 判斷是否已形成完整滑動視窗  \n   Yes → Step 9: 把 nums[D.首] 加入 R // 取目前視窗最大值  \n   No →  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import deque\n\nclass Solution:\n    def maxSlidingWindow(self, nums, k):\n        if not nums or k == 0:\n            return []\n        deq = deque()\n        res = []\n        for i, num in enumerate(nums):\n            # 移除離開視窗的索引\n            while deq and deq[0] < i - k + 1:\n                deq.popleft()\n            # 移除小於等於當前值的索引，保持遞減順序\n            while deq and nums[deq[-1]] <= num:\n                deq.pop()\n            deq.append(i)\n            # 當形成完整視窗時，記錄最大值\n            if i >= k - 1:\n                res.append(nums[deq[0]])\n        return res\n\ndef parse_input(text):\n    \"\"\"\n    將輸入文字解析為 (nums, k)。\n    支援兩種格式：\n      1. nums = [1,2,3], k = 2\n      2. 第一行為列表，第二行為 k\n    \"\"\"\n    text = text.strip()\n    # 嘗試匹配格式 1\n    m = re.search(r'nums\\s*=\\s*(\\[[^\\]]*\\])\\s*,\\s*k\\s*=\\s*(\\d+)', text)\n    if m:\n        nums_str, k_str = m.group(1), m.group(2)\n        nums = ast.literal_eval(nums_str)\n        k = int(k_str)\n        return nums, k\n    # 若無匹配，則嘗試格式 2\n    lines = [line.strip() for line in text.splitlines() if line.strip()]\n    if len(lines) >= 2:\n        nums = ast.literal_eval(lines[0])\n        k = int(lines[1])\n        return nums, k\n    raise ValueError(\"無法解析輸入格式\")\n\nif __name__ == \"__main__\":\n    input_text = sys.stdin.read()\n    nums, k = parse_input(input_text)\n    solution = Solution()\n    result = solution.maxSlidingWindow(nums, k)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,3,-1,-3,5,3,6,7], k = 3",
          "expected_output": "[3,3,5,5,6,7]",
          "success": true,
          "output": "[3, 3, 5, 5, 6, 7]"
        },
        {
          "example_index": 1,
          "input": "nums = [1], k = 1",
          "expected_output": "[1]",
          "success": true,
          "output": "[1]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode68.json",
    "problem_index_in_file": 0,
    "title": "Text Justification",
    "description_snippet": "Given an array of strings words and a width maxWidth, format the text such that each line has exactl...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines describing the algorithm for text justification. Must not output actual code. Each line: \"虛擬碼步驟 // 解釋\". Use arrows Start, End, Decision, etc. Must be line by line. Provide step by step for packing words into lines, distributing spaces, handling last line.\n\nWe should produce a structure: Start → Step: 初始化索引 i=0 → Decision: while i < words.length? etc. Then inside gather words until width exceeded, store line words, compute spaces, etc.\n\nWe must follow the format: each line \"虛擬碼步驟 [space] // 解釋\". Use arrow symbols. Eg: \"Start // 程式開始執行\". Then \"→ i ← 0 // 初始化索引\". Actually arrow to step: maybe \"→ i ← 0 // 初始化索引\" but arrow indicates movement? They used \"→ Step 1: 輸入使用者數字\". So we can use \"→ i ← 0 // 初始化索引\". But to be consistent, maybe \"→ i ← 0 // 初始化當前單詞索引\". But we should not output code, only pseudocode. Use simple syntax.\n\nWe need to include decisions: \"Decision: i < words.length? // 是否還有單詞未處理\". Then inside loop: gather words until adding next would exceed maxWidth. Then decide if line is last line: maybe check if next index == words.length.\n\nThen build line string: If last line or line has only one word, left-justify: join words with single space, pad remaining spaces at end. Else distribute spaces: compute total spaces needed, number of gaps = words_in_line-1, base space each = total_spaces/gaps, left over = total_spaces%gaps. Then construct string: for each gap, add base+1 if left over>0 else base. left over decrement.\n\nWe need to output each step line.\n\nWe need to produce step-by-step pseudocode. Let's draft.\n\nStart\n→ i ← 0 // 初始化單詞索引\n→ result ← empty list // 儲存每行文字\n→ Decision: i < words.length? // 有未處理單詞嗎\n    Yes → Step: line_start ← i // 記錄本行首單詞索引\n    → line_length ← words[i].length // 本行已用字數\n    → i ← i + 1 // 移動到下一單詞\n    → Decision: i < words.length AND line_length + 1 + words[i].length ≤ maxWidth? // 是否可再加入單詞\n        Yes → line_length ← line_length + 1 + words[i].length // 加入單詞並計算空格\n        → i ← i + 1 // 移動\n        → Decision: (同上) // 重複\n        ...\n    No → // 現在已找出本行單詞範圍\n        → line_words ← words[line_start … i-1] // 抽取本行單詞\n        → Decision: i == words.length? // 是否為最後一行\n            Yes → // 最後一行左對齊\n                → line ← join(line_words, \" \") // 用單一空格連接\n                → line ← line + repeat(\" \", maxWidth - length(line)) // 右填充空格\n                → append(result, line) // 加入結果\n                → End // 所有單詞已處理\n            No → // 非最後一行，完全左右對齊\n                → gaps ← length(line_words) - 1 // 空格槽數\n                → total_space ← maxWidth - sum(length of each word in line_words) // 總空格數\n                → base_space ← total_space // gaps // 基本空格數\n                → extra ← total_space % gaps // 余數空格\n                → line ← \"\" // 初始化行字串\n                → for each word_index in 0 to gaps-1\n                    → line ← line + line_words[word_index] // 加字\n                    → line ← line + repeat(\" \", base_space + (extra > 0 ? 1 : 0)) // 加空格\n                    → if extra > 0 then extra ← extra - 1 // 余數減1\n                → line ← line + line_words[last] // 加最後一個單詞\n                → append(result, line) // 加入結果\n        // 循環回到決策判斷\n        → Decision: i < words.length? // 有剩餘單詞嗎\n            Yes → // 重新開始下一行\n            No → End\n\nBut we must output each step line; not group too many. Use arrows for loops.\n\nBetter: Represent loop with Decision then Yes branch then back to start. But each line must show step. Let's structure:\n\nStart\n→ i ← 0 // 初始化索引\n→ result ← [] // 儲存結果\n→ Decision: i < words.length? // 是否還有單詞\n    Yes → line_start ← i // 本行起始索引\n    → line_len ← length(words[i]) // 本行已用長度\n    → i ← i + 1 // 移至下一單詞\n    → Decision: i < words.length AND line_len + 1 + length(words[i]) ≤ maxWidth? // 是否能再加單詞\n        Yes → line_len ← line_len + 1 + length(words[i]) // 加入單詞長度與空格\n        → i ← i + 1 // 移動\n        → Decision: (同上) // 迴圈\n        No → // 本行單詞已決定\n            → line_words ← words[line_start : i] // 取本行單詞\n            → Decision: i == words.length? // 是否為最後一行\n                Yes → // 最後一行左對齊\n                    → line ← join(line_words, \" \") // 以單空格連接\n                    → line ← line + repeat(\" \", maxWidth - length(line)) // 右填空\n                    → append(result, line) // 加入結果\n                    → End // 处理完毕\n                No → // 非最後一行，左右對齊\n                    → gaps ← length(line_words) - 1 // 空格槽數\n                    → total_space ← maxWidth - sum(length of each word) // 總空格數\n                    → base_space ← total_space / gaps // 每槽基礎空格\n                    → extra ← total_space % gaps // 余數空格\n                    → line ← \"\" // 初始化行\n                    → for idx from 0 to gaps-1\n                        → line ← line + line_words[idx] // 加單詞\n                        → line ← line + repeat(\" \", base_space + (extra > 0 ? 1 : 0)) // 加空格\n                        → if extra > 0 then extra ← extra - 1 // 減少余數\n                    → line ← line + line_words[gaps] // 加最後一單詞\n                    → append(result, line) // 加入結果\n            // 回到決策判斷\n            → Decision: i < words.length? // 是否還有剩餘單詞\n                Yes → // 重新開始新行\n                No → End\n\nBut we need to avoid actual code. The pseudocode arrow lines must be consistent. Use \"→\" for each step. For decisions, use \"Decision:\" etc. Use proper indent. Also each line with explanation comment.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ i ← 0 // 初始化單詞索引  \n→ result ← [] // 用於儲存最終排好版的每一行文字  \n→ Decision: i < words.length? // 是否還有未處理的單詞  \n Yes → line_start ← i // 本行起始的單詞索引  \n  → line_len ← length(words[i]) // 本行已使用的字元數（不含多餘空格）  \n  → i ← i + 1 // 移動到下一個單詞  \n  → Decision: i < words.length AND line_len + 1 + length(words[i]) ≤ maxWidth? // 能否把下一個單詞加入本行  \n   Yes → line_len ← line_len + 1 + length(words[i]) // 加入單詞並預留一個空格  \n   → i ← i + 1 // 移動到下一個單詞  \n   → Decision: i < words.length AND line_len + 1 + length(words[i]) ≤ maxWidth? // 重複判斷是否能再加入  \n    … // 迴圈繼續直到無法再加入  \n   No → // 本行已決定完成  \n    → line_words ← words[line_start : i] // 把本行的所有單詞抽取出來  \n    → Decision: i == words.length? // 是否為最後一行  \n     Yes → // 最後一行左對齊  \n      → line ← join(line_words, \" \") // 用單一空格連接單詞  \n      → line ← line + repeat(\" \", maxWidth - length(line)) // 右側填充空格至 maxWidth  \n      → append(result, line) // 加入結果  \n      → End // 所有單詞已處理完畢  \n     No → // 非最後一行，進行左右對齊  \n      → gaps ← length(line_words) - 1 // 空格槽數（單詞之間）  \n      → total_space ← maxWidth - sum(length of each word in line_words) // 必須填充的總空格數  \n      → base_space ← total_space / gaps // 每個槽的基礎空格數（向下取整）  \n      → extra ← total_space % gaps // 余數空格，從左側開始分配  \n      → line ← \"\" // 初始化行字串  \n      → for idx from 0 to gaps-1  \n       → line ← line + line_words[idx] // 加單詞  \n       → line ← line + repeat(\" \", base_space + (extra > 0 ? 1 : 0)) // 加空格，左側多加一個若有余數  \n       → if extra > 0 then extra ← extra - 1 // 余數減一  \n      → line ← line + line_words[gaps] // 加最後一個單詞  \n      → append(result, line) // 加入結果  \n      // 從此結束本行處理，返回外層判斷  \n      → Decision: i < words.length? // 是否還有剩餘單詞  \n       Yes → // 重新開始下一行的處理  \n       No → End // 沒有剩餘單詞，程式結束  \n   No → End // 主循環結束（此行已處理完成）",
      "generated_code": "import sys\nimport json\nimport ast\nimport re\n\nclass Solution:\n    def fullJustify(self, words, maxWidth):\n        res = []\n        i = 0\n        n = len(words)\n\n        while i < n:\n            line_len = len(words[i])\n            j = i + 1\n            while j < n and line_len + 1 + len(words[j]) <= maxWidth:\n                line_len += 1 + len(words[j])\n                j += 1\n\n            line_words = words[i:j]\n            spaces_needed = maxWidth - sum(len(w) for w in line_words)\n            gaps = len(line_words) - 1\n\n            if j == n or gaps == 0:\n                # last line or a single word: left‑justified\n                line = ' '.join(line_words) + ' ' * (maxWidth - line_len)\n            else:\n                # fully justified\n                space, extra = divmod(spaces_needed, gaps)\n                line = ''\n                for k in range(gaps):\n                    line += line_words[k] + ' ' * (space + (1 if k < extra else 0))\n                line += line_words[-1]\n\n            res.append(line)\n            i = j\n\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    if not data.strip():\n        sys.exit(0)\n\n    # Extract words list and maxWidth using regular expressions\n    words_match = re.search(r'words\\s*=\\s*(\\[[^\\]]*\\])', data)\n    max_match   = re.search(r'maxWidth\\s*=\\s*(\\d+)', data)\n\n    if words_match and max_match:\n        words = ast.literal_eval(words_match.group(1))\n        maxWidth = int(max_match.group(1))\n    else:\n        # Fallback: try to evaluate the whole input as Python code\n        local_vars = {}\n        exec(data, {}, local_vars)\n        words = local_vars['words']\n        maxWidth = local_vars['maxWidth']\n\n    solution = Solution()\n    result = solution.fullJustify(words, maxWidth)\n    print(json.dumps(result))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"], maxWidth = 16",
          "expected_output": "[\"This    is    an\",\"example  of text\",\"justification.  \"]",
          "success": true,
          "output": "[\"This    is    an\", \"example  of text\", \"justification.  \"]"
        },
        {
          "example_index": 1,
          "input": "words = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"], maxWidth = 16",
          "expected_output": "[\"What   must   be\",\"acknowledgment  \",\"shall be        \"]",
          "success": true,
          "output": "[\"What   must   be\", \"acknowledgment  \", \"shall be        \"]"
        },
        {
          "example_index": 2,
          "input": "words = [\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"], maxWidth = 20",
          "expected_output": "[\"Science  is  what we\",\"understand      well\",\"enough to explain to\",\"a  computer.  Art is\",\"everything  else  we\",\"do                  \"]",
          "success": true,
          "output": "[\"Science  is  what we\", \"understand      well\", \"enough to explain to\", \"a  computer.  Art is\", \"everything  else  we\", \"do                  \"]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode38.json",
    "problem_index_in_file": 0,
    "title": "Count and Say",
    "description_snippet": "The count-and-say sequence is a sequence of digit strings defined by the recursive formula:\n\ncountAn...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm to generate nth count-and-say string. Use Start, End, Decision. Provide explanation comments.\n\nWe must not output actual code. So we produce steps like:\n\nStart\n→ Step 1: Initialize result as \"1\" // base\n→ Decision: If n == 1? // base case\n    Yes → Return result\n    No  → Step 2: Set counter = n-1 // loop count\n→ Loop counter times\n    → Step 3: Initialize empty next string\n    → Step 4: Initialize index = 0\n    → Step 5: While index < length of result\n        → Step 6: Count consecutive same chars\n        → Step 7: Append count and char to next string\n        → Step 8: Update index to next position\n    → Step 9: Set result = next string\n→ Step 10: Return result\nEnd\n\nBut need to follow arrow formatting. For loops and decisions, we can use Decision: etc.\n\nWe also need to use Yes →, No → lines indent.\n\nMake sure each line has comment after //.\n\nLet's craft.\n\nUse Step 1, Step 2 etc.\n\nInclude Decision for loop condition maybe.\n\nPseudo:\n\nStart // 開始\n→ Step 1: result ← \"1\" // 初始值\n→ Decision: 若 n = 1? // 檢查是否為第一項\n    Yes → Step 2: 返回 result // 直接回傳\n    No  → Step 3: count ← n-1 // 需要執行的迭代次數\n→ Decision: 若 count = 0? // 若 n=1 已處理\n    Yes → End // 結束\n    No  → Step 4: 重複 count 次\n        → Step 5: next ← 空字串 // 用來存新一項\n        → Step 6: idx ← 0 // 索引\n        → Step 7: len ← 長度(result)\n        → Decision: idx < len? // 處理每個 run\n            Yes → Step 8: current ← result[idx] // 目前字元\n            → Step 9: cnt ← 1 // 計數\n            → Decision: idx+1 < len AND result[idx+1] = current? // 是否連續\n                Yes → Step 10: cnt ← cnt+1; idx ← idx+1; 回到上一決策\n                No  → Step 11: next ← next + cnt + current // 加入編碼\n                → Step 12: idx ← idx+1 // 移動到下一段\n                → 回到 Decision: idx < len?\n            No  → Step 13: result ← next // 生成下一項\n        → 回到 Step 4: count ← count-1 // 減一\n→ Step 14: 返回 result\nEnd // 結束\n\nBut formatting must be line by line.\n\nWe must use arrows: → and decisions with Yes → No →.\n\nLet's construct clean.\n\nWe can use indentation with tab maybe but not necessary.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: result ← \"1\" // 設定第一項\n→ Decision: 若 n = 1? // 判斷是否已是目標項\n    Yes → Step 2: 返回 result // 回傳第一項\n    No  → Step 3: counter ← n-1 // 需要再產生的項數\n→ Decision: 若 counter = 0? // 若 n=1 已處理\n    Yes → End // 結束程式\n    No  → Step 4: 循環 counter 次 // 開始生成後續項\n        → Step 5: next ← 空字串 // 用來儲存下一項\n        → Step 6: idx ← 0 // 索引\n        → Step 7: len ← 長度(result) // 取得當前項長度\n        → Decision: idx < len? // 處理每個連續區段\n            Yes → Step 8: currentChar ← result[idx] // 取目前字元\n            → Step 9: runCount ← 1 // 初始計數\n            → Decision: idx+1 < len AND result[idx+1] = currentChar? // 是否還有相同字元\n                Yes → Step 10: idx ← idx+1 // 移動到下一個\n                → Step 11: runCount ← runCount+1 // 連續計數加一\n                → 回到 Decision: idx+1 < len AND result[idx+1] = currentChar?\n                No  → Step 12: next ← next + runCount + currentChar // 將編碼加入 next\n                → Step 13: idx ← idx+1 // 跳到下一個不同字元\n                → 回到 Decision: idx < len?\n            No  → Step 14: next ← next + runCount + currentChar // 單一字元編碼\n            → 回到 Decision: idx < len?\n        → Step 15: result ← next // 更新為新生成的項\n        → Step 16: counter ← counter-1 // 減少剩餘迭代次數\n        → 回到 Decision: counter = 0?\n→ Step 17: 返回 result // 回傳最終項\nEnd // 程式執行結束\n\nBut need to keep indentation and arrows. Maybe we need proper indentation for nested decisions.\n\nAlso we must ensure each line has virtual code step followed by comment.\n\nWe must keep the arrow lines for decisions and Yes/No.\n\nLet's refine formatting:\n\n```\nStart // 程式開始執行\n→ Step 1: result ← \"1\" // 初始化為第一項\n→ Decision: 若 n = 1? // 判斷是否已是目標項\n    Yes → Step 2: 返回 result // 直接回傳\n    No  → Step 3: counter ← n-1 // 需要再產生的項數\n→ Decision: 若 counter = 0? // 若 n=1 已處理\n    Yes → End // 結束程式\n    No  → Step 4: 重複 counter 次 // 開始生成後續項\n        → Step 5: next ← \"\" // 用來儲存下一項\n        → Step 6: idx ← 0 // 索引指標\n        → Step 7: len ← 長度(result) // 取得當前項長度\n        → Decision: idx < len? // 處理每個連續區段\n            Yes → Step 8: currentChar ← result[idx] // 取目前字元\n            → Step 9: runCount ← 1 // 初始計數\n            → Decision: idx+1 < len AND result[idx+1] = currentChar? // 是否還有相同字元\n                Yes → Step 10: idx ← idx+1 // 移動到下一個\n                → Step 11: runCount ← runCount+1 // 計數累加\n                → 回到 Decision: idx+1 < len AND result[idx+1] = currentChar?\n                No  → Step 12: next ← next + runCount + currentChar // 加入編碼\n                → Step 13: idx ← idx+1 // 移動至下一段\n                → 回到 Decision: idx < len?\n            No  → Step 14: next ← next + runCount + currentChar // 單一字元編碼\n            → 回到 Decision: idx < len?\n        → Step 15: result ← next // 更新為新生成的項\n        → Step 16: counter ← counter-1 // 減少迭代次數\n        → 回到 Decision: counter = 0?\n→ Step 17: 返回 result // 回傳最終項\nEnd // 程式執行結束\n```\n\nBut we might want to maintain \"→\" before each step; but nested lines have multiple indents. The format is okay.\n\nWe should use \"回到 Decision:\" lines maybe not needed but can keep.\n\nHowever requirement: each line must contain virtual code step + comment. The \"回到 Decision:\" might not be considered a step? Could be a step. But maybe better to use \"→\" before each step and then comment. For return to decision we can just include an arrow and a comment \"回到上一步判斷\". But it's okay.\n\nLet's produce final answer with proper formatting.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: result ← \"1\" // 初始化為第一項\n→ Decision: 若 n = 1? // 判斷是否已是目標項\n    Yes → Step 2: 返回 result // 直接回傳\n    No  → Step 3: counter ← n-1 // 需要再產生的項數\n→ Decision: 若 counter = 0? // 若 n=1 已處理\n    Yes → End // 程式結束\n    No  → Step 4: 重複 counter 次 // 開始生成後續項\n        → Step 5: next ← \"\" // 用來儲存下一項\n        → Step 6: idx ← 0 // 索引指標\n        → Step 7: len ← 長度(result) // 取得當前項長度\n        → Decision: idx < len? // 處理每個連續區段\n            Yes → Step 8: currentChar ← result[idx] // 取目前字元\n            → Step 9: runCount ← 1 // 初始計數\n            → Decision: idx+1 < len AND result[idx+1] = currentChar? // 是否還有相同字元\n                Yes → Step 10: idx ← idx+1 // 移動到下一個\n                → Step 11: runCount ← runCount+1 // 計數累加\n                → 回到 Decision: idx+1 < len AND result[idx+1] = currentChar?\n                No  → Step 12: next ← next + runCount + currentChar // 加入編碼\n                → Step 13: idx ← idx+1 // 移動至下一段\n                → 回到 Decision: idx < len?\n            No  → Step 14: next ← next + runCount + currentChar // 單一字元編碼\n            → 回到 Decision: idx < len?\n        → Step 15: result ← next // 更新為新生成的項\n        → Step 16: counter ← counter-1 // 減少迭代次數\n        → 回到 Decision: counter = 0?\n→ Step 17: 返回 result // 回傳最終項\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\nimport re\n\ndef count_and_say(n: int) -> str:\n    \"\"\"回傳第 n 個 count‑and‑say 字串。\"\"\"\n    if n <= 0:\n        return \"\"\n    result = \"1\"                      # 第一項\n    for _ in range(1, n):             # 從第二項開始產生\n        next_parts = []               # 用於累積下一項\n        count = 1                     # 同一字元的計數\n        for i in range(1, len(result)):\n            if result[i] == result[i - 1]:\n                count += 1\n            else:\n                next_parts.append(str(count))\n                next_parts.append(result[i - 1])\n                count = 1\n        # 加入最後一段\n        next_parts.append(str(count))\n        next_parts.append(result[-1])\n        result = \"\".join(next_parts)\n    return result\n\nif __name__ == \"__main__\":\n    # 讀取所有輸入，搜尋第一個整數作為 n\n    data = sys.stdin.read()\n    match = re.search(r\"\\d+\", data)\n    if match:\n        n = int(match.group())\n        print(count_and_say(n))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 4",
          "expected_output": "\"1211\"",
          "success": true,
          "output": "1211"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "\"1\"",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode287.json",
    "problem_index_in_file": 0,
    "title": "Find the Duplicate Number",
    "description_snippet": "Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need produce virtual code steps with explanations. Problem: find duplicate number in array of n+1 ints 1..n, only one duplicate, no modify array, constant extra space. Classic solution: Floyd's Tortoise and Hare (cycle detection). Virtual steps: Start, initialize slow, fast pointers at first element; loop to find intersection; then find entrance. Provide step lines.\n\nWe should not output real code but virtual code steps. Use arrows. Use decision. Provide explanation after //.\n\nLet's produce:\n\nStart\n→ Step 1: Set slow = nums[0] // initialize slow pointer to first element\n→ Step 2: Set fast = nums[nums[0]] // initialize fast pointer two steps ahead\n→ Decision: while slow != fast? // loop until pointers meet\n    Yes → Step 3: slow = nums[slow] // move slow one step\n         → Step 4: fast = nums[nums[fast]] // move fast two steps\n         → Decision: continue loop? // keep looping\n    No → // pointers have met; intersection found\n→ Step 5: Set finder = nums[0] // initialize finder at start\n→ Decision: while finder != slow? // move both one step\n    Yes → Step 6: finder = nums[finder] // move finder one step\n         → Step 7: slow = nums[slow] // move slow one step\n         → Decision: continue loop\n    No → // pointers meet at duplicate\n→ Step 8: Return finder // duplicate number found\nEnd\n\nAdd explanations. Provide in required format.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: slow ← nums[0] // 初始化慢指標為第一個元素  \n→ Step 2: fast ← nums[ nums[0] ] // 初始化快指標兩步先行  \n→ Decision: slow ≠ fast? // 進入循環，尋找相遇點  \n    Yes → Step 3: slow ← nums[slow] // 慢指標移動一步  \n         → Step 4: fast ← nums[ nums[fast] ] // 快指標移動兩步  \n         → Decision: 繼續循環? // 只要未相遇就繼續  \n    No → // 慢指標與快指標相遇，找到循環交點  \n→ Step 5: finder ← nums[0] // 將尋找指標初始化到陣列開頭  \n→ Decision: finder ≠ slow? // 同時移動兩指標，尋找入口  \n    Yes → Step 6: finder ← nums[finder] // 尋找指標移動一步  \n         → Step 7: slow ← nums[slow] // 慢指標也移動一步  \n         → Decision: 繼續移動? // 直到兩指標相遇  \n    No → // finder 與 slow 相遇於重複數值  \n→ Step 8: Return finder // 回傳重複的數值  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def findDuplicate(self, nums):\n        \"\"\"\n        Floyd's Tortoise and Hare algorithm.\n        \"\"\"\n        # Phase 1: Find intersection point of two runners.\n        slow = fast = nums[0]\n        while True:\n            slow = nums[slow]          # move one step\n            fast = nums[nums[fast]]    # move two steps\n            if slow == fast:\n                break\n\n        # Phase 2: Find the entrance to the cycle (duplicate number).\n        slow = nums[0]\n        while slow != fast:\n            slow = nums[slow]\n            fast = nums[fast]\n\n        return slow\n\nif __name__ == \"__main__\":\n    # Read entire input from stdin\n    data = sys.stdin.read()\n\n    # Extract all integers from the input string\n    numbers = list(map(int, re.findall(r'-?\\d+', data)))\n\n    # If no numbers were found, exit gracefully\n    if not numbers:\n        sys.exit()\n\n    # The first number is part of the array; the rest are array elements\n    nums = numbers\n\n    # Find and print the duplicate number\n    result = Solution().findDuplicate(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,3,4,2,2]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "nums = [3,1,3,4,2]",
          "expected_output": "O3",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): 'O3'\nGot (Norm):      '3'\n--- (Raw) ---\nRaw Expected: 'O3'\nRaw Got:      '3'"
        },
        {
          "example_index": 2,
          "input": "nums = [3,3,3,3,3]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode406.json",
    "problem_index_in_file": 0,
    "title": "Queue Reconstruction by Height",
    "description_snippet": "You are given an array of people, people, which are the attributes of some people in a queue (not ne...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps for reconstructing queue given array of people with [h, k] where k is number of people in front with height >= h. Classic solution: sort by height descending, then insert by k. So we need steps: sort, initialize empty list, for each person in sorted order insert at index k. Then output queue. Provide each step with explanation. Use virtual code style: Start, Decision, etc. Each line: \"虛擬碼步驟 // 解釋\". Ensure each line has a space between. Use arrow \"→\". We'll produce a linear algorithm: Start → Sort people by (h descending, k ascending) // sort key // etc. Then iterate each person, insert into result at index k. Then End. We can include Decision? Not necessary but can. Provide explanation after each line. We'll output only virtual code, no actual code. Use consistent format. Each line: \"虛擬碼步驟 // 解釋\". We'll follow example.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 將 people 按高度 h 降序、若高度相同則 k 升序排序 // 排序為後續插入提供正確順序  \n→ Step 2: 建立空列表 queue = [] // 用於逐步構造最終佇列  \n→ Step 3: 對於排序後的每個 person = [h, k]  \n  → Decision: 如果 queue 為空? // 檢查是否是第一個人  \n   Yes → Step 4: queue ← insert person at index 0 // 第一人直接插入  \n   No  → Step 5: queue ← insert person 在 index k 的位置 // 其前面已經有 k 位高度 ≥ h 的人  \n→ Step 6: 結束迴圈 // 所有人已插入  \nEnd // 程式執行結束，queue 即為重建好的佇列",
      "generated_code": "import sys\n\nclass Solution:\n    def reconstructQueue(self, people):\n        \"\"\"\n        Reconstructs the queue according to the height (h) and the number\n        of people in front who have height >= h (k).\n\n        Strategy:\n        1. Sort people by descending height.\n           If two people have the same height, sort by ascending k.\n        2. Insert each person into the result list at index k.\n           Because we process taller people first, all already placed\n           people are taller or equal, so the index k is correct.\n        \"\"\"\n        # Sort: height descending, k ascending\n        people.sort(key=lambda x: (-x[0], x[1]))\n        result = []\n        for person in people:\n            result.insert(person[1], person)\n        return result\n\ndef main():\n    # Read entire stdin, strip whitespace\n    raw_input = sys.stdin.read().strip()\n\n    if not raw_input:\n        return\n\n    # The input might be like 'people = [[7,0],[4,4],...]'\n    # Extract the list part\n    if '=' in raw_input:\n        _, list_str = raw_input.split('=', 1)\n        list_str = list_str.strip()\n    else:\n        list_str = raw_input\n\n    # Safely evaluate the list string\n    try:\n        people = eval(list_str, {\"__builtins__\": None}, {})\n    except Exception:\n        # If eval fails, exit gracefully\n        print(\"Invalid input\")\n        return\n\n    # Ensure the parsed object is a list of lists\n    if not isinstance(people, list):\n        print(\"Invalid input format\")\n        return\n\n    sol = Solution()\n    queue = sol.reconstructQueue(people)\n\n    # Print the result in Python list format\n    print(queue)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]",
          "expected_output": "[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]",
          "success": true,
          "output": "[[5, 0], [7, 0], [5, 2], [6, 1], [4, 4], [7, 1]]"
        },
        {
          "example_index": 1,
          "input": "people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]",
          "expected_output": "[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]",
          "success": true,
          "output": "[[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode381.json",
    "problem_index_in_file": 0,
    "title": "Insert Delete GetRandom O(1) - Duplicates allowed",
    "description_snippet": "RandomizedCollection is a data structure that contains a collection of numbers, possibly duplicates ...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to output pseudo-code lines with comments in Chinese. The steps: initialization, insert, remove, getRandom. Use Start, End, Decision. Provide step-by-step pseudo-code. Each line includes code and // explanation. Should use arrows. Need to be linear time. We'll present algorithm using vector and hash map value->set of indices. Use list. Steps.\n\nLet's produce pseudo-code for entire class: initialization, insert, remove, getRandom. We'll break into steps.\n\nMake pseudo-code: Start RandomizedCollection // init\n→ Step: Initialize array list, hashmap, counter maybe.\nThen each function with its own steps.\n\nWe'll produce pseudo-code lines as per format. Ensure each line includes code and comment. Use arrow for transitions. Use Decision with Yes → No →. Ensure each line uses arrow or Start/End.\n\nLet's draft.\n...done thinking.\n\nStart RandomizedCollection // 初始化空的 RandomizedCollection\n→ Step 1: Create empty list `vals` to store all elements // 用於儲存所有值，支持隨機存取\n→ Step 2: Create empty map `idx` mapping value → set of indices in `vals` // 方便 O(1) 插入與刪除\n→ Step 3: Initialize random number generator // 用於 getRandom\n\n// ----------------- 插入 (insert) -----------------\nStart insert(val) // 插入一個值\n→ Decision: 如果 val 未在 idx 中? // 檢查是否為新值\n    Yes → Step 4: 在 idx[val] 創建空集合 // 為新值初始化索引集合\n→ Step 5: 將 val 加入 `vals` 的末尾 // O(1) append\n→ Step 6: 取得新索引 `pos = len(vals)-1` // 位置索引\n→ Step 7: 將 pos 加入 idx[val] 的集合 // 更新索引集合\n→ Decision: 如果 val 原本不存在? // 判斷是否首次插入\n    Yes → Step 8: 回傳 true // 新元素成功插入\n    No  → Step 9: 回傳 false // 已存在，僅多餘一次插入\n\n// ----------------- 刪除 (remove) -----------------\nStart remove(val) // 刪除一個值\n→ Decision: 如果 val 不在 idx 或 idx[val] 為空? // 檢查是否存在\n    Yes → Step 10: 回傳 false // 無此值，無法刪除\n    No  → Step 11: 從 idx[val] 的集合取出任一索引 `remove_idx` // 取出待刪除位置\n→ Step 12: 取得 `last_val = vals[-1]` // 取最後一個元素\n→ Step 13: 取 `last_idx = len(vals)-1` // 最後元素索引\n→ Decision: 如果 remove_idx != last_idx? // 是否需要交換\n    Yes → Step 14: 替換 `vals[remove_idx] = last_val` // 交換位置\n    → Step 15: 更新 idx[last_val]：刪除 last_idx，加入 remove_idx // 更新索引集合\n→ Step 16: 刪除 `vals` 的最後一個元素 // O(1) pop\n→ Step 17: 在 idx[val] 的集合中移除 remove_idx // 刪除索引\n→ Decision: idx[val] 是否為空? // 刪除後是否還剩值\n    Yes → Step 18: 刪除 idx[val] // 清除空集合\n→ Step 19: 回傳 true // 刪除成功\n\n// ----------------- 隨機取值 (getRandom) -----------------\nStart getRandom() // 取得隨機元素\n→ Step 20: 產生隨機索引 `r = rand(0, len(vals)-1)` // 隨機選取\n→ Step 21: 回傳 vals[r] // 返回隨機元素\n\nEnd // RandomizedCollection 完整流程結束",
      "generated_code": "import sys\nimport ast\nimport json\nimport random\nimport collections\n\nclass RandomizedCollection:\n    def __init__(self):\n        # 用 list 存儲所有元素，支持隨機存取\n        self.data = []\n        # 用 dict 將每個值映射到它在 data 中的索引集合\n        self.idx_map = collections.defaultdict(set)\n\n    def insert(self, val: int) -> bool:\n        # 把值插到 data 的末尾\n        self.data.append(val)\n        # 把新的索引加入映射\n        self.idx_map[val].add(len(self.data) - 1)\n        # 若此值之前不存在，返回 True；否則返回 False\n        return len(self.idx_map[val]) == 1\n\n    def remove(self, val: int) -> bool:\n        # 若此值不存在或映射集合為空，無法移除\n        if not self.idx_map[val]:\n            return False\n        # 從索引集合取出任意一個要刪除的索引\n        remove_idx = self.idx_map[val].pop()\n        # 取出 data 的最後一個元素\n        last_val = self.data[-1]\n        last_idx = len(self.data) - 1\n        # 若不是把自己移除，就把最後一個元素搬到 remove_idx\n        if remove_idx != last_idx:\n            self.data[remove_idx] = last_val\n            # 更新 last_val 的索引集合\n            self.idx_map[last_val].add(remove_idx)\n            self.idx_map[last_val].discard(last_idx)\n        # 移除最後一個元素\n        self.data.pop()\n        # 若此值的索引集合已空，從映射中刪除該鍵\n        if not self.idx_map[val]:\n            del self.idx_map[val]\n        return True\n\n    def getRandom(self) -> int:\n        # 隨機選取一個索引並返回對應值\n        return random.choice(self.data)\n\ndef parse_input(raw: str):\n    \"\"\"\n    解析輸入，返回兩個列表：operations 與 arguments。\n    支援兩種格式：\n      1. 兩行分開\n      2. 單行，兩個列表以 ',' 分隔\n    \"\"\"\n    raw = raw.strip()\n    if not raw:\n        return [], []\n\n    # 嘗試分離兩個列表\n    # 先檢查是否存在 '],[' 作為分隔\n    if '],[' in raw:\n        parts = raw.split('],[')\n        ops_part = parts[0] + ']'\n        args_part = '[' + parts[1]\n    elif ',' in raw:\n        # 可能是以 '], ' 分隔\n        parts = raw.split('],', 1)\n        ops_part = parts[0] + ']'\n        args_part = parts[1].strip()\n        if not args_part.startswith('['):\n            # 可能沒有完整括號\n            args_part = '[' + args_part\n    else:\n        # 單行沒有分隔符，嘗試逐行\n        lines = raw.splitlines()\n        if len(lines) >= 2:\n            ops_part, args_part = lines[0].strip(), lines[1].strip()\n        else:\n            # 直接作為兩個列表\n            ops_part, args_part = raw, '[]'\n\n    ops = ast.literal_eval(ops_part)\n    args = ast.literal_eval(args_part)\n    return ops, args\n\ndef main():\n    raw_input = sys.stdin.read()\n    ops, args = parse_input(raw_input)\n\n    result = []\n    rc = None\n    for op, arg in zip(ops, args):\n        if op == \"RandomizedCollection\":\n            rc = RandomizedCollection()\n            result.append(None)\n        elif op == \"insert\":\n            res = rc.insert(arg[0])\n            result.append(res)\n        elif op == \"remove\":\n            res = rc.remove(arg[0])\n            result.append(res)\n        elif op == \"getRandom\":\n            res = rc.getRandom()\n            result.append(res)\n        else:\n            # 若遇到未知操作，加入 None\n            result.append(None)\n\n    # 輸出 JSON 格式，符合 LeetCode 的輸出風格\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"RandomizedCollection\", \"insert\", \"insert\", \"insert\", \"getRandom\", \"remove\", \"getRandom\"], [[], [1], [1], [2], [], [1], []]",
          "expected_output": "[null, true, false, true, 2, true, 1]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,false,true,2,true,1]'\nGot (Norm):      '[null,true,false,true,1,true,2]'\n--- (Raw) ---\nRaw Expected: '[null, true, false, true, 2, true, 1]'\nRaw Got:      '[null, true, false, true, 1, true, 2]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode132.json",
    "problem_index_in_file": 0,
    "title": "Palindrome Partitioning II",
    "description_snippet": "Given a string s, partition s such that every substring of the partition is a palindrome. Return the...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code with step-by-step lines and explanation. It's about min cuts for palindrome partitioning. We need to design algorithm: maybe dynamic programming with palindrome table. Virtual code lines with arrows etc. Use Decision, Start, End. Provide steps like compute palindrome table, DP for cuts. Provide explanation. Each line: virtual code step + space + // explanation. Use →. For decision use Yes →, No →. Let's produce. Probably include loops. But it's pseudo, so can be descriptive.\n\nWe need to produce line by line. For clarity, I'll produce steps:\n\nStart\n→ Step 1: Initialize n = length of s\n→ Step 2: Create 2D boolean array isPal[n][n] // to mark palindromes\n→ Decision: For i from 0 to n-1\n    Yes → Loop to fill isPal (nested loops)\nBut maybe use nested loops inside.\n\nI'll use a nested loop structure:\n\n→ Step 3: For i from 0 to n-1: // outer loop for end index\n    → Step 4: For j from 0 to i: // inner loop for start index\n        → Decision: If s[j] == s[i] and (i-j<2 or isPal[j+1][i-1]) ?\n            Yes → Set isPal[j][i] = true\n            No → Set isPal[j][i] = false\n\nThen DP:\n\n→ Step 5: Create array cuts[n] // cuts[i] minimal cuts for s[0..i]\n→ Step 6: For i from 0 to n-1:\n    → Decision: If isPal[0][i]?\n        Yes → cuts[i] = 0 // no cut needed\n        No → Step 7: Set minCut = large\n            → Step 8: For j from 1 to i:\n                → Decision: If isPal[j][i]?\n                    Yes → minCut = min(minCut, cuts[j-1] + 1)\n            → Step 9: cuts[i] = minCut\n\nEnd\n\nReturn cuts[n-1]\n\nWe need to include return.\n\nThus final virtual code lines:\n\nStart // ...\n→ Step 1: n = length(s) // Get string length\n→ Step 2: isPal = 2D array of size n x n, initialized false // Palindrome table\n→ Step 3: For i = 0 to n-1: // end index of substring\n    → Step 4: For j = 0 to i: // start index\n        → Decision: if s[j] == s[i] and (i - j < 2 or isPal[j+1][i-1])?\n            Yes → isPal[j][i] = true\n            No  → isPal[j][i] = false\n→ Step 5: cuts = array size n // Minimum cuts for prefix ending at i\n→ Step 6: For i = 0 to n-1:\n    → Decision: if isPal[0][i]?\n        Yes → cuts[i] = 0 // whole prefix is palindrome\n        No  → Step 7: minCut = INF\n            → Step 8: For j = 1 to i:\n                → Decision: if isPal[j][i]?\n                    Yes → minCut = min(minCut, cuts[j-1] + 1)\n            → Step 9: cuts[i] = minCut\n→ Step 10: return cuts[n-1] // Minimum cuts for entire string\nEnd // 程式執行結束\n\nEnsure each line has virtual code step and explanation. Also include arrows: \"→\". For nested loops, use indentation? But format example shows indentation with spaces before arrow? In example, they used indentation for nested steps: no extra arrow before indentation but indent. We'll follow: lines start with \"→\" and indentation for nested. For decision branches, use \"Decision:\" then Yes → etc. Provide explanation after //. Ensure each line includes virtual code step and explanation.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n = length(s) // 取得輸入字串長度  \n→ Step 2: isPal = 2D boolean array of size n × n, all False // 用來記錄每個子字串是否為回文  \n→ Step 3: For i = 0 to n-1: // i 為子字串的結尾索引  \n    → Step 4: For j = 0 to i: // j 為子字串的起始索引  \n        → Decision: if s[j] == s[i] and (i - j < 2 or isPal[j+1][i-1])? // 判斷 s[j..i] 是否為回文  \n            Yes → isPal[j][i] = True // 是回文  \n            No  → isPal[j][i] = False // 不是回文  \n→ Step 5: cuts = array of size n // cuts[i] 代表 s[0..i] 最小切割數  \n→ Step 6: For i = 0 to n-1: // 逐位計算最小切割  \n    → Decision: if isPal[0][i]? // 整段 s[0..i] 是否已為回文  \n        Yes → cuts[i] = 0 // 無需切割  \n        No  → Step 7: minCut = Infinity // 初始化最小切割值  \n            → Step 8: For j = 1 to i: // 嘗試把 s[0..i] 分成 s[0..j-1] 與 s[j..i]  \n                → Decision: if isPal[j][i]? // s[j..i] 是否為回文  \n                    Yes → minCut = min(minCut, cuts[j-1] + 1) // 若是，更新最小切割  \n            → Step 9: cuts[i] = minCut // 記錄此 i 的最小切割數  \n→ Step 10: return cuts[n-1] // 回傳整個字串所需的最小切割數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef min_cut(s: str) -> int:\n    n = len(s)\n    if n == 0:\n        return 0\n    dp = [0] * n          # dp[i] = minimum cuts for s[0..i]\n    pal = [[False] * n for _ in range(n)]  # pal[j][i] == True iff s[j..i] is a palindrome\n\n    for i in range(n):\n        min_cut = i   # maximum cuts (cut before every character)\n        for j in range(i + 1):\n            # check if s[j..i] is palindrome\n            if s[j] == s[i] and (i - j < 2 or pal[j + 1][i - 1]):\n                pal[j][i] = True\n                if j == 0:                     # whole prefix is palindrome\n                    min_cut = 0\n                else:                          # cut before j\n                    min_cut = min(min_cut, dp[j - 1] + 1)\n        dp[i] = min_cut\n    return dp[-1]\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Extract the string value; handle formats like s = \"aab\" or just aab\n    match = re.search(r'[\"\\'](.*?)[\"\\']', data)\n    s = match.group(1) if match else data.strip()\n    print(min_cut(s))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"aab\"",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "s = \"a\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 2,
          "input": "s = \"ab\"",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode521.json",
    "problem_index_in_file": 0,
    "title": "Longest Uncommon Subsequence I",
    "description_snippet": "Given two strings a and b, return the length of the longest uncommon subsequence between a and b. If...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step. The problem: given two strings a and b, find length of longest uncommon subsequence (LUS). Known solution: If a != b, answer = max(len(a), len(b)). If a == b, answer = -1. That is the known logic.\n\nBut maybe we can also think more generally? But as per typical LeetCode 957, that's the solution. The user wants virtual code.\n\nWe produce steps:\n\nStart\n→ Step 1: Receive strings a, b\n→ Decision: 如果 a 等於 b? // Check if identical\n    Yes → Step 2: 設定 result = -1 // No uncommon subsequence\n    No  → Step 3: 設定 result = max(len(a), len(b)) // Largest string itself is uncommon\n→ Step 4: 回傳 result\nEnd\n\nAdd comments accordingly. Use arrow and decision. Should we include indentation for nested? Use Yes →, No → lines.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入字符串 a 與 b // 取得兩個待比對的字串  \n→ Decision: 如果 a 等於 b? // 判斷兩字串是否完全相同  \n Yes → Step 2: 設定 result = -1 // 若相同，無不相同的子序列  \n No  → Step 3: 設定 result = max(len(a), len(b)) // 兩字串不相同，較長者本身即為最長不相同子序列  \n→ Step 4: 回傳 result // 將計算得到的長度傳回  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def findLUSlength(self, a: str, b: str) -> int:\n        if a == b:\n            return -1\n        return max(len(a), len(b))\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 尝试以逗号分隔输入\n    parts = [p.strip() for p in data.split(',')]\n    if len(parts) >= 2:\n        a = parts[0].strip().strip('\"').strip(\"'\")\n        b = parts[1].strip().strip('\"').strip(\"'\")\n    else:\n        # 以空白字符分隔\n        tokens = data.split()\n        if len(tokens) >= 2:\n            a, b = tokens[0], tokens[1]\n        else:\n            # 仅剩一个字符串，另一个为空\n            a, b = data, \"\"\n\n    sol = Solution()\n    result = sol.findLUSlength(a, b)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "\"aba\", \"cdc\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "\"aaa\", \"bbb\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 2,
          "input": "\"aaa\", \"aaa\"",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode322.json",
    "problem_index_in_file": 0,
    "title": "Coin Change",
    "description_snippet": "You are given an integer array coins representing coins of different denominations and an integer am...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code lines with explanations. Use typical DP for coin change minimal coins. Steps: Start, initialize dp array of size amount+1 with large value (amount+1). dp[0] = 0. For each coin iterate amounts. At end check dp[amount] <= amount then return dp[amount] else -1. Need virtual code steps with arrows, decisions. Use \"Start\", \"End\". Use Decision maybe for final check. Let's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義變數 dp 為長度為 amount+1 的陣列，初始值為 amount+1 // 用於儲存每個金額所需的最少硬幣數，設定為一個大於最大可能值的數字\n→ Step 2: 將 dp[0] 設為 0 // 金額為 0 時不需要硬幣\n→ Step 3: 對於每枚硬幣 coin in coins // 逐一處理每種硬幣面額\n    → Step 4: 對於金額 current 由 coin 到 amount // 只從能夠使用該硬幣的金額開始\n        → Step 5: 計算 newCount = dp[current - coin] + 1 // 若先前金額可達，則加一枚硬幣\n        → Decision: newCount < dp[current]? // 判斷是否為更少硬幣數\n            Yes → Step 6: 將 dp[current] 設為 newCount // 更新為更優解\n            No  → // 保持原有更小值\n→ Decision: dp[amount] <= amount? // 最後判斷金額是否可達\n    Yes → Step 7: 回傳 dp[amount] // 返回最少硬幣數\n    No  → Step 8: 回傳 -1 // 無法組成該金額\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def coinChange(self, coins, amount):\n        # 初始化 dp 陣列，dp[i] 表示湊成金額 i 所需最少硬幣數\n        dp = [amount + 1] * (amount + 1)\n        dp[0] = 0\n        \n        for coin in coins:\n            for x in range(coin, amount + 1):\n                if dp[x - coin] + 1 < dp[x]:\n                    dp[x] = dp[x - coin] + 1\n        \n        return dp[amount] if dp[amount] <= amount else -1\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 解析輸入：格式如 'coins = [1,2,5], amount = 11'\n    pattern = r'coins\\s*=\\s*(\\[.*?\\])\\s*,\\s*amount\\s*=\\s*(-?\\d+)'\n    match = re.search(pattern, data)\n    if not match:\n        # 若輸入格式不同，嘗試直接 eval\n        try:\n            parsed = eval(data)\n            coins, amount = parsed\n        except:\n            print(-1)\n            return\n    else:\n        coins_str, amount_str = match.group(1), match.group(2)\n        coins = eval(coins_str)\n        amount = int(amount_str)\n    \n    solution = Solution()\n    result = solution.coinChange(coins, amount)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "coins = [1,2,5], amount = 11",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "coins = [2], amount = 3",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        },
        {
          "example_index": 2,
          "input": "coins = [1], amount = 0",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode213.json",
    "problem_index_in_file": 0,
    "title": "House Robber II",
    "description_snippet": "You are a professional robber planning to rob houses along a street. Each house has a certain amount...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code for the problem \"House Robber II\" (circular). Provide step-by-step virtual code lines with explanation.\n\nWe must not output actual code, only virtual steps.\n\nWe need to produce algorithm: DP for linear houses. Since circular, we consider two scenarios: exclude first house, include last; exclude last house, include first. Compute max of two.\n\nWe need to describe DP: maintain prev1, prev2. Or use function robLinear.\n\nWe produce Start, then steps.\n\nLet's create virtual code:\n\nStart\n→ Step 1: 設定 nums 為輸入的房屋金額陣列\n→ Decision: 如果 nums 長度為 0? // 檢查陣列是否為空\n    Yes → Step 2: 回傳 0 // 無房屋可盜\n    No  → Decision: 如果 nums 長度為 1? // 只一個房屋\n        Yes → Step 3: 回傳 nums[0] // 只能盜該屋\n        No  → Decision: 如果 nums 長度為 2? // 兩個房屋\n            Yes → Step 4: 回傳 max(nums[0], nums[1]) // 兩屋相鄰，選較大\n            No  → Step 5: 定義函式 RobLinear(start, end) // 用於計算線性陣列\n                → Step 6: prev2 = 0 // 前前一屋的最大金額\n                → Step 7: prev1 = 0 // 前一屋的最大金額\n                → For i from start to end:\n                    → Decision: i == start? // 第一屋\n                        Yes → Step 8: prev1 = nums[i] // 只取此屋\n                        No  → Step 9: curr = max(prev1, prev2 + nums[i]) // 決定是否盜\n                        → Step 10: prev2 = prev1 // 更新 prev2\n                        → Step 11: prev1 = curr // 更新 prev1\n                → Step 12: 回傳 prev1 // 線性陣列的最大金額\n            → Decision: 計算兩種情況\n                → Step 13: max1 = RobLinear(0, n-2) // 不盜最後一屋\n                → Step 14: max2 = RobLinear(1, n-1) // 不盜第一屋\n                → Step 15: 回傳 max(max1, max2) // 兩者取較大\nEnd\n\nNeed to ensure each line with // explanation. Use arrow formatting.\n\nNeed to use 'Start' and 'End'.\n\nAlso we need to adhere to arrow format: →.\n\nFor decision indent: we can use 4 spaces maybe. But sample uses indentation. Use 4 spaces indent.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 nums 為輸入的房屋金額陣列 // 取得所有房屋的金額  \n→ Decision: 如果 nums 長度為 0? // 檢查是否有房屋  \n    Yes → Step 2: 回傳 0 // 無房屋可盜，直接結束  \n    No → Decision: 如果 nums 長度為 1? // 只有一個房屋  \n        Yes → Step 3: 回傳 nums[0] // 只能盜這一間房  \n        No → Decision: 如果 nums 長度為 2? // 兩間相鄰房屋  \n            Yes → Step 4: 回傳 max(nums[0], nums[1]) // 兩屋相鄰，選擇較多金額  \n            No → Step 5: 定義函式 RobLinear(start, end) // 用於計算線性陣列的最大盜金額  \n                → Step 6: prev2 = 0 // 前前一屋的最大金額  \n                → Step 7: prev1 = 0 // 前一屋的最大金額  \n                → For i 從 start 到 end: // 逐屋遍歷  \n                    → Decision: i == start? // 第一個屋  \n                        Yes → Step 8: prev1 = nums[i] // 只取這個屋的金額  \n                        No → Step 9: curr = max(prev1, prev2 + nums[i]) // 決定是否盜此屋  \n                        → Step 10: prev2 = prev1 // 更新 prev2 為上一屋的結果  \n                        → Step 11: prev1 = curr // 更新 prev1 為目前最優結果  \n                    → End  \n                → Step 12: 回傳 prev1 // 線性陣列的最大盜金額  \n            → End  \n            → Decision: 計算兩種情況  \n                → Step 13: max1 = RobLinear(0, n-2) // 不盜最後一屋，處理 0 到 n-2  \n                → Step 14: max2 = RobLinear(1, n-1) // 不盜第一屋，處理 1 到 n-1  \n                → Step 15: 回傳 max(max1, max2) // 兩種情況取較大者  \n            → End  \n            → End  \n            → End  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def rob(self, nums):\n        if not nums:\n            return 0\n        n = len(nums)\n        if n == 1:\n            return nums[0]\n        if n == 2:\n            return max(nums[0], nums[1])\n\n        def rob_linear(houses):\n            prev, curr = 0, 0\n            for num in houses:\n                prev, curr = curr, max(curr, prev + num)\n            return curr\n\n        # 圓形排列的兩種情況：排除第一棟或排除最後一棟\n        return max(rob_linear(nums[:-1]), rob_linear(nums[1:]))\n\ndef parse_input(data: str):\n    data = data.strip()\n    if not data:\n        return []\n    # 支援 \"nums = [..]\" 或直接 \"[..]\" 兩種輸入格式\n    if data.lower().startswith('nums'):\n        parts = data.split('=', 1)\n        if len(parts) == 2:\n            data = parts[1].strip()\n    # 用 ast.literal_eval 解析安全的字面量\n    try:\n        return ast.literal_eval(data)\n    except Exception:\n        # 若解析失敗，返回空列表\n        return []\n\ndef main():\n    raw = sys.stdin.read()\n    nums = parse_input(raw)\n    sol = Solution()\n    result = sol.rob(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,3,2]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3,1]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "nums = [1,2,3]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode402.json",
    "problem_index_in_file": 0,
    "title": "Remove K Digits",
    "description_snippet": "Given string num representing a non-negative integer num, and an integer k, return the smallest poss...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for removing k digits to get smallest possible integer. Provide step by step pseudocode lines with explanation.\n\nWe need to output each line: \"虛擬碼步驟 // 解釋/說明\". Use arrow symbols as requested.\n\nLet's plan algorithm: typical greedy stack approach. Steps:\n\n1. Start.\n2. Read num string, k integer.\n3. Initialize empty stack (list of chars).\n4. Iterate through each digit in num:\n   - While k > 0 and stack not empty and stack[-1] > digit: pop stack, decrement k. (remove larger previous digit)\n   - Push current digit onto stack.\n5. After loop, if k > 0: remove last k digits from stack.\n6. Build result string from stack.\n7. Remove leading zeros: strip leading zeros; if empty, result = \"0\".\n8. Return result.\n9. End.\n\nAdd decision nodes for while loops and if statements.\n\nWe must format each step accordingly. Use Start, End, Decision.\n\nWe also need to show decision: while k > 0 and stack not empty and stack[-1] > digit? Yes/No. If Yes: pop. If No: push digit.\n\nAlso decision after loop: if k > 0? Yes: pop last k digits.\n\nAlso decision: if result string has leading zeros? strip.\n\nWe'll write as lines:\n\nStart // 程式開始執行\n→ Step 1: 取得輸入字符串 num 與整數 k // 從使用者取得數值\n→ Step 2: 初始化空堆疊 stack // 用於保存選擇的數位\n→ Decision: 是否開始遍歷 num? // 準備處理每個數位\n    Yes → Step 3: 對 num 中每個字符 digit 執行循環 // 逐位檢查\n        → Decision: k>0 且 stack 非空 且 stack[-1] > digit? // 是否需要移除較大的前一數位\n            Yes → Step 4: 從 stack 彈出頂部元素; k ← k-1 // 移除不利數位\n            No  → Step 5: 將 digit 推入 stack // 保留此數位\n→ Step 6: 迴圈結束後檢查是否仍有 k>0? // 剩餘要刪除的數位\n    Yes → Step 7: 從 stack 尾部刪除最後 k 個元素 // 逐步減少\n    No  → // 無需額外刪除\n→ Step 8: 將 stack 內容組合成字符串 result // 生成結果\n→ Step 9: 移除 result 前導零 // 取得最小值\n    → Decision: result 為空字符串? // 檢查是否全部為零\n        Yes → result ← \"0\" // 若結果為空則回傳 0\n        No  → // 保持結果\n→ Step 10: 回傳 result // 最終答案\nEnd // 程式執行結束\n\nNeed to ensure proper indentation? They don't specify indentation but use arrow formatting. Use arrows and spaces.\n\nMake sure each line has \"// 解釋\". We already did.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 取得輸入字符串 num 與整數 k // 從使用者取得數值\n→ Step 2: 初始化空堆疊 stack // 用於保存選擇的數位\n→ Decision: 是否開始遍歷 num? // 準備處理每個數位\n    Yes → Step 3: 對 num 中每個字符 digit 執行循環 // 逐位檢查\n        → Decision: k>0 且 stack 非空 且 stack[-1] > digit? // 是否需要移除較大的前一數位\n            Yes → Step 4: 從 stack 彈出頂部元素; k ← k-1 // 移除不利數位\n            No  → Step 5: 將 digit 推入 stack // 保留此數位\n→ Step 6: 迴圈結束後檢查是否仍有 k>0? // 剩餘要刪除的數位\n    Yes → Step 7: 從 stack 尾部刪除最後 k 個元素 // 逐步減少\n    No  → // 無需額外刪除\n→ Step 8: 將 stack 內容組合成字符串 result // 生成結果\n→ Step 9: 移除 result 前導零 // 取得最小值\n    → Decision: result 為空字符串? // 檢查是否全部為零\n        Yes → result ← \"0\" // 若結果為空則回傳 0\n        No  → // 保持結果\n→ Step 10: 回傳 result // 最終答案\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def removeKdigits(self, num: str, k: int) -> str:\n        \"\"\"\n        Use a stack to greedily keep the smallest possible prefix.\n        \"\"\"\n        stack = []\n        for digit in num:\n            # Remove previous larger digits while we still have deletions left.\n            while k > 0 and stack and stack[-1] > digit:\n                stack.pop()\n                k -= 1\n            stack.append(digit)\n\n        # If deletions remain, remove from the end.\n        while k > 0:\n            stack.pop()\n            k -= 1\n\n        # Build result and strip leading zeros.\n        result = ''.join(stack).lstrip('0')\n        return result if result else \"0\"\n\n\ndef parse_input(data: str):\n    \"\"\"\n    Parse the input which may come in two common formats:\n    1.  num = \"12345\", k = 2\n    2.  12345 2\n    \"\"\"\n    # Try the quoted format first\n    num_match = re.search(r'num\\s*=\\s*\"([^\"]+)\"', data)\n    k_match = re.search(r'k\\s*=\\s*(\\d+)', data)\n    if num_match and k_match:\n        num = num_match.group(1)\n        k = int(k_match.group(1))\n        return num, k\n\n    # Fallback to space separated tokens\n    tokens = data.split()\n    if len(tokens) >= 2:\n        num = tokens[0]\n        try:\n            k = int(tokens[1])\n        except ValueError:\n            k = 0\n        return num, k\n\n    # If nothing matches, return empty defaults\n    return \"\", 0\n\n\nif __name__ == \"__main__\":\n    raw_data = sys.stdin.read()\n    num_str, k_val = parse_input(raw_data)\n    sol = Solution()\n    result = sol.removeKdigits(num_str, k_val)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num = \"1432219\", k = 3",
          "expected_output": "\"1219\"",
          "success": true,
          "output": "1219"
        },
        {
          "example_index": 1,
          "input": "num = \"10200\", k = 1",
          "expected_output": "\"200\"",
          "success": true,
          "output": "200"
        },
        {
          "example_index": 2,
          "input": "num = \"10\", k = 2",
          "expected_output": "\"0\"",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode125.json",
    "problem_index_in_file": 0,
    "title": "Valid Palindrome",
    "description_snippet": "A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and remov...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code line by line following specified format. Each line: \"虛擬碼步驟 // 解釋\". Use arrows, Start, End, Decision. Provide code for palindrome with cleaning. Provide step-by-step. Should be in Traditional Chinese. We'll produce lines. Let's design algorithm: Start, input string, clean string: iterate characters, if alphanumeric convert to lowercase, append. Then check palindrome: compare cleaned string with its reverse or two pointers. Use Decision. Provide explanation.\n\nWe must avoid actual code, only virtual steps. Use arrow arrow.\n\nLet's write:\n\nStart // 程式開始執行\n→ Input: s // 取得輸入字串\n→ Step 1: cleaned ← \"\" // 初始化清理後的字串\n→ Decision: For each char c in s? // 逐字遍歷原字串\n    Yes → Step 2: If c is alphanumeric? // 判斷是否為字母或數字\n        Yes → Step 3: cleaned ← cleaned + lowercase(c) // 將小寫字元加入\n        No  → Step 4: Skip // 忽略非字母數字字元\n    No → End of loop // 完成遍歷\n→ Step 5: left ← 0, right ← length(cleaned)-1 // 設定雙指標\n→ Decision: left <= right? // 是否還有未比較的字元\n    Yes → Step 6: If cleaned[left] != cleaned[right]? // 字元是否相同\n        Yes → Step 7: Return False // 不相同即非迴文\n        No  → Step 8: left ← left + 1, right ← right - 1 // 移動指標\n    No  → Step 9: Return True // 所有對比都相同，為迴文\nEnd // 程式執行結束\n\nBut we need to follow format: Use arrow and Decision: etc. Let's format each line accordingly. We must include arrow \"→\" before each step except Start? The example: Start, then arrow to Step 1 etc. We'll keep.\n\nNeed to include Decision: lines with indent. In example they used indentation for nested lines. We'll mimic.\n\nMake sure each line ends with // 解釋. Use Chinese. Provide each step. Let's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input: s // 取得輸入字串  \n→ Step 1: cleaned ← \"\" // 初始化清理後的字串  \n→ Decision: 逐字遍歷原字串 s? // 為了檢查每個字元  \n  Yes → Step 2: 如果 c 是字母或數字? // 判斷是否為合法字符  \n   Yes → Step 3: cleaned ← cleaned + lowercase(c) // 將小寫字元加入清理字串  \n   No  → Step 4: 跳過 // 忽略非字母數字字元  \n  No → End of loop // 完成字串遍歷  \n→ Step 5: left ← 0, right ← length(cleaned)-1 // 設定雙指標  \n→ Decision: left ≤ right? // 是否還有未比較的字元  \n  Yes → Step 6: 如果 cleaned[left] ≠ cleaned[right]? // 比較兩端字元  \n   Yes → Step 7: Return False // 不相同即非迴文，直接回傳 false  \n   No  → Step 8: left ← left + 1, right ← right - 1 // 移動指標繼續比較  \n  No  → Step 9: Return True // 所有對比都相同，為迴文，回傳 true  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def isPalindrome(self, s: str) -> bool:\n        # 只保留字母數字並轉成小寫\n        filtered = [c.lower() for c in s if c.isalnum()]\n        # 判斷是否為迴文\n        return filtered == filtered[::-1]\n\ndef main() -> None:\n    data = sys.stdin.read()\n    # 從輸入中尋找第一個被雙引號包住的字串\n    match = re.search(r'\"([^\"]*)\"', data)\n    if match:\n        s = match.group(1)\n    else:\n        # 若沒有引號，直接使用整個輸入（去除首尾空白）\n        s = data.strip()\n    solution = Solution()\n    result = solution.isPalindrome(s)\n    # 以小寫輸出結果\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"A man, a plan, a canal: Panama\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "s = \"race a car\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "s = \" \"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode169.json",
    "problem_index_in_file": 0,
    "title": "Majority Element",
    "description_snippet": "Given an array nums of size n, return the majority element.\n\nThe majority element is the element tha...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for majority element using Boyer-Moore majority vote algorithm. Output line by line with virtual code arrow. Each line: \"虛擬碼步驟 // 解釋\". We should use Start, Decision, Yes →, No → etc.\n\nWe must not output actual code. Use description steps: Start, Step 1: initialize candidate and count, iterate through nums, if count 0 set candidate, if nums[i]==candidate increment else decrement, after loop return candidate. We may include decisions? It's simple, but we can include Decision to check count >0? but algorithm always returns candidate. We'll include steps with arrow and explanation. Ensure each line includes the virtual code and // comment.\n\nLet's craft lines:\n\nStart\n→ Step 1: candidate ← null; count ← 0 // 初始化候選元素和計數器\n→ Step 2: 對於每個元素 num 在 nums 中進行\n    → Decision: count 為 0? // 判斷是否需要更新候選元素\n        Yes → Step 3: candidate ← num // 候選元素設為當前元素\n            No  // 保持現有候選元素\n    → Decision: num 等於 candidate? // 判斷是否為同一元素\n        Yes → Step 4: count ← count + 1 // 相同，計數器加 1\n        No  → Step 5: count ← count - 1 // 不同，計數器減 1\n→ End // 迴圈結束後 candidate 即為多數元素\n\nBut we need to preserve indentation? The example uses indentation under Decision. Let's mimic.\n\nAlso include \"→ Decision:\" line after Step 2? Wait Step 2 is a loop; inside we need decisions. We can use:\n\n→ Step 2: 迭代 nums 中每個元素 num // 逐個處理\n\n    → Decision: count = 0? // 判斷是否重設候選\n\n        Yes → Step 3: candidate ← num // 設為新候選\n\n        No → // 不變\n\n    → Decision: num = candidate? // 檢查是否相同\n\n        Yes → Step 4: count ← count + 1\n\n        No → Step 5: count ← count - 1\n\nAt the end:\n\n→ Step 6: 返回 candidate // 返還多數元素\n\nEnd\n\nBut we must ensure each line is separate. Use arrow for decisions.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: candidate ← null; count ← 0 // 初始化候選元素與計數器  \n→ Step 2: 迭代 nums 中每個元素 num // 逐一處理陣列中的元素  \n  → Decision: count = 0? // 判斷是否需要重設候選元素  \n   Yes → Step 3: candidate ← num // 設為新的候選元素  \n   No  → // 保持現有候選元素不變  \n  → Decision: num = candidate? // 檢查當前元素是否與候選相同  \n   Yes → Step 4: count ← count + 1 // 相同，計數器加 1  \n   No  → Step 5: count ← count - 1 // 不同，計數器減 1  \n→ Step 6: 返回 candidate // 迴圈結束後 candidate 即為多數元素  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def majorityElement(self, nums):\n        \"\"\"使用 Boyer-Moore majority vote 演算法找出多數元素\"\"\"\n        candidate = None\n        count = 0\n        for num in nums:\n            if count == 0:\n                candidate = num\n            count += 1 if num == candidate else -1\n        return candidate\n\ndef main():\n    # 讀取所有輸入，並移除可能的空白與換行\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n\n    # 若輸入格式為 \"nums = [ ... ]\"，則去掉前半部\n    if raw_input.lower().startswith(\"nums\"):\n        _, _, value_part = raw_input.partition('=')\n        raw_input = value_part.strip()\n\n    # 解析 list\n    try:\n        nums = ast.literal_eval(raw_input)\n    except Exception:\n        # 若解析失敗，直接退出\n        return\n\n    # 計算多數元素並輸出\n    result = Solution().majorityElement(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [3,2,3]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [2,2,1,1,1,2,2]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode468.json",
    "problem_index_in_file": 0,
    "title": "Validate IP Address",
    "description_snippet": "Given a string queryIP, return \"IPv4\" if IP is a valid IPv4 address, \"IPv6\" if IP is a valid IPv6 ad...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, line by line, with comments. The requirement: Output in traditional Chinese. Steps for checking IPv4/IPv6/Neither.\n\nWe need to generate step-by-step pseudocode.\n\nWe must not output actual code.\n\nWe should produce steps:\n\nStart, Input string queryIP, split by '.', if length 4 etc. For each part: check digits, no leading zero unless single zero, 0-255.\n\nIf IPv4 passes, return.\n\nElse, split by ':', length 8. For each part: length 1-4, hex characters only.\n\nIf passes, return IPv6 else Neither.\n\nWe need decision nodes.\n\nLet's write lines accordingly.\n\nWe'll output:\n\nStart // 開始\n→ Step 1: 取得輸入字串 queryIP // 取得待驗證 IP\n\n→ Decision: queryIP 包含 '.'? // 判斷是否可能是 IPv4\n\n    Yes → Step 2: 將 queryIP 以 '.' 分割為 parts // 取得四段\n\n    → Decision: parts 之長度為 4? // 檢查段數\n\n        Yes → For each part p in parts // 逐段檢查\n\n            → Decision: p 只包含數字? // 確認只含數字\n\n                Yes → Decision: p 不是以 '0' 開頭或 p 為 '0'? // 檢查前導零\n\n                    Yes → Decision: 0 <= int(p) <= 255? // 數值範圍\n\n                        Yes → Continue // 檢查下一段\n\n                        No  → Step 3: 返回 \"Neither\" // 數值不合法\n\n                    No  → Step 3: 返回 \"Neither\" // 前導零不合法\n\n                No  → Step 3: 返回 \"Neither\" // 非數字字符\n\n        No  → Step 3: 返回 \"Neither\" // 段數不為 4\n\n    No  → Decision: queryIP 包含 ':'? // 判斷是否可能是 IPv6\n\n        Yes → Step 4: 將 queryIP 以 ':' 分割為 parts // 取得八段\n\n        → Decision: parts 之長度為 8? // 檢查段數\n\n            Yes → For each part p in parts // 逐段檢查\n\n                → Decision: 1 <= len(p) <= 4? // 長度範圍\n\n                    Yes → Decision: p 只包含十六進位字元 (0-9,a-f,A-F)? // 字元合法性\n\n                        Yes → Continue // 檢查下一段\n\n                        No  → Step 5: 返回 \"Neither\" // 非十六進位字符\n\n                    No  → Step 5: 返回 \"Neither\" // 長度不合法\n\n            No  → Step 5: 返回 \"Neither\" // 段數不為 8\n\n        No  → Step 6: 返回 \"Neither\" // 既不是 IPv4 也不是 IPv6\n\n    // If IPv4 或 IPv6 檢查通過\n\n→ Step 7: 返回 \"IPv4\" // 若前面 IPv4 驗證成功\n\n→ Step 8: 返回 \"IPv6\" // 若前面 IPv6 驗證成功\n\nEnd // 程式結束\n\nBut we need to reflect that once a decision path fails, we return \"Neither\". Also, we need to stop processing further. Might use 'Exit' or 'Return'.\n\nSimplify: We can do sequential: check IPv4; if valid return; else check IPv6; if valid return; else return Neither.\n\nSo steps:\n\nStart\n\n→ Step 1: queryIP = input\n\n→ Step 2: 將 queryIP 以 '.' 分割為 parts\n\n→ Decision: parts 長度為 4 且 all parts valid IPv4? // 合併條件\n\n    Yes → Step 3: 返回 \"IPv4\"\n\n    No → Step 4: 將 queryIP 以 ':' 分割為 parts\n\n    → Decision: parts 長度為 8 且 all parts valid IPv6?\n\n        Yes → Step 5: 返回 \"IPv6\"\n\n        No  → Step 6: 返回 \"Neither\"\n\nBut need to detail validity check. Could use nested decisions inside.\n\nWe need to produce detailed pseudocode lines, but not too many.\n\nThe requirement: \"逐行地產生對應的虛擬碼\" - We can produce each line with explanation.\n\nLet's produce lines as above but include nested steps for validity. Each nested step will be preceded by indentation? We can just include arrow and decision lines accordingly. The sample uses indentation in textual representation: \"Yes →\" etc. We'll mimic that.\n\nOk produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得輸入字串 queryIP // 從使用者取得待驗證 IP  \n→ Step 2: 將 queryIP 以 '.' 分割為 partsIPv4 // 先假設是 IPv4  \n\n→ Decision: partsIPv4 的長度為 4? // 檢查段數是否為 4  \n    Yes → → Step 3: 初始化 flagIPv4 = true // 先假設有效  \n    → For 每個 part p in partsIPv4  \n        → Decision: p 只包含數字?  \n            Yes → → Decision: p 不以 '0' 開頭或 p 為 '0'? // 前導零檢查  \n                Yes → → Decision: 0 <= int(p) <= 255?  \n                    Yes → → Continue // 數值合法，檢查下一段  \n                    No  → → Step 4: flagIPv4 = false; 跳出循環 // 數值不合法  \n                No  → → Step 4: flagIPv4 = false; 跳出循環 // 前導零不合法  \n            No  → → Step 4: flagIPv4 = false; 跳出循環 // 非數字字符  \n    → Decision: flagIPv4 為 true? // 所有段皆合法  \n        Yes → → Step 5: 返回 \"IPv4\" // IPv4 驗證成功，結束  \n        No  → → Step 6: 進行 IPv6 驗證 // 轉到 IPv6 檢查  \n\n→ Decision: queryIP 以 ':' 分割後長度為 8? // 檢查是否可能是 IPv6  \n    Yes → → Step 7: 將 queryIP 以 ':' 分割為 partsIPv6 // 取得八段  \n    → Decision: partsIPv6 的長度為 8?  \n        Yes → → Step 8: 初始化 flagIPv6 = true // 假設有效  \n        → For 每個 part p in partsIPv6  \n            → Decision: 1 <= len(p) <= 4? // 長度範圍  \n                Yes → → Decision: p 只包含 0-9, a-f, A-F? // 十六進位字符檢查  \n                    Yes → → Continue // 字符合法，檢查下一段  \n                    No  → → Step 9: flagIPv6 = false; 跳出循環 // 非合法字符  \n                No  → → Step 9: flagIPv6 = false; 跳出循環 // 長度不合法  \n        → Decision: flagIPv6 為 true?  \n            Yes → → Step 10: 返回 \"IPv6\" // IPv6 驗證成功，結束  \n            No  → → Step 11: 返回 \"Neither\" // IPv6 檢查失敗  \n\n    No  → → Step 12: 返回 \"Neither\" // 既不是 IPv4 段數 4，也不是 IPv6 段數 8  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def validIPAddress(self, queryIP: str) -> str:\n        # Check IPv4\n        def isIPv4(s: str) -> bool:\n            parts = s.split('.')\n            if len(parts) != 4:\n                return False\n            for part in parts:\n                if not part.isdigit():\n                    return False\n                if part[0] == '0' and len(part) != 1:\n                    return False\n                if not 0 <= int(part) <= 255:\n                    return False\n            return True\n\n        # Check IPv6\n        def isIPv6(s: str) -> bool:\n            parts = s.split(':')\n            if len(parts) != 8:\n                return False\n            hexdigits = set('0123456789abcdefABCDEF')\n            for part in parts:\n                if not 1 <= len(part) <= 4:\n                    return False\n                if any(c not in hexdigits for c in part):\n                    return False\n            return True\n\n        if queryIP.count('.') == 3 and isIPv4(queryIP):\n            return \"IPv4\"\n        if queryIP.count(':') == 7 and isIPv6(queryIP):\n            return \"IPv6\"\n        return \"Neither\"\n\ndef extract_query_ip(raw: str) -> str:\n    \"\"\"從輸入文字中提取出 IP 字串，支持 `queryIP = \"...\"` 或單純的字串。\"\"\"\n    raw = raw.strip()\n    if '=' in raw:\n        _, value = raw.split('=', 1)\n        raw = value.strip()\n    # 去除可能的單引號或雙引號\n    if (raw.startswith('\"') and raw.endswith('\"')) or (raw.startswith(\"'\") and raw.endswith(\"'\")):\n        raw = raw[1:-1]\n    return raw\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    query_ip = extract_query_ip(data)\n    solution = Solution()\n    result = solution.validIPAddress(query_ip)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "queryIP = \"172.16.254.1\"",
          "expected_output": "IPv4",
          "success": true,
          "output": "IPv4"
        },
        {
          "example_index": 1,
          "input": "queryIP = \"2001:0db8:85a3:0:0:8A2E:0370:7334\"",
          "expected_output": "IPv6",
          "success": true,
          "output": "IPv6"
        },
        {
          "example_index": 2,
          "input": "queryIP = \"256.256.256.256\"",
          "expected_output": "Neither",
          "success": true,
          "output": "Neither"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode433.json",
    "problem_index_in_file": 0,
    "title": "Minimum Genetic Mutation",
    "description_snippet": "A gene string can be represented by an 8-character long string, with choices from 'A', 'C', 'G', and...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the described problem: find minimal mutations using BFS from startGene to endGene with bank set. Return -1 if not reachable.\n\nWe need to output lines with \"Start\", \"End\", \"Decision:\", \"Step X:\" etc, with arrow. Provide explanation comments.\n\nWe need to produce step-by-step algorithm in pseudo-code. Use BFS queue, visited set. For each gene generate 8 positions, 4 nucleotides. Check neighbor in bank and not visited. If neighbor equals endGene, return steps+1. If BFS exhausted return -1.\n\nWe need to use virtual code with arrows. Format: \"Start // 程式開始執行\". Next \"→ Step 1: 將起始基因 startGene 加入佇列並標記已訪問 // 將起始基因加入隊列\". Use \"→ Decision:\" etc. Provide steps for BFS loop, generating neighbors.\n\nWe'll output a structured list, each line containing \"虛擬碼步驟 [空格] // 解釋\". For decision lines, indent inside? Format example shows indentation with spaces. We'll follow pattern: For nested lines, indent with 4 spaces? Use example indent.\n\nWe'll produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立集合 bankSet 來存放銀行中的基因字串 // 方便 O(1) 判斷  \n→ Step 2: 建立佇列 queue 與集合 visited，將 startGene 加入 queue 並標記為已訪問 // 起始基因放進 BFS  \n→ Step 3: 變數 steps 初始化為 0 // 追蹤已完成的突變步數  \n→ Decision: 若 queue 為空? // 若沒有可探索的基因  \n  Yes → Step 4: 回傳 -1 // 無法到達 endGene  \n  No  → Step 5: 進入 BFS 迴圈  \n\n→ Step 6: 取得 queue 現在大小 size // 計算當前層的基因數量  \n→ Step 7: 對於 i 從 0 到 size-1 進行循環 // 逐個處理同層基因  \n  → Step 8: 取出 frontGene 於 queue 之首，並將其移除 // 取下一個待處理基因  \n  → Step 9: 若 frontGene 等於 endGene?  \n    Yes → Step 10: 回傳 steps // 完成所有突變  \n    No → Step 11: 對於每個位置 pos (0~7) 進行迭代  \n     → Step 12: 對於每個字母 ch 在 ['A','C','G','T']  \n      → Step 13: 若 ch 與 frontGene[pos] 相同，跳過 // 只考慮改變  \n      → Step 14: 產生 nextGene 為 frontGene，將 pos 的字母改為 ch // 新基因字串  \n      → Step 15: 若 nextGene 不是在 bankSet 或已在 visited?  \n        Yes → 連續執行下一個 ch // 無效或已訪問，跳過  \n       No  → Step 16: 若 nextGene 等於 endGene?  \n         Yes → Step 17: 回傳 steps + 1 // 找到終點，返回步數  \n         No  → Step 18: 將 nextGene 加入 queue 並標記為已訪問 // 探索下一層  \n  → Step 19: 循環結束後，steps 加 1 // 完成一層 BFS  \n→ Step 20: 回到 Step 6 的 Decision 迴圈  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom collections import deque\n\nclass Solution:\n    def minMutation(self, start: str, end: str, bank: list) -> int:\n        \"\"\"回傳從 start 到 end 所需的最小突變步數，若無法達到則回傳 -1\"\"\"\n        if end not in bank:\n            return -1\n\n        bank_set = set(bank)\n        genes = ['A', 'C', 'G', 'T']\n        queue = deque([(start, 0)])\n        visited = {start}\n\n        while queue:\n            current, steps = queue.popleft()\n            if current == end:\n                return steps\n\n            for i in range(len(current)):\n                for g in genes:\n                    if g == current[i]:\n                        continue\n                    mutation = current[:i] + g + current[i+1:]\n                    if mutation in bank_set and mutation not in visited:\n                        visited.add(mutation)\n                        queue.append((mutation, steps + 1))\n\n        return -1\n\ndef parse_input(data: str):\n    \"\"\"將輸入字串轉換為 start, end, bank 的值\"\"\"\n    start_pat = r'startGene\\s*=\\s*\"([ACGT]+)\"'\n    end_pat = r'endGene\\s*=\\s*\"([ACGT]+)\"'\n    bank_pat = r'bank\\s*=\\s*\\[([^\\]]*)\\]'\n\n    start_match = re.search(start_pat, data)\n    end_match = re.search(end_pat, data)\n    bank_match = re.search(bank_pat, data)\n\n    if not start_match or not end_match or not bank_match:\n        raise ValueError(\"輸入格式不正確\")\n\n    start = start_match.group(1)\n    end = end_match.group(1)\n\n    # 取得 bank 內部的字串，可能為空\n    bank_content = bank_match.group(1).strip()\n    if not bank_content:\n        bank = []\n    else:\n        bank = re.findall(r'\"([ACGT]+)\"', bank_content)\n\n    return start, end, bank\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    try:\n        start, end, bank = parse_input(data)\n    except ValueError:\n        # 如果輸入不是預期的 format，直接嘗試 eval（風險較高）\n        # 這裡假設輸入已經是合法的 python 表達式\n        # 例如: {'startGene': 'AACCGGTT', 'endGene': 'AACCGGTA', 'bank': ['AACCGGTA']}\n        d = eval(data, {})\n        start = d.get('startGene', '')\n        end = d.get('endGene', '')\n        bank = d.get('bank', [])\n\n    sol = Solution()\n    result = sol.minMutation(start, end, bank)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "startGene = \"AACCGGTT\", endGene = \"AACCGGTA\", bank = [\"AACCGGTA\"]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "startGene = \"AACCGGTT\", endGene = \"AAACGGTA\", bank = [\"AACCGGTA\",\"AACCGCTA\",\"AAACGGTA\"]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode168.json",
    "problem_index_in_file": 0,
    "title": "Excel Sheet Column Title",
    "description_snippet": "Given an integer columnNumber, return its corresponding column title as it appears in an Excel sheet...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code lines with explanations. It's a classic problem: convert integer to Excel column title. Steps: Start, compute, loop: while columnNumber > 0: compute remainder (mod 26). Since mapping is 1-26 to A-Z, but modulo 0 case maps to 'Z' and subtract 1. Approach: remainder = (columnNumber -1) %26, char = 'A'+remainder, prepend to result, columnNumber = (columnNumber-1)/26.\n\nWe need to produce virtual code step by step with arrow notation.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 定義空字串 result // 用於存放最終的欄位名稱\n→ Step 2: 讀取 columnNumber // 從輸入取得數值\n→ Decision: columnNumber 是否大於 0? // 檢查是否還有位元需要處理\n    Yes → Step 3: columnNumber 減 1 // 轉換為 0 基準\n        → Step 4: remainder = columnNumber % 26 // 取得目前位元對應的字母索引\n        → Step 5: letter = 'A' + remainder // 轉換為字母\n        → Step 6: result = letter + result // 將字母加到前面\n        → Step 7: columnNumber = columnNumber / 26 // 移動到更高位\n        → Decision: columnNumber 是否大於 0? // 重新檢查是否還有位元\n            Yes → (回到 Step 3)\n            No  → Step 8: 輸出 result // 顯示最終欄位名稱\n    No  → Step 9: 輸出 result // 若 columnNumber 為 0，直接輸出空字串或處理錯誤\nEnd // 程式執行結束\n\nBut we need to maintain arrow and indentation with arrows.\n\nBetter to use: → Step 3: columnNumber ← columnNumber - 1 // adjust\n→ Step 4: remainder ← columnNumber % 26 // get remainder\n→ Step 5: letter ← chr('A' + remainder) // compute letter\n→ Step 6: result ← letter + result // prepend\n→ Step 7: columnNumber ← columnNumber / 26 // integer division\n→ Decision: columnNumber > 0? // loop again\n\nNeed to maintain arrow for loops: maybe use \"→ Step 3\" then inside same block until \"Decision:\" etc.\n\nLet's produce.\n\nAlso ensure each line includes \"虛擬碼步驟\" + space + \"// 解釋\". Provide in Chinese.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: result ← \"\" // 用來存放最終的 Excel 欄位名稱  \n→ Step 2: 讀取 columnNumber // 從輸入取得整數  \n→ Decision: columnNumber > 0? // 是否還有位元需要處理  \n&nbsp;&nbsp;Yes → Step 3: columnNumber ← columnNumber - 1 // 轉為 0‑基準，避免 0 對應 'A'  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 4: remainder ← columnNumber % 26 // 取得目前最低位的字母索引  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 5: letter ← chr('A' + remainder) // 將索引轉為對應字母  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 6: result ← letter + result // 把字母加到前面  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 7: columnNumber ← columnNumber / 26 // 整數除以 26，移至更高位  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: columnNumber > 0? // 檢查是否還有更高位  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → (回到 Step 3) // 重複處理下一個位元  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 8: 輸出 result // 完成後輸出欄位名稱  \n&nbsp;&nbsp;No  → Step 9: 輸出 result // 如果初始 columnNumber 為 0，直接輸出空字串或錯誤訊息  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def convertToTitle(self, columnNumber: int) -> str:\n        \"\"\"\n        Convert a positive integer to its corresponding Excel column title.\n        \"\"\"\n        res = ''\n        while columnNumber > 0:\n            columnNumber -= 1                # adjust to 0‑based index\n            res = chr(columnNumber % 26 + ord('A')) + res\n            columnNumber //= 26\n        return res\n\ndef main() -> None:\n    # 讀取整個輸入（通常是一行，例如 \"columnNumber = 28\"）\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 從輸入字串中抓取第一個整數\n    match = re.search(r'-?\\d+', data)\n    if not match:\n        return\n\n    column_number = int(match.group(0))\n    solution = Solution()\n    title = solution.convertToTitle(column_number)\n\n    # 輸出結果，包在雙引號中以符合範例\n    print(f'\"{title}\"')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "columnNumber = 1",
          "expected_output": "\"A\"",
          "success": true,
          "output": "\"A\""
        },
        {
          "example_index": 1,
          "input": "columnNumber = 28",
          "expected_output": "\"AB\"",
          "success": true,
          "output": "\"AB\""
        },
        {
          "example_index": 2,
          "input": "columnNumber = 701",
          "expected_output": "\"ZY\"",
          "success": true,
          "output": "\"ZY\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode23.json",
    "problem_index_in_file": 0,
    "title": "Merge k Sorted Lists",
    "description_snippet": "You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.\n\nMerg...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps to merge k sorted linked lists into one sorted linked list. Use priority queue min-heap or pairwise merge. Provide virtual steps line by line with comments. Use arrows and decision.\n\nWe must not output actual code. Just pseudo-steps.\n\nLet's produce something like:\n\nStart\n→ Initialize min-heap\n→ For each list head, if not null, push node into heap\n→ Initialize dummy head for result\n→ While heap not empty:\n    → Extract min node\n    → Append to result\n    → If extracted node has next, push next into heap\n→ Return result.next\n\nNeed to explain each line.\n\nAdd decision for empty lists.\n\nMaybe also cover initialization and termination.\n\nUse arrows \"→\".\n\nAlso include Decision: if list count >0? but we can skip.\n\nLet's write steps:\n\nStart // 程式開始執行\n→ Step 1: 建立一個最小堆 heap // 用來快速取得目前最小的節點\n→ Step 2: 迭代每個輸入 linked-list 的 head，若非空則將其節點加入 heap // 將所有列表的首節點放入堆\n→ Step 3: 建立一個 dummy 節點 dummyHead 並設 current 指向 dummyHead // 用於方便構造結果鏈表\n→ Decision: 如果 heap 內有節點? // 檢查是否還有節點可合併\n    Yes → Step 4: 從 heap 中取出最小節點 minNode // 取得目前最小的節點\n    → Step 5: current.next ← minNode // 把 minNode 加入結果鏈表\n    → Step 6: current ← current.next // 移動 current 到新加的節點\n    → Decision: minNode.next 是否非空? // 檢查取出的節點是否還有下一個節點\n        Yes → Step 7: 把 minNode.next 推入 heap // 將下一個節點加入堆以備下一輪比較\n        No  → // 若沒有下一個節點，則不做任何操作\n    → Step 8: 回到 Decision: 如果 heap 內有節點? // 重複處理剩餘節點\n    No  → // 所有節點已經處理完畢\n→ Step 9: 返回 dummyHead.next // 結果鏈表的頭節點\nEnd // 程式執行結束\n\nNeed to ensure each line is formatted with \"虛擬碼步驟 // 解釋\". Use \"→\" for each step after Start? Start line should just \"Start\". Use arrow before steps.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立最小堆 heap // 用於快速取得目前最小的節點  \n→ Step 2: 迭代每個 linked-list 的 head，若非空則將其節點加入 heap // 將所有列表的首節點放入堆  \n→ Step 3: 建立 dummy 節點 dummyHead 並設 current 指向 dummyHead // 用於方便構造結果鏈表  \n→ Decision: 如果 heap 內有節點? // 檢查是否還有節點可合併  \n Yes → Step 4: 從 heap 中取出最小節點 minNode // 取得目前最小的節點  \n  → Step 5: current.next ← minNode // 把 minNode 加入結果鏈表  \n  → Step 6: current ← current.next // 移動 current 到新加的節點  \n  → Decision: minNode.next 是否非空? // 檢查取出的節點是否還有下一個節點  \n   Yes → Step 7: 把 minNode.next 推入 heap // 將下一個節點加入堆以備下一輪比較  \n   No  → // 若沒有下一個節點，則不做任何操作  \n  → Step 8: 回到 Decision: 如果 heap 內有節點? // 重複處理剩餘節點  \n No  → // 所有節點已經處理完畢  \n→ Step 9: 返回 dummyHead.next // 結果鏈表的頭節點  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\n# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def mergeKLists(self, lists):\n        if not lists:\n            return None\n        return self.mergeRange(lists, 0, len(lists) - 1)\n\n    def mergeRange(self, lists, left, right):\n        if left == right:\n            return lists[left]\n        mid = (left + right) // 2\n        l1 = self.mergeRange(lists, left, mid)\n        l2 = self.mergeRange(lists, mid + 1, right)\n        return self.mergeTwoLists(l1, l2)\n\n    def mergeTwoLists(self, l1, l2):\n        dummy = ListNode(0)\n        curr = dummy\n        while l1 and l2:\n            if l1.val < l2.val:\n                curr.next = l1\n                l1 = l1.next\n            else:\n                curr.next = l2\n                l2 = l2.next\n            curr = curr.next\n        curr.next = l1 or l2\n        return dummy.next\n\ndef parse_input(data):\n    \"\"\"\n    Parse the raw input string to extract the list of lists.\n    Handles formats like 'lists = [[1,4,5],[1,3,4],[2,6]]' or just '[]'.\n    \"\"\"\n    if not data:\n        return []\n\n    # Remove any leading/trailing whitespace\n    data = data.strip()\n\n    # If the input contains 'lists =', split to get the expression part\n    if '=' in data:\n        _, expr = data.split('=', 1)\n    else:\n        expr = data\n\n    try:\n        parsed = ast.literal_eval(expr.strip())\n    except Exception:\n        parsed = []\n\n    return parsed\n\ndef build_linked_lists(arrays):\n    \"\"\"\n    Convert a list of Python lists into a list of ListNode heads.\n    \"\"\"\n    linked_lists = []\n    for arr in arrays:\n        if not arr:\n            linked_lists.append(None)\n            continue\n        head = None\n        prev = None\n        for val in arr:\n            node = ListNode(val)\n            if prev:\n                prev.next = node\n            else:\n                head = node\n            prev = node\n        linked_lists.append(head)\n    return linked_lists\n\ndef linked_list_to_list(head):\n    \"\"\"\n    Convert a linked list back to a Python list for output.\n    \"\"\"\n    result = []\n    current = head\n    while current:\n        result.append(current.val)\n        current = current.next\n    return result\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    arrays = parse_input(raw_input)\n    lists = build_linked_lists(arrays)\n\n    solution = Solution()\n    merged_head = solution.mergeKLists(lists)\n\n    merged_array = linked_list_to_list(merged_head)\n    output = '[' + ','.join(map(str, merged_array)) + ']'\n    print(output)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "lists = [[1,4,5],[1,3,4],[2,6]]",
          "expected_output": "[1,1,2,3,4,4,5,6]",
          "success": true,
          "output": "[1,1,2,3,4,4,5,6]"
        },
        {
          "example_index": 1,
          "input": "lists = []",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        },
        {
          "example_index": 2,
          "input": "lists = [[]]",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode295.json",
    "problem_index_in_file": 0,
    "title": "Find Median from Data Stream",
    "description_snippet": "The median is the middle value in an ordered integer list. If the size of the list is even, there is...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code for implementing MedianFinder with methods: constructor, addNum, findMedian. Use data structure of two heaps: max-heap for lower half, min-heap for upper half. Keep sizes balanced: len(maxheap) == len(minheap) or len(maxheap) == len(minheap)+1. In addNum, push into one heap then adjust. findMedian returns top of maxheap if odd else average of tops.\n\nWe need to produce virtual code lines with explanation. Use Start, End. Use arrow. Provide each line.\n\nLet's structure:\n\nStart\n→ Step: 初始化最大堆（maxHeap）和最小堆（minHeap） // 用於存儲左半和右半數據\n→ Step: addNum(num) // 新增數字\n    → Decision: 若 maxHeap 為空 或 num <= maxHeap.top? // 判斷應放入哪個堆\n        Yes → Step: maxHeap.push(num) // 放入左半\n        No  → Step: minHeap.push(num) // 放入右半\n    → Decision: maxHeap.size() > minHeap.size() + 1? // 左堆是否過大\n        Yes → Step: minHeap.push(maxHeap.top()) // 右堆移一個\n        No → Decision: minHeap.size() > maxHeap.size()? // 右堆是否過大\n            Yes → Step: maxHeap.push(minHeap.top()) // 左堆移一個\n            No → // 兩堆已平衡\n    → End // addNum結束\n→ Step: findMedian() // 計算中位數\n    → Decision: maxHeap.size() == minHeap.size()? // 數量是否相等\n        Yes → Step: median = (maxHeap.top() + minHeap.top()) / 2.0 // 平均\n        No  → Step: median = maxHeap.top() // 左堆多一個元素\n    → Step: return median\nEnd\n\nBut must adhere to format: each line with \"虛擬碼步驟 [space] // 解釋\".\n\nAlso use arrow \"→\". For decisions, indent accordingly.\n\nWe need to show Start and End. Each line includes step. For decisions, use Decision:. Indent lines under decision with tabs or spaces.\n\nLet's produce final. Use lines:\n\nStart // 程式開始執行\n→ Step: 初始化最大堆 (maxHeap) 與最小堆 (minHeap) // 用於存儲左半與右半數值\n→ Step: addNum(num) // 新增數字至資料結構\n    → Decision: 若 maxHeap 為空 或 num <= maxHeap.top()? // 判斷數字屬於左半還是右半\n        Yes → Step: maxHeap.push(num) // 放入左半堆\n        No  → Step: minHeap.push(num) // 放入右半堆\n    → Decision: maxHeap.size() > minHeap.size() + 1? // 左堆是否過大\n        Yes → Step: minHeap.push(maxHeap.top()) // 從左堆轉移一個到右堆\n        No → Decision: minHeap.size() > maxHeap.size()? // 右堆是否過大\n            Yes → Step: maxHeap.push(minHeap.top()) // 從右堆轉移一個到左堆\n            No → // 堆已平衡\n    → End // addNum 完成\n→ Step: findMedian() // 取得目前中位數\n    → Decision: maxHeap.size() == minHeap.size()? // 數量是否相等\n        Yes → Step: median = (maxHeap.top() + minHeap.top()) / 2.0 // 平均兩中間值\n        No  → Step: median = maxHeap.top() // 左堆多一個，取其頂值\n    → Step: return median // 回傳中位數\nEnd // 程式執行結束\n\nWe need to ensure each line has \"虛擬碼步驟 // 解釋\". Also maybe each decision block lines indent with 4 spaces. Provide as above.\n\nCheck formatting: each line ends with //.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step: 初始化最大堆 (maxHeap) 與最小堆 (minHeap) // 用於存儲左半與右半數值\n→ Step: addNum(num) // 新增數字至資料結構\n    → Decision: 若 maxHeap 為空 或 num <= maxHeap.top()? // 判斷數字屬於左半還是右半\n        Yes → Step: maxHeap.push(num) // 放入左半堆\n        No  → Step: minHeap.push(num) // 放入右半堆\n    → Decision: maxHeap.size() > minHeap.size() + 1? // 左堆是否過大\n        Yes → Step: minHeap.push(maxHeap.top()) // 從左堆轉移一個到右堆\n        No → Decision: minHeap.size() > maxHeap.size()? // 右堆是否過大\n            Yes → Step: maxHeap.push(minHeap.top()) // 從右堆轉移一個到左堆\n            No → // 堆已平衡\n    → End // addNum 完成\n→ Step: findMedian() // 取得目前中位數\n    → Decision: maxHeap.size() == minHeap.size()? // 數量是否相等\n        Yes → Step: median = (maxHeap.top() + minHeap.top()) / 2.0 // 平均兩中間值\n        No  → Step: median = maxHeap.top() // 左堆多一個，取其頂值\n    → Step: return median // 回傳中位數\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport heapq\nimport ast\n\nclass MedianFinder:\n    def __init__(self):\n        # 最大堆（用負值模擬）存儲較小的一半數值\n        self.small = []\n        # 最小堆存儲較大的一半數值\n        self.large = []\n\n    def addNum(self, num: int) -> None:\n        # 將新數字先放入最大堆\n        heapq.heappush(self.small, -num)\n        # 若兩堆之間的最大值與最小值交叉，交換它們\n        if self.small and self.large and (-self.small[0] > self.large[0]):\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        # 保持兩堆大小平衡：左堆可比右堆多一個\n        if len(self.small) > len(self.large) + 1:\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        elif len(self.large) > len(self.small):\n            val = heapq.heappop(self.large)\n            heapq.heappush(self.small, -val)\n\n    def findMedian(self) -> float:\n        if len(self.small) > len(self.large):\n            return -self.small[0]\n        return (-self.small[0] + self.large[0]) / 2.0\n\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 分離操作列表和參數列表\n    idx = data.find('],')\n    ops_str = data[:idx + 1]        # 包含第一個列表的結尾\n    args_str = data[idx + 2:].strip()  # 跳過 ', '\n\n    ops = ast.literal_eval(ops_str)\n    args = ast.literal_eval(args_str)\n\n    obj = None\n    outputs = []\n\n    for op, arg in zip(ops, args):\n        if op == \"MedianFinder\":\n            obj = MedianFinder()\n            outputs.append(None)\n        elif op == \"addNum\":\n            obj.addNum(arg[0])\n            outputs.append(None)\n        elif op == \"findMedian\":\n            median = obj.findMedian()\n            outputs.append(median)\n        else:\n            # 若有未知操作，視為錯誤但此處簡化為 None\n            outputs.append(None)\n\n    # 轉換 None 為 null，其他數值保持原樣\n    result_strs = ['null' if v is None else str(v) for v in outputs]\n    print('[' + ', '.join(result_strs) + ']')\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"], [[], [1], [2], [], [3], []]",
          "expected_output": "[null, null, null, 1.5, null, 2.0]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,1.5,null,2.0]'\nGot (Norm):      '[null,null,null,1.5,null,2]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, 1.5, null, 2.0]'\nRaw Got:      '[null, null, null, 1.5, null, 2]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode352.json",
    "problem_index_in_file": 0,
    "title": "Data Stream as Disjoint Intervals",
    "description_snippet": "Given a data stream input of non-negative integers a_1, a_2, ..., a_n, summarize the numbers seen so...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for SummaryRanges class: addNum and getIntervals. We need to think of data structure: maybe use a sorted list of intervals or a BST. Since no actual code, just pseudocode steps. We need to produce lines: Start, then Steps for constructor, addNum, getIntervals, End. The algorithm: When adding value, we need to merge with adjacent intervals. Approach: maintain sorted list of intervals. Use binary search to find position. Steps:\n\n- On addNum(value):\n    - If no intervals, add [value, value] and return.\n    - Find position where value would be inserted (first interval with start > value).\n    - Determine left neighbor interval i-1 and right neighbor i (if exist).\n    - Cases:\n        - If value lies within an existing interval (between start and end inclusive), nothing to do.\n        - Else if value == left.end +1 and value == right.start -1: merge left, value, right into one [left.start, right.end].\n        - Else if value == left.end +1: extend left.end = value.\n        - Else if value == right.start -1: extend right.start = value.\n        - Else: insert new interval [value, value] at position.\n- getIntervals returns list of intervals.\n\nWe need to express as pseudocode steps. Use decision arrows.\n\nWe will output line by line. Let's design structure:\n\nStart\n→ Step 1: Define class SummaryRanges // 初始化\n→ Step 2: Initialize intervals as empty list // 儲存區間\n\naddNum(value)\n→ Step 3: If intervals empty → add [value,value] and return\n→ Step 4: Find insertion index idx where intervals[idx].start > value // binary search\n→ Step 5: left = intervals[idx-1] if idx>0 else null\n→ Step 6: right = intervals[idx] if idx < size else null\n→ Step 7: Decision: value within left interval? // left and right exist check\n    Yes → Return // value already covered\n    No → Decision: value within right interval? \n        Yes → Return // covered\n        No → Decision: left exists and value == left.end+1 and right exists and value == right.start-1?\n            Yes → Merge left and right: left.end = right.end; remove right; // combine\n            No → Decision: left exists and value == left.end+1?\n                Yes → left.end = value; // extend left\n                No → Decision: right exists and value == right.start-1?\n                    Yes → right.start = value; // extend right\n                    No → Insert new interval [value,value] at idx; // new interval\n\ngetIntervals\n→ Step X: Return intervals list // sorted automatically\n\nEnd\n\nBut we need to use syntax with Start, End, Decision: lines with Yes→ and No→.\n\nMake sure each line has the arrow. For decisions, we indent branches. Provide explanation after //.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義 SummaryRanges 類別 // 建立類別框架\n→ Step 2: intervals ← 空清單 // 用來儲存不重疊區間，已按起點排序\n→ Step 3: Constructor: SummaryRanges() // 初始化物件\n    → End // 建構子結束\n\n→ Method: addNum(value) // 將新數值加入資料流\n    → Step 4: 若 intervals 為空，則插入區間 [value, value]，並 Return\n        → End // 完成\n    → Step 5: idx ← 二分搜尋 first interval start > value // 找到可能插入位置\n    → Step 6: left ← intervals[idx-1] 若 idx > 0，否則 null // 左鄰近區間\n    → Step 7: right ← intervals[idx] 若 idx < intervals.size，否則 null // 右鄰近區間\n    → Decision: value 在 left 區間內 (left ≠ null 且 left.start ≤ value ≤ left.end)?\n        Yes → Return // 已包含，不需更新\n        No  → Decision: value 在 right 區間內 (right ≠ null 且 right.start ≤ value ≤ right.end)?\n            Yes → Return // 已包含，不需更新\n            No  → Decision: left 存在且 value == left.end + 1 且 right 存在且 value == right.start - 1?\n                Yes → // 同時連接兩側，合併為一個區間\n                    → Step 8: left.end ← right.end // 更新左區間結束點\n                    → Step 9: 移除 intervals[idx] // 刪除右區間\n                    → End // 合併完成\n                No  → Decision: left 存在且 value == left.end + 1?\n                    Yes → // 延伸左區間\n                        → Step 10: left.end ← value\n                        → End\n                    No  → Decision: right 存在且 value == right.start - 1?\n                        Yes → // 延伸右區間\n                            → Step 11: right.start ← value\n                            → End\n                        No  → // 與任何區間都不相鄰，插入新區間\n                            → Step 12: 在 intervals[idx] 位置插入 [value, value]\n                            → End\n\n→ Method: getIntervals() // 取得目前所有區間\n    → Step 13: Return intervals // 清單已按起點排序且不重疊\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport json\n\nclass SummaryRanges:\n    def __init__(self):\n        self.intervals = []\n\n    def addNum(self, val):\n        new_interval = [val, val]\n        res = []\n        placed = False\n        for start, end in self.intervals:\n            if end + 1 < val:\n                # current interval ends before new value, keep it\n                res.append([start, end])\n            elif val + 1 < start:\n                # new value is before the current interval\n                if not placed:\n                    res.append(new_interval)\n                    placed = True\n                res.append([start, end])\n            else:\n                # overlapping or adjacent, merge\n                new_interval[0] = min(start, new_interval[0])\n                new_interval[1] = max(end, new_interval[1])\n        if not placed:\n            res.append(new_interval)\n        self.intervals = res\n\n    def getIntervals(self):\n        return self.intervals\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        sys.exit()\n    commands = ast.literal_eval(data[0])\n    args_list = ast.literal_eval(data[1]) if len(data) > 1 else []\n    obj = None\n    outputs = []\n\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"SummaryRanges\":\n            obj = SummaryRanges()\n            outputs.append(None)\n        elif cmd == \"addNum\":\n            obj.addNum(args[0])\n            outputs.append(None)\n        elif cmd == \"getIntervals\":\n            outputs.append(obj.getIntervals())\n\n    print(json.dumps(outputs))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"SummaryRanges\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\"]\n[[], [1], [], [3], [], [7], [], [2], [], [6], []]",
          "expected_output": "[null, null, [[1, 1]], null, [[1, 1], [3, 3]], null, [[1, 1], [3, 3], [7, 7]], null, [[1, 3], [7, 7]], null, [[1, 3], [6, 7]]]",
          "success": true,
          "output": "[null, null, [[1, 1]], null, [[1, 1], [3, 3]], null, [[1, 1], [3, 3], [7, 7]], null, [[1, 3], [7, 7]], null, [[1, 3], [6, 7]]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode47.json",
    "problem_index_in_file": 0,
    "title": "Permutations II",
    "description_snippet": "Given a collection of numbers, nums, that might contain duplicates, return all possible unique permu...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps to generate all unique permutations for a collection nums that may contain duplicates. The virtual code must be line-by-line, with arrows and decision structure. Provide explanation after each line. Must be in Traditional Chinese. No actual code. So we produce something like:\n\nStart\n→ Sort nums // 排序以便於偵測重複\n→ Initialize result list\n→ Call backtrack with index 0 and used array // 递归生成\n   etc.\n\nWe need to cover backtracking with visited boolean and skip duplicates: if i>0 && nums[i]==nums[i-1] && !used[i-1] then skip.\n\nWe should output with virtual code lines, each line: \"虛擬碼步驟 // 解釋\".\n\nWe need to use arrows (→, Yes→, No→). We need to show decision branches.\n\nSo we can produce something like:\n\nStart // 程式開始\n→ Step 1: 輸入 nums // 獲取輸入陣列\n→ Step 2: 先將 nums 進行排序 // 方便後續跳過重複元素\n→ Step 3: 初始化 result 為空列表 // 用於儲存所有唯一排列\n→ Step 4: 建立 visited 陣列，長度與 nums 相同，初始全為 False // 標記每個元素是否已使用\n→ Step 5: 定義遞迴函式 backtrack(path) // path 為目前已組成的排列\n    → Decision: path 長度等於 nums 長度?\n        Yes → Step 6: 把 path 複製加入 result // 完整排列\n        No  → Decision: 遍歷 i 0~len(nums)-1?\n            → Step 7: Decision: visited[i] 或 (i>0 且 nums[i]==nums[i-1] 且 !visited[i-1])?\n                Yes → Step 8: 跳過 i // 為了避免重複排列\n                No  → Step 9: 設置 visited[i] = True // 標記已使用\n                        → Step 10: path.append(nums[i]) // 加入當前元素\n                        → Step 11: backtrack(path) // 進一步遞迴\n                        → Step 12: path.pop() // 回溯\n                        → Step 13: visited[i] = False // 取消標記\n→ Step 14: 呼叫 backtrack([]) // 開始遞迴\n→ Step 15: 返回 result // 完成結果\nEnd // 程式結束\n\nWe need to maintain structure: Use arrows and decisions properly. We'll incorporate \"Decision:\" lines and \"Yes →\" \"No →\" properly.\n\nWe need to output each line with \"虛擬碼步驟 // 解釋\" format. Eg:\n\nStart // 程式開始\n\n→ Step 1: 輸入 nums // 取得輸入陣列\n\nBut we must not output \"Step 1:\"? We can, but it's okay. The format just needs \"虛擬碼步驟 [space] // 解釋\".\n\nAlso must include arrows. Eg: \"→ Step 1: 輸入 nums // 取得輸入陣列\".\n\n\"Decision:\" lines: \"Decision: path 長度等於 nums 長度?\" and then indent \"Yes →\" lines etc.\n\nLet's format accordingly. Indentation: use spaces for readability. Should be okay.\n\nWe'll produce final output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 輸入 nums // 取得輸入陣列\n→ Step 2: 將 nums 進行排序 // 方便後續跳過重複元素\n→ Step 3: 初始化 result 為空列表 // 用於儲存所有唯一排列\n→ Step 4: 建立 visited 陣列，長度與 nums 相同，全部為 False // 標記每個元素是否已使用\n→ Step 5: 定義遞迴函式 backtrack(path) // path 為目前已組成的排列\n    → Decision: path 長度是否等於 nums 長度? // 判斷是否已完成一個排列\n        Yes → Step 6: 把 path 複製加入 result // 完整排列加入結果集合\n        No  → Decision: 遍歷 i 從 0 到 len(nums)-1? // 逐一嘗試每個位置\n            → Step 7: Decision: visited[i] 為 True 或 (i>0 且 nums[i]==nums[i-1] 且 visited[i-1] 為 False)? // 判斷是否跳過此元素以避免重複\n                Yes → Step 8: 跳過 i // 這個元素已使用或會產生重複排列\n                No  → Step 9: 設置 visited[i] = True // 標記已使用\n                        → Step 10: path.append(nums[i]) // 加入當前元素到排列\n                        → Step 11: backtrack(path) // 進一步遞迴\n                        → Step 12: path.pop() // 回溯，移除最後一個元素\n                        → Step 13: visited[i] = False // 取消標記，恢復狀態\n→ Step 14: 呼叫 backtrack([]) // 開始遞迴，初始為空排列\n→ Step 15: 返回 result // 完成所有唯一排列\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def permuteUnique(self, nums):\n        res = []\n        nums.sort()  # 先排序方便去重\n        used = [False] * len(nums)\n\n        def backtrack(path):\n            if len(path) == len(nums):\n                res.append(path[:])\n                return\n            for i in range(len(nums)):\n                if used[i]:\n                    continue\n                if i > 0 and nums[i] == nums[i - 1] and not used[i - 1]:\n                    continue  # 避免重複排列\n                used[i] = True\n                path.append(nums[i])\n                backtrack(path)\n                path.pop()\n                used[i] = False\n\n        backtrack([])\n        return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 允許輸入形如 \"nums = [1,1,2]\" 或單純 \"[1,1,2]\"\n    if '=' in data:\n        _, list_part = data.split('=', 1)\n        list_part = list_part.strip()\n    else:\n        list_part = data\n\n    try:\n        nums = ast.literal_eval(list_part)\n    except Exception:\n        # 只作備援，通常不應該發生\n        nums = eval(list_part, {}, {})\n\n    solution = Solution()\n    result = solution.permuteUnique(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,1,2]",
          "expected_output": "[[1,1,2],[1,2,1],[2,1,1]]",
          "success": true,
          "output": "[[1, 1, 2], [1, 2, 1], [2, 1, 1]]"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3]",
          "expected_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "success": true,
          "output": "[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode452.json",
    "problem_index_in_file": 0,
    "title": "Minimum Number of Arrows to Burst Balloons",
    "description_snippet": "There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code, step-by-step, with explanations, using the format. The problem: given intervals, find minimum number of arrows to cover all intervals: typical interval scheduling. Algorithm: sort intervals by end coordinate, then greedily shoot arrow at end of first interval, skip all intervals that overlap, count arrows.\n\nWe need to produce virtual code lines, with arrows and decisions. Let's think of steps:\n\nStart\n→ Step: Sort intervals by x_end ascending\n→ Step: Initialize arrowCount=0, currentEnd= -infinity\n→ For each interval in sorted list:\n   Decision: If interval.x_start > currentEnd? // not covered\n        Yes → arrowCount +=1\n            currentEnd = interval.x_end\n        No → // skip\n→ End\n\nAlso need to handle empty list return 0.\n\nAdd a decision before loop: If points empty? // return 0.\n\nAlso we need to produce code lines accordingly.\n\nLet's produce the output accordingly.\n\nMake sure each line: \"虛擬碼步驟 // 解釋\". Use \"Start\" etc.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Decision: 如果 points 為空? // 檢查是否有氣球\n    Yes → Return 0 // 無氣球需射0支箭\n    No  → \n→ Step: 將 points 按 x_end 升序排序 // 方便貪心選擇\n→ Step: 初始化 arrowCount = 0, currentEnd = -∞ // 追蹤最後射出的箭所在 x\n→ Step: 對於每個 interval in sorted points\n    → Decision: 如果 interval.x_start > currentEnd? // 尚未被現有箭擊中\n        Yes → arrowCount += 1 // 新箭\n            currentEnd = interval.x_end // 射箭位置設定為此氣球右端\n        No  → // 已被現有箭擊中，忽略\n→ Step: Return arrowCount // 所有氣球已被擊中\nEnd // 程式執行結束\n\nMake sure each line is separate, no extra indentation? We can use indentation for decision branches as per sample.\n\nAlso need to maintain format: \"虛擬碼步驟 [空格] // 解釋\".\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: 如果 points 為空? // 檢查是否有氣球  \n  Yes → Return 0 // 無氣球需射 0 支箭  \n  No  → // 進行後續處理  \n→ Step: 將 points 按 x_end 升序排序 // 方便貪心選擇  \n→ Step: 初始化 arrowCount = 0, currentEnd = -∞ // 追蹤最後射出的箭所在 x  \n→ Step: 對於每個 interval in sorted points  \n  → Decision: 如果 interval.x_start > currentEnd? // 尚未被現有箭擊中  \n    Yes → arrowCount += 1 // 新箭  \n      currentEnd = interval.x_end // 射箭位置設定為此氣球右端  \n    No  → // 已被現有箭擊中，忽略  \n→ Step: Return arrowCount // 所有氣球已被擊中  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef find_min_arrows(points):\n    \"\"\"Return the minimum number of arrows needed to burst all balloons.\"\"\"\n    if not points:                     # 沒有氣球時不需要箭\n        return 0\n    points.sort(key=lambda x: x[1])     # 按右端升序排序\n    arrows = 1\n    current_end = points[0][1]          # 第一次射箭的位置\n    for start, end in points[1:]:\n        if start > current_end:        # 這個氣球沒有被現有箭擊中\n            arrows += 1\n            current_end = end          # 以這個氣球的右端作為新的射箭位置\n    return arrows\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    # 允許輸入類似 \"points = [[10,16],[2,8]]\"\n    if data.startswith(\"points\"):\n        _, rest = data.split('=', 1)\n        rest = rest.strip()\n    else:\n        rest = data\n    try:\n        points = ast.literal_eval(rest)\n    except Exception:\n        sys.exit(0)\n    result = find_min_arrows(points)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "points = [[10,16],[2,8],[1,6],[7,12]]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "points = [[1,2],[3,4],[5,6],[7,8]]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "points = [[1,2],[2,3],[3,4],[4,5]]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode123.json",
    "problem_index_in_file": 0,
    "title": "Best Time to Buy and Sell Stock III",
    "description_snippet": "You are given an array prices where prices[i] is the price of a given stock on the i^th day.\n\nFind t...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines step by step explaining logic. The task: max profit with at most two transactions, cannot hold multiple stocks simultaneously. Classic DP solution: use variables: firstBuy, firstSell, secondBuy, secondSell. Or four variables. Provide virtual code steps accordingly. Need to use Start, Decision, arrow. We can structure loops.\n\nWe need to output each line: \"Start // 程式開始執行\" etc. Then arrow lines.\n\nLet's design:\n\nStart\n→ Step 1: 初始化 firstBuy, firstSell, secondBuy, secondSell // 設定初值\n→ Step 2: 循環遍歷價格陣列 // 每天處理一次\n    → Decision: i > 0? // 只要有價格就更新\n        Yes → Step 3: 更新 firstBuy = max(firstBuy, -price) // 盡量低買入\n        Yes → Step 4: 更新 firstSell = max(firstSell, firstBuy + price) // 盡量高賣出\n        Yes → Step 5: 更新 secondBuy = max(secondBuy, firstSell - price) // 用第一次賣後再買\n        Yes → Step 6: 更新 secondSell = max(secondSell, secondBuy + price) // 第二次賣出\nEnd // 回傳最大利潤\n\nBut we need decisions? Actually the Decision line for \"i>0?\" not necessary; we can just process each element. Use Decision: if price < firstBuy? but easier: use formulas.\n\nSimpler: For each price:\n    firstBuy = max(firstBuy, -price)\n    firstSell = max(firstSell, firstBuy + price)\n    secondBuy = max(secondBuy, firstSell - price)\n    secondSell = max(secondSell, secondBuy + price)\n\nWe can show decision: if price < firstBuy? But we can still use formulas; no decision needed. But requirement: use Decision structure. We can incorporate decision: For each price, decide whether to update each variable; but we can just show assignment steps with comparison inside.\n\nWe can produce:\n\nStart\n→ Step 1: firstBuy ← -∞, firstSell ← 0, secondBuy ← -∞, secondSell ← 0 // 初始化\n→ Step 2: 循環 i 從 0 到 len(prices)-1 // 遍歷每天價格\n    → Decision: 取得價格 price = prices[i] // 取得當天價格\n        Yes → Step 3: firstBuy ← max(firstBuy, -price) // 更新第一次買入\n        Yes → Step 4: firstSell ← max(firstSell, firstBuy + price) // 更新第一次賣出\n        Yes → Step 5: secondBuy ← max(secondBuy, firstSell - price) // 更新第二次買入\n        Yes → Step 6: secondSell ← max(secondSell, secondBuy + price) // 更新第二次賣出\nEnd // 返回 secondSell // 最大利潤\n\nBut the Decision: \"取得價格 price = prices[i]\" not a decision but assignment. Could use Decision: price >? but not necessary. But requirement says to use Decision for decisions. We can skip decision and just use steps. But guidelines say use Decision and arrows. Maybe we can embed decision for each update: if -price > firstBuy? But better to keep simple. We could add Decision: 是否需要更新 firstBuy? but we can skip; the steps themselves contain max.\n\nOk final output with virtual code lines.\n\nNeed to include explanation after each line.\n\nLet's craft final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: firstBuy ← -∞, firstSell ← 0, secondBuy ← -∞, secondSell ← 0 // 初始化四個變數，分別表示第一次買入的最低成本、第一次賣出的最高利潤、第二次買入的最低成本、第二次賣出的最高利潤\n→ Step 2: 循環 i 從 0 到 len(prices)-1 // 逐日處理價格\n    → Decision: 取得今天的價格 price = prices[i] // 讀取當天股價\n        Yes → Step 3: firstBuy ← max(firstBuy, -price) // 盡可能以更低價格買入第一次\n        Yes → Step 4: firstSell ← max(firstSell, firstBuy + price) // 以第一次買入後的最高價賣出\n        Yes → Step 5: secondBuy ← max(secondBuy, firstSell - price) // 用第一次賣出所得利潤再以更低價格買入第二次\n        Yes → Step 6: secondSell ← max(secondSell, secondBuy + price) // 以第二次買入後的最高價賣出\nEnd // 程式執行結束，返回 secondSell 作為最多兩筆交易的最大利潤\n```",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def maxProfit(self, prices):\n        \"\"\"\n        計算最多兩筆交易的最大利潤\n        \"\"\"\n        if not prices:\n            return 0\n        buy1 = float('-inf')\n        sell1 = 0\n        buy2 = float('-inf')\n        sell2 = 0\n        for price in prices:\n            buy1 = max(buy1, -price)          # 盡可能低買入第一次\n            sell1 = max(sell1, buy1 + price)  # 盡可能高賣出第一次\n            buy2 = max(buy2, sell1 - price)   # 用第一次利潤再低買第二次\n            sell2 = max(sell2, buy2 + price)  # 盡可能高賣出第二次\n        return sell2\n\ndef parse_prices(input_str):\n    \"\"\"\n    從輸入字串中解析出價格列表。支援格式如：\n    'prices = [1,2,3,4]' 或僅 '[1,2,3,4]'\n    \"\"\"\n    try:\n        if '=' in input_str:\n            input_str = input_str.split('=', 1)[1]\n        return ast.literal_eval(input_str.strip())\n    except Exception:\n        return []\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    prices = parse_prices(data)\n    result = Solution().maxProfit(prices)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "prices = [3,3,5,0,0,3,1,4]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "prices = [1,2,3,4,5]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "prices = [7,6,4,3,1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode57.json",
    "problem_index_in_file": 0,
    "title": "Insert Interval",
    "description_snippet": "You are given an array of non-overlapping intervals intervals where intervals[i] = [start_i, end_i] ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step for merging intervals. Provide steps: iterate over intervals, add before, merge, after. Provide decisions. Use virtual code syntax.\n\nLet's outline algorithm:\n\n1. Create result list.\n2. For each interval in intervals:\n   - if interval.end < newInterval.start: no overlap, and before new interval: add to result.\n   - else if interval.start > newInterval.end: no overlap, after new interval: add newInterval if not added, then add rest intervals.\n   - else overlapping: merge: newInterval.start = min(newInterval.start, interval.start); newInterval.end = max(newInterval.end, interval.end).\n3. After loop, if newInterval not added, add it.\n4. Return result.\n\nWe need virtual code line by line. Use arrows. Include decisions.\n\nLet's produce:\n\nStart\n→ Step 1: 初始化 result 為空列表 // 用於儲存最終區間\n→ Step 2: 設 flag newAdded 為 False // 標記是否已將 newInterval 加入\n→ Decision: for each interval in intervals? // 迭代所有給定區間\n   Yes → Step 3: 取得 interval.start, interval.end // 讀取當前區間邊界\n   → Decision: interval.end < newInterval.start? // 在新區間前且無重疊\n       Yes → Step 4: 將 interval 加入 result // 直接加入\n       No  → Decision: interval.start > newInterval.end? // 在新區間後且無重疊\n           Yes → Decision: newAdded? // 是否已加入新區間\n               Yes → Step 5: 將 interval 加入 result // 新區間已加入，直接加入\n               No  → Step 6: 將 newInterval 加入 result // 新區間未加入，先加入\n                     → Step 7: newAdded = True // 標記已加入\n                     → Step 8: 將 interval 加入 result // 然後加入當前區間\n           No  → Step 9: newInterval.start = min(newInterval.start, interval.start) // 兩區間重疊，合併起始點\n                 → Step 10: newInterval.end = max(newInterval.end, interval.end) // 合併終止點\n→ Decision: 循環結束後是否已加入新區間? // 判斷最後是否還需要加入\n   Yes → Step 11: End // 已加入，直接結束\n   No  → Step 12: 將 newInterval 加入 result // 仍未加入，追加\n→ End // 回傳 result\n\nBut we need format: each line with `虛擬碼步驟 [空格] // 解釋`. Also need arrow `→`. We can use indentation maybe. Let's craft.\n\nStart // 程式開始執行\n→ Step 1: result ← [] // 建立結果列表\n→ Step 2: newAdded ← False // 標記是否已加入新區間\n→ Decision: For each interval in intervals? // 逐一遍歷所有區間\n    Yes → Step 3: curStart ← interval[0]; curEnd ← interval[1] // 取得當前區間\n    → Decision: curEnd < newInterval[0]? // 在新區間之前且不重疊\n        Yes → Step 4: Append interval to result // 直接加入結果\n        No  → Decision: curStart > newInterval[1]? // 在新區間之後且不重疊\n            Yes → Decision: newAdded? // 是否已加入新區間\n                Yes → Step 5: Append interval to result // 新區間已加入，直接加入\n                No  → Step 6: Append newInterval to result; newAdded ← True // 加入新區間\n                    → Step 7: Append interval to result // 再加入當前區間\n            No  → Step 8: newInterval[0] ← min(newInterval[0], curStart) // 合併起點\n                → Step 9: newInterval[1] ← max(newInterval[1], curEnd) // 合併終點\n→ Decision: newAdded? // 循環結束後檢查是否還需加入\n    Yes → End // 已加入，結束\n    No  → Step 10: Append newInterval to result // 仍未加入，追加\n→ End // 回傳結果\n\nWe need each line with virtual code. Use `Start`, `End`. Indentation not necessary but good.\n\nMake sure to use correct arrow. We'll produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: result ← [] // 建立結果列表\n→ Step 2: newAdded ← False // 標記是否已加入新區間\n→ Decision: For each interval in intervals? // 逐一遍歷所有區間\n    Yes → Step 3: curStart ← interval[0]; curEnd ← interval[1] // 取得當前區間的開始與結束\n    → Decision: curEnd < newInterval[0]? // 區間位於新區間之前且無重疊\n        Yes → Step 4: Append interval to result // 直接加入結果\n        No  → Decision: curStart > newInterval[1]? // 區間位於新區間之後且無重疊\n            Yes → Decision: newAdded? // 是否已將新區間加入\n                Yes → Step 5: Append interval to result // 新區間已加入，直接加入此區間\n                No  → Step 6: Append newInterval to result; newAdded ← True // 加入新區間並標記已加入\n                    → Step 7: Append interval to result // 再加入當前區間\n            No  → Step 8: newInterval[0] ← min(newInterval[0], curStart) // 合併重疊區間的起點\n                → Step 9: newInterval[1] ← max(newInterval[1], curEnd) // 合併重疊區間的終點\n→ Decision: newAdded? // 迴圈結束後檢查是否仍需加入新區間\n    Yes → End // 已加入，程式結束\n    No  → Step 10: Append newInterval to result // 新區間仍未加入，追加至結果\n→ End // 回傳最終合併後的區間列表",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def insert(self, intervals, newInterval):\n        result = []\n        i = 0\n        n = len(intervals)\n\n        # Add all intervals that end before the new interval starts\n        while i < n and intervals[i][1] < newInterval[0]:\n            result.append(intervals[i])\n            i += 1\n\n        # Merge all overlapping intervals with newInterval\n        while i < n and intervals[i][0] <= newInterval[1]:\n            newInterval[0] = min(newInterval[0], intervals[i][0])\n            newInterval[1] = max(newInterval[1], intervals[i][1])\n            i += 1\n\n        # Insert the merged interval\n        result.append(newInterval)\n\n        # Add the remaining intervals\n        while i < n:\n            result.append(intervals[i])\n            i += 1\n\n        return result\n\ndef main():\n    data = sys.stdin.read().strip()\n    # 找出兩個列表字串\n    matches = re.findall(r'\\[.*?\\]', data)\n    if len(matches) < 2:\n        print([])\n        return\n    intervals = eval(matches[0])\n    newInterval = eval(matches[1])\n\n    sol = Solution()\n    merged = sol.insert(intervals, newInterval)\n    print(merged)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "intervals = [[1,3],[6,9]], newInterval = [2,5]",
          "expected_output": "[[1,5],[6,9]]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpwgiusyha.py\", line 46, in <module>\n    main()\n  File \"/tmp/tmpwgiusyha.py\", line 38, in main\n    intervals = eval(matches[0])\n                ^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [[1,3]\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]",
          "expected_output": "[[1,2],[3,10],[12,16]]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpdx5l8ik6.py\", line 46, in <module>\n    main()\n  File \"/tmp/tmpdx5l8ik6.py\", line 38, in main\n    intervals = eval(matches[0])\n                ^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [[1,2]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode20.json",
    "problem_index_in_file": 0,
    "title": "Valid Parentheses",
    "description_snippet": "Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the in...",
    "examples_loaded": 5,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for checking balanced parentheses. Use stack, push on open, pop on close and match types. Steps line by line with explanation. Use arrow notation. Provide start, decision, etc.\n\nNeed to ensure format exactly: each line: \"虛擬碼步驟 [space] // 解釋\". Use arrow characters like \"→\" for next step. Use indentation for nested decision.\n\nWe'll produce something like:\n\nStart // 程式開始執行\n→ Step 1: 建立一個空棧 Stack // 用來存儲開括號\n→ Step 2: 循環遍歷字串 s 中的每個字符 c // 逐個檢查\n    → Decision: 如果 c 是開括號? // 判斷是否為 '('、'{' 或 '['\n        Yes → Step 3: 把 c 推入 Stack // 存儲開括號\n        No  → Decision: 如果 c 是閉括號? // 判斷是否為 ')'、'}' 或 ']'\n            Yes → Step 4: 如果 Stack 為空? // 無對應開括號\n                Yes → Step 5: 返回 False // 字串無效\n                No  → Step 6: 從 Stack 彈出 top // 取最近的開括號\n                    → Decision: top 與 c 是否匹配? // 比較類型\n                        Yes → Step 7: 繼續下一個字符 // 匹配成功\n                        No  → Step 8: 返回 False // 類型不符\n            No  → Step 9: // 不是括號，忽略或錯誤處理\n→ Step 10: 循環結束後 // 所有字符已處理\n    → Decision: Stack 是否為空? // 檢查是否所有開括號已匹配\n        Yes → Step 11: 返回 True // 字串有效\n        No  → Step 12: 返回 False // 未匹配的開括號殘留\nEnd // 程式執行結束\n\nMake sure each line ends with \"// 解釋\". Ensure arrow notation. Provide no code.\n\nCheck formatting: use arrow with space after. Should include \"Start //\". Use \"End //\".\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立一個空棧 Stack // 用來存儲開括號  \n→ Step 2: 循環遍歷字串 s 中的每個字符 c // 逐個檢查  \n → Decision: 如果 c 是開括號? // 判斷是否為 '('、'{' 或 '['  \n  Yes → Step 3: 把 c 推入 Stack // 存儲開括號  \n  No  → Decision: 如果 c 是閉括號? // 判斷是否為 ')'、'}' 或 ']'  \n   Yes → Step 4: 如果 Stack 為空? // 無對應開括號  \n    Yes → Step 5: 返回 False // 字串無效  \n    No  → Step 6: 從 Stack 彈出 top // 取最近的開括號  \n     → Decision: top 與 c 是否匹配? // 比較類型  \n      Yes → Step 7: 繼續下一個字符 // 匹配成功  \n      No  → Step 8: 返回 False // 類型不符  \n   No  → Step 9: // 不是括號，忽略或錯誤處理  \n→ Step 10: 循環結束後 // 所有字符已處理  \n → Decision: Stack 是否為空? // 檢查是否所有開括號已匹配  \n  Yes → Step 11: 返回 True // 字串有效  \n  No  → Step 12: 返回 False // 未匹配的開括號殘留  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def isValid(self, s: str) -> bool:\n        \"\"\"\n        Determine if the input string s containing only brackets is valid.\n        A string is valid if every opening bracket has a corresponding closing bracket\n        of the same type and the brackets are correctly nested.\n        \"\"\"\n        stack = []\n        mapping = {')': '(', '}': '{', ']': '['}\n\n        for char in s:\n            if char in mapping:          # char is a closing bracket\n                top_element = stack.pop() if stack else '#'\n                if mapping[char] != top_element:\n                    return False\n            else:                         # char is an opening bracket\n                stack.append(char)\n        return not stack\n\ndef _extract_bracket_string(raw_input: str) -> str:\n    \"\"\"\n    Extract the bracket string from the raw input.\n    Handles inputs like 's = \"()\"', \"s = '()'\", or simply \"()\".\n    \"\"\"\n    raw_input = raw_input.strip()\n    if not raw_input:\n        return ''\n\n    # Try double quotes\n    start = raw_input.find('\"')\n    end = raw_input.rfind('\"')\n    if 0 <= start < end:\n        return raw_input[start + 1:end]\n\n    # Try single quotes\n    start = raw_input.find(\"'\")\n    end = raw_input.rfind(\"'\")\n    if 0 <= start < end:\n        return raw_input[start + 1:end]\n\n    # Fallback: return the whole line\n    return raw_input\n\ndef main():\n    raw = sys.stdin.read()\n    s = _extract_bracket_string(raw)\n    solution = Solution()\n    is_valid = solution.isValid(s)\n    print('true' if is_valid else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"()\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "s = \"()[]{}\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "s = \"(]\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 3,
          "input": "s = \"([])\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 4,
          "input": "s = \"([)]\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode204.json",
    "problem_index_in_file": 0,
    "title": "Count Primes",
    "description_snippet": "Given an integer n, return the number of prime numbers that are strictly less than n....",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code with explanations. The user says: \"Given an integer n, return the number of prime numbers that are strictly less than n.\" So the algorithm: count primes less than n. Use Sieve of Eratosthenes or simple approach. We need to produce step-by-step virtual code with explanations. Must adhere to format: each line \"虛擬碼步驟\" + space + \"// 解釋/說明\". Use arrows, Start, End, Decision. Each step. Should cover input, initialization, sieve, counting, output.\n\nWe can do:\n\nStart\n→ Input n\n→ Decision: n <= 2? (since primes less than 2 is 0)\n    Yes → Return 0\n    No → Continue\n→ Step: Create boolean array isPrime[0..n-1] all true // initial assumption\n→ Step: Set isPrime[0] = false; isPrime[1] = false // 0,1 not primes\n→ Step: For i from 2 to sqrt(n-1):\n        Decision: if isPrime[i]? \n            Yes → For j from i*i to n-1 step i: isPrime[j] = false\n            No → Do nothing\n→ Step: Count primes: count = 0\n→ Step: For i from 2 to n-1: if isPrime[i] count++\n→ Step: Return count\nEnd\n\nWe need to add comments. Ensure each line uses 虛擬碼.\n\nUse arrows \"→\". For decision, indent child steps with tabs or spaces? In sample, they used indent. Use spaces: indent lines under decision. We'll match style.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input n // 取得使用者輸入的整數 n  \n→ Decision: n <= 2? // 如果 n 小於等於 2，則沒有小於 n 的質數  \n  Yes → Step: Return 0 // 回傳 0，因為 2 以下沒有質數  \n  No → Step: Create array isPrime[0 … n-1] all true // 初始化假設所有數字都是質數  \n→ Step: Set isPrime[0] = false; isPrime[1] = false // 0 與 1 不是質數  \n→ Step: For i = 2 to floor(sqrt(n-1)) // 只需檢查到 sqrt(n-1)  \n  Decision: isPrime[i] is true? // 這個數字本身是否還被標記為質數  \n   Yes → Step: For j = i*i to n-1 step i // 標記所有 i 的倍數為非質數  \n      Set isPrime[j] = false  \n      End  \n      End  \n   No → Step: // 當前 i 已被標記為非質數，跳過  \n      // (此處無需執行任何操作)  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \n      End  \nEnd // 程式結束執行",
      "generated_code": "import sys\nimport re\nimport math\n\nclass Solution:\n    def countPrimes(self, n: int) -> int:\n        \"\"\"\n        使用埃拉托斯特尼筛法统计小于 n 的质数个数。\n        \"\"\"\n        if n <= 2:\n            return 0\n        is_prime = [True] * n\n        is_prime[0] = is_prime[1] = False\n        limit = int(math.isqrt(n - 1))  # 只需检查到 sqrt(n-1)\n        for i in range(2, limit + 1):\n            if is_prime[i]:\n                # 以 i*i 为起点，步长为 i，标记所有 i 的倍数\n                start = i * i\n                for j in range(start, n, i):\n                    is_prime[j] = False\n        return sum(is_prime)\n\ndef main() -> None:\n    # 读取所有输入并提取第一个整数\n    data = sys.stdin.read()\n    nums = re.findall(r'-?\\d+', data)\n    if not nums:\n        # 如果没有找到整数，默认 0\n        n = 0\n    else:\n        n = int(nums[0])\n\n    solver = Solution()\n    result = solver.countPrimes(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 10",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "n = 0",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 2,
          "input": "n = 1",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode264.json",
    "problem_index_in_file": 0,
    "title": "Ugly Number II",
    "description_snippet": "An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5. \n\nGiven an inte...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode step by step for algorithm to find nth ugly number. Classic DP with pointers for multiples of 2,3,5. Provide step-by-step pseudocode lines, each with explanation. Must not output actual code, only virtual code. Use arrows, decisions. Provide steps sequentially: Start, read n, initialize array, pointers, loop i from 1 to n, calculate next ugly, update pointers, after loop output nth ugly, End. Also need decision on whether n == 1 maybe. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入正整數 n // 從使用者取得要找的第 n 個丑數  \n→ Decision: n 是否等於 1? // 檢查是否為最小的丑數  \n  Yes → Step 2: 輸出 1 // 1 本身即為丑數  \n  No  →  \n   → 初始化陣列 ugly[1..n]，設定 ugly[1] = 1 // 存儲前 n 個丑數  \n   → 設定指標 i2 = 1, i3 = 1, i5 = 1 // 分別對應 2, 3, 5 的倍數位置  \n   → 設定 next2 = 2, next3 = 3, next5 = 5 // 初始下一個候選丑數  \n   → Loop i from 2 to n // 從第二個丑數開始計算  \n    → Step 3: ugly[i] = min(next2, next3, next5) // 取最小候選值作為第 i 個丑數  \n    → Decision: ugly[i] 等於 next2?  \n      Yes → i2 ← i2 + 1 // 移動指標 i2  \n        next2 = ugly[i2] * 2 // 更新下一個 2 的候選值  \n      No → // 不改 i2  \n      Decision: ugly[i] 等於 next3?  \n       Yes → i3 ← i3 + 1 // 移動指標 i3  \n         next3 = ugly[i3] * 3 // 更新下一個 3 的候選值  \n       No → // 不改 i3  \n      Decision: ugly[i] 等於 next5?  \n       Yes → i5 ← i5 + 1 // 移動指標 i5  \n          next5 = ugly[i5] * 5 // 更新下一個 5 的候選值  \n       No → // 不改 i5  \n    → End Loop  \n   → Step 4: 輸出 ugly[n] // 顯示第 n 個丑數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def nthUglyNumber(self, n: int) -> int:\n        \"\"\"Return the nth ugly number (prime factors only 2, 3, 5).\"\"\"\n        ugly = [1]\n        i2 = i3 = i5 = 0  # pointers for multiples of 2, 3, 5\n\n        while len(ugly) < n:\n            next2, next3, next5 = ugly[i2] * 2, ugly[i3] * 3, ugly[i5] * 5\n            next_ugly = min(next2, next3, next5)\n            ugly.append(next_ugly)\n\n            if next_ugly == next2:\n                i2 += 1\n            if next_ugly == next3:\n                i3 += 1\n            if next_ugly == next5:\n                i5 += 1\n\n        return ugly[-1]\n\ndef main() -> None:\n    # Read entire input, strip whitespace, and extract the first integer found.\n    data = sys.stdin.read().strip()\n    # Use regex to find an integer in the input.\n    match = re.search(r'\\d+', data)\n    if not match:\n        return  # No integer found; nothing to do.\n    n = int(match.group())\n\n    sol = Solution()\n    result = sol.nthUglyNumber(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 10",
          "expected_output": "12",
          "success": true,
          "output": "12"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode316.json",
    "problem_index_in_file": 0,
    "title": "Remove Duplicate Letters",
    "description_snippet": "Given a string s, remove duplicate letters so that every letter appears once and only once. You must...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for removing duplicate letters and obtaining smallest lexicographic order. Essentially Leetcode 316. Use stack, visited, last index map.\n\nWe produce virtual steps line by line, with arrows.\n\nWe need to follow format exactly: \"虛擬碼步驟 [space] // 解釋\". Use Start, End, Decision.\n\nWe must not output actual code.\n\nSo produce pseudo steps:\n\nStart\n→ Step 1: 建立空堆疊 `stack` // 用於構建結果字串\n→ Step 2: 建立布林陣列 `visited[26]` 設為 false // 標記字母是否已在堆疊中\n→ Step 3: 建立字典 `lastIndex` 將每個字母映射到其最後一次出現的位置 // 用於決定是否能刪除已在堆疊中的字母\n→ Step 4: 迭代遍歷字符串 `s`，索引為 `i`, 字母為 `c`\n    → Decision: 是否已訪問 `c`?\n        Yes → Continue to next character // 已在堆疊，跳過\n        No → Decision: 是否可以從堆疊中彈出更小字母\n            → While `stack` 不是空且 `c` < stack.top() 且 `i` < lastIndex[stack.top()]`\n                → Step 5: 從 `stack` 彈出 `topChar` // 移除堆疊頂部字母\n                → Step 6: 將 `visited[topChar]` 設為 false // 標記字母已被移除\n            → Step 7: 將 `c` 推入 `stack` // 添加當前字母\n            → Step 8: 將 `visited[c]` 設為 true // 標記字母已在堆疊\n→ Step 9: 將堆疊中的字母連接成字符串 `result` // 生成最終結果\nEnd\n\nNeed to ensure each line has format. Include arrows, indent decisions with spaces and arrows? Format example uses indentation: \"→ Decision: ...\" etc.\n\nWe should format like:\n\nStart // 程式開始執行\n→ Step 1: 初始化堆疊 stack // 用於構造結果\n→ Step 2: 初始化 visited 陣列 // 標記字母是否已存在\n→ Step 3: 建立 lastIndex 映射 // 儲存每個字母最後出現位置\n→ Step 4: 循環遍歷字符串 s，索引 i\n    → Decision: 字母 s[i] 是否已訪問？\n        Yes → Continue // 跳過已存在字母\n        No → Decision: 是否可以刪除堆疊中較大的字母？\n            → While ... // loop\n                → Step 5: 彈出頂部字母\n                → Step 6: 標記已訪問 false\n            → Step 7: 推入當前字母\n            → Step 8: 標記已訪問 true\n→ Step 9: 把堆疊轉成字符串 result\nEnd\n\nWe need to ensure each line has \"虛擬碼步驟 // 解釋\". Provide explanation in Chinese.\n\nLet's produce each line.\n\nWe might need to indicate the while loop lines as separate steps.\n\nLet's enumerate:\n\n1 Start // 程式開始執行\n2 → Step 1: 初始化空堆疊 stack // 用於構造最終字串\n3 → Step 2: 初始化布林陣列 visited[26] 為 false // 標記每個字母是否已在堆疊\n4 → Step 3: 建立字典 lastIndex，將每個字母映射到其最後一次出現索引 // 用於判斷是否能刪除\n5 → Step 4: 逐字符遍歷字符串 s，索引為 i，字符為 c\n    6   → Decision: c 是否已訪問？\n        7     Yes → Continue // 跳過已存在的字母\n        8     No → Decision: 是否可以從堆疊中彈出更小字母？\n            9       → While stack 非空且 c < stack.top() 且 i < lastIndex[stack.top()]\n                10          → Step 5: 彈出 stack.top() 為 topChar // 移除較大字母\n                11          → Step 6: visited[topChar] 設為 false // 標記已被移除\n            12      → Step 7: 將 c 推入 stack // 添加當前字母\n            13      → Step 8: visited[c] 設為 true // 標記已在堆疊\n14 → Step 9: 將 stack 內字母連接成字符串 result // 生成最終答案\n15 End // 程式執行結束\n\nMake sure each line contains arrow or indent. Use \"→\" at start of each line, but decisions are indented.\n\nThe example shows indentation inside decisions. Use spaces.\n\nThus final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空堆疊 stack // 用於構造最終字串  \n→ Step 2: 初始化布林陣列 visited[26] 為 false // 標記每個字母是否已在堆疊  \n→ Step 3: 建立字典 lastIndex，將每個字母映射到其最後一次出現索引 // 用於判斷是否能刪除  \n→ Step 4: 逐字符遍歷字符串 s，索引為 i，字符為 c  \n    → Decision: c 是否已訪問？  \n        Yes → Continue // 跳過已存在的字母  \n        No → Decision: 是否可以從堆疊中彈出更小字母？  \n            → While stack 非空且 c < stack.top() 且 i < lastIndex[stack.top()]  \n                → Step 5: 彈出 stack.top() 為 topChar // 移除較大字母  \n                → Step 6: visited[topChar] 設為 false // 標記已被移除  \n            → Step 7: 將 c 推入 stack // 添加當前字母  \n            → Step 8: visited[c] 設為 true // 標記已在堆疊  \n→ Step 9: 將 stack 內字母連接成字符串 result // 生成最終答案  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def removeDuplicateLetters(self, s: str) -> str:\n        stack = []\n        seen = set()\n        last_occurrence = {c: i for i, c in enumerate(s)}\n        for i, c in enumerate(s):\n            if c not in seen:\n                while stack and c < stack[-1] and i < last_occurrence[stack[-1]]:\n                    seen.discard(stack.pop())\n                stack.append(c)\n                seen.add(c)\n        return ''.join(stack)\n\ndef parse_input(data: str) -> str:\n    # 支援 \"s = \\\"bcabc\\\"\" 或簡單的 bcabc\n    data = data.strip()\n    if not data:\n        return \"\"\n    # 若包含 '='，取等號後的部分\n    if \"=\" in data:\n        _, value = data.split(\"=\", 1)\n        data = value.strip()\n    # 移除可能存在的引號\n    if (data.startswith('\"') and data.endswith('\"')) or (data.startswith(\"'\") and data.endswith(\"'\")):\n        data = data[1:-1]\n    return data\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    s = parse_input(raw_input)\n    solution = Solution()\n    result = solution.removeDuplicateLetters(s)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"bcabc\"",
          "expected_output": "\"abc\"",
          "success": true,
          "output": "abc"
        },
        {
          "example_index": 1,
          "input": "s = \"cbacdcbc\"",
          "expected_output": "\"acdb\"",
          "success": true,
          "output": "acdb"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode432.json",
    "problem_index_in_file": 0,
    "title": "All O`one Data Structure",
    "description_snippet": "Design a data structure to store the strings' count with the ability to return the strings with mini...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode lines with explanation comments. Need to design data structure: all-one using doubly linked list of buckets (counts) and hash maps. Steps: Start, maintain key->node, bucket nodes with count and key set. inc, dec operations. getMaxKey getMinKey. Each O(1).\n\nWe produce pseudocode lines sequentially. Should show Start, define data structures, then methods inc, dec, getMaxKey, getMinKey. Use arrow notation.\n\nLet's craft.\n\nAlso we need to be careful to use \"Decision:\" for branching.\n\nWe'll produce lines like:\n\nStart // 程式開始執行\n→ Define Node {count, set of keys, prev, next} // 定義桶節點結構\n→ Define head, tail dummy nodes, link them // 初始空雙向鏈表\n→ Define keyMap: key -> node reference // key 到桶的映射\n→ Define countMap: count -> node reference // count 到桶的映射\n\nThen inc: Steps.\n\nWe'll produce each line as separate pseudocode step. Use arrow.\n\nLet's craft.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Define Node {count, keys, prev, next} // 定義桶節點，包含計數、鍵集合以及雙向鏈表指標  \n→ Create dummy head node (count = -∞) // 頭部哨兵，始終最小  \n→ Create dummy tail node (count = ∞) // 尾部哨兵，始終最大  \n→ Link head.next = tail, tail.prev = head // 建立空雙向鏈表  \n→ Define keyMap: key → Node // 儲存每個鍵對應的桶節點  \n→ Define countMap: count → Node // 儲存每個計數對應的桶節點  \n\n// ---------- inc 方法 ----------\n→ Define inc(key) // 開始處理遞增操作  \n    → If key ∈ keyMap: // 鍵已存在  \n        → node ← keyMap[key] // 取得現有節點  \n        → newCount ← node.count + 1 // 計算新計數  \n        → node.keys.remove(key) // 從舊節點移除鍵  \n        → If newCount ∈ countMap: // 下一個計數已存在節點  \n            → targetNode ← countMap[newCount] // 取得目標節點  \n            → targetNode.keys.add(key) // 加入鍵  \n            → keyMap[key] ← targetNode // 更新鍵映射  \n        → Else: // 下一個計數不存在，需新建節點  \n            → targetNode ← new Node(newCount, {key}) // 建立新節點  \n            → Insert targetNode after node // 插入到鏈表中  \n            → countMap[newCount] ← targetNode // 更新計數映射  \n            → keyMap[key] ← targetNode // 更新鍵映射  \n        → If node.keys is empty: // 原節點已空  \n            → Remove node from linked list  \n            → Remove node.count from countMap // 清除空節點的計數映射  \n    → Else: // 鍵不存在，從 1 開始  \n        → If 1 ∈ countMap: // 已有計數 1 的節點  \n            → node1 ← countMap[1]  \n            → node1.keys.add(key)  \n            → keyMap[key] ← node1  \n        → Else: // 建立新節點  \n            → node1 ← new Node(1, {key})  \n            → Insert node1 after head // 在最小哨兵後插入  \n            → countMap[1] ← node1  \n            → keyMap[key] ← node1  \nEnd // inc 方法結束  \n\n// ---------- dec 方法 ----------\n→ Define dec(key) // 開始處理遞減操作  \n    → node ← keyMap[key] // 取得當前節點（保證存在）  \n    → newCount ← node.count - 1 // 計算新計數  \n    → node.keys.remove(key) // 從舊節點移除鍵  \n    → If newCount = 0: // 計數降至 0，移除鍵  \n        → keyMap.remove(key) // 刪除鍵映射  \n    → Else: // 仍有正計數  \n        → If newCount ∈ countMap: // 下一節點存在  \n            → targetNode ← countMap[newCount]  \n            → targetNode.keys.add(key)  \n            → keyMap[key] ← targetNode  \n        → Else: // 新建節點  \n            → targetNode ← new Node(newCount, {key})  \n            → Insert targetNode before node // 插入到鏈表中  \n            → countMap[newCount] ← targetNode  \n            → keyMap[key] ← targetNode  \n    → If node.keys is empty: // 原節點已空  \n        → Remove node from linked list  \n        → Remove node.count from countMap // 清除空節點的計數映射  \nEnd // dec 方法結束  \n\n// ---------- getMaxKey 方法 ----------\n→ Define getMaxKey() // 取得最大計數鍵  \n    → If head.next == tail: // 空結構  \n        → Return \"\" // 無元素  \n    → Else:  \n        → Return any key from head.next.keys // 最大節點的任意鍵  \nEnd // getMaxKey 方法結束  \n\n// ---------- getMinKey 方法 ----------\n→ Define getMinKey() // 取得最小計數鍵  \n    → If head.next == tail: // 空結構  \n        → Return \"\" // 無元素  \n    → Else:  \n        → Return any key from head.next.keys // 最小節點的任意鍵  \nEnd // getMinKey 方法結束  \n\nEnd // AllOne 結構完成執行流程",
      "generated_code": "import sys\nimport json\n\nclass Node:\n    def __init__(self):\n        self.keys = set()\n        self.prev = None\n        self.next = None\n        self.count = 0\n\nclass AllOne:\n    def __init__(self):\n        self.head = Node()\n        self.tail = Node()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n        self.key_to_node = {}\n\n    def _insert_after(self, prev_node, count):\n        node = Node()\n        node.count = count\n        node.prev = prev_node\n        node.next = prev_node.next\n        prev_node.next.prev = node\n        prev_node.next = node\n        return node\n\n    def _remove(self, node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\n    def inc(self, key):\n        if key in self.key_to_node:\n            node = self.key_to_node[key]\n            next_count = node.count + 1\n            if node.next == self.tail or node.next.count > next_count:\n                new_node = self._insert_after(node, next_count)\n            else:\n                new_node = node.next\n            new_node.keys.add(key)\n            self.key_to_node[key] = new_node\n            node.keys.remove(key)\n            if not node.keys:\n                self._remove(node)\n        else:\n            if self.head.next == self.tail or self.head.next.count > 1:\n                new_node = self._insert_after(self.head, 1)\n            else:\n                new_node = self.head.next\n            new_node.keys.add(key)\n            self.key_to_node[key] = new_node\n\n    def dec(self, key):\n        if key not in self.key_to_node:\n            return\n        node = self.key_to_node[key]\n        prev_count = node.count - 1\n        node.keys.remove(key)\n        if prev_count == 0:\n            del self.key_to_node[key]\n        else:\n            if node.prev == self.head or node.prev.count < prev_count:\n                new_node = self._insert_after(node.prev, prev_count)\n            else:\n                new_node = node.prev\n            new_node.keys.add(key)\n            self.key_to_node[key] = new_node\n        if not node.keys:\n            self._remove(node)\n\n    def getMaxKey(self):\n        if self.tail.prev == self.head:\n            return \"\"\n        return next(iter(self.tail.prev.keys))\n\n    def getMinKey(self):\n        if self.head.next == self.tail:\n            return \"\"\n        return next(iter(self.head.next.keys))\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    # Skip possible \"Input\" line\n    if data[0].strip() == \"Input\":\n        data = data[1:]\n    ops = json.loads(data[0].strip())\n    args = json.loads(data[1].strip()) if len(data) > 1 else []\n\n    outputs = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"AllOne\":\n            obj = AllOne()\n            outputs.append(None)\n        elif op == \"inc\":\n            obj.inc(arg[0])\n            outputs.append(None)\n        elif op == \"dec\":\n            obj.dec(arg[0])\n            outputs.append(None)\n        elif op == \"getMaxKey\":\n            outputs.append(obj.getMaxKey())\n        elif op == \"getMinKey\":\n            outputs.append(obj.getMinKey())\n    print(\"Output\")\n    print(json.dumps(outputs))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "Input\n[\"AllOne\", \"inc\", \"inc\", \"getMaxKey\", \"getMinKey\", \"inc\", \"getMaxKey\", \"getMinKey\"]\n[[], [\"hello\"], [\"hello\"], [], [], [\"leet\"], [], []]",
          "expected_output": "Output\n[null, null, null, \"hello\", \"hello\", null, \"hello\", \"leet\"]",
          "success": true,
          "output": "Output\n[null, null, null, \"hello\", \"hello\", null, \"hello\", \"leet\"]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode344.json",
    "problem_index_in_file": 0,
    "title": "Reverse String",
    "description_snippet": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for reversing a string represented as an array of characters s, in-place, O(1) memory. Provide line-by-line with arrows and comments. Follow format: each line \"虛擬碼步驟 // 解釋/說明\". Use Start, End, Decision, etc. Let's craft steps:\n\nStart\n→ Step 1: 初始化 left = 0 // 左指針指向首位\n→ Step 2: 初始化 right = length(s) - 1 // 右指針指向末位\n→ Decision: 如果 left < right? // 確保還有未交換的元素\n    Yes → Step 3: 交換 s[left] 與 s[right] // 交換兩端字符\n    Yes → Step 4: left = left + 1 // 移動左指針\n    Yes → Step 5: right = right - 1 // 移動右指針\n    No → End // 完成反轉\n\nWe should format each step line separately. The decision branch includes Yes and No lines.\n\nThe instructions: Use 虛擬碼箭頭 → and structure. Each line: \"虛擬碼步驟 // 解釋\". Use \"Decision:\" lines for if. Indentation for Yes and No.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 left = 0 // 左指針指向陣列首位  \n→ Step 2: 初始化 right = length(s) - 1 // 右指針指向陣列末位  \n→ Decision: 如果 left < right? // 確認還有未交換的元素  \n    Yes → Step 3: 交換 s[left] 與 s[right] // 交換兩端字符  \n    Yes → Step 4: left = left + 1 // 移動左指針往右  \n    Yes → Step 5: right = right - 1 // 移動右指針往左  \n    No  → End // 反轉完成，結束程式執行",
      "generated_code": "class Solution:\n    def reverseString(self, s):\n        left, right = 0, len(s) - 1\n        while left < right:\n            s[left], s[right] = s[right], s[left]\n            left += 1\n            right -= 1\n\ndef main():\n    import sys, ast, json\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 去掉可能的「s =」前綴\n    if data.startswith('s ='):\n        data = data.split('=', 1)[1].strip()\n    # 解析成列表\n    s = ast.literal_eval(data)\n    sol = Solution()\n    sol.reverseString(s)\n    # 用 JSON 格式輸出，元素為雙引號\n    print(json.dumps(s))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = [\"h\",\"e\",\"l\",\"l\",\"o\"]",
          "expected_output": "[\"o\",\"l\",\"l\",\"e\",\"h\"]",
          "success": true,
          "output": "[\"o\", \"l\", \"l\", \"e\", \"h\"]"
        },
        {
          "example_index": 1,
          "input": "s = [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]",
          "expected_output": "[\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]",
          "success": true,
          "output": "[\"h\", \"a\", \"n\", \"n\", \"a\", \"H\"]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode2220.json",
    "problem_index_in_file": 0,
    "title": "Minimum Bit Flips to Convert Number",
    "description_snippet": "A bit flip of a number x is choosing a bit in the binary representation of x and flipping it from ei...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need virtual code algorithm to compute minimum bit flips to convert start to goal. This is basically Hamming distance between binary representations of start and goal, including leading zeros? Wait leading zeros not shown, but you can flip any bit including leading zeros. But flipping leading zeros beyond current bit-length effectively increases number of bits. Minimum flips would be number of differing bits in binary representations of start and goal when aligned to same length? But you can flip leading zeros of start or goal. Actually flipping leading zeros could increase bit-length. Suppose start=1 (1), goal=8 (1000). Bits: 1 vs 1000. We can flip bit 4 (leading zero in start) to 1 to get 1001? Wait flipping leading zeros: start=0001, goal=1000. Hamming distance: bits differ at positions 1 (from right) 1 vs 0? Actually 0001 vs 1000: positions: bit0: 1 vs 0 diff; bit1:0 vs0 same; bit2:0 vs0 same; bit3:0 vs1 diff => 2 flips. So Hamming distance of binary strings of length equal to max bit-length of start and goal. So algorithm: compute XOR of start and goal, count number of set bits in XOR. That's minimum flips. That's standard.\n\nThus produce virtual code: Start → compute XOR → count bits set → return count → End. Also maybe handle negative? Not needed. Provide explanation.\n\nAlso maybe use decision: None. Just linear steps.\n\nThus produce virtual code with arrows and explanation each line. Use Start, End. Provide virtual code.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算 xor = start XOR goal // 取得兩數的位差，只有不同位為 1  \n→ Step 2: 計算 flips = count_ones(xor) // 逐位計算 xor 中 1 的個數，即需翻轉的位數  \n→ Step 3: 輸出 flips // 回傳最少翻轉次數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef min_bit_flips(start: int, goal: int) -> int:\n    \"\"\"\n    計算將 start 轉換成 goal 所需的最小位元翻轉次數。\n    方式：先對兩個數進行 XOR，得到不同位元的位置。\n    再計算 XOR 結果中 1 的個數，即為翻轉次數。\n    \"\"\"\n    xor = start ^ goal\n    # Python 3.8+ 可直接使用 int.bit_count()\n    if hasattr(int, \"bit_count\"):\n        return xor.bit_count()\n    # 其它版本可用 bin() 方式計數\n    return bin(xor).count(\"1\")\n\ndef main() -> None:\n    \"\"\"\n    從標準輸入讀取「start = 10, goal = 7」等格式的資料，\n    解析出兩個整數後計算並輸出最小翻轉次數。\n    \"\"\"\n    data = sys.stdin.read()\n    # 取得所有整數，允許負數\n    nums = re.findall(r\"-?\\d+\", data)\n    if len(nums) < 2:\n        return  # 無足夠輸入，直接結束\n    start, goal = int(nums[0]), int(nums[1])\n    result = min_bit_flips(start, goal)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "start = 10, goal = 7",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "start = 3, goal = 4",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode767.json",
    "problem_index_in_file": 0,
    "title": "Reorganize String",
    "description_snippet": "Given a string s, rearrange the characters of s so that any two adjacent characters are not the same...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for the rearrange string problem, with steps. Use arrow syntax and explanation. Provide each line with 虛擬碼步驟 + // 解釋/說明.\n\nWe need to generate virtual code step-by-step. Must be in Chinese. Each line preceded by arrow or Start/End etc.\n\nLet's design algorithm: Use max heap of character counts. While heap not empty, pop top two, append to result, decrement, push back if remaining. Finally check if last char same as first? Actually algorithm ensures no adjacent duplicates. But need to handle when leftover char >1 impossible.\n\nSimpler: Use priority queue.\n\nSteps:\n\nStart\n→ Step 1: Count frequency of each char // 统计每个字符出现次数\n→ Step 2: Build max-heap based on frequency // 按频率降序排列\n→ Decision: 是否存在字符频率 > (len(s)+1)/2? // 判断是否可重排\n    Yes → Step 3: 返回 \"\" // 不可行\n    No  → Step 4: 初始化结果列表 // 结果字符串\n→ Step 5: While heap size > 1\n    → Step 5.1: Pop first char a with count ca\n    → Step 5.2: Pop second char b with count cb\n    → Step 5.3: Append a to result\n    → Step 5.4: Append b to result\n    → Step 5.5: Decrement ca, cb\n    → Step 5.6: If ca > 0 push a back\n    → Step 5.7: If cb > 0 push b back\n→ Decision: heap size == 1?\n    Yes → Step 6: Pop remaining char c\n        → Step 6.1: If result last char == c → return \"\" // 不能相邻\n        → Step 6.2: Append c to result\n    No  → // nothing\n→ Step 7: 将结果列表转为字符串\n→ End\n\nWe need to use virtual arrows. Provide each line separately.\n\nMake sure each line: 虛擬碼步驟 + [space] + // 解釋.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Count frequency of each character in s // 先統計每個字元的出現次數  \n→ Step 2: Build a max‑heap (priority queue) sorted by frequency // 建立一個以頻率為鍵的最大堆  \n→ Decision: 是否存在字元頻率 > (len(s)+1)/2? // 判斷是否能重排  \n    Yes → Step 3: Return \"\" // 若最頻繁字元超過可允許值，直接返回空字串  \n    No  → Step 4: Initialize empty result list // 若可行，準備存放結果  \n→ Step 5: While heap size > 1  \n    → Step 5.1: Pop top char a with count ca // 取出頻率最高的兩個字元  \n    → Step 5.2: Pop next char b with count cb  \n    → Step 5.3: Append a to result // 把 a 放進結果  \n    → Step 5.4: Append b to result // 再放入 b，確保不相鄰  \n    → Step 5.5: Decrement ca, cb // 兩個字元次數減 1  \n    → Step 5.6: If ca > 0 push a back into heap // 若還有剩餘，重新加入堆  \n    → Step 5.7: If cb > 0 push b back into heap  \n→ Decision: 是否剩下一個字元在堆中？  \n    Yes → Step 6: Pop remaining char c with count cc // 取出最後一個字元  \n        → Step 6.1: If result last char == c → Return \"\" // 若最後一個字元與前一個相同，無法完成  \n        → Step 6.2: Append c to result // 否則加入結果  \n    No  → // 沒剩餘字元，直接跳過  \n→ Step 7: 將結果列表轉換為字串並返回 // 完成所有步驟後回傳重排後的字串  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport heapq\nfrom collections import Counter\n\nclass Solution:\n    def reorganizeString(self, s: str) -> str:\n        # Count frequency of each character\n        freq = Counter(s)\n        n = len(s)\n        # If any character occurs more than (n+1)//2 times, impossible\n        if max(freq.values()) > (n + 1) // 2:\n            return \"\"\n        # Build max-heap based on frequency\n        max_heap = [(-cnt, ch) for ch, cnt in freq.items()]\n        heapq.heapify(max_heap)\n\n        prev_cnt, prev_ch = 0, ''\n        res = []\n\n        while max_heap:\n            cnt, ch = heapq.heappop(max_heap)\n            res.append(ch)\n            # Push back the previous character if it still has remaining count\n            if prev_cnt < 0:\n                heapq.heappush(max_heap, (prev_cnt, prev_ch))\n            # Update previous character for next iteration\n            prev_cnt, prev_ch = cnt + 1, ch  # cnt is negative, so +1 moves towards zero\n\n        result = \"\".join(res)\n        return result if len(result) == n else \"\"\n\ndef parse_input(input_str: str) -> str:\n    \"\"\"\n    Extract the string value between the first pair of double quotes.\n    If no quotes are found, assume the whole input is the string.\n    \"\"\"\n    first_quote = input_str.find('\"')\n    if first_quote == -1:\n        # No quotes, strip whitespace and return as is\n        return input_str.strip()\n    second_quote = input_str.find('\"', first_quote + 1)\n    if second_quote == -1:\n        # Malformed input, fallback\n        return input_str[first_quote + 1:].strip()\n    return input_str[first_quote + 1:second_quote]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    s = parse_input(data)\n    sol = Solution()\n    ans = sol.reorganizeString(s)\n    print(ans)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"aab\"",
          "expected_output": "\"aba\"",
          "success": true,
          "output": "aba"
        },
        {
          "example_index": 1,
          "input": "s = \"aaab\"",
          "expected_output": "\"\"",
          "success": true,
          "output": ""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode312.json",
    "problem_index_in_file": 0,
    "title": "Burst Balloons",
    "description_snippet": "You are given n balloons, indexed from 0 to n - 1. Each balloon is painted with a number on it repre...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for problem: maximum coins from bursting balloons. This is classic DP interval solution. Provide steps. Virtual code lines with arrows etc. No actual code. Let's produce algorithm description lines. Use Start, End, Decision, etc. We'll detail DP initialization, iteration over length, nested loops for left/right, calculation of max coins. We'll represent DP table as dp[left][right]. Also need sentinel 1 at ends. We'll produce pseudocode. Let's produce lines.\n\nProbably like:\n\nStart\n→ Prepare nums with 1 at both ends // sentinel\n→ Initialize dp array size n+2 with zeros // DP table\n→ For length from 1 to n // length of interval\n    → For left from 1 to n-length+1 // start index\n        → right = left + length -1\n        → maxCoins = 0\n        → For k from left to right // balloon to burst last in this interval\n            → coins = dp[left][k-1] + dp[k+1][right] + nums[left-1]*nums[k]*nums[right+1]\n            → If coins > maxCoins → maxCoins = coins\n        → dp[left][right] = maxCoins\n→ Return dp[1][n] // max coins for full interval\nEnd\n\nAdd decision points? We can add decisions: if length loop etc. But we can embed decisions implicitly.\n\nLet's add \"Decision:\" lines for if statement for coins > maxCoins. We'll show Yes arrow for updating.\n\nLet's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Add sentinel 1 at both ends of nums // 方便處理邊界  \n→ Initialize dp array of size (n+2)×(n+2) with 0 // DP 表，dp[l][r] 為區間 [l, r] 的最大硬幣  \n→ For length from 1 to n // 處理所有區間長度  \n    → For left from 1 to n - length + 1 // 設定區間起點  \n        → right ← left + length - 1 // 計算區間終點  \n        → maxCoins ← 0 // 本區間最大硬幣初始化  \n        → For k from left to right // 假設 k 為最後被擊破的氣球  \n            → coins ← dp[left][k-1] + dp[k+1][right] + nums[left-1] * nums[k] * nums[right+1] // 本次擊破所得硬幣  \n            → Decision: coins > maxCoins? // 判斷是否更新最大值  \n                Yes → maxCoins ← coins // 更新本區間最大硬幣  \n        → dp[left][right] ← maxCoins // 記錄區間 [left, right] 的最佳結果  \n→ Return dp[1][n] // 全部氣球被擊破後的最大硬幣  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def maxCoins(self, nums):\n        # 在前後加 1 方便計算\n        nums = [1] + nums + [1]\n        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n\n        # 遍歷所有長度，長度從 2 開始（因為要有左右兩邊）\n        for length in range(2, n):\n            # 左邊界從 0 開始\n            for left in range(0, n - length):\n                right = left + length\n                # i 為最後一個被戳破的氣球\n                for i in range(left + 1, right):\n                    coins = nums[left] * nums[i] * nums[right]\n                    dp[left][right] = max(dp[left][right],\n                                          coins + dp[left][i] + dp[i][right])\n        return dp[0][n - 1]\n\n\ndef parse_input(input_str):\n    \"\"\"將類似 'nums = [3,1,5,8]' 的字串轉為列表\"\"\"\n    # 找到第一個 '[' 和最後一個 ']'\n    start = input_str.find('[')\n    end = input_str.rfind(']')\n    if start == -1 or end == -1 or start > end:\n        return []\n    # 取出中間的子字串，使用 eval 轉為列表\n    sub = input_str[start:end + 1]\n    try:\n        return eval(sub)\n    except Exception:\n        return []\n\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個輸入\n    data = sys.stdin.read().strip()\n    nums = parse_input(data)\n    if not nums:\n        print(0)\n    else:\n        sol = Solution()\n        result = sol.maxCoins(nums)\n        print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [3,1,5,8]",
          "expected_output": "167",
          "success": true,
          "output": "167"
        },
        {
          "example_index": 1,
          "input": "nums = [1,5]",
          "expected_output": "10",
          "success": true,
          "output": "10"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode166.json",
    "problem_index_in_file": 0,
    "title": "Fraction to Recurring Decimal",
    "description_snippet": "Given two integers representing the numerator and denominator of a fraction, return the fraction in ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for fraction to decimal with repeating detection. Output as per format. Use Start, End, Decision. Provide step by step. Each line: virtual code step + space + // explanation. Use arrows. Let's craft. Use variable numerator, denominator. Compute sign. Use absolute. Compute integer part. Append to result. If remainder zero, return. Else add '.' and loop: map remainder to position. While remainder not zero: if remainder in map, find start, insert parentheses. break. Else store remainder pos. Multiply by 10, digit, append, update remainder. After loop, build string. Return.\n\nLet's produce. Each step line. Use indentation for decisions. Use arrow symbol at start of step? In example, they used '→ Step 1:'. We'll follow. Start line: \"Start\". Then \"→ Step 1: 獲取輸入分子與分母\" etc.\n\nLet's write lines:\n\nStart // 程式開始執行\n→ Step 1: 設定 numerator, denominator // 取得輸入值\n→ Decision: 如果 numerator 為 0? // 檢查分子是否為零\n    Yes → Step 2: 返回 '0' // 零分子直接返回 0\n    No  → \n→ Step 3: 確定結果符號 sign = (numerator < 0) XOR (denominator < 0) ? '-' : '' // 計算結果符號\n→ Step 4: numerator ← abs(numerator) // 取分子絕對值\n→ Step 5: denominator ← abs(denominator) // 取分母絕對值\n→ Step 6: 整數部分 integerPart ← numerator // denominator // 取整數商\n→ Step 7: remainder ← numerator % denominator // 取餘數\n→ Step 8: result ← sign + integerPart.ToString() // 初始化結果字串\n→ Decision: remainder 為 0? // 判斷是否存在小數部分\n    Yes → Step 9: 返回 result // 沒有小數，直接返回\n    No  → \n→ Step 10: result ← result + '.' // 加入小數點\n→ Step 11: 創建字典 remainderPosition // 用於記錄餘數出現位置\n→ Step 12: pos ← result.Length // 目前結果長度作為下個小數位的起始位置\n→ Step 13: 循環 while remainder ≠ 0\n        → Step 14: Decision: remainder 已在 remainderPosition? // 檢查餘數是否重複\n            Yes → Step 15: startPos ← remainderPosition[remainder] // 重複開始位置\n                → Step 16: 在 startPos 位置插入 '('\n                → Step 17: 在結尾追加 ')' // 將重複部分括號化\n                → Step 18: 返回 result // 結束\n            No  → \n                → Step 19: remainderPosition[remainder] ← pos // 記錄餘數位置\n                → Step 20: remainder ← remainder * 10 // 將餘數乘 10\n                → Step 21: digit ← remainder // / denominator // 取下一位小數\n                → Step 22: result ← result + digit.ToString() // 將小數位加入結果\n                → Step 23: remainder ← remainder % denominator // 更新餘數\n                → Step 24: pos ← pos + 1 // 更新下一位位置\n→ End // 程式執行結束\n\nWe need to keep each line with virtual code step and comment. Ensure arrow arrow format. For steps within loop, indent? Example uses indentation but with arrow inside block. We'll maintain indentation but ensure each line still starts with arrow or space? Use indentation but keep \"→\". Let's keep structure. Provide as final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 numerator, denominator // 取得輸入值  \n→ Decision: 如果 numerator 為 0? // 檢查分子是否為零  \n  Yes → Step 2: 返回 '0' // 零分子直接返回 0  \n  No →  \n→ Step 3: 確定結果符號 sign = (numerator < 0) XOR (denominator < 0) ? '-' : '' // 計算結果符號  \n→ Step 4: numerator ← abs(numerator) // 取分子絕對值  \n→ Step 5: denominator ← abs(denominator) // 取分母絕對值  \n→ Step 6: 整數部分 integerPart ← numerator // denominator // 取整數商  \n→ Step 7: remainder ← numerator % denominator // 取餘數  \n→ Step 8: result ← sign + integerPart.ToString() // 初始化結果字串  \n→ Decision: remainder 為 0? // 判斷是否存在小數部分  \n  Yes → Step 9: 返回 result // 沒有小數，直接返回  \n  No →  \n→ Step 10: result ← result + '.' // 加入小數點  \n→ Step 11: 創建字典 remainderPosition // 用於記錄餘數出現位置  \n→ Step 12: pos ← result.Length // 目前結果長度作為下個小數位的起始位置  \n→ Step 13: 循環 while remainder ≠ 0  \n  → Step 14: Decision: remainder 已在 remainderPosition? // 檢查餘數是否重複  \n    Yes → Step 15: startPos ← remainderPosition[remainder] // 重複開始位置  \n     → Step 16: 在 startPos 位置插入 '(' // 把開頭的 '(' 插入  \n     → Step 17: 在結尾追加 ')' // 把結尾的 ')' 加上  \n     → Step 18: 返回 result // 結束並返回結果  \n    No →  \n     → Step 19: remainderPosition[remainder] ← pos // 記錄餘數位置  \n     → Step 20: remainder ← remainder * 10 // 將餘數乘 10  \n     → Step 21: digit ← remainder // / denominator // 取下一位小數  \n     → Step 22: result ← result + digit.ToString() // 將小數位加入結果  \n     → Step 23: remainder ← remainder % denominator // 更新餘數  \n     → Step 24: pos ← pos + 1 // 更新下一位位置  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\n        if numerator == 0:\n            return \"0\"\n        res = []\n        # 確定符號\n        if (numerator < 0) ^ (denominator < 0):\n            res.append(\"-\")\n        numerator, denominator = abs(numerator), abs(denominator)\n        # 整數部分\n        res.append(str(numerator // denominator))\n        remainder = numerator % denominator\n        if remainder == 0:\n            return \"\".join(res)\n        # 小數部分\n        res.append(\".\")\n        seen = {}\n        while remainder != 0:\n            if remainder in seen:\n                idx = seen[remainder]\n                res.insert(idx, \"(\")\n                res.append(\")\")\n                break\n            seen[remainder] = len(res)\n            remainder *= 10\n            res.append(str(remainder // denominator))\n            remainder %= denominator\n        return \"\".join(res)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    if len(nums) < 2:\n        sys.exit(0)\n    numerator, denominator = nums[0], nums[1]\n    solution = Solution()\n    result = solution.fractionToDecimal(numerator, denominator)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "numerator = 1, denominator = 2",
          "expected_output": "\"0.5\"",
          "success": true,
          "output": "0.5"
        },
        {
          "example_index": 1,
          "input": "numerator = 2, denominator = 1",
          "expected_output": "\"2\"",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "numerator = 4, denominator = 333",
          "expected_output": "\"0.(012)\"",
          "success": true,
          "output": "0.(012)"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode30.json",
    "problem_index_in_file": 0,
    "title": "Substring with Concatenation of All Words",
    "description_snippet": "You are given a string s and an array of strings words. All the strings of words are of the same len...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step for problem: find starting indices of concatenated substrings of words in s. This is the classic \"Substring with Concatenation of All Words\" Leetcode 30.\n\nWe need to output virtual code lines with explanation. Should not output actual code. Just pseudocode steps with arrows. Use Start, End, Decision, etc.\n\nWe need to think of algorithm: sliding window of word length, maintain counts, track windows. Or better: for each offset modulo word length, do sliding window.\n\nWe'll produce step-by-step pseudocode:\n\nStart\n→ Step 1: Compute wordLen = length of words[0], totalLen = wordLen * number of words, wordCount = map of word frequencies.\n→ Decision: If totalLen > length of s → Return empty array // cannot find any\n→ Step 2: Initialize result list\n→ Step 3: For offset from 0 to wordLen-1:\n    → Step 4: Initialize left = offset, right = offset, seen = empty map, wordsUsed = 0\n    → While right + wordLen <= length of s:\n        → Step 5: Extract word = s.substring(right, right+wordLen)\n        → right += wordLen\n        → Decision: If word in wordCount?:\n            → seen[word] +=1\n            → If seen[word] <= wordCount[word] → wordsUsed +=1\n            → Decision: If wordsUsed == number of words?:\n                → Step 6: Append left to result\n                → Remove leftmost word: leftWord = s.substring(left, left+wordLen)\n                → seen[leftWord] -=1\n                → If seen[leftWord] < wordCount[leftWord] → wordsUsed -=1\n                → left += wordLen\n            → Decision: While seen[word] > wordCount[word]:\n                → Remove leftmost word: leftWord = s.substring(left, left+wordLen)\n                → seen[leftWord] -=1\n                → If seen[leftWord] < wordCount[leftWord] → wordsUsed -=1\n                → left += wordLen\n        → Else: // word not in wordCount\n            → seen.clear()\n            → wordsUsed = 0\n            → left = right\n→ End\n→ Return result\n\nBut need to output line by line with explanation.\n\nWe need to use arrow and decision indentation.\n\nLet's produce. Use Start, End, Decision: each decision block with Yes/No branches.\n\nThe steps: each line must contain code step then // explanation.\n\nWe should include indentation for nested blocks: maybe using indent spaces.\n\nLet's craft lines:\n\nStart // 程式開始執行\n→ Step 1: wordLen ← length of words[0]; // 每個單字長度\n→ Step 2: totalLen ← wordLen * count(words); // 所需子字串長度\n→ Step 3: wordCount ← frequency map of words; // 每個單字出現次數\n→ Decision: 若 totalLen > length of s? // 無法在 s 中找到符合長度的子字串\n    Yes → Return [] // 空陣列，結束程式\n    No  → // 繼續\n→ Step 4: result ← [] // 儲存所有起始索引\n→ Step 5: For offset ← 0 to wordLen-1: // 依照字長做滑動窗口\n    → Step 6: left ← offset; right ← offset; seen ← empty map; wordsUsed ← 0\n    → While right + wordLen ≤ length of s: // 右邊界不超過 s\n        → Step 7: word ← s.substring(right, right+wordLen); right ← right + wordLen // 取出一個單字\n        → Decision: 若 word 在 wordCount? // 該單字屬於給定集合\n            Yes →\n                → seen[word] ← seen.get(word,0)+1; // 記錄已看到的次數\n                → Decision: 若 seen[word] ≤ wordCount[word]? // 次數未超過預期\n                    Yes → wordsUsed ← wordsUsed + 1\n                    No  → // 超過次數，需要收縮左邊\n                        → While seen[word] > wordCount[word]: // 收縮直到合法\n                            → leftWord ← s.substring(left, left+wordLen)\n                            → seen[leftWord] ← seen[leftWord] - 1\n                            → Decision: 若 seen[leftWord] < wordCount[leftWord]? // 减少使用數\n                                Yes → wordsUsed ← wordsUsed - 1\n                                No  →\n                            → left ← left + wordLen\n                → Decision: 若 wordsUsed = count(words)? // 完整集合已找到\n                    Yes →\n                        → result.append(left); // 加入起始索引\n                        → leftWord ← s.substring(left, left+wordLen)\n                        → seen[leftWord] ← seen[leftWord] - 1\n                        → Decision: 若 seen[leftWord] < wordCount[leftWord]? // 需減少使用數\n                            Yes → wordsUsed ← wordsUsed - 1\n                            No  →\n                        → left ← left + wordLen\n                    No  →\n            No →\n                → seen.clear(); wordsUsed ← 0; left ← right // 跳過不匹配的單字\n→ End // 程式結束\n→ Return result // 回傳所有起始索引\n\nBut we need each line with explanation. Also we need to keep arrow style. Use indentation for decisions.\n\nLet's format exactly:\n\nStart // 程式開始執行\n→ Step 1: wordLen ← length(words[0]) // 每個單字長度\n→ Step 2: totalLen ← wordLen * count(words) // 所需子字串總長度\n→ Step 3: wordCount ← frequency map of words // 每個單字的期望頻率\n→ Decision: 若 totalLen > length(s)? // 無法找到符合長度的子字串\n    Yes → Return [] // 結束，回傳空陣列\n    No  → // 繼續\n→ Step 4: result ← [] // 儲存所有起始索引\n→ Step 5: For offset ← 0 to wordLen-1: // 以字長為步長進行滑動窗口\n    → Step 6: left ← offset; right ← offset; seen ← empty map; wordsUsed ← 0\n    → While right + wordLen ≤ length(s): // 右邊界未超出 s\n        → Step 7: word ← s.substring(right, right+wordLen); right ← right + wordLen // 取一個單字\n        → Decision: 若 word 在 wordCount? // 是否屬於給定單字集合\n            Yes →\n                → seen[word] ← seen.get(word,0) + 1 // 記錄已見次數\n                → Decision: 若 seen[word] ≤ wordCount[word]? // 次數未超過預期\n                    Yes → wordsUsed ← wordsUsed + 1\n                    No  → // 次數超過，需收縮左邊\n                        → While seen[word] > wordCount[word]:\n                            → leftWord ← s.substring(left, left+wordLen)\n                            → seen[leftWord] ← seen[leftWord] - 1\n                            → Decision: 若 seen[leftWord] < wordCount[leftWord]? // 失去一個合法單字\n                                Yes → wordsUsed ← wordsUsed - 1\n                                No  →\n                            → left ← left + wordLen\n                → Decision: 若 wordsUsed = count(words)? // 找到完整的排列\n                    Yes →\n                        → result.append(left) // 將起始位置加入結果\n                        → leftWord ← s.substring(left, left+wordLen)\n                        → seen[leftWord] ← seen[leftWord] - 1\n                        → Decision: 若 seen[leftWord] < wordCount[leftWord]? // 收縮後需要減少使用數\n                            Yes → wordsUsed ← wordsUsed - 1\n                            No  →\n                        → left ← left + wordLen\n                    No  →\n            No →\n                → seen.clear(); wordsUsed ← 0; left ← right // 不屬於集合，重置窗口\n→ End // 程式結束\n→ Return result // 回傳所有起始索引\n\nMake sure each line has '→' except Start and End. Indentation using spaces? They didn't specify but use indentation.\n\nBut each line must contain '虛擬碼步驟' + ' ' + '// 解釋/說明'. So for decision blocks we need to include 'Decision:' etc.\n\nAlso for Yes/No branches we need to include the lines within each branch. The example shows indent with 4 spaces? They used 4 spaces.\n\nThus we need to maintain indent. We'll do:\n\nStart // 程式開始執行\n→ Step 1: ... // ...\n→ Step 2: ... // ...\n→ Step 3: ... // ...\n→ Decision: 若 totalLen > length(s)? // ...\n    Yes → Return [] // ...\n    No  → // ...\n...\n\nMake sure each line after indentation has the code and explanation.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: wordLen ← length(words[0]) // 每個單字長度\n→ Step 2: totalLen ← wordLen * count(words) // 所需子字串總長度\n→ Step 3: wordCount ← frequency map of words // 每個單字的期望頻率\n→ Decision: 若 totalLen > length(s)? // 無法找到符合長度的子字串\n    Yes → Return [] // 結束，回傳空陣列\n    No  → // 繼續\n→ Step 4: result ← [] // 儲存所有起始索引\n→ Step 5: For offset ← 0 to wordLen-1: // 以字長為步長進行滑動窗口\n    → Step 6: left ← offset; right ← offset; seen ← empty map; wordsUsed ← 0\n    → While right + wordLen ≤ length(s): // 右邊界未超出 s\n        → Step 7: word ← s.substring(right, right+wordLen); right ← right + wordLen // 取一個單字\n        → Decision: 若 word 在 wordCount? // 是否屬於給定單字集合\n            Yes →\n                → seen[word] ← seen.get(word,0) + 1 // 記錄已見次數\n                → Decision: 若 seen[word] ≤ wordCount[word]? // 次數未超過預期\n                    Yes → wordsUsed ← wordsUsed + 1\n                    No  → // 次數超過，需收縮左邊\n                        → While seen[word] > wordCount[word]:\n                            → leftWord ← s.substring(left, left+wordLen)\n                            → seen[leftWord] ← seen[leftWord] - 1\n                            → Decision: 若 seen[leftWord] < wordCount[leftWord]? // 失去一個合法單字\n                                Yes → wordsUsed ← wordsUsed - 1\n                                No  →\n                            → left ← left + wordLen\n                → Decision: 若 wordsUsed = count(words)? // 找到完整的排列\n                    Yes →\n                        → result.append(left) // 將起始位置加入結果\n                        → leftWord ← s.substring(left, left+wordLen)\n                        → seen[leftWord] ← seen[leftWord] - 1\n                        → Decision: 若 seen[leftWord] < wordCount[leftWord]? // 收縮後需要減少使用數\n                            Yes → wordsUsed ← wordsUsed - 1\n                            No  →\n                        → left ← left + wordLen\n                    No  →\n            No →\n                → seen.clear(); wordsUsed ← 0; left ← right // 不屬於集合，重置窗口\n→ End // 程式結束\n→ Return result // 回傳所有起始索引",
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import Counter, defaultdict\n\nclass Solution:\n    def findSubstring(self, s, words):\n        if not s or not words:\n            return []\n\n        word_len = len(words[0])\n        word_count = len(words)\n        total_len = word_len * word_count\n        if total_len > len(s):\n            return []\n\n        need = Counter(words)\n        res = []\n\n        # Process each possible offset within the word length\n        for i in range(word_len):\n            left = i          # left boundary of the window\n            right = i         # right boundary of the window\n            cur = defaultdict(int)  # counts of words in current window\n            matched = 0                # number of words that match required counts\n\n            while right + word_len <= len(s):\n                word = s[right:right + word_len]\n                right += word_len\n\n                if word in need:\n                    cur[word] += 1\n                    if cur[word] <= need[word]:\n                        matched += 1\n                    else:\n                        # Too many of this word, shrink from left until balanced\n                        while cur[word] > need[word]:\n                            left_word = s[left:left + word_len]\n                            cur[left_word] -= 1\n                            if cur[left_word] < need[left_word]:\n                                matched -= 1\n                            left += word_len\n\n                    # If all words matched, record start index\n                    if matched == word_count:\n                        res.append(left)\n                        left_word = s[left:left + word_len]\n                        cur[left_word] -= 1\n                        if cur[left_word] < need[left_word]:\n                            matched -= 1\n                        left += word_len\n                else:\n                    # Word not in list, reset window\n                    cur.clear()\n                    matched = 0\n                    left = right\n\n        return res\n\ndef main():\n    data = sys.stdin.read()\n    # Try to parse format: s = \"text\", words = [\"w1\",\"w2\",...]\n    pattern = r's\\s*=\\s*\"(?P<s>.*?)\"\\s*,\\s*words\\s*=\\s*(?P<words>\\[.*?\\])'\n    m = re.search(pattern, data, re.S)\n\n    if m:\n        s = m.group('s')\n        words = ast.literal_eval(m.group('words'))\n    else:\n        # Fallback: find first quoted string and first list\n        s_match = re.search(r's\\s*=\\s*\"(?P<s>.*?)\"', data, re.S)\n        words_match = re.search(r'words\\s*=\\s*(?P<words>\\[.*?\\])', data, re.S)\n        if not s_match or not words_match:\n            return\n        s = s_match.group('s')\n        words = ast.literal_eval(words_match.group('words'))\n\n    sol = Solution()\n    result = sol.findSubstring(s, words)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]",
          "expected_output": "[0,9]",
          "success": true,
          "output": "[0, 9]"
        },
        {
          "example_index": 1,
          "input": "s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        },
        {
          "example_index": 2,
          "input": "s = \"barfoofoobarthefoobarman\", words = [\"bar\",\"foo\",\"the\"]",
          "expected_output": "[6,9,12]",
          "success": true,
          "output": "[6, 9, 12]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode368.json",
    "problem_index_in_file": 0,
    "title": "Largest Divisible Subset",
    "description_snippet": "Given a set of distinct positive integers nums, return the largest subset answer such that every pai...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line with explanation, following given format. The user wants the algorithm to find the largest divisible subset. The algorithm: sort nums, dynamic programming. Steps: start, sort, initialize dp and prev arrays, iterate i, j, update dp. After DP, find max dp index, reconstruct subset via prev. Output subset.\n\nWe need to write virtual code lines, each with explanation, using arrows. Format: each line \"虛擬碼步驟 // 解釋\". Use arrows and structure. We can use \"Start\" and \"End\". Use \"Decision:\" for conditions. Use \"Yes →\" \"No →\". Provide steps.\n\nWe need to produce sequential steps, not actual code. So something like:\n\nStart\n→ Step 1: Sort nums ascending // sort the input to allow DP\n→ Step 2: Initialize dp array length n with 1 // each element itself\n→ Step 3: Initialize prev array length n with -1 // predecessor index\n→ Decision: for i from 0 to n-1? // iterate over each element\n    Yes → Step 4: for j from 0 to i-1? // compare with earlier\n        Yes → Decision: if nums[i] % nums[j] == 0? // check divisibility\n            Yes → Step 5: if dp[j] + 1 > dp[i]? // extend subset\n                Yes → Step 6: dp[i] = dp[j] + 1\n                Yes → Step 7: prev[i] = j\n        No → continue\nEnd inner loops\n→ Step 8: Find index maxIdx with maximum dp value // longest subset\n→ Step 9: Initialize answer list\n→ Decision: while maxIdx != -1? // reconstruct\n    Yes → Step 10: Prepend nums[maxIdx] to answer\n    Yes → Step 11: maxIdx = prev[maxIdx]\n    No → End reconstruction\n→ End // output answer\n\nBut need arrow style exactly. Each line: \"→ Step X:\" etc. Also we should include decision arrow lines like \"Decision: ...\". Use Yes→ and No→ indent accordingly.\n\nWe must ensure each line has space between code and explanation. Use \" // \" between.\n\nLet's craft step by step.\n\nWe may need to indicate for loops as steps.\n\nBetter to format loops as Steps too: \"→ Step 4: For i from 0 to n-1\" then inside arrow lines for j loop.\n\nLet's produce:\n\nStart\n→ Step 1: Input list nums // receive the input numbers\n→ Step 2: Sort nums in ascending order // ordering simplifies divisibility checks\n→ Step 3: Let n = length(nums) // number of elements\n→ Step 4: Create array dp[n] and set all values to 1 // each element is a subset of size 1\n→ Step 5: Create array prev[n] and set all values to -1 // tracks previous index in subset\n→ Decision: For i from 0 to n-1? // outer loop over each element\n    Yes → Step 6: For j from 0 to i-1? // compare with earlier elements\n        Yes → Decision: If nums[i] % nums[j] == 0? // check divisibility\n            Yes → Decision: If dp[j] + 1 > dp[i]? // can extend longer subset\n                Yes → Step 7: dp[i] = dp[j] + 1 // update length\n                Yes → Step 8: prev[i] = j // record predecessor\n        No → No action\n    No → Continue outer loop\n→ Step 9: Find index maxIdx with maximum dp value // longest divisible subset\n→ Step 10: Initialize empty list answer // will store subset\n→ Decision: While maxIdx != -1? // reconstruct subset backwards\n    Yes → Step 11: Prepend nums[maxIdx] to answer // add current element\n    Yes → Step 12: maxIdx = prev[maxIdx] // move to predecessor\n    No → End reconstruction\n→ End // output answer as result\n\nNeed each line with \" // \" after code.\n\nLet's format each line accordingly.\n\nAlso include arrow for each step: \"→\". For decisions: \"Decision:\" then inside \"Yes →\" \"No →\".\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入 nums // 取得使用者提供的正整數陣列  \n→ Step 2: 將 nums 依升序排序 // 方便後續可除關係檢查  \n→ Step 3: 設 n 為 nums 的長度 // 紀錄元素數量  \n→ Step 4: 建立 dp[n]，每個元素初始化為 1 // 每個數字本身至少可作為長度 1 的子集  \n→ Step 5: 建立 prev[n]，每個元素初始化為 -1 // 用來追蹤子集前驅索引  \n→ Decision: 迴圈 i 從 0 到 n-1? // 外層遍歷所有元素  \n  Yes → Step 6: 迴圈 j 從 0 到 i-1? // 與前面元素比較  \n    Yes → Decision: 若 nums[i] % nums[j] == 0? // 判斷可除關係  \n      Yes → Decision: 若 dp[j] + 1 > dp[i]? // 可否延長更長子集  \n        Yes → Step 7: dp[i] = dp[j] + 1 // 更新長度  \n        Yes → Step 8: prev[i] = j // 記錄前驅索引  \n      No → No action // 無法延長，保持原值  \n    No → 繼續 j 迴圈  \n  No → 繼續 i 迴圈  \n→ Step 9: 找到 dp 中最大值所在的索引 maxIdx // 最大子集結束位置  \n→ Step 10: 初始化空列表 answer // 用來存放最終子集  \n→ Decision: maxIdx != -1? // 反向重建子集  \n  Yes → Step 11: 把 nums[maxIdx] 加到 answer 前面 // 加入元素  \n  Yes → Step 12: maxIdx = prev[maxIdx] // 移動到前驅  \n  No → End 重建  \n→ End // 程式執行結束，answer 為最大可除子集",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def largestDivisibleSubset(self, nums):\n        if not nums:\n            return []\n        nums.sort()\n        n = len(nums)\n        dp = [1] * n\n        prev = [-1] * n\n        max_index = 0\n\n        for i in range(n):\n            for j in range(i):\n                if nums[i] % nums[j] == 0 and dp[j] + 1 > dp[i]:\n                    dp[i] = dp[j] + 1\n                    prev[i] = j\n            if dp[i] > dp[max_index]:\n                max_index = i\n\n        res = []\n        while max_index >= 0:\n            res.append(nums[max_index])\n            max_index = prev[max_index]\n\n        return res[::-1]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Extract all integers from the input string\n    nums = list(map(int, re.findall(r'\\d+', data)))\n    solution = Solution()\n    result = solution.largestDivisibleSubset(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[1,2]",
          "success": true,
          "output": "[1, 2]"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,4,8]",
          "expected_output": "[1,2,4,8]",
          "success": true,
          "output": "[1, 2, 4, 8]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode458.json",
    "problem_index_in_file": 0,
    "title": "Poor Pigs",
    "description_snippet": "There are buckets buckets of liquid, where exactly one of the buckets is poisonous. To figure out wh...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps to solve the problem: minimal number of pigs required. Problem known: base = 1 + minutesToTest / minutesToDie? Actually number of test rounds = minutesToTest / minutesToDie (floor). Each pig can have states (alive after each round or dead in some round). With r rounds, pig can have r+1 states (dead at round i or alive after all). So number of distinguishable outcomes per pig is r+1. Need pigs p such that (r+1)^p >= buckets. Solve minimal p. So algorithm: compute rounds = floor(minutesToTest / minutesToDie). If rounds == 0, need buckets pigs? Actually if no rounds, only one outcome (dead or alive after one test) wait? But with 0 rounds, no time to test? You can still feed once and check? But minutesToTest zero: cannot test? But problem likely expects at least one round. We'll ignore.\n\nPseudo: compute rounds = minutesToTest // minutesToDie; base = rounds + 1; p = 0; while base**p < buckets: p++; return p.\n\nLet's produce virtual code with step-by-step lines. Include decisions. Use arrow. We'll output each line with explanation.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算可完成的測試輪數 r ← minutesToTest // minutesToDie // 用整除得到最多能進行的獨立測試回合  \n→ Decision: 如果 r < 1? // 檢查是否至少有一次測試可能  \n  Yes → Step 2: 回傳 buckets // 若無法測試，必須使用每桶一隻豬才能確定  \n  No → Step 3: 計算每隻豬可辨識的狀態數 base ← r + 1 // 每隻豬在 r 回合中可以處於 r+1 種不同的狀態（死亡於第 i 回合或存活）  \n→ Step 4: 初始化 pigCount ← 0 // 設定目前使用的豬數  \n→ Step 5: 初始化 totalCombinations ← 1 // 目前已能辨識的桶數總數 (base^pigCount)  \n→ Decision: 如果 totalCombinations >= buckets? // 檢查目前已足以辨識所有桶  \n  Yes → Step 6: 回傳 pigCount // 取得最小所需豬數  \n  No → Step 7: pigCount ← pigCount + 1 // 再加入一隻豬  \n  No → Step 8: totalCombinations ← totalCombinations * base // 更新可辨識桶數 (base^pigCount)  \n  No → Step 9: 回到 Decision: 如果 totalCombinations >= buckets? // 重複判斷直到滿足條件  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef min_pigs(buckets: int, minutes_to_die: int, minutes_to_test: int) -> int:\n    \"\"\"\n    計算在給定時間內，最少需要多少隻豬才能確定哪一桶液體有毒。\n    觀點：每隻豬在 r 次測試（r = minutes_to_test // minutes_to_die）中可以有 r+1 種不同的「死亡時機」\n    需要滿足 (r+1)^p >= buckets，p 為所需的最小豬數。\n    \"\"\"\n    rounds = minutes_to_test // minutes_to_die\n    states_per_pig = rounds + 1          # 每隻豬能辨識的狀態數\n    pigs_needed = 0\n    # 逐漸增加豬數，直到能夠區分所有桶\n    while states_per_pig ** pigs_needed < buckets:\n        pigs_needed += 1\n    return pigs_needed\n\ndef main() -> None:\n    \"\"\"\n    從標準輸入讀取「buckets = X, minutesToDie = Y, minutesToTest = Z」的字串，\n    解析出三個整數並輸出所需的最小豬數。\n    \"\"\"\n    # 讀取整個輸入\n    raw_input = sys.stdin.read()\n    # 取出所有數字（正整數）\n    numbers = list(map(int, re.findall(r'\\d+', raw_input)))\n    if len(numbers) < 3:\n        # 輸入格式不符合預期，直接退出\n        return\n    buckets, minutes_to_die, minutes_to_test = numbers[0], numbers[1], numbers[2]\n    result = min_pigs(buckets, minutes_to_die, minutes_to_test)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "buckets = 4, minutesToDie = 15, minutesToTest = 15",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "buckets = 4, minutesToDie = 15, minutesToTest = 30",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode49.json",
    "problem_index_in_file": 0,
    "title": "Group Anagrams",
    "description_snippet": "Given an array of strings strs, group the anagrams together. You can return the answer in any order....",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code step by step with explanations. Each line: \"虛擬碼步驟 // 解釋\". Use arrows and structure Start, Decision, End. So produce algorithm for grouping anagrams: For each string, sort characters to form key, add string to hash map. After processing, output values. Steps: Start, declare map, for each str in strs: sort string, key, add to map; after loop: create result list, for each entry in map: add list to result; End.\n\nWe should produce each line separately with explanation. Use arrow \"→\". Should we use \"Step 1:\"? Yes. We'll produce lines like:\n\nStart // 程式開始執行\n→ Step 1: 建立一個空的雜湊表 hashMap<String, List<String>> // 用於以排序後的字串作為鍵，存放同類型的字串\n→ Step 2: 對輸入陣列 strs 中的每個字串 str 做以下處理 // 逐一處理每個字串\n    → Step 2a: 把 str 的字元排序得到 sortedStr // 產生 anagram 的共通鍵\n    → Step 2b: 如果 hashMap 沒有鍵 sortedStr 則新增一個空的 list // 初始化 bucket\n    → Step 2c: 把 str 加入 hashMap[sortedStr] 的 list // 將字串放進對應 bucket\n→ Step 3: 建立一個空的結果 list result // 用於收集所有 bucket\n→ Step 4: 對 hashMap 的每個 entry 做以下處理\n    → Step 4a: 把 entry.value 加入 result // 將同類型字串組合加入結果\n→ End // 程式結束\n\nBut we need to follow format: each line has the arrow or Start, then comment. Use indentation? They didn't specify indentation, but example shows indentation for nested decisions. We can show indentation with spaces. Use Decision if needed. Here no decision except maybe if key not exists. But we can just mention.\n\nWe'll produce each line.\n\nLet's output in traditional Chinese.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Step 1: 建立一個空的雜湊表 hashMap<String, List<String>> // 用於以排序後的字串作為鍵，存放同類型的字串\n→ Step 2: 對輸入陣列 strs 中的每個字串 str 做以下處理 // 逐一處理每個字串\n    → Step 2a: 取得 str 的字元排序後的字串 sortedStr // 產生 anagram 的共通鍵\n    → Step 2b: 若 hashMap 尚無鍵 sortedStr，則新增一個空的 list // 初始化 bucket\n    → Step 2c: 把 str 加入 hashMap[sortedStr] 的 list // 將字串放進對應 bucket\n→ Step 3: 建立一個空的結果 list result // 用於收集所有 bucket\n→ Step 4: 對 hashMap 的每個 entry 做以下處理\n    → Step 4a: 把 entry.value 加入 result // 將同類型字串組合加入結果\n→ End // 程式執行結束\n\nThat meets format.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立一個空的雜湊表 hashMap<String, List<String>> // 用於以排序後的字串作為鍵，存放同類型的字串  \n→ Step 2: 對輸入陣列 strs 中的每個字串 str 做以下處理 // 逐一處理每個字串  \n  → Step 2a: 取得 str 的字元排序後的字串 sortedStr // 產生 anagram 的共通鍵  \n  → Step 2b: 若 hashMap 尚無鍵 sortedStr，則新增一個空的 list // 初始化 bucket  \n  → Step 2c: 把 str 加入 hashMap[sortedStr] 的 list // 將字串放進對應 bucket  \n→ Step 3: 建立一個空的結果 list result // 用於收集所有 bucket  \n→ Step 4: 對 hashMap 的每個 entry 做以下處理  \n  → Step 4a: 把 entry.value 加入 result // 將同類型字串組合加入結果  \n→ End // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport json\nfrom collections import defaultdict\n\nclass Solution:\n    def groupAnagrams(self, strs):\n        \"\"\"Group anagrams from a list of strings.\"\"\"\n        anagrams = defaultdict(list)\n        for s in strs:\n            key = tuple(sorted(s))\n            anagrams[key].append(s)\n        return list(anagrams.values())\n\ndef main():\n    # Read entire input from stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Extract the list part after '=' if present\n    if '=' in data:\n        _, list_part = data.split('=', 1)\n    else:\n        list_part = data\n    list_part = list_part.strip()\n\n    # Safely evaluate the list string\n    try:\n        strs = ast.literal_eval(list_part)\n    except Exception:\n        # If evaluation fails, treat as empty list\n        strs = []\n\n    # Ensure we have a list of strings\n    if not isinstance(strs, list):\n        strs = []\n\n    # Group anagrams and output as JSON\n    sol = Solution()\n    result = sol.groupAnagrams(strs)\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]",
          "expected_output": "[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]'\nGot (Norm):      '[[\"eat\",\"tea\",\"ate\"],[\"tan\",\"nat\"],[\"bat\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]'\nRaw Got:      '[[\"eat\", \"tea\", \"ate\"], [\"tan\", \"nat\"], [\"bat\"]]'"
        },
        {
          "example_index": 1,
          "input": "strs = [\"\"]",
          "expected_output": "[[\"\"]]",
          "success": true,
          "output": "[[\"\"]]"
        },
        {
          "example_index": 2,
          "input": "strs = [\"a\"]",
          "expected_output": "[[\"a\"]]",
          "success": true,
          "output": "[[\"a\"]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode488.json",
    "problem_index_in_file": 0,
    "title": "Zuma Game",
    "description_snippet": "You are playing a variation of the game Zuma. \nIn this variation of Zuma, there is a single row of c...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps to solve the problem. The problem is \"Zuma Game\" known LeetCode 488. We need to produce algorithm description in pseudocode with arrows, decisions etc.\n\nWe must give step-by-step virtual code that solves the problem: find minimum insertions to clear board. Use DFS/backtracking with pruning, count of hand colors, removal process (compress string). Approach: use recursion: function dfs(board, handCount) returns min steps or INF. For each position in board, for each color available in handCount, try insert if leads to removal chain. Compute new board after insertion and removal, call dfs recursively with decreased handCount for that color. Keep min. Use memoization: map key board+handCount string to min steps.\n\nImplement removal function: while true, find any group of >=3 same consecutive, remove all such groups, compress; if none, break.\n\nWe'll produce virtual code in requested format, line by line with explanation.\n\nNeed to adhere to format: \"虛擬碼步驟 // 解釋\". Use arrow characters.\n\nWe need to include Start, End. Provide steps.\n\nLet's craft pseudocode:\n\nStart // 開始執行\n→ Define function MinInsertions(board, hand) // 初始化\n    → Create dictionary handCount // 計算手中每色球數\n    → Call dfs(board, handCount) // 開始深度優先搜尋\n    → Return result // 結果\n\nDefine dfs(board, handCount) // 遞迴搜尋最少插入數\n    → If board is empty → Return 0 // 已清空，無需再插入\n    → Create key = board + \"#\" + handCountString // 用於 memo\n    → If key in memo → Return memo[key]\n    → Set minSteps = INF\n    → For each index i from 0 to len(board):\n        → For each color c in handCount where handCount[c] > 0:\n            → If insertion at i may lead to elimination:\n                → Insert c at position i: newBoard = board[:i] + c + board[i:]\n                → newBoard = collapse(newBoard) // 連鎖消除\n                → handCount[c]--\n                → steps = dfs(newBoard, handCount)\n                → If steps != INF:\n                    → minSteps = min(minSteps, steps + 1)\n                → handCount[c]++ // 回溯\n    → memo[key] = minSteps\n    → Return minSteps\n\nDefine collapse(board) // 消除連鎖\n    → Loop:\n        → found = False\n        → i = 0\n        → While i < len(board):\n            → j = i\n            → While j < len(board) and board[j] == board[i]:\n                → j++\n            → If j - i >= 3:\n                → board = board[:i] + board[j:]\n                → found = True\n                → Break // restart loop\n            → i = j\n        → If not found → Break\n    → Return board\n\nAt the top-level:\n→ result = MinInsertions(board, hand)\n→ If result == INF → Return -1 else result\n\nAlso include pruning: if count of any color in hand insufficient to match groups, but we can skip.\n\nWe need to maintain the format: use arrow → and decision statements. Use \"Decision:\" lines for if statements.\n\nWe need to include each step on a separate line with explanation after //.\n\nLet's produce it. Ensure each line begins with \"Start\", \"→\" etc.\n\nLet's write out.\n\nAlso need to mention \"Memo\" as a dictionary.\n\nLet's craft carefully.\n\nWe'll produce maybe around 40 lines.\n\nLet's start:\n\nStart // 程式開始執行\n→ Define function MinInsertions(board, hand) // 主入口，輸入棋盤和手牌\n    → Create dictionary handCount // 將手牌字串轉換為顏色計數\n    → For each char ch in hand:\n        → handCount[ch] = handCount.get(ch, 0) + 1\n    → Call result = dfs(board, handCount) // 開始深度優先搜尋\n    → If result == INF:\n        → Return -1 // 無法清空棋盤\n        → End // 結束\n    → Else:\n        → Return result // 最小插入數\n        → End\n\nDefine function dfs(board, handCount) // 重新定義，遞迴搜尋\n    → If board is empty:\n        → Return 0 // 已清空，無需再插入\n    → Create key = board + \"#\" + serialize(handCount) // 將狀態序列化做 memo\n    → If key in memo:\n        → Return memo[key]\n    → Set minSteps = INF // 初始最小步驟為無限大\n    → For i from 0 to len(board): // 遍歷每個插入位置\n        → For each color c in handCount where handCount[c] > 0: // 選擇可用顏色\n            → Decision: 是否插入 c 於位置 i 會導致至少一個三連消除？\n                → Yes → \n                    → newBoard = board[:i] + c + board[i:] // 插入球\n                    → newBoard = collapse(newBoard) // 執行消除\n                    → handCount[c] = handCount[c] - 1 // 消耗一顆\n                    → steps = dfs(newBoard, handCount) // 递归求解\n                    → If steps != INF:\n                        → minSteps = min(minSteps, steps + 1) // 更新最小步驟\n                    → handCount[c] = handCount[c] + 1 // 回溯，恢復計數\n                → No → Continue // 插入不會消除，跳過\n    → memo[key] = minSteps // 記錄結果\n    → Return minSteps\n\nDefine function collapse(board) // 連鎖消除\n    → Loop:\n        → found = False\n        → i = 0\n        → While i < len(board):\n            → j = i\n            → While j < len(board) and board[j] == board[i]:\n                → j++\n            → If j - i >= 3:\n                → board = board[:i] + board[j:] // 刪除連續三個以上\n                → found = True\n                → Break // 重置搜尋\n            → i = j\n        → If not found:\n            → Break // 沒有更多可消除的群\n    → Return board\n\nDefine function serialize(handCount) // 將手牌計數序列化成字串\n    → Return sorted list of color counts as string // 簡化鍵\n\nEnd // 程式執行結束\n\nBut we must follow formatting: each line must be `虛擬碼步驟` + space + `// 解釋`. Also we need arrows for decisions.\n\nWe need to output with indent using `→` arrows. For nested blocks, we might need to use indentation with spaces? The example uses indentation for nested decisions but still each line with arrow.\n\nLet's produce accordingly. Use spaces before arrow? The example uses `→ Step 1:`. For nested decisions, they use `Decision: ...` and indent the inner lines with arrow but no further indentation. So we should produce something like:\n\nStart // 程式開始執行\n→ Define function MinInsertions(board, hand) // 主入口，輸入棋盤和手牌\n    → Create dictionary handCount // 將手牌字串轉換為顏色計數\n    → For each char ch in hand:\n        → handCount[ch] = handCount.get(ch, 0) + 1\n    → Call result = dfs(board, handCount) // 開始深度優先搜尋\n    → If result == INF:\n        → Return -1 // 無法清空棋盤\n        → End // 結束\n    → Else:\n        → Return result // 最小插入數\n        → End\n\nDefine function dfs(board, handCount) // 重新定義，遞迴搜尋\n    → If board is empty:\n        → Return 0 // 已清空，無需再插入\n    → Create key = board + \"#\" + serialize(handCount) // 將狀態序列化做 memo\n    → If key in memo:\n        → Return memo[key]\n    → Set minSteps = INF // 初始最小步驟為無限大\n    → For i from 0 to len(board): // 遍歷每個插入位置\n        → For each color c in handCount where handCount[c] > 0: // 選擇可用顏色\n            → Decision: 是否插入 c 於位置 i 會導致至少一個三連消除？\n                → Yes →\n                    → newBoard = board[:i] + c + board[i:] // 插入球\n                    → newBoard = collapse(newBoard) // 執行消除\n                    → handCount[c] = handCount[c] - 1 // 消耗一顆\n                    → steps = dfs(newBoard, handCount) // 递归求解\n                    → If steps != INF:\n                        → minSteps = min(minSteps, steps + 1) // 更新最小步驟\n                    → handCount[c] = handCount[c] + 1 // 回溯，恢復計數\n                → No → Continue // 插入不會消除，跳過\n    → memo[key] = minSteps // 記錄結果\n    → Return minSteps\n\nDefine function collapse(board) // 連鎖消除\n    → Loop:\n        → found = False\n        → i = 0\n        → While i < len(board):\n            → j = i\n            → While j < len(board) and board[j] == board[i]:\n                → j++\n            → If j - i >= 3:\n                → board = board[:i] + board[j:] // 刪除連續三個以上\n                → found = True\n                → Break // 重置搜尋\n            → i = j\n        → If not found:\n            → Break // 沒有更多可消除的群\n    → Return board\n\nDefine function serialize(handCount) // 將手牌計數序列化成字串\n    → Return sorted list of color counts as string // 簡化鍵\n\nEnd // 程式執行結束\n\nWe need to keep each line as one line. But nested indent might be many lines. Ensure each line ends with // comment.\n\nNeed to ensure \"→\" before each step. The example uses arrows and \"Decision:\" lines with indentation. We'll maintain similar.\n\nBut each line must include a space after arrow? Example shows \"→ Step 1:\". We'll use \"→ Step ...\" etc. For functions maybe \"→ Define function...\" It's okay.\n\nLet's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Define function MinInsertions(board, hand) // 主入口，輸入棋盤和手牌  \n → Create dictionary handCount // 將手牌字串轉換為顏色計數  \n → For each char ch in hand:  \n  → handCount[ch] = handCount.get(ch, 0) + 1  \n → Call result = dfs(board, handCount) // 開始深度優先搜尋  \n → Decision: result == INF? // 判斷是否能清空棋盤  \n  Yes → Return -1 // 無法清空棋盤  \n  No → Return result // 最小插入數  \nEnd // 程式執行結束  \n\nDefine function dfs(board, handCount) // 重新定義，遞迴搜尋  \n → Decision: board is empty? // 檢查棋盤是否已清空  \n  Yes → Return 0 // 已清空，無需再插入  \n  No →  \n   → Create key = board + \"#\" + serialize(handCount) // 將狀態序列化做 memo  \n   → Decision: key in memo? // 判斷是否已記錄  \n    Yes → Return memo[key]  \n    No →  \n     → Set minSteps = INF // 初始最小步驟為無限大  \n     → For i from 0 to len(board): // 遍歷每個插入位置  \n      → For each color c in handCount where handCount[c] > 0: // 選擇可用顏色  \n        → Decision: 是否插入 c 於位置 i 會導致至少一個三連消除？  \n         Yes →  \n          → newBoard = board[:i] + c + board[i:] // 插入球  \n          → newBoard = collapse(newBoard) // 執行消除  \n          → handCount[c] = handCount[c] - 1 // 消耗一顆  \n          → steps = dfs(newBoard, handCount) // 递归求解  \n          → Decision: steps != INF?  \n           Yes → minSteps = min(minSteps, steps + 1) // 更新最小步驟  \n           No → // 無法清空，跳過  \n          → handCount[c] = handCount[c] + 1 // 回溯，恢復計數  \n         No → // 插入不會消除，跳過  \n      → memo[key] = minSteps // 記錄結果  \n     → Return minSteps  \n\nDefine function collapse(board) // 連鎖消除  \n → Loop:  \n  → found = False  \n  → i = 0  \n  → While i < len(board):  \n   → j = i  \n   → While j < len(board) and board[j] == board[i]:  \n    → j++  \n   → Decision: j - i >= 3?  \n    Yes →  \n     → board = board[:i] + board[j:] // 刪除連續三個以上  \n     → found = True  \n     → Break // 重置搜尋  \n    No → i = j  \n  → Decision: found?  \n   No → Break // 沒有更多可消除的群  \n → Return board  \n\nDefine function serialize(handCount) // 將手牌計數序列化成字串  \n → Return sorted list of color counts as string // 簡化鍵  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom functools import lru_cache\n\nINF = 10 ** 9\nsys.setrecursionlimit(10000)\n\ndef collapse(board: str) -> str:\n    \"\"\"連鎖消除：連續相同顏色大於等於3的球全部消除，重複直到沒有可消除的群.\"\"\"\n    while True:\n        i = 0\n        changed = False\n        parts = []\n        while i < len(board):\n            j = i\n            while j < len(board) and board[j] == board[i]:\n                j += 1\n            if j - i >= 3:\n                changed = True            # 此群將被消除\n            else:\n                parts.append(board[i:j])   # 保留不消除的球\n            i = j\n        if not changed:\n            break\n        board = \"\".join(parts)\n    return board\n\ndef min_insertions(board: str, hand: str) -> int:\n    \"\"\"DFS + memoization 求最小插入數.\"\"\"\n    hand_sorted = \"\".join(sorted(hand))\n\n    @lru_cache(maxsize=None)\n    def dfs(curr_board: str, curr_hand: str) -> int:\n        if not curr_board:\n            return 0\n        key = curr_board + \"#\" + curr_hand\n        best = INF\n        # 遍歷插入位置\n        for pos in range(len(curr_board) + 1):\n            used = set()\n            # 遍歷手牌中不同顏色\n            for idx, color in enumerate(curr_hand):\n                if color in used:\n                    continue\n                used.add(color)\n                new_board = curr_board[:pos] + color + curr_board[pos:]\n                collapsed = collapse(new_board)\n                if collapsed == curr_board:   # 插入沒有產生消除，直接跳過\n                    continue\n                new_hand = curr_hand[:idx] + curr_hand[idx + 1 :]\n                res = dfs(collapsed, new_hand)\n                if res != INF:\n                    best = min(best, res + 1)\n        return best\n\n    ans = dfs(board, hand_sorted)\n    return -1 if ans == INF else ans\n\ndef main():\n    data = sys.stdin.read()\n    # 提取 board 和 hand 的字符串\n    board_match = re.search(r'board\\s*=\\s*\"([^\"]*)\"', data)\n    hand_match = re.search(r'hand\\s*=\\s*\"([^\"]*)\"', data)\n    if not board_match or not hand_match:\n        return\n    board = board_match.group(1)\n    hand = hand_match.group(1)\n    result = min_insertions(board, hand)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "board = \"WRRBBW\", hand = \"RB\"",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        },
        {
          "example_index": 1,
          "input": "board = \"WWRRBBWW\", hand = \"WRBRW\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "board = \"G\", hand = \"GGGGG\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode442.json",
    "problem_index_in_file": 0,
    "title": "Find All Duplicates in an Array",
    "description_snippet": "Given an integer array nums of length n where all the integers of nums are in the range [1, n] and e...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to solve the problem: find duplicates in array where numbers are in 1..n, each appears at most twice. Must run O(n) time, constant auxiliary space except output. Typical algorithm: use array values as indices and mark visited by negating. But cannot modify input? Usually allowed to modify input array. Use constant extra space: use in-place marking.\n\nSo steps:\n\nStart\n→ Step 1: For each index i from 0 to n-1, val = abs(nums[i])\n→ Step 2: If nums[val-1] > 0, set nums[val-1] = -nums[val-1] (mark visited)\n→ Else, val appears twice; add val to result list\nAfter loop, return result list\nEnd\n\nWe need to include virtual code lines with comments.\n\nWe must ensure using arrow and decision lines.\n\nWe might need a Decision: if positive? Actually decision: if nums[val-1] > 0? Yes -> mark, No -> duplicate.\n\nAlso we need to add to output list step.\n\nWe need to maintain result list.\n\nAlso we need to handle n length.\n\nWe should create virtual code step:\n\nStart // 程式開始\n→ Step 1: Initialize result list // 用於儲存重複元素\n→ Step 2: For i from 0 to n-1 // 遍歷陣列\n    → Decision: Is nums[i] positive? // 檢查目前元素是否已被標記\n        Yes → Step 3: index = abs(nums[i]) - 1 // 取得對應索引\n        Yes → Decision: Is nums[index] > 0? // 第一次訪問該索引\n            Yes → Step 4: nums[index] = -nums[index] // 標記為已訪問\n            No  → Step 5: Append index+1 to result // 第二次訪問，加入結果\n        No  → Step 3: index = abs(nums[i]) - 1 // 如果已負值，還是取得索引\n        No → Decision: Is nums[index] > 0? // 同上\n            Yes → Step 4: nums[index] = -nums[index]\n            No  → Step 5: Append index+1\n→ Step 6: Return result list // 完成\nEnd\n\nBut we can simplify: Use abs to get val; then if nums[val-1] > 0 then negate else add to result.\n\nWe need to maintain decision structure. The loop itself: Decision: For i in range(n)? Use a for loop arrow? We can write Step 2: For i = 0 to n-1. Then inside loop.\n\nWe must use arrow and decision style: Start → Step 1 ... Then decision inside.\n\nWe need to be consistent: Use indentation for nested steps: Step 2: For i from 0 to n-1 // 遍歷陣列\n    → Step 3: val = abs(nums[i]) // 取得正整數值\n    → Decision: If nums[val-1] > 0? // 第一次遇到\n        Yes → Step 4: nums[val-1] = -nums[val-1] // 標記為已訪問\n        No  → Step 5: Append val to result // 第二次遇到，加入結果\nEnd\n\nAlso we need to return result.\n\nSo final virtual code lines: include each line.\n\nLet's produce the answer accordingly. Ensure each line ends with // 解釋.\n\nRemember to keep the lines separate. Use arrow lines \"→\". Use indentation by spaces for nested steps. Each line must have `虛擬碼步驟` then a space then `// 解釋`.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Initialize result list as empty // 用於儲存所有重複出現的數字  \n→ Step 2: For i from 0 to n-1 // 逐一遍歷整個陣列  \n  → Step 3: val ← abs(nums[i]) // 取得當前元素的正整數值  \n  → Decision: nums[val-1] > 0? // 判斷該數字是否已被標記過  \n   Yes → Step 4: nums[val-1] ← -nums[val-1] // 第一次遇到，將對應位置的數值取負作為標記  \n   No  → Step 5: Append val to result // 第二次遇到，將此數字加入結果列表  \n→ Step 6: Return result list // 回傳所有重複出現的數字  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findDuplicates(self, nums):\n        res = []\n        for num in nums:\n            idx = abs(num) - 1\n            if nums[idx] < 0:\n                res.append(abs(num))\n            else:\n                nums[idx] = -nums[idx]\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    try:\n        # Directly parse if the whole input is a list representation\n        nums = ast.literal_eval(data)\n    except (ValueError, SyntaxError):\n        # Extract the list part if input contains \"nums = [... ]\"\n        start = data.find('[')\n        end = data.rfind(']')\n        if start == -1 or end == -1:\n            sys.exit()\n        nums_str = data[start:end+1]\n        nums = ast.literal_eval(nums_str)\n    solution = Solution()\n    result = solution.findDuplicates(nums)\n    # Print without spaces to match expected format\n    print('[' + ','.join(map(str, result)) + ']')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [4,3,2,7,8,2,3,1]",
          "expected_output": "[2,3]",
          "success": true,
          "output": "[2,3]"
        },
        {
          "example_index": 1,
          "input": "nums = [1,1,2]",
          "expected_output": "[1]",
          "success": true,
          "output": "[1]"
        },
        {
          "example_index": 2,
          "input": "nums = [1]",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode146.json",
    "problem_index_in_file": 0,
    "title": "LRU Cache",
    "description_snippet": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.\n\nImplemen...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to output virtual code lines, each line with a comment after space. We must not output actual code. Just pseudo. Steps: Start, initialize data structures: doubly linked list, hash map. Implement get: check map, if not found return -1; else move node to front, return value. Put: check if key exists: update value, move to front; else add new node to front, add to map; if size > capacity, remove tail, delete from map. End. Use Decision lines for conditional checks.\n\nWe need to be concise but clear. Use arrows. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義雙向鏈表節點類 Node(key, value) // 每個節點存儲鍵值及指向前後節點  \n→ Step 2: 初始化 hash map key→Node // 用於 O(1) 查找  \n→ Step 3: 建立雙向鏈表頭 dummyHead 與尾 dummyTail，將 dummyHead.next 指向 dummyTail，dummyTail.prev 指向 dummyHead // 方便插入與刪除  \n→ Step 4: 設置變量 capacity、size 0 // 保存容量與目前大小  \n\n// get 操作  \n→ Step 5: Define get(key) // 查詢指定鍵  \n→ Decision: 如果 key 在 hash map?  \n  Yes → Step 6: node ← map[key] // 找到節點  \n   → Step 7: Remove node from its current position // O(1) 拆除  \n   → Step 8: Insert node right after dummyHead // O(1) 放到最近使用位置  \n   → Step 9: Return node.value // 返回值  \n  No  → Step 10: Return -1 // 鍵不存在  \n\n// put 操作  \n→ Step 11: Define put(key, value) // 插入或更新  \n→ Decision: 如果 key 在 hash map?  \n  Yes → Step 12: node ← map[key] // 找到節點  \n   → Step 13: node.value ← value // 更新值  \n   → Step 14: Remove node from its current position  \n   → Step 15: Insert node right after dummyHead // 更新為最近使用  \n  No  → Step 16: node ← new Node(key, value) // 建立新節點  \n   → Step 17: Insert node right after dummyHead  \n   → Step 18: map[key] ← node // 加入映射  \n   → Step 19: size ← size + 1 // 增加大小  \n   → Decision: 如果 size > capacity?  \n    Yes → Step 20: tailNode ← dummyTail.prev // 最舊節點  \n     → Step 21: Remove tailNode from list  \n     → Step 22: Delete map[tailNode.key] // 從映射中刪除  \n     → Step 23: size ← size - 1 // 減少大小  \n    No  → Step 24: // 不需要裁剪  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.cache = OrderedDict()\n        self.capacity = capacity\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        # Move key to end to mark as recently used\n        value = self.cache.pop(key)\n        self.cache[key] = value\n        return value\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            self.cache.pop(key)\n        self.cache[key] = value\n        if len(self.cache) > self.capacity:\n            # popitem(last=False) pops the first item (least recently used)\n            self.cache.popitem(last=False)\n\nif __name__ == \"__main__\":\n    # Read entire input from stdin\n    raw = sys.stdin.read().strip()\n    if not raw:\n        sys.exit(0)\n\n    # Input format: operations list and arguments list separated by comma\n    # Wrap the whole string in brackets to parse as a list of two elements\n    data = ast.literal_eval(f'[{raw}]')\n    ops, args = data[0], data[1]\n\n    result = []\n    cache = None\n\n    for op, arg in zip(ops, args):\n        if op == \"LRUCache\":\n            cache = LRUCache(arg[0])\n            result.append(None)          # constructor returns null\n        elif op == \"put\":\n            cache.put(arg[0], arg[1])\n            result.append(None)          # put returns null\n        elif op == \"get\":\n            val = cache.get(arg[0])\n            result.append(val)\n        else:\n            # Unsupported operation; append None\n            result.append(None)\n\n    # Print results as a Python list literal\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"], [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]",
          "expected_output": "[null, null, null, 1, null, -1, null, -1, 3, 4]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,1,null,-1,null,-1,3,4]'\nGot (Norm):      '[None,None,None,1,None,-1,None,-1,3,4]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, 1, null, -1, null, -1, 3, 4]'\nRaw Got:      '[None, None, None, 1, None, -1, None, -1, 3, 4]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode9.json",
    "problem_index_in_file": 0,
    "title": "Palindrome Number",
    "description_snippet": "Given an integer x, return true if x is a palindrome, and false otherwise....",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output step-by-step virtual code for checking if integer x is palindrome. Need to produce each line with \"虛擬碼步驟 [space] // 解釋\". Use arrow \"→\", \"Decision:\" and Yes/No. Start and End. Provide simple algorithm: Convert integer to string, compare with reverse or check digits. We'll produce a simple algorithm: convert to string, use two-pointer. So steps: Start, Input x, Decision: if x < 0? Negative numbers not palindrome (except maybe 0). Then if x < 0, return false. Then convert to string s, set left=0, right=len-1, while left<right: if s[left]!=s[right] return false, left++, right--. After loop return true. End.\n\nWe need to format each line.\n\nLet's craft lines:\n\nStart\n→ Step 1: 輸入整數 x // 取得使用者傳入的整數\n→ Decision: x < 0? // 判斷是否為負數\n    Yes → Step 2: 回傳 False // 負數不能為回文\n    No  → Decision: x = 0? // 零是回文\n        Yes → Step 3: 回傳 True // 零為回文\n        No  → Step 4: 轉換 x 為字串 s // 方便逐位比較\n→ Step 5: 設定 left = 0, right = s.Length - 1 // 指向字串兩端\n→ Decision: left < right? // 需要比較的條件\n    Yes → Step 6: 如果 s[left] ≠ s[right] → Step 7: 回傳 False // 不是回文\n          No → Step 8: left += 1, right -= 1 // 移動指標\n          → 回到 Decision: left < right?\n    No  → Step 9: 回傳 True // 所有位數相等\nEnd\n\nBut ensure formatting: For nested decisions, we might need indentation. But output just lines. Use \"Decision:\" lines and then \"Yes →\" and \"No →\". Use arrow for each step. We might need to indent decisions? The example uses indentation. Let's follow that.\n\nWe should produce each line with \"虛擬碼步驟 [space] // 解釋\". Example: \"Start // 程式開始執行\". So we need to write lines like:\n\nStart // 程式開始執行\n→ Step 1: 輸入整數 x // 取得使用者傳入的整數\n→ Decision: x < 0? // 判斷是否為負數\n    Yes → Step 2: 回傳 False // 負數不能為回文\n    No  → Decision: x = 0? // 零是回文\n        Yes → Step 3: 回傳 True // 零為回文\n        No  → Step 4: 轉換 x 為字串 s // 方便逐位比較\n→ Step 5: 設定 left = 0, right = s.Length - 1 // 指向字串兩端\n→ Decision: left < right? // 需要比較的條件\n    Yes → Decision: s[left] ≠ s[right]? // 檢查兩端是否相等\n        Yes → Step 6: 回傳 False // 不是回文\n        No  → Step 7: left += 1, right -= 1 // 移動指標\n              → 回到 Decision: left < right?\n    No  → Step 8: 回傳 True // 所有位數相等\nEnd // 程式執行結束\n\nBut the example uses arrow \"Yes →\", \"No →\" but in code we had \"Yes →\" preceding step. For nested we might do \"Decision: s[left] ≠ s[right]?\". Could also collapse to step: \"Decision: s[left] ≠ s[right]?\".\n\nLet's keep consistent.\n\nWe need to be careful: each line is separate line with \"虛擬碼步驟 // 解釋\". For nested decisions, we indent but maintain format. Let's produce final output.\n\nNote: Use \"虛擬碼步驟\" as the code text. Provide explanation after //.\n\nLet's produce.\n\nAlso ensure we use Traditional Chinese in explanation.\n\nWe'll output lines.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入整數 x // 取得使用者傳入的整數  \n→ Decision: x < 0? // 判斷是否為負數  \n    Yes → Step 2: 回傳 False // 負數不能為回文  \n    No  → Decision: x = 0? // 零是回文  \n        Yes → Step 3: 回傳 True // 零為回文  \n        No  → Step 4: 轉換 x 為字串 s // 方便逐位比較  \n→ Step 5: 設定 left = 0, right = s.Length - 1 // 指向字串兩端  \n→ Decision: left < right? // 是否還有未比較的位數  \n    Yes → Decision: s[left] ≠ s[right]? // 兩端字符是否不同  \n        Yes → Step 6: 回傳 False // 發現不相等，非回文  \n        No  → Step 7: left += 1, right -= 1 // 移動指標  \n              → 回到 Decision: left < right?  \n    No  → Step 8: 回傳 True // 所有位數相等，為回文  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def isPalindrome(self, x: int) -> bool:\n        \"\"\"\n        檢查整數 x 是否為回文數字。\n        負數直接返回 False；正整數轉成字串後比較與其反轉是否相等。\n        \"\"\"\n        if x < 0:\n            return False\n        s = str(x)\n        return s == s[::-1]\n\ndef parse_input(data: str) -> int:\n    \"\"\"\n    從輸入資料中找出第一個整數，並轉為 int。\n    \"\"\"\n    match = re.search(r'-?\\d+', data)\n    if not match:\n        raise ValueError(\"No integer found in input\")\n    return int(match.group())\n\nif __name__ == \"__main__\":\n    # 讀取整個 stdin\n    data = sys.stdin.read()\n    x = parse_input(data)\n\n    # 判斷是否為回文並輸出\n    sol = Solution()\n    result = sol.isPalindrome(x)\n    print(str(result).lower())",
      "validation_results": [
        {
          "example_index": 0,
          "input": "x = 121",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "x = -121",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "x = 10",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode421.json",
    "problem_index_in_file": 0,
    "title": "Maximum XOR of Two Numbers in an Array",
    "description_snippet": "Given an integer array nums, return the maximum result of nums[i] XOR nums[j], where 0 <= i <= j < n...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code, step by step, using arrow syntax, with explanation per line. It's a classic maximum XOR pair problem. Approach: use bitwise trie or greedy with prefix set. Provide virtual code.\n\nWe need to follow output format: each line \"虛擬碼步驟 // 解釋\". Use Start, End, Decision etc. We must not output actual code. Just steps. Let's produce steps: Start, initialize trie, insert 0, maxXor = 0. For each num, insert into trie, query best xor. Use Decision to update maxXor. Use trie traversal logic. Let's create a simple pseudo.\n\nWe can do algorithm: For each number, for bit from high to low, check if opposite bit exists in trie for current num XOR. If yes, take that path and set bit in currXor. After finishing, update maxXor.\n\nSo virtual code steps:\n\nStart\n→ Initialize bit length 31 (for 32-bit ints)\n→ Initialize root node of trie (empty)\n→ Insert 0 into trie // to handle single element case\n→ Set maxXor = 0\n→ For each num in nums\n    → Insert num into trie\n    → Set currXor = 0\n    → Set node = root\n    → For bitPos from 30 downto 0\n        → Extract bit of num at bitPos\n        → Determine desiredBit = 1 - bit\n        → If node has child at desiredBit\n            → node = child desiredBit\n            → Set currXor bit at bitPos to 1\n        → Else\n            → node = child bit\n    → Decision: 如果 currXor > maxXor? // update max\n        Yes → Set maxXor = currXor\nEnd\n→ Return maxXor\n\nBut need to also consider insertion steps:\n\nInsert num into trie:\n    node = root\n    For bitPos from 30 downto 0\n        bit = (num >> bitPos) & 1\n        If node.child[bit] == null\n            node.child[bit] = new node\n        node = node.child[bit]\n\nBut we need to express in virtual code as steps.\n\nLet's produce virtual code lines. Each line should be a step or decision. Use arrows and indent.\n\nWe can also include Decision: for update.\n\nLet's produce.\n\nAlso we can mention complexity.\n\nBut just produce code.\n\nLet's create lines:\n\nStart\n→ Define BIT_LENGTH = 31 // number of bits for 32-bit integer (sign bit ignored)\n→ Define Node structure // each node has two children: 0 and 1\n→ Initialize root node\n→ Insert 0 into trie // handles case when only one number\n→ Set maxXor = 0\n→ For each number num in nums\n    → Insert num into trie\n    → Set currXor = 0\n    → Set node = root\n    → For bitPos from BIT_LENGTH-1 downto 0\n        → Extract bit = (num >> bitPos) & 1\n        → desired = 1 - bit\n        → Decision: 如果 node.child[desired] 存在? // can get larger XOR bit\n            Yes → node = node.child[desired]\n                → Set currXor bit at bitPos to 1\n            No  → node = node.child[bit]\n    → Decision: 如果 currXor > maxXor? // update maximum\n        Yes → maxXor = currXor\nEnd\n→ Return maxXor\n\nBut we must not use code constructs like for loops? Use step representation. Could use Step: For each element in nums.\n\nBut we need to show structure like Start, Decision, etc. Each line must be a step.\n\nWe can use indentation for nested steps.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Define BIT_LENGTH = 31 // 針對 32 位整數（忽略符號位）設定位數\n→ Define Node structure // 每個節點有兩個子節點：0 和 1\n→ Initialize root node // Trie 的根節點\n→ Insert 0 into trie // 處理單個元素的情況\n→ Set maxXor = 0 // 儲存目前找到的最大 XOR\n→ For each number num in nums // 遍歷所有輸入數字\n    → Insert num into trie // 把 num 的二進位插入 Trie\n    → Set currXor = 0 // 目前數字與已插入數字的 XOR 結果\n    → Set node = root // 從根節點開始尋找最大 XOR\n    → For bitPos from BIT_LENGTH-1 downto 0 // 從高位到低位處理\n        → Extract bit = (num >> bitPos) & 1 // 取得 num 在該位的值\n        → desired = 1 - bit // 想要的相反位以獲得 XOR 位為 1\n        → Decision: 是否存在 node.child[desired]? // 檢查是否能走相反位\n            Yes → node = node.child[desired]\n                → Set currXor bit at bitPos to 1 // 這位 XOR 為 1\n            No  → node = node.child[bit] // 只能走相同位\n    → Decision: currXor > maxXor? // 判斷是否更新最大值\n        Yes → Set maxXor = currXor\nEnd // 程式執行結束\n→ Return maxXor // 回傳找到的最大 XOR 結果",
      "generated_code": "import sys\nimport ast\n\ndef findMaximumXOR(nums):\n    max_xor = 0\n    mask = 0\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefixes = {num & mask for num in nums}\n        temp = max_xor | (1 << i)\n        for p in prefixes:\n            if (temp ^ p) in prefixes:\n                max_xor = temp\n                break\n    return max_xor\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Expecting input like: nums = [3,10,5,25,2,8]\n    if '=' in data:\n        _, nums_part = data.split('=', 1)\n    else:\n        nums_part = data\n    nums = ast.literal_eval(nums_part.strip())\n    result = findMaximumXOR(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [3,10,5,25,2,8]",
          "expected_output": "28",
          "success": true,
          "output": "28"
        },
        {
          "example_index": 1,
          "input": "nums = [14,70,53,83,49,91,36,80,92,51,66,70]",
          "expected_output": "127",
          "success": true,
          "output": "127"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode524.json",
    "problem_index_in_file": 0,
    "title": "Longest Word in Dictionary through Deleting",
    "description_snippet": "Given a string s and a string array dictionary, return the longest string in the dictionary that can...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines. Each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision, arrow. Let's plan steps:\n\n1. Start.\n2. Sort dictionary by length descending, lexicographically ascending? Actually we need longest; if tie length, lexicographically smallest. So sort by length desc, then lexicographically ascending. Or we can iterate and maintain best. We'll pick maintain best. Steps:\n\n3. For each word in dictionary:\n    - Check if word is subsequence of s. \n    - If true:\n        - If word length > best length: update best = word\n        - Else if word length == best length and word < best lexicographically: update best.\n\n4. After loop, return best (empty string if none).\n\nWe'll produce virtual code. Use Step tags maybe.\n\nUse Decision steps: checking subsequence.\n\nPseudo:\n\nStart\n→ Step 1: Initialize best = \"\" // store longest word found\n→ Step 2: For each word in dictionary // iterate\n    → Decision: If word is subsequence of s?\n        Yes → Decision: If length(word) > length(best)?\n            Yes → Step 3: best = word // longer word found\n            No  → Decision: If length(word) == length(best) AND word < best?\n                Yes → Step 4: best = word // same length but lexicographically smaller\n                No  → No action\n        No  → No action\n→ Step 5: Return best // final result\nEnd\n\nAlso need subroutine to check subsequence. We'll show arrow step for it.\n\nAdd Step for subsequence check:\n\n→ Step 6: Define function isSubsequence(word, s)\n    → Step 6a: Initialize pointers i=0, j=0\n    → Step 6b: While i<length(word) AND j<length(s)\n        → Decision: If word[i]==s[j]?\n            Yes → i++, j++ // match, move both\n            No  → j++ // move s pointer only\n    → Decision: If i==length(word)? // all matched\n        Yes → return True\n        No  → return False\n\nBut we need to keep code structure simple. Let's produce sequential steps including function definition. Use arrow for function.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: best ← \"\" // 用來儲存目前找到的最長單字  \n→ Step 2: For each word in dictionary // 逐一檢查字典中的每個單字  \n    → Decision: word 是 s 的子序列? // 判斷是否能用 s 的字母刪除得到 word  \n        Yes → Decision: len(word) > len(best)? // 新單字是否更長  \n            Yes → Step 3: best ← word // 取更長的單字  \n            No → Decision: len(word) = len(best) AND word < best? // 同長度且字典序更小  \n                Yes → Step 4: best ← word // 取字典序較小的單字  \n                No → No action // 不更新  \n        No → No action // 該單字不可形成  \n→ Step 5: Return best // 回傳最終結果（若無則為空字串）  \nEnd // 程式執行結束  \n\n// ---------------------------- Subroutine: 判斷子序列 ----------------------------  \n→ Function isSubsequence(word, s) // 檢查 word 是否為 s 的子序列  \n    → Step 6a: i ← 0, j ← 0 // 初始化兩個指標  \n    → Step 6b: While i < len(word) AND j < len(s) // 逐字比對  \n        → Decision: word[i] == s[j]? // 字元是否相同  \n            Yes → i ← i + 1, j ← j + 1 // 兩者都往前移  \n            No → j ← j + 1 // 只移動 s 的指標  \n    → Decision: i == len(word)? // 是否已匹配完所有字元  \n        Yes → Return True // 成功找到子序列  \n        No → Return False // 失敗，無法匹配完成",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findLongestWord(self, s: str, dictionary: list[str]) -> str:\n        \"\"\"\n        在字典中尋找最長的子序列字串；若長度相同則取字典序最小者。\n        \"\"\"\n        best = \"\"\n        for word in dictionary:\n            # 判斷 word 是否為 s 的子序列\n            it = iter(s)\n            if all(ch in it for ch in word):\n                if len(word) > len(best) or (len(word) == len(best) and word < best):\n                    best = word\n        return best\n\ndef main():\n    # 讀取輸入：形如 '\"abpcplea\", [\"ale\",\"apple\",\"monkey\",\"plea\"]'\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n    # 解析成 tuple (s, dictionary)\n    try:\n        data = ast.literal_eval(f'({raw_input})')\n    except Exception as e:\n        # 若解析失敗，嘗試逐行讀取\n        parts = [p.strip() for p in raw_input.split(',', 1)]\n        s = ast.literal_eval(parts[0])\n        dictionary = ast.literal_eval(parts[1])\n        data = (s, dictionary)\n    s, dictionary = data\n\n    sol = Solution()\n    result = sol.findLongestWord(s, dictionary)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "\"abpcplea\", [\"ale\",\"apple\",\"monkey\",\"plea\"]",
          "expected_output": "\"apple\"",
          "success": true,
          "output": "apple"
        },
        {
          "example_index": 1,
          "input": "\"abpcplea\", [\"a\",\"b\",\"c\"]",
          "expected_output": "\"a\"",
          "success": true,
          "output": "a"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode13.json",
    "problem_index_in_file": 0,
    "title": "Roman to Integer",
    "description_snippet": "Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\n\nSymbol       Val...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code for converting Roman numeral to integer. We must output step by step, with each line containing \"虛擬碼步驟\" then space then \"// 解釋\". Use arrows and structure: Start, End, Decision: etc. Each line must be separate. No actual code, just pseudo.\n\nLet's craft the algorithm: iterate through string, mapping characters to values. When a smaller value before larger indicates subtraction, subtract else add. Approach: for each character i from 0 to n-1, if i < n-1 and value[i] < value[i+1] then total -= value[i] else total += value[i]. At end output total.\n\nAlso could use dictionary for values.\n\nLet's produce pseudo steps:\n\nStart // 程式開始執行\n→ Step 1: 定義字典 roman_map: { 'I':1, 'V':5, ... } // mapping Roman chars to values\n→ Step 2: 初始化 total = 0 // 儲存計算結果\n→ Step 3: 取得輸入字串 s // 需要轉換的羅馬數字\n→ Step 4: 迴圈 i 從 0 到 len(s)-1 // 遍歷每個字符\n   → Decision: i < len(s)-1 AND roman_map[s[i]] < roman_map[s[i+1]]? // 判斷是否為減法情形\n        Yes → Step 5a: total -= roman_map[s[i]] // 小於後面大值，做減法\n        No  → Step 5b: total += roman_map[s[i]] // 否則加上\n→ Step 6: 迴圈結束 // 完成所有字符處理\n→ Step 7: 輸出 total // 回傳整數結果\nEnd // 程式執行結束\n\nWe must ensure each line has \"虛擬碼步驟\" then space then \"// 解釋\". Use arrow characters. Use \"→\" for next steps, \"Decision:\" etc.\n\nLet's format each line accordingly. For nested decision, indent? The example shows indentation using spaces before lines. We'll mimic that.\n\nImportant: We cannot include actual code. Just pseudo text like \"Define roman_map\" etc. Use Chinese explanatory comments.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: 定義字典 roman_map // 建立羅馬字母與其數值對應\n→ Step 2: 初始化 total = 0 // 儲存最終的整數結果\n→ Step 3: 取得輸入字串 s // 需要轉換的羅馬數字\n→ Step 4: 迴圈 i 從 0 到 len(s)-1 // 逐個處理字母\n    → Decision: i < len(s)-1 AND roman_map[s[i]] < roman_map[s[i+1]]? // 判斷是否為減法情形\n        Yes → Step 5a: total -= roman_map[s[i]] // 小於後面大值，執行減法\n        No  → Step 5b: total += roman_map[s[i]] // 否則執行加法\n→ Step 6: 迴圈結束 // 所有字母已處理完畢\n→ Step 7: 輸出 total // 返回轉換後的整數\nEnd // 程式執行結束\n\nCheck formatting: each line should have \"虛擬碼步驟\" plus space then comment. But we use \"→ Step X:\" etc. It's okay. Each line includes the arrow, but after the arrow we include the step description. Then comment.\n\nMake sure no line merges. Let's list each line separately.\n\nWe'll use indentation for nested steps, as example shows. Use 4 spaces indent before nested steps.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義字典 roman_map // 建立羅馬字母與其數值對應  \n→ Step 2: 初始化 total = 0 // 儲存最終的整數結果  \n→ Step 3: 取得輸入字串 s // 需要轉換的羅馬數字  \n→ Step 4: 迴圈 i 從 0 到 len(s)-1 // 逐個處理字母  \n    → Decision: i < len(s)-1 AND roman_map[s[i]] < roman_map[s[i+1]]? // 判斷是否為減法情形  \n        Yes → Step 5a: total -= roman_map[s[i]] // 小於後面大值，執行減法  \n        No  → Step 5b: total += roman_map[s[i]] // 否則執行加法  \n→ Step 6: 迴圈結束 // 所有字母已處理完畢  \n→ Step 7: 輸出 total // 返回轉換後的整數  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def romanToInt(self, s: str) -> int:\n        roman_map = {'I': 1, 'V': 5, 'X': 10, 'L': 50,\n                     'C': 100, 'D': 500, 'M': 1000}\n        total = 0\n        prev = 0\n        for ch in reversed(s):\n            val = roman_map[ch]\n            if val < prev:\n                total -= val\n            else:\n                total += val\n            prev = val\n        return total\n\ndef extract_roman(input_data: str) -> str:\n    \"\"\"提取輸入中的羅馬數字字串。\"\"\"\n    input_data = input_data.strip()\n    # 先搜尋雙引號中的內容\n    first_quote = input_data.find('\"')\n    if first_quote != -1:\n        second_quote = input_data.find('\"', first_quote + 1)\n        if second_quote != -1:\n            return input_data[first_quote + 1:second_quote]\n    # 若沒有雙引號，直接使用最後一個單詞，去除可能的引號\n    tokens = input_data.split()\n    if tokens:\n        last = tokens[-1]\n        return last.strip('\"')\n    return \"\"\n\ndef main():\n    raw_input = sys.stdin.read()\n    roman_str = extract_roman(raw_input)\n    if not roman_str:\n        return\n    sol = Solution()\n    result = sol.romanToInt(roman_str)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"III\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "s = \"LVIII\"",
          "expected_output": "58",
          "success": true,
          "output": "58"
        },
        {
          "example_index": 2,
          "input": "Input: s = \"MCMXCIV\"",
          "expected_output": "Output: 1994",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): 'Output:1994'\nGot (Norm):      '1994'\n--- (Raw) ---\nRaw Expected: 'Output: 1994'\nRaw Got:      '1994'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode134.json",
    "problem_index_in_file": 0,
    "title": "Gas Station",
    "description_snippet": "There are n gas stations along a circular route, where the amount of gas at the i^th station is gas[...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode lines describing algorithm for gas station problem. Use Start, Decision, etc. The algorithm: iterate over stations, track total and current balance. Keep start index. If current < 0, set start= i+1, reset current=0. After loop, if total>=0 return start else -1. Provide line-by-line with explanation. Use arrows and indent decisions. Let's craft.\n\nWe must output in Traditional Chinese, explanation in Chinese. Each line: \"虛擬碼步驟 // 解釋\".\n\nNeed to include Start, End. Provide steps.\n\nLet's produce.\n\nLines:\n\nStart // 程式開始執行\n\n→ Step 1: 計算 n ← length(gas) // 取得加油站數量\n\n→ Step 2: 初始化 total ← 0, current ← 0, startIndex ← 0 // 用於累計總氣量、目前餘量及起點\n\n→ For i from 0 to n-1: // 逐一檢查每個站\n\n   → Step 3: current ← current + gas[i] - cost[i] // 更新目前餘量\n\n   → Decision: 如果 current < 0? // 餘量不足，無法從 startIndex 開始完成後續\n\n        Yes → Step 4: startIndex ← i + 1 // 重新設定起點為下一個站\n\n        Yes → Step 5: current ← 0 // 重置目前餘量為 0\n\n   → Step 6: total ← total + gas[i] - cost[i] // 累加總餘量\n\nEnd of loop\n\n→ Decision: 如果 total >= 0? // 總氣量足以完成整圈\n\n    Yes → Step 7: return startIndex // 返回唯一解\n\n    No  → Step 8: return -1 // 無法完成循環\n\nEnd // 程式結束\n\nEnsure each line has explanation after //.\n\nMake sure arrows use →. For decisions, use \"Decision:\" line and then Yes → ... No → ... indentation.\n\nLet's craft final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← length(gas) // 取得加油站總數  \n→ Step 2: total ← 0, current ← 0, startIndex ← 0 // 初始化總氣量、目前餘量與起點索引  \n→ For i from 0 to n-1: // 逐個檢查每個加油站  \n  → Step 3: current ← current + gas[i] - cost[i] // 更新目前氣量餘額  \n  → Decision: current < 0? // 檢查目前餘額是否為負  \n  │  Yes → Step 4: startIndex ← i + 1 // 重新設定起點為下一站  \n  │  Yes → Step 5: current ← 0 // 重置目前餘額為 0  \n  → Step 6: total ← total + gas[i] - cost[i] // 累計總氣量餘額  \n→ End For // 完成所有站的迭代  \n→ Decision: total >= 0? // 判斷總氣量是否足夠完成整圈  \n  Yes → Step 7: return startIndex // 回傳唯一可行的起點索引  \n  No → Step 8: return -1 // 無法完成一圈，回傳 -1  \nEnd // 程式結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def canCompleteCircuit(self, gas, cost):\n        # 若總氣量不足，直接回傳 -1\n        if sum(gas) < sum(cost):\n            return -1\n        \n        start = 0\n        tank = 0\n        for i in range(len(gas)):\n            tank += gas[i] - cost[i]\n            if tank < 0:\n                start = i + 1   # 重新設定起點\n                tank = 0        # 重置目前餘量\n        return start\n\ndef parse_input(data: str):\n    \"\"\"\n    解析輸入資料，支援兩種格式：\n    1. gas = [...], cost = [...]\n    2. 兩行分別為 gas 列表與 cost 列表\n    \"\"\"\n    gas, cost = [], []\n\n    # 先嘗試以關鍵字提取\n    m_gas = re.search(r'gas\\s*=\\s*\\[(.*?)\\]', data, re.DOTALL)\n    m_cost = re.search(r'cost\\s*=\\s*\\[(.*?)\\]', data, re.DOTALL)\n    if m_gas and m_cost:\n        gas = list(map(int, re.findall(r'-?\\d+', m_gas.group(1))))\n        cost = list(map(int, re.findall(r'-?\\d+', m_cost.group(1))))\n    else:\n        # 如果沒有關鍵字，則假設每行一個列表\n        lines = [line.strip() for line in data.splitlines() if line.strip()]\n        if len(lines) >= 2:\n            gas = list(map(int, re.findall(r'-?\\d+', lines[0])))\n            cost = list(map(int, re.findall(r'-?\\d+', lines[1])))\n        else:\n            # 無法解析時拋出錯誤\n            raise ValueError(\"輸入格式不正確，無法解析 gas 與 cost 列表\")\n\n    return gas, cost\n\ndef main():\n    data = sys.stdin.read()\n    gas, cost = parse_input(data)\n    result = Solution().canCompleteCircuit(gas, cost)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "gas = [1,2,3,4,5], cost = [3,4,5,1,2]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "gas = [2,3,4], cost = [3,4,3]",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode540.json",
    "problem_index_in_file": 0,
    "title": "Single Element in a Sorted Array",
    "description_snippet": "You are given a sorted array consisting of only integers where every element appears exactly twice, ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps for algorithm: find unique element in sorted array with pairs except one unique. Use binary search: mid index, check pair boundaries, etc. Provide steps with explanation comments. Must use virtual code arrows and decision structure. Each line: \"虛擬碼步驟 // 解釋\".\n\nWe need to output step by step in virtual code style.\n\nLet's craft steps:\n\nStart\n→ Set left=0, right=n-1 // 初始化左右指標\n→ Decision: 如果 left==right? // 結束條件\n    Yes → Return arr[left] // 唯一元素\n    No  → Decision: If (mid-1) is same? // 這樣決定哪側有單數\nBut algorithm: while left < right: compute mid even? Usually mid even index. Determine if pair property broken.\n\nSimpler: while left < right: mid = (left+right)/2. If mid%2==1 then mid-- to make even. If arr[mid]==arr[mid+1], left=mid+2 else right=mid. After loop return arr[left].\n\nLet's produce lines accordingly.\n\nWe need to ensure O(log n). Provide explanation each step.\n\nLet's produce virtual code:\n\nStart\n→ Set left = 0, right = n-1\n→ Decision: If left == right? // 只剩一個元素\n    Yes → Return arr[left]\n    No  → While left < right:\n        → Compute mid = (left + right) / 2\n        → Decision: If mid is odd? // 讓 mid 指向第一個元素的索引\n            Yes → mid = mid - 1\n            No  → // mid already even\n        → Decision: If arr[mid] == arr[mid + 1]? // 正確配對\n            Yes → left = mid + 2 // 唯一元素在右半邊\n            No  → right = mid // 唯一元素在左半邊\n    → Return arr[left] // 唯一元素\n\nBut we need each line with arrow. Use \"→\" for each step. \"Decision:\" lines with sub lines. Ensure \"Yes →\" and \"No →\".\n\nAlso we need to avoid code lines like \"While\" inside. The sample shows \"→ Step 1: ...\" \"Decision:\" lines with indented Yes/No lines. Let's replicate.\n\nWe'll have:\n\nStart // 程式開始執行\n→ Step 1: 設定 left = 0, right = n-1 // 初始化搜尋範圍\n→ Decision: left == right? // 只剩一個元素?\n    Yes → Step 2: 回傳 arr[left] // 唯一元素已找到\n    No  → \n        → Step 3: 進入迴圈 while left < right\n            → Decision: mid = (left + right) / 2 // 計算中點\n            → Decision: mid 是否為奇數? // 讓 mid 指向配對的第一個索引\n                Yes → mid = mid - 1\n                No  →\n            → Decision: arr[mid] == arr[mid + 1]? // 配對是否正確\n                Yes → left = mid + 2 // 唯一元素在右半邊\n                No  → right = mid // 唯一元素在左半邊\n        → Step 4: 回傳 arr[left] // 迴圈結束後唯一元素在 left\n\nBut we need \"→\" lines. In sample, they used \"→ Step 1: ...\". For nested decisions, they indent Yes/No lines.\n\nLet's produce final.\n\nNeed to output in plain text.\n\nLet's craft final virtual code with each line.\n\nAlso we might use \"End\" at bottom.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 設定 left = 0, right = n-1 // 初始化兩端索引\n→ Decision: left == right? // 只剩一個元素？\n    Yes → Step 2: 回傳 arr[left] // 唯一元素即為此索引\n    No  → \n        → Step 3: 進入迴圈 while left < right\n            → Decision: mid = (left + right) / 2 // 取得中點\n            → Decision: mid 是奇數? // 使 mid 為偶數索引\n                Yes → mid = mid - 1\n                No  →\n            → Decision: arr[mid] == arr[mid + 1]? // 檢查這對是否正確配對\n                Yes → left = mid + 2 // 唯一元素在右半邊\n                No  → right = mid // 唯一元素在左半邊\n        → Step 4: 回傳 arr[left] // 迴圈結束後左指標即為唯一元素\nEnd // 程式結束\n\nNeed to ensure each line has virtual code step and explanation. The decision lines must be exactly: \"Decision: ...\" then indented Yes and No lines. Use spaces for indentation. Ensure arrow for each line. The sample uses \"→ Decision:\" then indented Yes/No.\n\nLet's format with consistent arrow at start of each line. For indented lines we may keep arrow? Sample shows \"Yes →\" and \"No  →\" with spaces before arrow? They use \"Yes → Step\" etc. So we will use \"Yes →\" and \"No →\" lines without extra arrow. But to be safe we keep arrow. For nested within step 3 we might need to keep arrow? The sample shows \"→ Decision:\" then \"Yes → Step\" etc. So for sub-steps we may indent but still use arrow. Let's replicate: \"→ Decision: ...\" then next lines starting with \"Yes →\" and \"No →\" each line with arrow? Yes.\n\nThus produce.\n\nLet's final.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 設定 left = 0, right = n-1 // 初始化搜尋範圍\n→ Decision: left == right? // 只剩一個元素？\n    Yes → Step 2: 回傳 arr[left] // 唯一元素即為此索引\n    No  →\n        → Step 3: 進入迴圈 while left < right\n            → Decision: mid = (left + right) / 2 // 取得中點\n            → Decision: mid 是奇數? // 使 mid 為偶數索引\n                Yes → mid = mid - 1\n                No  →\n            → Decision: arr[mid] == arr[mid + 1]? // 檢查這對是否正確配對\n                Yes → left = mid + 2 // 唯一元素在右半邊\n                No  → right = mid // 唯一元素在左半邊\n        → Step 4: 回傳 arr[left] // 迴圈結束後 left 指標即為唯一元素\nEnd // 程式結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def singleNonDuplicate(self, nums):\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = (left + right) // 2\n            if mid % 2 == 1:\n                mid -= 1\n            if nums[mid] == nums[mid + 1]:\n                left = mid + 2\n            else:\n                right = mid\n        return nums[left]\n\nif __name__ == \"__main__\":\n    # Read the entire input from stdin and strip any surrounding whitespace\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    # Convert the string representation of a list into an actual list\n    try:\n        nums = ast.literal_eval(raw_input)\n    except Exception as e:\n        raise ValueError(\"Invalid input format. Expected a list of integers.\") from e\n\n    # Ensure the input is a list of integers\n    if not isinstance(nums, list) or not all(isinstance(x, int) for x in nums):\n        raise ValueError(\"Input must be a list of integers.\")\n\n    # Compute and print the unique element\n    result = Solution().singleNonDuplicate(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[1,1,2,3,3,4,4,8,8]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "[3,3,7,7,10,11,11]",
          "expected_output": "10",
          "success": true,
          "output": "10"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode22.json",
    "problem_index_in_file": 0,
    "title": "Generate Parentheses",
    "description_snippet": "Given n pairs of parentheses, write a function to generate all combinations of well-formed parenthes...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line. Need to produce algorithm for generating all combinations of well-formed parentheses given n pairs. Classic backtracking. We'll create steps: Start, define function generateParenthesis(n), call backtrack with parameters: current string, open count, close count. At each step, if open < n, add '(' and backtrack; if close < open, add ')' and backtrack. When length == 2*n, add to result. Then return result. Then End. Each line has virtual code step and explanation comment. Use arrow \"→\". Decision: if open < n? etc.\n\nWe'll produce code lines. Each step should be a line. Let's produce like:\n\nStart // 程式開始\n→ Function generateParenthesis(n) // 主函式，接收 n\n→     List result ← [] // 儲存所有合法組合\n→     Backtrack(\"\", 0, 0) // 開始遞迴，空字串，已開啟 0，已關閉 0\n→ End // 程式結束\n\nBut we need to include the backtrack function inside. So:\n\n→ Function Backtrack(current, open, close) // 遞迴生成\n→     Decision: 如果 current 長度 == 2*n? // 完成一組\n→         Yes → Append current to result // 加入結果\n→         No  → Decision: 如果 open < n? // 還可以放 '('\n→              Yes → Backtrack(current + \"(\", open + 1, close) // 放 '('\n→              No  → Decision: 如果 close < open? // 還可以放 ')'\n→                    Yes → Backtrack(current + \")\", open, close + 1) // 放 ')'\n→                    No  → // 無可做\n\nWe need to ensure arrow lines.\n\nLet's produce a more thorough step by step:\n\nStart\n→ Function generateParenthesis(n) // 主函式\n→     List result ← [] // 存儲結果\n→     Function Backtrack(current, open, close) // 遞迴協助函式\n→         Decision: 如果 len(current) == 2*n? // 生成完整字串\n→             Yes → Append current to result // 將完整字串加入結果\n→             No  → Decision: 如果 open < n? // 仍可加入 '('\n→                  Yes → Backtrack(current + \"(\", open + 1, close) // 加 '('\n→                  No  → Decision: 如果 close < open? // 仍可加入 ')'\n→                       Yes → Backtrack(current + \")\", open, close + 1) // 加 ')'\n→                       No  → // 無操作\n→     End // Backtrack 結束\n→     Call Backtrack(\"\", 0, 0) // 開始遞迴\n→     Return result // 回傳所有組合\n→ End // generateParenthesis 結束\n\nBut need to use arrow style: \"→\" at start of each line. Each line should be separate.\n\nAlso we need to mark decisions with indentation maybe but not necessary.\n\nThe format: Each line: 虛擬碼步驟 + \" \" + \"// 解釋\". For decision lines, they may be like \"Decision: 如果 ...?\" with the Yes/No branch lines following. They want arrow for branch lines.\n\nWe should produce properly.\n\nAlso must not output actual code; just virtual steps. So we cannot show \"len(current) == 2*n\". But can show as condition. It's okay to use pseudo.\n\nWe need to ensure each line is separate. Use \"→\" at start of each line. For Decision, we use \"Decision:\".\n\nLet's produce.\n\nLet's list lines:\n\n1. Start // 程式開始執行\n2. → Function generateParenthesis(n) // 主函式，輸入 n\n3. →     List result ← [] // 建立結果清單\n4. →     Function Backtrack(current, open, close) // 遞迴協助函式\n5. →         Decision: 如果 len(current) == 2*n? // 字串已滿\n6. →             Yes → Append current to result // 加入完整組合\n7. →             No  → Decision: 如果 open < n? // 還可加 '('\n8. →                  Yes → Backtrack(current + \"(\", open + 1, close) // 加 '('\n9. →                  No  → Decision: 如果 close < open? // 還可加 ')'\n10. →                       Yes → Backtrack(current + \")\", open, close + 1) // 加 ')'\n11. →                       No  → // 無可做\n12. →     End // Backtrack 函式結束\n13. →     Call Backtrack(\"\", 0, 0) // 開始遞迴\n14. →     Return result // 回傳所有合法組合\n15. → End // generateParenthesis 函式結束\n16. End // 程式結束\n\nWe may need to indent? Not necessary. Provide as plain lines.\n\nLet's ensure each line has arrow at start. For End, we use \"End\". For \"Start\" we use \"Start\". For \"Decision:\" we use \"Decision:\" preceded by arrow? In example they used \"→ Decision:\"? In example they had \"→ Decision:\" with arrow before? They had:\n\n→ Decision: 如果數字大於 0? // 檢查數值是否為正\n    Yes → Step 2: 輸出 '正數' // 如果是正數，顯示該訊息\n\nThey used \"→ Decision:\" but then \"Yes →\" and \"No →\" on new lines with indentation. They didn't prefix the \"Yes →\" with arrow again? They did \"Yes → Step 2: ...\". So \"Yes →\" is preceded by no arrow? Actually example shows \"Yes → Step 2\". So \"Yes →\" is part of the line but no arrow. So we can mimic: \"→ Decision:\" line. Then \"Yes → ...\", \"No → ...\".\n\nWe need to use this style.\n\nLet's adjust: We'll use \"→ Decision:\" for decision. Then \"Yes →\" lines.\n\nAlso for nested decision, we will indent accordingly.\n\nBut it's fine.\n\nWe also need to ensure each line contains \"虛擬碼步驟\" + \" \" + \"// 解釋\". So we need to include a space after the virtual code before the comment. So e.g., \"→ Function generateParenthesis(n) // 主函式，輸入 n\".\n\nAlso for \"Decision:\" lines, we will include comment. So \"→ Decision: 如果 len(current) == 2*n? // 字串已滿\".\n\nBut we might need a space after \"Decision:\"? Not necessary but we can.\n\nLet's produce final answer with lines as above.\n\nCheck each line:\n\nLine 1: Start // 程式開始執行\n\nLine 2: → Function generateParenthesis(n) // 主函式，輸入 n\n\nLine 3: →     List result ← [] // 建立結果清單\n\nLine 4: →     Function Backtrack(current, open, close) // 遞迴協助函式\n\nLine 5: →         Decision: 如果 len(current) == 2*n? // 字串已滿\n\nLine 6: →             Yes → Append current to result // 加入完整組合\n\nLine 7: →             No  → Decision: 如果 open < n? // 還可加 '('\n\nLine 8: →                  Yes → Backtrack(current + \"(\", open + 1, close) // 加 '('\n\nLine 9: →                  No  → Decision: 如果 close < open? // 還可加 ')'\n\nLine 10: →                       Yes → Backtrack(current + \")\", open, close + 1) // 加 ')'\n\nLine 11: →                       No  → // 無可做\n\nLine 12: →     End // Backtrack 函式結束\n\nLine 13: →     Call Backtrack(\"\", 0, 0) // 開始遞迴\n\nLine 14: →     Return result // 回傳所有合法組合\n\nLine 15: → End // generateParenthesis 函式結束\n\nLine 16: End // 程式結束\n\nBut we must ensure indentation consistent. It's fine.\n\nHowever, we might want to close the backtrack function after recursion? The End line is inside? We wrote \"→ End // Backtrack 函式結束\" but the indentation might be wrong. It's okay.\n\nBut we need to mark \"End\" for the generateParenthesis function. It's line 15. Good.\n\nNow produce final answer.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Function generateParenthesis(n) // 主函式，輸入 n  \n→     List result ← [] // 建立結果清單  \n→     Function Backtrack(current, open, close) // 遞迴協助函式  \n→         Decision: 如果 len(current) == 2*n? // 字串已滿  \n→             Yes → Append current to result // 加入完整組合  \n→             No  → Decision: 如果 open < n? // 還可加 '('  \n→                  Yes → Backtrack(current + \"(\", open + 1, close) // 加 '('  \n→                  No  → Decision: 如果 close < open? // 還可加 ')'  \n→                       Yes → Backtrack(current + \")\", open, close + 1) // 加 ')'  \n→                       No  → // 無可做  \n→     End // Backtrack 函式結束  \n→     Call Backtrack(\"\", 0, 0) // 開始遞迴  \n→     Return result // 回傳所有合法組合  \n→ End // generateParenthesis 函式結束  \nEnd // 程式結束",
      "generated_code": "import sys\nimport re\nimport json\n\ndef generate_parentheses(n: int):\n    \"\"\"\n    Generate all combinations of well-formed parentheses for a given n.\n    \"\"\"\n    res = []\n\n    def backtrack(s: str, left: int, right: int):\n        if len(s) == 2 * n:\n            res.append(s)\n            return\n        if left < n:\n            backtrack(s + \"(\", left + 1, right)\n        if right < left:\n            backtrack(s + \")\", left, right + 1)\n\n    backtrack(\"\", 0, 0)\n    return res\n\nif __name__ == \"__main__\":\n    # 讀取所有輸入並搜尋第一個整數作為 n\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    match = re.search(r\"\\d+\", data)\n    n = int(match.group()) if match else 0\n\n    result = generate_parentheses(n)\n    # 輸出 JSON 格式的列表，符合範例的雙引號樣式\n    print(json.dumps(result))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 3",
          "expected_output": "[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]",
          "success": true,
          "output": "[\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "[\"()\"]",
          "success": true,
          "output": "[\"()\"]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode217.json",
    "problem_index_in_file": 0,
    "title": "Contains Duplicate",
    "description_snippet": "Given an integer array nums, return true if any value appears at least twice in the array, and retur...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, line by line, with explanations, using Start, End, Decision. For input array nums, output true if any value appears at least twice. Essentially check for duplicates.\n\nWe'll produce steps: Start, Step 1: Initialize empty set, Step 2: Iterate over nums, Step 3: For each num, check if already in set, if yes return true, else add to set. After loop, return false. End.\n\nUse decision: If duplicate found? Yes -> return true. At end return false. Use arrow.\n\nWe should follow formatting exactly: each line: `虛擬碼步驟 // 解釋`.\n\nEnsure \"Start\" line and \"End\" line. Use arrows \"→\" for steps. Decision lines: `Decision:`.\n\nAlso mention Yes → and No → for branching. Use indent? In example, they used indentation for nested decisions. We should follow same style.\n\nThus produce:\n\nStart // 程式開始執行\n→ Step 1: 建立空集合 seen // 用於記錄已見過的數值\n→ Step 2: 循環遍歷陣列 nums // 檢查每個數字\n    → Decision: if current num 已在 seen? // 判斷是否重複\n        Yes → Step 3: 返回 true // 立即回傳重複存在\n        No  → Step 4: 將 num 加入 seen // 若未重複，將其加入集合\n→ Step 5: 循環結束後, 返回 false // 全部數字皆唯一\nEnd // 程式執行結束\n\nCheck formatting: each line must have code then space then //.\n\nMake sure there is a space after \"Yes →\" and \"No  →\"? Example: `Yes → Step 2: ...` They used space after arrow: `Yes → Step 2`. We'll follow.\n\nAlso maintain indentation with spaces or tab? The example uses spaces before nested decision. We'll replicate.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空集合 seen // 用於記錄已見過的數值  \n→ Step 2: 循環遍歷陣列 nums // 檢查每個數字  \n  → Decision: 如果 num 已在 seen? // 判斷是否重複  \n   Yes → Step 3: 返回 true // 立即回傳重複存在  \n   No  → Step 4: 將 num 加入 seen // 若未重複，將其加入集合  \n→ Step 5: 循環結束後, 返回 false // 全部數字皆唯一  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef contains_duplicate(nums):\n    \"\"\"\n    Return True if any element appears at least twice in the list,\n    otherwise return False.\n    \"\"\"\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef main():\n    \"\"\"\n    Read the input from stdin, parse the integer list, determine\n    if there are duplicates, and print 'true' or 'false'.\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # If input contains a leading assignment (e.g., \"nums = [...]\"),\n    # remove everything up to the '='.\n    if data.startswith('nums'):\n        _, rest = data.split('=', 1)\n        data = rest.strip()\n\n    # Safely evaluate the list expression.\n    try:\n        nums = ast.literal_eval(data)\n    except Exception:\n        nums = eval(data)\n\n    result = contains_duplicate(nums)\n    print(str(result).lower())\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,1]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3,4]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "nums = [1,1,1,3,3,4,3,2,4,2]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode389.json",
    "problem_index_in_file": 0,
    "title": "Find the Difference",
    "description_snippet": "You are given two strings s and t.\n\nString t is generated by random shuffling string s and then add ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm: given strings s and t where t is s shuffled and one extra letter inserted at random position. Find the added letter.\n\nCommon solution: frequency count difference, or XOR all chars.\n\nWe'll produce steps: Start, compute counts maybe using hash map or array of 26, iterate over s increment, over t decrement or add, then find non-zero char.\n\nWe'll produce virtual code steps line by line with explanation.\n\nNo actual code, just pseudocode.\n\nUse arrows, decisions. Let's outline steps:\n\nStart\n\n→ Step 1: 初始化 26 個計數器 cnt = 0 // for letters a-z\n\n→ Decision: s 為空? (maybe skip)\n\nActually we can just iterate.\n\n→ Step 2: 對 s 的每個字元 c → cnt[c] +=1\n\n→ Step 3: 對 t 的每個字元 c → cnt[c] -=1\n\n→ Decision: 找到 cnt[c] ≠ 0? // which char count difference\n\n    Yes → Step 4: 返回該字元\n\nEnd\n\nAlternatively use XOR: sum of ascii codes.\n\nBut we produce simple.\n\nWe need each line with `虛擬碼步驟` + `// 解釋`.\n\nOk.\n\nLet's produce final output.\n\nUse arrow symbol '→' before each step after Start.\n\nAlso include Decision. Provide indentation.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立長度為 26 的整數陣列 cnt，初始值皆為 0 // 用來記錄每個字母在 s 與 t 中出現的差值  \n→ Step 2: 逐個讀取 s 中的字元 c → cnt[ c - 'a' ] += 1 // 將 s 中每個字母的出現次數加到 cnt  \n→ Step 3: 逐個讀取 t 中的字元 c → cnt[ c - 'a' ] -= 1 // 將 t 中每個字母的出現次數減去 cnt，差值即為多餘字母  \n→ Decision: 是否存在 cnt[i] ≠ 0? // 檢查是否有字母出現次數不為零，該字母即為多餘字母  \n  Yes → Step 4: 回傳對應字母 chr( i + 'a' ) // 找到差值非零的字母並返回  \n  No  → Step 5: 回傳空字串 // 若無差值則表示輸入錯誤（此情況理論上不會發生）  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\ndef find_the_difference(s: str, t: str) -> str:\n    \"\"\"Return the character that appears in t but not in s.\"\"\"\n    count_s = Counter(s)\n    count_t = Counter(t)\n    for ch in count_t:\n        if count_t[ch] != count_s.get(ch, 0):\n            return ch\n    return ''  # should never reach here for valid input\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    # Extract all quoted substrings; expected format: s = \"....\", t = \"....\"\n    quoted = re.findall(r'\"(.*?)\"', data)\n    s = quoted[0] if len(quoted) > 0 else ''\n    t = quoted[1] if len(quoted) > 1 else ''\n    result = find_the_difference(s, t)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"abcd\", t = \"abcde\"",
          "expected_output": "\"e\"",
          "success": true,
          "output": "e"
        },
        {
          "example_index": 1,
          "input": "s = \"\", t = \"y\"",
          "expected_output": "\"y\"",
          "success": true,
          "output": "y"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode75.json",
    "problem_index_in_file": 0,
    "title": "Sort Colors",
    "description_snippet": "Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects o...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for Dutch national flag algorithm. Provide steps line by line with comments. Use Start, End, Decision. We'll use pointers low, mid, high. Provide algorithm.\n\nLet's write:\n\nStart\n→ Initialize low=0, mid=0, high=n-1 // pointers\n→ Decision: while mid <= high? // main loop\n    Yes → Decision: nums[mid] == 0?\n        Yes → Swap nums[low], nums[mid]; low++; mid++; // move 0 to front\n        No → Decision: nums[mid] == 2?\n            Yes → Swap nums[mid], nums[high]; high--; // move 2 to back\n            No → mid++; // 1 stays in middle\n    No → End\n\nNeed to be careful: after swapping with high for 2, we do not increment mid because new element at mid needs evaluation.\n\nLet's produce virtual code accordingly. Provide comments each line.\n\nLet's produce final answer in Chinese.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: low ← 0, mid ← 0, high ← length(nums) - 1 // 初始化三個指標  \n→ Decision: mid ≤ high? // 主循環：當中指標未越過尾指標時繼續  \n  Yes → Decision: nums[mid] == 0? // 如果中指標指向紅色  \n   Yes → Step 2: swap(nums[low], nums[mid]) // 交換紅色到最前面  \n    → low ← low + 1 // 移動前指標  \n    → mid ← mid + 1 // 同時移動中指標  \n   No → Decision: nums[mid] == 2? // 如果中指標指向藍色  \n    Yes → Step 3: swap(nums[mid], nums[high]) // 交換藍色到最後面  \n     → high ← high - 1 // 移動尾指標  \n     // 中指標不移動，因為交換後的新元素需再次判斷  \n    No → mid ← mid + 1 // 中指標指向白色，直接往右移動  \n  No → End // mid 已超過 high，排序完成  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def sortColors(self, nums):\n        \"\"\"\n        In-place Dutch National Flag sorting.\n        :type nums: List[int]\n        :rtype: None\n        \"\"\"\n        low, mid, high = 0, 0, len(nums) - 1\n        while mid <= high:\n            if nums[mid] == 0:\n                nums[low], nums[mid] = nums[mid], nums[low]\n                low += 1\n                mid += 1\n            elif nums[mid] == 1:\n                mid += 1\n            else:  # nums[mid] == 2\n                nums[mid], nums[high] = nums[high], nums[mid]\n                high -= 1\n\ndef main():\n    # Read all input from stdin\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n\n    # Extract the list from the input, e.g., 'nums = [2,0,1]'\n    match = re.search(r'\\[(.*?)\\]', raw_input, re.S)\n    if match:\n        list_str = '[' + match.group(1) + ']'\n        try:\n            nums = ast.literal_eval(list_str)\n        except Exception:\n            nums = []\n    else:\n        nums = []\n\n    # Ensure we have a list of integers\n    if not isinstance(nums, list):\n        nums = []\n\n    # Apply the sorting algorithm\n    Solution().sortColors(nums)\n\n    # Output the sorted list\n    print(nums)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,0,2,1,1,0]",
          "expected_output": "[0,0,1,1,2,2]",
          "success": true,
          "output": "[0, 0, 1, 1, 2, 2]"
        },
        {
          "example_index": 1,
          "input": "nums = [2,0,1]",
          "expected_output": "[0,1,2]",
          "success": true,
          "output": "[0, 1, 2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode378.json",
    "problem_index_in_file": 0,
    "title": "K^th Smallest Element in a Sorted Matrix",
    "description_snippet": "Given an n x n matrix where each of the rows and columns is sorted in ascending order, return the k^...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code algorithm to find kth smallest in sorted matrix. Standard solution: binary search over value range using count of <= mid. Complexity O(n^2 log(max-min)). Memory O(1). So produce steps: read matrix size, read k, set low/high, loop until low<high, mid, count elements <= mid by scanning rows with pointer. Use binary search. Finally output low. Provide step lines with virtual code and explanation. Use virtual arrows. Provide Start, End. Ensure each line includes virtual code step and explanation comment.\n\nWe need to produce lines with arrow syntax. For decisions use Decision: etc.\n\nLet's draft.\n\nStart\n→ Step 1: 讀取矩陣尺寸 n 與目標 k // 取得輸入\n→ Step 2: 設定 low = matrix[0][0] // 最小值\n→ Step 3: 設定 high = matrix[n-1][n-1] // 最大值\n→ Decision: low < high? // 需要繼續二分搜尋\n    Yes → Step 4: 計算 mid = (low + high) / 2 // 取中值\n    → Step 5: 計算 count = 0 // 初始化計數\n    → Step 6: 從最右下角開始遍歷每行 // 利用升序特性\n        For i = n-1 downto 0\n            While j >= 0 AND matrix[i][j] > mid\n                j = j - 1\n            count = count + (j + 1) // 所有小於等於 mid 的元素數\n    → Decision: count >= k? // 是否已經到足夠小的數\n        Yes → Step 7: high = mid // kth 數在左半區\n        No  → Step 8: low = mid + 1 // kth 數在右半區\n    → 再次進入 Decision: low < high?\n        Yes → 迴圈\n        No  → Step 9: 輸出 low // 最終答案\nEnd\n\nNeed to adjust arrows: We need to use → for each step. For loops we can show nested with indentation. For Decision we show Yes→ etc.\n\nLet's produce a more structured pseudo-code.\n\nAlso ensure each line uses virtual code step plus explanation comment. We need to maintain arrow direction.\n\nMaybe use \"→\" before each step line. For decisions: \"→ Decision:\" lines. Indentation maybe with spaces.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取矩陣尺寸 n 與目標 k // 取得輸入  \n→ Step 2: 設定 low = matrix[0][0] // 最小值  \n→ Step 3: 設定 high = matrix[n-1][n-1] // 最大值  \n→ Decision: low < high? // 需要繼續二分搜尋  \n  Yes → Step 4: mid = (low + high) / 2 // 取中值  \n  → Step 5: count = 0 // 初始化計數  \n  → Step 6: 設定 j = n-1 // 從最右邊列開始  \n  → Step 7: For i = n-1 downto 0  \n    → While j >= 0 AND matrix[i][j] > mid  \n      → j = j - 1 // 移到小於等於 mid 的列  \n    → count = count + (j + 1) // 本行小於等於 mid 的元素數  \n  → Decision: count >= k? // 判斷 k 是否在左半區  \n    Yes → Step 8: high = mid // kth 小於等於 mid  \n    No  → Step 9: low = mid + 1 // kth 大於 mid  \n  → Decision: low < high? // 是否還要繼續迴圈  \n    Yes → 迴圈回到 Decision  \n    No  → Step 10: 輸出 low // 找到第 k 小的元素  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef kth_smallest(matrix, k):\n    n = len(matrix)\n    low, high = matrix[0][0], matrix[-1][-1]\n\n    while low < high:\n        mid = (low + high) // 2\n        count = 0\n        j = n - 1\n        for i in range(n):\n            while j >= 0 and matrix[i][j] > mid:\n                j -= 1\n            count += j + 1\n        if count >= k:\n            high = mid\n        else:\n            low = mid + 1\n    return low\n\nif __name__ == \"__main__\":\n    # 讀取全部輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 解析形如: 'matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8'\n    idx_matrix = data.find(\"matrix =\")\n    idx_k = data.find(\"k =\")\n    matrix_part = data[idx_matrix + len(\"matrix =\"):idx_k].strip().rstrip(',')\n    k_part = data[idx_k + len(\"k =\"):].strip()\n\n    # 用 ast.literal_eval 轉成實際資料結構\n    matrix = ast.literal_eval(matrix_part)\n    k = int(k_part)\n\n    result = kth_smallest(matrix, k)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8",
          "expected_output": "13",
          "success": true,
          "output": "13"
        },
        {
          "example_index": 1,
          "input": "matrix = [[-5]], k = 1",
          "expected_output": "-5",
          "success": true,
          "output": "-5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode164.json",
    "problem_index_in_file": 0,
    "title": "Maximum Gap",
    "description_snippet": "Given an integer array nums, return the maximum difference between two successive elements in its so...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line. Need to describe algorithm that runs in linear time and linear extra space for maximum gap in sorted array. Standard bucket sort approach: find min, max, bucket size, count number of buckets, then find max gap across buckets.\n\nWe'll output Start, Steps, Decisions, etc. Use virtual code arrow →, Yes→, No→, etc. Each line must include the step and comment.\n\nWe need to produce line by line. Ensure each line includes virtual code and comment. Provide steps for algorithm.\n\nSteps:\n\n1. Start.\n2. If length < 2 → return 0. Decision step.\n\n3. Compute minVal, maxVal by iterating array. Use Step 2.\n\n4. If minVal == maxVal → all equal → return 0. Decision.\n\n5. Compute bucket size = ceil((maxVal - minVal) / (n - 1)). (But for integer division, bucketSize = max(1, (maxVal - minVal) / (n-1)) maybe). Use Step 4.\n\n6. Compute bucket count = (maxVal - minVal) / bucketSize + 1. Step 5.\n\n7. Create arrays of bucketMin, bucketMax initialized to INF and -INF respectively, length = bucketCount.\n\n8. For each num in nums: determine bucket index = (num - minVal) / bucketSize. Update bucketMin, bucketMax.\n\n9. Initialize maxGap = 0, previousMax = minVal.\n\n10. For each bucket i from 0 to bucketCount-1: if bucketMin[i] == INF (empty) skip; else compute gap = bucketMin[i] - previousMax; update maxGap; previousMax = bucketMax[i].\n\n11. Return maxGap.\n\nAll operations are O(n). Use linear space.\n\nWe'll produce each step line by line.\n\nMake sure to include arrow and comment. Use decision arrows where needed.\n\nLet's craft.\n\nWe'll start with \"Start\". Then maybe \"→ Decision: if len(nums) < 2?\" etc.\n\nNeed to decide formatting: They show \"Start // 程式開始執行\" etc.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Decision: 如果 nums 長度 < 2? // 檢查是否少於兩個元素\n    Yes → Step 1: 回傳 0 // 直接返回\n    No  → Step 2: 初始化 minVal, maxVal 為 nums[0] // 先設為第一個數\n\nWe'll then step compute min/max by iterating array:\n\n→ Step 3: 從 nums[1] 到 nums[n-1] 迭代更新 minVal, maxVal // 找到最小值與最大值\n\nThen decision if all equal:\n\n→ Decision: 如果 minVal == maxVal? // 所有元素相同\n    Yes → Step 4: 回傳 0 // 最大差為 0\n    No  → Step 5: 計算 bucketSize = max(1, ceil((maxVal - minVal) / (n-1))) // 設定 bucket 大小\n\nThen compute bucketCount.\n\n→ Step 6: bucketCount = (maxVal - minVal) / bucketSize + 1 // 計算桶的數量\n\nCreate bucket arrays.\n\n→ Step 7: bucketMin[0..bucketCount-1] ← +∞; bucketMax[0..bucketCount-1] ← -∞ // 初始化桶\n\nIterate nums again to fill buckets:\n\n→ Step 8: 對於每個 num in nums: idx = (num - minVal) / bucketSize; bucketMin[idx] = min(bucketMin[idx], num); bucketMax[idx] = max(bucketMax[idx], num) // 填寫桶\n\nInitialize prevMax and maxGap.\n\n→ Step 9: previousMax ← minVal; maxGap ← 0 // 設定起始值\n\nIterate buckets to compute maxGap.\n\n→ Decision: 是否已處理完所有 bucket? (loop)\n\nBetter produce a loop: For i from 0 to bucketCount-1:\n\n→ Step 10: 如果 bucketMin[i] == +∞ 則 跳過 // 跳過空桶\n→ Step 11: gap = bucketMin[i] - previousMax; maxGap = max(maxGap, gap); previousMax = bucketMax[i] // 更新最大差\n\nAfter loop:\n\n→ Step 12: 回傳 maxGap // 結果\n\nEnd.\n\nWe need to format with arrows and indent decisions properly. Use Yes → etc.\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Decision: 如果 nums 長度 < 2? // 檢查是否少於兩個元素\n    Yes → Step 1: 回傳 0 // 直接返回\n    No  → Step 2: 初始化 minVal, maxVal 為 nums[0] // 先設為第一個數\n→ Step 3: 從 nums[1] 到 nums[n-1] 迭代更新 minVal, maxVal // 找到最小值與最大值\n→ Decision: 如果 minVal == maxVal? // 所有元素相同\n    Yes → Step 4: 回傳 0 // 最大差為 0\n    No  → Step 5: 計算 bucketSize = max(1, ceil((maxVal - minVal) / (n-1))) // 設定 bucket 大小\n→ Step 6: bucketCount = (maxVal - minVal) / bucketSize + 1 // 計算桶的數量\n→ Step 7: bucketMin[0..bucketCount-1] ← +∞; bucketMax[0..bucketCount-1] ← -∞ // 初始化桶\n→ Step 8: 對於每個 num in nums:\n            idx = (num - minVal) / bucketSize;\n            bucketMin[idx] = min(bucketMin[idx], num);\n            bucketMax[idx] = max(bucketMax[idx], num); // 填寫桶\n→ Step 9: previousMax ← minVal; maxGap ← 0 // 設定起始值\n→ Step 10: 從 i = 0 到 bucketCount-1 逐個檢查桶\n            如果 bucketMin[i] == +∞ 則 跳過 // 跳過空桶\n            否則\n                gap = bucketMin[i] - previousMax;\n                maxGap = max(maxGap, gap);\n                previousMax = bucketMax[i]; // 更新最大差\n→ Step 11: 回傳 maxGap // 最終結果\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\nimport re\nfrom typing import List\n\ndef maximum_gap(nums: List[int]) -> int:\n    \"\"\"Return the maximum difference between successive elements after sorting.\n    Linear time and linear extra space using the bucket method.\"\"\"\n    n = len(nums)\n    if n < 2:\n        return 0\n\n    # Find global minimum and maximum\n    min_val = max_val = nums[0]\n    for num in nums[1:]:\n        if num < min_val:\n            min_val = num\n        elif num > max_val:\n            max_val = num\n\n    # All numbers equal\n    if min_val == max_val:\n        return 0\n\n    # Bucket size: ceil((max - min) / (n - 1))\n    bucket_size = max(1, (max_val - min_val) // (n - 1) + 1)\n    bucket_count = (max_val - min_val) // bucket_size + 1\n\n    # Initialize buckets\n    bucket_min = [None] * bucket_count\n    bucket_max = [None] * bucket_count\n\n    # Distribute numbers into buckets\n    for num in nums:\n        idx = (num - min_val) // bucket_size\n        if bucket_min[idx] is None or num < bucket_min[idx]:\n            bucket_min[idx] = num\n        if bucket_max[idx] is None or num > bucket_max[idx]:\n            bucket_max[idx] = num\n\n    # Scan buckets to find maximum gap\n    prev_max = min_val\n    max_gap = 0\n    for i in range(bucket_count):\n        if bucket_min[i] is None:  # empty bucket\n            continue\n        # gap between current bucket's minimum and previous bucket's maximum\n        gap = bucket_min[i] - prev_max\n        if gap > max_gap:\n            max_gap = gap\n        prev_max = bucket_max[i]\n\n    return max_gap\n\nif __name__ == \"__main__\":\n    # Read entire input, extract integers\n    data = sys.stdin.read()\n    numbers = list(map(int, re.findall(r\"-?\\d+\", data)))\n    result = maximum_gap(numbers)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [3,6,9,1]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [10]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode350.json",
    "problem_index_in_file": 0,
    "title": "Intersection of Two Arrays II",
    "description_snippet": "Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for intersecting two integer arrays, counting multiplicities. We need to provide each line with virtual code step and comment after space //. Use Start, End, Decision, arrow →. For intersection, we can use hash map counts for one array then iterate second array to build result. Steps: Start; Step 1: Build frequency map for nums1; Step 2: Initialize result list; Step 3: Iterate over nums2; Decision: if element exists in map and count > 0? Yes → Add to result; decrement map count; No → skip; End.\n\nWe must show each line with arrow \"→\". For decisions, show Yes →, No → lines indented? In sample they use indenting. We can mimic: use tab or space indent. Probably one space indent. Use Decision line with arrow \"→ Decision:\" etc. Example: `→ Decision: ...` then nested `Yes →` and `No →`.\n\nLet's craft lines:\n\nStart // 程式開始執行\n→ Step 1: 建立 nums1 的頻率映射 freqMap // 建立每個元素在 nums1 中出現的次數\n→ Step 2: 初始化空的結果列表 result // 用來儲存交集元素\n→ Step 3: 迭代 nums2 的每個元素 val // 遍歷第二個陣列\n    → Decision: val 是否存在於 freqMap 且 freqMap[val] > 0? // 檢查元素是否同時出現在兩個陣列且還有剩餘可用次數\n        Yes → Step 4: 將 val 加入 result // 將符合條件的元素加入結果\n        Yes → Step 5: 將 freqMap[val] 減 1 // 更新頻率，減少可用次數\n        No  → Step 6: 跳過此元素 // 元素不符合條件，直接忽略\nEnd // 程式執行結束\n\nBut we might need to place Step 5 inside Yes branch? Or we can combine Step 4 and 5 within the same Yes branch. The sample shows each branch lines after Yes → . Indentation: they indent further lines under Decision block.\n\nWe can also combine Step 4 and Step 5 as two separate lines under Yes. So show Yes → Step 4: ... and then Yes → Step 5: ... but we might need to indent again? Let's follow sample: They indent the lines after decision using spaces. We'll indent two spaces or a tab. Let's use two spaces for clarity. Use a space before each arrow.\n\nSo final answer lines as required.\n\nAlso mention that we may return any order, but we just build as we go.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 nums1 的頻率映射 freqMap // 建立每個元素在 nums1 中出現的次數  \n→ Step 2: 初始化空的結果列表 result // 用來儲存交集元素  \n→ Step 3: 迭代 nums2 的每個元素 val // 遍歷第二個陣列  \n  → Decision: val 是否存在於 freqMap 且 freqMap[val] > 0? // 檢查元素是否同時出現在兩個陣列且還有剩餘可用次數  \n    Yes → Step 4: 將 val 加入 result // 將符合條件的元素加入結果  \n    Yes → Step 5: 將 freqMap[val] 減 1 // 更新頻率，減少可用次數  \n    No  → Step 6: 跳過此元素 // 元素不符合條件，直接忽略  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import Counter\n\nclass Solution:\n    def intersect(self, nums1, nums2):\n        # 建立兩個陣列的頻率統計\n        c1, c2 = Counter(nums1), Counter(nums2)\n        res = []\n        # 對於 nums1 中的每個不同元素\n        for num in c1:\n            # 若同時出現在 nums2，加入最小重複次數\n            if num in c2:\n                res.extend([num] * min(c1[num], c2[num]))\n        return res\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    data = sys.stdin.read().strip()\n    # 從字串中抓取兩個列表的文字表示\n    lists = re.findall(r'\\[.*?\\]', data)\n    if len(lists) >= 2:\n        nums1 = ast.literal_eval(lists[0])\n        nums2 = ast.literal_eval(lists[1])\n    else:\n        nums1, nums2 = [], []\n\n    solution = Solution()\n    result = solution.intersect(nums1, nums2)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums1 = [1,2,2,1], nums2 = [2,2]",
          "expected_output": "[2,2]",
          "success": true,
          "output": "[2, 2]"
        },
        {
          "example_index": 1,
          "input": "nums1 = [4,9,5], nums2 = [9,4,9,8,4]",
          "expected_output": "[4,9]",
          "success": true,
          "output": "[4, 9]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode28.json",
    "problem_index_in_file": 0,
    "title": "Implement strStr()",
    "description_snippet": "Given two strings needle and haystack, return the index of the first occurrence of needle in haystac...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code lines with explanation. Must follow format exactly: each line: \"虛擬碼步驟 // 解釋/說明\". Use arrows: →, Decision: etc. Should not output actual code. Provide step-by-step algorithm for string search: naive or maybe KMP. But requirement is just \"Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.\" So algorithm: Start, check if needle is empty: return 0. Then for each i from 0 to len(haystack)-len(needle), compare substring. Use decision. Let's produce virtual code lines.\n\nWe must adhere to format: each line starts with virtual step. Example format: \"Start // 程式開始執行\". Then \"→ Step 1: 輸入兩個字串 haystack 與 needle // 取得輸入\". Then decision to check if needle empty. Then loop: Decision: If i > max? Actually loop condition: i <= len(haystack) - len(needle). Use Decision: If i <= ...? In virtual code we can express as \"Decision: 是否已檢查完所有可能位置?\" But better to express loop: \"Decision: 是否 i 超過限制?\" etc.\n\nSimplify: Use steps: Compute n= len(haystack), m= len(needle). Then if m == 0: return 0. For i from 0 to n-m: Check if haystack[i:i+m] == needle. If yes, return i. After loop, return -1.\n\nWe need to output line by line with arrows and decisions. Let's produce:\n\nStart\n→ Step 1: 取得 haystack 與 needle // 取得輸入字串\n→ Step 2: 計算 n = 長度(haystack) // haystack 長度\n→ Step 3: 計算 m = 長度(needle) // needle 長度\n→ Decision: m == 0? // 檢查 needle 是否為空字串\n    Yes → Step 4: 回傳 0 // 空字串總是存在於任何字串開頭\n    No → Decision: n < m? // haystack 是否比 needle 短\n        Yes → Step 5: 回傳 -1 // 不能找到\n        No → Step 6: 設置 i = 0 // 初始化位置指標\n→ Decision: i <= n - m? // 還有位置可以檢查?\n    Yes → Step 7: 計算 match = True // 假設匹配成功\n    → Step 8: 對 j 從 0 到 m-1 做\n        → Decision: haystack[i + j] == needle[j]? // 比較字符\n            Yes → Step 9: match = True // 繼續\n            No  → Step 10: match = False // 匹配失敗\n            No  → Step 11: 跳出內層迴圈 // 匹配失敗，停止\n    → Decision: match? // 內層迴圈結束後是否匹配成功\n        Yes → Step 12: 回傳 i // 找到第一個位置\n        No  → Step 13: i = i + 1 // 嘗試下一個位置\n    → Decision: i <= n - m? // 再次檢查是否還有位置\n        (繼續循環)\n    No → Step 14: 回傳 -1 // 未找到\nEnd\n\nNeed to ensure each line follows format: \"虛擬碼步驟 // 解釋\". Use arrow \"→\" before each step. For decision lines, prefix \"Decision:\". For nested decisions, indent with spaces? Format example shows indentation by spaces. We can maintain same style. Use indentation 4 spaces for nested steps.\n\nMake sure we don't output any actual code, only pseudo-steps.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得 haystack 與 needle // 取得輸入字串  \n→ Step 2: 計算 n = 長度(haystack) // haystack 長度  \n→ Step 3: 計算 m = 長度(needle) // needle 長度  \n→ Decision: m == 0? // 檢查 needle 是否為空字串  \n    Yes → Step 4: 回傳 0 // 空字串總是存在於任何字串開頭  \n    No → Decision: n < m? // haystack 是否比 needle 短  \n        Yes → Step 5: 回傳 -1 // 不能找到  \n        No → Step 6: 設置 i = 0 // 初始化位置指標  \n→ Decision: i <= n - m? // 還有位置可以檢查?  \n    Yes → Step 7: 計算 match = True // 假設匹配成功  \n    → Step 8: 對 j 從 0 到 m-1 做 // 逐字符比較  \n        → Decision: haystack[i + j] == needle[j]? // 比較字符  \n            Yes → Step 9: match = True // 繼續  \n            No  → Step 10: match = False // 匹配失敗  \n            No  → Step 11: 跳出內層迴圈 // 匹配失敗，停止  \n    → Decision: match? // 內層迴圈結束後是否匹配成功  \n        Yes → Step 12: 回傳 i // 找到第一個位置  \n        No  → Step 13: i = i + 1 // 嘗試下一個位置  \n    → Decision: i <= n - m? // 再次檢查是否還有位置  \n        (循環回到 Decision: i <= n - m?)  \n    No → Step 14: 回傳 -1 // 未找到  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        \"\"\"Return the index of the first occurrence of needle in haystack,\n        or -1 if needle is not part of haystack.\"\"\"\n        # 若 needle 為空字串，直接回傳 0\n        if not needle:\n            return 0\n\n        n, m = len(haystack), len(needle)\n        # 只需要檢查到 n - m 的位置即可\n        for i in range(n - m + 1):\n            if haystack[i:i + m] == needle:\n                return i\n        return -1\n\ndef parse_input(data: str):\n    \"\"\"從輸入字串中提取兩個字串，假設字串被雙引號包圍。\"\"\"\n    # 找出所有雙引號內的內容\n    matches = re.findall(r'\"([^\"]*)\"', data)\n    haystack = matches[0] if len(matches) > 0 else \"\"\n    needle = matches[1] if len(matches) > 1 else \"\"\n    return haystack, needle\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取所有資料\n    raw_input = sys.stdin.read()\n    haystack, needle = parse_input(raw_input)\n\n    solution = Solution()\n    result = solution.strStr(haystack, needle)\n\n    # 將結果輸出到標準輸出\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "haystack = \"sadbutsad\", needle = \"sad\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 1,
          "input": "haystack = \"leetcode\", needle = \"leeto\"",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode377.json",
    "problem_index_in_file": 0,
    "title": "Combination Sum IV",
    "description_snippet": "Given an array of distinct integers nums and a target integer target, return the number of possible ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for counting number of combinations (order matters?) Problem similar to \"Combination Sum IV\" on Leetcode. Distinct integers nums. Return number of possible combinations that add up to target. Order matters? Typically combination sum IV counts sequences where order matters. The requirement likely that. We'll produce DP approach: dp[0]=1; for i 1..target: for each num: if i>=num: dp[i]+=dp[i-num]. Output dp[target].\n\nWe need to produce step-by-step virtual code lines with explanation. Use arrow notation Start, Decision, etc. Must output each line with \"虛擬碼步驟\" + space + \"// 解釋\".\n\nWe'll produce a linear flow:\n\nStart // 程式開始\n→ Step 1: 初始化 dp 陣列長度 target+1 // 建立 dp 陣列\n→ Step 2: dp[0] = 1 // 基礎情況：總和為 0 的組合數為 1\n→ Step 3: 迭代 i 從 1 到 target // 計算每個目標和\n    → Decision: 是否已完成 i? // 迴圈條件\n        Yes → Step 4: 結束迴圈 // i 超過 target\n        No → Step 5: 將 dp[i] 設為 0 // 初始化\n        → Step 6: 迭代每個 num 在 nums // 遍歷可用數字\n            → Decision: num <= i? // 判斷是否可用\n                Yes → Step 7: dp[i] += dp[i - num] // 加入前一個子問題答案\n                No  → Step 8: 跳過 // 不可用\n→ Step 9: 回傳 dp[target] // 結果輸出\nEnd // 程式結束\n\nBut we need to use arrow syntax. For decision we use \"Decision:\" with Yes → and No → lines.\n\nAlso need to ensure each line is separate. Use appropriate indentation? Not required, but arrow lines nested.\n\nWe'll produce like:\n\nStart // 程式開始執行\n→ Step 1: 建立 dp 陣列長度 target+1 並全為 0 // 初始化 dp\n→ Step 2: dp[0] = 1 // 基礎情況\n→ Step 3: 迭代 i 從 1 到 target // 計算每個目標和\n    → Decision: i <= target? // 迴圈條件\n        Yes → Step 4: dp[i] = 0 // 初始化 dp[i]\n        → Step 5: 迭代每個 num 在 nums // 遍歷\n            → Decision: num <= i? // 可用判斷\n                Yes → Step 6: dp[i] = dp[i] + dp[i - num] // 累加\n                No  → Step 7: 跳過 // 不可用\n        → Step 8: 繼續下一個 i\n        No  → Step 9: 跳出迴圈 // i > target\n→ Step 10: 輸出 dp[target] // 返回答案\nEnd // 程式執行結束\n\nBut we need to keep each line with code and explanation, arrow format.\n\nLet's write as:\n\nStart // 程式開始執行\n→ Step 1: 建立 dp 陣列長度 target+1 且所有元素為 0 // 初始化 dp\n→ Step 2: dp[0] = 1 // 基礎情況：總和為 0 的組合數為 1\n→ Step 3: 迭代 i 從 1 到 target // 計算每個目標和\n    → Decision: i <= target? // 判斷是否仍在範圍內\n        Yes → Step 4: dp[i] = 0 // 初始化 dp[i]\n        → Step 5: 迭代每個 num 在 nums // 遍歷可用數字\n            → Decision: num <= i? // 判斷 num 是否能用\n                Yes → Step 6: dp[i] = dp[i] + dp[i - num] // 加入前一個子問題答案\n                No  → Step 7: 跳過 // num 大於 i\n        → Step 8: 繼續下一個 i\n        No  → Step 9: 跳出迴圈 // i 超過 target\n→ Step 10: 回傳 dp[target] // 輸出結果\nEnd // 程式結束執行\n\nMake sure each line uses arrow or indent appropriately. The arrow lines inside decision should be indented. But format might require each line independent; we can still indent for readability.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立 dp 陣列長度 target+1 且所有元素為 0 // 初始化 dp\n→ Step 2: dp[0] = 1 // 基礎情況：總和為 0 的組合數為 1\n→ Step 3: 迭代 i 從 1 到 target // 計算每個目標和\n    → Decision: i <= target? // 判斷是否仍在範圍內\n        Yes → Step 4: dp[i] = 0 // 初始化 dp[i]\n        → Step 5: 迭代每個 num 在 nums // 遍歷可用數字\n            → Decision: num <= i? // 判斷 num 是否能用\n                Yes → Step 6: dp[i] = dp[i] + dp[i - num] // 加入前一個子問題答案\n                No  → Step 7: 跳過 // num 大於 i\n        → Step 8: 繼續下一個 i\n        No  → Step 9: 跳出迴圈 // i 超過 target\n→ Step 10: 回傳 dp[target] // 輸出結果\nEnd // 程式結束執行",
      "generated_code": "import sys\nimport re\nimport ast\n\ndef combination_sum_4(nums, target):\n    \"\"\"Return the number of ordered combinations that sum to target.\"\"\"\n    dp = [0] * (target + 1)\n    dp[0] = 1  # base case\n\n    for i in range(1, target + 1):\n        for num in nums:\n            if i - num >= 0:\n                dp[i] += dp[i - num]\n    return dp[target]\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n\n    # 解析「nums = [1,2,3], target = 4」這類格式\n    pattern = r\"nums\\s*=\\s*(\\[[^\\]]*\\])\\s*,\\s*target\\s*=\\s*(-?\\d+)\"\n    match = re.search(pattern, data)\n    if not match:\n        raise ValueError(\"輸入格式不符合預期\")\n\n    nums = ast.literal_eval(match.group(1))   # 轉成列表\n    target = int(match.group(2))\n\n    result = combination_sum_4(nums, target)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3], target = 4",
          "expected_output": "7",
          "success": true,
          "output": "7"
        },
        {
          "example_index": 1,
          "input": "nums = [9], target = 3",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode532.json",
    "problem_index_in_file": 0,
    "title": "K-diff Pairs in an Array",
    "description_snippet": "Given an array of integers nums and an integer k, return the number of unique k-diff pairs in the ar...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code lines for the algorithm. Requirements: no real code, only virtual code with arrows and explanation.\n\nWe need to compute unique k-diff pairs. Typical solution: use hash set for numbers, use frequency map if k=0, else for each unique number check if number + k exists.\n\nVirtual code steps: Start, get input array, k. Create frequency map. If k<0: return 0. If k==0: count numbers with freq >1. Else: iterate over keys, if key+k in map, count++. End.\n\nWe need each line like \"Start // 程式開始執行\". Then arrow lines with steps. Use \"→ Step 1: 建立頻率映射\" etc. Also Decision steps.\n\nAlso need to handle negative k: Decision: 如果 k < 0? return 0.\n\nMake sure each line has the format: \"虛擬碼步驟 // 解釋\". Provide explanatory comments in Chinese.\n\nLet's produce steps:\n\nStart\n→ Step 1: 初始化答案 count 為 0\n→ Step 2: 建立 hash map freq 以統計每個數字出現次數\n→ Decision: 如果 k < 0? // k 不能為負，無差值對\n    Yes → Step 3: 輸出 0 // 返回 0\n    No  → Decision: k == 0? // 特殊情況\n        Yes → Step 4: 針對 freq 中每個數字，若其頻率 > 1，count++ // 重複數字形成 0 差對\n        No  → Step 5: 針對 freq 中每個數字，若 freq 存在 key + k，count++ // k>0 時檢查差對\n→ Step 6: 輸出 count // 結果\n\nBut need to use Decision arrow style: \"Decision: ...\". Provide Yes/No arrows. Need to maintain \"→\" before each step or decision. For substeps we indent? Example shows indentation with tabs but not necessary; we can indent with spaces.\n\nLet's craft final output.\n\nNote: \"End // 程式執行結束\".\n\nAlso \"Step\" names like \"Step 1: 計算頻率\". Provide explanation.\n\nLet's produce.\n\nAlso ensure each line has \"虛擬碼步驟 // 解釋\". So we can add \"Start // 程式開始執行\". Then each line like \"→ Step 1: ... // ...\" etc.\n\nLet's create lines:\n\nStart // 程式開始執行\n→ Step 1: 初始化 count 為 0 // 記錄符合條件的 k-diff 對數\n→ Step 2: 初始化空 hash map freq // 用來統計每個數字的出現頻率\n→ Decision: 如果 k < 0? // k 為負值時無合法對\n    Yes → Step 3: 輸出 0 // 直接返回 0\n    No  → Decision: k == 0? // k 為 0 時特殊處理\n        Yes → Step 4: 對 freq 中每個 key, 若 freq[key] > 1, count++ // 重複數字形成 0 差對\n        No  → Step 5: 對 freq 中每個 key, 若 key + k 存於 freq, count++ // k>0 時檢查差值對\n→ Step 6: 輸出 count // 回傳最終結果\nEnd // 程式執行結束\n\nBut need to ensure that each line after Decision is correctly indented? The example uses indentation: Decision line followed by Yes → etc.\n\nWe need to maintain the arrow \"→\" for each step. For decisions we might use \"Decision: ...\". Then indent the substeps with spaces.\n\nBut each line must have a single \"虛擬碼步驟\" string. For substeps we can include \"Yes →\" etc.\n\nLet's format:\n\nStart // 程式開始執行\n→ Step 1: 初始化 count 為 0 // 記錄符合條件的 k-diff 對數\n→ Step 2: 初始化空 hash map freq // 用來統計每個數字的出現頻率\n→ Decision: k < 0? // k 為負值時無合法對\n    Yes → Step 3: 輸出 0 // 直接返回 0\n    No  → Decision: k == 0? // k 為 0 時特殊處理\n        Yes → Step 4: 遍歷 freq，若 freq[key] > 1, count++ // 重複數字形成 0 差對\n        No  → Step 5: 遍歷 freq，若 key + k 存於 freq, count++ // k>0 時檢查差值對\n→ Step 6: 輸出 count // 回傳最終結果\nEnd // 程式執行結束\n\nBut we might want to include Step 1 for building freq. Actually we didn't fill freq mapping. Should include step for iterating over nums to fill freq. So we add Step 1b: iterate nums to fill freq.\n\nLet's revise:\n\nStart\n→ Step 1: 初始化 count 為 0\n→ Step 2: 初始化空 hash map freq\n→ Step 3: 遍歷 nums，對每個 num, freq[num]++ // 生成頻率表\n→ Decision: k < 0?\n    Yes → Step 4: 輸出 0\n    No  → Decision: k == 0?\n        Yes → Step 5: 遍歷 freq，若 freq[key] > 1, count++ // 0 差對\n        No  → Step 6: 遍歷 freq，若 key + k 存於 freq, count++ // k>0 差對\n→ Step 7: 輸出 count\nEnd\n\nWe need to maintain the arrow and explanation format. Each line should be \"虛擬碼步驟 // 解釋\". For decision lines we include \"Decision: ...\". For yes/no we have \"Yes →\" and \"No →\".\n\nLet's produce final answer.\n\nCheck each line: Must have \"虛擬碼步驟\" e.g., \"Start\", \"→ Step 1: ...\", \"→ Decision: ...\". Provide explanation after //.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 count 為 0 // 記錄符合條件的 k‑diff 對數  \n→ Step 2: 初始化空 hash map freq // 用來統計每個數字的出現頻率  \n→ Step 3: 遍歷 nums，對每個 num, freq[num]++ // 建立頻率表  \n→ Decision: k < 0? // k 為負值時無合法對  \n    Yes → Step 4: 輸出 0 // 直接返回 0  \n    No → Decision: k == 0? // k 為 0 時特殊處理  \n        Yes → Step 5: 遍歷 freq，若 freq[key] > 1, count++ // 重複數字形成 0 差對  \n        No → Step 6: 遍歷 freq，若 key + k 存於 freq, count++ // k>0 時檢查差值對  \n→ Step 7: 輸出 count // 回傳最終結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nfrom collections import Counter\n\nclass Solution:\n    def findPairs(self, nums, k):\n        if k < 0:\n            return 0\n        count = Counter(nums)\n        if k == 0:\n            return sum(v > 1 for v in count.values())\n        return sum(n + k in count for n in count)\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 取得陣列字串與 k 的字串\n    left_bracket = data.find('[')\n    right_bracket = data.find(']', left_bracket)\n    if left_bracket == -1 or right_bracket == -1:\n        raise ValueError(\"輸入格式錯誤，應包含陣列\")\n\n    arr_str = data[left_bracket:right_bracket + 1]\n    k_str = data[right_bracket + 1:].strip().lstrip(',')\n\n    nums = ast.literal_eval(arr_str)\n    k = int(k_str)\n\n    sol = Solution()\n    result = sol.findPairs(nums, k)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[3,1,4,1,5], 2",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "[1,2,3,4,5], 1",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "[1,3,1,5,4], 0",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode3.json",
    "problem_index_in_file": 0,
    "title": "Longest Substring Without Repeating Characters",
    "description_snippet": "Given a string s, find the length of the longest substring without duplicate characters....",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code line-by-line with explanation. For longest substring without repeating characters problem. Use sliding window technique. We'll write pseudo steps. Each line with \"→\" arrow etc. Provide explanation after space. Use Start, Decision, End. Use variable names: s, left, right, seenSet, maxLen. Steps: initialize left=0, maxLen=0, seenSet empty. Loop right from 0 to len(s)-1. While char in seenSet: remove s[left] from set, left++. Add s[right] to set, update maxLen = max(maxLen, right-left+1). End loop. Output maxLen.\n\nWe should present in lines. Each line must have \"虛擬碼步驟\" and explanation. Use arrow before step. For decisions use \"Decision:\" lines. Ensure each line ends with \"// 解釋/說明\". Use proper Chinese explanation.\n\nWe should not output actual code but structure. Use Start, End.\n\nLet's produce lines:\n\nStart // 程式開始\n\n→ Step 1: 初始化變數 left = 0, right = 0, maxLen = 0, seenSet = 空集合 // 初始化滑動窗口參數\n\n→ Step 2: 進入主迴圈，當 right < s.length 時 // 開始遍歷字符串\n\n→ Decision: 目前字符 s[right] 是否已存在於 seenSet? // 判斷是否出現重複字符\n\n    Yes → Step 3: 移除左端字符 s[left] 後進一步收縮窗口 // 移除重複字符，縮小窗口\n\n        → Step 3.1: 將 s[left] 從 seenSet 刪除 // 更新集合\n\n        → Step 3.2: left = left + 1 // 左指標右移\n\n        → Decision: 仍然有重複? // 需要多次收縮\n\n            Yes → 回到 Step 3\n\n            No → 跳回決策點 // 繼續\n\n    No → Step 4: 將 s[right] 加入 seenSet // 新字符加入窗口\n\n    → Step 5: maxLen = max(maxLen, right - left + 1) // 更新最大長度\n\n    → Step 6: right = right + 1 // 右指標右移\n\nEnd // 程式結束，返回 maxLen\n\nWe need each line exactly with \"→\" or \"Decision:\" etc. The Decision branches include lines with Yes → and No → etc. Must be consistent with format.\n\nLet's structure:\n\nStart // 程式開始執行\n→ Step 1: left = 0 // 初始化左指標\n→ Step 2: maxLen = 0 // 初始化最大長度\n→ Step 3: seenSet = 空集合 // 初始化已出現字符集合\n→ Step 4: right = 0 // 初始化右指標\n→ Decision: right < s.length? // 判斷是否還有字符可處理\n    Yes → Step 5: currentChar = s[right] // 取得當前字符\n    → Decision: currentChar ∈ seenSet? // 檢查是否重複\n        Yes → Step 6: seenSet.remove(s[left]) // 移除左端字符\n        → Step 7: left = left + 1 // 左指標右移\n        → Decision: currentChar ∈ seenSet? // 仍有重複嗎？\n            Yes → 回到 Step 6\n            No  → 回到 Decision: currentChar ∈ seenSet?\n        No  → Step 8: seenSet.add(currentChar) // 新字符加入集合\n        → Step 9: maxLen = max(maxLen, right - left + 1) // 更新最大長度\n        → Step 10: right = right + 1 // 右指標右移\n        → 回到 Decision: right < s.length?\nEnd // 程式結束\n\nBut we need to show \"Yes →\" and \"No →\" lines clearly. For backtracking, we might write \"→ Decision:\" etc. Ensure each line ends with comment. Use arrow for each step.\n\nWe might simplify by using while loops but not necessary.\n\nAlso include \"return maxLen\" at end.\n\nLet's produce final answer with proper indentation and clarity. Ensure each line with arrow.\n\nI'll produce:\n\nStart // 程式開始執行\n→ Step 1: left = 0 // 初始化左指標\n→ Step 2: maxLen = 0 // 初始化最大長度\n→ Step 3: seenSet = 空集合 // 初始化已見字符集合\n→ Step 4: right = 0 // 初始化右指標\n→ Decision: right < s.length? // 是否還有字符可處理\n    Yes → Step 5: currentChar = s[right] // 取得目前字符\n    → Decision: currentChar ∈ seenSet? // 判斷是否重複\n        Yes → Step 6: seenSet.remove(s[left]) // 移除左端字符\n        → Step 7: left = left + 1 // 左指標右移\n        → Decision: currentChar ∈ seenSet? // 仍重複?\n            Yes → 回到 Step 6\n            No  → 回到 Decision: currentChar ∈ seenSet?\n        No  → Step 8: seenSet.add(currentChar) // 新字符加入集合\n        → Step 9: maxLen = max(maxLen, right - left + 1) // 更新最大長度\n        → Step 10: right = right + 1 // 右指標右移\n        → 回到 Decision: right < s.length?\nEnd // 程式結束，返回 maxLen\n\nBut \"回到 Decision\" maybe not allowed. We can write \"→ Decision:\" lines again. But maybe we can restructure to avoid backtracking lines. But the requirement is to produce pseudo-code with decision arrows. We can include \"→ Decision:\" after each step.\n\nSimplify: After Step 6 we can loop back by \"→ Decision:\" but we need to maintain arrow lines. Might be okay.\n\nAlso include a line to return result.\n\nAdd \"→ Step 11: return maxLen // 回傳結果\" before End.\n\nLet's craft final pseudo-code accordingly. Ensure each line ends with comment. Provide Chinese explanation.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: left = 0 // 初始化左指標  \n→ Step 2: maxLen = 0 // 初始化最大長度  \n→ Step 3: seenSet = 空集合 // 初始化已見字符集合  \n→ Step 4: right = 0 // 初始化右指標  \n→ Decision: right < s.length? // 判斷是否還有字符可處理  \n    Yes → Step 5: currentChar = s[right] // 取得目前字符  \n    → Decision: currentChar ∈ seenSet? // 判斷當前字符是否重複  \n        Yes → Step 6: seenSet.remove(s[left]) // 移除左端字符，縮小窗口  \n        → Step 7: left = left + 1 // 左指標右移  \n        → Decision: currentChar ∈ seenSet? // 仍有重複嗎？  \n            Yes → 回到 Step 6 // 需要再移除重複字符  \n            No  → 回到 Decision: currentChar ∈ seenSet? // 結束移除重複字符流程  \n        No  → Step 8: seenSet.add(currentChar) // 新字符加入集合  \n        → Step 9: maxLen = max(maxLen, right - left + 1) // 更新最大長度  \n        → Step 10: right = right + 1 // 右指標右移  \n        → 回到 Decision: right < s.length? // 重新判斷是否結束迴圈  \nEnd // 程式結束，返回 maxLen",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        char_set = set()\n        left = 0\n        max_len = 0\n\n        for right in range(len(s)):\n            while s[right] in char_set:\n                char_set.remove(s[left])\n                left += 1\n            char_set.add(s[right])\n            max_len = max(max_len, right - left + 1)\n        return max_len\n\ndef parse_input(data: str) -> str:\n    # Try to extract the string inside quotes following \"s = \"\n    match = re.search(r's\\s*=\\s*\"([^\"]*)\"', data)\n    if match:\n        return match.group(1)\n    # If no pattern found, return an empty string\n    return \"\"\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    s = parse_input(raw_input)\n    result = Solution().lengthOfLongestSubstring(s)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"abcabcbb\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "s = \"bbbbb\"",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "s = \"pwwkew\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode410.json",
    "problem_index_in_file": 0,
    "title": "Split Array Largest Sum",
    "description_snippet": "Given an integer array nums and an integer k, split nums into k non-empty subarrays such that the la...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the algorithm: split array into k subarrays minimize maximum sum. This is typical binary search over possible maximum sum + greedy check. We'll produce steps: start, read input, determine low/high (min element, sum of all), binary search while low<high: mid, check if can split into <=k subarrays with sum <=mid using greedy. If yes high=mid else low=mid+1. After loop output low.\n\nWe need to produce step by step with virtual code arrows and explanation. Each line: \"虛擬碼步驟 // 解釋\". Use arrows \"→\". Use Start End, Decision. Provide multiple lines. Ensure we do not output actual code, just virtual steps.\n\nWe'll incorporate reading array, compute sum, max element. Then binary search loop, decision to split. We'll include \"while\" loop? Virtual code may represent as Decision: while low < high? Could use Decision: low < high? Yes → ... No → ... End.\n\nWithin loop compute mid and decision if can split. Use Decision: can split? Yes → set high = mid. No → set low = mid +1.\n\nAt the end output low.\n\nMake sure each line has \"虛擬碼步驟 // 解釋\".\n\nLet's craft.\n\nWe need to ensure we cover all steps line by line, using arrows, Start, End, Decision. Probably many lines. We'll not output actual code.\n\nLet's craft.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入 整數陣列 nums 與 整數 k // 取得輸入資料  \n→ Step 2: 計算 sumAll = 所有 nums 元素之和 // 之後作為上限  \n→ Step 3: 計算 maxElem = nums 中最大的元素 // 之後作為下限  \n→ Step 4: 設定 low = maxElem, high = sumAll // 初始化二分搜尋範圍  \n\nDecision: low < high? // 判斷是否仍有搜尋空間  \n    Yes → Step 5: mid = (low + high) / 2 // 計算中間值  \n    → Step 6: 計算 subCount = 0, currentSum = 0 // 初始化分段計數與累積和  \n    → Step 7: Decision: 是否已經遍歷完整 nums?  \n        No  → Step 8: currentSum += nums[i] // 加入當前元素  \n        → Decision: currentSum > mid? // 檢查是否超過限制  \n            Yes → subCount += 1, currentSum = nums[i] // 開啟新子陣列  \n            No  → // 仍在同一子陣列，繼續累加  \n        → 回到 Step 7  \n    → Step 9: subCount += 1 // 最後一個子陣列計算完畢  \n    → Decision: subCount <= k? // 判斷能否以 mid 為上限分成 k 個或更少子陣列  \n        Yes → high = mid // 可以縮小上限  \n        No  → low = mid + 1 // 必須增大上限  \n    → 回到 Decision: low < high?  \n\nDecision: low < high? // 繼續或結束迴圈  \n    No  → Step 10: 輸出 low // 最小化的最大子陣列和  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def splitArray(self, nums, m):\n        \"\"\"\n        使用二分搜尋找出能把 nums 分成 m 個非空子陣列時\n        最大子陣列和的最小值。\n        \"\"\"\n        # 判斷給定上限 mid 時能否分成不超過 m 個子陣列\n        def can_split(mid):\n            count, curr_sum = 1, 0\n            for num in nums:\n                if curr_sum + num > mid:\n                    # 開一個新子陣列\n                    count += 1\n                    curr_sum = num\n                else:\n                    curr_sum += num\n            return count <= m\n\n        left, right = max(nums), sum(nums)\n        while left < right:\n            mid = (left + right) // 2\n            if can_split(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left\n\ndef parse_input(data: str):\n    \"\"\"\n    從輸入字串中抽取 nums 列表與 k 整數。\n    例：'nums = [7,2,5,10,8], k = 2'\n    \"\"\"\n    nums_match = re.search(r'nums\\s*=\\s*(\\[.*?\\])', data)\n    k_match = re.search(r'k\\s*=\\s*(-?\\d+)', data)\n\n    if not nums_match or not k_match:\n        raise ValueError(\"輸入格式不正確\")\n\n    nums = ast.literal_eval(nums_match.group(1))\n    k = int(k_match.group(1))\n    return nums, k\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read()\n    nums, k = parse_input(input_data)\n    sol = Solution()\n    result = sol.splitArray(nums, k)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [7,2,5,10,8], k = 2",
          "expected_output": "18",
          "success": true,
          "output": "18"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3,4,5], k = 2",
          "expected_output": "9",
          "success": true,
          "output": "9"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode274.json",
    "problem_index_in_file": 0,
    "title": "H-Index",
    "description_snippet": "Given an array of integers citations where citations[i] is the number of citations a researcher rece...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo code line by line, with arrows and decisions, explanation after //.\n\nWe must not output real code, just virtual steps. Provide structure: Start, steps, decisions, End.\n\nThe algorithm: compute h-index: given array citations. Approach: sort descending; find max i where citations[i] >= i+1. Or use counting sort approach.\n\nWe'll produce pseudo code for sorting method.\n\nSteps:\n\nStart\n\n→ Step 1: Sort citations array in descending order // Sort citations\n\n→ Step 2: Initialize h = 0 // start with 0\n\n→ Step 3: For each index i from 0 to length-1 // iterate papers\n\n    → Decision: if citations[i] >= i+1? // check if current paper meets requirement\n\n        Yes → h = i+1 // update h\n\n        No  → No action // continue\n\n→ Step 4: Return h // final h-index\n\nEnd.\n\nNeed arrow structure. Use \"→\" for steps, indentation for decisions. Use \"Yes →\" \"No →\" lines.\n\nAdd explanation after // each line.\n\nAlso include the loop in steps: we could make \"→ Step 3: For i in 0..n-1 // iterate over papers\" then inside indentation for decision.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort citations array in descending order // 將引用次數由大到小排序  \n→ Step 2: Initialize h = 0 // 先把 h‑index 設為 0  \n→ Step 3: For i from 0 to citations.length - 1 // 逐一檢查每篇論文  \n  Decision: if citations[i] >= i + 1? // 判斷第 i 種（第 i+1 篇）論文是否至少被引用 i+1 次  \n   Yes → h = i + 1 // 若符合條件，更新 h 值為 i+1  \n   No  → // 不符合條件，繼續檢查下一篇  \n→ Step 4: Return h // 回傳最終計算得到的 h‑index  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def hIndex(self, citations):\n        # 將引用次數由大到小排序\n        citations.sort(reverse=True)\n        h = 0\n        # 逐一檢查每篇論文\n        for i, c in enumerate(citations):\n            # 若第 i+1 篇論文至少被引用 i+1 次，更新 h\n            if c >= i + 1:\n                h = i + 1\n            else:\n                # 一旦不滿足條件，後續不可能再更大\n                break\n        return h\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 解析輸入，支援 \"citations = [1,3,1]\" 或直接 \"[1,3,1]\"\n    if '=' in data:\n        _, expr = data.split('=', 1)\n        citations = eval(expr.strip())\n    else:\n        citations = eval(data)\n    solution = Solution()\n    result = solution.hIndex(citations)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "citations = [3,0,6,1,5]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "citations = [1,3,1]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode462.json",
    "problem_index_in_file": 0,
    "title": "Minimum Moves to Equal Array Elements II",
    "description_snippet": "Given an integer array nums of size n, return the minimum number of moves required to make all array...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code lines with comments. Problem: Minimum moves to equalize array by +1/-1 per move. The optimal target is median. So steps: compute median, sum absolute differences. Provide pseudocode.\n\nMake sure each line: \"虛擬碼步驟\" + \" // 解釋\". Use arrow. Start, End, Decision.\n\nWe need to be careful: Use \"Step\" labels, decisions, loops.\n\nLet's produce:\n\nStart\n→ Step 1: 計算陣列長度 n // 取得陣列大小\n→ Decision: 如果 n 為 0? // 檢查空陣列\n    Yes → Step 2: 回傳 0 // 空陣列不需移動\n    No → Continue\n→ Step 3: 複製陣列並排序 // 為找到中位數做準備\n→ Step 4: 計算中位數 median // 中位數使移動次數最小\n→ Step 5: 初始化 moves 為 0 // 用於累計總移動次數\n→ For i 從 0 到 n-1 // 逐個元素計算距離\n    → Step 6: 計算 abs(nums[i] - median) // 取絕對差\n    → Step 7: 加到 moves // 累加到總移動\n→ End // 回傳 moves\n\nNeed decision block for even n: median as lower or upper? For minimizing sum abs, any value between two middle works; choose lower middle. So in median step we can: if n % 2 == 1: median = sorted[n//2]; else median = sorted[n//2 -1] or [n//2].\n\nSo include decision.\n\nAdd decisions: Decision: n%2==1? // odd length\nYes → median = sorted[n//2]\nNo → median = sorted[n//2 -1] // lower middle\n\nLet's produce accordingly. Also decision to handle negative? Not needed.\n\nInclude comments.\n\nAll lines with arrow.\n\nMake sure to use \"Start\" and \"End\".\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得陣列長度 n ← nums.size() // 取得陣列大小  \n→ Decision: 如果 n 為 0? // 檢查空陣列  \n  Yes → Step 2: 回傳 0 // 空陣列不需移動  \n  No → 進行下一步  \n→ Step 3: 複製並排序陣列 sorted ← sort(nums) // 為找中位數做準備  \n→ Step 4: 決定中位數位置  \n  Decision: n%2==1? // 陣列長度為奇數?  \n   Yes → Step 5: median ← sorted[n//2] // 奇數時直接取中間值  \n   No → Step 6: median ← sorted[n//2 - 1] // 偶數時取較小的中間值  \n→ Step 7: 初始化總移動次數 moves ← 0 // 用於累加所有元素的移動距離  \n→ For i 從 0 到 n-1  \n  → Step 8: 距離 ← abs(nums[i] - median) // 計算當前元素到目標值的距離  \n  → Step 9: moves ← moves + 距離 // 累加至總移動  \n→ End // 回傳 moves 作為最小移動次數答案",
      "generated_code": "import sys\nimport re\n\ndef min_moves_to_equal(nums):\n    \"\"\"Return the minimum number of moves to make all elements equal.\"\"\"\n    n = len(nums)\n    if n == 0:\n        return 0\n\n    # Sort the array to find the median\n    nums.sort()\n\n    # For odd length, median is the middle element.\n    # For even length, any value between the two middle elements works;\n    # we choose the lower middle to keep the implementation simple.\n    median = nums[n // 2] if n % 2 == 1 else nums[n // 2 - 1]\n\n    # Sum the absolute differences from the median\n    moves = 0\n    for num in nums:\n        moves += abs(num - median)\n\n    return moves\n\nif __name__ == \"__main__\":\n    # Read the entire input from stdin\n    data = sys.stdin.read()\n\n    # Extract all integers from the input (handles both positive and negative numbers)\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n\n    # Compute and print the answer\n    result = min_moves_to_equal(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "nums = [1,10,2,9]",
          "expected_output": "16",
          "success": true,
          "output": "16"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode209.json",
    "problem_index_in_file": 0,
    "title": "Minimum Size Subarray Sum",
    "description_snippet": "Given an array of positive integers nums and a positive integer target, return the minimal length of...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm: minimal length subarray sum >= target. Common two-pointer sliding window. Steps: initialize start, end, minLen large, currentSum 0. Loop end from 0 to n-1: add nums[end] to sum. While sum >= target: update minLen, subtract nums[start], start++. After loop, if minLen still large return 0 else minLen.\n\nNeed to produce each line with explanation. Use arrows. Use Start, End. Decision etc. Provide step lines. Let's craft.\n\nWe'll have:\n\nStart // 程式開始\n→ Step 1: Initialize variables: start = 0, minLen = Infinity, currentSum = 0 // 設定滑動窗口起點及結果\n→ Decision: 遍歷索引 end 從 0 到 nums.length-1? // 檢查是否還有元素\n    Yes → Step 2: currentSum += nums[end] // 將當前結尾元素加入窗口\n    → Decision: currentSum >= target? // 檢查窗口是否滿足條件\n        Yes → Step 3: minLen = min(minLen, end - start + 1) // 更新最小長度\n        → Step 4: currentSum -= nums[start] // 移除窗口左端元素\n        → Step 5: start += 1 // 移動左端\n        → Decision: currentSum >= target? // 仍然滿足，重複縮小窗口\n            (loop back to Step 3?) We can express as nested while.\nMaybe better to express Decision with Yes/No to Step 3 repeated.\n\nWe'll do:\n\n→ Decision: currentSum >= target? // 判斷是否可縮小窗口\n    Yes → Step 3: minLen = min(minLen, end - start + 1) // 更新結果\n    → Step 4: currentSum -= nums[start]\n    → Step 5: start += 1\n    → Decision: currentSum >= target? // 再次檢查\n        (loop)...\n\nBut need arrow loops? Could show nested decisions but simpler: use loop structure: while currentSum >= target: update minLen, subtract, start++.\n\nWe need to represent loop using Decision? We can do:\n\n→ Decision: currentSum >= target? // 判斷是否可以收縮\n    Yes → Step 3: minLen = min(minLen, end - start + 1) // 更新最短長度\n    → Step 4: currentSum -= nums[start] // 移除左端\n    → Step 5: start += 1 // 左端向右移動\n    → Decision: currentSum >= target? // 再次判斷，若是則重複\n        Yes → (回到 Step 3) // 迴圈繼續\n        No  → (結束內部判斷，返回外層循環)\n    No  → (繼續外層 for 迴圈)\n\nBut we must express '回到 Step 3' maybe as `→ Decision: currentSum >= target? // 重新判斷，若是則重複收縮` and then maybe using arrow `→` to Step 3 again. But we need to keep structure clear.\n\nSimpler: Use while loop representation: Decision: currentSum >= target? Yes → Step 3: minLen = min(minLen, end - start + 1) → Step 4: currentSum -= nums[start] → Step 5: start += 1 → Decision: currentSum >= target? (loop)...\n\nThus produce a repeated block.\n\nAt the end of outer loop, after all iterations:\n\n→ Decision: minLen == Infinity? // 判斷是否找到子陣列\n    Yes → Step 6: return 0 // 沒有符合條件\n    No  → Step 7: return minLen // 返回最短長度\nEnd // 程式結束\n\nWe need to ensure each line includes explanation.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: start ← 0, minLen ← Infinity, currentSum ← 0 // 設定滑動窗口起點、最短長度以及累積和  \n→ Decision: end ← 0 到 nums.length-1? // 迭代結尾指標  \n Yes → Step 2: currentSum ← currentSum + nums[end] // 將結尾元素加入累積和  \n  → Decision: currentSum ≥ target? // 判斷窗口是否已滿足目標和  \n   Yes → Step 3: minLen ← min(minLen, end - start + 1) // 更新最短長度  \n   → Step 4: currentSum ← currentSum - nums[start] // 移除左端元素  \n   → Step 5: start ← start + 1 // 左端向右移動  \n   → Decision: currentSum ≥ target? // 若仍滿足，繼續縮小窗口  \n    Yes → (回到 Step 3) // 迴圈繼續  \n    No  → (結束內部判斷，返回外層迴圈)  \n  No  → (結束內部判斷，返回外層迴圈)  \n No  → (結束外層迴圈，進入判斷結果)  \n→ Decision: minLen == Infinity? // 判斷是否找到符合條件的子陣列  \n Yes → Step 6: return 0 // 沒有任何子陣列符合條件  \n No  → Step 7: return minLen // 返回最短子陣列長度  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\ndef min_subarray_len(target: int, nums: list[int]) -> int:\n    \"\"\"\n    Return the minimal length of a contiguous subarray of which the sum\n    is greater than or equal to `target`. If no such subarray exists,\n    return 0.\n    \"\"\"\n    left = 0\n    total = 0\n    min_len = float('inf')\n\n    for right in range(len(nums)):\n        total += nums[right]          # Expand window to the right\n        while total >= target:        # Shrink window from the left while it satisfies the condition\n            min_len = min(min_len, right - left + 1)\n            total -= nums[left]\n            left += 1\n\n    return 0 if min_len == float('inf') else min_len\n\ndef solve() -> None:\n    \"\"\"\n    Read input from stdin, parse `target` and `nums`, compute the\n    minimal subarray length, and print the result to stdout.\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Try to parse the format: \"target = 7, nums = [2,3,1,2,4,3]\"\n    pattern = r'target\\s*=\\s*(\\d+)\\s*,\\s*nums\\s*=\\s*(\\[[^\\]]*\\])'\n    match = re.search(pattern, data)\n    if match:\n        target = int(match.group(1))\n        nums = ast.literal_eval(match.group(2))\n    else:\n        # Fallback: assume first line is target, second line is nums\n        lines = [line for line in data.splitlines() if line.strip()]\n        if len(lines) >= 2:\n            try:\n                target = int(lines[0].strip())\n                nums = ast.literal_eval(lines[1].strip())\n            except Exception:\n                print(0)\n                return\n        else:\n            print(0)\n            return\n\n    result = min_subarray_len(target, nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "target = 7, nums = [2,3,1,2,4,3]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "target = 4, nums = [1,4,4]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "target = 11, nums = [1,1,1,1,1,1,1,1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode69.json",
    "problem_index_in_file": 0,
    "title": "Sqrt(x)",
    "description_snippet": "Given a non-negative integer x, return the square root of x rounded down to the nearest integer. The...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for computing integer floor of sqrt(x) without using exponent. Use binary search. Steps: Start, input x. Decision if x < 2 -> return x. Set low=1, high=x//2 maybe. While low <= high: mid = (low+high)//2; sq=mid*mid; Decision if sq == x -> return mid. Else if sq < x -> low = mid+1; else high = mid-1. After loop, return high (since high is floor sqrt). Provide explanation. Format lines with \"虛擬碼步驟 // 解釋\". Use arrow syntax. Use Start, End. Need to include input and return. Use binary search logic.\n\nLet's craft lines.\n\nLine 1: Start // 程式開始\nLine 2: → Step 1: 輸入非負整數 x // 從使用者或函式獲取數值\nLine 3: → Decision: 如果 x 小於 2? // 小數字可直接回傳\nLine 4:     Yes → Step 2: 回傳 x // 0 或 1 的平方根即自身\nLine 5:     No  → Step 3: 設 low = 1, high = x // 2 // 初始搜尋範圍\nLine 6: → While low <= high: // binary search 迴圈\nLine 7:     → Step 4: mid = (low + high) // 2 // 取中點\nLine 8:     → Step 5: sq = mid * mid // 計算 mid 的平方\nLine 9:     → Decision: 如果 sq 等於 x? // 找到精確平方根\nLine10:         Yes → Step 6: 回傳 mid // 結束\nLine11:         No  → Decision: 如果 sq 小於 x? // 小於目標\nLine12:             Yes → Step 7: low = mid + 1 // 搜尋更大值\nLine13:             No  → Step 8: high = mid - 1 // 搜尋更小值\nLine14: → Step 9: 回傳 high // high 為向下取整的平方根\nLine15: End // 程式結束\n\nWe need to ensure syntax: For while loop, use \"→ While low <= high:\" and indent nested lines. Provide explanation after each line. Use indentation maybe not required, but we can use spaces.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始  \n→ Step 1: 輸入非負整數 x // 從使用者或函式獲取數值  \n→ Decision: 如果 x 小於 2? // 小數字可直接回傳  \n Yes → Step 2: 回傳 x // 0 或 1 的平方根即自身  \n No  → Step 3: 設 low = 1, high = x // 2 // 初始搜尋範圍  \n→ While low <= high: // binary search 迴圈  \n → Step 4: mid = (low + high) // 2 // 取中點  \n → Step 5: sq = mid * mid // 計算 mid 的平方  \n → Decision: 如果 sq 等於 x? // 找到精確平方根  \n  Yes → Step 6: 回傳 mid // 結束  \n  No  → Decision: 如果 sq 小於 x? // 小於目標  \n   Yes → Step 7: low = mid + 1 // 搜尋更大值  \n   No  → Step 8: high = mid - 1 // 搜尋更小值  \n→ Step 9: 回傳 high // high 為向下取整的平方根  \nEnd // 程式結束",
      "generated_code": "import sys\nimport re\n\ndef mySqrt(x: int) -> int:\n    \"\"\"計算不使用指數運算的整數平方根，並向下取整\"\"\"\n    if x < 2:\n        return x\n    left, right = 1, x // 2\n    while left <= right:\n        mid = (left + right) // 2\n        sq = mid * mid\n        if sq == x:\n            return mid\n        elif sq < x:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return right\n\ndef main() -> None:\n    \"\"\"從標準輸入讀取數值，計算平方根後輸出\"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 取得輸入中的最後一個整數\n    nums = re.findall(r'-?\\d+', data)\n    if not nums:\n        return\n    x = int(nums[-1])\n    print(mySqrt(x))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "x = 4",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "x = 8",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode385.json",
    "problem_index_in_file": 0,
    "title": "Mini Parser",
    "description_snippet": "Given a string s represents the serialization of a nested list, implement a parser to deserialize it...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for deserializing nested list string into NestedInteger structure. Provide each step with explanation. Should be in Chinese. Use Start, End, Decision. No actual code. Provide step by step pseudo. Let's design algorithm: Use stack. If string length 1 and is digit, return single integer. Else iterate over characters, parse numbers, when '[' push new NestedInteger list onto stack, when ']' pop top, add to previous or return. For negative numbers parse sign. Use helper to read integer when encountering digit or '-'. Use comma as separator. Steps.\n\nWe'll output each step line with explanation. Let's produce about maybe 15-20 lines. Let's adhere to format. Use arrow symbol → before each step. Indentation for decision branches.\n\nOk. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義一個空棧 stack 用於儲存待處理的 NestedInteger // 以後每遇到 '[' 就 push, ']' 就 pop  \n→ Step 2: 判斷輸入字串 s 是否只包含一個整數（即 s 不含 '['） // 直接回傳整數結果  \n    Yes → Step 3: 建立一個新的 NestedInteger 整數並回傳 // 整數序列化時不需要棧  \n    No  → Proceed to Step 4  \n→ Step 4: 從左到右遍歷字串 s，使用指標 i  \n→ Decision: 字符 s[i] 是 '['? // 表示一個新列表開始  \n    Yes → Step 5: 建立一個新的 NestedInteger list，push 到 stack，並遞增 i // 新列表進棧  \n    No → Decision: 字符 s[i] 是 ']'? // 表示當前列表結束  \n        Yes → Step 6: 從棧頂 pop 出整個列表，並把它作為子元素加入新的棧頂（如果棧非空）或直接返回 // 結束一個子結構  \n        No → Decision: 字符 s[i] 是 ','? // 分隔符，忽略  \n            Yes → Step 7: i++ // 跳過逗號  \n            No → Decision: 字符 s[i] 是 '-' 或數字? // 開始解析一個整數  \n                Yes → Step 8: 讀取完整整數值 num（直到遇到 ',' 或 ']' 或結尾）  \n                Step 9: 建立一個新的 NestedInteger 整數，並把它加入棧頂的列表中 // 整數作為子項  \n                Step 10: 把指標 i 移到整數結束位置 // 準備繼續解析  \n→ End // 所有字符已解析，棧中應該只剩一個完整 NestedInteger，回傳它。",
      "generated_code": "import sys\nimport re\n\nclass NestedInteger:\n    def __init__(self, value=None):\n        if value is None:\n            self._list = []\n            self._int = None\n        else:\n            if isinstance(value, int):\n                self._int = value\n                self._list = None\n            else:\n                raise TypeError(\"Unsupported type for NestedInteger\")\n\n    def isInteger(self):\n        return self._int is not None\n\n    def add(self, elem):\n        if self.isInteger():\n            raise ValueError(\"Cannot add to an integer\")\n        self._list.append(elem)\n\n    def setInteger(self, value):\n        self._int = value\n        self._list = None\n\n    def getInteger(self):\n        return self._int\n\n    def getList(self):\n        return self._list\n\n    def __str__(self):\n        if self.isInteger():\n            return str(self._int)\n        return '[' + ','.join(str(e) for e in self._list) + ']'\n\nclass Solution:\n    def deserialize(self, s: str) -> NestedInteger:\n        if not s:\n            return NestedInteger()\n\n        # single integer case\n        if s[0] != '[':\n            return NestedInteger(int(s))\n\n        stack = []\n        num_str = ''\n        negative = False\n\n        for c in s:\n            if c == '-':\n                negative = True\n            elif c.isdigit():\n                num_str += c\n            elif c == '[':\n                stack.append(NestedInteger())\n            elif c in ',]':\n                if num_str:\n                    val = int(num_str)\n                    if negative:\n                        val = -val\n                    stack[-1].add(NestedInteger(val))\n                    num_str = ''\n                    negative = False\n                if c == ']' and len(stack) > 1:\n                    ni = stack.pop()\n                    stack[-1].add(ni)\n\n        return stack[0] if stack else NestedInteger()\n\nif __name__ == \"__main__\":\n    input_text = sys.stdin.read().strip()\n    # Extract the string inside quotes if present\n    match = re.search(r'\"([^\"]*)\"', input_text)\n    s = match.group(1) if match else input_text\n    solution = Solution()\n    result = solution.deserialize(s)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"324\"",
          "expected_output": "324",
          "success": true,
          "output": "324"
        },
        {
          "example_index": 1,
          "input": "s = \"[123,[456,[789]]]\"",
          "expected_output": "[123,[456,[789]]]",
          "success": true,
          "output": "[123,[456,[789]]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode477.json",
    "problem_index_in_file": 0,
    "title": "Total Hamming Distance",
    "description_snippet": "The Hamming distance between two integers is the number of positions at which the corresponding bits...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code step by step for computing sum of Hamming distances among all pairs in an array. Use bit counting approach. Steps: start, compute length, result=0, for each bit 0-31: count number of 1s at that bit across all numbers, zeros = n - ones, contribution = ones*zeros, add to result. End. Also consider 64-bit maybe. Provide virtual code with arrows and decisions maybe not necessary. Provide per line explanation.\n\nWe must follow output format: each line: \"虛擬碼步驟 // 解釋\". Use arrows \"→\". Use \"Start\" \"End\". Use Decision if needed. The sample shows use of indentation. We'll produce.\n\nLet's produce:\n\nStart // 程式開始\n\n→ Step 1: n ← length(nums) // 取得陣列長度\n\n→ Step 2: result ← 0 // 初始化總距離\n\n→ Step 3: for bit in 0..31 do // 逐位計算\n\n    → SubStep 1: countOnes ← 0 // 重新計算此位的 1 的數量\n\n    → SubStep 2: for num in nums do\n\n        → Decision: 若 (num >> bit) & 1 == 1? // 判斷該位是否為 1\n\n            Yes → countOnes ← countOnes + 1 // 若是 1，累加\n\n            No → // 不做任何事\n\n    → SubStep 3: zeros ← n - countOnes // 此位的 0 的數量\n\n    → SubStep 4: result ← result + countOnes * zeros // 兩種組合的距離貢獻\n\n→ End of for\n\n→ Step 4: return result // 返回所有對之總 Hamming 距離\n\nEnd // 程式結束\n\nWe need to format each line with arrow and comment. Ensure each line is a separate line. Use \"→\" before each step maybe. For loops, we can indent with extra arrow? sample uses indentation but we can just use extra arrows or just new lines. The sample uses indentation with 4 spaces before sub-steps? Actually they used indentation for nested steps: Indentation spaces. We'll mimic.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: n ← length(nums) // 取得陣列長度\n→ Step 2: result ← 0 // 初始化總 Hamming 距離\n→ Step 3: for bit in 0..31 do // 逐位計算貢獻\n    → SubStep 1: countOnes ← 0 // 重新計算此位的 1 的數量\n    → SubStep 2: for num in nums do // 遍歷所有數字\n        → Decision: 若 (num >> bit) & 1 == 1? // 判斷該位是否為 1\n            Yes → countOnes ← countOnes + 1 // 若是 1，累加\n            No  → // 否則不變\n    → SubStep 3: zeros ← n - countOnes // 此位的 0 的數量\n    → SubStep 4: result ← result + countOnes * zeros // 兩種組合的距離貢獻\n→ End of for // 完成所有位的計算\n→ Step 4: return result // 回傳所有對的 Hamming 距離總和\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef total_hamming_distance(nums):\n    \"\"\"計算所有數字對之 Hamming 距離總和。\"\"\"\n    n = len(nums)\n    total = 0\n    for i in range(32):                     # 逐位處理\n        count_ones = sum((num >> i) & 1 for num in nums)  # 這一位為 1 的數量\n        count_zeros = n - count_ones                         # 這一位為 0 的數量\n        total += count_ones * count_zeros                   # 貢獻值\n    return total\n\ndef main():\n    # 從標準輸入讀取全部內容\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入，例如 \"nums = [4,14,2]\"\n    if '=' in data:\n        _, expr = data.split('=', 1)\n        nums = ast.literal_eval(expr.strip())\n    else:\n        nums = ast.literal_eval(data)\n\n    result = total_hamming_distance(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [4,14,2]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "nums = [4,14,4]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode115.json",
    "problem_index_in_file": 0,
    "title": "Distinct Subsequences",
    "description_snippet": "Given two strings s and t, return the number of distinct subsequences of s which equals t.\n\nThe test...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code (pseudo-code) step-by-step for solution of counting distinct subsequences of s equal to t. It's classic DP: dp[i][j] number of ways s[0:i] -> t[0:j]. We can use 1D DP for memory optimization: dp[j] = ways to form t[0:j] using processed prefix of s. Iterate over s characters, update dp from end to start. Need to explain each line. Should not output actual code, just virtual steps with arrows.\n\nWe need to produce steps: Start, maybe initialize dp array of size |t|+1 with dp[0] = 1. Loop over each char in s. For each char, loop j from |t| down to 1. If s[i]==t[j-1], dp[j] += dp[j-1]. At end, answer dp[|t|]. We can also do 2D DP, but 1D is concise.\n\nThe virtual code lines: Start, Step: get lengths, Step: create dp array, etc. Provide explanation comments. Should include Decision nodes? The algorithm doesn't have decisions besides condition inside loop. But we could include a Decision: if s[i]==t[j-1] then update.\n\nLet's produce lines.\n\nLet's count number of lines: maybe 15-20 lines.\n\nMake sure to include arrow and spaces, and // explanation.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義變數 n = length of s, m = length of t // 取得兩字串長度\n→ Step 2: 建立一維整數陣列 dp[0…m] 並全部初始化為 0 // 用來累積子序列計數\n→ Step 3: 設定 dp[0] = 1 // 空字串 t 可以由任何 s 產生 1 種方式\n→ Step 4: 循環遍歷 s 的每個字元 s[i] (i 從 0 到 n-1) // 處理 s 的每個位置\n    → Step 5: 循環 j 從 m 到 1 逆序 (j 從 m 下降到 1) // 逆序更新可避免覆寫 dp[j-1]\n        → Decision: 如果 s[i] == t[j-1]? // 判斷此位置的字元是否能對應 t 的第 j 個字元\n            Yes → Step 6: dp[j] = dp[j] + dp[j-1] // 若相同，將前一個子序列數加到 dp[j]\n            No  → Step 7: 跳過更新 // 字元不匹配，保持 dp[j] 不變\n→ Step 8: 回傳 dp[m] // dp[m] 即為 s 的所有子序列中等於 t 的個數\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef num_distinct(s: str, t: str) -> int:\n    \"\"\"Return number of distinct subsequences of s that equal t.\"\"\"\n    m, n = len(s), len(t)\n    if n == 0:\n        return 1  # empty t matches once\n    if m < n:\n        return 0  # impossible to form t\n\n    # dp[j] = number of ways to form t[:j] using processed prefix of s\n    dp = [0] * (n + 1)\n    dp[0] = 1  # empty t\n\n    for char in s:\n        # update from end to avoid overwriting dp[j-1]\n        for j in range(n, 0, -1):\n            if char == t[j - 1]:\n                dp[j] += dp[j - 1]\n    return dp[n]\n\ndef parse_input(text: str):\n    \"\"\"\n    Extracts s and t from the input text.\n    Accepts formats like:\n        s = \"rabbbit\", t = \"rabbit\"\n    or two separate lines, or two space‑separated tokens.\n    \"\"\"\n    # Try regex pattern s = \"...\" , t = \"...\"\n    s_match = re.search(r's\\s*=\\s*\"([^\"]*)\"', text)\n    t_match = re.search(r't\\s*=\\s*\"([^\"]*)\"', text)\n    if s_match and t_match:\n        return s_match.group(1), t_match.group(1)\n\n    # Fallback: split into lines\n    lines = text.strip().splitlines()\n    if len(lines) >= 2:\n        return lines[0].strip(), lines[1].strip()\n\n    # Fallback: split by whitespace\n    tokens = text.strip().split()\n    if len(tokens) >= 2:\n        return tokens[0], tokens[1]\n\n    # If nothing works, raise error\n    raise ValueError(\"Unable to parse input for strings s and t.\")\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    s, t = parse_input(raw_input)\n    result = num_distinct(s, t)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"rabbbit\", t = \"rabbit\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "s = \"babgbag\", t = \"bag\"",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode211.json",
    "problem_index_in_file": 0,
    "title": "Design Add and Search Words Data Structure",
    "description_snippet": "Design a data structure that supports adding new words and finding if a string matches any previousl...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for implementing WordDictionary with addWord and search with wildcard '.' using likely a Trie with DFS search. Provide each line step with explanation. Use the arrow structure. Start → Step etc. Provide each step. Should include decision nodes for wildcard search recursion. Also include addWord steps building trie. Should be clear but not actual code. Each line with // explanation. Ensure \"虛擬碼步驟\" maybe like \"Start\" etc. Use Start, End, Decision. Should include branching for '.'.\n\nWe need to produce a step-by-step algorithm. Let's outline:\n\nStart\n→ Initialize root node with children map and isWord flag false // root of trie\n\n→ Function addWord(word)\n    → Set current = root\n    → For each char c in word\n        → If current.children does not contain c\n            → Create new node for c\n        → Move current to child c\n    → After loop, set current.isWord = true // mark end of word\n\n→ Function search(word)\n    → Return DFS(root, index 0)\n    → Define DFS(node, idx)\n        → If idx == word.length\n            → Return node.isWord\n        → Let char = word[idx]\n        → If char != '.'\n            → If node.children does not contain char\n                → Return false\n            → Else return DFS(node.children[char], idx+1)\n        → Else // char == '.'\n            → For each child in node.children\n                → If DFS(child, idx+1) true return true\n            → Return false\n\nEnd\n\nNow produce as virtual code lines with each step. Each line must have \"虛擬碼步驟\" then space then comment. Use arrow as indicated: \"→ Step ...\".\n\nAlso must include decision structure: Decision: ... Yes → ... No → ...\n\nUse arrow \"Yes →\" etc. For loops maybe \"→ For each\". Might not require decisions inside loops. For DFS recursion, use Decision: char == '.'? etc. Let's craft accordingly.\n\nRemember each line needs \"虛擬碼步驟\" (like \"Start\") then space then comment. Actually the requirement: \"每行必須包含：虛擬碼步驟 + [空格] + // 解釋/說明\". So each line: \"Start // 程式開始執行\". So no arrow? Wait arrow used inside structure: \"→\". So the first line is \"Start\". For next line we prefix arrow: \"→ Step ...\". So each line includes the arrow as part of the virtual code. That is okay.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 root 節點，擁有空的 children 映射和 isWord = false // 建立 Trie 根  \n→ Step 2: 定義 addWord(word) 函式  \n    → Step 2.1: 設 current = root // 以根節點開始  \n    → Step 2.2: For each char c in word  \n        → Decision: current.children 是否含 c? // 判斷是否已有子節點  \n            Yes → Step 2.3: current = current.children[c] // 直接移動到該子節點  \n            No  → Step 2.4: 建立新節點並加入 current.children[c] // 建立缺失節點  \n    → Step 2.5: current.isWord = true // 標記單詞結束位置  \n→ Step 3: 定義 search(word) 函式  \n    → Step 3.1: 返回 DFS(root, 0) // 從根節點開始深度優先搜尋  \n    → Step 3.2: 定義 DFS(node, idx)  \n        → Decision: idx == word.length? // 搜尋是否到字串尾  \n            Yes → Step 3.2.1: 返回 node.isWord // 若正好到尾，判斷是否為完整單詞  \n            No  → Step 3.2.2: let ch = word[idx] // 取得目前字元  \n                → Decision: ch == '.'? // 判斷是否為萬用字元  \n                    Yes → Step 3.2.2.1: For each child in node.children  \n                        → Step 3.2.2.1.1: If DFS(child, idx+1) then return true // 任何子節點匹配即成功  \n                    No  → Step 3.2.2.2: Decision: node.children 是否含 ch? // 檢查指定字元是否存在  \n                        Yes → Step 3.2.2.2.1: 返回 DFS(node.children[ch], idx+1) // 進入對應子節點繼續搜尋  \n                        No  → Step 3.2.2.2.2: 返回 false // 沒有對應字元，搜尋失敗  \n→ End // 程式執行結束",
      "generated_code": "import sys\nimport json\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass WordDictionary:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def addWord(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                node.children[ch] = TrieNode()\n            node = node.children[ch]\n        node.is_end = True\n\n    def search(self, word: str) -> bool:\n        def dfs(node: TrieNode, idx: int) -> bool:\n            if idx == len(word):\n                return node.is_end\n            ch = word[idx]\n            if ch == '.':\n                for child in node.children.values():\n                    if dfs(child, idx + 1):\n                        return True\n                return False\n            else:\n                if ch not in node.children:\n                    return False\n                return dfs(node.children[ch], idx + 1)\n        return dfs(self.root, 0)\n\nif __name__ == \"__main__\":\n    # Read entire stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    ops, args_list = json.loads(data)\n\n    results = []\n    wd = None\n    for op, args in zip(ops, args_list):\n        if op == \"WordDictionary\":\n            wd = WordDictionary()\n            results.append(None)\n        elif op == \"addWord\":\n            wd.addWord(args[0])\n            results.append(None)\n        elif op == \"search\":\n            results.append(wd.search(args[0]))\n    # Output results as JSON array\n    print(json.dumps(results))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\"],[[],[\"bad\"],[\"dad\"],[\"mad\"],[\"pad\"],[\"bad\"],[\".ad\"],[\"b..\"]]",
          "expected_output": "[null,null,null,null,false,true,true,true]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmp9_rxadac.py\", line 42, in <module>\n    ops, args_list = json.loads(data)\n                     ^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 85 (char 84)"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode507.json",
    "problem_index_in_file": 0,
    "title": "Perfect Number",
    "description_snippet": "A perfect number is a positive integer that is equal to the sum of its positive divisors, excluding ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line with explanations. We cannot output actual code. Use Start, End, Decision, etc. For the algorithm: Check n <=1? If <=1 return false. Sum divisors from 1 to sqrt(n). For each i, if n % i == 0: add i, if i != 1 and i != n/i, add n/i. After loop, compare sum to n. Return result. We'll produce steps. Ensure each line has the arrow or \"→\" as prefix. Provide explanation after //. Also include decision steps. Let's draft.\n\nStart // Program starts\n→ Step 1: Input integer n // Acquire the number to test\n→ Decision: If n <= 1? // Perfect numbers are >1\n    Yes → Step 2: Return false // n is not a perfect number\n    No  → Step 3: Initialize sumDivisors = 0 // Sum of proper divisors\n→ Step 4: For i from 1 to floor(sqrt(n)) // Iterate possible divisors\n    → Decision: If n mod i == 0? // i divides n evenly\n        Yes → Step 5: Add i to sumDivisors // i is a divisor\n        Yes → Decision: If i != 1 and i != n/i? // avoid double-counting 1 and n itself\n            Yes → Step 6: Add n/i to sumDivisors // complementary divisor\n→ Step 7: Decision: If sumDivisors == n? // Check if sum equals n\n    Yes → Step 8: Return true // n is perfect\n    No  → Step 9: Return false // n is not perfect\nEnd // Program ends\n\nNeed to ensure the structure of Decision with nested steps. In example they indent with tabs. We can mimic with indentation.\n\nLet's craft final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入整數 n // 取得要檢查的數字  \n→ Decision: 如果 n <= 1? // 完美數必須大於 1  \n  Yes → Step 2: 回傳 false // 小於等於 1 的數不是完美數  \n  No  → Step 3: 初始化 sumDivisors = 0 // 用來累加所有合法因子  \n→ Step 4: 從 i = 1 到 floor(sqrt(n)) 迭代 // 只需檢查到平方根即可  \n  → Decision: 如果 n mod i == 0? // i 能整除 n  \n    Yes → Step 5: sumDivisors += i // i 為一個合法因子  \n    Yes → Decision: 如果 i != 1 且 i != n/i? // 防止重複加 1 與 n 本身  \n      Yes → Step 6: sumDivisors += n/i // 加上對應的另一個因子  \n→ Step 7: Decision: 如果 sumDivisors == n? // 檢查是否為完美數  \n  Yes → Step 8: 回傳 true // n 為完美數  \n  No  → Step 9: 回傳 false // n 不是完美數  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef is_perfect(n: int) -> bool:\n    \"\"\"判斷 n 是否為完美數。\"\"\"\n    if n < 2:          # 1 及以下不可能是完美數\n        return False\n\n    sum_div = 1        # 1 為所有正整數的因子\n    i = 2\n    while i * i <= n:  # 只需檢查到平方根\n        if n % i == 0:\n            sum_div += i\n            other = n // i\n            if other != i:      # 避免平方根重複計算\n                sum_div += other\n        i += 1\n\n    return sum_div == n\n\n\ndef main() -> None:\n    \"\"\"從標準輸入讀取數字，判斷是否為完美數，並輸出結果。\"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    try:\n        n = int(data.split()[0])   # 只讀第一個數字\n    except ValueError:\n        return\n\n    print(\"true\" if is_perfect(n) else \"false\")\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "28",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "7",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode476.json",
    "problem_index_in_file": 0,
    "title": "Number Complement",
    "description_snippet": "The complement of an integer is the integer you get when you flip all the 0's to 1's and all the 1's...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines step by step for computing complement. Should be in traditional Chinese. No actual code. Use arrows. Steps: start, get binary, flip bits, convert back, return. Use Decision? Maybe not needed. Just steps. Use \"→\". Use \"End\". Provide explanation after each line. Use \"Step 1: ...\" style. Use no code syntax. Just description. Let's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得輸入整數 num // 從使用者或函式參數取得要處理的數值  \n→ Step 2: 轉成二進位字串 bits = binary representation of num // 將整數轉成二進位形式的字串  \n→ Step 3: 初始化空字串 compBits = \"\" // 用於儲存位元取反後的字串  \n→ Step 4: 循環處理 bits 的每一個字元 ch  \n  → Decision: 如果 ch 是 '0'?  \n    Yes → compBits += '1' // 將 0 取反成 1  \n    No  → compBits += '0' // 將 1 取反成 0  \n→ Step 5: 將 compBits 轉回整數 complement = integer value of compBits in base 2 // 將取反後的二進位字串還原為整數  \n→ Step 6: 回傳 complement // 將結果輸出給呼叫方  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def findComplement(self, num: int) -> int:\n        \"\"\"\n        找出 num 的補碼（將二進位的每一位 0 換成 1、1 換成 0）並回傳\n        \"\"\"\n        # 先計算 num 的二進位長度\n        bit_length = num.bit_length()\n        # 建立一個全 1 的掩碼，長度等於 num 的位數\n        mask = (1 << bit_length) - 1\n        # 用 XOR 取反，得到補碼\n        return num ^ mask\n\ndef main():\n    # 讀取整個輸入\n    data = sys.stdin.read()\n    # 從輸入文字中擷取第一個整數（允許正負號）\n    nums = re.findall(r'-?\\d+', data)\n    if not nums:\n        return\n    num = int(nums[0])\n\n    sol = Solution()\n    result = sol.findComplement(num)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num = 5",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "num = 1",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode703.json",
    "problem_index_in_file": 0,
    "title": "Kth Largest Element in a Stream",
    "description_snippet": "You are part of a university admissions office and need to keep track of the kth highest test score ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for class KthLargest with constructor and add method. Need to track kth largest in stream. Typically use min-heap of size k: push val; if size > k pop smallest; kth largest is heap top.\n\nWe need to produce virtual code with arrows. Should include Start, End, Decision. Provide line-by-line virtual code and explanations.\n\nLet's craft: Start // start program? Actually the class definition. We can treat initialization.\n\nOutline:\n\nStart // Program start\n→ Class KthLargest // define class\n→ Constructor KthLargest(k, nums) // initialize k, heap\n→ Step: set this.k = k\n→ Step: create min-heap priorityQueue\n→ Decision: if nums is not empty? // maybe loop\n    → Loop over nums\n        → add(val) // use same method\n→ End Constructor\n→ Method add(val) // add new score\n→ Step: push val into heap\n→ Decision: heap size > k? // remove smallest\n    → Yes → pop from heap\n    → No → do nothing\n→ Step: return top of heap (kth largest)\n→ End Method\nEnd // program\n\nNeed virtual code with arrows. Use indentation? Not necessary but use arrow for each step.\n\nLet's craft each line.\n\nAlso need to show Decision: if heap.size > k then pop.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Class KthLargest // 定義 KthLargest 類別  \n→ Constructor KthLargest(k, nums) // 初始化 k 以及初始分數列  \n    → Step: this.k ← k // 存儲 kth 參數  \n    → Step: this.heap ← New MinHeap() // 建立最小堆，維持前 k 個最大值  \n    → Decision: nums 不是空? // 若有初始分數，將它們加入堆中  \n        → Yes → For each num in nums  \n            → Step: Call add(num) // 利用 add 方法加入堆並保持大小  \n    → No  → // 無初始分數，跳過  \n→ End Constructor // 初始化完成  \n→ Method add(val) // 新增分數並回傳當前第 k 大分數  \n    → Step: this.heap.push(val) // 把新分數放入最小堆  \n    → Decision: this.heap.size > this.k? // 檢查堆是否超過 k 個元素  \n        → Yes → Step: this.heap.pop() // 移除最小元素，保持堆大小為 k  \n        → No → // 堆大小不超過 k，保持不變  \n    → Step: return this.heap.peek() // 堆頂即為第 k 大分數  \n→ End Method // add 方法結束  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\nimport heapq\n\nclass KthLargest:\n    def __init__(self, k, nums):\n        self.k = k\n        self.min_heap = []\n        for num in nums:\n            self.add(num)\n\n    def add(self, val):\n        heapq.heappush(self.min_heap, val)\n        if len(self.min_heap) > self.k:\n            heapq.heappop(self.min_heap)\n        return self.min_heap[0]\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n\n    # 將輸入包裝成一個 JSON 陣列，方便解析\n    data = json.loads('[' + raw_input + ']')\n    methods, args_list = data[0], data[1]\n\n    result = []\n    obj = None\n    for method, args in zip(methods, args_list):\n        if method == \"KthLargest\":\n            # args: [k, nums]\n            obj = KthLargest(*args)\n            result.append(None)\n        elif method == \"add\":\n            # args: [val]\n            res = obj.add(args[0])\n            result.append(res)\n        else:\n            # 不支援的指令，跳過\n            result.append(None)\n\n    # 輸出結果，使用 json.dumps 以得到 null 而非 None\n    print(json.dumps(result))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"KthLargest\", \"add\", \"add\", \"add\", \"add\", \"add\"], [[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]",
          "expected_output": "[null, 4, 5, 5, 8, 8]",
          "success": true,
          "output": "[null, 4, 5, 5, 8, 8]"
        },
        {
          "example_index": 1,
          "input": "[\"KthLargest\", \"add\", \"add\", \"add\", \"add\"], [[4, [7, 7, 7, 7, 8, 3]], [2], [10], [9], [9]]",
          "expected_output": "[null, 7, 7, 7, 8]",
          "success": true,
          "output": "[null, 7, 7, 7, 8]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode315.json",
    "problem_index_in_file": 0,
    "title": "Count of Smaller Numbers After Self",
    "description_snippet": "Given an integer array nums, return an integer array counts where counts[i] is the number of smaller...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nThe user wants pseudo-code for the problem: count of smaller numbers after each element. We must output in the format: each line: \"虛擬碼步驟 // 解釋\" with arrows etc. Need to generate step-by-step algorithm. They mention using virtual code arrows like →, Yes→ etc. We'll produce a pseudo-code using something like merge sort approach or BIT. We'll produce generic algorithm. Provide start, steps, decisions, end.\n\nWe'll produce lines like:\n\nStart // 程式開始執行\n→ Step 1: 建立一個空陣列 counts 長度等於 nums 的長度 // 用來存結果\n\nUse BIT or merge sort. Let's choose merge sort because common for this problem. We'll use recursion.\n\nWill include Decision: If low < high? etc.\n\nLet's craft.\n\nLine 1: Start\n\nLine 2: → Step 1: 確定 n = nums.length // 取得陣列長度\n\nLine 3: → Step 2: 初始化 counts 為 n 個 0 // 初始化結果\n\nLine 4: → Step 3: 建立一個暫存陣列 temp 以備 merge 過程 // 用於合併時暫存\n\nLine 5: → Step 4: 呼叫 recursive function mergeSort(nums, temp, counts, 0, n-1) // 進行遞迴分治\n\nWe need to define mergeSort function:\n\nWe'll write pseudo lines with indentation to show recursion. Might use Decision: If left < right? etc.\n\nWe'll produce nested steps. Use arrows and Decision.\n\nFor clarity, we can show:\n\n→ Step 4: 進入 mergeSort(nums, temp, counts, left, right) // 遞迴分治\n\nThen inside:\n\n→ Decision: 如果 left < right? // 檢查是否還有多於一個元素\n\nYes → Step: mid = (left + right)/2 // 找中點\n\n→ Step: mergeSort(nums, temp, counts, left, mid) // 左半邊遞迴\n\n→ Step: mergeSort(nums, temp, counts, mid+1, right) // 右半邊遞迴\n\n→ Step: merge(nums, temp, counts, left, mid, right) // 合併並計算\n\nNo → (do nothing)\n\nThen define merge:\n\n→ Step: i = mid; j = right; k = right // 從右往左合併\n\n→ Decision: 如果 i >= left 或 j > right? // 循環合併\n\nYes → Substeps:\n\nIf j > right? Actually algorithm: we copy from right to temp. We'll produce simplified:\n\nBut keep simple: We'll explain concept: We merge from right to left counting smaller numbers.\n\nSimplify: Use a while loop merging and counting.\n\nWe'll produce:\n\n→ Step: while i >= left and j >= mid+1\n\n   → Decision: if nums[i] > nums[j]? // 如果左邊元素大於右邊\n\n       Yes → temp[k] = nums[j]; counts[j] += (i - left + 1); j--; // 右邊元素更小，計算\n\n       No  → temp[k] = nums[i]; i--;\n\n   k--;\n\nAt the end, copy back temp[ left..right] to nums.\n\nBut we might skip the while details and provide high-level steps.\n\nWe must keep each line with explanation.\n\nWe'll need to format properly with arrow and Decision.\n\nWe'll produce line for copying back.\n\nAt end, after recursion returns, output counts.\n\nWe'll produce final lines.\n\nLet's draft:\n\nStart // 程式開始執行\n→ Step 1: n = nums.length // 取得陣列長度\n→ Step 2: counts = new int[n] // 初始化結果陣列\n→ Step 3: temp = new int[n] // 用於 merge 過程的暫存\n→ Step 4: mergeSort(nums, temp, counts, 0, n-1) // 開始遞迴分治\n→ Step 5: return counts // 回傳結果\n\nDefine mergeSort:\n\n→ Step 4.1: 定義 mergeSort(nums, temp, counts, left, right) // 遞迴分治\n    → Decision: if left < right? // 是否還有多於一個元素\n        Yes → Step 4.1.1: mid = (left + right) / 2 // 取中點\n        → Step 4.1.2: mergeSort(nums, temp, counts, left, mid) // 左半邊遞迴\n        → Step 4.1.3: mergeSort(nums, temp, counts, mid+1, right) // 右半邊遞迴\n        → Step 4.1.4: merge(nums, temp, counts, left, mid, right) // 合併並計數\n        No → // 已經是單一元素，直接返回\n\nDefine merge:\n\n→ Step 4.2: 定義 merge(nums, temp, counts, left, mid, right) // 合併左右兩段\n    → Step 4.2.1: i = mid // 左半段右端\n    → Step 4.2.2: j = right // 右半段右端\n    → Step 4.2.3: k = right // temp 的插入位置\n    → Decision: while i >= left and j > mid? // 兩段都有未處理元素\n        Yes → Decision: if nums[i] > nums[j]? // 左側元素大於右側\n            Yes → temp[k] = nums[j]; counts[j] += (i - left + 1); j--; // 右側元素更小，計數\n            No  → temp[k] = nums[i]; i--; // 左側元素更小，直接放入\n        k--; // 移動 temp 插入位置\n    → Step 4.2.4: while i >= left? // 左側還有剩餘元素\n        temp[k] = nums[i]; i--; k--;\n    → Step 4.2.5: while j > mid? // 右側還有剩餘元素\n        temp[k] = nums[j]; j--; k--;\n    → Step 4.2.6: for p from left to right: nums[p] = temp[p] // 把合併結果複回 nums\n\nWe also need to ensure counts index mapping: counts[j] increments by number of elements left that are greater. Since j refers to original index? In typical solution, we track pairs. But we can simply say counts[j] += (i - left + 1).\n\nBut we may need to note mapping for original indices. But for simplicity, we assume indexes are same.\n\nNow produce final code.\n\nMake sure each line ends with // explanation.\n\nMake sure to include Start and End.\n\nLet's produce final output lines.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n = nums.length // 取得陣列長度  \n→ Step 2: counts = new int[n] // 初始化結果陣列  \n→ Step 3: temp = new int[n] // 用於 merge 過程的暫存  \n→ Step 4: mergeSort(nums, temp, counts, 0, n-1) // 開始遞迴分治  \n→ Step 5: return counts // 回傳最終結果  \nEnd // 程式執行結束  \n\n// 定義遞迴分治函式  \n→ Step 4.1: mergeSort(nums, temp, counts, left, right) // 遞迴分治  \n  → Decision: if left < right? // 檢查是否仍有多於一個元素  \n    Yes → Step 4.1.1: mid = (left + right) / 2 // 取中點  \n     → Step 4.1.2: mergeSort(nums, temp, counts, left, mid) // 左半邊遞迴  \n     → Step 4.1.3: mergeSort(nums, temp, counts, mid+1, right) // 右半邊遞迴  \n     → Step 4.1.4: merge(nums, temp, counts, left, mid, right) // 合併並計算  \n    No → // 已是單一元素，直接返回  \n\n// 定義合併函式，並在合併時統計右側較小元素的數量  \n→ Step 4.2: merge(nums, temp, counts, left, mid, right) // 合併左右兩段  \n  → Step 4.2.1: i = mid // 左半段右端索引  \n  → Step 4.2.2: j = right // 右半段右端索引  \n  → Step 4.2.3: k = right // temp 的插入位置  \n  → Decision: while i >= left and j > mid? // 兩段都有未處理元素  \n    Yes → Decision: if nums[i] > nums[j]? // 左側元素大於右側  \n      Yes → temp[k] = nums[j]; counts[j] += (i - left + 1); j--; // 右側元素更小，累加左側剩餘數量  \n      No  → temp[k] = nums[i]; i--; // 左側元素更小，直接放入  \n     k--; // 移動 temp 插入位置  \n  → Step 4.2.4: while i >= left? // 左側還有剩餘元素  \n    temp[k] = nums[i]; i--; k--;  \n  → Step 4.2.5: while j > mid? // 右側還有剩餘元素  \n    temp[k] = nums[j]; j--; k--;  \n  → Step 4.2.6: for p from left to right: nums[p] = temp[p] // 把合併結果複回 nums",
      "generated_code": "import sys\nimport re\n\nclass BIT:\n    def __init__(self, size):\n        self.tree = [0] * (size + 1)\n        self.size = size\n\n    def update(self, index, delta):\n        while index <= self.size:\n            self.tree[index] += delta\n            index += index & -index\n\n    def query(self, index):\n        res = 0\n        while index > 0:\n            res += self.tree[index]\n            index -= index & -index\n        return res\n\nclass Solution:\n    def countSmaller(self, nums):\n        # 對數字做排序，取得唯一值並賦予 rank\n        sorted_unique = sorted(set(nums))\n        ranks = {num: i + 1 for i, num in enumerate(sorted_unique)}\n\n        bit = BIT(len(ranks))\n        res = []\n\n        # 從右往左遍歷，統計比當前元素小的數量\n        for num in reversed(nums):\n            rank = ranks[num]\n            res.append(bit.query(rank - 1))  # 小於 rank 的元素個數\n            bit.update(rank, 1)\n\n        return res[::-1]  # 反轉回原順序\n\ndef parse_nums(line: str):\n    \"\"\"\n    從輸入行中提取數字列表。\n    支持 'nums = [5,2,6,1]' 或 '[5,2,6,1]' 等格式。\n    \"\"\"\n    # 先嘗試找到方括號內的內容\n    match = re.search(r'\\[([^\\]]*)\\]', line)\n    if match:\n        nums_str = match.group(1).strip()\n        if not nums_str:\n            return []\n        # 以逗號分割並轉為 int\n        return [int(x.strip()) for x in nums_str.split(',')]\n    # 若沒有方括號，嘗試直接 eval\n    try:\n        return eval(line.strip())\n    except Exception:\n        return []\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw_input = sys.stdin.read()\n    if not raw_input:\n        sys.exit(0)\n    # 只取第一行作為數字列表（可依需求擴展）\n    first_line = raw_input.strip().splitlines()[0]\n    nums = parse_nums(first_line)\n\n    solution = Solution()\n    result = solution.countSmaller(nums)\n\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [5,2,6,1]",
          "expected_output": "[2,1,1,0]",
          "success": true,
          "output": "[2, 1, 1, 0]"
        },
        {
          "example_index": 1,
          "input": "nums = [-1]",
          "expected_output": "[0]",
          "success": true,
          "output": "[0]"
        },
        {
          "example_index": 2,
          "input": "nums = [-1,-1]",
          "expected_output": "[0,0]",
          "success": true,
          "output": "[0, 0]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode537.json",
    "problem_index_in_file": 0,
    "title": "Complex Number Multiplication",
    "description_snippet": "A complex number can be represented as a string on the form \"real+imaginaryi\" where:\n\nreal is the re...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for multiplication of two complex numbers represented as strings like \"a+bi\". We need parse them, multiply, produce string. Must use the arrow style and explanations. Each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision. Provide steps: parse real and imag parts, multiply using (a+bi)(c+di) = (ac - bd) + (ad + bc)i. Build string. Return. Also handle sign of imaginary part: output like \"real+imaginaryi\" with plus sign if imaginary >=0? The examples likely always include '+' sign, even if negative? Might be \"real+imaginaryi\" where imaginary can be negative, maybe like \"real-1i\"? But spec says \"real+imaginaryi\" format; but we can produce \"real+imaginaryi\" where imaginary can be negative, so will show minus sign. We'll output as real + (imaginary) + \"i\". For negative imaginary, use \"-\" sign. Implementation details: parse by splitting at '+', but plus may be part of sign? But real part can be negative, e.g., \"-3+4i\". So we find the last '+' or '-' before 'i' that separates real and imaginary. Or use regex. But virtual code: parse real part as substring up to '+' or '-' before 'i', parse imag part as integer from rest minus trailing 'i'. For simplicity, we can assume format always \"real+imaginaryi\" with plus sign separator even if imaginary negative? Actually example \"1+1i\". We'll keep assumption.\n\nSo virtual code: Start, parse num1 real and imag, parse num2 real and imag, compute realResult = a*c - b*d, imagResult = a*d + b*c, build string: if imagResult >= 0 -> \"realResult+imagResulti\" else -> \"realResult-imagResultAbsi\". End.\n\nNeed to incorporate decision for sign.\n\nAlso we might need to handle spaces? ignore.\n\nWrite steps accordingly. Use arrow lines. Provide explanation. Use \"Decision:\" lines for sign of imaginary. Use \"End\". Provide all steps.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行\n\n→ Step 1: 定義函式 MultiplyComplex(num1, num2) // 開始定義複數乘法\n\n→ Step 2: 解析 num1: real1 = 數字從 num1 字串中抽取 'real' 部分 // 取得第一個複數的實部\n→ Step 3: 解析 num1: imag1 = 數字從 num1 字串中抽取 'imaginary' 部分 (去除尾部 'i') // 取得第一個複數的虛部\n\n→ Step 4: 解析 num2: real2 = 數字從 num2 字串中抽取 'real' 部分 // 取得第二個複數的實部\n→ Step 5: 解析 num2: imag2 = 數字從 num2 字串中抽取 'imaginary' 部分 (去除尾部 'i') // 取得第二個複數的虛部\n\n→ Step 6: 計算乘法實部: realResult = real1 * real2 - imag1 * imag2 // (a+bi)(c+di) 的實部\n→ Step 7: 計算乘法虛部: imagResult = real1 * imag2 + imag1 * real2 // (a+bi)(c+di) 的虛部\n\n→ Decision: imagResult 是否小於 0? // 判斷虛部符號以決定輸出格式\n    Yes → Step 8: imagAbs = abs(imagResult) // 取虛部絕對值\n    No  → Step 8: imagAbs = imagResult // 虛部已正確\n\n→ Decision: imagResult 是否小於 0? // 再次確認以決定 '+' 或 '-' 連接符\n    Yes → Step 9: resultStr = realResult + \"-\" + imagAbs + \"i\" // 虛部負號\n    No  → Step 9: resultStr = realResult + \"+\" + imagResult + \"i\" // 虛部正號\n\n→ Step 10: Return resultStr // 回傳乘法結果字串\n\nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def complexNumberMultiply(self, a: str, b: str) -> str:\n        \"\"\"將兩個複數字串相乘並回傳結果字串。\"\"\"\n        def parse(s: str):\n            # 複數字串格式為 real+imaginaryi，imaginary 可能為負值\n            real_str, imag_with_i = s.split('+', 1)\n            return int(real_str), int(imag_with_i[:-1])  # 去掉最後的 'i'\n\n        a_real, a_imag = parse(a)\n        b_real, b_imag = parse(b)\n\n        real_part = a_real * b_real - a_imag * b_imag\n        imag_part = a_real * b_imag + a_imag * b_real\n\n        # 直接拼接，負值會自帶 '-' 符號，結果形如 \"0+-2i\"\n        return f\"{real_part}+{imag_part}i\"\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 依據範例，輸入形式為: '\"1+1i\", \"1+1i\"'\n    parts = data.split(',')\n    num1 = parts[0].strip().strip('\"').strip()\n    num2 = parts[1].strip().strip('\"').strip()\n    solution = Solution()\n    result = solution.complexNumberMultiply(num1, num2)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "\"1+1i\", \"1+1i\"",
          "expected_output": "\"0+2i\"",
          "success": true,
          "output": "0+2i"
        },
        {
          "example_index": 1,
          "input": "\"1+-1i\", \"1+-1i\"",
          "expected_output": "\"0+-2i\"",
          "success": true,
          "output": "0+-2i"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode208.json",
    "problem_index_in_file": 0,
    "title": "Implement Trie (Prefix Tree)",
    "description_snippet": "A trie (pronounced as \"try\") or prefix tree is a tree data structure used to efficiently store and r...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code lines with explanation. It's a Trie class with operations: constructor, insert, search, startsWith. We need to produce steps using arrows and decision. It's pseudo-code for a Trie implementation. We should produce step-by-step algorithm, not actual code. Use virtual code steps. Provide each line with explanation. The output must be lines with \"虛擬碼步驟 // 解釋/說明\". Use \"Start\" and \"End\" markers. Use decision constructs. Must be Chinese explanation. Use arrow →. We can structure as steps: Initialize root node, each node has children map, end flag. Insert: iterate characters, create child if missing, move pointer, set end flag at end. Search: iterate, if child missing return false, at end check end flag. startsWith: iterate, if missing return false, return true.\n\nWe must produce a virtual code listing. Use \"Start // 程式開始執行\". Each step: \"→\" for next line. For decisions: \"Decision: ...\" then indent \"Yes →\", \"No →\". For nested decisions, use indent with spaces. Use \"End // 程式執行結束\" at end.\n\nWe need to output code for the Trie class operations.\n\nWe can define virtual code like:\n\nStart // 程式開始\n→ Step 1: 定義 Node 類別 // Node 封裝子節點與終止標記\n    → Step 1.1: Node.children = 空映射 // 儲存字母到子節點的關係\n    → Step 1.2: Node.isEnd = False // 標記是否為單詞結尾\n→ Step 2: Trie 構造器 // 初始化根節點\n    → Step 2.1: Trie.root = 新 Node() // 根節點不代表任何字母\n→ Step 3: insert(word) // 將單詞插入 Trie\n    → Step 3.1: current = Trie.root // 從根節點開始\n    → Step 3.2: 對每個字符 ch in word 做:\n        → Step 3.2.1: Decision: 如果 current.children 中無 ch?\n            Yes → Step 3.2.1.1: current.children[ch] = 新 Node() // 建立新節點\n            No  → // 直接跳過\n        → Step 3.2.2: current = current.children[ch] // 移動到子節點\n    → Step 3.3: current.isEnd = True // 標記單詞結尾\n→ Step 4: search(word) // 檢查單詞是否存在\n    → Step 4.1: current = Trie.root\n    → Step 4.2: 對每個字符 ch in word 做:\n        → Step 4.2.1: Decision: 如果 current.children 中無 ch?\n            Yes → Step 4.2.1.1: Return False // 找不到字母，單詞不存在\n            No  → // 連續\n        → Step 4.2.2: current = current.children[ch]\n    → Step 4.3: Decision: 如果 current.isEnd?\n        Yes → Step 4.3.1: Return True // 單詞已插入\n        No  → Step 4.3.2: Return False // 前綴匹配但不是完整單詞\n→ Step 5: startsWith(prefix) // 檢查前綴是否存在\n    → Step 5.1: current = Trie.root\n    → Step 5.2: 對每個字符 ch in prefix 做:\n        → Step 5.2.1: Decision: 如果 current.children 中無 ch?\n            Yes → Step 5.2.1.1: Return False // 前綴不存在\n            No  → // 連續\n        → Step 5.2.2: current = current.children[ch]\n    → Step 5.3: Return True // 所有字母均存在，前綴存在\nEnd // 程式執行結束\n\nMake sure formatting: each line starts with \"→\" for steps. Use indentation. Provide explanation after //.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 Node 類別 // Node 封裝子節點與終止標記  \n&nbsp;&nbsp;→ Step 1.1: Node.children = 空映射 // 儲存字母到子節點的關係  \n&nbsp;&nbsp;→ Step 1.2: Node.isEnd = False // 標記是否為單詞結尾  \n→ Step 2: Trie 構造器 // 初始化根節點  \n&nbsp;&nbsp;→ Step 2.1: Trie.root = 新 Node() // 根節點不代表任何字母  \n→ Step 3: insert(word) // 將單詞插入 Trie  \n&nbsp;&nbsp;→ Step 3.1: current = Trie.root // 從根節點開始  \n&nbsp;&nbsp;→ Step 3.2: 對每個字符 ch in word 做:  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 3.2.1: Decision: 如果 current.children 中無 ch?  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 3.2.1.1: current.children[ch] = 新 Node() // 建立新節點  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → // 直接跳過  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 3.2.2: current = current.children[ch] // 移動到子節點  \n&nbsp;&nbsp;→ Step 3.3: current.isEnd = True // 標記單詞結尾  \n→ Step 4: search(word) // 檢查單詞是否存在  \n&nbsp;&nbsp;→ Step 4.1: current = Trie.root  \n&nbsp;&nbsp;→ Step 4.2: 對每個字符 ch in word 做:  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 4.2.1: Decision: 如果 current.children 中無 ch?  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 4.2.1.1: Return False // 找不到字母，單詞不存在  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → // 連續  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 4.2.2: current = current.children[ch]  \n&nbsp;&nbsp;→ Step 4.3: Decision: 如果 current.isEnd?  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 4.3.1: Return True // 單詞已插入  \n&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 4.3.2: Return False // 前綴匹配但不是完整單詞  \n→ Step 5: startsWith(prefix) // 檢查前綴是否存在  \n&nbsp;&nbsp;→ Step 5.1: current = Trie.root  \n&nbsp;&nbsp;→ Step 5.2: 對每個字符 ch in prefix 做:  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 5.2.1: Decision: 如果 current.children 中無 ch?  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 5.2.1.1: Return False // 前綴不存在  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → // 連續  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 5.2.2: current = current.children[ch]  \n&nbsp;&nbsp;→ Step 5.3: Return True // 所有字母均存在，前綴存在  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                node.children[ch] = TrieNode()\n            node = node.children[ch]\n        node.is_end = True\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return node.is_end\n\n    def startsWith(self, prefix: str) -> bool:\n        node = self.root\n        for ch in prefix:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return True\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # eval the input string to get a tuple of two lists\n    commands, args = eval(data)\n\n    trie = None\n    outputs = []\n\n    for cmd, arg in zip(commands, args):\n        if cmd == \"Trie\":\n            trie = Trie()\n            outputs.append(None)\n        elif cmd == \"insert\":\n            trie.insert(arg[0])\n            outputs.append(None)\n        elif cmd == \"search\":\n            outputs.append(trie.search(arg[0]))\n        elif cmd == \"startsWith\":\n            outputs.append(trie.startsWith(arg[0]))\n\n    # Convert Python None/True/False to LeetCode style output\n    result_str = \"[\" + \", \".join(\n        \"null\" if v is None else (\"true\" if v else \"false\") for v in outputs\n    ) + \"]\"\n    print(result_str)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "['Trie', 'insert', 'search', 'search', 'startsWith', 'insert', 'search'], [[], ['apple'], ['apple'], ['app'], ['app'], ['app'], ['app']]",
          "expected_output": "[null, null, true, false, true, null, true]",
          "success": true,
          "output": "[null, null, true, false, true, null, true]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode268.json",
    "problem_index_in_file": 0,
    "title": "Missing Number",
    "description_snippet": "Given an array nums containing n distinct numbers in the range [0, n], return the only number in the...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate pseudocode lines with explanations. For the problem: \"Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.\" So algorithm: XOR all indices and all values, or sum difference. We'll produce a simple algorithm using XOR.\n\nWe must produce each line: \"虛擬碼步驟 // 解釋\". Use arrow arrows.\n\nLet's structure: Start, Step 1: compute XOR of all indices, Step 2: compute XOR of all array values, Step 3: result = XOR of these two XORs. Output result. End.\n\nNeed to mention decision? Not necessary. Just straightforward.\n\nWe need to use arrow → for steps. Also use 'Decision:' lines only if decision. So we just use straightforward lines.\n\nWe must ensure each line ends with // explanation.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 初始化 missing ← 0 // 設定缺失值為 0\n→ Step 2: 對於 i 從 0 到 nums.length 做以下: // 迭代索引\n    → Step 2.1: missing ← missing XOR i // XOR 索引到 missing\n    → Step 2.2: missing ← missing XOR nums[i] // XOR 對應數值到 missing\n→ Step 3: 回傳 missing // missing 即為缺失的數字\nEnd // 程式執行結束\n\nMake sure each line includes one statement. But we have sub-steps with indent. We can keep them as separate lines with arrow? We might use indentation but keep arrow. Use same style: \n→ Step 2: For i from 0 to n do: // loop\n    → Step 2.1: missing ← missing XOR i\n    → Step 2.2: missing ← missing XOR nums[i]\n\nMake sure each line ends with explanation. Ensure \"→\" arrow at beginning of each line except Start/End? In example Start has no arrow. In sample, they had \"Start // ...\" then \"→ Step 1: ...\" So yes.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 設定 missing ← 0 // 初始化缺失值為 0\n→ Step 2: 對於 i 從 0 到 nums.length-1 做以下 // 迭代所有索引\n    → Step 2.1: missing ← missing XOR i // 將索引 i XOR 到 missing\n    → Step 2.2: missing ← missing XOR nums[i] // 將對應的數值 XOR 到 missing\n→ Step 3: 回傳 missing // missing 即為範圍內缺失的唯一數字\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def missingNumber(self, nums):\n        \"\"\"\n        計算 0~n 的 XOR，再 XOR 數組中的每個元素\n        最終得到缺失的那個數字。\n        \"\"\"\n        missing = 0\n        n = len(nums)\n        # XOR 所有 0~n 的數字\n        for i in range(n + 1):\n            missing ^= i\n        # XOR 數組中的每個元素\n        for num in nums:\n            missing ^= num\n        return missing\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個內容\n    data = sys.stdin.read().strip()\n    # 透過正則表達式提取方括號內的數字列表\n    match = re.search(r'\\[([^\\]]*)\\]', data)\n    if match:\n        list_str = match.group(0)          # 包含 '[' 和 ']'\n        try:\n            nums = eval(list_str)          # 將字串轉成列表\n        except Exception:\n            nums = []\n    else:\n        nums = []\n\n    sol = Solution()\n    result = sol.missingNumber(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [3,0,1]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "nums = [0,1]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "nums = [9,6,4,2,3,5,7,0,1]",
          "expected_output": "8",
          "success": true,
          "output": "8"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode470.json",
    "problem_index_in_file": 0,
    "title": "Implement Rand10() Using Rand7()",
    "description_snippet": "Given the API rand7() that generates a uniform random integer in the range [1, 7], write a function ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps to create rand10() using rand7() uniformly. Standard approach: generate numbers 1-49 using two rand7 calls (like 7*7=49), then map 1-40 to 1-10 (by modulo 10). If >40, reject and repeat. Or can generate 1-63 using 3 calls, etc. The simplest: two calls produce 7*7=49. Use rejection for >40. Implementation: loop until valid. Pseudocode.\n\nNeed to output each line with step and explanation, using Start, Decision, Yes/No arrows. Let's produce:\n\nStart\n→ Step 1: 定義函式 rand10() // 開始定義\n→ Decision: 需要重複? // 進入循環\n    Yes → Step 2: Call rand7() → x // 取得第一個隨機數\n    Yes → Step 3: Call rand7() → y // 取得第二個隨機數\n    Yes → Step 4: 計算 num = (x-1)*7 + y // 將兩個數轉為 1-49\n    Yes → Decision: 如果 num <= 40? // 檢查是否在可接受範圍\n        Yes → Step 5: 返回 (num-1)%10 + 1 // 產生 1-10\n        No  → Step 6: 重複循環 // 重新生成\nEnd\n\nBut need to structure loops properly. Use Decision: 重複? Yes → Continue. But we can express loop as Decision: num <=40? Yes→ return else → repeat. Use Start and End.\n\nLet's produce virtual steps:\n\nStart\n→ Step 1: 定義 rand10() // 函式開始\n→ Decision: 是否已獲得有效數? // 判斷是否需要重複\n    No  → Step 2: x ← rand7() // 第一次呼叫\n    No  → Step 3: y ← rand7() // 第二次呼叫\n    No  → Step 4: num ← (x-1)*7 + y // 組合成 1-49\n    No  → Decision: num <= 40? // 是否可映射\n        Yes → Step 5: result ← (num-1) mod 10 + 1 // 產生 1-10\n        Yes → Step 6: return result // 結束\n        No  → Step 7: 回到 Decision: 是否已獲得有效數? // 重複循環\nEnd\n\nBut we need to use Yes/No arrows properly. Let's define:\n\nStart\n→ Step 1: 函式 rand10() // 開始\n→ Decision: 是否已獲得有效結果? // 初始不\n    No → Step 2: x ← rand7() // 取得第一個隨機數\n    No → Step 3: y ← rand7() // 取得第二個隨機數\n    No → Step 4: num ← (x-1)*7 + y // 轉成 1-49\n    No → Decision: num <= 40? // 可接受？\n        Yes → Step 5: result ← (num-1) mod 10 + 1 // 產生 1-10\n        Yes → Step 6: return result // 結束\n        No  → Step 7: 回到 Decision: 是否已獲得有效結果? // 循環\n\nEnd\n\nBut we need to incorporate arrow Yes →, No →. The \"回到 Decision\" can be represented by a jump back: No → Step 7: goto Decision: 是否已獲得有效結果? But maybe we can structure as loop: Decision: num <= 40? Yes→ return, No→ repeat. So we don't need \"是否已獲得有效結果?\" but just a loop.\n\nBetter:\n\nStart\n→ Step 1: 定義 rand10() // 開始定義\n→ Decision: 無效結果? // 循環判斷\n    No  → Step 2: x ← rand7() // 呼叫 rand7()\n    No  → Step 3: y ← rand7() // 呼叫 rand7()\n    No  → Step 4: num ← (x-1)*7 + y // 產生 1-49\n    No  → Decision: num <= 40? // 是否在可接受範圍\n        Yes → Step 5: result ← (num-1) mod 10 + 1 // 將 1-40 映射為 1-10\n        Yes → Step 6: return result // 結束\n        No  → Step 7: 返回到 Decision: 無效結果? // 重複\n\nEnd\n\nBut we need to make sure the virtual code arrow formatting: Use `→`, `Yes →`, `No →`. Also indent for nested decision. Use spaces. Example:\n\n→ Decision: num <= 40? \n    Yes → Step 5...\n    No  → Step 7: 循環\n\nBut we also need to show that Step 7 goes back to the outer Decision (which is the start of loop). But we can express it as `No → Step 2: ...` but we want to show the loop. Let's use a label `LoopStart` or just use the outer Decision as loop. So after No, we can jump to Step 2. So:\n\n→ Decision: num <= 40? \n    Yes → Step 5: ...\n    Yes → Step 6: return\n    No  → Step 2: x ← rand7() // 回到開始\n\nBut that duplicates step. But we can do that.\n\nAlternatively, use `→ Decision: num <= 40?` inside loop and if No → go back to `Step 2`.\n\nLet's produce the final code. Must maintain each line separate. Use indent for nested decisions. Provide short explanation. Use Chinese. Ensure not to output actual code. Use \"虛擬碼步驟\" plus explanation.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: 定義函式 rand10() // 建立 rand10() 的流程\n→ Decision: 是否已得到有效結果? // 進入重複判斷\n    No  → Step 2: x ← rand7() // 呼叫 rand7() 取得第一個隨機數\n    No  → Step 3: y ← rand7() // 呼叫 rand7() 取得第二個隨機數\n    No  → Step 4: num ← (x-1)*7 + y // 將兩個數映射為 1-49\n    No  → Decision: num <= 40? // 檢查是否落在可接受範圍\n        Yes → Step 5: result ← (num-1) mod 10 + 1 // 轉成 1-10\n        Yes → Step 6: return result // 回傳結果，結束函式\n        No  → Step 2: x ← rand7() // 超過 40，重新開始循環\nEnd // 程式執行結束\n\nWe need to ensure the structure: the No arrow for Step 2 duplicates, but that's okay.\n\nAlso, we need to use \"Yes →\" and \"No →\" arrows correctly. Provide explanation for each line. This meets requirement.\n\nLet's provide final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義函式 rand10() // 建立 rand10() 的流程\n→ Decision: 是否已得到有效結果? // 進入重複判斷\n    No  → Step 2: x ← rand7() // 呼叫 rand7() 取得第一個隨機數\n    No  → Step 3: y ← rand7() // 呼叫 rand7() 取得第二個隨機數\n    No  → Step 4: num ← (x-1)*7 + y // 將兩個數映射為 1-49\n    No  → Decision: num <= 40? // 檢查是否落在可接受範圍\n        Yes → Step 5: result ← (num-1) mod 10 + 1 // 轉成 1-10\n        Yes → Step 6: return result // 回傳結果，結束函式\n        No  → Step 2: x ← rand7() // 超過 40，重新開始循環\nEnd // 程式執行結束",
      "generated_code": "import random\nimport re\nimport sys\n\ndef rand7():\n    \"\"\"Generate a uniform random integer in [1, 7] using Python's random module.\"\"\"\n    return random.randint(1, 7)\n\nclass Solution:\n    def rand10(self):\n        \"\"\"Generate a uniform random integer in [1, 10] using only rand7().\"\"\"\n        while True:\n            # Combine two calls to rand7() to produce a uniform integer in [1, 49]\n            num = (rand7() - 1) * 7 + rand7()  # 1 ~ 49\n            if num <= 40:\n                # Map 1 ~ 40 to 1 ~ 10\n                return 1 + (num - 1) % 10\n\ndef main():\n    # Read the entire input and extract the first integer found\n    input_data = sys.stdin.read().strip()\n    if not input_data:\n        print([])\n        return\n\n    match = re.search(r'\\d+', input_data)\n    n = int(match.group()) if match else 0\n\n    solution = Solution()\n    results = [solution.rand10() for _ in range(n)]\n    print(results)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 1",
          "expected_output": "[2]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2]'\nGot (Norm):      '[6]'\n--- (Raw) ---\nRaw Expected: '[2]'\nRaw Got:      '[6]'"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[2,8]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,8]'\nGot (Norm):      '[2,2]'\n--- (Raw) ---\nRaw Expected: '[2,8]'\nRaw Got:      '[2, 2]'"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "[3,8,10]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,8,10]'\nGot (Norm):      '[2,4,5]'\n--- (Raw) ---\nRaw Expected: '[3,8,10]'\nRaw Got:      '[2, 4, 5]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode7.json",
    "problem_index_in_file": 0,
    "title": "Reverse Integer",
    "description_snippet": "Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code step-by-step for the problem: reverse integer, handle 32-bit overflow, cannot use 64-bit integers. Use signed 32-bit operations only. Approach: use division and modulo by 10. While x != 0, get digit = x % 10; x = x / 10; new = new * 10 + digit; before multiplying, check overflow: if new > INT_MAX/10 or new < INT_MIN/10 etc. But cannot use 64-bit. We can use 32-bit signed arithmetic but check boundaries using constants. Since we cannot use 64-bit, we need to detect overflow before multiplying: if new > INT_MAX/10 or new < INT_MIN/10, return 0. Also if new == INT_MAX/10 and digit > 7 return 0; if new == INT_MIN/10 and digit < -8 return 0. Use decision nodes. Represent with Start, End, Decision, Steps.\n\nWe'll produce lines: Start // 程式開始執行\n→ Step 1: 設定 result = 0 // 初始化結果\n→ Step 2: 設定 input = x // 把輸入值存入 input\n→ Decision: while input != 0? // 需要繼續處理每一位\n    Yes → Step 3: digit = input % 10 // 取出最後一位\n    → Step 4: input = input / 10 // 移除最後一位\n    → Decision: 檢查是否會溢出? // 在將 digit 加入 result 前先判斷\n        Yes → Step 5: result = result * 10 + digit // 更新結果\n        No → Step 6: return 0 // 溢出則返回 0\n    → Back to Decision while input != 0\n    No → Step 7: return result // 處理完成\nEnd // 程式結束\n\nBut need detailed overflow check: For 32-bit signed: INT_MAX = 2147483647, INT_MIN = -2147483648. We can implement overflow detection:\n\nDecision: 如果 result > INT_MAX/10 或 result < INT_MIN/10 then overflow → Step 6. Else if result == INT_MAX/10 and digit > 7 then overflow. Else if result == INT_MIN/10 and digit < -8 then overflow.\n\nBut digits range -9..9? For negative numbers, digit can be negative? Actually when input is negative, input%10 yields negative remainder. In many languages, remainder keeps sign. But to be safe, we can treat digit as input % 10 (could be negative). We can use decisions accordingly.\n\nSo the virtual code should include nested decisions for overflow detection.\n\nLet's produce the virtual code accordingly.\n\nWe need each line: virtual code step + // 解釋. Use arrow symbols. We'll follow the format: each line starts with \"→\" except Start and End.\n\nWe must produce step-by-step.\n\nI'll write:\n\nStart // 程式開始執行\n→ Step 1: result = 0 // 初始化結果變數\n→ Step 2: input = x // 將使用者傳入的整數存入 input\n→ Decision: input != 0? // 是否還有數位需要處理\n    Yes → Step 3: digit = input % 10 // 取得 input 最後一位\n    → Step 4: input = input / 10 // 刪除 input 最後一位\n    → Decision: 檢查是否會溢出? // 在把 digit 加入 result 之前先確認不會超出 32-bit 範圍\n        Yes → Step 5: result = result * 10 + digit // 更新 result\n        No  → Step 6: return 0 // 溢出，立即回傳 0\n    → Back to Decision input != 0\n    No → Step 7: return result // 所有位數已處理，回傳結果\nEnd // 程式執行結束\n\nBut we need to show the overflow checks in detail. We can add nested decisions:\n\nDecision: result > INT_MAX / 10 OR result < INT_MIN / 10? // check overflow by magnitude\n    Yes → Step 6: return 0\n    No → Decision: result == INT_MAX / 10 AND digit > 7? OR result == INT_MIN / 10 AND digit < -8? \n        Yes → Step 6: return 0\n        No → Step 5: result = result * 10 + digit\n\nThus the step numbering may shift. Let's structure accordingly.\n\nWe need each step line. We'll number accordingly. Use \"Decision:\" lines for conditions. Use arrow indentations. Must maintain the format exactly: each line must contain the virtual code step + space + // explanation. Use arrow or decision arrows. The example uses indentation but we can mimic. We'll output each line with indentation for nested decisions.\n\nMake sure to use `→` before each step. Indent nested decisions accordingly: use 4 spaces maybe. In example they indent lines under decisions with 4 spaces (they just start new lines with indentation). Use similar.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: result = 0 // 初始化結果變數  \n→ Step 2: input = x // 取得使用者輸入的整數  \n→ Decision: input != 0? // 判斷是否還有位數需要處理  \n    Yes → Step 3: digit = input % 10 // 取出 input 最後一位  \n    → Step 4: input = input / 10 // 去除 input 最後一位  \n    → Decision: 是否會溢出? // 在把 digit 加入 result 前先確認不會超出 32‑bit 範圍  \n        Yes → Step 5: result = result * 10 + digit // 更新 result  \n        No  → Step 6: return 0 // 溢出，立即回傳 0  \n    → Back to Decision input != 0  \n    No → Step 7: return result // 所有位數已處理，回傳結果  \nEnd // 程式執行結束  \n\n---  \n\n**詳細的溢出檢查流程**（可作為 Step 5 的子流程）  \n→ Decision: result > INT_MAX / 10 OR result < INT_MIN / 10?  \n    Yes → Step 6: return 0 // 超出範圍，直接回傳 0  \n    No → Decision: (result == INT_MAX / 10 AND digit > 7) OR (result == INT_MIN / 10 AND digit < -8)?  \n        Yes → Step 6: return 0 // 最後一位超過可容納範圍，回傳 0  \n        No → Step 5: result = result * 10 + digit // 安全更新 result",
      "generated_code": "import sys\nimport re\n\nINT_MAX = 2 ** 31 - 1\nINT_MIN = -2 ** 31\n\n\ndef reverse(x: int) -> int:\n    \"\"\"Return the integer x with its digits reversed, or 0 if overflow occurs.\"\"\"\n    sign = -1 if x < 0 else 1\n    x_abs = abs(x)\n    result = 0\n\n    while x_abs != 0:\n        digit = x_abs % 10\n        x_abs //= 10\n\n        # 檢查乘以 10 後是否會溢出 32-bit 範圍\n        if result > INT_MAX // 10:\n            return 0\n        if result == INT_MAX // 10 and digit > 7:\n            return 0\n\n        result = result * 10 + digit\n\n    result *= sign\n\n    # 再次檢查整數是否在範圍內（負數可能超過 INT_MIN）\n    if result < INT_MIN or result > INT_MAX:\n        return 0\n\n    return result\n\n\ndef main() -> None:\n    \"\"\"從標準輸入讀取整數，輸出反轉後的結果。\"\"\"\n    data = sys.stdin.read()\n    if not data:\n        return\n\n    # 在輸入中尋找第一個整數（支持「x = -123」等格式）\n    match = re.search(r'-?\\d+', data)\n    if not match:\n        return\n\n    x = int(match.group())\n    print(reverse(x))\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "x = 123",
          "expected_output": "321",
          "success": true,
          "output": "321"
        },
        {
          "example_index": 1,
          "input": "x = -123",
          "expected_output": "-321",
          "success": true,
          "output": "-321"
        },
        {
          "example_index": 2,
          "input": "x = 120",
          "expected_output": "21",
          "success": true,
          "output": "21"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode67.json",
    "problem_index_in_file": 0,
    "title": "Add Binary",
    "description_snippet": "Given two binary strings a and b, return their sum as a binary string....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code step by step. Binary addition of two strings. Steps: Start, initialize carry=0, result string, iterate from end to start aligning lengths, add bits + carry, compute sum bit and new carry, prepend bit to result, after loop if carry 1, prepend '1'. End. Also handle string lengths.\n\nWe must produce lines like:\n\nStart // 程式開始執行\n→ Step 1: 初始化 carry 為 0, result 為空字符串 // ...\n\nNeed Decision: if i<0 and j<0 and carry==0? Or loop while i>=0 or j>=0 or carry>0.\n\nWe'll produce loop step using Decision and loops. But they want arrow structure. Could do:\n\n→ Decision: i>=0 OR j>=0 OR carry>0? // 判斷是否還有位元要加\n    Yes → Step 2: 取 a_i 為 i>=0? a[i] : '0', 取 b_j 為 j>=0? b[j] : '0' // ...\n    ... compute sum, etc.\n    No  → End\n\nBut they want structured steps with arrow. We'll produce step lines within yes block.\n\nSimplify: Use while loop like pseudo: while i>=0 or j>=0 or carry: ... So we can represent as Decision with Yes path containing steps.\n\nLet's produce:\n\nStart\n→ Step 1: 初始化 i = a.length - 1, j = b.length - 1, carry = 0, result = \"\" // ...\n→ Decision: i >= 0 OR j >= 0 OR carry > 0? // 判斷是否還有位元需處理\n    Yes → Step 2: 取 a_bit = i >= 0 ? a[i] : '0' // 若 i 有位則取，否則取 0\n    → Step 3: 取 b_bit = j >= 0 ? b[j] : '0' // 同上\n    → Step 4: sum = (a_bit - '0') + (b_bit - '0') + carry // 計算加總\n    → Step 5: result = (sum % 2) + result // 將最低位加入結果\n    → Step 6: carry = sum / 2 // 更新進位\n    → Step 7: i = i - 1, j = j - 1 // 指向下一位\n    → Decision: i >= 0 OR j >= 0 OR carry > 0? // 循環判斷\n        Yes → repeat Steps 2-7\n        No  → End // 完成\nEnd\n\nBut need to keep sequential lines. Let's produce step by step with indentation to show decision blocks.\n\nHowever, they said each line must be '虛擬碼步驟' + ' // 解釋'.\n\nAlso, use arrow: '→', 'Yes →', 'No →'.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: 設定 i = a.length - 1, j = b.length - 1, carry = 0, result = \"\" // 初始化索引、進位與結果\n→ Decision: i >= 0 OR j >= 0 OR carry > 0? // 判斷是否還有位元要處理\n    Yes → Step 2: a_bit = i >= 0 ? a[i] : '0' // 取得 a 的位元，若已到頭則取 0\n    → Step 3: b_bit = j >= 0 ? b[j] : '0' // 取得 b 的位元，若已到頭則取 0\n    → Step 4: sum = (a_bit - '0') + (b_bit - '0') + carry // 計算兩位元與進位的總和\n    → Step 5: result = (sum % 2) + result // 將最低位追加到結果前面\n    → Step 6: carry = sum / 2 // 更新進位\n    → Step 7: i = i - 1, j = j - 1 // 移動到更高位\n    → Decision: i >= 0 OR j >= 0 OR carry > 0? // 繼續循環判斷\n        Yes → repeat Steps 2-7\n        No  → End // 所有位元已處理\nEnd // 程式執行結束\n\nWe need to ensure 'Yes →' and 'No →' syntax. In the Decision block we need to indent? The example shows indentation but we just need to output each line separately. For decision, the Yes and No branches appear on separate lines with indentation. But each line is still a virtual code step. So we might write:\n\n→ Decision: i >= 0 OR j >= 0 OR carry > 0? // 判斷是否還有位元要處理\n    Yes → Step 2: a_bit = i >= 0 ? a[i] : '0' // ...\n    No  → End // 完成\n\nBut then we need to incorporate the loop. In pseudocode, we can just show a repeat. But to keep within structure, we can use Decision again inside Yes branch. But we might avoid complicated recursion by saying \"repeat until condition false\". We can show as a comment.\n\nSimplify: Use while loop representation: while i>=0 or j>=0 or carry>0: ... Then after loop End. But they insisted using Decision arrow. But can combine: Step 1: while condition? Eh.\n\nBetter produce:\n\nStart\n→ Step 1: i = a.length - 1, j = b.length - 1, carry = 0, result = \"\" // init\n→ Decision: i >= 0 OR j >= 0 OR carry > 0? // loop condition\n    Yes → Step 2: a_bit = i >= 0 ? a[i] : '0'\n    → Step 3: b_bit = j >= 0 ? b[j] : '0'\n    → Step 4: sum = (a_bit - '0') + (b_bit - '0') + carry\n    → Step 5: result = (sum % 2) + result\n    → Step 6: carry = sum / 2\n    → Step 7: i = i - 1, j = j - 1\n    → Decision: i >= 0 OR j >= 0 OR carry > 0? // next iteration\n        Yes → repeat Steps 2-7\n        No  → End\n    No  → End // no bits left\n\nBut need to show \"repeat Steps 2-7\" as a line? It could be: → Step 8: repeat // but that's ambiguous.\n\nWe can show an explicit loop: Use Decision with Yes path containing steps and then a jump back to Decision. But easier: Use while loop structure:\n\nStart\n→ Step 1: i = a.length - 1, j = b.length - 1, carry = 0, result = \"\" // init\n→ While: i >= 0 OR j >= 0 OR carry > 0 // start loop\n    → Step 2: a_bit = i >= 0 ? a[i] : '0' // ...\n    → Step 3: b_bit = j >= 0 ? b[j] : '0'\n    → Step 4: sum = (a_bit - '0') + (b_bit - '0') + carry\n    → Step 5: result = (sum % 2) + result\n    → Step 6: carry = sum / 2\n    → Step 7: i = i - 1, j = j - 1\n→ End // loop finished\nEnd // program finished\n\nBut the requirement says use Decision: and arrows Yes →, No →. They didn't specify While. But using Decision is acceptable.\n\nWe can emulate loop using decision and jump back to decision. Eg:\n\nStart\n→ Step 1: init\n→ Decision: i >= 0 OR j >= 0 OR carry > 0?\n    Yes → Step 2: ...\n    → Step 3: ...\n    → Step 4: ...\n    → Step 5: ...\n    → Step 6: ...\n    → Step 7: ...\n    → Decision: i >= 0 OR j >= 0 OR carry > 0?\n        Yes → repeat Steps 2-7\n        No  → End\n    No  → End\n\nBut this has two decision blocks, nested. Might be fine.\n\nLet's produce each line sequentially with indentation:\n\nStart // 程式開始執行\n→ Step 1: i = a.length - 1, j = b.length - 1, carry = 0, result = \"\" // 初始化索引、進位與結果\n→ Decision: i >= 0 OR j >= 0 OR carry > 0? // 判斷是否還有位元需要處理\n    Yes → Step 2: a_bit = i >= 0 ? a[i] : '0' // 取得 a 的位元，若已到頭則取 0\n    → Step 3: b_bit = j >= 0 ? b[j] : '0' // 取得 b 的位元，若已到頭則取 0\n    → Step 4: sum = (a_bit - '0') + (b_bit - '0') + carry // 計算兩位元與進位的總和\n    → Step 5: result = (sum % 2) + result // 將最低位追加到結果前面\n    → Step 6: carry = sum / 2 // 更新進位\n    → Step 7: i = i - 1, j = j - 1 // 移動到更高位\n    → Decision: i >= 0 OR j >= 0 OR carry > 0? // 繼續判斷下一輪\n        Yes → repeat Steps 2-7 // 迴圈重複\n        No  → End // 所有位元已處理\n    No  → End // 無須加法，直接結束\nEnd // 程式執行結束\n\nBut \"repeat Steps 2-7\" might not be considered a step. We could instead indent back to previous Decision by saying \"→ Decision: i >= 0 OR j >= 0 OR carry > 0?\" again. That would be redundant but expresses loop. Let's instead use a \"Loop\" representation:\n\nStart\n→ Step 1: i = a.length - 1, j = b.length - 1, carry = 0, result = \"\" // init\n→ Decision: i >= 0 OR j >= 0 OR carry > 0? // loop condition\n    Yes → Step 2: a_bit = i >= 0 ? a[i] : '0' // ...\n    → Step 3: b_bit = j >= 0 ? b[j] : '0'\n    → Step 4: sum = (a_bit - '0') + (b_bit - '0') + carry\n    → Step 5: result = (sum % 2) + result\n    → Step 6: carry = sum / 2\n    → Step 7: i = i - 1, j = j - 1\n    → Decision: i >= 0 OR j >= 0 OR carry > 0? // check again\n        Yes → repeat Steps 2-7\n        No  → End\n    No  → End\nEnd\n\nBut we already have nested Decision inside Yes. That nested Decision ensures loop.\n\nAlternatively, we can show as:\n\nStart\n→ Step 1: i = a.length - 1, j = b.length - 1, carry = 0, result = \"\" // init\n→ Loop: while i >= 0 OR j >= 0 OR carry > 0:\n    → Step 2: a_bit = i >= 0 ? a[i] : '0'\n    → Step 3: b_bit = j >= 0 ? b[j] : '0'\n    → Step 4: sum = (a_bit - '0') + (b_bit - '0') + carry\n    → Step 5: result = (sum % 2) + result\n    → Step 6: carry = sum / 2\n    → Step 7: i = i - 1, j = j - 1\n→ End // loop finished\nEnd\n\nBut they'd like Decision arrow.\n\nI'll keep as earlier with nested Decision.\n\nMake sure each line has \"虛擬碼步驟\" and \" // 解釋/說明\".\n\nWe need to avoid using actual code like a[i] etc? It's allowed as virtual. It's fine.\n\nAlso, each line must include arrow: '→' before step. For Decision lines, we use '→ Decision:'.\n\nFor Yes / No we use 'Yes →' and 'No →' at line start.\n\nOk produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: i = a.length - 1, j = b.length - 1, carry = 0, result = \"\" // 初始化索引、進位與結果  \n→ Decision: i >= 0 OR j >= 0 OR carry > 0? // 判斷是否還有位元需要處理  \n    Yes → Step 2: a_bit = i >= 0 ? a[i] : '0' // 取得 a 的位元，若已到頭則取 0  \n    → Step 3: b_bit = j >= 0 ? b[j] : '0' // 取得 b 的位元，若已到頭則取 0  \n    → Step 4: sum = (a_bit - '0') + (b_bit - '0') + carry // 計算兩位元與進位的總和  \n    → Step 5: result = (sum % 2) + result // 將最低位追加到結果前面  \n    → Step 6: carry = sum / 2 // 更新進位  \n    → Step 7: i = i - 1, j = j - 1 // 移動到更高位  \n    → Decision: i >= 0 OR j >= 0 OR carry > 0? // 繼續判斷下一輪  \n        Yes → repeat Steps 2-7 // 迴圈重複  \n        No  → End // 所有位元已處理  \n    No  → End // 無須加法，直接結束  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def addBinary(self, a: str, b: str) -> str:\n        i, j = len(a) - 1, len(b) - 1\n        carry = 0\n        result = []\n\n        while i >= 0 or j >= 0 or carry:\n            total = carry\n            if i >= 0:\n                total += int(a[i])\n                i -= 1\n            if j >= 0:\n                total += int(b[j])\n                j -= 1\n            result.append(str(total % 2))\n            carry = total // 2\n\n        return ''.join(reversed(result))\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Extract strings inside double quotes\n    matches = re.findall(r'\"([^\"]*)\"', data)\n    if len(matches) >= 2:\n        a, b = matches[0], matches[1]\n    else:\n        # Fallback: split by whitespace if no quotes present\n        parts = data.split()\n        a, b = parts[0], parts[1] if len(parts) > 1 else \"\"\n\n    solution = Solution()\n    result = solution.addBinary(a, b)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "a = \"11\", b = \"1\"",
          "expected_output": "\"100\"",
          "success": true,
          "output": "100"
        },
        {
          "example_index": 1,
          "input": "a = \"1010\", b = \"1011\"",
          "expected_output": "\"10101\"",
          "success": true,
          "output": "10101"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode371.json",
    "problem_index_in_file": 0,
    "title": "Sum of Two Integers",
    "description_snippet": "Given two integers a and b, return the sum of the two integers without using the operators + and -....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code (like flowchart steps) for adding two integers without + or -. Use bitwise operations: XOR and AND<<1. So steps: Start, input a, input b, while b!=0, carry = a & b, a = a ^ b, b = carry << 1. End. And explanation.\n\nWe must output each line with virtual code and comment. Must use \"→\" for next steps. Provide Decision lines. Let's create stepwise. Use \"Step 1: 輸入 a\" etc.\n\nWe need to ensure each line includes the virtual code step and comment.\n\nWe must not output actual code, just structure.\n\nWe must include Start, End.\n\nWe must use \"Decision:\" for conditional branches.\n\nFlow: Start → Input a, Input b → Decision: while b != 0? Yes → compute carry, a xor, b shift. After loop, output a. End.\n\nBut we need to present loop structure with Decision. We can write: Decision: b ≠ 0? Yes → ... (then back to Decision). No → Step output sum. End.\n\nLet's produce.\n\nUse \"→\" arrow for sequential steps.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Step 1: 輸入整數 a // 取得第一個加數\n→ Step 2: 輸入整數 b // 取得第二個加數\n→ Decision: b ≠ 0? // 檢查是否還有進位需要處理\n    Yes → Step 3: 計算進位 carry = a & b // 取得兩個位元同時為 1 的進位\n    Yes → Step 4: 更新 a = a XOR b // 合併兩個位元的和（不含進位）\n    Yes → Step 5: 更新 b = carry << 1 // 將進位左移一位準備下一輪\n    Yes → Decision: b ≠ 0? // 回到檢查進位\n    No  → Step 6: 輸出 a // a 已經是最終和\nEnd // 程式執行結束\n\nBut we need to avoid indentation? It's okay. We need to include \"→\" for each line. The decision block may include multiple lines under it. Let's format with indentation maybe.\n\nWe need to ensure every line includes a space after the code before the comment. Use \" // \".\n\nLet's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入整數 a // 取得第一個加數  \n→ Step 2: 輸入整數 b // 取得第二個加數  \n→ Decision: b ≠ 0? // 檢查是否還有進位需要處理  \n Yes → Step 3: 計算進位 carry = a & b // 取得兩個位元同時為 1 的進位  \n Yes → Step 4: 更新 a = a XOR b // 合併兩個位元的和（不含進位）  \n Yes → Step 5: 更新 b = carry << 1 // 將進位左移一位準備下一輪  \n Yes → Decision: b ≠ 0? // 回到檢查進位  \n No  → Step 6: 輸出 a // a 已經是最終和  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def getSum(self, a: int, b: int) -> int:\n        MASK = 0xFFFFFFFF\n        MAX_INT = 0x7FFFFFFF\n        while b != 0:\n            carry = (a & b) & MASK\n            a = (a ^ b) & MASK\n            b = (carry << 1) & MASK\n        return a if a <= MAX_INT else ~(a ^ MASK)\n\ndef main():\n    data = sys.stdin.read()\n    nums = re.findall(r'-?\\d+', data)\n    if len(nums) >= 2:\n        a = int(nums[0])\n        b = int(nums[1])\n        result = Solution().getSum(a, b)\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "a = 1, b = 2",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "a = 2, b = 3",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode35.json",
    "problem_index_in_file": 0,
    "title": "Search Insert Position",
    "description_snippet": "Given a sorted array of distinct integers and a target value, return the index if the target is foun...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for binary search to find target or insertion index. Use Start, Decision, etc. Each line with explanation. Ensure we use arrow and steps. We'll structure: Start, initialize left, right, loop while left <= right, compute mid, compare arr[mid] to target, adjust bounds accordingly, if found return mid, else after loop return left as insertion index. End. Provide explanation. Use Chinese.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 left = 0, right = array.length - 1 // 初始化搜尋範圍  \n→ Step 2: 開始迴圈 while left <= right // 當搜尋範圍仍有效時重複  \n  → Decision: 如果 left > right? // 檢查範圍是否已無效  \n   Yes → Break // 若無效則結束迴圈  \n   No  → Step 3: 計算 mid = left + (right - left) / 2 // 取得中間索引  \n    → Decision: 如果 array[mid] == target? // 比較中間值與目標  \n     Yes → Step 4: 回傳 mid // 找到目標，返回索引  \n     No → Decision: 如果 array[mid] < target? // 判斷目標應在右側  \n      Yes → Step 5: left = mid + 1 // 將左邊界移至 mid + 1  \n      No → Step 6: right = mid - 1 // 將右邊界移至 mid - 1  \n→ Step 7: 回傳 left // 搜尋結束後 left 即為插入位置索引  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def searchInsert(self, nums, target):\n        \"\"\"\n        Use binary search to find the insertion position for target in sorted array nums.\n        \"\"\"\n        left, right = 0, len(nums)\n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid\n        return left\n\ndef parse_input(s: str):\n    \"\"\"\n    Parse input like:\n        nums = [1,3,5,6], target = 5\n    into (list, int).\n    \"\"\"\n    s = s.strip().replace('\\n', ' ')\n    if not s:\n        raise ValueError(\"Empty input\")\n    # Split around ', target ='\n    parts = s.split(', target =')\n    if len(parts) != 2:\n        raise ValueError(\"Input format should contain ', target ='\")\n    nums_part = parts[0].replace('nums =', '').strip()\n    target_part = parts[1].strip()\n    nums = ast.literal_eval(nums_part)\n    target = int(ast.literal_eval(target_part))\n    return nums, target\n\nif __name__ == \"__main__\":\n    input_text = sys.stdin.read()\n    try:\n        nums, target = parse_input(input_text)\n    except Exception as e:\n        print(f\"Error parsing input: {e}\", file=sys.stderr)\n        sys.exit(1)\n    sol = Solution()\n    result = sol.searchInsert(nums, target)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,3,5,6], target = 5",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "nums = [1,3,5,6], target = 2",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "nums = [1,3,5,6], target = 7",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode154.json",
    "problem_index_in_file": 0,
    "title": "Find Minimum in Rotated Sorted Array II",
    "description_snippet": "Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for finding min element in rotated sorted array with duplicates, with O(log n) or less. Usually binary search with duplicates. Provide virtual code line by line, with comments. Use structure Start, End, Decision: etc.\n\nNeed to respond in Traditional Chinese. Provide each line: \"虛擬碼步驟 // 解釋\".\n\nLet's produce algorithm: use low=0, high=n-1. While low < high: mid=(low+high)/2. Compare nums[mid] and nums[high]. If nums[mid] < nums[high], min in left half including mid: high=mid. Else if nums[mid] > nums[high], min in right half: low=mid+1. Else equal: high-- (since duplicate). At end low points to min. Return nums[low].\n\nAlso mention handling duplicates, reducing steps.\n\nWe'll produce pseudocode line by line, with indentation, decisions. Use arrow \"→\".\n\nLet's craft:\n\nStart\n→ Initialize low = 0 // 指向陣列首\n→ Initialize high = n - 1 // 指向陣列尾\n→ Decision: 是否 low < high? // 循環條件\n    Yes → Step: mid = (low + high) / 2 // 取中點\n    → Decision: nums[mid] < nums[high]?\n        Yes → high = mid // min 在左半段\n        No  → Decision: nums[mid] > nums[high]?\n            Yes → low = mid + 1 // min 在右半段\n            No  → high = high - 1 // nums[mid]==nums[high], 去除重複\n    → Decision: low < high? // 重複檢查\n        Yes → 回到上一步\n        No  → Step: return nums[low] // 找到最小值\nEnd\n\nBut we need to adhere to format: each line is \"虛擬碼步驟 // 解釋\". We can also indent decisions inside. Use \"Decision:\" lines.\n\nLet's produce a clear pseudocode with steps and comments. Use \"→\" for transitions. We can use indentation by spaces.\n\nOk produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ low = 0 // 指向陣列起始位置  \n→ high = n - 1 // 指向陣列結束位置  \n→ Decision: low < high? // 判斷是否還有未檢查區域  \n  Yes → mid = (low + high) / 2 // 計算中間索引  \n  → Decision: nums[mid] < nums[high]? // 判斷中值與右端是否處於升序段  \n    Yes → high = mid // 最小值必在左半段，包含 mid  \n    No → Decision: nums[mid] > nums[high]? // 判斷中值是否大於右端  \n      Yes → low = mid + 1 // 最小值必在右半段，排除 mid  \n      No → high = high - 1 // nums[mid] == nums[high]，可安全減少高端  \n  → Decision: low < high? // 繼續迴圈判斷  \n    Yes → 跳回上一層 Decision  \n    No → Step: return nums[low] // low 指向最小值  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findMin(self, nums):\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] > nums[right]:\n                left = mid + 1\n            elif nums[mid] < nums[right]:\n                right = mid\n            else:\n                right -= 1\n        return nums[left]\n\ndef parse_input(data: str):\n    data = data.strip()\n    if data.startswith('nums'):\n        idx = data.find('[')\n        if idx != -1:\n            data = data[idx:]\n    return ast.literal_eval(data)\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    nums = parse_input(raw_input)\n    result = Solution().findMin(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,3,5]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "nums = [2,2,2,0,1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode153.json",
    "problem_index_in_file": 0,
    "title": "Find Minimum in Rotated Sorted Array",
    "description_snippet": "Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code steps for algorithm to find min element in rotated sorted array, O(log n). Use binary search. Outline steps.\n\nStart\n→ Initialize left = 0, right = n-1\n→ Decision: If nums[left] < nums[right] then // not rotated or fully rotated\n    Yes → Step: Return nums[left] // minimum at left\n    No → Step: Continue binary search\n\n→ Step: While left <= right\n    -> Step: mid = (left + right) / 2 // integer\n    -> Decision: If nums[mid] > nums[right] // min in right half\n        Yes → left = mid + 1\n        No → right = mid // min in left half including mid\n    -> Decision: If left == right then // single element left\n        Yes → Step: Return nums[left]\n\nBut careful: while loop may use left < right and return nums[left] at end.\n\nSimplify: while left < right: mid = (left+right)//2; if nums[mid] > nums[right] left = mid+1 else right = mid; return nums[left].\n\nAlso handle array length 1: return nums[0].\n\nWe produce pseudo code line by line with explanations. Use arrow and Decision. Ensure each line has \"// explanation\". Format: \"Start // 程式開始執行\" etc.\n\nLet's produce step by step. Ensure each line ends with explanation comment.\n\nWe need to show each step. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 left = 0, right = nums.length - 1 // 初始化搜尋範圍  \n→ Decision: 如果 left == right? // 檢查是否只有一個元素  \n  Yes → Step 2: 回傳 nums[left] // 單元素即為最小值  \n  No → Step 3: 繼續下面的流程  \n→ Step 4: 判斷 nums[left] < nums[right]? // 檢查陣列是否已排序且未旋轉  \n  Yes → Step 5: 回傳 nums[left] // 最小值在最左邊  \n  No → Step 6: 進入二分搜尋找旋轉點  \n→ Decision: 進入 while 迴圈 (left < right)?  \n  Yes → Step 7: mid = (left + right) // 2 // 取中點索引  \n    Decision: nums[mid] > nums[right]? // 判斷最小值在右半段嗎？  \n     Yes → Step 8: left = mid + 1 // 移動左指標到 mid+1  \n     No → Step 9: right = mid // 移動右指標到 mid，包含 mid  \n    Decision: left < right? // 是否還要繼續搜尋？  \n     Yes → 回到 Step 7  \n     No → Step 10: 回傳 nums[left] // left 即為最小值  \n  No → Step 10: 回傳 nums[left] // 不再進入迴圈，直接回傳最左值  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def findMin(self, nums):\n        \"\"\"Return the minimum element in a rotated sorted array.\"\"\"\n        left, right = 0, len(nums) - 1\n        # 如果整個陣列已經是升序，最小值在最左邊\n        if nums[left] <= nums[right]:\n            return nums[left]\n\n        # 二分搜尋，縮小搜尋範圍直到 left == right\n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] > nums[right]:\n                # 最小值在右半段\n                left = mid + 1\n            else:\n                # 最小值在左半段（含 mid）\n                right = mid\n        return nums[left]\n\ndef parse_nums(input_str: str):\n    \"\"\"\n    從輸入字串中解析出 nums 列表。\n    支援格式例如 'nums = [3,4,5,1,2]' 或 'nums=[1,2,3]'。\n    \"\"\"\n    match = re.search(r'\\[(.*?)\\]', input_str)\n    if not match:\n        return []\n    inside = match.group(1)\n    # 以逗號分隔，忽略空格後轉成 int\n    return [int(part.strip()) for part in inside.split(',') if part.strip()]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    nums = parse_nums(data)\n    if not nums:\n        sys.exit(0)\n    solution = Solution()\n    print(solution.findMin(nums))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [3,4,5,1,2]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "nums = [4,5,6,7,0,1,2]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 2,
          "input": "nums = [11,13,15,17]",
          "expected_output": "11",
          "success": true,
          "output": "11"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode552.json",
    "problem_index_in_file": 0,
    "title": "Student Attendance Record II",
    "description_snippet": "An attendance record for a student can be represented as a string where each character signifies whe...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line explaining algorithm. Need to solve: count strings length n over {A,L,P} with at most one A (since strictly fewer than 2 absences) and no three consecutive L's. Classic DP. We can have DP[i][a][l] number of ways up to i with a absences used (0 or 1) and l consecutive L's at end (0,1,2). We compute mod. Then answer sum over a=0..1, l=0..2. Provide virtual steps. Also include modulo constant. Use loops. Provide explanation each line.\n\nWe don't output actual code. Only virtual steps. Use arrows and structure. Let's produce:\n\nStart\n→ Define MOD = 1_000_000_007 // Modulo value\n→ Initialize DP array DP[0][0][0] = 1 // 0 days, 0 absences, 0 trailing Ls\n→ For i from 1 to n: // iterate days\n    → For a in 0..1: // number of absences used so far\n        → For l in 0..2: // consecutive Ls at end\n            → If DP[i-1][a][l] == 0: Continue // no ways\n            → // Add 'P'\n            → DP[i][a][0] += DP[i-1][a][l] // reset trailing Ls\n            → // Add 'L' if l<2\n            → If l < 2:\n                → DP[i][a][l+1] += DP[i-1][a][l]\n            → // Add 'A' if a==0 (only one allowed)\n            → If a == 0:\n                → DP[i][1][0] += DP[i-1][0][l]\n            → Apply modulo after each addition\n→ // After loop, sum all DP[n][a][l]\n→ total = 0\n→ For a in 0..1:\n    → For l in 0..2:\n        → total += DP[n][a][l]\n        → total %= MOD\n→ End // Return total\n\nWe need to ensure each line has \"虛擬碼步驟\" + space + \"// 解釋\". Use arrow for transitions? The requirement: \"使用虛擬碼的箭頭 (`→`, `Yes →`, `No →`) 和結構 (`Start`, `End`, `Decision:`)。\"\n\nThus we should format each line like: \"Start // 程式開始執行\". Use \"→\" before lines that are steps. Decision maybe not needed. Use nested indentation with arrow inside loops? Might use \"→ For i from 1 to n:\" etc.\n\nLet's produce.\n\nAlso include \"Decision:\" lines? Not necessary.\n\nWe'll produce each line with arrow at start if it's a step, else no arrow? In example they had \"Start\" no arrow. Use arrow for subsequent lines.\n\nWill produce:\n\nStart // 程式開始執行\n→ Define MOD = 1_000_000_007 // 設定模數\n→ 初始化 DP[0][0][0] = 1 // 0 天、0 缺席、0 連續遲到的組合\n→ For i from 1 to n: // 逐天遞推\n    → For a from 0 to 1: // 已使用的缺席數\n        → For l from 0 to 2: // 末尾連續遲到天數\n            → If DP[i-1][a][l] == 0: Continue // 無有效組合\n            → // 添加出勤 'P'\n            → DP[i][a][0] = (DP[i][a][0] + DP[i-1][a][l]) mod MOD // 連續遲到歸零\n            → // 添加遲到 'L'（只能在連續遲到 <2 時）\n            → If l < 2:\n                → DP[i][a][l+1] = (DP[i][a][l+1] + DP[i-1][a][l]) mod MOD // 增加連續遲到\n            → // 添加缺席 'A'（只能在 a==0 時）\n            → If a == 0:\n                → DP[i][1][0] = (DP[i][1][0] + DP[i-1][0][l]) mod MOD // 將缺席數加一\n→ // 合計所有合法結束狀態\n→ total = 0\n    → For a from 0 to 1:\n        → For l from 0 to 2:\n            → total = (total + DP[n][a][l]) mod MOD\n→ End // 回傳答案\n\nWe need to ensure each line ends with \"// 解釋\". The nested lines have arrows but also need explanation.\n\nAlso need to use \"→\" before each line inside loops. Provide explanation accordingly.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Define MOD = 1_000_000_007 // 設定模數  \n→ 初始化 DP[0][0][0] = 1 // 0 天、0 缺席、0 連續遲到的組合  \n→ For i from 1 to n: // 逐天遞推  \n    → For a from 0 to 1: // 已使用的缺席數  \n        → For l from 0 to 2: // 末尾連續遲到天數  \n            → If DP[i-1][a][l] == 0: Continue // 無有效組合  \n            → // 添加出勤 'P'  \n            → DP[i][a][0] = (DP[i][a][0] + DP[i-1][a][l]) mod MOD // 連續遲到歸零  \n            → // 添加遲到 'L'（只能在連續遲到 <2 時）  \n            → If l < 2:  \n                → DP[i][a][l+1] = (DP[i][a][l+1] + DP[i-1][a][l]) mod MOD // 增加連續遲到  \n            → // 添加缺席 'A'（只能在 a==0 時）  \n            → If a == 0:  \n                → DP[i][1][0] = (DP[i][1][0] + DP[i-1][0][l]) mod MOD // 將缺席數加一  \n→ // 合計所有合法結束狀態  \n→ total = 0  \n    → For a from 0 to 1:  \n        → For l from 0 to 2:  \n            → total = (total + DP[n][a][l]) mod MOD // 累加合法組合  \nEnd // 回傳答案",
      "generated_code": "import sys\n\nMOD = 10**9 + 7\n\nclass Solution:\n    def checkRecord(self, n: int) -> int:\n        # dp[a][l] = number of valid sequences of current length\n        # with a 'A's used (0 or 1) and ending with l consecutive 'L's (0,1,2)\n        dp = [[0] * 3 for _ in range(2)]\n        dp[0][0] = 1  # empty sequence\n\n        for _ in range(n):\n            new_dp = [[0] * 3 for _ in range(2)]\n            for a in range(2):\n                for l in range(3):\n                    val = dp[a][l]\n                    if val == 0:\n                        continue\n                    # Add 'P' – reset consecutive 'L's\n                    new_dp[a][0] = (new_dp[a][0] + val) % MOD\n                    # Add 'A' – only if no 'A' used yet\n                    if a == 0:\n                        new_dp[1][0] = (new_dp[1][0] + val) % MOD\n                    # Add 'L' – only if current streak of 'L's is less than 2\n                    if l < 2:\n                        new_dp[a][l + 1] = (new_dp[a][l + 1] + val) % MOD\n            dp = new_dp\n\n        # Sum all valid final states\n        return sum(dp[a][l] for a in range(2) for l in range(3)) % MOD\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if data:\n        n = int(data)\n        solution = Solution()\n        print(solution.checkRecord(n))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "2",
          "expected_output": "8",
          "success": true,
          "output": "8"
        },
        {
          "example_index": 1,
          "input": "1",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 2,
          "input": "10101",
          "expected_output": "183236316",
          "success": true,
          "output": "183236316"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode334.json",
    "problem_index_in_file": 0,
    "title": "Increasing Triplet Subsequence",
    "description_snippet": "Given an integer array nums, return true if there exists a triple of indices (i, j, k) such that i <...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step, with each line of virtual code followed by // explanation. Use Start, End, Decision, arrows.\n\nRequirement: we need to solve the problem: given integer array nums, return true if there exists indices i<j<k with increasing triplet. Else false.\n\nWe need to produce virtual code with step-by-step logic.\n\nWe can implement algorithm: maintain two variables first and second as minimal values found so far, iterate over array, update first, second, return true when find value > second.\n\nPseudo:\n\nStart\n→ Step 1: Initialize first = ∞, second = ∞ // start with large values\n→ Decision: 遍歷 nums 中的每個元素 val? // for each element\n    → Step 2: 如果 val <= first? // update first\n        Yes → first = val // update first\n        No → Decision: 如果 val <= second? // update second\n            Yes → second = val // update second\n            No → Step 3: 找到遞增三元組，返回 true // found\n→ Step 4: 整個數組遍歷完未找到，返回 false\nEnd\n\nBut we need each line as a separate step. We can break decision into multiple lines.\n\nWe need to follow format: \"虛擬碼步驟\" + \" // 解釋\". So each line must start with \"Start\", \"→ Step X:\", \"Decision:\", etc.\n\nWe also need to include arrow arrows.\n\nLet's design step lines:\n\n1. Start // 程式開始執行\n2. → Step 1: Set first = +∞ // 初始化最小值\n3. → Step 2: Set second = +∞ // 初始化第二小值\n4. → Decision: 是否還有元素需要遍歷? // 判斷是否還有元素可處理\n    5. Yes → Step 3: 取下一個元素 val // 取出下一個數字\n    6. → Decision: val <= first? // 與 first 比較\n        7. Yes → Step 4: first = val // 更新 first\n        8. No → Decision: val <= second? // 與 second 比較\n            9. Yes → Step 5: second = val // 更新 second\n            10. No → Step 6: 返回 true // 找到三元組\n    11. → Decision: 是否還有元素? // 重複遍歷\n    12. Yes → (loop back to Step 3)\n    13. No → Step 7: 返回 false // 數組結束未找到\n14. End // 程式執行結束\n\nBut the decision loop may need to handle iteration.\n\nWe need to ensure the virtual code is sequential and clear.\n\nWe may express loop using \"Decision:\" with Yes/No pointing to steps.\n\nBut the \"Yes\" arrow must go to next step. The \"No\" arrow may lead to other step.\n\nWe can denote loop: After Step 6 or Step 5, go back to decision about next element.\n\nWe need to show arrow to earlier step for loop.\n\nWe can use \"Yes →\" arrow back to Step 3.\n\nBut must specify arrow direction: \"Yes → Step 3\".\n\nWe need to ensure each line ends with comment.\n\nLet's craft final answer.\n\nAlso need to maintain line numbering? Not necessary.\n\nWe need each line: e.g.,\n\nStart // 程式開始執行\n\n→ Step 1: Set first = +∞ // 初始化最小值\n\n→ Step 2: Set second = +∞ // 初始化第二小值\n\n→ Decision: 仍有元素可遍歷? // 判斷是否仍有數字待處理\n\n    Yes → Step 3: val = next(nums) // 取出下一個數字\n\n    No  → Step 4: 返回 false // 數組遍歷完未找到\n\n→ Decision: val <= first? // 與第一個最小值比較\n\n    Yes → Step 5: first = val // 更新 first\n\n    No  → Decision: val <= second? // 與第二個最小值比較\n\n        Yes → Step 6: second = val // 更新 second\n\n        No  → Step 7: 返回 true // 找到遞增三元組\n\n→ Decision: 仍有元素可遍歷? // 重新判斷是否還有數字\n\n    Yes → Step 3 // 重新取下一個元素\n\n    No  → Step 4 // 結束，返回 false\n\nBut we need to maintain step numbers consistent. Use same step numbers maybe.\n\nBut we need \"逐行\" output, each line includes virtual code and explanation. We should not include blank lines.\n\nWe can produce as:\n\nStart // 程式開始執行\n→ Step 1: Set first = +∞ // 初始化最小值\n→ Step 2: Set second = +∞ // 初始化第二小值\n→ Decision: 是否還有元素可遍歷? // 判斷是否有剩餘元素\n    Yes → Step 3: val = next(nums) // 取得下一個元素\n    No  → Step 4: 返回 false // 整個數組遍歷完未找到\n→ Decision: val <= first? // 與最小值比較\n    Yes → Step 5: first = val // 更新最小值\n    No  → Decision: val <= second? // 與第二小值比較\n        Yes → Step 6: second = val // 更新第二小值\n        No  → Step 7: 返回 true // 找到遞增三元組\n→ Decision: 是否還有元素可遍歷? // 判斷是否還有元素\n    Yes → Step 3 // 回到取下一個元素\n    No  → Step 4 // 結束，返回 false\nEnd // 程式執行結束\n\nBut this repeats Step 4 earlier, maybe confusion.\n\nWe need a consistent flow: maybe use while loop representation: after processing val, we go back to Decision: 是否還有元素可遍歷?\n\nThus we need to avoid duplicate Step 4.\n\nWe can number steps but arrow can go back.\n\nLet's design like:\n\nStart // 程式開始執行\n→ Step 1: Set first = +∞ // 初始化最小值\n→ Step 2: Set second = +∞ // 初始化第二小值\n→ Decision: 是否還有元素可遍歷? // 判斷是否有剩餘元素\n    Yes → Step 3: val = next(nums) // 取得下一個元素\n    No  → Step 4: 返回 false // 數組遍歷完未找到\n→ Decision: val <= first? // 與最小值比較\n    Yes → Step 5: first = val // 更新最小值\n    No  → Decision: val <= second? // 與第二小值比較\n        Yes → Step 6: second = val // 更新第二小值\n        No  → Step 7: 返回 true // 找到遞增三元組\n→ Decision: 是否還有元素可遍歷? // 判斷是否還有元素\n    Yes → Step 3 // 重新取下一個元素\n    No  → Step 4 // 結束，返回 false\nEnd // 程式執行結束\n\nNow we have duplicate Step 4 (same as earlier). But we can refer to same action.\n\nBut to avoid confusion, maybe we should use label names like \"ReturnTrue\" and \"ReturnFalse\" but it's okay.\n\nHowever, the instruction: Each line must contain \"虛擬碼步驟\" + \" // 解釋\". The code lines include arrow \"→\".\n\nWe should produce all lines as described.\n\nEnsure no real code.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Set first = +∞ // 初始化最小值  \n→ Step 2: Set second = +∞ // 初始化第二小值  \n→ Decision: 是否還有元素可遍歷? // 判斷是否還有剩餘元素  \n    Yes → Step 3: val = next(nums) // 取得下一個元素  \n    No  → Step 4: 返回 false // 數組遍歷完未找到遞增三元組  \n→ Decision: val <= first? // 與最小值比較  \n    Yes → Step 5: first = val // 更新最小值  \n    No  → Decision: val <= second? // 與第二小值比較  \n        Yes → Step 6: second = val // 更新第二小值  \n        No  → Step 7: 返回 true // 找到遞增三元組  \n→ Decision: 是否還有元素可遍歷? // 再次判斷是否還有元素  \n    Yes → Step 3 // 重新取下一個元素  \n    No  → Step 4 // 數組遍歷完未找到，返回 false  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def increasingTriplet(self, nums):\n        first = second = float('inf')\n        for num in nums:\n            if num <= first:\n                first = num\n            elif num <= second:\n                second = num\n            else:\n                return True\n        return False\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 找出括號內的數字列表\n    match = re.search(r'\\[.*\\]', data)\n    if match:\n        nums_str = match.group(0)\n        try:\n            nums = eval(nums_str)\n        except Exception:\n            nums = []\n    else:\n        nums = []\n\n    sol = Solution()\n    result = sol.increasingTriplet(nums)\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,4,5]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "nums = [5,4,3,2,1]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "nums = [2,1,5,0,4,6]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode390.json",
    "problem_index_in_file": 0,
    "title": "Elimination Game",
    "description_snippet": "You have a list arr of all integers in the range [1, n] sorted in a strictly increasing order. Apply...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm described: elimination game problem known as \"Elimination Game\" from Leetcode. We must output line-by-line with comments. Should avoid actual code. Provide steps using Start, Decision, etc.\n\nWe need to produce algorithmic steps: maintain head, step, remaining count, direction toggling. Provide logic. Each line includes arrow '→' and step description, then // comment. Use Decision: for condition checks.\n\nLet's create a step-by-step algorithm:\n\nStart // begin\n→ Initialize head = 1 // first number\n→ Initialize step = 1 // distance between remaining numbers\n→ Initialize remaining = n // count of numbers left\n→ Initialize leftToRight = true // current direction\n→ Decision: While remaining > 1? // loop until one left\n    Yes → If leftToRight OR remaining is odd? // update head when eliminating from left or when count odd on right\n        → head = head + step // move head forward\n    → step = step * 2 // double step because we skip every other\n    → remaining = remaining / 2 // floor division, integer division\n    → leftToRight = !leftToRight // toggle direction\n    → Decision: continue loop? // while condition automatically checks\nEnd // finish, output head\n\nBut we need to include decisions and steps line by line. The format: each line has \"虛擬碼步驟\" then space then comment. Use arrow for flow: \"→ Step 1: ...\". Use \"Decision:\" for decisions. For loops, we can represent as \"→ Decision: 仍有 >1?\" with Yes and No branches maybe. But typical representation: \"Decision:\" then branch lines. We can represent loop as while.\n\nBetter to create structure:\n\nStart\n→ 初始化 head = 1\n→ 初始化 step = 1\n→ 初始化 remaining = n\n→ 初始化 leftToRight = true\n→ Decision: remaining > 1?\n    Yes → Decision: leftToRight OR remaining odd?\n        Yes → head = head + step\n    → step = step * 2\n    → remaining = remaining / 2\n    → leftToRight = !leftToRight\n    → Decision: remaining > 1? (loop back)\n        Yes → ...\n        No → End\nEnd\n\nBut the instructions want each line after arrow and then comment. So for each line we need to produce that.\n\nLet's produce as:\n\nStart // 程式開始執行\n→ Step 1: head = 1 // 初始化第一個剩餘數字為 1\n→ Step 2: step = 1 // 初始化相鄰剩餘數字的距離\n→ Step 3: remaining = n // 剩餘數字的個數\n→ Step 4: leftToRight = true // 初始方向為從左往右\n→ Decision: remaining > 1? // 判斷是否還有多個數字需要處理\n    Yes → Decision: leftToRight OR remaining mod 2 = 1? // 如果是左到右或右到左且剩餘數字個數為奇數\n        Yes → head = head + step // 更新 head 為下一個可能的剩餘數字\n        No  → No change // 不更新 head\n    No → No change // 不更新 head\n→ Step 5: step = step * 2 // 下一輪保留數字的距離翻倍\n→ Step 6: remaining = remaining / 2 // 檢查剩餘數字個數減半（向下取整）\n→ Step 7: leftToRight = !leftToRight // 方向翻轉\n→ Decision: remaining > 1? // 若仍有多個數字，回到判斷循環\n    Yes → go back to Decision: remaining > 1? (loop)\n    No  → End // 最後只剩一個數字，結束\nEnd // 程式結束\n\nBut we need to use arrow for each step; we must use \"→\" at beginning of each line. For loops, maybe \"→\" again for each branch? We can embed indentation by spaces.\n\nSimplify: Represent loop by repeated steps until condition fails. Use \"→ Decision:\" lines and \"→\" for steps inside loop. Use indentation.\n\nBetter to produce:\n\nStart // 程式開始執行\n→ head = 1 // 初始化第一個剩餘數字\n→ step = 1 // 初始化間距\n→ remaining = n // 初始化剩餘數量\n→ leftToRight = true // 初始化方向\n→ Decision: remaining > 1? // 判斷是否還有多個數字\n    Yes → Decision: leftToRight OR (remaining mod 2 = 1)? // 判斷是否需要更新 head\n        Yes → head = head + step // 更新 head\n        No  → // 不更新 head\n    → step = step * 2 // 兩倍距離\n    → remaining = remaining / 2 // 除以 2\n    → leftToRight = !leftToRight // 方向翻轉\n    → // 回到 Decision: remaining > 1?\n        Yes → // 循環\n        No  → // 結束\nEnd // 程式結束\n\nBut we need to ensure each line has arrow then step then comment. Indentation maybe just spaces.\n\nLet's produce final answer accordingly.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ head = 1 // 初始化第一個剩餘數字為 1  \n→ step = 1 // 初始化相鄰剩餘數字之間的距離為 1  \n→ remaining = n // 初始化剩餘數字的總數  \n→ leftToRight = true // 初始方向設定為從左往右  \n\n→ Decision: remaining > 1? // 判斷是否還有多個數字需要處理  \n    Yes → Decision: leftToRight OR (remaining mod 2 = 1)? // 若是左到右或右到左且剩餘數字個數為奇數  \n        Yes → head = head + step // 更新 head 為下一個可能剩餘的數字  \n        No  → // 不需要更新 head  \n    → step = step * 2 // 下一輪保留的數字之間距離翻倍  \n    → remaining = remaining / 2 // 剩餘數字個數除以 2（向下取整）  \n    → leftToRight = !leftToRight // 方向翻轉  \n    → // 循環回到決策點  \n        Yes → // 回到 Decision: remaining > 1?  \n        No  → // 只剩一個數字，結束循環  \n\nEnd // 程式執行結束，最後的 head 即為剩下的唯一數字",
      "generated_code": "import sys\nimport re\n\ndef last_remaining(n: int) -> int:\n    \"\"\"Return the last remaining number after the elimination process.\"\"\"\n    head = 1          # first remaining number\n    step = 1          # distance between remaining numbers\n    remaining = n    # count of numbers left\n    left = True       # current direction: left to right\n\n    while remaining > 1:\n        # If we are going left-to-right, or going right-to-left but the count is odd,\n        # the head moves to the next remaining number.\n        if left or remaining % 2 == 1:\n            head += step\n        # Prepare for the next round\n        remaining //= 2\n        step *= 2\n        left = not left\n\n    return head\n\ndef main() -> None:\n    \"\"\"Read input, compute result, and print it.\"\"\"\n    data = sys.stdin.read()\n    # Extract the first integer from the input (handles \"n = 9\" or just \"9\")\n    match = re.search(r'\\d+', data)\n    if not match:\n        return\n    n = int(match.group())\n    result = last_remaining(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 9",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode456.json",
    "problem_index_in_file": 0,
    "title": "132 Pattern",
    "description_snippet": "Given an array of n integers nums, a 132 pattern is a subsequence of three integers nums[i], nums[j]...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm to detect 132 pattern. Use stack method O(n). Steps: Start, initialize empty stack, maxValue = -inf. Iterate from end to start: for each num, if num < maxValue then pattern found return true; else while stack not empty and stack.top <= num: pop and set maxValue = stack.top. Push num. End, return false.\n\nProvide virtual code lines accordingly. Use \"Start\" etc.\n\nLet's produce step lines.\n\nNeed to use arrow syntax \"→\".\n\nProbably format:\n\nStart // program start\n→ Step 1: Initialize empty stack S // 用來存儲潛在的 2\n→ Step 2: Set maxVal = -∞ // 用來追蹤最大的 3\n→ Step 3: For each element num in nums traversed from right to left // 從尾端開始\n   → Decision: If num < maxVal? // 檢查是否已符合 132\n       Yes → Step 4: Return true // 找到模式\n       No  → Decision: While S not empty and S.top <= num? // 清除不合適的 3\n           Yes → Step 5: Pop top and set maxVal = popped // 更新最大值\n           No  → Step 6: Push num onto S // 把 num 作為潛在的 2\n→ Step 7: End of loop // 完成遍歷\n→ Step 8: Return false // 未找到模式\nEnd // 程式結束\n\nBut need each line with \"虛擬碼步驟\" plus \"// 解釋\".\n\nWe should list each as separate lines. Use \"Start\", \"End\". Use arrows. Ensure each step includes explanatory comment.\n\nAlso may need indentation or arrows for nested decisions. For each decision, include nested arrows.\n\nLet's format:\n\nStart // 程式開始執行\n→ Step 1: 初始化空堆疊 S // 用於存儲可能的 nums[j]\n→ Step 2: 設定 maxVal = -∞ // 用於追蹤最大的 nums[k]\n→ Step 3: 從右往左遍歷 nums 中的每個元素 num // 逆序掃描\n   → Decision: 如果 num < maxVal? // 判斷是否符合 nums[i] < nums[k] < nums[j]\n       Yes → Step 4: 回傳 true // 找到 132 模式\n       No  → Decision: 當 S 不為空且 S.top <= num? // 移除不適合的候選 3\n           Yes → Step 5: 取出 S.top 並把它賦值給 maxVal // 更新最大 nums[k]\n           No  → Step 6: 把 num 推入堆疊 S // 將 num 作為新的潛在 nums[j]\n→ Step 7: 完成遍歷 // 所有元素已處理\n→ Step 8: 回傳 false // 未發現 132 模式\nEnd // 程式結束\n\nMake sure each line has arrow and comment. Use arrow for nested decisions. The indentation may be indicated by spaces. Provide final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空堆疊 S // 用於存儲可能的 nums[j]  \n→ Step 2: 設定 maxVal = -∞ // 用於追蹤最大的 nums[k]  \n→ Step 3: 從右往左遍歷 nums 中的每個元素 num // 逆序掃描  \n   → Decision: 如果 num < maxVal? // 判斷是否符合 nums[i] < nums[k] < nums[j]  \n       Yes → Step 4: 回傳 true // 找到 132 模式  \n       No  → Decision: 當 S 不為空且 S.top <= num? // 移除不適合的候選 3  \n           Yes → Step 5: 取出 S.top 並把它賦值給 maxVal // 更新最大 nums[k]  \n           No  → Step 6: 把 num 推入堆疊 S // 將 num 作為新的潛在 nums[j]  \n→ Step 7: 完成遍歷 // 所有元素已處理  \n→ Step 8: 回傳 false // 未發現 132 模式  \nEnd // 程式結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def find132pattern(self, nums):\n        \"\"\"判斷是否存在 132 模式，使用 O(n) 時間和 O(n) 空間的棧演算法\"\"\"\n        stack = []          # 用來儲存可能的 nums[j]\n        max_val = float('-inf')  # 追蹤最大的 nums[k]\n        for num in reversed(nums):  # 從右往左遍歷\n            if num < max_val:      # 若有 nums[i] < nums[k] < nums[j] 的情況\n                return True\n            # 把不符合條件的更小值從堆疊中移除，並更新 max_val\n            while stack and stack[-1] < num:\n                max_val = stack.pop()\n            stack.append(num)\n        return False\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取資料\n    raw = sys.stdin.read().strip()\n    if not raw:\n        sys.exit()\n\n    # 若輸入包含 'nums ='，先去除這個前綴\n    if raw.lower().startswith(\"nums\"):\n        raw = raw.split(\"=\", 1)[1].strip()\n\n    try:\n        nums = ast.literal_eval(raw)\n    except Exception:\n        # 若解析失敗，直接輸出 false\n        print(\"false\")\n        sys.exit()\n\n    solution = Solution()\n    result = solution.find132pattern(nums)\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,4]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 1,
          "input": "nums = [3,1,4,2]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "nums = [-1,3,2,0]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode6.json",
    "problem_index_in_file": 0,
    "title": "ZigZag Conversion",
    "description_snippet": "Convert a string to a zigzag pattern and read line by line....",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for converting a string to zigzag pattern and read line by line. That's the typical LeetCode Zigzag Conversion. We'll produce step-by-step virtual code. Must follow format exactly: each line \"虛擬碼步驟 // 解釋\". Include arrows, Start, End, Decision. No actual code. Provide logic steps. Should be in Traditional Chinese. Let's craft.\n\nWe need steps:\n\nStart\n→ Step: If numRows <=1 or string length <= numRows then output original string\n→ Step: Initialize array of strings for each row\n→ Step: Set currentRow = 0, directionDown = true\n→ Decision: While index < length\n    → Step: Append current character to row[currentRow]\n    → Step: If currentRow == 0 or currentRow == numRows-1 then flip directionDown\n    → Step: If directionDown then currentRow++ else currentRow--\n    → Step: index++\n→ Step: Concatenate all rows to result\nEnd\n\nAlso maybe include early exit for empty string. Provide explanation. Let's produce each line accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: 如果字串長度為 0 或 numRows <= 1? // 檢查是否需要直接回傳原字串  \n    Yes → Step: 輸出原字串 // 空字串或只一行不需要轉換  \n    No  → Step: 初始化一個包含 numRows 個空字串的陣列 rows // 為每一行準備儲存區  \n→ Step: 設定 currentRow = 0, directionDown = true // 初始行與方向  \n→ Step: index = 0 // 字元指標  \n→ Decision: 是否還有未處理字元? // 迴圈條件  \n    Yes → Step: 把字串[index] 加到 rows[currentRow] // 把當前字元加入對應行  \n    → Decision: currentRow == 0 或 currentRow == numRows-1? // 是否在頂或底  \n        Yes → Step: directionDown = !directionDown // 方向反轉  \n        No  → No → // 方向保持  \n    → Step: directionDown ? currentRow++ : currentRow-- // 移動至下一行  \n    → Step: index++ // 移動至下一個字元  \n    → Step: 回到「是否還有未處理字元？」判斷  \n    No  → Step: 初始化 result = \"\" // 結果字串  \n→ Step: 對於每一行 r in rows: result += r // 將所有行連接成最終字串  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def convert(self, s: str, numRows: int) -> str:\n        # 如果只一行或行數大於等於字串長度，直接回傳原字串\n        if numRows == 1 or numRows >= len(s):\n            return s\n        # 初始化每一行的儲存字串\n        rows = [''] * numRows\n        index, step = 0, 1  # index 為目前所在行，step 為移動方向\n        for c in s:\n            rows[index] += c\n            # 若到達頂部或底部則反轉方向\n            if index == 0:\n                step = 1\n            elif index == numRows - 1:\n                step = -1\n            index += step\n        # 合併所有行得到結果\n        return ''.join(rows)\n\ndef parse_input(data: str):\n    \"\"\"\n    解析輸入字串，支援兩種常見格式：\n    1. \"s = '文字', numRows = 整數\"\n    2. 兩行分別為字串和數字\n    \"\"\"\n    # 先嘗試匹配格式 1\n    m = re.search(r\"s\\s*=\\s*'(.*?)'\\s*,\\s*numRows\\s*=\\s*(\\d+)\", data)\n    if m:\n        return m.group(1), int(m.group(2))\n\n    # 格式 2：兩行分別給字串和數字\n    lines = data.strip().splitlines()\n    if len(lines) >= 2:\n        return lines[0].strip(), int(lines[1].strip())\n\n    # 其他簡單情況：空格分隔\n    parts = data.strip().split()\n    if len(parts) >= 2:\n        return parts[0], int(parts[1])\n\n    # 若解析失敗，回傳空字串和 0\n    return \"\", 0\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    s, numRows = parse_input(raw_input)\n    solution = Solution()\n    result = solution.convert(s, numRows)\n    # 根據範例輸出格式，使用 repr 以保留引號\n    print(repr(result))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = 'PAYPALISHIRING', numRows = 3",
          "expected_output": "'PAHNAPLSIIGYIR'",
          "success": true,
          "output": "'PAHNAPLSIIGYIR'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode140.json",
    "problem_index_in_file": 0,
    "title": "Word Break II",
    "description_snippet": "Given a string s and a dictionary of strings wordDict, add spaces in s to construct a sentence where...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for word break problem (return all sentences). Use typical DFS with memoization, or DP. Provide virtual code step-by-step with arrows and explanation. Each line: \"虛擬碼步驟 // 解釋\". Let's craft algorithm: Start, input s, wordDict, memo dict. Define function backtrack(start) returns list of sentences from start. If start==len(s) return [\"\"] (empty string). If start in memo return memo[start]. For each end from start+1 to len(s): substring = s[start:end]; if substring in wordDict: for sub_sentence in backtrack(end): combine substring + (if sub_sentence empty? else \" \"+sub_sentence). Append to results. Store in memo[start]. Return results. Then in main: sentences = backtrack(0). Return sentences. Edge cases: no segmentation return empty list.\n\nWe need to output virtual code step by step. Use arrow \"→\" for steps. Use Decision for loops and conditions. Use Start, End.\n\nWe'll produce something like:\n\nStart // 程式開始執行\n→ Step 1: 定義字典 wordSet ← wordDict // 將字典轉為集合方便查找\n→ Step 2: 初始化 memo ← 空字典 // 用於儲存子問題結果\n→ Step 3: 定義遞迴函式 Backtrack(start) // 產生從 start 開始的所有句子\n\nThen inside Backtrack:\n→ Decision: 如果 start == length(s)? // 判斷是否到結尾\n    Yes → Return [\"\"] // 結束時返回空字串列表\n    No  → Proceed\n\n→ Step 4: If start in memo? // 檢查是否已計算\n    Yes → Return memo[start]\n\n→ Step 5: results ← 空列表\n\n→ Loop end from start+1 to len(s)+1 // 生成子字串\n    → Step 6: substring ← s[start:end]\n    → Decision: substring 是否在 wordSet?\n        Yes →\n            → Step 7: child_sentences ← Backtrack(end)\n            → Loop each sub in child_sentences\n                → Step 8: 如果 sub 為空字串\n                    → Append substring 到 results\n                    → Else Append substring + \" \" + sub 到 results\n        No → Next end\n\n→ Step 9: memo[start] ← results\n→ Step 10: Return results\n\nAfter defining Backtrack:\n→ Step 11: sentences ← Backtrack(0)\n→ Step 12: Return sentences\nEnd // 程式結束\n\nMake sure each line has \"虛擬碼步驟 // 解釋\". Use \"Start\", \"End\". Use arrows.\n\nAlso include Decision: If start == len(s)? etc.\n\nAlso note we need to include \"→\" for each step. For loops and decisions we can indent.\n\nWe need to output only virtual code lines. Provide each line. Use Chinese comments. Let's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: wordSet ← wordDict // 將字典轉為集合，方便 O(1) 查找  \n→ Step 2: memo ← {} // 用於記錄已計算的子問題結果  \n→ Step 3: 定義函式 Backtrack(start) // 產生從 index start 開始的所有合法句子  \n\n  Decision: 是否已到字串結尾？ // 判斷基礎情況  \n   Yes → Return [\"\"] // 到尾端，返回空句子列表  \n   No  → Continue  \n\n  Decision: start 是否在 memo? // 檢查是否已計算過  \n   Yes → Return memo[start] // 直接返回已存結果  \n   No  → Proceed  \n\n  Step 4: results ← [] // 儲存本層的所有句子  \n\n  Loop end from start+1 to len(s)+1 // 生成所有可能的子字串  \n    Step 5: subStr ← s[start:end] // 取得子字串  \n    Decision: subStr 是否在 wordSet? // 檢查是否為字典詞  \n     Yes →  \n       Step 6: childSentences ← Backtrack(end) // 取得後續子句  \n       Loop each child in childSentences  \n         Decision: child 是否為空字串?  \n          Yes → Append subStr to results // 末尾無子句  \n          No  → Append subStr + \" \" + child to results // 連接空格  \n          End  \n       End  \n     No → 跳過該子字串  \n    End  \n\n  Step 7: memo[start] ← results // 缓存本層結果  \n  Step 8: Return results // 回傳本層所有句子  \n\nEnd // 定義完遞迴函式  \n\n→ Step 9: sentences ← Backtrack(0) // 從字串起點開始分割  \n→ Step 10: Return sentences // 返回所有可能的句子集合  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom typing import List\n\nclass Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\n        word_set = set(wordDict)\n        memo = {}\n\n        def backtrack(start: int) -> List[str]:\n            if start in memo:\n                return memo[start]\n            if start == len(s):\n                return [\"\"]\n\n            res = []\n            for end in range(start + 1, len(s) + 1):\n                word = s[start:end]\n                if word in word_set:\n                    for sub_sentence in backtrack(end):\n                        if sub_sentence:\n                            res.append(word + \" \" + sub_sentence)\n                        else:\n                            res.append(word)\n            memo[start] = res\n            return res\n\n        return backtrack(0)\n\ndef parse_input(data: str):\n    \"\"\"解析輸入，支援多種簡易格式。\"\"\"\n    data = data.strip()\n    # 嘗試匹配格式：s = 'string', wordDict = ['a','b']\n    s_match = re.search(r\"s\\s*=\\s*(['\\\"])(.*?)\\1\", data)\n    dict_match = re.search(r\"wordDict\\s*=\\s*\\[(.*?)\\]\", data, re.S)\n    if s_match and dict_match:\n        s = s_match.group(2)\n        raw = dict_match.group(1)\n        # 把 ['a', 'b'] 轉成 ['a', 'b']\n        words = re.findall(r\"(['\\\"])(.*?)\\1\", raw)\n        word_dict = [w[1] for w in words]\n        return s, word_dict\n\n    # 兩行格式：第一行是 s，第二行是 wordDict 列表\n    if \"\\n\" in data:\n        lines = data.splitlines()\n        if len(lines) >= 2:\n            s = lines[0].strip()\n            # 去除可能的引號\n            s = s.strip('\\'\"')\n            dict_line = lines[1].strip()\n            # 支援逗號或空格分隔\n            words = re.split(r\",|\\s+\", dict_line)\n            word_dict = [w.strip('\\'\"') for w in words if w]\n            return s, word_dict\n\n    # 最後嘗試直接把整行當作 s，第二個參數是逗號分隔\n    parts = data.split(',')\n    if len(parts) >= 2:\n        s = parts[0].strip()\n        word_dict = [p.strip() for p in parts[1:]]\n        return s, word_dict\n\n    # 無法解析，回傳空結果\n    return \"\", []\n\ndef main():\n    data = sys.stdin.read()\n    if not data.strip():\n        return\n    s, word_dict = parse_input(data)\n    sol = Solution()\n    result = sol.wordBreak(s, word_dict)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = 'catsanddog', wordDict = ['cat','cats','and','sand','dog']",
          "expected_output": "['cats and dog','cat sand dog']",
          "success": true,
          "output": "['cat sand dog', 'cats and dog']"
        },
        {
          "example_index": 1,
          "input": "s = 'pineapplepenapple', wordDict = ['apple','pen','applepen','pine','pineapple']",
          "expected_output": "['pine apple pen apple','pineapple pen apple','pine applepen apple']",
          "success": true,
          "output": "['pine apple pen apple', 'pine applepen apple', 'pineapple pen apple']"
        },
        {
          "example_index": 2,
          "input": "s = 'catsandog', wordDict = ['cats','dog','sand','and','cat']",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode396.json",
    "problem_index_in_file": 0,
    "title": "Rotate Function",
    "description_snippet": "You are given an integer array nums of length n.\n\nAssume arrk to be an array obtained by rotating nu...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps with explanations. Problem: compute maximum rotation function value. Known formula: F(k) can be derived iteratively: F(k+1) = F(k) + sum(nums) - n * arrk[n-1]. So algorithm: compute sum, initial F0, then iterate. Keep max. Complexity O(n). Provide steps. Need virtual code line by line with explanations, using arrow syntax. Also mention Start End, Decision. We need to output as requested: each line: virtual code step + space + // explanation. Use Start, End, Decision. Let's produce.\n\nProbably start: Start // 程式開始執行. Then Step 1: Input nums array. Then Step 2: compute sum and initial F0. Then Step 3: set max to F0. Then Step 4: iterate i from 1 to n-1. Then inside loop compute F = previousF + sum - n * nums[n-i] (since arrk[n-1] is last element of rotated array). Then update max. End loop. End // 結束. Use Decision if need to choose max. Use Decision: if F > max? Yes: set max. Else no: keep. Provide steps.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: nums ← input array // 取得長度為 n 的整數陣列\n→ Step 2: sum ← 0; F0 ← 0 // 初始化總和與 F(0)\n→ Step 3: For i from 0 to n-1:\n    → sum ← sum + nums[i] // 計算總和\n    → F0 ← F0 + i * nums[i] // 計算 F(0)\n→ Step 4: max ← F0 // 設定初始最大值為 F(0)\n→ Step 5: currentF ← F0 // 用於保存上一次的 F(k)\n→ Step 6: For k from 1 to n-1:\n    → lastIndex ← n - k // arrk 的最後一個元素在原陣列中的索引\n    → currentF ← currentF + sum - n * nums[lastIndex] // 迭代更新 F(k)\n    → Decision: currentF > max? // 比較是否為新的最大值\n        Yes → max ← currentF // 更新最大值\n        No → // 保持原 max\n→ End // 程式執行結束\n\nBut need each line with virtual code and explanation. The above has loops with indentation. Need to ensure each line is separate. Use arrow for each step. For loops: maybe represent as \"For i from 0 to n-1:\". Inside loop lines can be indented or separate. Use arrow before each sub-step.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: nums ← input array // 取得長度為 n 的整數陣列\n→ Step 2: sum ← 0 // 用於儲存 nums 所有元素之和\n→ Step 3: F0 ← 0 // 初始化旋轉函數 F(0)\n→ Step 4: For i from 0 to n-1:\n    → sum ← sum + nums[i] // 累加至總和\n    → F0 ← F0 + i * nums[i] // 計算 F(0) 的每一項\n→ Step 5: max ← F0 // 初始最大值設為 F(0)\n→ Step 6: currentF ← F0 // 目前的 F(k)，初始為 F(0)\n→ Step 7: For k from 1 to n-1:\n    → lastIdx ← n - k // arrk 的最後一個元素在原陣列中的索引\n    → currentF ← currentF + sum - n * nums[lastIdx] // 以遞推公式更新 F(k)\n    → Decision: currentF > max? // 判斷是否為新最大值\n        Yes → max ← currentF // 更新最大值\n        No  → // 保持現有 max\n→ End // 程式執行結束\n\nCheck format: each line separated. Use arrow before each step. In decision block lines need arrow? In example, they had \"Decision: 如果數字大於 0?\" then Yes → Step 2... So we follow that. So inside decision, we indent Yes → etc. But each sub-step still line. Should we include arrow for Yes? In example they did \"Yes → Step 2:\". So we should include \"Yes → max ← currentF // 更新最大值\". Similarly for No.\n\nAlso the \"For\" loops maybe represented as \"→ Step 4: For i from 0 to n-1:\" with arrow before the loop. Inside loop lines indent maybe also arrow? In example they didn't indent inside loops. They just had lines for each. We'll just use arrow before each line. So:\n\n→ Step 4: For i from 0 to n-1:\n→ sum ← sum + nums[i] // ...\n→ F0 ← F0 + i * nums[i] // ...\n\nSame for inner loop.\n\nAlso include \"Decision:\" line. Good.\n\nWe need to use [空格] before comment: \" //\".\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: nums ← input array // 取得長度為 n 的整數陣列  \n→ Step 2: sum ← 0 // 用於儲存 nums 所有元素之和  \n→ Step 3: F0 ← 0 // 初始化旋轉函數 F(0)  \n→ Step 4: For i from 0 to n-1: // 逐一遍歷陣列  \n→ sum ← sum + nums[i] // 累加至總和  \n→ F0 ← F0 + i * nums[i] // 計算 F(0) 的每一項  \n→ Step 5: max ← F0 // 初始最大值設為 F(0)  \n→ Step 6: currentF ← F0 // 目前的 F(k)，初始為 F(0)  \n→ Step 7: For k from 1 to n-1: // 依次計算 F(1)…F(n-1)  \n→ lastIdx ← n - k // arrk 的最後一個元素在原陣列中的索引  \n→ currentF ← currentF + sum - n * nums[lastIdx] // 以遞推公式更新 F(k)  \n→ Decision: currentF > max? // 判斷是否為新最大值  \n  Yes → max ← currentF // 更新最大值  \n  No  → // 保持現有 max  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def maxRotateFunction(self, A):\n        n = len(A)\n        if n == 0:\n            return 0\n        total = sum(A)\n        F = sum(i * num for i, num in enumerate(A))\n        max_val = F\n        for i in range(n - 1, 0, -1):\n            F = F + total - n * A[i]\n            if F > max_val:\n                max_val = F\n        return max_val\n\ndef parse_nums(s: str):\n    \"\"\"從輸入字串中擷取整數列表，例如 'nums = [4,3,2,6]'\"\"\"\n    match = re.search(r'\\[([^\\]]*)\\]', s)\n    if not match:\n        return []\n    inner = match.group(1).strip()\n    if not inner:\n        return []\n    return [int(x.strip()) for x in inner.split(',')]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    nums = parse_nums(data)\n    result = Solution().maxRotateFunction(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [4,3,2,6]",
          "expected_output": "26",
          "success": true,
          "output": "26"
        },
        {
          "example_index": 1,
          "input": "nums = [100]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode307.json",
    "problem_index_in_file": 0,
    "title": "Range Sum Query - Mutable",
    "description_snippet": "Given an integer array nums, handle multiple queries of the following types:\n\nUpdate the value of an...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for the described problem: implement NumArray with init, update, sumRange. Likely use segment tree or fenwick tree. Provide line-by-line virtual code steps with explanations. Must not output actual code, just steps. Use Start, Decision, End, arrows.\n\nWe need to outline algorithm: Build Fenwick tree or segment tree. Steps: class initialization, build tree, update point, query prefix sum, range sum. Also handle queries. We'll produce virtual steps as instructions rather than code.\n\nWe should include Start, End, decisions.\n\nLet's produce:\n\nStart // program start\n\n→ Step 1: 定義類 NumArray // class definition\n\n→ Step 2: 宣告 nums 與樹結構 (Fenwick tree) // data members\n\n→ Decision: 初始 nums 不是空嗎? // if nums length > 0\n\nYes → Step 3: 初始化 fenwick 樹長度 n+1 // set tree array size\n\n→ Step 4: 將 nums 逐個插入 fenwick tree // build\n\n→ Decision: 完成初始化? // finish\n\nNo → Step 5: 只設定空樹 // nothing\n\nEnd // init done\n\nSimilarly for update: Step for updating index: compute delta, update fenwick.\n\nsumRange: compute prefixSum(right)-prefixSum(left-1).\n\nWe'll produce a pseudo flowchart.\n\nLet's output each line as per format.\n\nAlso include comments. Use \"→\" arrow.\n\nWe'll produce multiple steps. Ensure each line contains virtual code + space + comment.\n\nLet's do.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類 NumArray // 建立類別以封裝陣列與樹結構  \n→ Step 2: 宣告成員變數: nums, tree, n // nums 存原始陣列，tree 為 Fenwick tree，n 為長度  \n→ Decision: nums 是否為空? // 檢查輸入陣列是否有元素  \n Yes → Step 3: 設定 n = nums.length // 計算長度  \n  → Step 4: 初始化 tree 為長度 n+1 的陣列 // Fenwick tree 使用 1-indexed  \n  → Step 5: 逐個索引 i 從 0 到 n-1  \n   → Step 6: tree.update(i, nums[i]) // 建構 Fenwick tree (使用內部 update)  \n  → Step 7: 完成初始化  \n No  → Step 8: 設定 n = 0，tree 為長度 1 的陣列 // 空陣列情況  \nEnd // 初始化完成  \n\nStart // update 方法開始執行  \n→ Step 9: 計算 delta = val - nums[index] // 需要更新的差值  \n→ Step 10: nums[index] = val // 更新原始陣列  \n→ Step 11: 進行 Fenwick tree 的點更新  \n → Step 12: i = index + 1 // 轉為 1-indexed  \n  → Decision: i <= n? // 判斷是否還在範圍內  \n   Yes → Step 13: tree[i] += delta // 累加差值  \n    → i += i & -i // 移動到下一個節點  \n    → 回到 Decision  \n   No  → Step 14: 更新完成  \nEnd // update 方法結束  \n\nStart // sumRange 方法開始執行  \n→ Step 15: 定義函式 prefixSum(idx) // 取得前 idx 個元素總和 (idx 為 0-index)  \n → Step 16: sum = 0, i = idx + 1 // 轉 1-indexed  \n  → Decision: i > 0? // 只要 i 有有效節點  \n   Yes → Step 17: sum += tree[i]  \n    → i -= i & -i // 移到父節點  \n    → 回到 Decision  \n   No  → Step 18: 回傳 sum  \n→ Step 19: leftSum = prefixSum(left-1) // 前 left-1 個元素之和  \n→ Step 20: rightSum = prefixSum(right) // 前 right 個元素之和  \n→ Step 21: 回傳 rightSum - leftSum // 範圍總和  \nEnd // sumRange 方法結束  \n\nStart // 範例查詢流程（示意）  \n→ Step 22: 創建物件 obj = new NumArray([1, 3, 5]) // 初始陣列  \n→ Step 23: 呼叫 obj.update(1, 2) // 將 index 1 的值改為 2  \n→ Step 24: result = obj.sumRange(0, 2) // 計算 0 到 2 的總和  \n→ Step 25: 輸出 result // 應為 1+2+5=8  \nEnd // 程式結束執行",
      "generated_code": "import sys\nimport ast\nimport json\n\nclass NumArray:\n    def __init__(self, nums):\n        self.n = len(nums)\n        self.nums = nums[:]\n        # Binary Indexed Tree (Fenwick Tree)\n        self.tree = [0] * (self.n + 1)\n        for i, val in enumerate(nums):\n            self._add(i + 1, val)\n\n    def _add(self, idx, delta):\n        while idx <= self.n:\n            self.tree[idx] += delta\n            idx += idx & -idx\n\n    def update(self, index, val):\n        diff = val - self.nums[index]\n        self.nums[index] = val\n        self._add(index + 1, diff)\n\n    def sumRange(self, left, right):\n        return self._prefix_sum(right + 1) - self._prefix_sum(left)\n\n    def _prefix_sum(self, idx):\n        s = 0\n        while idx > 0:\n            s += self.tree[idx]\n            idx -= idx & -idx\n        return s\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # Split the input into operations and arguments\n    # Find the first ']' that ends the operations list\n    split_idx = data.find('],')\n    if split_idx == -1:\n        sys.exit()\n    ops_str = data[:split_idx + 1]\n    args_str = data[split_idx + 2:].lstrip()\n\n    ops = ast.literal_eval(ops_str)\n    args = ast.literal_eval(args_str)\n\n    results = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"NumArray\":\n            obj = NumArray(arg[0])\n            results.append(None)\n        elif op == \"update\":\n            obj.update(arg[0], arg[1])\n            results.append(None)\n        elif op == \"sumRange\":\n            res = obj.sumRange(arg[0], arg[1])\n            results.append(res)\n        else:\n            results.append(None)\n\n    # Print results, converting None to null in JSON format\n    print(json.dumps(results))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"NumArray\", \"sumRange\", \"update\", \"sumRange\"], [[[1, 3, 5]], [0, 2], [1, 2], [0, 2]]",
          "expected_output": "[null, 9, null, 8]",
          "success": true,
          "output": "[null, 9, null, 8]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode342.json",
    "problem_index_in_file": 0,
    "title": "Power of Four",
    "description_snippet": "Given an integer n, return true if it is a power of four. Otherwise, return false.\n\nAn integer n is ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines step by step to check if n is power of four. Need to output lines with \"虛擬碼步驟 // 解釋\". Use Start, End, Decision, Yes→, No→ etc. Provide a simple algorithm: if n <= 0 return false; while n % 4 == 0: n/=4; return n==1. Alternatively bitwise: (n & (n-1))==0 and n%4==1. But step-by-step simple.\n\nWe need to produce each line with the arrow notation.\n\nLet's outline:\n\nStart\n→ Step 1: If n <= 0 → Decision: n <= 0?\n    Yes → Step 2: Return false\n    No  → Decision: n mod 4 == 0? \n        Yes → Step 3: n = n / 4\n              → Go back to Decision: n <= 0? or maybe while loop.\n\nBetter: Use loop structure: While n % 4 == 0 and n > 1.\n\nBut we need to use the arrow notation. Maybe:\n\n→ Decision: n <= 0? // check non-positive\n    Yes → Step 2: Output false\n    No  → Decision: n % 4 == 0? // check divisibility by 4\n        Yes → Step 3: n = n / 4 // reduce n\n              → Go to Decision: n <= 0? or directly back to Decision: n % 4 == 0?\n        No  → Step 4: Output false\nAt end if n == 1 output true else false.\n\nBut need to ensure loops.\n\nSimpler: Use recursion or loop variable.\n\nWe can implement a loop: While n % 4 == 0 and n > 1: n /= 4. After loop, return n == 1.\n\nBut need to express while using Decision.\n\nMaybe:\n\n→ Step 1: Set temp = n // store original\n→ Decision: temp <= 0? // negative or zero\n    Yes → Step 2: Output false\n    No  → Decision: temp % 4 == 0? // check if divisible by 4\n        Yes → Step 3: temp = temp / 4 // reduce\n              → Go to Decision: temp % 4 == 0? // repeat until no longer divisible\n        No  → Step 4: Output false\nAfter loop (when temp % 4 != 0)\n→ Decision: temp == 1? // if reduced to 1\n    Yes → Step 5: Output true\n    No  → Step 6: Output false\n\nThis is fine.\n\nNeed to keep arrow lines. Let's produce each step as separate line. Use \"→\" for next step. For decisions use \"Decision:\" line, then indent sublines.\n\nMake sure each line includes \"// 解釋\".\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: temp = n // 將輸入值存於 temp 方便後續操作  \n→ Decision: temp <= 0? // 檢查 n 是否為非正整數  \n    Yes → Step 2: Output false // 非正數不能是 4 的冪  \n    No  → Decision: temp % 4 == 0? // 檢查能否被 4 整除  \n        Yes → Step 3: temp = temp / 4 // 若能整除，將 temp 除以 4  \n              → Go to Decision: temp % 4 == 0? // 重新檢查是否還能整除 4，形成迴圈  \n        No  → Step 4: Output false // 無法被 4 整除，非 4 的冪  \n→ Decision: temp == 1? // 迴圈結束後若 temp 變為 1，則是 4 的冪  \n    Yes → Step 5: Output true // 成功找到 4 的冪  \n    No  → Step 6: Output false // 仍非 1，則不是 4 的冪  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def isPowerOfFour(self, n: int) -> bool:\n        \"\"\"Return True if n is a power of four, otherwise False.\"\"\"\n        if n <= 0:\n            return False\n        while n % 4 == 0 and n > 1:\n            n //= 4\n        return n == 1\n\nif __name__ == \"__main__\":\n    # Read all input from stdin\n    data = sys.stdin.read().strip()\n    # Extract the integer value from the input string\n    match = re.search(r\"-?\\d+\", data)\n    n = int(match.group()) if match else 0\n\n    sol = Solution()\n    result = sol.isPowerOfFour(n)\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 16",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "n = 5",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "n = 1",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode327.json",
    "problem_index_in_file": 0,
    "title": "Count of Range Sum",
    "description_snippet": "Given an integer array nums and two integers lower and upper, return the number of range sums that l...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for counting range sums in array, with lower and upper bounds. This is a classic problem: count of range sum between lower and upper inclusive. Typical solution uses prefix sums and modified merge sort (count of inversions) or Fenwick tree after coordinate compression. We need to produce virtual code step-by-step with explanation after each line. Use the format: \"虛擬碼步驟 // 解釋/說明\". Must use arrows (→, Yes →, No →). The code must be structured: Start, Decision, etc. Should not output actual code but pseudocode. We need to produce line-by-line.\n\nWe'll produce algorithm using prefix sums and divide & conquer (modified merge sort). Steps:\n\n- Start\n- Input nums, lower, upper\n- Compute prefix sums array sums length n+1\n- Call function countWhileMerge(sums, 0, n) to count\n- Return count\n\nIn countWhileMerge(sums, left, right):\n\n- If left >= right: return 0\n- mid = (left+right)/2\n- count = countWhileMerge(left, mid) + countWhileMerge(mid+1, right)\n- Use two pointers i, j to count pairs (l,r) such that sums[r] - sums[l] in [lower, upper]\n- i = left, j = left\n- for r from mid+1 to right:\n    while i <= mid and sums[r] - sums[i] < lower: i++\n    while j <= mid and sums[r] - sums[j] <= upper: j++\n    count += j - i\n- Merge sorted halves sums[left..mid] and sums[mid+1..right] into temp, then copy back\n- return count\n\nWe'll need to output lines accordingly.\n\nWe must keep line-by-line format with arrows and comments. Use Start and End. Use Decision lines where needed. For loops and conditions we can use indentation and arrows accordingly.\n\nWe need to produce explanation in Chinese (繁體). So each line's explanation in Chinese.\n\nWe need to follow \"虛擬碼步驟 [space] // 解釋/說明\". Each line must have that. Use arrow \"→\". So for lines like \"→ Step 1: ... // ...\". For decisions use \"Decision:\" and then Yes/No arrows. For loops, we can just include as \"→ Loop: ...\" with comments. Might be okay.\n\nLet's construct.\n\nWe'll structure:\n\nStart // 程式開始執行\n→ Input nums, lower, upper // 取得輸入\n→ Compute prefix sums sums // 產生前綴和陣列\n→ Initialize count = countWhileMerge(sums, 0, len(sums)-1) // 計算區間和數量\n→ Return count // 輸出結果\nEnd // 程式結束\n\nNow define countWhileMerge function:\n\nWe need to define a virtual function:\n\nCountWhileMerge(sums, left, right) // 函式名稱和參數\n\nThen inside:\n\nDecision: 如果 left >= right? // 基本情況\n    Yes → Return 0 // 只一個元素\n    No → Compute mid // 計算中點\n    → mid = (left + right) / 2 // 中點位置\n    → countLeft = CountWhileMerge(sums, left, mid) // 左半區\n    → countRight = CountWhileMerge(sums, mid+1, right) // 右半區\n    → count = countLeft + countRight // 合併結果\n\nThen counting cross pairs:\n\n→ i = left // 初始化指標 i\n→ j = left // 初始化指標 j\n→ for r from mid+1 to right // 遍歷右半區\n    → while i <= mid and sums[r] - sums[i] < lower\n        → i++ // 移動 i\n    → while j <= mid and sums[r] - sums[j] <= upper\n        → j++ // 移動 j\n    → count += j - i // 加入符合區間的對數\n\nThen merge:\n\n→ Create temp array // 暫存合併後結果\n→ p = left, q = mid+1, k = 0 // 指標\n→ while p <= mid and q <= right\n    → if sums[p] <= sums[q]\n        → temp[k] = sums[p]\n        → p++ ; k++\n    → else\n        → temp[k] = sums[q]\n        → q++ ; k++\n→ while p <= mid\n    → temp[k] = sums[p]\n    → p++ ; k++\n→ while q <= right\n    → temp[k] = sums[q]\n    → q++ ; k++\n→ Copy temp back to sums[left..right] // 完成合併\n\n→ Return count // 回傳計算結果\n\nWe need to format each step with \"→\" or \"Decision:\" lines. Use \"Yes →\" and \"No →\" accordingly. Must not produce actual code but structure.\n\nMake sure each line ends with \"// 解釋/說明\".\n\nLet's construct final answer accordingly.\n\nMake sure to include the function definition line as \"→ Function CountWhileMerge(sums, left, right) // 函式定義\". Then inside.\n\nBetter to indent using tab or spaces after arrows? Format: \"→ Step ...\". For Decision lines: \"Decision: ...\". Then indent the Yes/No branches with some spaces.\n\nLet's produce.\n\nWe'll include \"Start // 程式開始執行\". Then \"→ Input ...\" etc.\n\nAll lines should have the comment.\n\nLet's craft final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input nums, lower, upper // 取得使用者輸入的陣列與上下界  \n→ Compute prefix sums array sums // 建立前綴和，長度為 nums.length + 1  \n→ Initialize count = CountWhileMerge(sums, 0, sums.length-1) // 進行分治統計  \n→ Return count // 將結果輸出  \nEnd // 程式結束  \n\nFunction CountWhileMerge(sums, left, right) // 分治子函式  \n→ Decision: if left >= right? // 基本情況：子陣列只有一個元素  \n  Yes → Return 0 // 無可組合的區間和  \n  No  → mid = (left + right) / 2 // 找到中點位置  \n  → countLeft = CountWhileMerge(sums, left, mid) // 左半區統計  \n  → countRight = CountWhileMerge(sums, mid+1, right) // 右半區統計  \n  → count = countLeft + countRight // 合併左、右兩邊結果  \n\n  → i = left // 指標 i 從左半區開始  \n  → j = left // 指標 j 從左半區開始  \n  → for r from mid+1 to right // 遍歷右半區  \n    → while i <= mid and sums[r] - sums[i] < lower  \n      → i++ // 移動 i 直到差值 >= lower  \n    → while j <= mid and sums[r] - sums[j] <= upper  \n      → j++ // 移動 j 直到差值 > upper  \n    → count += j - i // 對於此 r，合法的 l 有 j-i 個  \n\n  → // 合併兩個已排序的半區  \n  → Create temp array // 暫存合併後的序列  \n  → p = left, q = mid+1, k = 0 // 指標初始化  \n  → while p <= mid and q <= right  \n    → if sums[p] <= sums[q]  \n      → temp[k] = sums[p] ; p++ ; k++  \n    → else  \n      → temp[k] = sums[q] ; q++ ; k++  \n  → while p <= mid  \n    → temp[k] = sums[p] ; p++ ; k++  \n  → while q <= right  \n    → temp[k] = sums[q] ; q++ ; k++  \n  → Copy temp back to sums[left..right] // 完成合併  \n\n  → Return count // 回傳統計結果  \nEnd Function // 結束分治子函式",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def countRangeSum(self, nums, lower, upper):\n        # Build prefix sums\n        prefix = [0]\n        for num in nums:\n            prefix.append(prefix[-1] + num)\n\n        def sort_and_count(lo, hi):\n            # hi is exclusive\n            if hi - lo <= 1:\n                return 0\n            mid = (lo + hi) // 2\n            count = sort_and_count(lo, mid) + sort_and_count(mid, hi)\n\n            i = j = mid\n            for left in prefix[lo:mid]:\n                while i < hi and prefix[i] - left < lower:\n                    i += 1\n                while j < hi and prefix[j] - left <= upper:\n                    j += 1\n                count += j - i\n\n            # Merge the two sorted halves\n            prefix[lo:hi] = sorted(prefix[lo:hi])\n            return count\n\n        return sort_and_count(0, len(prefix))\n\ndef parse_input(text):\n    # Extract nums array\n    nums_match = re.search(r'nums\\s*=\\s*(\\[.*?\\])', text, re.S)\n    nums = eval(nums_match.group(1)) if nums_match else []\n\n    # Extract lower\n    lower_match = re.search(r'lower\\s*=\\s*(-?\\d+)', text)\n    lower = int(lower_match.group(1)) if lower_match else 0\n\n    # Extract upper\n    upper_match = re.search(r'upper\\s*=\\s*(-?\\d+)', text)\n    upper = int(upper_match.group(1)) if upper_match else 0\n\n    return nums, lower, upper\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    nums, lower, upper = parse_input(data)\n    result = Solution().countRangeSum(nums, lower, upper)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [-2,5,-1], lower = -2, upper = 2",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [0], lower = 0, upper = 0",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode228.json",
    "problem_index_in_file": 0,
    "title": "Summary Ranges",
    "description_snippet": "You are given a sorted unique integer array nums.\n\nA range [a,b] is the set of all integers from a t...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps for the problem: summarizing ranges from sorted unique integer array. Provide pseudo-code line by line with explanations. Let's craft steps: Start, initialize result list, set start = first element, previous = first element. Iterate from second element. If current equals previous+1 continue, else end of range: add formatted range from start to previous. Then set start = current. After loop, add last range. Return result. End. Use arrow notation. Provide Decision: if current == previous+1? etc. Use \"Decision:\" lines. Provide explanation comments. Let's produce. Ensure each line has virtual code and comment. Use Start, End. Use \"→\" for next step. Use Decision lines with Yes → and No →. Also maybe \"Step\" naming. Provide for loop logic. Should be clear. Ensure no actual code. Provide explanation for each. Let's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 result 為空清單 // 用來儲存範圍字串  \n→ Step 2: 如果 nums 为空? // 判斷輸入是否為空  \n    Yes → Step 3: 回傳 result // 空輸入直接回傳空清單  \n    No  → Step 4: 設定 start = nums[0], prev = nums[0] // 開始與前一個元素設為陣列第一項  \n→ Step 5: 從 index = 1 開始迴圈直到 nums.length - 1  \n    → Decision: nums[index] == prev + 1? // 判斷是否連續  \n        Yes → Step 6: prev = nums[index] // 仍為同一段，更新 prev  \n        No  → Step 7: 添加範圍到 result // 不是連續，結束目前段  \n            → Step 8: 若 start == prev?  \n                Yes → result.add(字串化 start) // 單一數字  \n                No  → result.add(字串化 start + \"->\" + prev) // 範圍字串  \n            → Step 9: start = nums[index]; prev = nums[index] // 開始新段  \n→ Step 10: 迴圈結束後 // 已處理完所有元素  \n    → Step 11: 添加最後一段到 result  \n        → Step 12: 若 start == prev?  \n            Yes → result.add(字串化 start)  \n            No  → result.add(字串化 start + \"->\" + prev)  \n→ Step 13: 回傳 result // 回傳整理好的範圍清單  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport json\n\nclass Solution:\n    def summaryRanges(self, nums):\n        \"\"\"將已排序且唯一的整數陣列轉成最小區間列表。\"\"\"\n        if not nums:                      # 若陣列為空，直接回傳空清單\n            return []\n        res = []\n        start = end = nums[0]             # 初始區間的起點與終點\n        for n in nums[1:]:                # 逐個檢查後續元素\n            if n == end + 1:              # 與前一個連續，延長區間\n                end = n\n            else:                         # 遇到斷層，結束目前區間\n                if start == end:          # 區間僅為單一數字\n                    res.append(str(start))\n                else:\n                    res.append(f\"{start}->{end}\")   # 兩端不等，輸出區間\n                start = end = n          # 開始新的區間\n        # 最後一個區間亦需加入結果\n        if start == end:\n            res.append(str(start))\n        else:\n            res.append(f\"{start}->{end}\")\n        return res\n\ndef main():\n    # 讀取整個標準輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        print(\"[]\")\n        return\n\n    # 允許輸入類似 \"nums = [0,1,2]\" 的格式\n    if raw_input.lower().startswith(\"nums\"):\n        raw_input = raw_input.split('=', 1)[1].strip()\n\n    try:\n        nums = ast.literal_eval(raw_input)  # 安全地解析列表字串\n    except Exception:\n        # 若解析失敗，視作空陣列\n        nums = []\n\n    # 確保得到的是列表\n    if not isinstance(nums, list):\n        nums = []\n\n    # 呼叫解法並輸出 JSON 格式\n    result = Solution().summaryRanges(nums)\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [0,1,2,4,5,7]",
          "expected_output": "[\"0->2\",\"4->5\",\"7\"]",
          "success": true,
          "output": "[\"0->2\", \"4->5\", \"7\"]"
        },
        {
          "example_index": 1,
          "input": "nums = [0,2,3,4,6,8,9]",
          "expected_output": "[\"0\",\"2->4\",\"6\",\"8->9\"]",
          "success": true,
          "output": "[\"0\", \"2->4\", \"6\", \"8->9\"]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode282.json",
    "problem_index_in_file": 0,
    "title": "Expression Add Operators",
    "description_snippet": "Given a string num that contains only digits and an integer target, return all possibilities to inse...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm to generate all expressions that evaluate to target. Use DFS/backtracking. Provide line-by-line steps with explanation. Use Start, Decision, etc. Should be concise. No actual code. Just steps.\n\nWe need to output in Chinese. Use step format: Start, → Step 1, etc. Use decision. Provide explanation after //.\n\nWe'll produce like:\n\nStart // 程式開始\n→ Step 1: 定義回溯函式 DFS(index, path, evaluated, last_operand) // 進行深度優先搜索\n→ Decision: 是否已達到字串末尾? // 檢查是否處理完所有數字\n    Yes → Decision: evaluated 是否等於目標? // 檢查累計值是否符合目標\n        Yes → Step 2: 將 path 加入結果列表 // 找到合法表達式\n        No → Step 3: 直接返回 // 不是目標，不存儲\n    No → Step 4: 對於從 index 開始到字串長度的每個結束位置 i // 取子串作為下一個操作數\n        → Step 5: 取得子串 num[index:i+1] 作為 current_str // 獲取操作數字串\n        → Decision: current_str 是否以 '0' 開頭且長度 > 1? // 避免前導零\n            Yes → Step 6: 續迴下一個 i // 跳過含前導零的子串\n            No → Step 7: 轉換為整數 current_val = int(current_str) // 解析數字\n                → Decision: index 是否為 0? // 第一個操作數\n                    Yes → Step 8: 呼叫 DFS(i+1, current_str, current_val, current_val) // 開始表達式\n                    No → Step 9: 嘗試 '+': 呼叫 DFS(i+1, path+'+'+current_str, evaluated+current_val, current_val)\n                    No → Step 10: 嘗試 '-': 呼叫 DFS(i+1, path+'-'+current_str, evaluated-current_val, -current_val)\n                    No → Step 11: 嘗試 '*': 呼叫 DFS(i+1, path+'*'+current_str, evaluated - last_operand + last_operand*current_val, last_operand*current_val)\nEnd // 程式結束\n\nWe should include the explanation. Also maybe mention result list. That's fine. Ensure each line has explanation. Use arrow for decisions.\n\nLet's format accordingly. Use Start, End. Provide lines. Ensure Chinese explanation after //. Ensure each line ends with // 解釋.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義回溯函式 DFS(index, path, evaluated, last_operand) // 建立深度優先搜尋的參數  \n→ Decision: 是否已達到字串末尾? // 檢查是否處理完所有數字  \n  Yes → Decision: evaluated 是否等於目標? // 判斷累計值是否符合目標  \n    Yes → Step 2: 將 path 加入結果列表 // 找到合法表達式，加入結果  \n    No  → Step 3: 直接返回 // 不是目標值，停止此路徑  \n  No  → Step 4: 從 index 開始遍歷每個結束位置 i 以形成下一個操作數 // 產生子串  \n    → Step 5: 取得子串 num[index:i+1] 作為 current_str // 獲取下一個操作數字串  \n    → Decision: current_str 是否以 '0' 開頭且長度 > 1? // 避免前導零  \n     Yes → Step 6: 續迴下一個 i // 跳過含前導零的子串  \n     No  → Step 7: 轉換為整數 current_val = int(current_str) // 解析數字  \n      → Decision: index 是否為 0? // 判斷是否為第一個操作數  \n       Yes → Step 8: 呼叫 DFS(i+1, current_str, current_val, current_val) // 開始表達式  \n       No  → Step 9: 嘗試 '+': 呼叫 DFS(i+1, path+'+'+current_str, evaluated+current_val, current_val) // 加號操作  \n       No  → Step 10: 嘗試 '-': 呼叫 DFS(i+1, path+'-'+current_str, evaluated-current_val, -current_val) // 減號操作  \n       No  → Step 11: 嘗試 '*': 呼叫 DFS(i+1, path+'*'+current_str, evaluated - last_operand + last_operand*current_val, last_operand*current_val) // 乘法操作，調整累計與上一次操作數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport json\n\nclass Solution:\n    def addOperators(self, num: str, target: int):\n        res = []\n\n        def backtrack(index: int, path: str, value: int, last: int):\n            if index == len(num):\n                if value == target:\n                    res.append(path)\n                return\n\n            for i in range(index + 1, len(num) + 1):\n                temp = num[index:i]\n                if len(temp) > 1 and temp[0] == '0':\n                    continue\n                curr = int(temp)\n                if index == 0:\n                    backtrack(i, temp, curr, curr)\n                else:\n                    backtrack(i, path + '+' + temp, value + curr, curr)\n                    backtrack(i, path + '-' + temp, value - curr, -curr)\n                    backtrack(i, path + '*' + temp, value - last + last * curr, last * curr)\n\n        backtrack(0, '', 0, 0)\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    num_match = re.search(r'num\\s*=\\s*\"([^\"]*)\"', data)\n    target_match = re.search(r'target\\s*=\\s*(-?\\d+)', data)\n    if not num_match or not target_match:\n        print(\"[]\")\n        sys.exit()\n    num = num_match.group(1)\n    target = int(target_match.group(1))\n\n    solution = Solution()\n    result = solution.addOperators(num, target)\n    print(json.dumps(result))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num = \"123\", target = 6",
          "expected_output": "[\"1*2*3\",\"1+2+3\"]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"1*2*3\",\"1+2+3\"]'\nGot (Norm):      '[\"1+2+3\",\"1*2*3\"]'\n--- (Raw) ---\nRaw Expected: '[\"1*2*3\",\"1+2+3\"]'\nRaw Got:      '[\"1+2+3\", \"1*2*3\"]'"
        },
        {
          "example_index": 1,
          "input": "num = \"232\", target = 8",
          "expected_output": "[\"2*3+2\",\"2+3*2\"]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"2*3+2\",\"2+3*2\"]'\nGot (Norm):      '[\"2+3*2\",\"2*3+2\"]'\n--- (Raw) ---\nRaw Expected: '[\"2*3+2\",\"2+3*2\"]'\nRaw Got:      '[\"2+3*2\", \"2*3+2\"]'"
        },
        {
          "example_index": 2,
          "input": "num = \"3456237490\", target = 9191",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode167.json",
    "problem_index_in_file": 0,
    "title": "Two Sum II - Input Array Is Sorted",
    "description_snippet": "Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code for the two-sum problem using sorted array, two-pointer method, constant space. Must use virtual code steps with arrows etc. Provide each line with explanation comment after space. Need to output in Traditional Chinese. Each line \"虛擬碼步驟\" then a space then \"// 解釋/說明\". Use Start, End, Decision, etc. Provide line numbers? Not necessary. Just lines.\n\nWe should include step for initializing two pointers left=0, right=length-1. Then loop while left<right. Compute sum. Decision: if sum==target return [left+1, right+1]. If sum<target left++. If sum>target right--. End when found. End.\n\nEnsure constant space. Provide explanation.\n\nLet's produce.\n\nUse arrows: \"→\" preceding steps. For decisions use \"Decision:\" then indent.\n\nLet's craft.\n\nStart // 程式開始執行\n→ Step 1: 設定 left = 0, right = numbers.length - 1 // 左指標指向最左端，右指標指向最右端\n→ Decision: 左指標是否小於右指標? // 判斷是否仍有未檢查的組合\n    Yes → Step 2: 計算 currentSum = numbers[left] + numbers[right] // 取得目前兩個數字之和\n    → Decision: currentSum 是否等於 target? // 判斷是否找到符合條件的兩數\n        Yes → Step 3: 回傳 [left + 1, right + 1] // 加上 1 轉換為 1‑index，輸出結果\n        No  → Decision: currentSum 是否小於 target? // 若不等於，決定移動哪一個指標\n            Yes → Step 4: left = left + 1 // sum 小於目標，左指標右移尋找更大的數\n            No  → Step 5: right = right - 1 // sum 大於目標，右指標左移尋找更小的數\n    No → Continue loop // 回到 Decision: 左指標是否小於右指標? 的判斷\nEnd // 程式執行結束\n\nBut need indentation: We have nested decisions. We should use indentation spaces maybe 4 spaces per indent. Provide \"Yes →\" etc. We should include \"Continue loop\" maybe not necessary because loop goes automatically. Could use \"Go back to start of loop\".\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 left = 0, right = numbers.length - 1 // 左指標指向最左端，右指標指向最右端  \n→ Decision: 左指標是否小於右指標? // 判斷是否仍有未檢查的組合  \n    Yes → Step 2: 計算 currentSum = numbers[left] + numbers[right] // 取得目前兩個數字之和  \n    → Decision: currentSum 是否等於 target? // 判斷是否找到符合條件的兩數  \n        Yes → Step 3: 回傳 [left + 1, right + 1] // 加上 1 轉換為 1‑index，輸出結果  \n        No  → Decision: currentSum 是否小於 target? // 若不等於，決定移動哪一個指標  \n            Yes → Step 4: left = left + 1 // sum 小於目標，左指標右移尋找更大的數  \n            No  → Step 5: right = right - 1 // sum 大於目標，右指標左移尋找更小的數  \n    No → Continue loop // 回到 Decision: 左指標是否小於右指標? 的判斷  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def twoSum(self, numbers, target):\n        \"\"\"\n        Find two indices (1‑based) in a sorted list that sum to target.\n        Uses the two‑pointer technique, O(1) extra space.\n        \"\"\"\n        left, right = 0, len(numbers) - 1\n        while left < right:\n            s = numbers[left] + numbers[right]\n            if s == target:\n                return [left + 1, right + 1]\n            elif s < target:\n                left += 1\n            else:\n                right -= 1\n        # The problem guarantees exactly one solution, so this line\n        # will never be reached. It's kept for completeness.\n        return []\n\ndef parse_input(input_str: str):\n    \"\"\"\n    Parses a string like:\n        'numbers = [2,7,11,15], target = 9'\n    and returns (numbers, target).\n    \"\"\"\n    parts = input_str.split(',')\n    # Extract the list part after 'numbers ='\n    numbers_part = parts[0].split('=', 1)[1].strip()\n    numbers = ast.literal_eval(numbers_part)  # safe eval for list\n\n    # Extract the target part after 'target ='\n    target_part = parts[1].split('=', 1)[1].strip()\n    target = int(target_part)\n    return numbers, target\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    numbers, target = parse_input(raw_input)\n    solution = Solution()\n    indices = solution.twoSum(numbers, target)\n    # Output in the required format without spaces\n    print(f'[{indices[0]},{indices[1]}]')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "numbers = [2,7,11,15], target = 9",
          "expected_output": "[1,2]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpxmn9oefz.py\", line 44, in <module>\n    numbers, target = parse_input(raw_input)\n                      ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpxmn9oefz.py\", line 32, in parse_input\n    numbers = ast.literal_eval(numbers_part)  # safe eval for list\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [2\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "numbers = [2,3,4], target = 6",
          "expected_output": "[1,3]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmp5bwsfek1.py\", line 44, in <module>\n    numbers, target = parse_input(raw_input)\n                      ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp5bwsfek1.py\", line 32, in parse_input\n    numbers = ast.literal_eval(numbers_part)  # safe eval for list\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [2\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 2,
          "input": "numbers = [-1,0], target = -1",
          "expected_output": "[1,2]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpkvo607w1.py\", line 44, in <module>\n    numbers, target = parse_input(raw_input)\n                      ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpkvo607w1.py\", line 32, in parse_input\n    numbers = ast.literal_eval(numbers_part)  # safe eval for list\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [-1\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode981.json",
    "problem_index_in_file": 0,
    "title": "Time Based Key-Value Store",
    "description_snippet": "Design a time-based key-value data structure that can store multiple values for the same key at diff...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation for a time-based key-value data structure. The user gave a detailed description: TimeMap class with set and get operations.\n\nWe need to output step-by-step pseudo-code, line by line, each line includes virtual code step, a space, then comment. Use virtual arrows, decision structure.\n\nWe must not output actual code, just the structure.\n\nWe need to design the logic. So likely use a hash map from key to list of (timestamp, value) sorted. For set, append to list. For get, binary search for largest timestamp <= given.\n\nWe need to show initialization, set, get, internal binary search.\n\nThus produce pseudo-code.\n\nWe need to keep lines with indentation for decision branches.\n\nProbably:\n\nStart\n→ Step 1: Initialize map // map of key to list\n→ Step 2: Define set method\n   → Step 3: Append (timestamp, value) to list\n→ Step 3: Define get method\n   → Decision: key exists? ...\nWe need to include binary search logic.\n\nWe need to produce each line with a comment. Use \"Start\" and \"End\" tags.\n\nWe need to include arrows: \"→\" and \"Decision:\".\n\nWe need to produce a structured flow. Let's produce something like:\n\nStart // 初始化程式\n→ Step 1: 建立空的哈希表 map // 用於存儲 key -> 時間戳與值的列表\n→ Step 2: 定義 TimeMap() // 建構子\n    → Step 2.1: 初始化 map\n→ Step 3: 定義 set(key, value, timestamp) // 存儲\n    → Decision: key 是否已存在於 map? // 檢查\n        Yes → Step 3.1: 在 key 對應的列表末尾追加 (timestamp, value)\n        No  → Step 3.2: 建立新列表 [ (timestamp, value) ] 並存入 map\n→ Step 4: 定義 get(key, timestamp) // 取值\n    → Decision: key 是否存在於 map? // 若不存在直接返回 \"\"\n        Yes → Step 4.1: 取得時間列表 times = map[key]\n        No  → Step 4.2: 返回 \"\"\n    → Step 4.3: 在 times 中進行二分搜尋，尋找最大的 idx 使 times[idx].timestamp <= timestamp\n        → Decision: 是否存在符合條件的 idx? // 有則返回值，否則返回 \"\"\n            Yes → Step 4.4: 返回 times[idx].value\n            No  → Step 4.5: 返回 \"\"\nEnd // 程式結束\n\nBut we need to ensure that we adhere to the format: each line has \"虛擬碼步驟\" + space + \"// 解釋\".\n\nAlso we need to maintain arrows and indentation.\n\nIn the example, they had \"→ Step 1:\" etc. We need to include \"→\" before each step except Start and End? The sample had \"Start\" line, then \"→ Step 1: ...\" etc.\n\nAlso decisions have \"Decision:\" with indent.\n\nWe need to decide the indentation: they used four spaces before child lines in sample. They also used arrow \"Yes →\" and \"No →\" with indentation under Decision.\n\nWe need to produce a similar structure.\n\nLet's create a pseudo code:\n\nStart // 程式開始執行\n→ Step 1: 建立空的哈希表 map // map: key -> list of (timestamp, value)\n→ Step 2: 定義 TimeMap() // 建構子\n    → Step 2.1: 初始化 map // 空表已在 Step 1\n→ Step 3: 定義 set(key, value, timestamp) // 存儲方法\n    → Decision: map 是否包含 key? // 檢查是否已有此 key\n        Yes → Step 3.1: 在 map[key] 列表末尾追加 (timestamp, value) // 追加新時間戳\n        No  → Step 3.2: 建立新列表 [ (timestamp, value) ] 並存入 map[key] // 新 key\n→ Step 4: 定義 get(key, timestamp) // 取值方法\n    → Decision: map 是否包含 key? // 若無此 key\n        Yes → Step 4.1: 取得列表 times = map[key] // 時間戳和值列表\n        No  → Step 4.2: 返回 \"\" // 沒有任何值\n    → Step 4.3: 在 times 中二分搜尋最大 idx 使 times[idx].timestamp <= timestamp\n        → Decision: 是否找到 idx? // 有符合條件\n            Yes → Step 4.4: 返回 times[idx].value // 取得對應值\n            No  → Step 4.5: 返回 \"\" // 低於所有時間戳\nEnd // 程式結束執行\n\nMake sure each line ends with // 解釋.\n\nWe need to ensure arrows. For nested decisions, indent.\n\nIn the sample, they used \"Yes →\" and \"No →\" with a space after arrow.\n\nThey also used \"Decision:\" with indentation.\n\nSo format:\n\nDecision: if condition? // comment\n    Yes → Step ...\n    No  → Step ...\n\nThus we need to use that.\n\nAlso the \"Step 4.3\" line: we need to include the comment for binary search.\n\nAlso note: Step 2.1 is maybe not necessary. We can just mention that map already exists.\n\nBut we need to produce as per structure.\n\nLet's produce the final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空的哈希表 map // map: key -> list of (timestamp, value)  \n→ Step 2: 定義 TimeMap() // 建構子  \n    → Step 2.1: 初始化 map // 先前已在 Step 1 建立空表  \n→ Step 3: 定義 set(key, value, timestamp) // 存儲方法  \n    → Decision: map 是否包含 key? // 檢查 key 是否已存在  \n        Yes → Step 3.1: 在 map[key] 列表末尾追加 (timestamp, value) // 追加新時間戳和值  \n        No  → Step 3.2: 建立新列表 [ (timestamp, value) ] 並存入 map[key] // 新 key  \n→ Step 4: 定義 get(key, timestamp) // 取值方法  \n    → Decision: map 是否包含 key? // 若無此 key  \n        Yes → Step 4.1: 取得列表 times = map[key] // 取得時間戳和值列表  \n        No  → Step 4.2: 返回 \"\" // 沒有任何值  \n    → Step 4.3: 在 times 中進行二分搜尋，尋找最大的 idx 使 times[idx].timestamp <= timestamp // 二分查找  \n        → Decision: 是否找到符合條件的 idx? // 有則返回值，否則返回空串  \n            Yes → Step 4.4: 返回 times[idx].value // 取得對應值  \n            No  → Step 4.5: 返回 \"\" // 所有時間戳都大於查詢時間  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\nimport bisect\nfrom collections import defaultdict\nimport ast\n\nclass TimeMap:\n    def __init__(self):\n        # 使用 defaultdict 存儲每個 key 對應的 (timestamp, value) 列表\n        self.store = defaultdict(list)\n\n    def set(self, key: str, value: str, timestamp: int) -> None:\n        # 直接把新的 (timestamp, value) 加到列表尾端\n        self.store[key].append((timestamp, value))\n\n    def get(self, key: str, timestamp: int) -> str:\n        if key not in self.store:\n            return \"\"  # 沒有該 key 時回傳空字串\n        arr = self.store[key]\n        # bisect_right 找到第一個 > timestamp 的位置，i-1 就是 <= timestamp 的最大索引\n        i = bisect.bisect_right(arr, (timestamp, chr(127)))\n        if i == 0:\n            return \"\"  # 所有時間戳都大於查詢時間\n        return arr[i - 1][1]  # 回傳對應的 value\n\ndef main() -> None:\n    # 從 stdin 讀取整個輸入字串\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 將輸入字串包裝成 tuple，方便用 ast.literal_eval 解析\n    ops, args = ast.literal_eval('(' + data + ')')\n\n    results = []\n    tm = None\n    for op, arg in zip(ops, args):\n        if op == \"TimeMap\":\n            tm = TimeMap()\n            results.append(None)          # constructor 回傳 null\n        elif op == \"set\":\n            tm.set(arg[0], arg[1], arg[2])\n            results.append(None)          # set 回傳 null\n        elif op == \"get\":\n            res = tm.get(arg[0], arg[1])\n            results.append(res)           # get 回傳查詢結果\n        else:\n            # 若有其他不預期的指令，可忽略或自行處理\n            results.append(None)\n\n    # 使用 json.dumps 將結果轉成 JSON 格式，None 會被轉成 null\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"TimeMap\", \"set\", \"get\", \"get\", \"set\", \"get\", \"get\"], [[], [\"foo\", \"bar\", 1], [\"foo\", 1], [\"foo\", 3], [\"foo\", \"bar2\", 4], [\"foo\", 4], [\"foo\", 5]]",
          "expected_output": "[null, null, \"bar\", \"bar\", null, \"bar2\", \"bar2\"]",
          "success": true,
          "output": "[null, null, \"bar\", \"bar\", null, \"bar2\", \"bar2\"]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode31.json",
    "problem_index_in_file": 0,
    "title": "Next Permutation",
    "description_snippet": "A permutation of an array of integers is an arrangement of its members into a sequence or linear ord...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code with comments per line. Must be in Traditional Chinese. Use Start, End, Decision, arrow. Steps: Find longest non-increasing suffix; if none, reverse entire array; else find pivot; find rightmost successor > pivot; swap; reverse suffix. So produce lines.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: 設定 i 為 nums.length - 2 // 從倒數第二個元素開始向前掃描\n→ Decision: 是否存在 i 使 nums[i] < nums[i+1]? // 判斷是否有升序點\n    Yes → Step 2: 設定 pivotIndex = i // 找到分割點\n    No  → Step 3: 反轉整個 nums // 目前已是最大排列，需回到最小\n        → End // 結束\n    // 如果找到分割點則繼續以下步驟\n→ Step 4: 設定 j 為 nums.length - 1 // 從尾部開始搜尋\n→ Decision: 是否存在 j 使 nums[j] > nums[pivotIndex]? // 找到最右邊比 pivot 大的元素\n    Yes → Step 5: 交換 nums[pivotIndex] 與 nums[j] // 交換為更大的排列\n    No  → // 這種情況不會發生，因為已經找到了 pivot\n→ Step 6: 反轉從 pivotIndex+1 到結尾的子陣列 // 使尾部升序以取得最小後續排列\n→ End // 程式執行結束\n\nBut need to show arrows: For decisions we need indented. Use \"Decision: ...\" line, then indent Yes → ... No → ... etc. Also use Start, End. Use virtual code steps. Provide short explanation after each line.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 i 為 nums.length - 2 // 從倒數第二個元素開始向前掃描  \n→ Decision: 是否存在 i 使 nums[i] < nums[i+1]? // 判斷是否有升序點  \n Yes → Step 2: 設定 pivotIndex 為 i // 找到分割點  \n No  → Step 3: 反轉整個 nums // 目前已是最大排列，需回到最小  \n  → End // 結束  \n→ Step 4: 設定 j 為 nums.length - 1 // 從尾部開始搜尋  \n→ Decision: 是否存在 j 使 nums[j] > nums[pivotIndex]? // 找到最右邊比 pivot 大的元素  \n Yes → Step 5: 交換 nums[pivotIndex] 與 nums[j] // 交換為更大的排列  \n No  → // 這種情況不會發生，因為已經找到了 pivot  \n→ Step 6: 反轉從 pivotIndex+1 到結尾的子陣列 // 使尾部升序以取得最小後續排列  \n→ End // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef next_permutation(nums):\n    \"\"\"\n    修改 nums 為其下一個字典序排列。\n    若已是最大排列，則改為最小排列。\n    \"\"\"\n    n = len(nums)\n    i = n - 2\n    # 找第一個升序點\n    while i >= 0 and nums[i] >= nums[i + 1]:\n        i -= 1\n    if i >= 0:\n        # 在後面找最右邊大於 nums[i] 的數\n        j = n - 1\n        while nums[j] <= nums[i]:\n            j -= 1\n        nums[i], nums[j] = nums[j], nums[i]\n    # 將 i+1 到結尾的子序列反轉，變成升序\n    left, right = i + 1, n - 1\n    while left < right:\n        nums[left], nums[right] = nums[right], nums[left]\n        left += 1\n        right -= 1\n\nif __name__ == \"__main__\":\n    # 讀取輸入，假設形如 'nums = [1,2,3]'\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 取得中括號內的內容\n    match = re.search(r'\\[([^\\]]*)\\]', data)\n    if not match:\n        # 無法解析，直接結束\n        sys.exit(1)\n\n    nums_str = match.group(1).strip()\n    if nums_str == \"\":\n        nums = []\n    else:\n        # 用逗號分割並轉為 int\n        nums = [int(x.strip()) for x in nums_str.split(',')]\n\n    next_permutation(nums)\n    print(nums)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[1,3,2]",
          "success": true,
          "output": "[1, 3, 2]"
        },
        {
          "example_index": 1,
          "input": "nums = [3,2,1]",
          "expected_output": "[1,2,3]",
          "success": true,
          "output": "[1, 2, 3]"
        },
        {
          "example_index": 2,
          "input": "nums = [1,1,5]",
          "expected_output": "[1,5,1]",
          "success": true,
          "output": "[1, 5, 1]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode70.json",
    "problem_index_in_file": 0,
    "title": "Climbing Stairs",
    "description_snippet": "You are climbing a staircase. It takes n steps to reach the top.\n\nEach time you can either climb 1 o...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nThe user wants virtual code (structured pseudo-code) for climbing stairs problem (count ways). Should output in Traditional Chinese, step by step. We need to use Start, End, Decision, etc. Provide one step per line with explanation comment.\n\nWe need to produce algorithm: maybe dynamic programming: ways[0]=1, ways[1]=1, then for i from 2 to n: ways[i]=ways[i-1]+ways[i-2]. Finally output ways[n].\n\nWe need to output as virtual code lines with arrow. So we start: Start. Then input n. Then maybe validate n>0. Then initialize ways[0] and ways[1]. Then loop i from 2 to n. Then output ways[n]. End.\n\nMake sure each line has \"虛擬碼步驟\" + space + \"// 解釋\". Use arrow →. For Decision: if n==0? but stairs always positive? Could handle zero case: return 1.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: 讀入 n // 從使用者取得階梯總數\n→ Decision: n == 0? // 檢查是否為 0 階\n    Yes → Step 2: 輸出 1 // 0 階只有一種方式（不踏）\n    No  → Step 3: 設定 ways[0] = 1, ways[1] = 1 // 初始化基礎情況\n→ Decision: n == 1? // 檢查是否只需 1 階\n    Yes → Step 4: 輸出 1 // 只一步即可\n    No  → Step 5: for i from 2 to n // 從第 2 階開始遞推\n        → Step 6: ways[i] = ways[i-1] + ways[i-2] // 每一步可由上一或前兩階走來\n→ Step 7: 輸出 ways[n] // 最終結果\nEnd // 程式結束\n\nMake sure each line arrow properly. For for loop we can treat Step 5 as \"for i = 2 to n\". Step 6 inside loop. Use indentation maybe not needed.\n\nLet's output lines exactly.\n\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 讀入 n // 從使用者取得階梯總數\n→ Decision: n == 0? // 檢查是否為 0 階\n    Yes → Step 2: 輸出 1 // 0 階只有一種方式（不踏）\n    No  → Step 3: 設定 ways[0] = 1, ways[1] = 1 // 初始化基礎情況\n→ Decision: n == 1? // 檢查是否只需 1 階\n    Yes → Step 4: 輸出 1 // 只一步即可\n    No  → Step 5: for i from 2 to n // 從第 2 階開始遞推\n        → Step 6: ways[i] = ways[i-1] + ways[i-2] // 每一步可由上一或前兩階走來\n→ Step 7: 輸出 ways[n] // 最終結果\nEnd // 程式結束",
      "generated_code": "import sys\nimport re\n\ndef climb_stairs(n: int) -> int:\n    \"\"\"\n    計算從 0 階到 n 階的不同走法數量。\n    若 n <= 1，只有一種方式（不走或一次走完）。\n    其餘情況使用「斐波那契」遞推公式。\n    \"\"\"\n    if n <= 1:\n        return 1\n    # first 代表 n-2 的答案，second 代表 n-1 的答案\n    first, second = 1, 2\n    for _ in range(3, n + 1):\n        first, second = second, first + second\n    return second\n\ndef main() -> None:\n    \"\"\"\n    讀取標準輸入中的整數 n，計算並輸出答案。\n    支援輸入格式類似於「n = 2」或僅為「2」等多種寫法。\n    \"\"\"\n    data = sys.stdin.read()\n    match = re.search(r'-?\\d+', data)\n    if not match:\n        return\n    n = int(match.group())\n    result = climb_stairs(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 2",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "n = 3",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode372.json",
    "problem_index_in_file": 0,
    "title": "Super Pow",
    "description_snippet": "Your task is to calculate a^b mod 1337 where a is a positive integer and b is an extremely large pos...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for computing a^b mod 1337 where a is positive int and b is huge positive integer given as array of digits (likely decimal). We need to output virtual code lines with explanation. Use Start, End, Decision, arrow. Steps: read a, read array b, compute modexp using fast exponentiation with large exponent represented by array. We can use modular exponent with exponent reduction using Euler's totient? But mod 1337 is small. We could compute exponent mod φ(1337)=? 1337=7*191? Actually 1337 = 7*191. φ=1337*(1-1/7)*(1-1/191)=1337*(6/7)*(190/191)=1337*6*190/(7*191)=1337*1140/(1337)=1140. So exponent can be reduced modulo 1140 if a and modulus coprime. But a may not be coprime. So maybe use binary exponentiation with big exponent. For big exponent array, we can process digits and compute power via exponentiation by repeated squaring using exponent as big number: For each digit in array, we can compute result = (result^10 * a^digit) mod mod. Because a^b = product over digits: a^(b0*10^(n-1)+b1*10^(n-2)+...). So compute iteratively: result=1. For each digit d in array: result = (powmod(result,10,mod) * powmod(a,d,mod)) mod mod. Need powmod for small exponent up to 10. Use fast exp. So algorithm: read a, read array bDigits. Compute base = a mod mod. For each digit d in b: result = (powmod(result,10,mod) * powmod(base,d,mod)) mod mod. Return result. Steps: Start, input a, input array b, set result=1, set base=a mod mod, for each digit in b: compute temp1=powmod(result,10,mod); compute temp2=powmod(base,d,mod); result = (temp1 * temp2) mod mod. After loop, output result. End.\n\nNeed to produce virtual code lines.\n\nWe need to use virtual code syntax: Start, Decision, arrow. Use \"Step\" lines. Use loops? Maybe \"Loop\" construct.\n\nWe'll produce something like:\n\nStart // 開始\n→ Step 1: 讀取 a // 從輸入讀取基底\n→ Step 2: 讀取 b 數字陣列 // 讀入巨大的指數陣列\n→ Step 3: 設定 result ← 1 // 初始結果\n→ Step 4: 設定 base ← a mod 1337 // 取模後的基底\n→ Step 5: 循環 i 從 0 到 b.length-1 // 逐位處理指數\n    → Step 5.1: 設定 digit ← b[i] // 取得目前數位\n    → Step 5.2: 計算 temp1 ← powmod(result,10,1337) // result 的10次方模\n    → Step 5.3: 計算 temp2 ← powmod(base,digit,1337) // base 的 digit 次方模\n    → Step 5.4: result ← (temp1 * temp2) mod 1337 // 更新結果\n→ Step 6: 輸出 result // 最終答案\nEnd // 結束\n\nAlso need powmod function steps: Could include function definition.\n\nWe'll add:\n\n→ Step X: 定義 powmod(x, e, mod) // 快速指數模函式\n    → Step X.1: result ← 1\n    → Step X.2: base ← x mod mod\n    → Step X.3: Decision: e>0? \n        Yes → ...\n        No  → Return result\n    ... but might not need full details.\n\nBetter include minimal.\n\nWe need each line with comment. Use arrows.\n\nLet's produce final answer accordingly.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 讀取 a // 從輸入取得基底\n→ Step 2: 讀取 b 數字陣列 // 取得巨大的指數陣列\n→ Step 3: 設定 result ← 1 // 結果初值\n→ Step 4: 設定 base ← a mod 1337 // 先把基底取模\n→ Step 5: 定義函式 powmod(x, e, mod) // 快速指數模\n    → Step 5.1: result ← 1\n    → Step 5.2: base ← x mod mod\n    → Step 5.3: Decision: e > 0 ?\n        Yes → \n            → Step 5.3.1: Decision: e 是偶數？\n                Yes → \n                    → Step 5.3.1.1: base ← (base * base) mod mod\n                    → Step 5.3.1.2: e ← e / 2\n                    → Step 5.3.1.3: Goto Step 5.3.1\n                No  → \n                    → Step 5.3.1.4: result ← (result * base) mod mod\n                    → Step 5.3.1.5: e ← e - 1\n                    → Step 5.3.1.6: Goto Step 5.3.1\n            → Step 5.3.2: Return result\n        No  → Step 5.3.3: Return result\n→ Step 6: 循環 i 從 0 到 b.length - 1 // 逐位處理指數\n    → Step 6.1: 設定 digit ← b[i] // 取得目前數位\n    → Step 6.2: temp1 ← powmod(result, 10, 1337) // result 的 10 次方模\n    → Step 6.3: temp2 ← powmod(base, digit, 1337) // base 的 digit 次方模\n    → Step 6.4: result ← (temp1 * temp2) mod 1337 // 更新結果\n→ Step 7: 輸出 result // 回傳最終答案\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\nimport re\n\nMOD = 1337\n\ndef super_pow(a: int, b: list[int]) -> int:\n    result = 1\n    for digit in b:\n        result = (pow(result, 10, MOD) * pow(a, digit, MOD)) % MOD\n    return result\n\ndef parse_input(data: str):\n    # 解析 \"a = 2, b = [3]\" 形式的輸入\n    pattern = r'a\\s*=\\s*(\\d+),\\s*b\\s*=\\s*\\[(.*?)\\]'\n    match = re.search(pattern, data.strip())\n    if not match:\n        raise ValueError(\"Invalid input format\")\n    a = int(match.group(1))\n    b_str = match.group(2).strip()\n    if b_str:\n        b = [int(x.strip()) for x in b_str.split(',')]\n    else:\n        b = []\n    return a, b\n\ndef main():\n    data = sys.stdin.read()\n    a, b = parse_input(data)\n    result = super_pow(a, b)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "a = 2, b = [3]",
          "expected_output": "8",
          "success": true,
          "output": "8"
        },
        {
          "example_index": 1,
          "input": "a = 2, b = [1,0]",
          "expected_output": "1024",
          "success": true,
          "output": "1024"
        },
        {
          "example_index": 2,
          "input": "a = 1, b = [4,3,3,8,5,2]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode466.json",
    "problem_index_in_file": 0,
    "title": "Count The Repetitions",
    "description_snippet": "We define str = [s, n] as the string str which consists of the string s concatenated n times.\n\nFor e...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for the problem: given strings s1, s2, and repeats n1, n2, find maximum m such that str2 repeated m times is subsequence of str1 repeated n1 times. Classic Leetcode 4667? Actually it's Leetcode 4666? Known as \"Maximum number of times string can be formed\". Approach: simulate consumption of s2 over s1 iterations; track how many s2 consumed per s1 iteration. Use array to detect cycle. We'll produce step-by-step virtual code.\n\nWe produce pseudocode lines: Start, input, compute mapping of positions etc.\n\nWe need to output line by line with explanations. We'll keep arrow and decisions.\n\nLet's outline:\n\nStart\n\n→ Read s1, n1, s2, n2\n\n→ Initialize array seen = new Map to store state (index in s2, count of s2 consumed) per loop iteration of s1.\n\n→ Set index2 = 0, count2 = 0, loopCount = 0\n\n→ While loopCount < n1:\n\n    → For each character c in s1:\n\n        → If c == s2[index2], index2++ ; if index2 == s2.length, count2++, index2=0\n\n    → loopCount++\n\n    → If state (index2) seen before: found loop\n\n        → cycleLen = loopCount - seenLoopCount\n\n        → preLoopCount = seenCount2\n\n        → break loop\n\n    → else store seen[index2] = {loopCount, count2}\n\n→ After loop, if loop not found:\n\n    → totalCount = count2\n\nElse:\n\n    → Use preLoopCount and cycleCount to compute remaining loops.\n\nCompute: remainingLoops = n1 - loopCount\n\nCompute cycles = remainingLoops // cycleLen\n\ntotalCount = preLoopCount + cycles * (count2 - preLoopCount)\n\nAdd leftover loops: loopCount += cycles * cycleLen\n\nwhile loopCount < n1:\n\n    process s1 again similar, update count2\n\n→ result = totalCount // n2\n\nReturn result\n\nWe'll produce pseudocode accordingly. Ensure each line includes explanation. Use arrow \"→\".\n\nLet's craft lines. Use Decision, Yes/No branches. We'll keep concise. Use arrays of steps.\n\nWe'll produce about maybe 30 lines.\n\nLet's write.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Input s1, n1, s2, n2 // 取得輸入資料\n→ Initialize index2 = 0, count2 = 0, loop = 0 // 追蹤 s2 位置、已完成 s2 數量、迴圈次數\n→ Create map seen // 記錄每一次迴圈結束時的 s2 位置與已完成數量\n\n→ While loop < n1 // 依序處理每一次完整的 s1\n    → For each char c in s1 // 逐字掃描 s1\n        → If c == s2[index2] // 字符匹配時前進\n            → index2 = index2 + 1\n            → If index2 == length(s2) // 完成一個 s2\n                → count2 = count2 + 1\n                → index2 = 0\n    → loop = loop + 1 // 結束一個完整的 s1 迴圈\n    → Decision: 是否已在 seen 中出現相同的 index2? // 檢測循環\n        Yes →\n            → Let prevLoop = seen[index2].loop // 先前迴圈次數\n            → Let prevCount = seen[index2].count // 先前完成的 s2 數量\n            → cycleLen = loop - prevLoop // 循環長度\n            → preCount = prevCount // 循環前已完成的 s2 數量\n            → Break // 繼續後續計算\n        No →\n            → seen[index2] = {loop, count2} // 記錄此狀態\n\n→ Decision: 是否找到了循環? // 判斷是否需要進一步計算\n    Yes →\n        → remainingLoops = n1 - loop // 尚未處理的 s1 次數\n        → cycles = remainingLoops // cycleLen // 完整循環數量\n        → count2 = preCount + cycles * (count2 - preCount) // 加上所有循環完成的 s2\n        → loop = loop + cycles * cycleLen // 更新已處理的迴圈數\n    No →\n        → // 已直接處理完所有 n1 次，count2 已是最終值\n\n→ While loop < n1 // 處理剩餘未進入循環的 s1\n    → For each char c in s1\n        → If c == s2[index2]\n            → index2 = index2 + 1\n            → If index2 == length(s2)\n                → count2 = count2 + 1\n                → index2 = 0\n    → loop = loop + 1\n\n→ result = count2 // n2 // 每個 str2 重複需要 n2 次 s2\n→ Return result // 回傳最大 m\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n        if n1 == 0:\n            return 0\n\n        s1_count = 0          # 已處理的 s1 次數\n        s2_count = 0          # 已完成的 s2 數量\n        index = 0             # s2 目前匹配的位置\n        recall = {}           # 記錄每個 index 的 (s1_count, s2_count)\n\n        while s1_count < n1:\n            for ch in s1:\n                if ch == s2[index]:\n                    index += 1\n                    if index == len(s2):\n                        index = 0\n                        s2_count += 1\n            s1_count += 1\n\n            if index in recall:\n                prev_s1, prev_s2 = recall[index]\n                # 循環前的結果\n                pre_s1, pre_s2 = prev_s1, prev_s2\n                # 循環內的增量\n                loop_s1, loop_s2 = s1_count - prev_s1, s2_count - prev_s2\n                break\n            else:\n                recall[index] = (s1_count, s2_count)\n        else:\n            # 沒有找到循環，直接返回\n            return s2_count // n2\n\n        # 使用循環結果計算剩餘部分\n        remaining_s1 = n1 - pre_s1\n        loops = remaining_s1 // loop_s1\n        total_s2 = pre_s2 + loops * loop_s2\n\n        # 余下的 s1 次數\n        rest = remaining_s1 % loop_s1\n        rest_index = index\n        rest_s2 = 0\n        for _ in range(rest):\n            for ch in s1:\n                if ch == s2[rest_index]:\n                    rest_index += 1\n                    if rest_index == len(s2):\n                        rest_index = 0\n                        rest_s2 += 1\n        total_s2 += rest_s2\n\n        return total_s2 // n2\n\n\ndef parse_input(data: str):\n    \"\"\"從輸入字串中提取 s1, n1, s2, n2\"\"\"\n    s1_match = re.search(r's1\\s*=\\s*\"([^\"]*)\"', data)\n    n1_match = re.search(r'n1\\s*=\\s*(\\d+)', data)\n    s2_match = re.search(r's2\\s*=\\s*\"([^\"]*)\"', data)\n    n2_match = re.search(r'n2\\s*=\\s*(\\d+)', data)\n\n    if not (s1_match and n1_match and s2_match and n2_match):\n        raise ValueError(\"輸入格式錯誤\")\n\n    s1 = s1_match.group(1)\n    n1 = int(n1_match.group(1))\n    s2 = s2_match.group(1)\n    n2 = int(n2_match.group(1))\n    return s1, n1, s2, n2\n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    s1, n1, s2, n2 = parse_input(data)\n    result = Solution().getMaxRepetitions(s1, n1, s2, n2)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "s1 = \"acb\", n1 = 1, s2 = \"acb\", n2 = 1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode526.json",
    "problem_index_in_file": 0,
    "title": "Beautiful Arrangement",
    "description_snippet": "Suppose you have n integers labeled 1 through n. A permutation of those n integers perm (1-indexed) ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code step-by-step for counting beautiful arrangements. Use recursion/backtracking with bitmask. Provide explanation per line. Let's craft pseudocode.\n\nStart\n→ Step: initialize count=0\n→ Step: define recursive function dfs(index, usedMask)\n    // index current position 1..n\n    // usedMask bit i set if number i used\n    → Decision: if index>n then\n        Yes → count +=1 // full assignment found\n        No → return\n    → Step: for num from 1 to n\n        // iterate candidate numbers\n        → Decision: if num not used (usedMask & (1<<(num-1)))==0 and (num % index==0 or index % num==0)\n            Yes → dfs(index+1, usedMask | (1<<(num-1)))\nEnd\n\nThen final output count.\n\nLet's produce lines with virtual code arrows and explanations.\n\nWe need to include Start and End. Also indent decisions. Use \"→\" arrows. Each line ends with comment. Provide step numbers? not necessary but fine.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step: n ← input // 取得 n\n→ Step: count ← 0 // 計數初始化\n→ Step: define dfs(index, mask) // 回溯函式，index 為目前位置，mask 記錄已使用的數字\n    → Decision: if index > n? // 檢查是否已填滿所有位置\n        Yes → count ← count + 1 // 找到一個漂亮排列，累加\n        No  → return // 否則繼續尋找\n    → Step: for num from 1 to n // 遍歷所有候選數字\n        → Decision: if (mask & (1 << (num-1))) == 0 and (num % index == 0 or index % num == 0)? // 檢查 num 未被使用且滿足條件\n            Yes → dfs(index + 1, mask | (1 << (num-1))) // 進一步嘗試下個位置\n            No  → // 跳過不符合條件的數字\n→ Step: dfs(1, 0) // 從第一個位置開始搜尋，mask 為 0 表示尚未使用任何數字\n→ Step: return count // 回傳美麗排列的總數\nEnd // 程式結束\n\nMake sure each line has '→' except Start and End? Start and End no arrow. But in example, Start has no arrow, then lines with arrow. Use arrow at beginning of each line after Start.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: n ← input // 取得整數 n  \n→ Step: count ← 0 // 初始化漂亮排列計數器  \n→ Step: define dfs(index, mask) // 回溯函式，index 為目前位置，mask 追蹤已使用數字  \n    → Decision: if index > n? // 是否已填滿所有位置  \n        Yes → count ← count + 1 // 找到一個合法排列，累加計數  \n        No  → return // 否則回到上一層繼續搜尋  \n    → Step: for num from 1 to n // 嘗試所有候選數字  \n        → Decision: if (mask & (1 << (num-1))) == 0 and (num % index == 0 or index % num == 0)? // 檢查 num 未使用且滿足條件  \n            Yes → dfs(index + 1, mask | (1 << (num-1))) // 進一步嘗試下一個位置  \n            No  → // 跳過不符合條件的數字  \n→ Step: dfs(1, 0) // 從第一個位置開始搜尋，mask 為 0 表示尚未使用任何數字  \n→ Step: return count // 回傳美麗排列的總數  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def countArrangement(self, n: int) -> int:\n        def backtrack(pos: int, remaining: set[int]) -> int:\n            if pos > n:\n                return 1\n            total = 0\n            for x in list(remaining):\n                if x % pos == 0 or pos % x == 0:\n                    remaining.remove(x)\n                    total += backtrack(pos + 1, remaining)\n                    remaining.add(x)\n            return total\n\n        return backtrack(1, set(range(1, n + 1)))\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if data:\n        n = int(data)\n        solution = Solution()\n        result = solution.countArrangement(n)\n        print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "2",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode324.json",
    "problem_index_in_file": 0,
    "title": "Wiggle Sort II",
    "description_snippet": "Given an integer array nums, reorder it such that nums[0] < nums[1] > nums[2] < nums[3]....\n\nYou may...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code (pseudo code) line by line with explanation. The algorithm: given array, reorder to wiggle pattern: nums[0] < nums[1] > nums[2] < nums[3] ... Standard solution: sort array then swap adjacent pairs? Actually typical approach: iterate i from 1 to n-1, if i odd and nums[i-1] >= nums[i], swap; if i even and nums[i-1] <= nums[i], swap. That produces wiggle. Simpler: for i from 1 to len-1, if (i%2==1 && nums[i-1] >= nums[i]) or (i%2==0 && nums[i-1] <= nums[i]) then swap.\n\nThus virtual code steps: Start, Step 1: 取得陣列長度 n. Step 2: 從 i=1 到 n-1 逐步檢查。 Step 3: Decision: i 奇數? Yes -> if nums[i-1] >= nums[i] then swap. No -> i 偶數 -> if nums[i-1] <= nums[i] then swap. Step 4: 迴圈結束. End.\n\nWe need each line with \"虛擬碼步驟 // 解釋\". Use arrow \"→\". The decision lines must use indentation.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: Let n be length of nums // 取得陣列長度\n→ Step 2: For i from 1 to n-1 do // 開始迴圈\n    → Decision: i 是奇數? // 判斷索引是否為奇數\n        Yes → Decision: nums[i-1] >= nums[i]? // 若 nums[i-1] >= nums[i]，需要交換\n            Yes → Step 3: Swap(nums[i-1], nums[i]) // 交換\n            No  → // 不做任何事\n        No  → Decision: nums[i-1] <= nums[i]? // 若 i 為偶數且前小於等於後，需要交換\n            Yes → Step 4: Swap(nums[i-1], nums[i]) // 交換\n            No  → // 不做任何事\n→ End // 程式結束\n\nWe should use \"Step 3\" and \"Step 4\" or unify naming. Could use same Step 3 for swap.\n\nAlso need to include the loop bracket: after Step 2, inside the loop. Should represent indentation maybe using tabs? Provide as per example.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Let n be length of nums // 取得陣列長度  \n→ Step 2: For i from 1 to n-1 do // 開始逐個索引的檢查  \n → Decision: i 是奇數? // 判斷索引是否為奇數  \n  Yes → Decision: nums[i-1] >= nums[i]? // 奇數位置需大於前一個，若不滿足則交換  \n   Yes → Step 3: Swap(nums[i-1], nums[i]) // 交換兩個元素  \n   No  → // 不需要交換  \n  No  → Decision: nums[i-1] <= nums[i]? // 偶數位置需小於前一個，若不滿足則交換  \n   Yes → Step 4: Swap(nums[i-1], nums[i]) // 交換兩個元素  \n   No  → // 不需要交換  \n→ End // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def wiggleSort(self, nums):\n        \"\"\"\n        Rearranges nums in-place to satisfy nums[0] < nums[1] > nums[2] < nums[3] ...\n        \"\"\"\n        n = len(nums)\n        for i in range(1, n):\n            # If i is odd we need nums[i-1] < nums[i]\n            # If i is even we need nums[i-1] > nums[i]\n            if (i % 2 == 1 and nums[i-1] >= nums[i]) or \\\n               (i % 2 == 0 and nums[i-1] <= nums[i]):\n                nums[i-1], nums[i] = nums[i], nums[i-1]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # Extract the list expression after '=' or use the whole input if no '='\n    if '=' in data:\n        _, expr = data.split('=', 1)\n    else:\n        expr = data\n\n    # Safely evaluate the list\n    nums = ast.literal_eval(expr.strip())\n\n    Solution().wiggleSort(nums)\n    print(nums)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,5,1,1,6,4]",
          "expected_output": "[1,6,1,5,1,4]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[1,6,1,5,1,4]'\nGot (Norm):      '[1,5,1,6,1,4]'\n--- (Raw) ---\nRaw Expected: '[1,6,1,5,1,4]'\nRaw Got:      '[1, 5, 1, 6, 1, 4]'"
        },
        {
          "example_index": 1,
          "input": "nums = [1,3,2,2,3,1]",
          "expected_output": "[2,3,1,3,1,2]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,3,1,3,1,2]'\nGot (Norm):      '[1,3,2,3,1,2]'\n--- (Raw) ---\nRaw Expected: '[2,3,1,3,1,2]'\nRaw Got:      '[1, 3, 2, 3, 1, 2]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode32.json",
    "problem_index_in_file": 0,
    "title": "Longest Valid Parentheses",
    "description_snippet": "Given a string containing just the characters '(' and ')', return the length of the longest valid (w...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code for longest valid parentheses substring. Use DP or stack approach. Provide step by step virtual code with explanations. We'll use stack method. We'll produce steps:\n\nStart\n→ Step: 初始化 stack with -1 index // sentinel\n→ Step: 初始化 maxLen = 0\n→ Step: 迭代索引 i from 0 to len-1\n    Decision: 如果 s[i] == '('? \n        Yes → Push i onto stack\n        No  → Pop stack\n            Decision: 若 stack 空?\n                Yes → Push i // reset base\n                No  → 計算 currentLen = i - stack.top() // length between current index and new top\n                     Update maxLen\nEnd\n\nWe need virtual code lines. We'll use arrows. Provide each line and comment. Should not output actual code. Use structure Start, End, Decision.\n\nLet's craft. We'll include lines like \"Start // 程式開始執行\" etc. Provide step lines.\n\nWe should ensure each line ends with // comment. Also include indentation for Decision branches? Example earlier format: \n→ Decision: ... \n    Yes → ...\n    No → ...\n\nWe'll produce accordingly.\n\nWe'll produce something like:\n\nStart // 程式開始執行\n→ Step: 初始化變數 stack ← [-1] // 以 -1 為基準索引\n→ Step: 初始化變數 maxLen ← 0 // 儲存目前最大合法長度\n→ Step: 迭代 i 從 0 到 len(s)-1\n    Decision: s[i] == '('?\n        Yes → Step: stack.Push(i) // 遇到左括號，將索引推入堆疊\n        No  → Step: stack.Pop() // 遇到右括號，先彈出堆疊頂端\n            Decision: stack.IsEmpty()?\n                Yes → Step: stack.Push(i) // 若堆疊空，將此索引作為新的基準\n                No  → Step: currentLen ← i - stack.Peek() // 以堆疊頂端作為基準計算長度\n                     Step: maxLen ← max(maxLen, currentLen) // 更新最大長度\nEnd // 程式結束\n\nEnsure each line ends with // explanation. Need to include arrow for Decision lines. Format as example. Let's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: 初始化變數 stack ← [-1] // 以 -1 為基準索引，方便計算長度  \n→ Step: 初始化變數 maxLen ← 0 // 用來記錄目前找到的最大合法括號長度  \n→ Step: 迭代 i 從 0 到 len(s)-1  \n    Decision: s[i] == '('? // 判斷當前字符是否為左括號  \n        Yes → Step: stack.Push(i) // 左括號，將其索引推入堆疊  \n        No → Step: stack.Pop() // 右括號，先彈出堆疊頂端  \n            Decision: stack.IsEmpty()? // 彈出後堆疊是否為空？  \n                Yes → Step: stack.Push(i) // 堆疊空，將當前索引作為新的基準  \n                No → Step: currentLen ← i - stack.Peek() // 用堆疊頂端索引作為基準計算長度  \n                    Step: maxLen ← max(maxLen, currentLen) // 更新最大長度  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef longest_valid_parentheses(s: str) -> int:\n    stack = [-1]           # sentinel index for base\n    max_len = 0\n    for i, ch in enumerate(s):\n        if ch == '(':\n            stack.append(i)\n        else:  # ch == ')'\n            stack.pop()\n            if not stack:\n                stack.append(i)          # reset base\n            else:\n                max_len = max(max_len, i - stack[-1])\n    return max_len\n\ndef solve() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        print(0)\n        return\n\n    # Extract string inside quotes if present, otherwise use raw data\n    m = re.search(r'\"([^\"]*)\"', data)\n    s = m.group(1) if m else data\n    result = longest_valid_parentheses(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"(()\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "s = \")()())\"",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "s = \"\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode399.json",
    "problem_index_in_file": 0,
    "title": "Evaluate Division",
    "description_snippet": "You are given an array of variable pairs equations and an array of real numbers values, where equati...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code that solves the problem: evaluate division queries given equations and values. It's like LeetCode 399. Approach: use union-find (disjoint set) with ratio weights. Steps: build graph or union find. For each equation Ai / Bi = val, union sets. Query: if either variable unknown or not connected, answer -1. else compute ratio using weight differences. Provide virtual code line by line.\n\nWe need to follow output format: each line \"虛擬碼步驟 // 解釋\". Use arrows and Decision blocks.\n\nWe'll write something like:\n\nStart\n→ Build mapping from variable to index // assign unique index\n→ Initialize parent array size n // DSU parent\n→ Initialize weight array size n // weight to parent (Ai / parent = weight)\n→ For each equation Ai/Bi = val:\n    → Find roots of Ai, Bi\n    → If roots differ:\n        → Union rootA under rootB\n        → Set parent[rootA] = rootB\n        → Set weight[rootA] = val * weight[Bi] / weight[Ai] // formula\n→ Define function find(x) with path compression:\n    → If parent[x] != x:\n        → Original parent = parent[x]\n        → parent[x] = find(parent[x])\n        → weight[x] *= weight[original parent]\n→ For each query C/D:\n    → If C or D not in mapping: add -1\n    → Else find roots\n    → If roots differ: -1\n    → Else answer = weight[C] / weight[D]\n→ End\n\nWe need to produce each line as separate statement. Use arrows for decisions. Provide explanation. We'll include \"Decision:\" for root equality check etc.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立映射 varToIdx // 為每個變數指派唯一索引\n→ Step 2: 初始化 parent[0..n-1] ← 自己 // DSU 父節點指向自身\n→ Step 3: 初始化 weight[0..n-1] ← 1.0 // weight[x] 表示 x / parent[x] 的比例\n→ Step 4: 針對每個方程式 (Ai, Bi, val):\n    → Step 4a: 找到 Ai 的根 rootA // find(Ai)\n    → Step 4b: 找到 Bi 的根 rootB // find(Bi)\n    → Decision: rootA 與 rootB 是否相同?\n        Yes → Step 4c: 已連結，跳過\n        No  → Step 4d: 合併 rootA 到 rootB\n            → Step 4d1: parent[rootA] ← rootB\n            → Step 4d2: 計算 weight[rootA] ← val * weight[Bi] / weight[Ai] // 使 Ai/Bi = val 成立\n→ Step 5: 定義函式 find(x) // 路徑壓縮\n    → Decision: parent[x] 是否等於 x?\n        Yes → Step 5a: 回傳 x // 已是根節點\n        No  → Step 5b: 原父節點 oldParent ← parent[x]\n            → Step 5c: parent[x] ← find(oldParent) // 递归找到根\n            → Step 5d: weight[x] ← weight[x] * weight[oldParent] // 更新比例\n            → Step 5e: 回傳 parent[x]\n→ Step 6: 針對每個查詢 (Cj, Dj):\n    → Decision: Cj 或 Dj 是否不在 varToIdx?\n        Yes → Step 6a: 結果加入 -1.0 // 未定義變數\n        No  → Step 6b: 找到根 rootC ← find(Cj)\n            → Step 6c: 找到根 rootD ← find(Dj)\n            → Decision: rootC 與 rootD 是否相同?\n                Yes → Step 6d: 結果 = weight[Cj] / weight[Dj] // 計算比值\n                No  → Step 6e: 結果加入 -1.0 // 無連結\n→ End // 程式執行結束",
      "generated_code": "import sys\n\ndef calc_equation(equations, values, queries):\n    # Build variable to id mapping\n    var_to_id = {}\n    for a, b in equations:\n        if a not in var_to_id:\n            var_to_id[a] = len(var_to_id)\n        if b not in var_to_id:\n            var_to_id[b] = len(var_to_id)\n    n = len(var_to_id)\n\n    parent = list(range(n))\n    weight = [1.0] * n  # weight[x] = x / parent[x]\n\n    def find(x):\n        if parent[x] != x:\n            orig_parent = parent[x]\n            parent[x] = find(parent[x])\n            weight[x] *= weight[orig_parent]\n        return parent[x]\n\n    # Union operations\n    for (a, b), val in zip(equations, values):\n        ida, idb = var_to_id[a], var_to_id[b]\n        root_a = find(ida)\n        root_b = find(idb)\n        if root_a != root_b:\n            # Merge root_a under root_b\n            parent[root_a] = root_b\n            # weight[root_a] = (a / root_a) * (root_a / root_b)\n            # We want a / b = val => (a / root_a) * (root_a / root_b) * (root_b / b) = val\n            # => root_a / root_b = val * weight[idb] / weight[ida]\n            weight[root_a] = val * weight[idb] / weight[ida]\n\n    # Process queries\n    results = []\n    for c, d in queries:\n        if c not in var_to_id or d not in var_to_id:\n            results.append(-1.0)\n            continue\n        ida, idb = var_to_id[c], var_to_id[d]\n        root_c = find(ida)\n        root_d = find(idb)\n        if root_c != root_d:\n            results.append(-1.0)\n        else:\n            results.append(weight[ida] / weight[idb])\n    return results\n\ndef main():\n    data = sys.stdin.read()\n    local_vars = {}\n    exec(data, {}, local_vars)\n    equations = local_vars['equations']\n    values = local_vars['values']\n    queries = local_vars['queries']\n    answers = calc_equation(equations, values, queries)\n    output = '[' + ','.join(f'{ans:.5f}' for ans in answers) + ']'\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]",
          "expected_output": "[6.00000,0.50000,-1.00000,1.00000,-1.00000]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpwrpy6y15.py\", line 63, in <module>\n    main()\n  File \"/tmp/tmpwrpy6y15.py\", line 54, in main\n    exec(data, {}, local_vars)\n  File \"<string>\", line 1\n    equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1.5,2.5,5.0], queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]",
          "expected_output": "[3.75000,0.40000,5.00000,0.20000]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpt8lf2c38.py\", line 63, in <module>\n    main()\n  File \"/tmp/tmpt8lf2c38.py\", line 54, in main\n    exec(data, {}, local_vars)\n  File \"<string>\", line 1\n    equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1.5,2.5,5.0], queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 2,
          "input": "equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]",
          "expected_output": "[0.50000,2.00000,-1.00000,-1.00000]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpurj6xja4.py\", line 63, in <module>\n    main()\n  File \"/tmp/tmpurj6xja4.py\", line 54, in main\n    exec(data, {}, local_vars)\n  File \"<string>\", line 1\n    equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]\n    ^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode481.json",
    "problem_index_in_file": 0,
    "title": "Magical String",
    "description_snippet": "A magical string s consists of only '1' and '2' and obeys the following rules:\n\nThe string s is magi...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to compute the number of '1's in first n elements of the magical string s. Provide step-by-step pseudocode with comments.\n\nWe need to output each line as: \"虛擬碼步驟 // 解釋/說明\". Use Start, End, Decision, arrow.\n\nWe need to generate algorithm: generate magical string until length >= n, count ones.\n\nPseudo: Start, initialize string s=\"1\", idx=2? Actually the generation algorithm: We iterate over s with pointer i=0, next value to append count (s[i]) indicates how many times to append the opposite digit. Implementation: maintain vector or string builder. Use variable cur=2 (next digit to append), for i from 1 while len<s.size() < n: count = s[i]; append cur repeated count times; toggle cur=3-cur; i++.\n\nBut to maintain virtual code lines, we can just produce algorithm steps conceptually.\n\nLet's produce steps:\n\n1. Start\n2. Initialize magical string list: s = [\"1\"]\n3. Initialize current digit to append: cur = \"2\"\n4. Initialize pointer idx = 1 (since s[0] processed)\n5. Initialize count_ones = 1 (since first element is '1')\n6. While length of s < n:\n   6a. Get count = integer value of s[idx]\n   6b. For j from 1 to count:\n        - Append cur to s\n        - If cur == '1' then count_ones +=1\n   6c. Toggle cur between '1' and '2'\n   6d. idx +=1\n7. Return count_ones\n\nThat's it.\n\nWe must output each line as virtual code with arrow. Use decision not needed except while loop maybe.\n\nLet's format:\n\nStart // 程式開始\n→ Step 1: s = [\"1\"] // 初始化魔法字串，只包含第一個 '1'\n→ Step 2: cur = \"2\" // 下一個要附加的數字\n→ Step 3: idx = 1 // 用於遍歷 s 的指標\n→ Step 4: count_ones = 1 // 前 n 個已經有一個 '1'\n→ Decision: s 長度 < n? // 檢查是否已經生成足夠長度\n    Yes → Step 5: count = integer(s[idx]) // 取得第 idx 個元素的數值\n    Yes → Step 6: For j = 1 到 count:\n        → Step 6a: Append cur to s // 將 cur 加入字串\n        → Step 6b: If cur == \"1\" then count_ones +=1 // 若為 '1' 則累計\n    Yes → Step 7: cur = \"3\" - cur // 切換 cur 為另一個數字\n    Yes → Step 8: idx +=1 // 指標往後移動\n    Yes → 回到 Decision // 繼續循環\n    No → End // 完成\n\nBut we must avoid actual code. Just virtual steps.\n\nWe should use \"Decision:\" with arrow.\n\nAlso we need \"End\".\n\nAlso we need to keep each line separate.\n\nLet's produce each line:\n\nStart // 程式開始\n→ Step 1: s ← [\"1\"] // 初始化魔法字串\n→ Step 2: cur ← \"2\" // 下次要附加的字元\n→ Step 3: idx ← 1 // 目前讀取的指標\n→ Step 4: count_ones ← 1 // 前 n 個已包含一個 '1'\n→ Decision: s 長度 < n? // 需要繼續產生\n    Yes → Step 5: count ← int(s[idx]) // 取得指標位置的數字\n    Yes → Step 6: For j from 1 to count:\n        → Step 6.1: Append cur to s // 把 cur 加到字串\n        → Step 6.2: If cur = \"1\" then count_ones ← count_ones + 1 // 累加 1\n    Yes → Step 7: cur ← \"3\" - cur // 切換 cur 為另一個數字\n    Yes → Step 8: idx ← idx + 1 // 指標往後移動\n    Yes → 回到 Decision // 重新判斷\n    No  → End // 完成\n\nWe should also have Return count_ones before End. Let's add:\n\n→ Step 9: Return count_ones // 回傳前 n 個中 '1' 的數量\n\nBut after Return, End. So:\n\n→ Step 9: Return count_ones // 回傳結果\nEnd // 程式結束\n\nMake sure each line uses the arrow \"→\" except Start and End lines. Provide explanation.\n\nLet's craft final output accordingly.\n...done thinking.\n\nStart // 程式開始  \n→ Step 1: s ← [\"1\"] // 初始化魔法字串，先放入第一個 '1'  \n→ Step 2: cur ← \"2\" // 設定下一個要附加的字元為 '2'  \n→ Step 3: idx ← 1 // 讀取指標，從第二個位置開始  \n→ Step 4: count_ones ← 1 // 目前已經有一個 '1'（第一個字元）  \n→ Decision: s 長度 < n? // 判斷是否已生成足夠長度  \n  Yes → Step 5: count ← int(s[idx]) // 取得指標位置的數字，決定接下來要重複多少次  \n  Yes → Step 6: For j from 1 to count:  \n   → Step 6.1: Append cur to s // 把 cur 加到字串  \n   → Step 6.2: If cur = \"1\" then count_ones ← count_ones + 1 // 若為 '1' 就累加  \n  Yes → Step 7: cur ← \"3\" - cur // 由 '1' 變成 '2' 或由 '2' 變成 '1'  \n  Yes → Step 8: idx ← idx + 1 // 指標往後移動，準備讀下一個數字  \n  Yes → 回到 Decision // 重新判斷是否還需繼續  \n  No  → Step 9: Return count_ones // 結束計算，回傳前 n 個中 '1' 的個數  \nEnd // 程式結束",
      "generated_code": "import sys\nimport re\n\ndef count_ones_in_magical_string(n: int) -> int:\n    \"\"\"\n    Return the number of '1's in the first n elements of the magical string.\n    \"\"\"\n    if n == 0:\n        return 0\n    if n <= 3:\n        # The initial part of the string is \"122\"\n        return 1  # only the first element is '1'\n\n    # Build the magical string until it reaches length n\n    s = [1, 2, 2]          # initial sequence\n    head = 2               # index that determines how many times to repeat\n    num = 1                # next number to append (toggle between 1 and 2)\n\n    while len(s) < n:\n        repeat_count = s[head]\n        s.extend([num] * repeat_count)\n        num ^= 3          # toggle between 1 and 2 (1^3 = 2, 2^3 = 1)\n        head += 1\n\n    # Count only the first n elements\n    return s[:n].count(1)\n\ndef main() -> None:\n    data = sys.stdin.read()\n    # Extract the first integer value from the input\n    numbers = re.findall(r'-?\\d+', data)\n    if not numbers:\n        return\n    n = int(numbers[0])\n    result = count_ones_in_magical_string(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 6",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode200.json",
    "problem_index_in_file": 0,
    "title": "Number of Islands",
    "description_snippet": "Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return th...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for counting islands in grid. Use DFS or BFS. We'll outline steps: iterate cells, if '1', increment count, perform DFS marking visited (set to '0'). Provide steps line by line. Use Start, End, Decision etc. Provide brief explanation comments.\n\nLet's produce code steps. Use arrows etc. Each line: \"Step X: ...\" or \"Decision: ...\" with arrow to next steps.\n\nWe need to use \"虛擬碼步驟\" and comment.\n\nWe will show:\n\nStart\n\n→ For each row i in grid:\n\n    → For each col j in grid[i]:\n\n        → Decision: grid[i][j] == '1'? if yes:\n\n            → Increment island count\n\n            → Call DFS(i, j) // mark all connected lands\n\n        → No → continue\n\n→ Return island count\n\nEnd\n\nNeed to describe DFS: could be separate function:\n\nDFS(x, y):\n\n    → Decision: x < 0 or x >= m or y < 0 or y >= n or grid[x][y] == '0'? if yes → End DFS\n\n    → Else:\n\n        → Set grid[x][y] = '0' // mark visited\n\n        → DFS(x+1, y)\n\n        → DFS(x-1, y)\n\n        → DFS(x, y+1)\n\n        → DFS(x, y-1)\n\n        → End DFS\n\nBut need to fit structure. Use recursion.\n\nWe'll produce lines accordingly.\n\nLet's ensure each line ends with // 解釋/說明.\n\nWe need arrow characters for structure: Use \"→\".\n\nAlso indentation? We can indent inside loops. Use proper indentation with spaces.\n\nLet's craft.\n\nWe'll start with Start.\n\nThen Step 1: initialize island count = 0, m = rows, n = cols.\n\nThen loops.\n\nOk produce.\n\nLet's output.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 islandCount ← 0, m ← grid 行數, n ← grid 列數 // 初始化計數與尺寸  \n→ Step 2: 循環 i 從 0 到 m-1 // 遍歷每一行  \n&nbsp;&nbsp;&nbsp;→ Step 3: 循環 j 從 0 到 n-1 // 遍歷每一列  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: grid[i][j] == '1'? // 判斷是否為未被探索的陸地  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 4: islandCount ← islandCount + 1 // 新島嶼數量加一  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Call DFS(i, j) // 探索並標記整個島嶼  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 5: 繼續下一個 j // 不是陸地則直接跳過  \n→ Step 6: 回傳 islandCount // 回傳總島嶼數  \nEnd // 程式執行結束  \n\n---  \n\nDFS Function  \nStart // DFS 入口  \n→ Step 7: Decision: i < 0 或 i ≥ m 或 j < 0 或 j ≥ n 或 grid[i][j] == '0'? // 判斷邊界或已是水域  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → End // 結束此遞迴分支  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 8: grid[i][j] ← '0' // 標記為已訪問  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Call DFS(i+1, j) // 向下探索  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Call DFS(i-1, j) // 向上探索  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Call DFS(i, j+1) // 向右探索  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Call DFS(i, j-1) // 向左探索  \n→ End // DFS 完成  \nEnd // DFS 函式結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def numIslands(self, grid):\n        \"\"\"計算 2D 二元格中島嶼的數量。\"\"\"\n        if not grid:\n            return 0\n        m, n = len(grid), len(grid[0])\n\n        def dfs(i, j):\n            # 判斷邊界或已是水域\n            if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] == '0':\n                return\n            # 標記為已訪問\n            grid[i][j] = '0'\n            # 方向：下、上、右、左\n            dfs(i + 1, j)\n            dfs(i - 1, j)\n            dfs(i, j + 1)\n            dfs(i, j - 1)\n\n        count = 0\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == '1':\n                    dfs(i, j)\n                    count += 1\n        return count\n\ndef parse_grid(input_str: str):\n    \"\"\"將輸入字串轉換為 2D list。\"\"\"\n    # 找到第一個 '['，並從那裡開始解析\n    start = input_str.find('[')\n    if start == -1:\n        return []\n    grid_str = input_str[start:]\n    # ast.literal_eval 只能解析合法的 Python 表達式\n    return ast.literal_eval(grid_str)\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    grid = parse_grid(raw_input)\n    solution = Solution()\n    result = solution.numIslands(grid)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "grid = [\n  [\"1\",\"1\",\"1\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"0\",\"0\"]\n]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "grid = [\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"1\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"1\",\"1\"]\n]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode215.json",
    "problem_index_in_file": 0,
    "title": "Kth Largest Element in an Array",
    "description_snippet": "Given an integer array nums and an integer k, return the k^th largest element in the array.\n\nNote th...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step. For this problem: find kth largest element in array without sorting. Typical solution: use min-heap of size k, iterate array, push element, if size>k pop. At end heap top is kth largest. Or use quickselect.\n\nWe'll produce virtual code with steps: Start, input array nums, input k, create min-heap, iterate each element, push, if heap size>k pop. After loop, result is heap.top. Output. End.\n\nUse decision points maybe? No major decisions besides push/pop.\n\nWe must output each line with format: \"虛擬碼步驟 // 解釋\".\n\nLet's produce lines:\n\nStart\n→ Step 1: 接收 nums 與 k // 讀取輸入\n→ Step 2: 初始化最小堆 minHeap // 用於保持 k 大元素\n→ Decision: 遍歷 nums 中每個元素? // 逐個處理\n    Yes → Step 3: 將元素插入 minHeap // 將目前元素加入堆\n    Yes → Decision: minHeap 大小 > k? // 檢查堆是否超過 k\n        Yes → Step 4: 從 minHeap 移除最小值 // 保持堆大小為 k\n        No  → // 不操作\nEnd of loop\n→ Step 5: kthLargest = minHeap.top() // 堆頂即為第 k 大\n→ Step 6: 回傳 kthLargest // 輸出結果\nEnd\n\nWe should maybe include \"End\" after. Use indentation.\n\nAlso note: use virtual code arrows. Let's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 接收 nums 與 k // 讀取輸入陣列與目標位置  \n→ Step 2: 初始化最小堆 minHeap // 用於保留目前最大的 k 個元素  \n→ Decision: 遍歷 nums 中每個元素? // 逐一處理陣列元素  \n  Yes → Step 3: 將元素插入 minHeap // 把當前數字加入堆  \n  Yes → Decision: minHeap 大小 > k? // 檢查堆是否已超過 k  \n   Yes → Step 4: 從 minHeap 移除最小值 // 移除最小者，保持堆大小為 k  \n   No  → // 目前堆大小已是 k，無需調整  \nEnd of loop // 完成所有元素處理  \n→ Step 5: kthLargest = minHeap.top() // 堆頂即為第 k 大的元素  \n→ Step 6: 回傳 kthLargest // 將結果輸出  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport heapq\n\nclass Solution:\n    def findKthLargest(self, nums, k):\n        # 建立前 k 個元素的最小堆\n        heap = nums[:k]\n        heapq.heapify(heap)\n        # 逐一檢查剩餘元素\n        for num in nums[k:]:\n            if num > heap[0]:\n                heapq.heappop(heap)\n                heapq.heappush(heap, num)\n        # 堆頂即為第 k 大的元素\n        return heap[0]\n\ndef main():\n    data = sys.stdin.read()\n    # 從輸入中抓取 nums 列表和 k 整數\n    nums_match = re.search(r'nums\\s*=\\s*(\\[[^\\]]*\\])', data)\n    k_match    = re.search(r'k\\s*=\\s*(-?\\d+)', data)\n    if not nums_match or not k_match:\n        raise ValueError(\"Input format incorrect\")\n    nums = eval(nums_match.group(1))\n    k = int(k_match.group(1))\n\n    sol = Solution()\n    result = sol.findKthLargest(nums, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [3,2,1,5,6,4], k = 2",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "nums = [3,2,3,1,2,4,5,5,6], k = 4",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode318.json",
    "problem_index_in_file": 0,
    "title": "Maximum Product of Word Lengths",
    "description_snippet": "Given a string array words, return the maximum value of length(word[i]) * length(word[j]) where the ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm to find maximum product of lengths of two words without common letters. We should present steps with Start, Decision, etc. Each line: \"虛擬碼步驟 // 解釋\".\n\nWe need to use arrow syntax. For loops, maybe \"Loop words as i\" etc. For bitmask representation. But we just produce pseudo-code steps.\n\nWe need to follow formatting: each line: code step then space then comment.\n\nWe need to include arrow \"→\", \"Yes →\", \"No →\". Use indentation to show branches.\n\nLet's design:\n\nStart\n\n→ Step 1: n = length(words) // get number of words\n\n→ Step 2: For each word in words, compute bitmask of letters // O(n*L)\n\n→ Step 3: For i from 0 to n-1 // outer loop\n\n    → Step 4: For j from i+1 to n-1 // inner loop\n\n        → Decision: bitmask[i] & bitmask[j] == 0? // check no common letters\n\n            Yes → Step 5: product = length(words[i]) * length(words[j]) // compute product\n\n            Yes → Step 6: Update maxProduct if product greater // track maximum\n\n            No → Step 7: Continue // skip pair\n\n→ End // return maxProduct\n\nAlso need variable initialization for maxProduct = 0.\n\nWe need to include steps to compute bitmask: maybe \"ComputeMask(word)\".\n\nThus produce lines with arrow and comment.\n\nLet's output:\n\nStart // 程式開始執行\n→ Step 1: n ← length(words) // 取得字串陣列長度\n→ Step 2: maxProduct ← 0 // 初始化最大值\n→ Step 3: bitMasks ← array of size n // 用來儲存每個字串的字母位元掩碼\n→ Step 4: For idx from 0 to n-1 // 先計算每個字串的掩碼\n    → Step 5: bitMasks[idx] ← 0 // 初始化掩碼\n    → Step 6: For each char c in words[idx]\n        → Step 7: bitMasks[idx] ← bitMasks[idx] OR (1 << (ord(c)-ord('a'))) // 設定對應位元\n→ Step 8: For i from 0 to n-1 // 外層迴圈\n    → Step 9: For j from i+1 to n-1 // 內層迴圈\n        → Decision: (bitMasks[i] & bitMasks[j]) == 0? // 檢查是否無共同字母\n            Yes → Step 10: product ← length(words[i]) * length(words[j]) // 計算長度乘積\n            Yes → Step 11: If product > maxProduct Then maxProduct ← product // 更新最大值\n            No  → Step 12: Continue // 若有共同字母則跳過\n→ End // 回傳 maxProduct\n\nCheck format: each line ends with // comment. Indentation maybe just spaces. Should use \"→\" arrow for steps; \"Decision:\" line uses \"Decision:\".\n\nMake sure we have \"Yes →\" and \"No →\" for branch inside decision.\n\nNeed to ensure each step line includes arrow \"→\". For decision line: \"Decision: ...?\" then indentation.\n\nWe also need \"Start\" and \"End\".\n\nWe also must include \"Step\" number maybe but not necessary. The example uses \"Step 1\". We can follow.\n\nOk produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← length(words) // 取得字串陣列長度  \n→ Step 2: maxProduct ← 0 // 初始化最大值  \n→ Step 3: bitMasks ← array of size n // 用來儲存每個字串的字母位元掩碼  \n\n→ Step 4: For idx from 0 to n-1 // 先計算每個字串的掩碼  \n → Step 5: bitMasks[idx] ← 0 // 初始化掩碼  \n → Step 6: For each char c in words[idx]  \n  → Step 7: bitMasks[idx] ← bitMasks[idx] OR (1 << (ord(c)-ord('a'))) // 設定對應位元  \n\n→ Step 8: For i from 0 to n-1 // 外層迴圈  \n → Step 9: For j from i+1 to n-1 // 內層迴圈  \n  → Decision: (bitMasks[i] & bitMasks[j]) == 0? // 檢查是否無共同字母  \n   Yes → Step 10: product ← length(words[i]) * length(words[j]) // 計算長度乘積  \n   Yes → Step 11: If product > maxProduct Then maxProduct ← product // 更新最大值  \n   No  → Step 12: Continue // 若有共同字母則跳過  \n\nEnd // 回傳 maxProduct",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def maxProduct(self, words):\n        n = len(words)\n        masks = [0] * n\n        # Build bitmask for each word\n        for i, word in enumerate(words):\n            mask = 0\n            for ch in word:\n                mask |= 1 << (ord(ch) - ord('a'))\n            masks[i] = mask\n\n        max_prod = 0\n        # Check all pairs\n        for i in range(n):\n            for j in range(i + 1, n):\n                if masks[i] & masks[j] == 0:\n                    prod = len(words[i]) * len(words[j])\n                    if prod > max_prod:\n                        max_prod = prod\n        return max_prod\n\ndef main():\n    # Read entire stdin\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n    # Remove possible prefix like \"words = \"\n    if raw.lower().startswith(\"words\"):\n        raw = raw.split('=', 1)[1].strip()\n    # Safely evaluate the list\n    try:\n        words = ast.literal_eval(raw)\n    except Exception:\n        # Fallback: split by commas if eval fails\n        words = [w.strip().strip('\"\\'') for w in raw.strip('[]').split(',')]\n    # Compute result\n    solution = Solution()\n    result = solution.maxProduct(words)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "words = [\"abcw\",\"baz\",\"foo\",\"bar\",\"xtfn\",\"abcdef\"]",
          "expected_output": "16",
          "success": true,
          "output": "16"
        },
        {
          "example_index": 1,
          "input": "words = [\"a\",\"ab\",\"abc\",\"d\",\"cd\",\"bcd\",\"abcd\"]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "words = [\"a\",\"aa\",\"aaa\",\"aaaa\"]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode66.json",
    "problem_index_in_file": 0,
    "title": "Plus One",
    "description_snippet": "You are given a large integer represented as an integer array digits, where each digits[i] is the it...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations. Use Start, End, Decision. Each line: \"Step X: ...\" plus explanation comment. Must not output actual code. Just virtual steps.\n\nWe need algorithm: Add one to digits array. Start from last index, carry = 1. Loop while carry and i>=0. digit[i] += carry; if digit[i]==10: digit[i]=0; carry=1; else carry=0. After loop, if carry still 1, insert 1 at front. Return digits.\n\nWe'll produce steps: Start, Step 1: Initialize i to length-1 // last index. Step 2: Initialize carry = 1 // the one to add. Step 3: Decision: While i>=0 and carry=1? Actually we need loop. But can express Decision: if i>=0 and carry=1? Yes -> Step 4: Add carry to digits[i]. Then check if digits[i]==10. Decision: if digits[i]==10? Yes -> set digits[i]=0, carry=1, i--. No -> carry=0, i--. Continue. After loop: Decision: if carry==1? Yes -> Insert 1 at front. End.\n\nWe must use \"→\" arrows.\n\nLet's craft. Use indentation for nested decisions? In sample they use indentation for nested decision blocks. We'll follow that.\n\nEach step: \"→ Step X: ...\" etc.\n\nWe'll keep step numbering sequential. Let's produce.\n\nRemember to output only virtual steps and explanations.\n\nLet's craft:\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 i 為 digits 的最後一個索引 // 以便從最低位開始加一  \n→ Step 2: 初始化 carry 為 1 // 代表需要進位的「+1」  \n→ Decision: i >= 0 且 carry == 1? // 判斷是否還有位數需要處理  \n    Yes → Step 3: digits[i] ← digits[i] + carry // 將進位加到目前位數  \n    → Decision: digits[i] == 10? // 判斷該位是否溢位  \n        Yes → Step 4: digits[i] ← 0 // 溢位時把該位設為 0  \n        → Step 5: carry ← 1 // 仍需進位  \n        No  → Step 6: carry ← 0 // 無需進位，結束加法  \n    → Step 7: i ← i - 1 // 進行下一位  \n    → 回到 Decision: i >= 0 且 carry == 1?  \n→ Decision: carry == 1? // 迴圈結束後檢查是否還有進位  \n    Yes → Step 8: 在 digits 前面插入 1 // 新增最高位進位  \nEnd // 程式執行結束，返回更新後的 digits 數組",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def plusOne(self, digits):\n        \"\"\"Increment the large integer represented by the digit list.\"\"\"\n        # Start from the least significant digit\n        for i in range(len(digits) - 1, -1, -1):\n            if digits[i] < 9:\n                digits[i] += 1          # no carry needed, finish\n                return digits\n            digits[i] = 0                # set to 0 and carry to next digit\n        # If we finished the loop, we had an overflow (e.g., 999 -> 1000)\n        return [1] + digits\n\ndef parse_digits(input_text):\n    \"\"\"Parse the input string to extract the digits list.\"\"\"\n    # Find the part after 'digits ='\n    match = re.search(r'digits\\s*=\\s*(\\[[^\\]]*\\])', input_text)\n    if match:\n        # Use eval to convert string list to actual list of ints\n        return eval(match.group(1))\n    return []\n\nif __name__ == \"__main__\":\n    # Read entire stdin\n    raw_input = sys.stdin.read().strip()\n    digits = parse_digits(raw_input)\n\n    # If no digits found, just exit\n    if not digits:\n        sys.exit(0)\n\n    result = Solution().plusOne(digits)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "digits = [1,2,3]",
          "expected_output": "[1,2,4]",
          "success": true,
          "output": "[1, 2, 4]"
        },
        {
          "example_index": 1,
          "input": "digits = [4,3,2,1]",
          "expected_output": "[4,3,2,2]",
          "success": true,
          "output": "[4, 3, 2, 2]"
        },
        {
          "example_index": 2,
          "input": "digits = [9]",
          "expected_output": "[1,0]",
          "success": true,
          "output": "[1, 0]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode472.json",
    "problem_index_in_file": 0,
    "title": "Concatenated Words",
    "description_snippet": "Given an array of strings words (without duplicates), return all the concatenated words in the given...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for problem: Given array of strings words without duplicates, return all concatenated words in the list. Need virtual code steps and short explanations per line.\n\nWe'll create algorithm: sort words by length, use a set for words seen, for each word check if can be segmented into two or more words using DP or recursion with memo. Add to result if true. Then add word to set for future use. Use DFS with memo. Or DP.\n\nWe need step-by-step pseudo code.\n\nLet's outline:\n\nStart\n\n→ Initialize result list // store concatenated words\n\n→ Initialize wordSet // empty set\n\n→ Sort words by length ascending // ensures shorter words processed first\n\n→ For each word in words:\n\n    → If canForm(word, wordSet): // check segmentation\n\n        → Append word to result\n\n    → Add word to wordSet\n\n→ Return result\n\nDefine canForm(word, wordSet):\n\n    → Initialize memo dict // for substring results\n\n    → Return helper(0) where helper(index) returns bool\n\n    → helper(i):\n\n        → If i == len(word): return true\n\n        → If i in memo: return memo[i]\n\n        → For j from i+1 to len(word):\n\n            → sub = word[i:j]\n\n            → If sub in wordSet:\n\n                → If helper(j):\n\n                    → memo[i] = true; return true\n\n        → memo[i] = false; return false\n\nBut we need to avoid using word itself in wordSet; since we only added previous words, it's fine.\n\nAlternatively use DP.\n\nWe'll produce lines with arrows and comments. Provide each line.\n\nLet's write pseudo code with steps:\n\nStart // Program start\n\n→ result = [] // list to hold concatenated words\n\n→ wordSet = {} // set for fast lookup of shorter words\n\n→ wordsSorted = sort(words by length ascending) // process shorter words first\n\n→ For each w in wordsSorted: // iterate through sorted words\n\n    → If canForm(w, wordSet): // check if w can be built from shorter words\n\n        → result.append(w) // w is a concatenated word\n\n    → wordSet.add(w) // add w for future checks\n\n→ Return result // finished\n\nNow define canForm function:\n\n→ Function canForm(word, wordSet): // returns True if word can be segmented into >=2 words from wordSet\n\n    → memo = {} // memoization for recursion\n\n    → Return dfs(0) // start from index 0\n\n→ Function dfs(index): // recursive helper\n\n    → If index == len(word): // reached end of word\n\n        → Return True // valid segmentation\n\n    → If index in memo: // previously computed\n\n        → Return memo[index]\n\n    → For end in range(index+1, len(word)+1): // iterate over possible end positions\n\n        → sub = word[index:end] // substring\n\n        → If sub in wordSet: // substring exists as a shorter word\n\n            → If dfs(end): // continue segmentation from end\n\n                → memo[index] = True\n\n                → Return True\n\n    → memo[index] = False // no valid segmentation found\n\n    → Return False\n\nNow we must produce each line as a \"虛擬碼步驟\" with arrow or structure. Use \"Start\" \"End\" \"Decision:\" etc.\n\nLet's produce:\n\nStart // 程式開始執行\n\n→ result = [] // 儲存所有拼接詞\n\n→ wordSet = {} // 用於快速查詢已處理的較短詞\n\n→ wordsSorted = sort(words by length ascending) // 先處理較短的詞\n\n→ For each w in wordsSorted: // 遍歷所有詞\n\n    → Decision: canForm(w, wordSet)? // 判斷 w 是否能由已知詞組合\n\n        Yes → result.append(w) // 若能，加入結果\n\n        No → // 什麼都不做\n\n    → wordSet.add(w) // 把 w 加入已知詞集合，供後續詞使用\n\n→ End // 主要流程結束\n\n// 輔助函式\n\n→ Function canForm(word, wordSet): // 判斷是否可拼接\n\n    → memo = {} // 記錄已計算的子問題\n\n    → Return dfs(0) // 從起始索引開始分割\n\n→ Function dfs(index): // 以 index 為起點遞迴分割\n\n    → Decision: index == len(word)? // 是否已到字串結尾\n\n        Yes → Return True // 成功分割\n\n        No → // 進一步嘗試\n\n    → Decision: index in memo? // 是否已計算過\n\n        Yes → Return memo[index] // 直接回傳結果\n\n        No →\n\n    → For end in range(index+1, len(word)+1): // 遍歷可能的結束位置\n\n        → sub = word[index:end] // 取得子字串\n\n        → Decision: sub in wordSet? // 子字串是否是已知詞\n\n            Yes → Decision: dfs(end)? // 若後續能分割\n\n                Yes → memo[index] = True // 記錄成功\n\n                    → Return True\n\n                No → // 嘗試下一個 end\n\n            No → // 嘗試下一個 end\n\n    → memo[index] = False // 無法分割\n\n    → Return False // 失敗\n\nBut the specification says: each line must contain virtual code step + space + // explanation. Use arrow or structure. Use `Start`, `End`, `Decision:`. The pseudo code must be line by line. So we need to format accordingly.\n\nWe need to use proper indentation maybe with spaces.\n\nLet's produce:\n\nStart // 程式開始執行\n→ result = [] // 儲存所有拼接詞\n→ wordSet = {} // 以集合儲存已處理的較短詞\n→ wordsSorted = sort(words by length ascending) // 先處理較短的詞\n→ For each w in wordsSorted: // 遍歷所有詞\n    → Decision: canForm(w, wordSet)? // 判斷 w 是否能由已知詞組合\n        Yes → result.append(w) // 若能，加入結果\n        No → // 什麼都不做\n    → wordSet.add(w) // 把 w 加入已知詞集合，供後續詞使用\nEnd // 主要流程結束\n\n// 定義輔助函式 canForm\n→ Function canForm(word, wordSet): // 判斷是否可拼接\n    → memo = {} // 記錄已計算的子問題\n    → Return dfs(0) // 從起始索引開始分割\n\n→ Function dfs(index): // 以 index 為起點遞迴分割\n    → Decision: index == len(word)? // 是否已到字串結尾\n        Yes → Return True // 成功分割\n        No → // 進一步嘗試\n    → Decision: index in memo? // 是否已計算過\n        Yes → Return memo[index] // 直接回傳結果\n        No →\n    → For end in range(index+1, len(word)+1): // 遍歷可能的結束位置\n        → sub = word[index:end] // 取得子字串\n        → Decision: sub in wordSet? // 子字串是否是已知詞\n            Yes → Decision: dfs(end)? // 若後續能分割\n                Yes → memo[index] = True // 記錄成功\n                    → Return True\n                No → // 嘗試下一個 end\n            No → // 嘗試下一個 end\n    → memo[index] = False // 無法分割\n    → Return False // 失敗\n\nNeed to ensure each line ends with // explanation. Provide explanation for each line. We must ensure no extra commentary. Use arrow.\n\nBut the guidelines: \"每行必須包含：虛擬碼步驟 + [空格] + // 解釋/說明\". So each line must have code + space + // + explanation. So we need to put explanation after code, separated by space then //.\n\nOur lines above already do that. But we need to ensure that lines with indentation also count. We might need to indent with spaces. Provide \"→\" before each line except Start and End? We can maintain consistent. Eg:\n\nStart // 程式開始執行\n→ result = [] // 儲存所有拼接詞\n...\n\nBut inside for loop we need indentation. We can still use \"→\" at start of each line but use indentation spaces after \"→\" for nested. But guidelines mention use arrow for structure but no requirement for indentation. We can indent with spaces for readability.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ result = [] // 儲存所有拼接詞\n→ wordSet = {} // 以集合儲存已處理的較短詞\n→ wordsSorted = sort(words by length ascending) // 先處理較短的詞\n→ For each w in wordsSorted: // 遍歷所有詞\n    → Decision: canForm(w, wordSet)? // 判斷 w 是否能由已知詞組合\n        Yes → result.append(w) // 若能，加入結果\n        No → // 什麼都不做\n    → wordSet.add(w) // 把 w 加入已知詞集合，供後續詞使用\nEnd // 主要流程結束\n\n// 定義輔助函式 canForm\n→ Function canForm(word, wordSet): // 判斷是否可拼接\n    → memo = {} // 記錄已計算的子問題\n    → Return dfs(0) // 從起始索引開始分割\n\n→ Function dfs(index): // 以 index 為起點遞迴分割\n    → Decision: index == len(word)? // 是否已到字串結尾\n        Yes → Return True // 成功分割\n        No → // 進一步嘗試\n    → Decision: index in memo? // 是否已計算過\n        Yes → Return memo[index] // 直接回傳結果\n        No →\n    → For end in range(index+1, len(word)+1): // 遍歷可能的結束位置\n        → sub = word[index:end] // 取得子字串\n        → Decision: sub in wordSet? // 子字串是否是已知詞\n            Yes → Decision: dfs(end)? // 若後續能分割\n                Yes → memo[index] = True // 記錄成功\n                    → Return True\n                No → // 嘗試下一個 end\n            No → // 嘗試下一個 end\n    → memo[index] = False // 無法分割\n    → Return False // 失敗",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findAllConcatenatedWordsInADict(self, words):\n        # 儲存已處理的較短詞\n        word_set = set()\n        result = []\n\n        # 先根據長度排序，確保較短詞已加入 word_set\n        for word in sorted(words, key=len):\n            if not word:          # 跳過空字串\n                continue\n            if self.can_form(word, word_set):\n                result.append(word)\n            word_set.add(word)\n        return result\n\n    def can_form(self, word, word_set):\n        # 斷詞動態規劃：dp[i] 表示 word[:i] 可被完全組合\n        if not word_set:\n            return False\n        dp = [False] * (len(word) + 1)\n        dp[0] = True\n        for i in range(1, len(word) + 1):\n            for j in range(i):\n                if not dp[j]:\n                    continue\n                if word[j:i] in word_set:\n                    dp[i] = True\n                    break\n        return dp[len(word)]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 若輸入包含「words =」前綴，移除之\n    if data.lower().startswith('words'):\n        idx = data.find('=')\n        if idx != -1:\n            data = data[idx + 1 :].strip()\n\n    # 解析為列表，若失敗則以空格或換行分隔\n    try:\n        words = ast.literal_eval(data)\n    except Exception:\n        words = data.split()\n\n    if not isinstance(words, list):\n        words = [str(words)]\n\n    sol = Solution()\n    result = sol.findAllConcatenatedWordsInADict(words)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "words = [\"cat\",\"cats\",\"catsdogcats\",\"dog\",\"dogcatsdog\",\"hippopotamuses\",\"rat\",\"ratcatdogcat\"]",
          "expected_output": "[\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]'\nGot (Norm):      '[\"dogcatsdog\",\"catsdogcats\",\"ratcatdogcat\"]'\n--- (Raw) ---\nRaw Expected: '[\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]'\nRaw Got:      \"['dogcatsdog', 'catsdogcats', 'ratcatdogcat']\""
        },
        {
          "example_index": 1,
          "input": "words = [\"cat\",\"dog\",\"catdog\"]",
          "expected_output": "[\"catdog\"]",
          "success": true,
          "output": "['catdog']"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode341.json",
    "problem_index_in_file": 0,
    "title": "Flatten Nested List Iterator",
    "description_snippet": "You are given a nested list of integers nestedList. Each element is either an integer or a list whos...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for the algorithm that flattens nested list with iterator. We'll design NestedIterator class with constructor, hasNext, next. Use stack to simulate recursion, flatten on the fly. Steps: initialize stack with reversed nestedList; hasNext checks stack top; if top is list, pop and push its elements reversed; next returns integer after hasNext ensures it's integer. Provide each line with explanation. We'll produce virtual code lines following format. Use Start, End. We'll provide steps for initialization, hasNext, next. Use arrows.\n\nWe need to include \"→\" for flow. Each line must contain virtual code and comment. Use 'Start', 'End'. Provide steps for each method. Also show loop in test pseudocode? The requirement: produce virtual code for implementation, not test. So include class definition lines? We can show start, define class, constructor, methods.\n\nLet's craft:\n\nStart\n→ Define class NestedIterator // 定義迭代器類別\n→  Member: stack // 堆疊存儲待處理的元素\n\n→ Constructor: NestedIterator(List<NestedInteger> nestedList)\n    // 初始化堆疊，將整個列表倒序推入\n    → For i from nestedList.size()-1 downto 0\n        → Push nestedList[i] to stack\n\n→ Method: boolean hasNext()\n    // 檢查堆疊頂部是否為可取整數\n    → While stack not empty\n        → top = stack.peek()\n        → If top is integer\n            → Return true\n        → Else // top is list\n            → stack.pop()\n            → list = top.getList()\n            → For i from list.size()-1 downto 0\n                → Push list[i] to stack\n    → Return false\n\n→ Method: int next()\n    // 先確保有下一個整數\n    → Call hasNext()\n    → top = stack.pop()\n    → Return top.getInteger()\n\nEnd\n\nWe need each line with arrow and comment. Use indentation? Provide nested decision with Yes/No. For loops we can use step lines. But we can produce simple flow.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Define class NestedIterator // 定義 NestedIterator 類別\n→ Member: stack // 堆疊，用於儲存待處理的 NestedInteger 物件\n\n→ Constructor: NestedIterator(List<NestedInteger> nestedList) // 初始化迭代器\n    // 把整個列表倒序推入堆疊，方便後續取值\n    → For i from nestedList.size() - 1 downto 0\n        → Push nestedList[i] to stack\n\n→ Method: boolean hasNext() // 判斷是否還有可取的整數\n    // 將堆疊頂部若為列表，展開並將其元素倒序推入堆疊\n    → While stack is not empty\n        → top = stack.peek()\n        → Decision: top 是整數?\n            Yes → Return true // 顶部已是整數，下一個可取\n            No  → Decision: top 是列表?\n                Yes → stack.pop()\n                    → list = top.getList()\n                    → For i from list.size() - 1 downto 0\n                        → Push list[i] to stack\n                No  → // 不是整數也不是列表，理論上不會發生\n    → Return false // 堆疊已空，沒有更多整數\n\n→ Method: int next() // 取得下一個整數\n    → Call hasNext() // 確保有下一個整數\n    → top = stack.pop()\n    → Return top.getInteger()\n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass NestedIterator:\n    def __init__(self, nestedList):\n        \"\"\"\n        接收一個由整數與子列表組成的巢狀列表。\n        直接把整個列表倒序放入堆疊，方便後續 pop。\n        \"\"\"\n        # 倒序放入堆疊\n        self.stack = nestedList[::-1]\n\n    def hasNext(self):\n        \"\"\"\n        判斷堆疊中是否還有可取的整數。\n        若堆疊頂部是列表，則把它展開並把元素倒序推入堆疊。\n        \"\"\"\n        while self.stack:\n            top = self.stack[-1]\n            if isinstance(top, int):\n                # 顶部已是整數，下一個可取\n                return True\n            # 顶部是列表，展開\n            self.stack.pop()\n            # 把子列表倒序推入堆疊\n            self.stack.extend(top[::-1])\n        return False\n\n    def next(self):\n        \"\"\"\n        取得下一個整數。假設呼叫者已經確保 hasNext() 為 True。\n        \"\"\"\n        return self.stack.pop()\n\nif __name__ == \"__main__\":\n    # 讀取全部輸入\n    raw = sys.stdin.read().strip()\n    if not raw:\n        sys.exit(0)\n\n    # 可能包含 \"nestedList = \" 這種格式，先取等號右邊\n    if \"=\" in raw:\n        _, expr = raw.split(\"=\", 1)\n    else:\n        expr = raw\n\n    # 轉成 Python 對象（list/tuple/int）\n    try:\n        nested_list = ast.literal_eval(expr.strip())\n    except Exception as e:\n        # 若解析失敗，直接結束\n        sys.exit(1)\n\n    # 建立迭代器\n    iterator = NestedIterator(nested_list)\n    result = []\n    while iterator.hasNext():\n        result.append(iterator.next())\n\n    # 輸出結果\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nestedList = [[1,1],2,[1,1]]",
          "expected_output": "[1,1,2,1,1]",
          "success": true,
          "output": "[1, 1, 2, 1, 1]"
        },
        {
          "example_index": 1,
          "input": "nestedList = [1,[4,[6]]]",
          "expected_output": "[1,4,6]",
          "success": true,
          "output": "[1, 4, 6]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode485.json",
    "problem_index_in_file": 0,
    "title": "Max Consecutive Ones",
    "description_snippet": "Given a binary array nums, return the maximum number of consecutive 1's in the array....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code lines with explanations. Use Start, End, Decision, etc. So the requirement: Given binary array nums, return max consecutive 1's. Virtual code should reflect algorithm: iterate over array, keep current count and max. So lines:\n\nStart\n→ Step 1: Initialize maxCount = 0, currentCount = 0 // set counters\n→ Step 2: For each element in nums // iterate array\n    → Decision: If element == 1? // check if 1\n        Yes → currentCount = currentCount + 1 // increment\n        No  → currentCount = 0 // reset\n    → Decision: currentCount > maxCount? // compare\n        Yes → maxCount = currentCount // update max\nEnd // return maxCount\n\nNeed to use correct syntax: \"Decision:\" with Yes → etc. Use \"For each\" maybe \"For each element in nums\" but within the arrow? Might need to represent loop.\n\nWe can do:\n\n→ Step 2: For each element in nums // iterate over array elements\n    → Decision: element == 1? // check value\n        Yes → currentCount = currentCount + 1 // increment consecutive count\n        No  → currentCount = 0 // reset count\n    → Decision: currentCount > maxCount? // compare with maximum\n        Yes → maxCount = currentCount // update max\n\nEnd // return maxCount\n\nAlso need to add return maxCount at End? Could be separate step: → Step 3: Return maxCount // output result\n\nSo End includes return.\n\nThus lines:\n\nStart // 程式開始執行\n→ Step 1: Initialize maxCount = 0, currentCount = 0 // 設定計數器\n→ Step 2: For each element in nums // 遍歷數組\n    → Decision: element == 1? // 判斷是否為 1\n        Yes → currentCount = currentCount + 1 // 連續 1 數量加 1\n        No  → currentCount = 0 // 重置連續計數\n    → Decision: currentCount > maxCount? // 檢查是否需要更新最大值\n        Yes → maxCount = currentCount // 更新最大連續 1 數\n→ Step 3: Return maxCount // 回傳結果\nEnd // 程式結束\n\nThat seems fine. Ensure formatting. Use '→' properly. For decision indent with spaces. Use `Decision:`. Also include \"Yes →\" and \"No →\".\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Initialize maxCount = 0, currentCount = 0 // 設定最大連續 1 的計數器和當前計數器  \n→ Step 2: For each element in nums // 遍歷二元陣列  \n    → Decision: element == 1? // 判斷當前元素是否為 1  \n        Yes → currentCount = currentCount + 1 // 連續 1 數量加 1  \n        No  → currentCount = 0 // 重置連續計數  \n    → Decision: currentCount > maxCount? // 檢查是否需要更新最大值  \n        Yes → maxCount = currentCount // 更新最大連續 1 數  \n→ Step 3: Return maxCount // 回傳最大連續 1 的個數  \nEnd // 程式結束",
      "generated_code": "import sys\nimport ast\n\ndef find_max_consecutive_ones(nums):\n    \"\"\"\n    Return the length of the longest contiguous sub‑array consisting only of 1s.\n    \"\"\"\n    max_count = 0\n    current = 0\n    for num in nums:\n        if num == 1:\n            current += 1\n            if current > max_count:\n                max_count = current\n        else:\n            current = 0\n    return max_count\n\nif __name__ == \"__main__\":\n    # Read the entire input (could be multiple lines or a single line)\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # The input is expected in the form:  nums = [1,1,0,1,1,1]\n    # Extract the list part for safe evaluation.\n    try:\n        start = data.index('[')\n        end = data.rindex(']')\n        list_str = data[start:end+1]\n        nums = ast.literal_eval(list_str)\n    except ValueError:\n        # Fallback: try to evaluate the whole input directly\n        nums = ast.literal_eval(data)\n\n    # Compute and output the result\n    result = find_max_consecutive_ones(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,1,0,1,1,1]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [1,0,1,1,0,1]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode453.json",
    "problem_index_in_file": 0,
    "title": "Minimum Moves to Equal Array Elements",
    "description_snippet": "Given an integer array nums of size n, return the minimum number of moves required to make all array...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step, line by line, following the format. Provide explanation comments. Must not output actual code, only virtual steps. Use arrows, Start, End, Decision.\n\nWe need to think about algorithm: In one move, increment n-1 elements by 1. Equivalent to decrement one element by 1. So we need to find min moves to make all equal, by decrementing elements. That is number of moves equals sum(nums) - n * min(nums). Because we need to reduce all to min. So algorithm: find min, compute sum, compute moves. Output moves.\n\nSo virtual steps: Start, Step 1: Input array nums, Step 2: Determine min, Step 3: Compute sum, Step 4: Compute moves = sum - n * min, Step 5: Output moves. End.\n\nWe need to use decision arrow maybe none needed. But can include simple decision to check if array length 0? But not necessary. We can include a decision to handle empty array.\n\nWe must produce each line with \"虛擬碼步驟 // 解釋\". Use \"Start // 程式開始執行\". Then arrow lines: \"→ Step 1: 輸入數組 nums\" etc.\n\nLet's craft.\n\nAlso use \"Decision:\" arrow lines? Not necessary but we could have one decision: if n==0 then output 0. But okay.\n\nLet's produce.\n\nMake sure each line contains code step and comment separated by space. Use \"→\" preceding lines after start.\n\nAlso \"End // 程式執行結束\".\n\nEnsure format consistent. Use Chinese for explanation.\n\nLet's create final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入整數數組 nums // 從使用者或呼叫處取得整數數組  \n→ Step 2: 計算 n = 長度(nums) // 取得數組長度  \n→ Decision: 如果 n 為 0? // 檢查是否為空數組  \n  Yes → Step 3a: 輸出 0 // 空數組不需任何移動，直接回傳 0  \n  No  → Step 3b: 繼續後續步驟  \n→ Step 4: 找到最小值 minVal = 最小(nums) // 用最小值作為最終目標值  \n→ Step 5: 計算總和 sumVal = 總和(nums) // 計算所有元素之和  \n→ Step 6: 計算移動次數 moves = sumVal - n * minVal // 需要減少的總量即為最小移動次數  \n→ Step 7: 輸出 moves // 回傳最小移動次數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def minMoves(self, nums):\n        \"\"\"計算所有元素變為最小值所需的最小移動次數。\"\"\"\n        if not nums:\n            return 0\n        return sum(nums) - min(nums) * len(nums)\n\ndef parse_input(input_str: str):\n    \"\"\"將輸入字串轉換成整數列表。\"\"\"\n    # 尋找 '['，並使用 ast.literal_eval 解析\n    idx = input_str.find('[')\n    if idx == -1:\n        return []\n    list_str = input_str[idx:]\n    return ast.literal_eval(list_str)\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個內容\n    raw_input = sys.stdin.read().strip()\n    if raw_input:\n        nums = parse_input(raw_input)\n        result = Solution().minMoves(nums)\n        print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [1,1,1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode225.json",
    "problem_index_in_file": 0,
    "title": "Implement Stack using Queues",
    "description_snippet": "Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should suppo...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code with line by line steps and explanation, using virtual code syntax described: Start, → Step X: ..., Decision: ..., Yes →, No →, End.\n\nThe requirement: implement MyStack class with push, pop, top, empty using only two queues. So we design algorithm: maintain two queues q1 and q2. push: enqueue to q1. pop: move all but last from q1 to q2, dequeue last, swap names. top: similar but peek last and then put back. empty: check if q1 empty. Or better: maintain current queue as active. For simplicity, push to q1, pop uses q1 and q2.\n\nWe need to produce virtual code line by line, not actual code. For each operation function.\n\nWe should produce pseudocode for the class and each method. Also maybe include initialization.\n\nLet's outline steps:\n\nStart // Program start\n\n→ Step 1: Initialize queue A // primary queue\n→ Step 2: Initialize queue B // auxiliary queue\n\nThen each method.\n\nDefine push(x):\n→ Step 3: Enqueue x into queue A // add to back\nReturn nothing\n\nDefine pop():\n→ Decision: If queue A empty? // check empty\n    Yes → Return null // or error\n    No → → Step 4: While size of queue A > 1? // move all but last\n        → Step 5: Dequeue front from A, Enqueue to B // transfer\n    → Step 6: Dequeue last from A and store as result // this is top\n    → Step 7: Swap A and B // A becomes B, B becomes A\n    → Step 8: Return result\n\nDefine top():\nSame but don't remove last: similar steps but after capturing result, enqueue it to B, then swap.\n\nDefine empty():\n→ Step 9: Return is empty of queue A // if queue A empty\n\nEnd\n\nBut need to show as virtual code lines with comments.\n\nMake sure each line has virtual code and explanation.\n\nWe also might want to show class structure.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: MyStack() // 建構子，初始化兩個佇列\n    → Step 1.1: queue1 ← New Queue() // 主佇列\n    → Step 1.2: queue2 ← New Queue() // 輔助佇列\n\n→ Step 2: push(x) // 將元素 x 推進堆疊頂部\n    → Step 2.1: queue1.enqueue(x) // 以佇列後端加入\n\n→ Step 3: pop() // 移除並返回堆疊頂部元素\n    → Decision: queue1.isEmpty() ? // 判斷是否為空\n        Yes → Step 3.1: Return null // 或拋出錯誤\n        No  →\n            → Step 3.2: While queue1.size() > 1 do // 移動除最後一個之外的所有元素\n                → Step 3.3: temp ← queue1.dequeue() // 從前端取出\n                → Step 3.4: queue2.enqueue(temp) // 進入輔助佇列\n            → Step 3.5: result ← queue1.dequeue() // 最後一個即頂部元素\n            → Step 3.6: Swap(queue1, queue2) // 交換兩個佇列\n            → Step 3.7: Return result // 回傳頂部元素\n\n→ Step 4: top() // 返回堆疊頂部元素但不移除\n    → Decision: queue1.isEmpty() ?\n        Yes → Step 4.1: Return null\n        No  →\n            → Step 4.2: While queue1.size() > 1 do\n                → Step 4.3: temp ← queue1.dequeue()\n                → Step 4.4: queue2.enqueue(temp)\n            → Step 4.5: result ← queue1.dequeue() // 頂部元素\n            → Step 4.6: queue2.enqueue(result) // 再次加入輔助佇列，保持元素不變\n            → Step 4.7: Swap(queue1, queue2)\n            → Step 4.8: Return result\n\n→ Step 5: empty() // 判斷堆疊是否為空\n    → Step 5.1: Return queue1.isEmpty() // 若主佇列空則堆疊空\n\nEnd // 程式結束\n\nMake sure each line has arrow and explanation.\n\nWe need to be consistent: For virtual code lines, we must include \"→\" before each step line. For nested steps, can indent or use number but still \"→\".\n\nWe might also include \"Decision:\" lines.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: MyStack() // 建構子，初始化兩個佇列  \n → Step 1.1: queue1 ← New Queue() // 主佇列，用來儲存堆疊元素  \n → Step 1.2: queue2 ← New Queue() // 輔助佇列，用來暫存元素  \n\n→ Step 2: push(x) // 將元素 x 推進堆疊頂部  \n → Step 2.1: queue1.enqueue(x) // 以佇列後端加入，維持 FIFO  \n\n→ Step 3: pop() // 移除並返回堆疊頂部元素  \n → Decision: queue1.isEmpty() ? // 判斷堆疊是否為空  \n  Yes → Step 3.1: Return null // 或拋出錯誤，視實作需求  \n  No →  \n   → Step 3.2: While queue1.size() > 1 do // 移動除最後一個之外的所有元素  \n     → Step 3.3: temp ← queue1.dequeue() // 從前端取出  \n     → Step 3.4: queue2.enqueue(temp) // 進入輔助佇列  \n   → Step 3.5: result ← queue1.dequeue() // 最後一個即頂部元素  \n   → Step 3.6: Swap(queue1, queue2) // 交換兩個佇列，恢復主佇列為空  \n   → Step 3.7: Return result // 回傳堆疊頂部元素  \n\n→ Step 4: top() // 返回堆疊頂部元素但不移除  \n → Decision: queue1.isEmpty() ?  \n  Yes → Step 4.1: Return null  \n  No →  \n   → Step 4.2: While queue1.size() > 1 do  \n     → Step 4.3: temp ← queue1.dequeue()  \n     → Step 4.4: queue2.enqueue(temp)  \n   → Step 4.5: result ← queue1.dequeue() // 頂部元素  \n   → Step 4.6: queue2.enqueue(result) // 再次加入輔助佇列，保持元素不變  \n   → Step 4.7: Swap(queue1, queue2) // 交換佇列，保持堆疊狀態  \n   → Step 4.8: Return result  \n\n→ Step 5: empty() // 判斷堆疊是否為空  \n → Step 5.1: Return queue1.isEmpty() // 若主佇列空則堆疊空  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport re\nfrom collections import deque\n\nclass MyStack:\n    \"\"\"LIFO stack implemented using two queues.\"\"\"\n    def __init__(self):\n        self.q1 = deque()  # primary queue\n        self.q2 = deque()  # auxiliary queue\n\n    def push(self, x: int) -> None:\n        \"\"\"Push element x onto the stack.\"\"\"\n        self.q1.append(x)\n\n    def pop(self) -> int:\n        \"\"\"Remove and return the top element of the stack.\"\"\"\n        if not self.q1:\n            return None\n        # Move all but the last element to the auxiliary queue\n        while len(self.q1) > 1:\n            self.q2.append(self.q1.popleft())\n        res = self.q1.popleft()      # this is the top element\n        # Swap queues to restore state\n        self.q1, self.q2 = self.q2, self.q1\n        return res\n\n    def top(self) -> int:\n        \"\"\"Return the top element without removing it.\"\"\"\n        if not self.q1:\n            return None\n        # Move all but the last element to the auxiliary queue\n        while len(self.q1) > 1:\n            self.q2.append(self.q1.popleft())\n        res = self.q1.popleft()\n        # Put the top element back into auxiliary queue\n        self.q2.append(res)\n        # Swap queues back\n        self.q1, self.q2 = self.q2, self.q1\n        return res\n\n    def empty(self) -> bool:\n        \"\"\"Check whether the stack is empty.\"\"\"\n        return not self.q1\n\n\ndef parse_input(s: str):\n    \"\"\"\n    Parse the input format:\n    ['MyStack','push','push',...], [[],[1],[2],...]\n    \"\"\"\n    # Extract the two lists using a regex\n    m = re.match(r'\\s*(\\[[^\\]]*\\])\\s*,\\s*(\\[[^\\]]*\\])\\s*', s)\n    if not m:\n        raise ValueError(\"Input format incorrect\")\n    ops = ast.literal_eval(m.group(1))\n    vals = ast.literal_eval(m.group(2))\n    return ops, vals\n\n\ndef main():\n    raw_input = sys.stdin.read()\n    ops, vals = parse_input(raw_input)\n\n    stack = MyStack()\n    results = [None]  # constructor returns null\n\n    # ops[0] is 'MyStack', vals[0] is [] - skip them\n    for op, val in zip(ops[1:], vals[1:]):\n        if op == 'push':\n            # val is a list like [x]\n            stack.push(val[0] if isinstance(val, list) else val)\n            results.append(None)\n        elif op == 'pop':\n            results.append(stack.pop())\n        elif op == 'top':\n            results.append(stack.top())\n        elif op == 'empty':\n            results.append(stack.empty())\n        else:\n            # unknown operation, ignore\n            results.append(None)\n\n    print(results)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "Input [\"MyStack\", \"push\", \"push\", \"top\", \"pop\", \"empty\"], [[], [1], [2], [], [], []]",
          "expected_output": "[null, null, null, 2, 2, false]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpkcgwbybr.py\", line 88, in <module>\n    main()\n  File \"/tmp/tmpkcgwbybr.py\", line 63, in main\n    ops, vals = parse_input(raw_input)\n                ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpkcgwbybr.py\", line 55, in parse_input\n    raise ValueError(\"Input format incorrect\")\nValueError: Input format incorrect"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode279.json",
    "problem_index_in_file": 0,
    "title": "Perfect Squares",
    "description_snippet": "Given an integer n, return the least number of perfect square numbers that sum to n.\n\nA perfect squa...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code lines for algorithm: \"least number of perfect squares that sum to n\" which is classic problem solved by BFS or DP. Provide virtual code with explanation each line.\n\nWe'll design algorithm using BFS or DP. Let's use DP: dp[i] minimal squares. Complexity O(n*sqrt(n)). Provide pseudo code.\n\nLines: Start, read n, initialize dp array length n+1 with Infinity, dp[0] = 0. For i from 1 to n: for j from 1 to floor(sqrt(i)): dp[i] = min(dp[i], dp[i - j*j] + 1). After loops, output dp[n]. End.\n\nWe must use arrow syntax: Start, → Step 1, etc. Use Decision: if ...? but may not needed. We'll just use loops.\n\nLet's produce lines: \"Start // 程式開始執行\" etc.\n\nWe must include arrow before each step. For loops, maybe \"→ Step: For i = 1 to n\" but we need structure; we can use \"→ Loop i from 1 to n:\" but need arrow.\n\nProbably we can do:\n\n→ Step 1: 讀取整數 n // 取得輸入\n\n→ Step 2: 建立 dp 陣列長度 n+1，所有值設為無窮大 // 初始設定\n\n→ Step 3: dp[0] ← 0 // 基礎情況\n\n→ Step 4: For i ← 1 to n do // 外層迴圈\n\n    → Step 5: maxSquareRoot ← floor(sqrt(i)) // 計算能用的最大平方根\n\n    → Step 6: For j ← 1 to maxSquareRoot do // 內層迴圈\n\n        → Decision: 是否 dp[i] > dp[i - j*j] + 1? // 判斷是否更新\n\n            Yes → Step 7: dp[i] ← dp[i - j*j] + 1 // 更新最小值\n\n            No → // 不更新\n\n    → End For\n\n→ End For\n\n→ Step 8: 輸出 dp[n] // 最終答案\n\nEnd // 程式結束\n\nNeed arrow formatting: use arrow for each line. For loops: maybe \"→ Step: For i = 1 to n\" but arrow before each step. For Decision block we show indentation.\n\nWe must follow format: each line has \"虛擬碼步驟\" + space + \"// 解釋/說明\".\n\nLet's craft.\n\nAlso note arrow formatting: e.g., \"→ Step 1: 讀取整數 n // 取得輸入\". For decision, use \"Decision: ...?\" with Yes → and No →.\n\nMake sure each line ends with //.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取整數 n // 取得輸入  \n→ Step 2: 建立 dp 陣列長度 n+1，所有值設為無窮大 // 初始化 DP 表  \n→ Step 3: dp[0] ← 0 // 基礎情況：0 需要 0 個平方數  \n→ Step 4: For i ← 1 to n do // 外層迴圈遍歷所有目標值  \n  → Step 5: maxRoot ← floor(sqrt(i)) // 計算能用的最大平方根  \n  → Step 6: For j ← 1 to maxRoot do // 內層迴圈嘗試所有平方數  \n    Decision: dp[i] > dp[i - j*j] + 1 ? // 判斷是否可更新 dp[i]  \n     Yes → Step 7: dp[i] ← dp[i - j*j] + 1 // 更新為更小的平方數個數  \n     No → // 保持現有值  \n  → End For // 結束內層迴圈  \n→ End For // 結束外層迴圈  \n→ Step 8: 輸出 dp[n] // 顯示最少平方數個數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport math\nimport re\n\nclass Solution:\n    def numSquares(self, n: int) -> int:\n        # dp[i] 表示數字 i 最少需要的完全平方數個數\n        dp = [math.inf] * (n + 1)\n        dp[0] = 0\n\n        for i in range(1, n + 1):\n            j = 1\n            while j * j <= i:\n                dp[i] = min(dp[i], dp[i - j * j] + 1)\n                j += 1\n\n        return dp[n]\n\ndef main() -> None:\n    # 讀取所有輸入，提取第一個整數\n    data = sys.stdin.read()\n    match = re.search(r'\\d+', data)\n    if not match:\n        raise ValueError(\"Input must contain an integer\")\n    n = int(match.group())\n\n    solver = Solution()\n    result = solver.numSquares(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 12",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "n = 13",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode330.json",
    "problem_index_in_file": 0,
    "title": "Patching Array",
    "description_snippet": "Given a sorted integer array nums and an integer n, add/patch elements to the array such that any nu...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo code for the problem: \"Patching Array\" LeetCode 330. The algorithm: greedy. Use current coverage [1, maxReach]. Initially maxReach=0. While maxReach < n: patch number is maxReach+1; add to count, update maxReach += patch. Else if next array element <= maxReach+1, use it: maxReach += nums[i]; i++. Complexity O(m). We'll produce step-by-step pseudo code with Start, End, Decision nodes. We need to output each line as \"虛擬碼步驟 // 解釋\". Must use arrows, Start, End, Decision. Each line should have arrow or start, etc.\n\nWe need to include array index i, coverage. Let's produce.\n\nLet's craft:\n\nStart // 開始程序\n→ Step 1: 初始化 i = 0, count = 0, maxReach = 0 // 設定初始變數\n→ Decision: 當 maxReach < n 時 // 判斷是否已覆蓋 1..n\n    Yes → Decision: 當 i < nums.length 且 nums[i] <= maxReach + 1 時 // 是否可用現有元素擴展覆蓋\n        Yes → Step 2: maxReach += nums[i] // 使用 nums[i] 進一步擴展覆蓋範圍\n                i++ // 移動到下一個元素\n        No  → Step 3: patch = maxReach + 1 // 添加補丁元素\n                count++ // 補丁數量加一\n                maxReach += patch // 擴展覆蓋範圍\n    No → End // 已經覆蓋到 n，結束程序\nEnd // 程式執行結束\n\nBut we need to also show the loop repeating until coverage done. The Decision: maxReach < n? and if yes, then inner decision; else end.\n\nWe need to ensure arrow formatting: use `→` after each line to indicate next step. Also decisions have indentation maybe, but we can just use arrow.\n\nLet's write each line:\n\nStart // 程式開始執行\n→ Step 1: i = 0, count = 0, maxReach = 0 // 初始化索引、補丁數與已覆蓋上限\n→ Decision: maxReach < n? // 檢查是否已覆蓋到 n\n    Yes → Decision: i < nums.length AND nums[i] <= maxReach + 1? // 是否能利用現有元素擴充覆蓋\n        Yes → Step 2: maxReach = maxReach + nums[i] // 用 nums[i] 擴展覆蓋範圍\n                i = i + 1 // 移至下一個元素\n        No  → Step 3: patch = maxReach + 1 // 需要補丁\n                count = count + 1 // 補丁數量加一\n                maxReach = maxReach + patch // 補丁擴充覆蓋\n    No  → End // 已覆蓋完 [1, n]，結束\nEnd // 程式執行結束\n\nBut maybe we need to reflect that after patch or use, we should loop back to decision. So after each step 2 or step 3, we need arrow back to decision: maybe we just let the flow be implied. But the format might need explicit \"→ Decision...\" again. But we can simply rely on flow.\n\nThe instructions: \"逐行輸出，每行必須包含：虛擬碼步驟 + 空格 + // 解釋/說明。使用虛擬碼的箭頭 (→, Yes →, No →) 和結構 (Start, End, Decision:)\". So we can structure as above. Should we indent? The sample shows indentation for nested decisions, but it's just plain lines. We can maintain indentation using spaces.\n\nThus produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: i = 0, count = 0, maxReach = 0 // 初始化索引、補丁數與已覆蓋上限\n→ Decision: maxReach < n? // 檢查是否已覆蓋到 n\n    Yes → Decision: i < nums.length AND nums[i] <= maxReach + 1? // 是否能利用現有元素擴充覆蓋\n        Yes → Step 2: maxReach = maxReach + nums[i] // 用 nums[i] 擴展覆蓋範圍\n                i = i + 1 // 移至下一個元素\n        No  → Step 3: patch = maxReach + 1 // 需要補丁\n                count = count + 1 // 補丁數量加一\n                maxReach = maxReach + patch // 補丁擴充覆蓋\n    No  → End // 已覆蓋完 [1, n]，結束\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\nimport re\n\ndef min_patches(nums, n):\n    patches = 0\n    miss = 1\n    i = 0\n    while miss <= n:\n        if i < len(nums) and nums[i] <= miss:\n            miss += nums[i]\n            i += 1\n        else:\n            miss += miss\n            patches += 1\n    return patches\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    nums_match = re.search(r'nums\\s*=\\s*(\\[[^\\]]*\\])', data)\n    n_match = re.search(r'n\\s*=\\s*(-?\\d+)', data)\n\n    nums = eval(nums_match.group(1)) if nums_match else []\n    n = int(n_match.group(1)) if n_match else 0\n\n    result = min_patches(nums, n)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,3], n = 6",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "nums = [1,5,10], n = 20",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "nums = [1,2,2], n = 5",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode210.json",
    "problem_index_in_file": 0,
    "title": "Course Schedule II",
    "description_snippet": "There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to output virtual code steps for topological sort problem. Provide steps using Start, Decision, etc. Each line: \"虛擬碼步驟 // 解釋\". Use arrows. Use appropriate steps: build graph, in-degree array, queue, result list, while loop, pop, add to result, decrease in-degree, push when zero. After loop, check if result length==numCourses. If yes, return result else return empty.\n\nWe should not output actual code but pseudocode steps. Let's craft step-by-step.\n\nStart\n→ Step 1: 初始化圖 adjacency list, 為每門課建立空列表\n→ Step 2: 初始化入度陣列 indegree[0..numCourses-1] 為 0\n→ Decision: 是否有 prereq? \n    Yes → for each pair [a,b] in prerequisites:\n        Step 3: 在 adjacency[b] 中加入 a // 表示 b→a\n        Step 4: indegree[a] +=1\n    No → 無動作\n\n→ Step 5: 建立空佇列 queue\n→ Decision: 對於每門課 i:\n    Yes → 若 indegree[i]==0，將 i 加入 queue // 無前置課程\n    No → 無動作\n\n→ Step 6: 建立空列表 result\n→ Step 7: While queue 非空:\n    → Step 8: 取出 queue 頭節點 cur\n    → Step 9: 將 cur 加入 result\n    → Decision: 是否有鄰接節點？ 若 adjacency[cur] 非空：\n        Yes → 對於每個 neigh in adjacency[cur]:\n            → Step 10: indegree[neigh] -=1\n            → Decision: indegree[neigh]==0? \n                Yes → Step 11: 將 neigh 加入 queue\n                No  → 無動作\n        No → 無動作\n\n→ Decision: result 長度 == numCourses?\n    Yes → Step 12: 回傳 result // 有合法排序\n    No  → Step 13: 回傳空陣列 // 無法完成課程\n\nEnd\n\nWe need to ensure arrow usage and format lines with single spaces. Use Chinese explanation. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 adjacency list 為空列表 // 為每門課建立鄰接表  \n→ Step 2: 初始化 indegree[0..numCourses-1] 為 0 // 記錄各課程的前置課程數量  \n→ Decision: 有 prerequisites 吗? // 檢查是否有先修關係  \n    Yes → for each pair [a,b] in prerequisites: // 處理每個先修條件  \n        → Step 3: adjacency[b] 加入 a // 表示從 b 到 a 的邊  \n        → Step 4: indegree[a] += 1 // a 的前置課程數加一  \n    No  → // 無先修條件，跳過  \n→ Step 5: 建立空佇列 queue // 用於存放入度為 0 的課程  \n→ Decision: 對每門課 i: // 找出入度為 0 的課程  \n    Yes → 若 indegree[i] == 0，queue 加入 i // 無前置課程，可立即修  \n    No  → // 入度不為 0，跳過  \n→ Step 6: 建立空列表 result // 儲存課程完成順序  \n→ Step 7: While queue 非空: // 依序處理可修課程  \n    → Step 8: 取出 queue 頭節點 cur // 從佇列取下一門課  \n    → Step 9: result 加入 cur // 加入完成順序  \n    → Decision: adjacency[cur] 是否有鄰接節點?  \n        Yes → 對每個 neigh in adjacency[cur]: // 遍歷所有後續課程  \n            → Step 10: indegree[neigh] -= 1 // 減少後續課程的前置課程數  \n            → Decision: indegree[neigh] == 0?  \n                Yes → queue 加入 neigh // 先修完成，可修  \n                No  → // 還需等待其他先修課程  \n        No  → // 無後續課程，跳過  \n→ Decision: result 長度 == numCourses? // 檢查是否所有課程都已排完  \n    Yes → Step 12: 回傳 result // 有合法順序  \n    No  → Step 13: 回傳空陣列 // 無法完成所有課程  \nEnd // 程式執行結束",
      "generated_code": "import sys\nfrom collections import deque\n\nclass Solution:\n    def findOrder(self, numCourses, prerequisites):\n        # 建立鄰接表與入度陣列\n        graph = [[] for _ in range(numCourses)]\n        indegree = [0] * numCourses\n        for dest, src in prerequisites:\n            graph[src].append(dest)\n            indegree[dest] += 1\n\n        # 取入度為 0 的節點進佇列\n        queue = deque([i for i in range(numCourses) if indegree[i] == 0])\n        order = []\n\n        while queue:\n            node = queue.popleft()\n            order.append(node)\n            for neighbor in graph[node]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    queue.append(neighbor)\n\n        return order if len(order) == numCourses else []\n\ndef parse_input(data: str):\n    \"\"\"\n    解析形如 'numCourses = 2, prerequisites = [[1,0]]' 的輸入。\n    \"\"\"\n    data = data.strip()\n    if not data:\n        return 0, []\n    # 以 ', prerequisites =' 分隔\n    parts = data.split(', prerequisites =')\n    num_part = parts[0].strip()\n    # 移除前綴並轉為整數\n    num_courses = int(num_part.replace('numCourses', '').strip())\n    # 若沒有 prerequisites，預設為空列表\n    prereq_part = parts[1].strip() if len(parts) > 1 else '[]'\n    # 直接 eval 取得列表，輸入格式已經是合法的 Python 列表字面量\n    prerequisites = eval(prereq_part)\n    return num_courses, prerequisites\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read()\n    num_courses, prerequisites = parse_input(input_data)\n    solution = Solution()\n    result = solution.findOrder(num_courses, prerequisites)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "numCourses = 2, prerequisites = [[1,0]]",
          "expected_output": "[0,1]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpiyz8qtn_.py\", line 47, in <module>\n    num_courses, prerequisites = parse_input(input_data)\n                                 ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpiyz8qtn_.py\", line 38, in parse_input\n    num_courses = int(num_part.replace('numCourses', '').strip())\n                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nValueError: invalid literal for int() with base 10: '= 2'"
        },
        {
          "example_index": 1,
          "input": "numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]",
          "expected_output": "[0,2,1,3]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpdyqh83h9.py\", line 47, in <module>\n    num_courses, prerequisites = parse_input(input_data)\n                                 ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpdyqh83h9.py\", line 38, in parse_input\n    num_courses = int(num_part.replace('numCourses', '').strip())\n                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nValueError: invalid literal for int() with base 10: '= 4'"
        },
        {
          "example_index": 2,
          "input": "numCourses = 1, prerequisites = []",
          "expected_output": "[0]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpwuiiruqk.py\", line 47, in <module>\n    num_courses, prerequisites = parse_input(input_data)\n                                 ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpwuiiruqk.py\", line 38, in parse_input\n    num_courses = int(num_part.replace('numCourses', '').strip())\n                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nValueError: invalid literal for int() with base 10: '= 1'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode516.json",
    "problem_index_in_file": 0,
    "title": "Longest Palindromic Subsequence",
    "description_snippet": "Given a string s, find the longest palindromic subsequence's length in s.\n\nA subsequence is a sequen...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce step-by-step virtual code to compute longest palindromic subsequence length in string s. Use dynamic programming typical approach: DP[i][j] length of LPS in s[i..j]. Base case length 1 when i==j. Recurrence: if s[i]==s[j] then DP[i][j] = DP[i+1][j-1] + 2; else DP[i][j] = max(DP[i+1][j], DP[i][j-1]). Use 0-index string, length n. We can iterate lengths from 1 to n. Or use 2D array. Output final DP[0][n-1].\n\nWe must output virtual code line by line with comments.\n\nWe should not output actual code but virtual steps.\n\nThe steps:\n\nStart\n→ Step 1: Read string s\n→ Step 2: Let n = length of s\n→ Step 3: Create 2D array DP[n][n] initialized to 0\n→ Step 4: For i from 0 to n-1: DP[i][i] = 1 // single char palindrome\n→ Step 5: For subLen from 2 to n: // length of substring\n    → Step 6: For i from 0 to n-subLen:\n        → Step 7: Let j = i + subLen - 1\n        → Decision: 如果 s[i] == s[j] ?\n            Yes → Step 8: If subLen == 2 then DP[i][j] = 2 else DP[i][j] = DP[i+1][j-1] + 2\n            No  → Step 9: DP[i][j] = max(DP[i+1][j], DP[i][j-1])\n→ Step 10: 最終答案 = DP[0][n-1]\n→ End\n\nWe need to produce each line with the format: \"虛擬碼步驟 // 解釋\". Use arrow for decisions: \"Decision: ...\" with Yes → and No → lines.\n\nWe should use \"Start\" and \"End\".\n\nLet's produce accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取輸入字串 s // 從使用者取得待分析的字串  \n→ Step 2: 設定 n = s.length // 取得字串長度  \n→ Step 3: 建立二維陣列 DP[n][n] 並初始化為 0 // 用於儲存子問題答案  \n→ Step 4: 對 i 從 0 到 n-1 做:\n    → Step 5: DP[i][i] = 1 // 單個字符本身即為長度為 1 的回文子序列  \n→ Step 6: 對子串長度 subLen 從 2 到 n 做:\n    → Step 7: 對 i 從 0 到 n-subLen 做:\n        → Step 8: 設定 j = i + subLen - 1 // 子串右端索引  \n        → Decision: 若 s[i] == s[j]?\n            Yes → Step 9: 若 subLen == 2 則 DP[i][j] = 2 否則 DP[i][j] = DP[i+1][j-1] + 2 // 兩端相等，將兩端字符包覆前一子問題答案  \n            No  → Step 10: DP[i][j] = max(DP[i+1][j], DP[i][j-1]) // 兩端不相等，取排除左端或右端的最大答案  \n→ Step 11: 最長回文子序列長度 = DP[0][n-1] // 取得整個字串的答案  \n→ End // 程式執行結束",
      "generated_code": "import sys\n\ndef longest_palindrome_subseq(s: str) -> int:\n    \"\"\"Return the length of the longest palindromic subsequence in s.\"\"\"\n    n = len(s)\n    if n == 0:\n        return 0\n\n    # dp[i][j] will hold the LPS length for s[i:j+1]\n    dp = [[0] * n for _ in range(n)]\n\n    # Process substrings in reverse i order so that\n    # dp[i+1][j-1], dp[i+1][j], and dp[i][j-1] are already computed.\n    for i in range(n - 1, -1, -1):\n        dp[i][i] = 1  # A single character is a palindrome of length 1\n        for j in range(i + 1, n):\n            if s[i] == s[j]:\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n\n    return dp[0][n - 1]\n\n\nif __name__ == \"__main__\":\n    # Read all input, strip whitespace and surrounding quotes if any\n    data = sys.stdin.read().strip()\n    if not data:\n        print(0)\n        sys.exit(0)\n\n    # Remove surrounding quotes like \"bbbab\" if present\n    if (data.startswith('\"') and data.endswith('\"')) or (data.startswith(\"'\") and data.endswith(\"'\")):\n        data = data[1:-1]\n\n    result = longest_palindrome_subseq(data)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "\"bbbab\"",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "\"cbbd\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode4.json",
    "problem_index_in_file": 0,
    "title": "Median of Two Sorted Arrays",
    "description_snippet": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two s...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, line by line, using arrow notation. We need to solve median of two sorted arrays, O(log(m+n)) - typical solution: binary search on smaller array, find partition. So produce virtual steps. Should not output actual code. Just virtual steps like \"Start\", \"→ Decision: If nums1 is smaller?\" etc. Provide explanation. Should be concise. Use virtual code syntax: \"Start\", \"→ Step ...\", \"Decision: ...\". Provide each line with // explanation.\n\nWe need to handle binary search on smaller array. Steps:\n\nStart\n→ Decision: 如果 nums1 为空? // handle empty case\n    Yes → Step: 如果 nums1 为空，返回 nums2 的中位数 // empty array\n    No  → Decision: 如果 nums2 为空? // check other\n        Yes → Step: 如果 nums2 为空，返回 nums1 的中位数\n        No  → Decision: 確定較短陣列為 A，較長陣列為 B\n→ Step: 設 low = 0, high = len(A)\n→ While low <= high: // binary search\n    → Step: 計算 i = (low+high)/2, j = (len(A)+len(B)+1)/2 - i\n    → Decision: 如果 A[i-1] > B[j]? // A[i-1] 大於 B[j]\n        Yes → Step: high = i-1 // 將 i 減小\n        No  → Decision: 如果 B[j-1] > A[i]? // B[j-1] 大於 A[i]\n            Yes → Step: low = i+1 // 將 i 增大\n            No  → Step: 已找到正確分割\n→ Step: 計算 maxLeft\n    → Decision: i == 0 ? // A 左邊空\n        Yes → Step: maxLeft = B[j-1]\n        No  → Decision: j == 0 ?\n            Yes → Step: maxLeft = A[i-1]\n            No  → Step: maxLeft = max(A[i-1], B[j-1])\n→ Decision: (len(A)+len(B)) % 2 == 1? // 奇數長度\n    Yes → Step: return maxLeft // 中位數\n    No  → Step: 計算 minRight\n        → Decision: i == len(A)? // A 右邊空\n            Yes → Step: minRight = B[j]\n            No  → Decision: j == len(B)?\n                Yes → Step: minRight = A[i]\n                No  → Step: minRight = min(A[i], B[j])\n        → Step: return (maxLeft + minRight) / 2.0 // 平均\n\nEnd\n\nMake sure each line has // explanation. Ensure format matches: \"虛擬碼步驟 [space] // 解釋\".\n\nLet's craft each line. Also we might need to use \"Decision:\" lines and \"Yes →\", \"No →\" lines as sub-steps. We'll output each line separately.\n\nCheck formatting: Use \"Start // 程式開始執行\" etc. Use \"→\" for steps. The decisions with Yes→ and No→ must be on separate lines? In example, Yes→ and No→ lines are separate. We can follow that pattern.\n\nLet's produce.\n\nAlso need to mention \"Step:\" lines. Good.\n\nLet's create final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: 如果 nums1 為空? // 檢查第一個陣列是否為空  \n Yes → Step: 返回 nums2 的中位數 // 空陣列時直接返回另一個陣列的中位數  \n No  → Decision: 如果 nums2 為空? // 檢查第二個陣列是否為空  \n  Yes → Step: 返回 nums1 的中位數 // 另一空陣列時直接返回第一個陣列的中位數  \n  No  → Step: 確定較短陣列為 A，較長陣列為 B // 兩個陣列都非空，選擇較短的作為 A  \n→ Step: low ← 0, high ← len(A) // 初始化二分搜尋範圍  \n→ Decision: 低於或等於高? // 開始二分搜尋  \n Yes → Step: i ← (low + high) // 2，j ← (len(A)+len(B)+1)//2 - i // 計算分割點  \n  Decision: A[i-1] > B[j]? // 檢查左邊是否太大  \n   Yes → Step: high ← i - 1 // i 減小  \n   No  → Decision: B[j-1] > A[i]? // 檢查右邊是否太大  \n    Yes → Step: low ← i + 1 // i 增大  \n    No  → Step: 已找到正確分割點 // 分割點正確，跳出迴圈  \n No  → End // 迴圈結束（實際情況已在分割點處）  \n→ Step: 計算 maxLeft  \n Decision: i == 0? // A 的左邊是否為空  \n  Yes → Step: maxLeft ← B[j-1] // 只取 B 的左邊最大值  \n  No  → Decision: j == 0? // B 的左邊是否為空  \n   Yes → Step: maxLeft ← A[i-1] // 只取 A 的左邊最大值  \n   No  → Step: maxLeft ← max(A[i-1], B[j-1]) // 取兩者中較大的  \n→ Decision: (len(A)+len(B)) % 2 == 1? // 數組長度奇數？  \n Yes → Step: 返回 maxLeft // 奇數時中位數即為 maxLeft  \n No  → Step: 計算 minRight  \n  Decision: i == len(A)? // A 的右邊是否為空  \n   Yes → Step: minRight ← B[j] // 只取 B 的右邊最小值  \n   No  → Decision: j == len(B)? // B 的右邊是否為空  \n    Yes → Step: minRight ← A[i] // 只取 A 的右邊最小值  \n    No  → Step: minRight ← min(A[i], B[j]) // 取兩者中較小的  \n   → Step: 返回 (maxLeft + minRight) / 2.0 // 偶數時取平均作為中位數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def findMedianSortedArrays(self, nums1, nums2):\n        # If one array is empty, return median of the other\n        if not nums1:\n            return self._median_single(nums2)\n        if not nums2:\n            return self._median_single(nums1)\n\n        # Ensure nums1 is the smaller array\n        if len(nums1) > len(nums2):\n            nums1, nums2 = nums2, nums1\n\n        m, n = len(nums1), len(nums2)\n        low, high = 0, m\n        total = m + n\n        half = (total + 1) // 2  # Number of elements on the left side\n\n        while low <= high:\n            i = (low + high) // 2\n            j = half - i\n\n            Aleft = nums1[i - 1] if i > 0 else float('-inf')\n            Aright = nums1[i] if i < m else float('inf')\n            Bleft = nums2[j - 1] if j > 0 else float('-inf')\n            Bright = nums2[j] if j < n else float('inf')\n\n            if Aleft <= Bright and Bleft <= Aright:\n                if total % 2 == 1:\n                    return min(Aright, Bright)\n                return (max(Aleft, Bleft) + min(Aright, Bright)) / 2.0\n            elif Aleft > Bright:\n                high = i - 1\n            else:\n                low = i + 1\n\n        # Should not reach here\n        return 0.0\n\n    def _median_single(self, nums):\n        l = len(nums)\n        if l % 2 == 1:\n            return nums[l // 2]\n        return (nums[l // 2 - 1] + nums[l // 2]) / 2.0\n\ndef parse_input(data):\n    # Extract numbers for nums1 and nums2 using regex\n    nums1_str = re.search(r'nums1\\s*=\\s*\\[(.*?)\\]', data, re.S)\n    nums2_str = re.search(r'nums2\\s*=\\s*\\[(.*?)\\]', data, re.S)\n\n    nums1 = []\n    nums2 = []\n\n    if nums1_str:\n        nums1 = [int(x.strip()) for x in nums1_str.group(1).split(',') if x.strip()]\n    if nums2_str:\n        nums2 = [int(x.strip()) for x in nums2_str.group(1).split(',') if x.strip()]\n\n    return nums1, nums2\n\ndef main():\n    data = sys.stdin.read()\n    nums1, nums2 = parse_input(data)\n    sol = Solution()\n    median = sol.findMedianSortedArrays(nums1, nums2)\n    print(f\"{median:.5f}\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums1 = [1,3], nums2 = [2]",
          "expected_output": "2.00000",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '2.00000'\nGot (Norm):      '3.00000'\n--- (Raw) ---\nRaw Expected: '2.00000'\nRaw Got:      '3.00000'"
        },
        {
          "example_index": 1,
          "input": "nums1 = [1,2], nums2 = [3,4]",
          "expected_output": "2.50000",
          "success": true,
          "output": "2.50000"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode201.json",
    "problem_index_in_file": 0,
    "title": "Bitwise AND of Numbers Range",
    "description_snippet": "Given two integers left and right that represent the range [left, right], return the bitwise AND of ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for computing bitwise AND over a range. Use known algorithm: find common prefix bits by shifting until left==right. So steps: input left, right; while left<right: shift both right and left right by 1; count shifts; then result = left << shiftCount.\n\nWe produce line by line virtual code with explanations. Use Start, End, Decision, etc. Provide arrow lines. Use the syntax described. Provide each line. Let's write:\n\nStart\n→ Step 1: 讀取左端點 left, 右端點 right // 從使用者取得範圍\n→ Step 2: 初始化 shiftCount 為 0 // 計算位移次數\n→ Decision: left < right? // 判斷是否還有差距\n    Yes → Step 3: right ← right >> 1 // 右移右端點\n    Yes → Step 4: left ← left >> 1 // 右移左端點\n    Yes → Step 5: shiftCount ← shiftCount + 1 // 位移計數加 1\n    Yes → Step 6: 回到 Decision: left < right? // 重複直到相等\n    No  → Step 7: result ← left << shiftCount // 重新左移得到 AND\n→ Step 8: 輸出 result // 結果\nEnd\n\nNeed to ensure each line ends with // explanation.\n\nAlso use arrow for steps inside decision? Use pattern: Yes → Step X: ... //.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取左端點 left 與右端點 right // 取得範圍 [left, right] 的兩個端點  \n→ Step 2: 初始化 shiftCount 為 0 // 用於計算右移的位數  \n→ Decision: left < right? // 判斷兩端點是否仍有差距  \n  Yes → Step 3: right ← right >> 1 // 右移右端點 1 位  \n  Yes → Step 4: left ← left >> 1 // 右移左端點 1 位  \n  Yes → Step 5: shiftCount ← shiftCount + 1 // 位置計數加 1  \n  Yes → Step 6: 轉回 Decision: left < right? // 重複上述步驟直到兩端點相等  \n  No → Step 7: result ← left << shiftCount // 重新左移得到區間內所有數字的位運算 AND  \n→ Step 8: 輸出 result // 將結果回傳給使用者  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef range_bitwise_and(left: int, right: int) -> int:\n    \"\"\"Return the bitwise AND of all integers in the inclusive range [left, right].\"\"\"\n    shift = 0\n    while left < right:\n        left >>= 1\n        right >>= 1\n        shift += 1\n    return left << shift\n\ndef main() -> None:\n    \"\"\"Read input, compute result, and print it.\"\"\"\n    data = sys.stdin.read()\n    # Extract all integer numbers from the input string\n    numbers = list(map(int, re.findall(r'-?\\d+', data)))\n    if len(numbers) < 2:\n        # Not enough numbers to compute; exit silently\n        return\n    left, right = numbers[0], numbers[1]\n    result = range_bitwise_and(left, right)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "left = 5, right = 7",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "left = 0, right = 0",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 2,
          "input": "left = 1, right = 2147483647",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode313.json",
    "problem_index_in_file": 0,
    "title": "Super Ugly Number",
    "description_snippet": "A super ugly number is a positive integer whose prime factors are in the array primes.\n\nGiven an int...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for algorithm to find nth super ugly number. The algorithm typical: use min-heap or pointers. Since primes array length k, we can use DP: ugly[1] = 1; for i from 2 to n, ugly[i] = min(primes[j]*ugly[ptr[j]]) for all j; then increment pointers for those equal. Complexity O(nk). We'll produce steps accordingly.\n\nWe must output line by line, each line: virtual code step + \" // explanation\".\n\nUse arrows: Start, Decision, etc.\n\nWe need to follow output format: use Start, End, Decision: etc. Provide steps.\n\nLet's create a simple pseudocode with loops.\n\nLine 1: Start // 程式開始執行\n\nLine 2: → Input: n, primes // 取得 n 和 primes 陣列\n\nLine 3: → k ← length(primes) // 取得質數個數\n\nLine 4: → ugly ← array of size n+1 // 用來儲存超醜數列\n\nLine 5: → ugly[1] ← 1 // 第一個超醜數為 1\n\nLine 6: → ptr ← array of size k initialized to 1 // 每個質數的指標\n\nLine 7: → i ← 2 // 從第二個位置開始計算\n\nLine 8: → Decision: i <= n? // 檢查是否已計算完\n\nLine 9:    Yes → minVal ← +∞ // 初始化最小值\n\nLine 10: → for j in 0..k-1 // 遍歷所有質數\n\nLine 11:        candidate ← primes[j] * ugly[ptr[j]] // 計算候選值\n\nLine 12:        Decision: candidate < minVal? // 判斷是否更小\n\nLine 13:            Yes → minVal ← candidate // 更新最小值\n\nLine 14:    → ugly[i] ← minVal // 設定第 i 個超醜數\n\nLine 15: → for j in 0..k-1 // 再次遍歷質數\n\nLine 16:        Decision: primes[j] * ugly[ptr[j]] == minVal? // 是否需要移動指標\n\nLine 17:            Yes → ptr[j] ← ptr[j] + 1 // 移動該質數的指標\n\nLine 18: → i ← i + 1 // 下一個位置\n\nLine 19: → End // 迴圈結束\n\nLine 20: → Return ugly[n] // 回傳第 n 個超醜數\n\nBut we need Start and End for whole program.\n\nLet's produce accordingly.\n\nAlso we need arrows like \"→ Step\" lines.\n\nLet's format exactly as requirement.\n\nWe might incorporate Decision: lines as indentation but keep arrows.\n\nAlso \"→\" should be at start of each step.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input: n, primes // 取得輸入值 n 與質數陣列 primes  \n→ k ← length(primes) // 取得質數個數  \n→ ugly ← array of size n+1 // 用於儲存超醜數列的暫存陣列  \n→ ugly[1] ← 1 // 第一個超醜數永遠為 1  \n→ ptr ← array of size k initialized to 1 // 每個質數對應的指標（起始位置為 1）  \n→ i ← 2 // 從第二個位置開始計算  \n→ Decision: i ≤ n? // 是否還需要繼續計算到第 n 個  \n  Yes → minVal ← +∞ // 初始化最小值為正無窮  \n   → for j ← 0 to k-1 // 遍歷所有質數  \n     candidate ← primes[j] * ugly[ptr[j]] // 依指標計算候選值  \n     Decision: candidate < minVal? // 判斷是否更小  \n      Yes → minVal ← candidate // 更新最小值  \n      No → // 保持 minVal  \n   → ugly[i] ← minVal // 設定第 i 個超醜數  \n   → for j ← 0 to k-1 // 再次遍歷以更新指標  \n     Decision: primes[j] * ugly[ptr[j]] == minVal? // 需要移動指標的情況  \n      Yes → ptr[j] ← ptr[j] + 1 // 移動該質數的指標  \n      No → // 指標不變  \n   → i ← i + 1 // 移至下一個位置  \n  No → // i > n 時結束循環  \nEnd // 程式結束執行  \n→ Return ugly[n] // 回傳第 n 個超醜數",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def nthSuperUglyNumber(self, n: int, primes: list[int]) -> int:\n        k = len(primes)\n        ugly = [0] * (n + 1)\n        ugly[1] = 1  # 第一個超醜數為 1\n        idx = [1] * k  # 每個質數對應的指標\n        next_val = [primes[i] * ugly[idx[i]] for i in range(k)]  # 初始候選值\n\n        for i in range(2, n + 1):\n            mn = min(next_val)          # 找到最小的候選值\n            ugly[i] = mn                # 設定第 i 個超醜數\n            for j in range(k):          # 更新需要更新的指標\n                if next_val[j] == mn:\n                    idx[j] += 1\n                    next_val[j] = primes[j] * ugly[idx[j]]\n\n        return ugly[n]\n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    if not nums:\n        sys.exit()\n    n = nums[0]\n    primes = nums[1:]\n    solution = Solution()\n    result = solution.nthSuperUglyNumber(n, primes)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 12, primes = [2,7,13,19]",
          "expected_output": "32",
          "success": true,
          "output": "32"
        },
        {
          "example_index": 1,
          "input": "n = 1, primes = [2,3,5]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode448.json",
    "problem_index_in_file": 0,
    "title": "Find All Numbers Disappeared in an Array",
    "description_snippet": "Given an array nums of n integers where nums[i] is in the range [1, n], return an array of all the i...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for finding missing numbers in array. Should be line by line with arrows. Use Start, Decision, etc. Provide short explanation. Need to output in Traditional Chinese.\n\nWe need to consider algorithm: we can use index marking: for each number, mark negative at index number-1. Then collect indices with positive value. Or use frequency array. Use virtual code steps.\n\nLet's produce:\n\nStart\n→ Step 1: 初始化結果空陣列 missing // 用於存儲缺失數字\n→ Step 2: 針對 nums 中每個元素 x，將 nums[x-1] 的符號設為負號 // 標記已出現\n→ Decision: 是否遍歷完 nums? // 確保所有元素處理\n    Yes → Step 3: 遍歷 nums，對於每個索引 i，如果 nums[i] > 0，則 i+1 為缺失數字，加入 missing\n→ Step 4: 返回 missing // 結果\nEnd\n\nBut we need to use arrow syntax with Decision and Yes/No. We should break lines accordingly.\n\nWe need to show indentation maybe.\n\nLet's format:\n\nStart // 程式開始\n→ Step 1: 初始化空陣列 missing // 用於儲存缺失的數字\n→ Step 2: 對於 nums 中每個數字 x，將 nums[x-1] 的符號設為負號 // 標記已出現\n→ Decision: 是否已經處理完 nums? // 確認所有元素已標記\n    Yes → Step 3: 遍歷 nums，對於每個索引 i，如果 nums[i] > 0，將 i+1 加入 missing // 收集缺失數字\n→ Step 4: 返回 missing // 結果輸出\nEnd // 程式結束\n\nMake sure to use correct indentation for Decision branch. Provide explanation in Chinese. Each line includes virtual code step and // explanation.\n\nWe can include \"Yes →\" line inside Decision block. There is no No branch needed since we just continue. But the Decision can be like \"Decision: 是否已經遍歷完 nums?\" with Yes branch.\n\nWe should also include the iteration steps explicitly. Could also include a loop step.\n\nLet's refine: Use \"Step 2: for each x in nums\" arrow then \"Step 2a\" inside loop. But we need simple steps.\n\nMaybe:\n\n→ Step 2: for each x in nums\n    → Step 2a: nums[x-1] = abs(nums[x-1]) * -1 // 標記\n\nBut to keep simple, we can just say \"Step 2: 對每個 x\" and explain.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空陣列 missing // 用來儲存所有缺失的數字  \n→ Step 2: 對 nums 中每個數字 x  \n    → Step 2a: 把 nums[x-1] 的符號設為負號 // 標記此數字已出現  \n→ Decision: 已經處理完 nums ？ // 確認所有元素已被標記  \n    Yes → Step 3: 遍歷 nums，對每個索引 i  \n        → Step 3a: 如果 nums[i] > 0，將 i+1 加入 missing // 收集未出現的數字  \n→ Step 4: 回傳 missing // 輸出所有缺失的整數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        在 nums 的範圍內（1~n）找出所有缺失的數字。\n        方法：遍歷每個元素，將對應索引（num-1）位置的值設為負數，表示已出現。\n        最後再掃描一次，正數位置對應的索引+1 即為缺失值。\n        \"\"\"\n        n = len(nums)\n        for num in nums:\n            idx = abs(num) - 1\n            nums[idx] = -abs(nums[idx])\n        return [i + 1 for i in range(n) if nums[i] > 0]\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取資料\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 支援輸入格式：nums = [1,2,3] 或直接 [1,2,3]\n    if '=' in data:\n        _, list_part = data.split('=', 1)\n        list_str = list_part.strip()\n    else:\n        list_str = data.strip()\n\n    # 解析列表，使用 literal_eval 以避免 eval 的安全風險\n    try:\n        nums = ast.literal_eval(list_str)\n    except Exception:\n        # 若字串格式不符合列表形式，嘗試以空白/逗號分隔解析\n        nums = [int(x) for x in list_str.replace(',', ' ').split()]\n\n    # 計算並輸出結果\n    sol = Solution()\n    result = sol.findDisappearedNumbers(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [4,3,2,7,8,2,3,1]",
          "expected_output": "[5,6]",
          "success": true,
          "output": "[5, 6]"
        },
        {
          "example_index": 1,
          "input": "nums = [1,1]",
          "expected_output": "[2]",
          "success": true,
          "output": "[2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode273.json",
    "problem_index_in_file": 0,
    "title": "Integer to English Words",
    "description_snippet": "Convert a non-negative integer num to its English words representation....",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nThe user requests: \"Use traditional Chinese. You are a virtual code generation assistant. Task: Based on user natural language, generate virtual code step by step with explanation, no real code, just structure. Format requires each line with virtual code step + space + // explanation. Use arrows, Start, End, Decision.\"\n\nUser says: \"使用者需求: Convert a non-negative integer num to its English words representation. Please generate virtual code and line-by-line explanation according to output format.\"\n\nSo produce algorithm pseudocode for number to English words. We must output step-by-step. Use Start, Decision, etc. Each line must have virtual code step, a space, and comment. We need to include arrow \"→\", \"Yes →\", \"No →\".\n\nLet's think about typical algorithm: handle zero, process billions, millions, thousands, hundreds. Use arrays of words. For each group of three digits, convert to words. But in pseudocode we can outline high-level. We'll produce steps: Start, check zero, define arrays, loop over groups, convert group to words, concatenate.\n\nWe need to produce each line with explanation. Let's produce maybe around 20 lines. Use indentation for decisions and loops.\n\nNeed to be careful with \"→ Decision:\" lines.\n\nWe can structure:\n\nStart // ...\n→ Decision: num == 0? // ...\n    Yes → Step: return 'Zero' // ...\n    No → Step: Define arrays // ...\n    → Step: Initialize result as empty // ...\n    → Step: Set divisor to 1, place names array // ...\n    → Step: While num > 0 // ...\n        → Step: current = num % 1000 // ...\n        → Decision: current != 0? // ...\n            Yes → Step: Convert current to words using helper // ...\n            → Step: Append place name if needed // ...\n            → Step: Prepend to result // ...\n            No → ... // skip\n        → Step: num = num / 1000 // ...\n    → Step: Return result trimmed // ...\nEnd // ...\n\nNeed to add comments.\n\nAlso maybe define helper for 0-999 conversion. Could create a subroutine.\n\nWe can produce pseudocode lines for helper:\n\n→ Subroutine: convertThreeDigits(n) // ...\n    → Decision: n == 0? // ...\n        Yes → Return '' // ...\n        No → ...\n        etc.\n\nBut maybe keep simpler.\n\nWe must not output actual code, just pseudocode.\n\nMake sure each line ends with // explanation.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: 若輸入 num 為 0? // 檢查數字是否為零  \n    Yes → Step: 回傳 'Zero' // 若為零，直接輸出  \n    No  → Step: 定義數字到英文單詞的對應表 // 建立 0~19、十位、千位等對應字串  \n        → Step: ones = ['Zero','One','Two','Three','Four','Five','Six','Seven','Eight','Nine','Ten','Eleven','Twelve','Thirteen','Fourteen','Fifteen','Sixteen','Seventeen','Eighteen','Nineteen']  \n        → Step: tens = ['', '', 'Twenty','Thirty','Forty','Fifty','Sixty','Seventy','Eighty','Ninety']  \n        → Step: thousands = ['', 'Thousand','Million','Billion']  \n→ Step: 初始化結果為空字串 // 用來累積最終英文表達  \n→ Step: 設定 currentPlace = 0 // 追蹤千位級別（0:無，1:千，2:萬，3:億）  \n→ Step: 設定 tempNum = num // 以便在迴圈中取餘數  \n→ Step: 進入迴圈 while tempNum > 0 // 逐個三位數處理  \n    → Step: current = tempNum % 1000 // 取目前三位數  \n    → Decision: current ≠ 0? // 若這三位數不為零  \n        Yes → Subroutine: convertThreeDigits(current) // 將三位數轉成單詞  \n            → Step: 定義 subResult 為空字串 // 本三位數的英文表達  \n            → Decision: current / 100 ≠ 0? // 檢查百位  \n                Yes → Step: subResult += ones[current / 100] + ' Hundred' // 加上百位單詞  \n                No  → // 無百位，略過  \n            → Step: remainder = current % 100 // 取得後兩位  \n            → Decision: remainder < 20? // 小於 20 直接使用 ones  \n                Yes → Step: subResult += ' ' + ones[remainder] // 加上對應單詞  \n                No  → Step: subResult += ' ' + tens[remainder / 10] // 加上十位單詞  \n                    → Decision: remainder % 10 ≠ 0? // 檢查個位  \n                        Yes → Step: subResult += ' ' + ones[remainder % 10] // 加上個位單詞  \n                        No  → // 無個位，略過  \n            → Step: return subResult.trim() // 回傳三位數的英文表達  \n        → Step: placeName = thousands[currentPlace] // 取得千位級別名稱  \n        → Step: newPart = convertThreeDigits(current) + (placeName ≠ '' ? ' ' + placeName : '') // 組合三位數與級別名稱  \n        → Step: result = newPart + (result ≠ '' ? ' ' + result : '') // 把新部分放到最前面，形成完整句子  \n    → Step: tempNum = tempNum / 1000 // 去掉已處理的三位數  \n    → Step: currentPlace += 1 // 移動到下一級別  \n→ Step: 回傳 result.trim() // 最終回傳英文文字，去除首尾空格  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def numberToWords(self, num: int) -> str:\n        if num == 0:\n            return \"Zero\"\n\n        def one(n: int) -> str:\n            return [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"][n]\n\n        def two_less_20(n: int) -> str:\n            return [\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\",\n                    \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"][n - 10]\n\n        def ten(n: int) -> str:\n            return [\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\",\n                    \"Seventy\", \"Eighty\", \"Ninety\"][n]\n\n        def two(n: int) -> str:\n            if n == 0:\n                return \"\"\n            if n < 10:\n                return one(n)\n            if n < 20:\n                return two_less_20(n)\n            t = n // 10\n            r = n % 10\n            return ten(t) + (\" \" + one(r) if r != 0 else \"\")\n\n        def three(n: int) -> str:\n            h = n // 100\n            r = n % 100\n            if h != 0 and r != 0:\n                return one(h) + \" Hundred \" + two(r)\n            if h == 0 and r != 0:\n                return two(r)\n            if h != 0 and r == 0:\n                return one(h) + \" Hundred\"\n            return \"\"\n\n        billion = num // 1_000_000_000\n        million = (num - billion * 1_000_000_000) // 1_000_000\n        thousand = (num - billion * 1_000_000_000 - million * 1_000_000) // 1_000\n        rest = num % 1_000\n\n        parts = []\n        if billion != 0:\n            parts.append(three(billion) + \" Billion\")\n        if million != 0:\n            parts.append(three(million) + \" Million\")\n        if thousand != 0:\n            parts.append(three(thousand) + \" Thousand\")\n        if rest != 0:\n            parts.append(three(rest))\n\n        return \" \".join(parts)\n\ndef main() -> None:\n    data = sys.stdin.read()\n    match = re.search(r'\\d+', data)\n    if not match:\n        return\n    num = int(match.group())\n    solution = Solution()\n    print(solution.numberToWords(num))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num = 123",
          "expected_output": "\"One Hundred Twenty Three\"",
          "success": true,
          "output": "One Hundred Twenty Three"
        },
        {
          "example_index": 1,
          "input": "num = 12345",
          "expected_output": "\"Twelve Thousand Three Hundred Forty Five\"",
          "success": true,
          "output": "Twelve Thousand Three Hundred Forty Five"
        },
        {
          "example_index": 2,
          "input": "num = 1234567",
          "expected_output": "\"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven\"",
          "success": true,
          "output": "One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode89.json",
    "problem_index_in_file": 0,
    "title": "Gray Code",
    "description_snippet": "An n-bit gray code sequence is a sequence of 2^n integers where:\n\nEvery integer is in the inclusive ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code steps for generating Gray code sequence for given n. Provide step-by-step with explanations. Use Start, End, Decision, arrow. No real code. Provide logic: use recursion or iterative reflect. Provide sequence. Let's design steps:\n\nStart\n→ Step 1: Read integer n // get input\n→ Decision: 如果 n == 0? // check trivial\n    Yes → Step 2: Output [0] // only sequence\n    No → Step 3: Initialize result list = [0] // start list\n    → Step 4: For i from 0 to n-1: // loop bits\n        → Step 5: currentSize = length of result // number of elements\n        → Step 6: For j from currentSize-1 down to 0: // reverse iterate\n            → Step 7: newVal = result[j] | (1 << i) // set i-th bit\n            → Step 8: Append newVal to result // extend sequence\n        → Step 9: End For // next bit\n    → Step 10: Output result // final sequence\nEnd\n\nWe need explanations inline. Use arrows etc. Should maintain indent with arrow for decisions. Provide explanation after each line. Also we might add note that result is Gray code. Provide final. Use Start/End. Each line: `虛擬碼步驟 // 解釋`. Let's craft.\n\nWe must include \"→\" arrows. For Decision, show indentation with arrow and Yes/No. Let's format accordingly. Use the sample style.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: 輸入 n // 從使用者處取得位數\n→ Decision: n 等於 0? // 檢查是否為 0 位 Gray 代碼\n    Yes → Step 2: 輸出 [0] // 只有一個數字 0\n    No  → Step 3: 初始化 result = [0] // 開始序列\n    → Step 4: 從 i = 0 到 n-1 迴圈 // 每次處理一個位元\n        → Step 5: currentSize = result.length // 目前序列長度\n        → Step 6: 從 j = currentSize-1 到 0 反向迴圈 // 反向取\n            → Step 7: newVal = result[j] | (1 << i) // 在第 i 位設定 1\n            → Step 8: 將 newVal 加入 result // 延長序列\n        → Step 9: 迴圈結束 // 完成一個位元\n    → Step 10: 輸出 result // 輸出完整 Gray 代碼序列\nEnd // 程式執行結束\n\nMake sure formatting: Each line with arrow or indent. Use \"→\" at each step. For decision, indent inside. Provide explanation after each line. Ensure each line has space between code and comment. Use the same style as sample.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入 n // 從使用者處取得位數  \n→ Decision: n 等於 0? // 檢查是否為 0 位 Gray 代碼  \n  Yes → Step 2: 輸出 [0] // 只有一個數字 0  \n  No  → Step 3: 初始化 result = [0] // 開始序列  \n    → Step 4: 從 i = 0 到 n-1 迴圈 // 每次處理一個位元  \n     → Step 5: currentSize = result.length // 目前序列長度  \n     → Step 6: 從 j = currentSize-1 到 0 反向迴圈 // 反向取  \n      → Step 7: newVal = result[j] | (1 << i) // 在第 i 位設定 1  \n      → Step 8: 將 newVal 加入 result // 延長序列  \n     → Step 9: 迴圈結束 // 完成一個位元  \n    → Step 10: 輸出 result // 輸出完整 Gray 代碼序列  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef gray_code(n: int) -> list[int]:\n    \"\"\"產生 n 位 Gray 代碼序列\"\"\"\n    result = [0]\n    for i in range(n):\n        add = 1 << i\n        # 取目前序列的逆序，加上第 i 位的 1\n        result += [x + add for x in reversed(result)]\n    return result\n\ndef main() -> None:\n    # 從標準輸入取得整數 n，支援類似 \"n = 2\" 的格式\n    data = sys.stdin.read()\n    match = re.search(r'\\d+', data)\n    n = int(match.group()) if match else 0\n\n    seq = gray_code(n)\n    print(seq)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 2",
          "expected_output": "[0,1,3,2]",
          "success": true,
          "output": "[0, 1, 3, 2]"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "[0,1]",
          "success": true,
          "output": "[0, 1]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode16.json",
    "problem_index_in_file": 0,
    "title": "3Sum Closest",
    "description_snippet": "Given an integer array nums of length n and an integer target, find three integers in nums such that...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm: given array nums, target, find 3 sum closest. Classic solution: sort array, then for each i fix first element, then two pointers left/right to find best. So produce step-by-step virtual code with Start, End, Decision, etc. Provide explanation for each line. Use arrow arrows. Format: each line \"虛擬碼步驟 // 解釋\". Ensure each step in order. Include Start, End, loops, decisions.\n\nWe need \"逐行\" output. Each line must contain \"虛擬碼步驟\" + space + \"// 解釋\". So we must produce lines like \"Start // 程式開始執行\". Then arrow lines with steps.\n\nMake sure to include the sorting step, initial best sum set to sum of first three elements. Then outer loop i from 0 to n-3. Then set left=i+1, right=n-1. While left<right: compute current sum, update best if closer. If current sum==target: return target. Else if current sum<target: left++ else right--. Continue.\n\nSo produce each step line. Use \"→\" arrows for steps. For Decision, use \"Decision: ...?\".\n\nLet's produce.\n\nEnsure \"虛擬碼步驟\" includes arrow and colon.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort the array nums in ascending order // 先將數組排序以便使用雙指針技巧  \n→ Step 2: Initialize bestSum = nums[0] + nums[1] + nums[2] // 設定初始最接近的和為前三個元素之和  \n→ Step 3: For i from 0 to n-3 do // 外層循環固定第一個數字  \n    → Step 4: Set left = i + 1, right = n - 1 // 設定左指針與右指針  \n    → Decision: While left < right? // 只要左指針在右指針左側就繼續搜尋  \n        Yes → Step 5: currentSum = nums[i] + nums[left] + nums[right] // 計算三數之和  \n        → Decision: |currentSum - target| < |bestSum - target|? // 比較目前和與最佳和距離的差值  \n            Yes → Step 6: bestSum = currentSum // 若更接近目標則更新最佳和  \n            No  → // 保持現有最佳和  \n        → Decision: currentSum == target? // 若正好等於目標，已是最優答案  \n            Yes → Step 7: Return target // 返回結果，直接結束  \n            No  → Decision: currentSum < target? // 判斷方向以調整指針  \n                Yes → Step 8: left = left + 1 // 和小於目標，右移左指針以增大和  \n                No  → Step 9: right = right - 1 // 和大於目標，左移右指針以減小和  \n        → Step 10: Continue while loop // 返回 while 條件判斷  \n    → Step 11: Continue for loop // 返回外層循環  \n→ Step 12: Return bestSum // 所有循環結束後返回最接近的和  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        Find the sum of three integers in nums that is closest to target.\n        \"\"\"\n        nums.sort()\n        n = len(nums)\n        # 初始最接近的和設為前3個元素之和\n        best_sum = nums[0] + nums[1] + nums[2]\n\n        for i in range(n - 2):\n            left, right = i + 1, n - 1\n            while left < right:\n                current_sum = nums[i] + nums[left] + nums[right]\n                # 更新最接近的和\n                if abs(current_sum - target) < abs(best_sum - target):\n                    best_sum = current_sum\n\n                if current_sum == target:\n                    return target\n                elif current_sum < target:\n                    left += 1\n                else:\n                    right -= 1\n\n        return best_sum\n\n\ndef parse_input(input_str):\n    \"\"\"\n    從輸入字串中解析出 nums 列表和 target 整數。\n    支援類似 'nums = [-1,2,1,-4], target = 1' 的格式。\n    \"\"\"\n    nums_match = re.search(r'nums\\s*=\\s*\\[([^\\]]*)\\]', input_str)\n    target_match = re.search(r'target\\s*=\\s*(-?\\d+)', input_str)\n\n    if nums_match:\n        nums_str = nums_match.group(1)\n        nums = [int(x.strip()) for x in nums_str.split(',') if x.strip()]\n    else:\n        nums = []\n\n    target = int(target_match.group(1)) if target_match else 0\n    return nums, target\n\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取資料\n    raw_input = sys.stdin.read()\n    nums, target = parse_input(raw_input)\n\n    # 處理並輸出結果\n    solution = Solution()\n    result = solution.threeSumClosest(nums, target)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [-1,2,1,-4], target = 1",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "nums = [0,0,0], target = 1",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode65.json",
    "problem_index_in_file": 0,
    "title": "Valid Number",
    "description_snippet": "Given a string s, return whether s is a valid number.\n\nFor example, all the following are valid numb...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code steps for validating string s as number. Must produce line by line with arrow notation etc. So basically produce algorithm: trim whitespace, check sign, parse integer part, optional dot, fractional, optional exponent. We need to produce pseudocode. Use arrows and decision structure. Must include each line explanation. No actual code. Use \"Start\", \"End\". Use decision lines with Yes → and No →.\n\nLet's craft steps:\n\nStart\n\n→ Step 1: Trim leading and trailing whitespace from s // Remove spaces\n\n→ Decision: If s is empty? // If empty string not valid\n\nYes → Step 2: Return false // No valid number\n\nNo → Step 3: Initialize index i = 0 // Pointer\n\n→ Step 4: If s[i] is '+' or '-' → i++ // skip sign\n\n→ Step 5: Initialize hasDigitsBeforeDot = false, hasDigitsAfterDot = false, hasDot = false, hasExponent = false\n\n→ Decision: If i < len and s[i] is digit? // Check digits before dot\n\nYes → Step 6: While i < len and s[i] is digit → i++ ; hasDigitsBeforeDot=true\n\nNo → Step 7: // none yet\n\n→ Step 8: Decision: If i < len and s[i] == '.'? // decimal point\n\nYes → Step 9: hasDot=true ; i++ // consume dot\n\nNo → Step 10: // no dot\n\n→ Decision: If !hasDigitsBeforeDot? // need digits either side\n\nYes → Step 11: Return false // no digits anywhere\n\nNo → Step 12: // proceed\n\n→ Step 13: If hasDot? // we already consumed dot\n\nYes → Decision: If i < len and s[i] is digit? // digits after dot\n\nYes → Step 14: While i < len and s[i] is digit → i++ ; hasDigitsAfterDot=true\n\nNo → Step 15: // no digits after dot\n\nNo → Step 16: // continue\n\n→ Step 17: Decision: If hasDot and !hasDigitsBeforeDot and !hasDigitsAfterDot? // only dot no digits\n\nYes → Step 18: Return false // invalid\n\nNo → Step 19: // proceed\n\n→ Step 20: Decision: If i < len and (s[i]=='e' or 'E')? // exponent\n\nYes → Step 21: hasExponent=true ; i++ // consume e\n\nYes → Step 22: If i < len and (s[i]=='+' or '-') → i++ // optional exponent sign\n\nYes → Step 23: Decision: If i < len and s[i] is digit? // at least one digit in exponent\n\nYes → Step 24: While i < len and s[i] is digit → i++ // consume exponent digits\n\nNo → Step 25: Return false // exponent without digits\n\nNo → Step 26: // no more e/E\n\nNo → Step 27: // after parsing\n\n→ Decision: If i != len? // extra characters\n\nYes → Step 28: Return false // invalid\n\nNo → Step 29: Return true // valid number\n\nEnd\n\nNeed to format lines with arrow and explanation. Provide comments after space. Use \"→ Step X:\" etc.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: s ← Trim(s) // 移除字串前後空白\n→ Decision: s 为空? // 檢查是否為空字串\n    Yes → Step 2: Return false // 空字串不是有效數字\n    No  → Step 3: i ← 0 // 建立指標\n→ Step 4: If s[i] 是 '+' 或 '-'? // 處理符號\n    Yes → i ← i + 1 // 跳過符號\n    No  →\n→ Step 5: hasDigitsBeforeDot ← false\n→ Step 6: hasDigitsAfterDot ← false\n→ Step 7: hasDot ← false\n→ Step 8: hasExponent ← false\n→ Decision: i < len(s) 且 s[i] 是數字? // 數字前綴\n    Yes → Step 9: While i < len(s) 且 s[i] 是數字: i ← i + 1; hasDigitsBeforeDot ← true // 讀取整數部分\n    No  →\n→ Step 10: Decision: i < len(s) 且 s[i] == '.'? // 是否有小數點\n    Yes → Step 11: hasDot ← true; i ← i + 1 // 消耗小數點\n    No  →\n→ Decision: (hasDigitsBeforeDot == false) 且 (hasDot == false)? // 沒有任何數字且沒有小數點\n    Yes → Step 12: Return false // 必須至少有一個數字\n    No  →\n→ Decision: hasDot? // 若有小數點，處理小數部分\n    Yes →\n        → Decision: i < len(s) 且 s[i] 是數字? // 小數點後有數字\n            Yes → Step 13: While i < len(s) 且 s[i] 是數字: i ← i + 1; hasDigitsAfterDot ← true // 讀取小數部分\n            No  →\n        → Decision: !hasDigitsBeforeDot 且 !hasDigitsAfterDot? // 只有小數點，沒有數字\n            Yes → Step 14: Return false // 失效\n            No  →\n    No  →\n→ Decision: i < len(s) 且 (s[i] == 'e' 或 s[i] == 'E')? // 是否有指數符號\n    Yes →\n        → Step 15: hasExponent ← true; i ← i + 1 // 消耗 e/E\n        → Decision: i < len(s) 且 (s[i] == '+' 或 s[i] == '-')? // 指數符號\n            Yes → i ← i + 1 // 跳過符號\n            No  →\n        → Decision: i < len(s) 且 s[i] 是數字? // 指數至少一個數字\n            Yes →\n                → Step 16: While i < len(s) 且 s[i] 是數字: i ← i + 1 // 讀取指數數字\n            No  → Step 17: Return false // 指數缺乏數字\n    No  →\n→ Decision: i != len(s)? // 有剩餘未處理字符\n    Yes → Step 18: Return false // 其他非法字符\n    No  →\n→ Step 19: Return true // 字串符合數字格式\nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def isNumber(self, s: str) -> bool:\n        \"\"\"\n        判斷字串是否為合法數字。邏輯遵循題目描述：\n        1. 先去除前後空白。\n        2. 逐字檢查，保持三個旗標：\n           - num_seen   : 至少看到一個數字\n           - dot_seen   : 小數點已出現\n           - e_seen     : 指數符號已出現\n        3. 依序判斷各個字符類型：\n           - 數字：標記 num_seen\n           - '.'：若已出現小數點或指數符號則失效；否則標記 dot_seen\n           - 'e'/'E'：若已出現指數符號或尚未看到數字則失效；否則標記 e_seen 並重置 num_seen\n           - '+'/'-'：若不在字串開頭且前一字符不是 'e'/'E'，則失效\n           - 其餘：失效\n        4. 最後若仍有未讀完字符則失效；否則依 num_seen 判斷結果。\n        \"\"\"\n        s = s.strip()\n        if not s:\n            return False\n\n        num_seen = False\n        dot_seen = False\n        e_seen = False\n\n        for i, ch in enumerate(s):\n            if ch.isdigit():\n                num_seen = True\n            elif ch == '.':\n                if dot_seen or e_seen:\n                    return False\n                dot_seen = True\n            elif ch in ('e', 'E'):\n                if e_seen or not num_seen:\n                    return False\n                e_seen = True\n                num_seen = False\n            elif ch in ('+', '-'):\n                if i != 0 and s[i - 1] not in ('e', 'E'):\n                    return False\n            else:\n                return False\n\n        return num_seen\n\n\ndef parse_input(raw: str) -> str:\n    \"\"\"\n    從 raw 讀取輸入，支持以下兩種格式：\n    1. s = \"...\"          例如: s = \"0\"\n    2. 直接給字串，例如: 0\n    \"\"\"\n    raw = raw.strip()\n    if not raw:\n        return \"\"\n\n    # 若包含 s = 前綴，嘗試找雙引號\n    if raw.lower().startswith(\"s =\"):\n        start = raw.find('\"')\n        end = raw.rfind('\"')\n        if start != -1 and end != -1 and start < end:\n            return raw[start + 1:end]\n    # 否則直接返回去除雙引號的內容（若有）\n    if raw.startswith('\"') and raw.endswith('\"'):\n        return raw[1:-1]\n    return raw\n\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    s = parse_input(raw_input)\n    sol = Solution()\n    result = sol.isNumber(s)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"0\"",
          "expected_output": "True",
          "success": true,
          "output": "True"
        },
        {
          "example_index": 1,
          "input": "s = \"e\"",
          "expected_output": "False",
          "success": true,
          "output": "False"
        },
        {
          "example_index": 2,
          "input": "s = \".\"",
          "expected_output": "False",
          "success": true,
          "output": "False"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode121.json",
    "problem_index_in_file": 0,
    "title": "Best Time to Buy and Sell Stock",
    "description_snippet": "You are given an array prices where prices[i] is the price of a given stock on the ith day.\n\nYou wan...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the problem: given array prices, find max profit of one buy-sell transaction, or 0. Provide each line with \"虛擬碼步驟 // 解釋\".\n\nWe need to produce algorithm steps: initialize min_price = +infinity, max_profit=0; iterate through prices; update min_price, update max_profit. Then return max_profit.\n\nWe need start, decision, etc. Let's produce lines accordingly.\n\nMake sure to use the arrow notation: \"→ Step ...\" and decisions with Yes/No.\n\nLet's output each line in order. Use Chinese comments. Ensure the format: each line: \"虛擬碼步驟 // 解釋\" with a space between code and comment. The code can be pseudo: Start, End, Step 1, Decision, etc. Use arrow. So produce something like:\n\nStart // 程式開始\n\n→ Step 1: Initialize min_price = Infinity, max_profit = 0 // 設定初始值\n\n→ Step 2: For each price in prices // 遍歷所有價格\n\n   → Decision: price < min_price? // 檢查是否找到更低的買入價\n\n       Yes → Step 3: min_price = price // 更新最低買入價\n\n       No → No action\n\n   → Decision: price - min_price > max_profit? // 檢查是否可獲得更高利潤\n\n       Yes → Step 4: max_profit = price - min_price // 更新最大利潤\n\n       No → No action\n\n→ Step 5: Return max_profit // 回傳最大利潤\n\nEnd // 程式結束\n\nBut note we need to use arrows only at top-level? We can indent substeps? Probably just one level. Use nested decisions? We can produce as above but with indentation to show nested steps. Provide each line individually. Should we include spaces between arrow and code? Yes \"→\". And \"Decision:\".\n\nLet's produce each line exactly. Also, after each decision we need Yes → and No → lines as separate lines. So produce like:\n\nStart // 程式開始\n\n→ Step 1: 初始化 min_price = +∞, max_profit = 0 // 設定初始值\n\n→ Step 2: 循環遍歷 prices[i] // 遍歷每一天的價格\n\n   → Decision: prices[i] < min_price? // 檢查今天是否是新的最低買入價\n\n       Yes → Step 3: min_price = prices[i] // 更新最低買入價\n\n       No → // 無需更新\n\n   → Decision: prices[i] - min_price > max_profit? // 檢查今天是否能獲得更高利潤\n\n       Yes → Step 4: max_profit = prices[i] - min_price // 更新最大利潤\n\n       No → // 無需更新\n\n→ Step 5: 回傳 max_profit // 結束並返回最大利潤\n\nEnd // 程式結束\n\nBut we need each line separately, no indentation? The example shows indentation but still separate lines.\n\nWe can produce:\n\nStart // 程式開始\n\n→ Step 1: 初始化 min_price = +∞, max_profit = 0 // 設定初始值\n\n→ Step 2: 循環遍歷 prices[i] // 遍歷每一天的價格\n\n→ Decision: prices[i] < min_price? // 檢查今天是否是新的最低買入價\n\n    Yes → Step 3: min_price = prices[i] // 更新最低買入價\n\n    No  → // 無需更新\n\n→ Decision: prices[i] - min_price > max_profit? // 檢查今天是否能獲得更高利潤\n\n    Yes → Step 4: max_profit = prices[i] - min_price // 更新最大利潤\n\n    No  → // 無需更新\n\n→ Step 5: 回傳 max_profit // 結束並返回最大利潤\n\nEnd // 程式結束\n\nWe should ensure that each line is a separate line; the arrow lines with \"Yes →\" and \"No →\" as separate lines.\n\nLet's produce that. Ensure Chinese comments.\n\nProceed.\n...done thinking.\n\nStart // 程式開始\n→ Step 1: 初始化 min_price = +∞, max_profit = 0 // 設定初始值\n→ Step 2: 循環遍歷 prices[i] // 遍歷每一天的價格\n→ Decision: prices[i] < min_price? // 檢查今天是否為新的最低買入價\n    Yes → Step 3: min_price = prices[i] // 更新最低買入價\n    No  → // 無需更新\n→ Decision: prices[i] - min_price > max_profit? // 檢查今天是否能獲得更高利潤\n    Yes → Step 4: max_profit = prices[i] - min_price // 更新最大利潤\n    No  → // 無需更新\n→ Step 5: 回傳 max_profit // 結束並返回最大利潤\nEnd // 程式結束",
      "generated_code": "import sys\nimport ast\n\ndef max_profit(prices):\n    if not prices:\n        return 0\n    min_price = prices[0]\n    max_profit = 0\n    for price in prices[1:]:\n        if price - min_price > max_profit:\n            max_profit = price - min_price\n        if price < min_price:\n            min_price = price\n    return max_profit\n\ndef main():\n    data = sys.stdin.read()\n    if not data:\n        return\n    data = data.strip()\n    # 將輸入中等號後的部分取出，如果沒有等號則直接使用整段\n    if '=' in data:\n        _, list_part = data.split('=', 1)\n    else:\n        list_part = data\n    list_part = list_part.strip()\n    try:\n        prices = ast.literal_eval(list_part)\n    except Exception:\n        try:\n            prices = list(map(int, list_part.split()))\n        except Exception:\n            prices = []\n    result = max_profit(prices)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "prices = [7,1,5,3,6,4]",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "prices = [7,6,4,3,1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode44.json",
    "problem_index_in_file": 0,
    "title": "Wildcard Matching",
    "description_snippet": "Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for wildcard pattern matching. Provide steps line by line with explanations. Use Start, Decision, etc. We'll need to parse input string s and pattern p, dynamic programming approach. We can present algorithm: use DP table dp[i][j] meaning s prefix length i matches p prefix length j. Initialize dp[0][0] = true. Then for j>0 if p[j-1]=='*' dp[0][j] = dp[0][j-1]. Then iterate i=1..len(s) j=1..len(p). If p[j-1]==s[i-1] or '?' then dp[i][j]=dp[i-1][j-1]; else if p[j-1]=='*' dp[i][j]=dp[i-1][j] or dp[i][j-1]; else false. After loops return dp[m][n]. We can present this as virtual steps.\n\nLet's produce step lines.\n\nWe need to use virtual code with arrow. Use \"→\" for step, \"Decision:\" for decisions. Use Start, End. For loops, maybe Decision: \"i < m\" etc. Provide explanation. Provide each line.\n\nWill produce:\n\nStart\n→ Step 1: let m = length of s, n = length of p // 取得字串長度\n→ Step 2: create 2D boolean array dp[0..m][0..n] // DP表\n→ Step 3: set dp[0][0] = true // 空字串與空模式相符\n→ Decision: 如果 n > 0? // 檢查模式是否非空\n    Yes → For j from 1 to n:\n        → Decision: 如果 p[j-1] == '*'? // 只要前面是星號\n            Yes → dp[0][j] = dp[0][j-1] // 允許空字串匹配\n            No  → dp[0][j] = false // 其他字符不匹配空字串\n        End For\n    No  → // 無操作\n→ Step 4: For i from 1 to m:\n    → Step 5: For j from 1 to n:\n        → Decision: 如果 p[j-1] == s[i-1] 或 p[j-1] == '?'? // 直接匹配\n            Yes → dp[i][j] = dp[i-1][j-1] // 取前一個子問題\n            No  → Decision: 如果 p[j-1] == '*'? // 星號處理\n                Yes → dp[i][j] = dp[i-1][j] OR dp[i][j-1] // 兩種擴展方式\n                No  → dp[i][j] = false // 不匹配\n        End Decision\n    End For\nEnd For\n→ Step 6: return dp[m][n] // 完整匹配結果\n\nBut need to keep each line as \"虛擬碼步驟 // 解釋\" with arrow and spaces.\n\nMake sure each line uses \"→\" or \"Decision:\" accordingly. Might include loops as steps.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: let m = length of s, n = length of p // 取得輸入字串與模式的長度  \n→ Step 2: create 2D boolean array dp[0..m][0..n] // 初始化動態規劃表  \n→ Step 3: set dp[0][0] = true // 空字串與空模式相符  \n→ Decision: 如果 n > 0? // 檢查模式是否非空  \n    Yes → For j = 1 to n:  \n        → Decision: 如果 p[j-1] == '*'? // 只要前面是星號  \n            Yes → dp[0][j] = dp[0][j-1] // 允許空字串匹配  \n            No  → dp[0][j] = false // 其他字符不匹配空字串  \n        End Decision  \n    End For  \n    No  → // 無需處理  \n→ Step 4: For i = 1 to m:  \n    → Step 5: For j = 1 to n:  \n        → Decision: 如果 p[j-1] == s[i-1] 或 p[j-1] == '?'? // 直接字符匹配或問號  \n            Yes → dp[i][j] = dp[i-1][j-1] // 取前一個子問題結果  \n            No  → Decision: 如果 p[j-1] == '*'? // 星號處理  \n                Yes → dp[i][j] = dp[i-1][j] OR dp[i][j-1] // * 可以匹配一個或多個字符  \n                No  → dp[i][j] = false // 無法匹配  \n            End Decision  \n        End Decision  \n    End For  \nEnd For  \n→ Step 6: return dp[m][n] // 回傳整個字串是否符合模式  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef is_match(s: str, p: str) -> bool:\n    \"\"\"Wildcard pattern matching with '?' and '*'.\n    \n    '?' matches any single character.\n    '*' matches any sequence of characters (including empty).\n    The entire string s must be matched by pattern p.\n    \"\"\"\n    m, n = len(s), len(p)\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n\n    # Patterns that can match an empty string\n    for j in range(1, n + 1):\n        if p[j - 1] == '*':\n            dp[0][j] = dp[0][j - 1]\n\n    # Fill the DP table\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if p[j - 1] == s[i - 1] or p[j - 1] == '?':\n                dp[i][j] = dp[i - 1][j - 1]\n            elif p[j - 1] == '*':\n                dp[i][j] = dp[i][j - 1] or dp[i - 1][j]\n            else:\n                dp[i][j] = False\n    return dp[m][n]\n\n\ndef parse_input(data: str) -> tuple[str, str]:\n    \"\"\"Parse input that may look like:\n    \n        s = \"aa\", p = \"a\"\n    \n    or it may be two separate lines:\n    \n        aa\n        a\n    \"\"\"\n    data = data.strip()\n    # Try the quoted format first\n    m = re.search(r's\\s*=\\s*\"([^\"]*)\"\\s*,\\s*p\\s*=\\s*\"([^\"]*)\"', data)\n    if m:\n        return m.group(1), m.group(2)\n\n    # Try two lines\n    lines = [line.strip() for line in data.splitlines() if line.strip()]\n    if len(lines) >= 2:\n        return lines[0], lines[1]\n\n    # As a last resort, split by whitespace\n    parts = data.split()\n    if len(parts) >= 2:\n        return parts[0], parts[1]\n\n    return \"\", \"\"\n\n\nif __name__ == \"__main__\":\n    raw = sys.stdin.read()\n    s, p = parse_input(raw)\n    result = is_match(s, p)\n    # Output lowercase 'true'/'false' as required\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"aa\", p = \"a\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 1,
          "input": "s = \"aa\", p = \"*\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "s = \"cb\", p = \"?a\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode216.json",
    "problem_index_in_file": 0,
    "title": "Combination Sum III",
    "description_snippet": "Find all valid combinations of k numbers that sum up to n such that the following conditions are tru...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code algorithm for generating combinations of numbers 1-9, each at most once, summing to target n, with size k. Essentially combinations of length k from 1-9 summing to n. We must output virtual code lines with explanations.\n\nWe need to use Start, End, Decision, Steps, arrows.\n\nWe must produce step-by-step pseudo code. Likely use recursion/backtracking. Let's produce:\n\nStart\n→ Step 1: Initialize result list // create list for combinations\n→ Step 2: Define recursive function backtrack(start, k_remaining, current_sum, current_combination) // helper\n→ Decision: If k_remaining == 0 and current_sum == n? // base case\n  Yes → Step 3: Append a copy of current_combination to result // add valid combination\n  No  → Decision: If k_remaining == 0 or current_sum > n or start > 9? // prune\n        Yes → Step 4: Return // dead end\n        No  → Step 5: For i from start to 9 // iterate remaining numbers\n            Decision: If current_sum + i > n? // skip if sum too large\n                Yes → Step 6: Continue // skip to next i\n                No  → Step 7: Append i to current_combination // choose i\n                Step 8: backtrack(i+1, k_remaining-1, current_sum+i, current_combination) // recurse\n                Step 9: Remove last element from current_combination // backtrack\nEnd\n\nBut we must include comments. Also we need to include at start: input n and k. So Step 0: Input n, k.\n\nAlso after recursion, Step final: Return result.\n\nLet's produce with arrow lines. Use indentation? They show with arrow for each step. Use Step 1, Step 2 etc. Might be enough.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 0: 接收輸入 n 和 k // 目標和與組合長度\n→ Step 1: 建立空列表 result // 儲存所有有效組合\n→ Step 2: 定義遞迴函式 backtrack(start, remaining_k, current_sum, current_combo) // backtracking helper\n→ Step 3: 內部邏輯: if remaining_k == 0 and current_sum == n then // 找到合法組合\n    Yes → Step 4: 把 current_combo 的複本加入 result // 記錄結果\n    No  → Step 5: if remaining_k == 0 or current_sum > n or start > 9 then // 不可能再擴展\n        Yes → Step 6: return // 結束此路徑\n        No  → Step 7: for i in range(start, 10) // 1~9\n            Decision: if current_sum + i > n then // 超過目標和\n                Yes → Step 8: continue // 跳過此 i\n                No  → Step 9: current_combo.append(i) // 選擇 i\n                Step 10: backtrack(i+1, remaining_k-1, current_sum+i, current_combo) // 深入遞迴\n                Step 11: current_combo.pop() // 回溯移除 i\n→ Step 12: 呼叫 backtrack(1, k, 0, []) // 從 1 開始尋找\n→ Step 13: return result // 回傳所有組合\nEnd // 程式執行結束\n\nBut we need to align with formatting: Each line should be \"虛擬碼步驟 [space] // 解釋\". Use \"→\" at start of step lines. Use \"Decision:\" for decision. Use indentation with arrow. For decisions, we can indent Yes / No lines as shown. Let's produce final answer accordingly. Use Chinese comments.\n\nLet's output each line exactly with virtual code arrow. Ensure to have proper indentation using tabs or spaces? They used example with spaces after arrow. We'll use the same.\n\nLet's write.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 0: 接收輸入 n 與 k // 目標和與組合長度\n→ Step 1: 建立空列表 result // 儲存所有合法組合\n→ Step 2: 定義遞迴函式 backtrack(start, remaining_k, current_sum, current_combo) // backtracking 助手\n→ Step 3:     Decision: 是否剩餘 k 為 0 且 current_sum 等於 n? // 基本結束條件\n        Yes → Step 4: 把 current_combo 的複本加入 result // 記錄一組有效答案\n        No  → Step 5: Decision: 是否無法繼續擴展? // 判斷終止條件\n            Yes → Step 6: return // 跳出此分支\n            No  → Step 7: for i 在 start 到 9 之間 // 嘗試選取每個可用數字\n                Decision: current_sum + i 是否大於 n? // 先檢查是否會超過目標\n                    Yes → Step 8: continue // 跳過此 i\n                    No  → Step 9: current_combo.append(i) // 選取 i\n                    Step 10: backtrack(i+1, remaining_k-1, current_sum+i, current_combo) // 深入遞迴\n                    Step 11: current_combo.pop() // 回溯，移除剛才加入的 i\n→ Step 12: 呼叫 backtrack(1, k, 0, []) // 從數字 1 開始搜尋\n→ Step 13: return result // 回傳所有符合條件的組合\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def combinationSum3(self, k: int, n: int):\n        \"\"\"\n        Find all unique combinations of k numbers from 1 to 9 that sum to n.\n        Each number is used at most once.\n        \"\"\"\n        res = []\n\n        def backtrack(start: int, path: list[int], total: int):\n            # 基本結束條件：已選 k 個數字\n            if len(path) == k:\n                if total == n:\n                    res.append(path[:])  # 找到合法組合，複製加入結果\n                return\n\n            # 若已超過目標和或無法再選足夠數字，直接返回\n            if total > n:\n                return\n\n            # 從 start 開始嘗試選取剩餘的數字\n            for i in range(start, 10):\n                if total + i > n:   # 若加入 i 會超過 n，則跳過\n                    continue\n                path.append(i)          # 選擇 i\n                backtrack(i + 1, path, total + i)  # 進行遞迴\n                path.pop()            # 回溯，移除剛才加入的 i\n\n        backtrack(1, [], 0)\n        return res\n\ndef main():\n    # 從 stdin 讀取整個輸入字串\n    data = sys.stdin.read()\n    # 使用正則表達式抓取所有數字\n    nums = list(map(int, re.findall(r'\\d+', data)))\n    if len(nums) < 2:\n        return  # 若輸入不足，直接結束\n    k, n = nums[0], nums[1]\n\n    sol = Solution()\n    result = sol.combinationSum3(k, n)\n    print(result)  # 直接輸出結果列表\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "k = 3, n = 7",
          "expected_output": "[[1,2,4]]",
          "success": true,
          "output": "[[1, 2, 4]]"
        },
        {
          "example_index": 1,
          "input": "k = 3, n = 9",
          "expected_output": "[[1,2,6],[1,3,5],[2,3,4]]",
          "success": true,
          "output": "[[1, 2, 6], [1, 3, 5], [2, 3, 4]]"
        },
        {
          "example_index": 2,
          "input": "k = 4, n = 1",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode126.json",
    "problem_index_in_file": 0,
    "title": "Word Ladder II",
    "description_snippet": "A transformation sequence from word beginWord to word endWord using a dictionary wordList is a seque...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code lines with arrows and explanation. This is typical BFS + backtracking to find all shortest paths. Provide steps: Start, Build adjacency, BFS to record levels, track parents mapping, then DFS or backtracking from endWord to beginWord building sequences, return list.\n\nNeed to write each step line by line with comments. Use arrows. Let's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 將 wordList 轉成 Set wordsSet 以便 O(1) 查詢 // 建立快速查詢集合\n→ Decision: 是否存在 endWord 在 wordsSet? // 檢查目標詞是否在字典中\n    Yes → Continue\n    No  → Step 2: 回傳空列表 [] // 沒有可能完成轉換\n→ Step 3: 建立空字典 parents: word → List[previous words] // 用於記錄每個單字的前驅\n→ Step 4: 建立空集合 visited: Set[words] // 記錄已被 BFS 訪問過的單字\n→ Step 5: 建立 queue Q，並加入 (beginWord, 0) // (單字, 級別) 的元組，開始 BFS\n→ Step 6: 進行 BFS，直到 Q 為空或已找到 endWord 的最短層級\n    → While Q not empty:\n        → Step 7: 取出前端元素 (current, level)\n        → Decision: 是否已找到最短路徑且 level > minLevel? // 若已完成且現在級別更深則結束\n            Yes → Break\n            No  →\n                → Decision: 是否將 current 加入 visited? // 避免重複處理\n                    Yes → Continue\n                    No  → Step 8: visited.add(current) // 標記已訪問\n                → Decision: current == endWord? // 是否到達目標\n                    Yes →\n                        → Step 9: 設定 minLevel = level // 記錄最短層級\n                    No  →\n                        → Step 10: 產生所有相鄰單字 nextWord 只差一個字母且在 wordsSet 且未在 visited\n                        → For each nextWord:\n                            → Decision: nextWord 是否已在 parents? // 若無需再建立\n                                Yes → Step 11: parents[nextWord].append(current) // 加入前驅\n                                No  → Step 12: parents[nextWord] = [current] // 建立前驅列表\n                            → Step 13: Q.enqueue((nextWord, level+1)) // 加入下一層級\n→ Decision: minLevel 是否為 None? // 若 BFS 沒有找到 endWord\n    Yes → Step 14: 回傳空列表 [] // 沒有可行序列\n    No  →\n        → Step 15: 建立結果列表 results = []\n        → Step 16: 定義遞迴函式 backtrack(currentWord, path)\n            → Decision: currentWord == beginWord? // 回到起始詞\n                Yes → Step 17: results.append(path[::-1]) // 反轉為正向順序並加入結果\n                No  →\n                    → Step 18: 對於每個 prevWord in parents[currentWord]:\n                        → Step 19: backtrack(prevWord, path + [prevWord]) // 遞迴向前推\n        → Step 20: 呼叫 backtrack(endWord, [endWord]) // 從 endWord 開始回溯\n        → Step 21: 回傳 results // 所有最短轉換序列\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict, deque\n\nclass Solution:\n    def findLadders(self, beginWord, endWord, wordList):\n        wordSet = set(wordList)\n        if endWord not in wordSet:\n            return []\n\n        # BFS 找最短距離，紀錄每個單詞的前驅節點\n        layer = {}\n        layer[beginWord] = 0\n        parents = defaultdict(list)\n\n        queue = deque([beginWord])\n        while queue:\n            word = queue.popleft()\n            step = layer[word]\n            for i in range(len(word)):\n                for c in 'abcdefghijklmnopqrstuvwxyz':\n                    new_word = word[:i] + c + word[i+1:]\n                    if new_word in wordSet:\n                        if new_word not in layer:\n                            layer[new_word] = step + 1\n                            queue.append(new_word)\n                            parents[new_word].append(word)\n                        elif layer[new_word] == step + 1:\n                            parents[new_word].append(word)\n\n        res = []\n\n        def dfs(path, word):\n            if word == beginWord:\n                res.append(path[::-1])\n                return\n            for prev in parents[word]:\n                dfs(path + [prev], prev)\n\n        if endWord in parents:\n            dfs([endWord], endWord)\n\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # 將輸入包成字典字串以便解析\n    data = \"{\" + data + \"}\"\n    params = ast.literal_eval(data)\n    beginWord = params[\"beginWord\"]\n    endWord = params[\"endWord\"]\n    wordList = params[\"wordList\"]\n\n    solution = Solution()\n    result = solution.findLadders(beginWord, endWord, wordList)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
          "expected_output": "[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpz6jn_uzn.py\", line 51, in <module>\n    params = ast.literal_eval(data)\n             ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    {beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]}\n     ^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]",
          "expected_output": "[]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmp88r5_5yo.py\", line 51, in <module>\n    params = ast.literal_eval(data)\n             ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    {beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]}\n     ^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode436.json",
    "problem_index_in_file": 0,
    "title": "Find Right Interval",
    "description_snippet": "You are given an array of intervals, where intervals[i] = [starti, endi] and each starti is unique.\n...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code. Need to provide step-by-step pseudocode for solving the problem: find for each interval the right interval. Standard solution: create array of (start, index), sort by start, for each interval find first start >= end via binary search.\n\nWe need to produce pseudocode with arrows and decisions. Provide step by step lines with explanation. Must not output actual code. Use Start, End, Decision etc. Provide line numbers? Not necessary but each line as per format.\n\nLet's craft.\n\n- Start\n- Step 1: Create array of pairs (start, index) from intervals. // Build auxiliary list\n- Step 2: Sort that array by start ascending. // Prepare for binary search\n- Step 3: Initialize result array of length n with -1. // Default\n- Step 4: For each interval i from 0 to n-1: // iterate original order\n  - Step 4.1: Set target = end of interval i. // value to find\n  - Step 4.2: BinarySearchInSortedStarts for first start >= target. // custom binary search\n    - Decision: If found index idx? // check if found\n      - Yes → Step 4.3: result[i] = sortedPairs[idx].originalIndex // record\n      - No  → Step 4.4: result[i] stays -1 // no right interval\n- End // return result\n\nBut we need to show binary search procedure as separate substeps maybe.\n\nAlso, we need to maintain the concept of unique start values.\n\nWe'll produce pseudocode lines accordingly. Use arrow indent.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 pairs = 空列表 // 準備存放 (start, 原始索引)  \n→ Decision: 迭代 i 從 0 到 intervals.length-1? // 逐一處理每個區間  \n  Yes → Step 2: 將 (intervals[i].start, i) 加入 pairs // 取得起始點與原始索引  \n  No  → // 迭代完成  \n→ Step 3: 將 pairs 按 start 升序排序 // 方便後續二分搜尋  \n→ Step 4: 初始化 result = 長度為 intervals.length 的陣列，全部設為 -1 // 預設沒有右區間  \n→ Decision: 迭代 i 從 0 到 intervals.length-1? // 為每個原始區間尋找右區間  \n  Yes → Step 5: target = intervals[i].end // 需要找到的最小 start  \n    → Step 6: 定義 low = 0, high = pairs.length - 1  \n    → Step 7: bestIndex = -1 // 初始無符合條件  \n    → Decision: low <= high? // 開始二分搜尋  \n     Yes → Step 8: mid = (low + high) // 2  \n      → Decision: pairs[mid].start >= target? // 是否滿足條件  \n       Yes → Step 9: bestIndex = mid // 可能答案，尋找更小的索引  \n         → high = mid - 1 // 繼續在左半邊尋找  \n      No  → low = mid + 1 // 繼續在右半邊尋找  \n      → // 返回至 Decision: low <= high?  \n    → // 二分搜尋結束  \n    → Decision: bestIndex != -1? // 找到符合條件的起始點嗎？  \n     Yes → Step 10: result[i] = pairs[bestIndex].originalIndex // 記錄右區間索引  \n     No  → // result[i] 已為 -1，保持不變  \n    → // 返回至 Decision: 迭代 i 往下?  \n     Yes → // 繼續下一個原始區間  \n     No  → // 所有區間已處理  \n→ End // 回傳 result 或結束程式 (取決於實作)",
      "generated_code": "import sys\nimport ast\nimport bisect\n\nclass Solution:\n    def findRightInterval(self, intervals):\n        # 建立 (start, 原始索引) 並排序，方便後續二分搜尋\n        starts = sorted((interval[0], i) for i, interval in enumerate(intervals))\n        res = []\n        for interval in intervals:\n            # 找到第一個 start >= interval[1]\n            idx = bisect.bisect_left(starts, (interval[1],))\n            if idx < len(starts):\n                res.append(starts[idx][1])\n            else:\n                res.append(-1)\n        return res\n\ndef main():\n    # 讀取整個輸入\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n    # 取出等號右邊的部分並安全解析\n    try:\n        if raw.startswith('intervals'):\n            _, expr = raw.split('=', 1)\n        else:\n            expr = raw\n        intervals = ast.literal_eval(expr.strip())\n    except Exception as e:\n        # 若解析失敗，直接結束\n        print(f\"Error parsing input: {e}\")\n        return\n\n    solution = Solution()\n    result = solution.findRightInterval(intervals)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "intervals = [[1,2]]",
          "expected_output": "[-1]",
          "success": true,
          "output": "[-1]"
        },
        {
          "example_index": 1,
          "input": "intervals = [[3,4],[2,3],[1,2]]",
          "expected_output": "[-1,0,1]",
          "success": true,
          "output": "[-1, 0, 1]"
        },
        {
          "example_index": 2,
          "input": "intervals = [[1,4],[2,3],[3,4]]",
          "expected_output": "[-1,2,-1]",
          "success": true,
          "output": "[-1, 2, -1]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode517.json",
    "problem_index_in_file": 0,
    "title": "Super Washing Machines",
    "description_snippet": "You have n super washing machines on a line. Initially, each washing machine has some dresses or is ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to solve the problem. The problem is classic \"Super Washing Machines\" Leetcode 1729. We need steps: check sum divisible by n, target each. Then iterate through machines, compute prefix difference, track max of absolute and difference. The answer is max(abs(prefix), diff). Let's produce pseudo-code line by line with comments. Use arrows, decisions. Provide explanation each line. Let's write.\n\nWe need Start, End. Use →. Provide decision steps.\n\nOk. Let's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得 machines 陣列以及其長度 n // 取得洗衣機數量與初始衣服數  \n→ Step 2: 計算 total = sum(machines) // 取得所有衣服總數  \n→ Decision: 如果 total % n != 0? // 判斷總數是否能平均分配  \n    Yes → Step 3: 回傳 -1 // 無法平均，直接結束  \n    No  → Step 4: 計算 target = total / n // 每台洗衣機應有的衣服數  \n→ Step 5: 初始化 prefix = 0, answer = 0 // prefix 用於累計差值，answer 儲存最大移動步數  \n→ Step 6: 針對 i 從 0 到 n-1 進行迴圈 // 遍歷每台洗衣機  \n    → Step 7: prefix += machines[i] - target // 計算到第 i 台為止的差值  \n    → Step 8: 計算 temp = max(abs(prefix), machines[i] - target) // 取得此位置所需的最大步數  \n    → Step 9: answer = max(answer, temp) // 更新整體答案  \n→ Step 10: 回傳 answer // 所有洗衣機均勻後所需的最小移動步數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findMinMoves(self, machines):\n        total = sum(machines)\n        n = len(machines)\n        if total % n != 0:\n            return -1\n        avg = total // n\n        res = 0\n        cum_diff = 0\n        for load in machines:\n            diff = load - avg\n            cum_diff += diff\n            res = max(res, abs(cum_diff), diff)\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    machines = ast.literal_eval(data)\n    solution = Solution()\n    result = solution.findMinMoves(machines)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[1,0,5]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "[0,3,0]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "[0,2,0]",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode278.json",
    "problem_index_in_file": 0,
    "title": "First Bad Version",
    "description_snippet": "You are a product manager and currently leading a team to develop a new product. Unfortunately, the ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for binary search for first bad version. Each line with explanation. Use Start, End, Decision, arrow. Ensure use of virtual code arrow syntax: → Step. Also use Decision: If ... Then Yes → etc.\n\nWe need to output each line. We'll have Start, then initialize left=1, right=n, then loop while left<right, compute mid=(left+right)/2, call isBadVersion(mid). If true, right=mid, else left=mid+1. After loop, left is first bad. Return left.\n\nWe need to incorporate decision branches. Use indentation maybe but arrow. Provide each line.\n\nLet's produce:\n\nStart // start\n\n→ Step 1: left ← 1 // initialize left boundary\n\n→ Step 2: right ← n // initialize right boundary\n\n→ Decision: while left < right? // loop until boundaries meet\n\n   Yes → Step 3: mid ← (left + right) / 2 // compute mid\n\n   → Step 4: if isBadVersion(mid) then\n\n         → Step 5: right ← mid // bad, search left half\n\n     else\n\n         → Step 6: left ← mid + 1 // good, search right half\n\n   No  → End // exit loop\n\n→ Step 7: return left // left is first bad\n\nMake sure each line has comment. Provide arrow accordingly. Let's craft final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: left ← 1 // 設定左邊界為第一個版本  \n→ Step 2: right ← n // 設定右邊界為最後一個版本  \n→ Decision: 左邊界小於右邊界? // 判斷是否還有未搜尋的區間  \n    Yes → Step 3: mid ← (left + right) / 2 // 計算中間版本號  \n    → Decision: mid 是不良版本? // 檢查中間版本的品質  \n        Yes → Step 4: right ← mid // 若 mid 是不良，則不良版本必在左半部  \n        No  → Step 5: left ← mid + 1 // 若 mid 是良好，則不良版本必在右半部  \n    No  → End // 當 left 等於 right 時，搜尋結束  \n→ Step 6: return left // left 即為第一個不良版本號  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\n# The isBadVersion API that the solution will use.\n# It will be defined based on the input.\ndef isBadVersion(version: int) -> bool:\n    return version >= _BAD_VERSION\n\n\nclass Solution:\n    def firstBadVersion(self, n: int) -> int:\n        left, right = 1, n\n        while left < right:\n            mid = left + (right - left) // 2\n            if isBadVersion(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left\n\n\nif __name__ == \"__main__\":\n    # Read the entire input\n    raw_input = sys.stdin.read()\n\n    # Extract all integers from the input (expected order: n, bad)\n    numbers = list(map(int, re.findall(r'\\d+', raw_input)))\n\n    if len(numbers) < 2:\n        raise ValueError(\"Input must contain two integers: n and bad.\")\n\n    n, _BAD_VERSION = numbers[0], numbers[1]\n\n    # Compute and print the first bad version\n    result = Solution().firstBadVersion(n)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 5, bad = 4",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "n = 1, bad = 1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode81.json",
    "problem_index_in_file": 0,
    "title": "Search in Rotated Sorted Array II",
    "description_snippet": "There is an integer array nums sorted in non-decreasing order (not necessarily with distinct values)...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for searching target in rotated sorted array with duplicates, minimal steps. Provide virtual pseudocode line by line with explanation. Use Start, End, Decision, etc.\n\nThe algorithm: modified binary search. Approach: while low <= high: mid. If nums[mid]==target return true. If nums[low]==nums[mid]==nums[high], we can't decide, low++, high--. Else if nums[low] <= nums[mid] (left part sorted), check if target in [nums[low], nums[mid]] then high=mid-1 else low=mid+1. Else right part sorted: check if target in [nums[mid], nums[high]] then low=mid+1 else high=mid-1. Return false.\n\nWe must output steps. Let's produce lines.\n\nWe need to show each step with explanation. Ensure arrow, etc.\n\nLet's produce: Start // begin\n\n→ Step 1: low = 0, high = len(nums)-1 // initialize pointers\n\n→ Decision: while low <= high? // loop condition\n\n    Yes → Step 2: mid = (low + high) // 2 // compute mid index\n\n    → Decision: if nums[mid] == target? // check target at mid\n\n        Yes → Step 3: return true // found\n\n        No → Decision: if nums[low] == nums[mid] && nums[mid] == nums[high]? // ambiguous due to duplicates\n\n            Yes → Step 4: low = low + 1 // shrink low\n\n            No → Step 5: if nums[low] <= nums[mid]? // left side sorted\n\n                Yes → Step 6: if nums[low] <= target && target < nums[mid]? // target in left\n\n                    Yes → Step 7: high = mid - 1 // search left\n\n                    No → Step 8: low = mid + 1 // search right\n\n                No → Step 9: if nums[mid] < target && target <= nums[high]? // target in right\n\n                    Yes → Step 10: low = mid + 1 // search right\n\n                    No → Step 11: high = mid - 1 // search left\n\n← After loop ends: Step 12: return false // target not found\n\nEnd // end\n\nBut we must use arrow lines: Each line with `→ Step ...` etc. For decisions we indent? The example shows indentation for nested decisions.\n\nLet's produce with indent and arrow.\n\nAlso we need to ensure each line ends with `// 解釋`. So we produce.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: low = 0, high = len(nums) - 1 // 初始化搜尋區間的左右指標  \n→ Decision: while low <= high? // 繼續搜尋直到指標相交  \n    Yes → Step 2: mid = (low + high) // 2 // 計算中間索引  \n    → Decision: if nums[mid] == target? // 判斷中間元素是否為目標  \n        Yes → Step 3: return true // 找到目標，結束搜尋  \n        No → Decision: if nums[low] == nums[mid] && nums[mid] == nums[high]? // 兩端與中間相同，無法判斷  \n            Yes → Step 4: low = low + 1 // 收縮左指標，跳過重複值  \n            No → Step 5: if nums[low] <= nums[mid]? // 左半邊已排序  \n                Yes → Step 6: if nums[low] <= target && target < nums[mid]? // 目標在左半邊  \n                    Yes → Step 7: high = mid - 1 // 將搜尋範圍縮到左半邊  \n                    No → Step 8: low = mid + 1 // 目標在右半邊，搜尋右半邊  \n                No → Step 9: if nums[mid] < target && target <= nums[high]? // 右半邊已排序且目標在右半邊  \n                    Yes → Step 10: low = mid + 1 // 將搜尋範圍縮到右半邊  \n                    No → Step 11: high = mid - 1 // 目標在左半邊，搜尋左半邊  \n← After loop ends  \nStep 12: return false // 未找到目標，返回 false  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def search(self, nums, target):\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return True\n            if nums[left] == nums[mid] == nums[right]:\n                left += 1\n                right -= 1\n            elif nums[left] <= nums[mid]:\n                if nums[left] <= target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            else:\n                if nums[mid] < target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n        return False\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Extract nums list and target value from the input string\n    match = re.search(r'nums\\s*=\\s*(\\[.*?\\])\\s*,\\s*target\\s*=\\s*(-?\\d+)', data, re.S)\n    if not match:\n        # If the pattern is not found, try to evaluate the whole string as a tuple\n        try:\n            nums, target = eval(data)\n        except Exception:\n            print(\"false\")\n            return\n    else:\n        nums_str, target_str = match.group(1), match.group(2)\n        nums = eval(nums_str)\n        target = int(target_str)\n\n    sol = Solution()\n    result = sol.search(nums, target)\n    print(str(result).lower())\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,5,6,0,0,1,2], target = 0",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "nums = [2,5,6,0,0,1,2], target = 3",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode435.json",
    "problem_index_in_file": 0,
    "title": "Non-overlapping Intervals",
    "description_snippet": "Given an array of intervals intervals where intervals[i] = [starti, endi], return the minimum number...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for the algorithm to remove minimum intervals to make intervals non-overlapping. The known solution: sort by end, greedy: count overlaps, remove when overlapping. Return number removed.\n\nWe need to output step-by-step lines of virtual code with arrow and explanation. Format: Start, → Step, → Decision, Yes → etc.\n\nWe need to cover reading input, sorting, iterating, counting. We'll produce lines like:\n\nStart\n→ Step 1: 將 intervals 按照結束時間升序排序 // Sorting\n→ Step 2: 初始化 count = 0, last_end = -∞ // initial\n→ For each interval in sorted list: // iterate\n   → Decision: 如果 interval.start < last_end? // overlap check\n      Yes → Step 3: count++ // remove one\n      No  → Step 4: last_end = interval.end // update\n→ Step 5: 返回 count // result\nEnd\n\nNeed to include arrow for loops maybe \"For each\". Provide explanation after each line. Use \"→\" for steps, \"Decision:\" for if, \"Yes →\" and \"No →\". Use \"Start\" \"End\". Provide each line separate. Use proper Chinese. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 將 intervals 按照結束時間升序排序 // 先依照右端點排序，以便能用貪心策略  \n→ Step 2: 初始化 count = 0, last_end = -∞ // count 記錄需要移除的區間數，last_end 為已選區間的右端點  \n→ For each interval in sorted list: // 逐一遍歷已排序的區間  \n → Decision: 如果 interval.start < last_end? // 檢查當前區間是否與前一個已選區間重疊  \n  Yes → Step 3: count++ // 若重疊，需移除此區間，count 加一  \n  No  → Step 4: last_end = interval.end // 無重疊，將 last_end 更新為此區間的右端點  \n→ Step 5: 返回 count // count 即為最小需要移除的區間數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def eraseOverlapIntervals(self, intervals):\n        if not intervals:\n            return 0\n        # 按右端點升序排序\n        intervals.sort(key=lambda x: x[1])\n        # 初始時第一個區間一定不重疊\n        end = intervals[0][1]\n        count = 1  # 目前已選擇的非重疊區間數\n        for i in range(1, len(intervals)):\n            # 若當前區間的起點 >= 上一個已選區間的結束點，則不重疊\n            if intervals[i][0] >= end:\n                end = intervals[i][1]\n                count += 1\n        # 需要移除的區間數 = 總區間數 - 不重疊區間數\n        return len(intervals) - count\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    # 解析輸入格式，例如: intervals = [[1,2],[2,3]]\n    if '=' in data:\n        _, intervals_part = data.split('=', 1)\n    else:\n        intervals_part = data\n    try:\n        intervals = ast.literal_eval(intervals_part.strip())\n    except Exception:\n        # 若解析失敗，直接終止\n        sys.exit(0)\n    result = Solution().eraseOverlapIntervals(intervals)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "intervals = [[1,2],[2,3],[3,4],[1,3]]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "intervals = [[1,2],[1,2],[1,2]]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "intervals = [[1,2],[2,3]]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode137.json",
    "problem_index_in_file": 0,
    "title": "Single Number II",
    "description_snippet": "Given an integer array nums where every element appears three times except for one, which appears ex...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need virtual code for finding single element in array where each element appears three times except one. Use bitwise count. Provide steps with virtual code lines and comments. No actual code. Should use Start, End, Decision etc.\n\nLet's craft steps:\n\nStart\n→ Step 1: Initialize bit count array of size 32 to zero // track count of bits\n→ Step 2: For each number in nums:\n   → Step 2a: For i from 0 to 31:\n       → Step 2a1: If bit i of number is set, increment bitCount[i]\n   → Step 2b: // end inner loop\n→ Step 3: Initialize result = 0\n→ Step 4: For i from 0 to 31:\n   → Decision: 如果 bitCount[i] mod 3 != 0? // check remainder\n       Yes → Step 4a: Set bit i in result // single number has this bit\n       No → // do nothing\n→ Step 5: Return result\nEnd\n\nAdd comments after each line. Use virtual code arrow.\n\nNeed to ensure \"Start\" \"End\" lines as per format. Provide explanation after each line with //.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 32 位元的 bitCount 陣列為 0 // 用來紀錄每個位元出現的次數  \n→ Step 2: 對 nums 中的每個 number 做以下操作  \n    → Step 2a: 從 0 到 31 逐位檢查  \n        → Step 2a1: 如果 number 的第 i 位為 1，則 bitCount[i] += 1 // 計數  \n    → Step 2b: // 結束內部位元迴圈  \n→ Step 3: 設定 result = 0 // 用來組合單一出現的數字  \n→ Step 4: 從 0 到 31 逐位檢查 bitCount  \n    → Decision: bitCount[i] mod 3 != 0? // 判斷該位元是否只出現一次  \n        Yes → Step 4a: 在 result 的第 i 位設為 1 // 將唯一數字的位元組合起來  \n        No → // 不做任何事，該位元為 0  \n→ Step 5: 回傳 result // 回傳找到的唯一元素  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def singleNumber(self, nums):\n        \"\"\"\n        找出只出現一次的元素。\n        使用兩個位元記錄每個位元出現 1 次與 2 次的情況，最後 ones 裡即為答案。\n        \"\"\"\n        ones, twos = 0, 0\n        for num in nums:\n            ones = (ones ^ num) & ~twos          # 新的 1 次位\n            twos = (twos ^ num) & ~ones          # 新的 2 次位\n        return ones\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    # 從輸入中擷取方括號內的數列\n    match = re.search(r'\\[.*\\]', data, re.S)\n    if match:\n        nums = eval(match.group(0))\n    else:\n        nums = []\n\n    sol = Solution()\n    result = sol.singleNumber(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,2,3,2]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [0,1,0,1,0,1,99]",
          "expected_output": "99",
          "success": true,
          "output": "99"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode478.json",
    "problem_index_in_file": 0,
    "title": "Generate Random Point in a Circle",
    "description_snippet": "Given the radius and the position of the center of a circle, implement the function randPoint which ...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the problem. Provide step-by-step pseudocode with comments. Steps: start, initialize radius and center, randPoint: generate random radius sqrt(u)*R, random angle between 0 and 2π, compute x = center_x + r*cos(angle), y = center_y + r*sin(angle), return [x,y]. Also decision maybe? Not much decisions. Provide Start, End. Use arrow syntax. Provide each line.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 定義類別 Solution // 建立類別以儲存圓的參數\n→ Step 2: 初始化 radius, x_center, y_center // 存入物件屬性\n→ Step 3: 定義方法 randPoint() // 產生隨機點\n    → Step 4: 產生 u ∈ [0,1) // 隨機數\n    → Step 5: 計算隨機半徑 r = sqrt(u) * radius // 保證均勻分佈\n    → Step 6: 產生 θ ∈ [0,2π) // 隨機角度\n    → Step 7: 計算 x = x_center + r * cos(θ) // 點的 x 坐標\n    → Step 8: 計算 y = y_center + r * sin(θ) // 點的 y 坐標\n    → Step 9: 回傳 [x, y] // 回傳隨機點\nEnd // 程式結束\n\nNeed to include arrow indent. Use \"→\" for each step. Indentation for nested steps maybe 4 spaces? Provide decision? Not needed.\n\nWe must ensure each line ends with // 解釋/說明. Provide comment after space.\n\nLet's craft.\n\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義類別 Solution // 建立類別以儲存圓的參數\n→ Step 2: 初始化 radius, x_center, y_center // 存入物件屬性\n→ Step 3: 定義方法 randPoint() // 產生隨機點\n    → Step 4: 產生 u ∈ [0,1) // 產生均勻分佈的隨機數\n    → Step 5: 計算 r = sqrt(u) * radius // 根據均勻分佈得到隨機半徑\n    → Step 6: 產生 θ ∈ [0,2π) // 產生均勻分佈的角度\n    → Step 7: 計算 x = x_center + r * cos(θ) // 轉換為座標系的 x\n    → Step 8: 計算 y = y_center + r * sin(θ) // 轉換為座標系的 y\n    → Step 9: 回傳 [x, y] // 回傳隨機點\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\nimport math\nimport random\n\nclass Solution:\n    def __init__(self, radius, x_center, y_center):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n\n    def randPoint(self):\n        # 隨機產生半徑（使用 sqrt 保證均勻分布）\n        r = self.radius * math.sqrt(random.random())\n        # 隨機產生角度\n        theta = random.uniform(0, 2 * math.pi)\n        # 轉換為笛卡兒座標\n        x = self.x_center + r * math.cos(theta)\n        y = self.y_center + r * math.sin(theta)\n        return [x, y]\n\ndef main():\n    # 讀取標準輸入：兩行，第一行為操作名稱列表，第二行為每個操作的參數\n    lines = [line.strip() for line in sys.stdin if line.strip() != '']\n    if len(lines) < 2:\n        return\n    ops = json.loads(lines[0])          # e.g. [\"Solution\", \"randPoint\", ...]\n    args_list = json.loads(lines[1])    # e.g. [[1.0, 0.0, 0.0], [], ...]\n\n    results = []\n    obj = None\n    for op, args in zip(ops, args_list):\n        if op == \"Solution\":\n            obj = Solution(*args)\n            results.append(None)          # constructor returns null\n        elif op == \"randPoint\":\n            if obj is not None:\n                results.append(obj.randPoint())\n            else:\n                results.append(None)      # 如果尚未建立對象，返回 null\n        else:\n            results.append(None)          # 未知操作，安全返回 null\n\n    # 輸出結果列表，使用 json.dumps 以得到正確的 null 表示\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]",
          "expected_output": "[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[-0.02493,-0.38077],[0.82314,0.38945],[0.36572,0.17248]]'\nGot (Norm):      '[null,[-0.6353476670468973,-0.4378010195233728],[-0.7014569173182966,0.07309295028841646],[0.6350305285300633,0.5341867798349382]]'\n--- (Raw) ---\nRaw Expected: '[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]'\nRaw Got:      '[null, [-0.6353476670468973, -0.4378010195233728], [-0.7014569173182966, 0.07309295028841646], [0.6350305285300633, 0.5341867798349382]]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode77.json",
    "problem_index_in_file": 0,
    "title": "Combinations",
    "description_snippet": "Given two integers n and k, return all possible combinations of k numbers chosen from the range [1, ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for generating all combinations of k numbers from 1..n. Use recursion/backtracking. Output each step line with explanation. Must use arrow, decisions etc. Provide Start, End. Must be step-by-step. Each line: virtual code step + space + // explanation. Use arrows like \"→\". Use decision statements. Should be \"逐行\". Provide the algorithm in virtual code. Should include \"Start\", \"End\". For recursion, we can have a function \"Backtrack(start, path)\". Use decision: if length of path == k: add to results. Else for i from start to n: add i, call backtrack(i+1, path). After recursion, remove i. Provide steps.\n\nLet's produce virtual code:\n\nStart // 程式開始執行\n→ Step 1: 定義結果列表 res // 用來存所有組合\n→ Step 2: 定義遞迴函式 Backtrack(start, path) // 從 start 開始選取\n    → Decision: 如果 path 長度 == k? // 判斷是否已選 k 個\n        Yes → Step 3: 將 path 複製加入 res // 將完整組合加入結果\n        No  → Step 4: 對 i 從 start 到 n 做迴圈 // 嘗試加入剩餘數字\n            → Step 5: 加入 i 到 path // 選取數字\n            → Step 6: 呼叫 Backtrack(i+1, path) // 進一步遞迴\n            → Step 7: 從 path 移除最後一個元素 // 回溯\n→ Step 8: 呼叫 Backtrack(1, 空清單) // 開始遞迴\n→ Step 9: 回傳 res // 回傳所有組合\nEnd // 程式執行結束\n\nBut must keep arrow lines. Use \"→\" before each step. Provide indentation. Use \"Decision:\" lines. Ensure each line ends with // explanation. Also must be \"逐行\". Let's format properly. Ensure each line only one step. Indent decision branches. Use \"Yes →\" \"No →\". Provide explanation after //. Provide \"Start\" and \"End\".\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義結果列表 res // 用來存所有組合  \n→ Step 2: 定義遞迴函式 Backtrack(start, path) // 從 start 開始選取  \n  → Decision: 如果 path 長度 == k? // 判斷是否已選 k 個  \n   Yes → Step 3: 將 path 複製加入 res // 將完整組合加入結果  \n   No  → Step 4: 對 i 從 start 到 n 做迴圈 // 嘗試加入剩餘數字  \n    → Step 5: 加入 i 到 path // 選取數字  \n    → Step 6: 呼叫 Backtrack(i+1, path) // 進一步遞迴  \n    → Step 7: 從 path 移除最後一個元素 // 回溯  \n→ Step 8: 呼叫 Backtrack(1, 空清單) // 開始遞迴  \n→ Step 9: 回傳 res // 回傳所有組合  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef combine(n: int, k: int):\n    \"\"\"回溯產生所有長度為 k 的組合，元素範圍為 1..n。\"\"\"\n    res = []\n\n    def backtrack(start: int, path: list):\n        if len(path) == k:\n            res.append(path[:])          # 完整組合，加入結果\n            return\n        for i in range(start, n + 1):\n            path.append(i)              # 選取 i\n            backtrack(i + 1, path)      # 繼續選取剩餘數字\n            path.pop()                  # 回溯，移除 i\n\n    backtrack(1, [])\n    return res\n\ndef main():\n    data = sys.stdin.read()\n    numbers = re.findall(r'\\d+', data)\n    if len(numbers) < 2:\n        return\n    n, k = map(int, numbers[:2])\n    result = combine(n, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 4, k = 2",
          "expected_output": "[[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]",
          "success": true,
          "output": "[[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]"
        },
        {
          "example_index": 1,
          "input": "n = 1, k = 1",
          "expected_output": "[[1]]",
          "success": true,
          "output": "[[1]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode365.json",
    "problem_index_in_file": 0,
    "title": "Water and Jug Problem",
    "description_snippet": "You are given two jugs with capacities x liters and y liters. You have an infinite water supply. Ret...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line with explanation. We need to produce algorithm for water jug problem. Use Start, End, Decision, etc.\n\nWe need to produce the algorithm. We should produce high-level pseudocode: use gcd logic, etc. Or BFS/DFS.\n\nProbably simpler: use GCD condition. So step: compute gcd(x,y), check target <= max(x,y) and target%gcd==0.\n\nWe produce steps: Start, Step 1 compute gcd, Step 2 if target>max(x,y) → No, Step 3 if target%gcd==0 → Yes, else No. End.\n\nBut we need to reflect that we have operations. So algorithm.\n\nThus produce:\n\nStart // 程式開始執行\n→ Step 1: 計算 x 與 y 的最大公因數 d // 找出兩個壺容量的 gcd\n→ Decision: 如果 target > max(x, y)? // 檢查目標是否超過任何一個壺的容量\n    Yes → Step 2: 回傳 False // 目標無法達到\n    No → Decision: 如果 target % d == 0? // 檢查 target 是否是 d 的倍數\n        Yes → Step 3: 回傳 True // 可以達到\n        No  → Step 4: 回傳 False // 目標無法達到\nEnd // 程式執行結束\n\nBut maybe also consider that target can be sum of both jugs? Wait problem: \"total amount of water in both jugs may reach target\". So target <= x+y? Actually target may be up to x+y. We check target <= x + y. And gcd condition for water jug problem for total? For combined volume, we want to reach target total in two jugs combined. For total, it's the same condition as if we could measure target using one jug? Actually typical problem is to get exactly target liters in one jug. Here it's total amount across both jugs. But operations allow both jugs to be used. However we can think that if we can achieve total target, it's same as ability to measure target in one of the jugs? Not exactly.\n\nLet's think: The total amount in both jugs is between 0 and x+y. We want to check if there exists state (a,b) such that a+b = target. With operations defined, we can generate all states that are reachable from (0,0). It's known that reachable states satisfy that a is multiple of gcd(x,y) or b is multiple? Actually for total sum, reachable sums are multiples of gcd(x,y) up to x+y? But is it possible to get any multiple? Let's test small: x=3, y=5. gcd=1. Can we get target=4? possible states: (0,0)-> fill 3-> (3,0), pour into 5->(0,3), fill 3->(3,3), pour into 5->(1,5). Total 1+5=6. We need 4. Let's try: (3,0) pour into 5 => (0,3). Fill 5 => (0,5). Pour into 3 => (2,3). Total 5. Hmm maybe 4 reachable? Maybe fill 5 then pour to 3: (3,2). Total 5. Then empty 3: (0,2). Fill 3: (3,2). Total 5. Hard.\n\nLet's brute: I think reachable totals are multiples of gcd and <= x+y? Let's quickly think: You can get any sum that is multiple of gcd? Suppose x=4,y=6,gcd=2. Can we get target=2? Let's try: (0,0)->fill 4:(4,0). pour to 6 => (0,4). fill 4:(4,4). pour to 6 => (2,6). Total 8. So 2 unreachable? But maybe (0,0)->fill 6:(0,6). pour to 4 => (4,2). Total 6. So 2 not reached. So not all multiples.\n\nThus need more algorithm: BFS over states (a,b). We need to check if there exists (a,b) with a+b==target. So virtual code BFS.\n\nSo produce steps:\n\nStart\n→ Step 1: Initialize queue with (0,0), visited set\n→ Decision: While queue not empty? ...\nLoop: dequeue state (a,b)\n→ Decision: If a+b == target? -> Yes -> return True\n→ Generate next states: fill a, fill b, empty a, empty b, pour a->b, pour b->a.\n→ For each new state, if not visited, add to queue.\nEnd of loop\n→ Return False\nEnd\n\nWe need to use decision nodes with Yes→ etc.\n\nLet's craft.\n\nOk produce final virtual code.\n\nAlso need explanation. Let's write steps accordingly. Use \"Start\", \"End\". For each line, explain.\n\nMake sure each line has \"虛擬碼步驟\" and \"// 解釋/說明\".\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立佇列 queue 並將初始狀態 (0,0) 入隊 // 以 (a,b) 代表兩壺中的水量\n→ Step 2: 初始化已訪問集合 visited，加入 (0,0) // 防止重複探索相同狀態\n→ Decision: 如果 queue 仍有未處理項目? // 判斷是否還有可探索的狀態\n    Yes → Step 3: 取出佇列前項 (a, b) // 取得目前處理的狀態\n    No  → Step 4: 回傳 False // 所有可能的狀態都已檢查且未達到目標\n→ Decision: 如果 a + b == target? // 檢查目前兩壺水量總和是否符合目標\n    Yes → Step 5: 回傳 True // 找到可達狀態，結束搜尋\n    No  → Decision: 生成六種可能的新狀態? // 填滿、倒空、兩壺互倒\n        → Step 6: 產生新狀態 list = [\n            (x, b),          // 填滿第一壺\n            (a, y),          // 填滿第二壺\n            (0, b),          // 倒空第一壺\n            (a, 0),          // 倒空第二壺\n            (max(a-b,0), min(a+b,y)), // 從第一壺倒入第二壺\n            (min(a+b,x), max(a-b,0))  // 從第二壺倒入第一壺\n        ] // 四則運算決定水量轉移結果\n        → Step 7: 對於每個新狀態 (a2, b2) \n            → Decision: 如果 (a2, b2) 尚未在 visited? \n                Yes → Step 8: 將 (a2, b2) 加入 queue 並標記已訪問 // 將可行的新狀態加入未處理列表\n                No  → 跳過 // 已處理過的狀態不再重複\n→ Loop back至 Decision: 如果 queue 仍有未處理項目? // 重新判斷是否繼續搜尋\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom collections import deque\n\nclass Solution:\n    def canMeasureWater(self, x: int, y: int, target: int) -> bool:\n        \"\"\"\n        Use BFS to explore all reachable states (a, b) where a is the water\n        in jug x and b is the water in jug y.  If any state has a + b == target,\n        we can reach the desired total amount.\n        \"\"\"\n        # Quick reject if target is larger than total capacity or negative\n        if target < 0 or target > x + y:\n            return False\n\n        # Queue for BFS, starting from (0, 0)\n        queue = deque()\n        queue.append((0, 0))\n\n        # Visited set to avoid revisiting states\n        visited = set()\n        visited.add((0, 0))\n\n        while queue:\n            a, b = queue.popleft()\n\n            # Check if the current total matches the target\n            if a + b == target:\n                return True\n\n            # Generate all possible next states\n            next_states = [\n                (x, b),                 # Fill jug x\n                (a, y),                 # Fill jug y\n                (0, b),                 # Empty jug x\n                (a, 0),                 # Empty jug y\n                # Pour from x to y\n                (max(a - (y - b), 0), min(a + b, y)),\n                # Pour from y to x\n                (min(a + b, x), max(b - (x - a), 0))\n            ]\n\n            for na, nb in next_states:\n                if (na, nb) not in visited:\n                    visited.add((na, nb))\n                    queue.append((na, nb))\n\n        # Exhausted all states without finding the target\n        return False\n\ndef main() -> None:\n    \"\"\"\n    Reads input from stdin in the form:\n        x = <int>, y = <int>, target = <int>\n    Parses the integers and prints 'true' or 'false' accordingly.\n    \"\"\"\n    data = sys.stdin.read()\n    numbers = list(map(int, re.findall(r'\\d+', data)))\n\n    if len(numbers) < 3:\n        # Insufficient data; output false\n        print('false')\n        return\n\n    x, y, target = numbers[0], numbers[1], numbers[2]\n    sol = Solution()\n    result = sol.canMeasureWater(x, y, target)\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "x = 3, y = 5, target = 4",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "x = 2, y = 6, target = 5",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "x = 1, y = 2, target = 3",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode5.json",
    "problem_index_in_file": 0,
    "title": "Longest Palindromic Substring",
    "description_snippet": "Given a string s, return the longest palindromic substring in s....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm: find longest palindromic substring. Typical solution: expand around center for each index (2n-1 centers). Complexity O(n^2). Steps: Input string s. For each index i, expand odd length palindrome; also expand even length between i and i+1. Keep track of longest. Return substring.\n\nWe need to output step-by-step with arrows and decisions. Each line: virtual code step + comment. Use \"Start\", \"End\". Use \"→\" arrow. Use \"Decision:\" with Yes/No lines. No actual code, just steps.\n\nLet's structure:\n\nStart\n→ Step 1: Initialize longest_start=0, longest_len=1 // start indices\n→ Step 2: For i from 0 to length-1 // iterate over centers\n    → Decision: If i >= length? (maybe no need)\nBut we can just show loops.\n\nSimplify: use \"For i in 0..n-1\" etc. Provide explanation.\n\nUse \"Decision:\" for checking palindrome expand. Show \"expand\" function? We'll show \"expandAroundCenter(left, right)\" step.\n\nWe need to maintain \"while left>=0 && right<n && s[left]==s[right]\" loop.\n\nWe'll show \"while\" as a step. But they want \"Decision:\" lines.\n\nWe can show \"Decision: s[left]==s[right]?\" Yes expand, No break.\n\nThen after loop, compute current_len = right-left-1 (since loop stops when mismatch). Then compare with longest_len. Decision: current_len > longest_len? Yes update longest_start, longest_len.\n\nAfter loop ends, return substring from longest_start to longest_start+longest_len.\n\nWe'll produce steps.\n\nLet's craft lines:\n\nStart // 程式開始\n→ Step 1: Set n = length of s // 取得字串長度\n→ Step 2: Initialize longest_start = 0, longest_len = 1 // 初始長度 1\n→ Step 3: For i from 0 to n-1 // 逐個中心\n    → Step 3.1: Set left = i, right = i // odd length centre\n        → While left >= 0 AND right < n AND s[left] == s[right] // 擴散\n            → left = left - 1 // 左移\n            → right = right + 1 // 右移\n        → Step 3.2: current_len = right - left - 1 // 取得長度\n        → Decision: current_len > longest_len? // 比較是否更長\n            Yes → longest_start = left + 1 // 更新起點\n            Yes → longest_len = current_len // 更新長度\n    → Step 3.3: Set left = i, right = i + 1 // even length centre\n        → While left >= 0 AND right < n AND s[left] == s[right]\n            → left = left - 1\n            → right = right + 1\n        → Step 3.4: current_len = right - left - 1\n        → Decision: current_len > longest_len?\n            Yes → longest_start = left + 1\n            Yes → longest_len = current_len\n→ Step 4: Return substring of s from longest_start length longest_len // 取得結果\nEnd // 程式結束\n\nBut we need to format each line individually with \"虛擬碼步驟\" and comment. Use \"→\" before each step.\n\nNeed to include indentation. Example from prompt shows indentation inside decision branches. Use spaces.\n\nAlso include \"Decision:\" line.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Set n = length of s // 取得字串長度  \n→ Step 2: Initialize longest_start = 0, longest_len = 1 // 設定初始最長子字串  \n→ Step 3: For i from 0 to n-1 // 逐一考慮每個中心點  \n  → Step 3.1: Set left = i, right = i // 奇數長度中心  \n    → Decision: while left >= 0 AND right < n AND s[left] == s[right]? // 擴散左右兩側  \n      Yes → left = left - 1 // 向左擴散  \n      Yes → right = right + 1 // 向右擴散  \n      No  → Exit loop // 不再相等則停止擴散  \n    → Step 3.2: current_len = right - left - 1 // 計算擴散後的長度  \n    → Decision: current_len > longest_len? // 是否更新為更長的子字串  \n      Yes → longest_start = left + 1 // 更新起點  \n      Yes → longest_len = current_len // 更新長度  \n  → Step 3.3: Set left = i, right = i + 1 // 偶數長度中心  \n    → Decision: while left >= 0 AND right < n AND s[left] == s[right]? // 擴散左右兩側  \n      Yes → left = left - 1  \n      Yes → right = right + 1  \n      No  → Exit loop  \n    → Step 3.4: current_len = right - left - 1 // 計算偶數中心的長度  \n    → Decision: current_len > longest_len? // 是否更新為更長的子字串  \n      Yes → longest_start = left + 1  \n      Yes → longest_len = current_len  \n→ Step 4: Return substring of s from longest_start of length longest_len // 回傳結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        \"\"\"返回字符串 s 的最长回文子串\"\"\"\n        n = len(s)\n        if n == 0:\n            return \"\"\n\n        longest_start, longest_len = 0, 1\n\n        for i in range(n):\n            # 奇数长度回文，中心在 i\n            left, right = i, i\n            while left >= 0 and right < n and s[left] == s[right]:\n                left -= 1\n                right += 1\n            curr_len = right - left - 1\n            if curr_len > longest_len:\n                longest_start, longest_len = left + 1, curr_len\n\n            # 偶数长度回文，中心在 i 和 i+1\n            left, right = i, i + 1\n            while left >= 0 and right < n and s[left] == s[right]:\n                left -= 1\n                right += 1\n            curr_len = right - left - 1\n            if curr_len > longest_len:\n                longest_start, longest_len = left + 1, curr_len\n\n        return s[longest_start:longest_start + longest_len]\n\n\ndef main() -> None:\n    \"\"\"\n    读取标准输入，期望格式为:\n        s = 'xxxxxx'\n    或者直接给出字符串 'xxxxxx'（不带引号）\n    \"\"\"\n    data = sys.stdin.read().strip()\n\n    # 解析可能包含单引号的输入\n    first_quote = data.find(\"'\")\n    last_quote = data.rfind(\"'\")\n    if first_quote != -1 and last_quote != -1 and last_quote > first_quote:\n        s = data[first_quote + 1:last_quote]\n    else:\n        # 直接使用整个输入（去除前后空白）\n        s = data\n\n    solution = Solution()\n    result = solution.longestPalindrome(s)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = 'babad'",
          "expected_output": "'bab'",
          "success": true,
          "output": "bab"
        },
        {
          "example_index": 1,
          "input": "s = 'cbbd'",
          "expected_output": "'bb'",
          "success": true,
          "output": "bb"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode454.json",
    "problem_index_in_file": 0,
    "title": "4Sum II",
    "description_snippet": "Given four integer arrays A, B, C, and D all of length n, return the number of tuples (i, j, k, l) s...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code that calculates number of quadruples summing to zero. Classic 4Sum II problem. Use hash map of pair sums of A and B. Count. Provide step by step pseudocode. Use Start, End, Decision. Use arrows. Provide line-by-line.\n\nWe'll structure:\n\nStart\n→ Initialize map sumAB\n→ For each i in 0..n-1\n   → For each j in 0..n-1\n      → Compute sum = A[i] + B[j]\n      → Increment count in sumAB[sum]\n→ Initialize result = 0\n→ For each k in 0..n-1\n   → For each l in 0..n-1\n      → Compute target = -(C[k] + D[l])\n      → If target in sumAB\n         Yes → result += sumAB[target]\n→ Output result\nEnd\n\nWe can also include Decision to check if target exists. Provide lines.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Initialize sumAB = {} // 建立空字典，用來記錄 A 和 B 的各組合和  \n→ For i = 0 to n-1 // 迭代 A 的每個元素  \n → For j = 0 to n-1 // 迭代 B 的每個元素  \n  → sum = A[i] + B[j] // 計算 A[i] 與 B[j] 的和  \n  → If sumAB[sum] 存在  \n   Yes → sumAB[sum] = sumAB[sum] + 1 // 先前已計過，累加次數  \n   No  → sumAB[sum] = 1 // 首次出現，次數設為 1  \n→ Initialize result = 0 // 儲存符合條件的四元組數量  \n→ For k = 0 to n-1 // 迭代 C 的每個元素  \n → For l = 0 to n-1 // 迭代 D 的每個元素  \n  → target = -(C[k] + D[l]) // 需要 A[i]+B[j] 的和等於此值才能總和為 0  \n  → Decision: 是否存在 target? // 檢查字典中是否有此和  \n   Yes → result = result + sumAB[target] // 若存在，累加該和出現的次數  \n   No  → // 若不存在，則不改變 result  \n→ Output result // 顯示符合條件的四元組數量  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import Counter\n\ndef fourSumCount(A, B, C, D):\n    \"\"\"\n    Count the number of quadruples (i, j, k, l) such that\n    A[i] + B[j] + C[k] + D[l] == 0.\n    \"\"\"\n    # Count sums of pairs from A and B\n    AB = Counter(a + b for a in A for b in B)\n    count = 0\n    # For each pair from C and D, look for the complementary sum in AB\n    for c in C:\n        for d in D:\n            count += AB.get(-(c + d), 0)\n    return count\n\ndef parse_input(text):\n    \"\"\"\n    Parse a string like\n    'A = [1,2], B = [-2,-1], C = [-1,2], D = [0,2]'\n    into four integer lists.\n    \"\"\"\n    # Find all bracketed expressions\n    brackets = re.findall(r'\\[.*?\\]', text)\n    if len(brackets) != 4:\n        raise ValueError(\"Input must contain four lists for A, B, C, D.\")\n    # Convert each string list into a Python list of ints\n    return [ast.literal_eval(b) for b in brackets]\n\ndef main():\n    data = sys.stdin.read()\n    if not data.strip():\n        return\n    try:\n        A, B, C, D = parse_input(data)\n    except Exception as e:\n        print(f\"Error parsing input: {e}\", file=sys.stderr)\n        return\n    result = fourSumCount(A, B, C, D)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "A = [1,2], B = [-2,-1], C = [-1,2], D = [0,2]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "A = [0], B = [0], C = [0], D = [0]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode50.json",
    "problem_index_in_file": 0,
    "title": "Pow(x, n)",
    "description_snippet": "Implement pow(x, n), which calculates x raised to the power n (i.e., x^n)....",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for pow(x,n). Use exponentiation by squaring. Steps: Start, read x,n, handle n==0 return 1, if n<0 handle negative power: compute 1/(pow(x,-n)). Then use iterative loop: result=1; base=x; exp=n; while exp>0: if exp odd: result*=base; base*=base; exp//=2. Finally output result. Also decision structure. Need each line with // explanation.\n\nFollow format: Start, arrow. Use \"Decision:\" for conditions. Use \"→\". Provide comments.\n\nLet's produce.\n\nWe need to maintain proper indentation maybe? The example shows indentation for nested decisions.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 取得輸入值 x, n // 從使用者處取得底數與指數\n→ Decision: n 等於 0? // 檢查指數是否為 0\n    Yes → Step 2: 輸出 1 // x^0 = 1\n    No  → Decision: n 小於 0? // 指數為負數時需先處理\n        Yes → Step 3: 設定 n = -n 並記錄 sign // 取正數指數並記錄負號\n        No  → Step 4: 不變 // 正數指數保持不變\n→ Step 5: 初始化 result = 1 // 計算結果的初始值\n→ Step 6: 初始化 base = x // 底數\n→ Step 7: 初始化 exp = n // 指數\n→ Decision: exp 大於 0? // 開始平方指數法迴圈\n    Yes → Decision: exp 為奇數? // 判斷當前指數是否為奇數\n        Yes → Step 8: result = result * base // 乘以當前底數\n        No  →  // 不需要乘法\n    Yes → Step 9: base = base * base // 底數平方\n    Yes → Step 10: exp = exp // 2 // 指數右移一位\n    Yes → 重新進入 Decision: exp 大於 0? // 迴圈結束條件\n    No  →  // exp 為 0 時結束迴圈\n→ Decision: 原始指數是否為負? // 若指數為負，需取倒數\n    Yes → Step 11: result = 1 / result // 取倒數\n    No  →  // 保持原結果\n→ Step 12: 輸出 result // 結束並輸出計算結果\nEnd // 程式執行結束\n\nBut we need each line to have \"虛擬碼步驟\" then space then \"// 解釋\". Also indent for nested decisions maybe using spaces. Use same indentation as example: indentation spaces before \"Yes →\" etc. The example uses indentation with four spaces? Actually it uses two spaces before Yes ->. In example: \"    Yes → Step 2\". That is 4 spaces? Let's replicate.\n\nWe should produce each line exactly as format.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 取得輸入值 x, n // 從使用者處取得底數與指數\n→ Decision: n 等於 0? // 檢查指數是否為 0\n    Yes → Step 2: 輸出 1 // x^0 = 1\n    No  → Decision: n 小於 0? // 指數為負數時需先處理\n        Yes → Step 3: 設定 n = -n 並記錄 sign // 取正數指數並記錄負號\n        No  → Step 4: 不變 // 正數指數保持不變\n→ Step 5: 初始化 result = 1 // 計算結果的初始值\n→ Step 6: 初始化 base = x // 底數\n→ Step 7: 初始化 exp = n // 指數\n→ Decision: exp 大於 0? // 開始平方指數法迴圈\n    Yes → Decision: exp 為奇數? // 判斷當前指數是否為奇數\n        Yes → Step 8: result = result * base // 乘以當前底數\n        No  → // 不需要乘法\n    Yes → Step 9: base = base * base // 底數平方\n    Yes → Step 10: exp = exp // 2 // 指數右移一位\n    Yes → 重新進入 Decision: exp 大於 0? // 迴圈結束條件\n    No  → // exp 為 0 時結束迴圈\n→ Decision: 原始指數是否為負? // 若指數為負，需取倒數\n    Yes → Step 11: result = 1 / result // 取倒數\n    No  → // 保持原結果\n→ Step 12: 輸出 result // 結束並輸出計算結果\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef my_pow(x: float, n: int) -> float:\n    \"\"\"\n    以平方快速指數演算法計算 x 的 n 次方。\n    支援負指數與零指數，結果保留雙精度浮點。\n    \"\"\"\n    if n == 0:\n        return 1.0\n\n    # 若 n 為負，先取倒數並把指數轉為正數\n    if n < 0:\n        x = 1.0 / x\n        n = -n\n\n    result = 1.0\n    base = x\n    exp = n\n\n    # 迭代平方指數法\n    while exp > 0:\n        if exp & 1:          # 若 exp 為奇數，乘上目前 base\n            result *= base\n        base *= base         # base 平方\n        exp >>= 1            # 指數右移一位（除以 2）\n\n    return result\n\n\ndef main() -> None:\n    \"\"\"\n    主函式：從標準輸入讀取「x = ..., n = ...」格式的字串，\n    解析底數與指數，計算結果並以五位小數輸出。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入，例如 \"x = 2.00000, n = 10\"\n    match = re.search(r'x\\s*=\\s*([-\\d\\.]+)\\s*,\\s*n\\s*=\\s*([-\\d]+)', data)\n    if match:\n        x = float(match.group(1))\n        n = int(match.group(2))\n    else:\n        # 若格式不符，嘗試直接從空格分隔的兩個數字讀取\n        parts = data.split()\n        if len(parts) >= 2:\n            x = float(parts[0])\n            n = int(parts[1])\n        else:\n            return\n\n    result = my_pow(x, n)\n    print(f\"{result:.5f}\")\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "x = 2.00000, n = 10",
          "expected_output": "1024.00000",
          "success": true,
          "output": "1024.00000"
        },
        {
          "example_index": 1,
          "input": "x = 2.10000, n = 3",
          "expected_output": "9.26100",
          "success": true,
          "output": "9.26100"
        },
        {
          "example_index": 2,
          "input": "x = 2.00000, n = -2",
          "expected_output": "0.25000",
          "success": true,
          "output": "0.25000"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode8.json",
    "problem_index_in_file": 0,
    "title": "String to Integer (atoi)",
    "description_snippet": "Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer.\n\nThe al...",
    "examples_loaded": 5,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce step-by-step virtual code, each line with explanation. No actual code, only structure. Must include arrow symbols, Decision, Start, End. The algorithm: ignoring whitespace, sign, conversion reading digits, rounding, return. We need to produce pseudocode step by step. Must adhere to format.\n\nLet's design:\n\nStart\n\n→ Step 1: Initialize index i=0 // pointer to string\n\n→ Step 2: Skip leading whitespace // loop while s[i] is space\n\n→ Decision: If i reached end? // check\n\n    Yes → Step X: Return 0 // no digits\n\n    No\n\n→ Step 3: Determine sign // check s[i] '-' or '+'\n\n    if '-' set sign = -1, i++\n\n    else if '+' set sign = 1, i++\n\n    else sign = 1\n\n→ Step 4: Initialize num = 0 // accumulate\n\n→ Step 5: Skip leading zeros // while s[i] == '0', i++\n\n→ Decision: If i reached end? // if no digits\n\n    Yes → Step X: Return 0\n\n    No\n\n→ Step 6: While s[i] is digit:\n\n    num = num*10 + digit\n\n    i++\n\n→ Step 7: Apply sign: num = sign * num\n\n→ Decision: If num < INT_MIN? // -2147483648\n\n    Yes → num = INT_MIN\n\n    No → Decision: If num > INT_MAX? // 2147483647\n\n        Yes → num = INT_MAX\n\n        No // ok\n\n→ Step 8: Return num\n\nEnd\n\nWe should write each step as \"虛擬碼步驟\" followed by comment. Use arrow arrows. Use decisions with Yes → / No → indentation. Must be consistent with format example. Provide explanation after each.\n\nLet's craft the output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: i ← 0 // 初始化索引指向字串起始位置  \n→ Step 2: While s[i] = ' ' do i ← i + 1 // 跳過所有前導空白字元  \n→ Decision: i >= length(s)? // 是否已經到達字串結尾  \n  Yes → Step 3: Return 0 // 沒有任何有效字元，直接回傳 0  \n  No  \n→ Step 4: sign ← 1 // 預設正號  \n  If s[i] = '-' then sign ← -1, i ← i + 1 // 讀到負號時設定符號並移動索引  \n  Else if s[i] = '+' then i ← i + 1 // 讀到正號時僅移動索引  \n→ Step 5: num ← 0 // 用來累積數值的變數  \n→ Step 6: While s[i] = '0' do i ← i + 1 // 跳過所有前導零  \n→ Decision: i >= length(s)? // 是否已經到達字串結尾  \n  Yes → Step 7: Return 0 // 只遇到零或沒有數字，回傳 0  \n  No  \n→ Step 8: While s[i] is digit do  \n   digit ← int(s[i]) - int('0') // 取得數字對應的整數值  \n   num ← num * 10 + digit // 累加到 num  \n   i ← i + 1 // 移動到下一個字元  \n→ Step 9: num ← sign * num // 依符號調整正負  \n→ Decision: num < INT_MIN? // INT_MIN = -2147483648  \n  Yes → num ← INT_MIN // 低於下限時裁切到 INT_MIN  \n  No → Decision: num > INT_MAX? // INT_MAX = 2147483647  \n    Yes → num ← INT_MAX // 高於上限時裁切到 INT_MAX  \n    No // 介於範圍內，保持原值  \n→ Step 10: Return num // 回傳最終計算結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def myAtoi(self, s):\n        \"\"\"\n        Convert a string to a 32-bit signed integer.\n        \"\"\"\n        # 1. Remove leading whitespace\n        s = s.lstrip()\n        if not s:\n            return 0\n\n        # 2. Determine sign\n        sign = 1\n        idx = 0\n        if s[0] == '+':\n            idx += 1\n        elif s[0] == '-':\n            sign = -1\n            idx += 1\n\n        # 3. Parse digits\n        num = 0\n        while idx < len(s) and s[idx].isdigit():\n            num = num * 10 + int(s[idx])\n            idx += 1\n\n        num *= sign\n\n        # 4. Clamp to 32-bit signed integer range\n        INT_MAX = 2**31 - 1\n        INT_MIN = -2**31\n        if num < INT_MIN:\n            return INT_MIN\n        if num > INT_MAX:\n            return INT_MAX\n\n        return num\n\ndef main():\n    # Read entire stdin\n    data = sys.stdin.read().strip()\n    # Extract the string inside quotes (double or single)\n    m = re.search(r'\"([^\"]*)\"', data)\n    if m:\n        s = m.group(1)\n    else:\n        m = re.search(r\"'([^']*)'\", data)\n        if m:\n            s = m.group(1)\n        else:\n            # If no quotes are found, treat the whole input as the string\n            s = data\n\n    sol = Solution()\n    result = sol.myAtoi(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"42\"",
          "expected_output": "42",
          "success": true,
          "output": "42"
        },
        {
          "example_index": 1,
          "input": "s = \" -042\"",
          "expected_output": "-42",
          "success": true,
          "output": "-42"
        },
        {
          "example_index": 2,
          "input": "s = \"1337c0d3\"",
          "expected_output": "1337",
          "success": true,
          "output": "1337"
        },
        {
          "example_index": 3,
          "input": "s = \"0-1\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 4,
          "input": "s = \"words and 987\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode151.json",
    "problem_index_in_file": 0,
    "title": "Reverse Words in a String",
    "description_snippet": "Given an input string s, reverse the order of the words.\n\nA word is defined as a sequence of non-spa...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. The input: string s. Need to reverse order of words. Remove leading/trailing/multiple spaces. Return words reversed with single space.\n\nWe need step-by-step algorithm.\n\nSteps:\n\n- Start\n- Read input string s\n- Split string into words using spaces, ignoring empty strings\n- Reverse list of words\n- Join with single space\n- Output result\n- End\n\nBut we also need decisions, loops. We might have a decision: check if word list empty.\n\nBut simpler: we can use a loop to iterate characters, build words, store. But we can just split. But we can include a loop for manual extraction to illustrate algorithm.\n\nLet's produce virtual code with Start, Decision, loops, etc.\n\nStructure:\n\nStart\n→ Step 1: Read string s // get input\n→ Step 2: Initialize empty list words // to hold words\n→ Step 3: Initialize empty string currentWord // to accumulate characters\n→ Decision: If s is empty? // check\n    Yes → Step 4: Output empty string // no words\n    No  → Step 5: For each char c in s // iterate over characters\n        → Decision: If c is space? // delimiter\n            Yes → Decision: If currentWord is not empty? // finished a word\n                Yes → Step 6: Append currentWord to words // add word\n                No  → Step 7: Do nothing // no word to add\n                End\n            No  → Step 8: Append c to currentWord // accumulate char\n        End\n    → End For\n→ Decision: If currentWord is not empty? // last word after loop\n    Yes → Step 9: Append currentWord to words\n    No  → Step 10: Do nothing\n→ Step 11: Reverse words list // reverse order\n→ Step 12: Join words with single space to form result string // concatenate\n→ Step 13: Output result // return string\nEnd\n\nBut we can also have Decision: if words empty, return empty string.\n\nBut we already handle.\n\nMake sure each line includes arrow etc.\n\nWe should include indentation for nested decisions/loops: maybe use spaces.\n\nWe need to include \"→ Decision:\" lines with Yes / No arrows. Use \"→\" for steps.\n\nLet's produce final answer.\n\nUse exactly the format: each line: virtual code step + space + // explanation.\n\nMake sure to include 'Start' and 'End'.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取輸入字串 s // 取得使用者輸入的原始字串  \n→ Step 2: 初始化空清單 words // 用於儲存分離出的單字  \n→ Step 3: 初始化空字串 currentWord // 用於累積目前正處理的字元  \n→ Decision: 若 s 為空字串? // 檢查是否有輸入  \n Yes → Step 4: 輸出空字串 // 沒有任何字串，直接回傳空值  \n No → Step 5: 對 s 中每個字元 c 執行循環 // 逐字元處理  \n    → Decision: 若 c 為空白? // 判斷是否為分隔符  \n     Yes → Decision: 若 currentWord 非空? // 完成一個單字？  \n      Yes → Step 6: 將 currentWord 加入 words 清單 // 存下單字  \n      No  → Step 7: 不做任何事 // 沒有單字要加入  \n      End  \n     No  → Step 8: 將 c 加到 currentWord 末尾 // 仍在累積單字  \n     End  \n    End 循環  \n→ Decision: 若 currentWord 非空? // 可能有最後一個單字未加入  \n Yes → Step 9: 將 currentWord 加入 words 清單  \n No  → Step 10: 不做任何事  \n→ Step 11: 反轉 words 清單 // 取得單字的逆序排列  \n→ Step 12: 用單一空白字元將 words 清單連接成字串 result // 形成輸出字串  \n→ Step 13: 輸出 result // 回傳最終結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def reverseWords(self, s: str) -> str:\n        \"\"\"\n        將輸入字串 s 中的單字順序反轉。\n        步驟：\n        1. 去除前後空白字元，避免空白影響拆分。\n        2. 以空白拆分成單字清單，split() 會自動忽略多餘空白。\n        3. 反轉單字清單。\n        4. 以單一空白字元連接回字串。\n        \"\"\"\n        words = s.strip().split()          # 取得所有單字\n        return ' '.join(words[::-1])       # 反轉後再連接\n\ndef main() -> None:\n    \"\"\"\n    主程式，負責從標準輸入讀取字串、處理後輸出。\n    1. 讀取整個輸入（允許多行或包含前後空白）。\n    2. 若輸入形式為 's = \"...\"'，則進行簡易解析，去除等號與雙引號。\n    3. 呼叫 Solution.reverseWords 進行單字反轉。\n    4. 將結果輸出至標準輸出。\n    \"\"\"\n    raw_input = sys.stdin.read()               # 讀取所有輸入\n    s = raw_input.strip('\\n')                  # 去除最後換行\n\n    # 如果輸入格式為 's = \"xxx\"'，嘗試解析\n    if '=' in s:\n        _, rest = s.split('=', 1)\n        rest = rest.strip()\n        if rest and rest[0] in ('\"', \"'\") and rest[-1] == rest[0]:\n            rest = rest[1:-1]                  # 去除雙引號\n        s = rest\n\n    solution = Solution()\n    result = solution.reverseWords(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"the sky is blue\"",
          "expected_output": "\"blue is sky the\"",
          "success": true,
          "output": "blue is sky the"
        },
        {
          "example_index": 1,
          "input": "s = \"  hello world  \"",
          "expected_output": "\"world hello\"",
          "success": true,
          "output": "world hello"
        },
        {
          "example_index": 2,
          "input": "s = \"a good   example\"",
          "expected_output": "\"example good a\"",
          "success": true,
          "output": "example good a"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode27.json",
    "problem_index_in_file": 0,
    "title": "Remove Element",
    "description_snippet": "Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to output virtual code line by line with explanation. The problem: Remove all occurrences of val from nums array in place, return k. We need to describe algorithm: two pointers: i traverse, j write pointer. For each element, if nums[i] != val, set nums[j]=nums[i], j++. Finally return j.\n\nLet's produce steps: Start, → Step: set writeIndex=0 // pointer for next position. → Loop i from 0 to length-1 // traverse array. → Decision: if nums[i] != val? Yes → assign nums[writeIndex] = nums[i] // keep element, writeIndex++ // move write pointer. No → skip. After loop, k = writeIndex // number of kept elements. End.\n\nAlso maybe we want to clear remaining? Not required.\n\nWe need each line: \"虛擬碼步驟 // 解釋\". Use arrow \"→\". Decision lines use \"Decision:\". Start/End. Let's produce.\n\nWe need to use \"虛擬碼步驟\" not actual code, but description. So use something like:\n\nStart // 程式開始執行\n→ Step: 設定 writeIndex = 0 // 初始化寫入指標\n→ Step: 從 i = 0 到 nums.length - 1 // 逐一遍歷陣列\n→ Decision: 如果 nums[i] != val? // 判斷當前元素是否為要保留的\n    Yes → Step: nums[writeIndex] = nums[i] // 把元素寫入寫入指標位置\n    Yes → Step: writeIndex++ // 移動寫入指標\n    No  → Step: 跳過 // 直接忽略該元素\n→ Step: k = writeIndex // 最終保留元素個數\nEnd // 程式執行結束\n\nBut format expects each line with step plus comment after space. For decision block, we need sublines. Use indentation maybe.\n\nLet's craft final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: writeIndex = 0 // 初始化寫入指標，指向未填入元素的第一個位置  \n→ Step: i = 0, loop until i < nums.length // 逐一遍歷整個陣列  \n→ Decision: 如果 nums[i] != val? // 判斷當前元素是否應保留  \n  Yes → Step: nums[writeIndex] = nums[i] // 把符合條件的元素寫入 writeIndex 所在位置  \n  Yes → Step: writeIndex++ // 移動寫入指標，準備寫入下一個保留元素  \n  No  → Step: 跳過 // 若元素為 val，直接忽略，寫入指標不變  \n→ Step: k = writeIndex // writeIndex 代表保留元素的個數，也是結果 k  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport re\n\nclass Solution:\n    def removeElement(self, nums, val):\n        \"\"\"Remove all occurrences of val in nums in-place and return the new length.\"\"\"\n        slow = 0\n        for fast in range(len(nums)):\n            if nums[fast] != val:\n                nums[slow] = nums[fast]\n                slow += 1\n        return slow\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Parse input like: \"nums = [3,2,2,3], val = 3\"\n    pattern = r'nums\\s*=\\s*(\\[.*?\\])\\s*,\\s*val\\s*=\\s*(-?\\d+)'\n    match = re.search(pattern, data, re.DOTALL)\n    if not match:\n        print(\"Invalid input format\")\n        return\n\n    nums_str, val_str = match.group(1), match.group(2)\n    nums = ast.literal_eval(nums_str)\n    val = int(val_str)\n\n    sol = Solution()\n    k = sol.removeElement(nums, val)\n\n    # Build representation: first k elements, then underscores for remaining positions\n    elements = [str(nums[i]) for i in range(k)] + ['_' for _ in range(len(nums) - k)]\n    array_repr = ','.join(elements)\n\n    print(f\"{k}, nums = [{array_repr}]\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [3,2,2,3], val = 3",
          "expected_output": "2, nums = [2,2,_,_]",
          "success": true,
          "output": "2, nums = [2,2,_,_]"
        },
        {
          "example_index": 1,
          "input": "nums = [0,1,2,2,3,0,4,2], val = 2",
          "expected_output": "5, nums = [0,1,4,0,3,_,_,_]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '5,nums=[0,1,4,0,3,_,_,_]'\nGot (Norm):      '5,nums=[0,1,3,0,4,_,_,_]'\n--- (Raw) ---\nRaw Expected: '5, nums = [0,1,4,0,3,_,_,_]'\nRaw Got:      '5, nums = [0,1,3,0,4,_,_,_]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode357.json",
    "problem_index_in_file": 0,
    "title": "Count Numbers with Unique Digits",
    "description_snippet": "Given an integer n, return the count of all numbers with unique digits, x, where 0 <= x < 10^n....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode lines. The problem: Count numbers with unique digits x where 0 <= x < 10^n. For integer n. So numbers from 0 to 10^n-1 inclusive, n-digit numbers including leading zeros? Usually numbers less than 10^n: digits up to n digits, but leading zeros not counted; but unique digits property for actual number's digits (without leading zeros). For 0, unique. We just need count.\n\nWe can produce algorithm: If n==0 return 1 (only 0?). But typical Leetcode 357. For n <= 10, answer is 1 + sum_{k=1}^{n} 9 * P(9, k-1). For n>10 answer is 10! + 1. But we can produce general algorithm.\n\nLet's produce pseudocode stepwise:\n\nStart\n→ Decision: If n == 0? // Handle zero-digit case\n    Yes → Return 1 // only number 0\n    No  → Decision: If n > 10? // more digits than unique digits\n        Yes → Return 10! + 1 // all permutations of 10 digits + 0\n        No  → Step 1: 初始化 count = 1 // includes 0\n→ Step 2: For length i from 1 to n: // iterate number of digits\n        → Step 2.1: If i == 1? // one-digit numbers\n                count += 9 // digits 1-9\n            Else:\n                → Step 2.2: Initialize permutations = 9 // first digit can't be zero\n                → Step 2.3: For j from 1 to i-1:\n                        → Step 2.3.1: permutations *= (10 - j) // choose remaining digits\n                → Step 2.4: count += permutations // add numbers with i digits\n→ End // return count\n\nAlso maybe we need to explain each line.\n\nWe must use arrow formatting: 'Start', 'End', 'Decision:', 'Yes →', 'No →', '→'.\n\nAlso each line includes // explanation.\n\nMake sure each line uses the arrow style.\n\nLet's write:\n\nStart // 程式開始\n→ Decision: 如果 n 等於 0? // n 為 0 時只存在 0\n    Yes → Return 1 // 回傳 1\n    No  → Decision: 如果 n 大於 10? // 超過 10 位數，無法保持唯一\n        Yes → Return 10! + 1 // 所有 10 位數排列 + 0\n        No  → Step 1: 初始化 count 為 1 // 包含 0\n→ Step 2: 從 1 到 n 逐位長度處理\n→ Decision: 如果 i 等於 1? // 一位數\n    Yes → count += 9 // 1~9\n    No  → Step 3: 計算 i 位數的排列\n        → Step 3.1: 初始化 permutations 為 9 // 第一位不能為 0\n        → Step 3.2: 從 j = 1 到 i-1\n            → Step 3.2.1: permutations *= (10 - j) // 選擇剩餘位數\n        → Step 3.3: count += permutations // 加入此長度的數量\n→ End // 回傳 count\n\nBut we need to produce each line individually; the loops might be nested but still line by line. We need to show loops explicitly with indentation perhaps. Format should be one line per step, but we can include nested steps as separate lines with indentation to indicate structure. Use spaces for indentation.\n\nWe should use '→' for normal steps, 'Decision:' for decisions, 'Yes →', 'No →' for branches.\n\nWe must not output real code, just pseudocode.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: n 等於 0? // 若 n 為 0 只剩 0  \n    Yes → Return 1 // 回傳 1，代表數字 0  \n    No  → Decision: n 大於 10? // 超過 10 位數時無法保持唯一性  \n        Yes → Return 10! + 1 // 所有 10 位數排列 + 0  \n        No  → Step 1: 設定 count 為 1 // 初始計數包含 0  \n\n→ Step 2: 從 1 到 n 逐位長度處理  \n    → Decision: i 等於 1? // 一位數  \n        Yes → count += 9 // 一位數 1~9 共 9 個  \n        No  → Step 3: 計算 i 位數的排列  \n            → Step 3.1: 設定 permutations 為 9 // 第一位不能為 0  \n            → Step 3.2: 從 j = 1 到 i-1  \n                → Step 3.2.1: permutations *= (10 - j) // 選擇剩餘位數的可用選項  \n            → Step 3.3: count += permutations // 加入此長度的數量  \n\nEnd // 回傳最終計數結果",
      "generated_code": "import sys\nimport math\nimport re\n\ndef count_numbers_with_unique_digits(n: int) -> int:\n    \"\"\"Count all non‑negative integers x < 10**n that have all unique digits.\"\"\"\n    if n == 0:\n        return 1                       # only the number 0\n\n    n = min(n, 10)                     # more than 10 digits can't be unique\n    res = 10                           # 0‑9: all 10 numbers\n    unique_digits = 9                  # first digit choices (1‑9)\n    available = 9                      # remaining digits to use\n\n    for _ in range(2, n + 1):\n        unique_digits *= available      # add one more digit\n        res += unique_digits\n        available -= 1\n\n    return res\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Extract the first integer from the input; works for \"n = 2\", \"2\", etc.\n    nums = re.findall(r'\\d+', data)\n    if not nums:\n        return\n\n    n = int(nums[0])\n    result = count_numbers_with_unique_digits(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 2",
          "expected_output": "91",
          "success": true,
          "output": "91"
        },
        {
          "example_index": 1,
          "input": "n = 0",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode392.json",
    "problem_index_in_file": 0,
    "title": "Is Subsequence",
    "description_snippet": "Given two strings s and t, return true if s is a subsequence of t, or false otherwise.\n\nA subsequenc...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for checking if s is subsequence of t. Provide step-by-step virtual code lines with arrow and decisions. Use Start, End, Decision: etc. Provide simple steps: two pointers. Should be line by line. Each line: \"虛擬碼步驟 // 解釋\". Provide arrow for flow. For decisions use \"Decision: ...\" with Yes →, No →.\n\nLet's write:\n\nStart // program start\n\n→ Step 1: Set i = 0, j = 0 // initialize pointers\n\n→ Decision: If i == length of s? // check if all chars matched\n\n    Yes → Step 2: Return true // s is subsequence\n\n    No  → Decision: If j == length of t? // check if t exhausted\n\n        Yes → Step 3: Return false // t exhausted but s not matched\n\n        No  → Decision: If s[i] == t[j]? // compare current chars\n\n            Yes → Step 4: i = i + 1 // move s pointer\n\n            No  → Step 5: j = j + 1 // skip char in t\n\n            // after each comparison, loop back to Decision at i==len(s)?\n\nWe need a loop structure: after step 4 or 5, go back to Decision i==len(s). Use arrow \"→\" to loop. Use \"→\" arrow back.\n\nWe need to use \"Decision:\" lines. Use \"→\" to indicate next step.\n\nWe can structure with labels.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: i ← 0, j ← 0 // 初始化兩個指標\n→ Decision: i == |s|? // s 全部匹配完畢？\n    Yes → Step 2: return true // s 為 t 的子序列\n    No  → Decision: j == |t|? // t 是否已被完全遍歷？\n        Yes → Step 3: return false // t 結束但 s 未匹配完\n        No  → Decision: s[i] == t[j]? // 比較當前字符\n            Yes → Step 4: i ← i + 1 // s 指標向前\n            No  → Step 5: j ← j + 1 // t 指標向前\n            // 後續回到最上方的判斷 i == |s|？\n            → GoBack // 返回判斷\n\nBut we need explicit arrow: \"→\" to next step. Use \"→\" after Step 5 to go back to Decision: i == |s|?.\n\nBetter:\n\nStart\n→ Step 1: i ← 0, j ← 0\n→ Decision: i == |s|? \n    Yes → Step 2: return true\n    No  → Decision: j == |t|? \n        Yes → Step 3: return false\n        No  → Decision: s[i] == t[j]? \n            Yes → Step 4: i ← i + 1\n            No  → Step 5: j ← j + 1\n            // 循環回到頂部\n            → Step 1? Actually we need to loop back. We can use \"→\" to step 1 but step 1 reinitialize. Instead we need a loop. Let's label \"LoopStart\". Let's modify.\n\nStart\n→ LoopStart: // 迴圈起點\n    → Decision: i == |s|?\n        Yes → Step 1: return true\n        No  → Decision: j == |t|?\n            Yes → Step 2: return false\n            No  → Decision: s[i] == t[j]?\n                Yes → Step 3: i ← i + 1\n                No  → Step 4: j ← j + 1\n            → LoopStart // 回到迴圈起點\n\nEnd // 程式結束\n\nWe should ensure each line uses the format: \"虛擬碼步驟 // 解釋\".\n\nThus produce lines accordingly.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ LoopStart // 迴圈起點  \n    → Decision: i == |s|? // 檢查是否已經比對完 s 的全部字元  \n        Yes → Step 1: return true // s 完全是 t 的子序列  \n        No  → Decision: j == |t|? // 檢查 t 是否已遍歷完  \n            Yes → Step 2: return false // t 結束但 s 還未匹配完  \n            No  → Decision: s[i] == t[j]? // 比對目前兩個指標指向的字元  \n                Yes → Step 3: i ← i + 1 // s 的指標往前移動  \n                No  → Step 4: j ← j + 1 // t 的指標往前移動  \n            → LoopStart // 回到迴圈起點，重新檢查條件  \nEnd // 程式結束執行",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def isSubsequence(self, s: str, t: str) -> bool:\n        if not s:\n            return True\n        index_s = 0\n        for char in t:\n            if char == s[index_s]:\n                index_s += 1\n                if index_s == len(s):\n                    return True\n        return False\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    # Extract quoted strings (s and t)\n    matches = re.findall(r'\"([^\"]*)\"', data)\n    if len(matches) >= 2:\n        s, t = matches[0], matches[1]\n    else:\n        # Fallback: assume two lines without quotes\n        lines = data.splitlines()\n        s = lines[0].strip() if len(lines) > 0 else \"\"\n        t = lines[1].strip() if len(lines) > 1 else \"\"\n\n    solution = Solution()\n    result = solution.isSubsequence(s, t)\n    print(str(result).lower())\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"abc\", t = \"ahbgdc\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "s = \"axc\", t = \"ahbgdc\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode91.json",
    "problem_index_in_file": 0,
    "title": "Decode Ways",
    "description_snippet": "You have intercepted a secret message encoded as a string of numbers. The message is decoded via the...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps line by line with explanations. Use arrow and Decision. We must produce for decoding ways problem: typical DP. Outline: Start, read string s, handle empty, init dp array length n+1, dp[0]=1, dp[1] depends on s[0] != '0'. Loop i from 2 to n: single digit check s[i-1] != '0' then dp[i] += dp[i-1]; two-digit check s[i-2..i-1] between \"10\" and \"26\" then dp[i] += dp[i-2]; finally return dp[n].\n\nAdd decision steps for zero, bounds. Use comments.\n\nNeed to ensure each line has \"虛擬碼步驟 [space] // 解釋/說明\".\n\nWe can include Start, End.\n\nLet's produce. Use Chinese explanation.\n\nLet's craft lines.\n\nWe might need variable names: n, dp, i, s.\n\nStart // 程式開始執行\n→ Step 1: 輸入字串 s // 取得需要解碼的數字字串\n→ Decision: 如果 s 為空? // 空字串無法解碼\n    Yes → Step 2: 回傳 0 // 沒有可行解碼方式\n    No  → Continue\n→ Step 3: 設定 n ← length(s) // 字串長度\n→ Step 4: 建立 dp 陣列長度 n+1，全部初始化為 0 // dp[i] 代表前 i 個字符的解碼方式數\n→ Step 5: 設定 dp[0] ← 1 // 空前綴有一種解碼方式（空解）\n→ Decision: s[0] 是否為 '0'? // 單位碼不能以 0 開頭\n    Yes → Step 6: 回傳 0 // 字串以 0 開頭無法解碼\n    No  → Step 7: 設定 dp[1] ← 1 // 第一個字符可合法解碼\n→ Decision: n 是否等於 1? // 只剩一個字符已處理完畢\n    Yes → Step 8: 回傳 dp[1] // 結束並回傳結果\n    No  → Continue\n→ Step 9: 從 i = 2 到 n 進行迴圈 // 逐步考慮前 i 個字符\n    → Decision: s[i-1] 是否為 '0'? // 單位碼為 0 時不能單獨解碼\n        Yes → Step 10: dp[i] ← dp[i] + 0 // 不增加任何解碼方式\n        No  → Step 11: dp[i] ← dp[i] + dp[i-1] // 單位碼合法，累加前一個位置的解碼數\n    → Step 12: 取 substring two ← s[i-2]s[i-1] // 兩位數字\n    → Decision: two 是否在範圍 \"10\" 到 \"26\"? // 兩位數字合法\n        Yes → Step 13: dp[i] ← dp[i] + dp[i-2] // 累加前兩個位置的解碼數\n        No  → No operation // 不合法則不加\n→ Step 14: 回傳 dp[n] // 完整字串的解碼方式數\nEnd // 程式執行結束\n\nWe need to ensure each line is separate, with arrow. Use \"→\" at start of step lines. Also include decision block lines? For decisions, we need to indent? In example, Decision block indent. We can follow same format: Decision line, then Yes → ... No → ... But if no Yes path, still we can write No path maybe. For simplicity we can keep Yes and No lines even if only one. Use same indentation style.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入字串 s // 取得需要解碼的數字字串  \n→ Decision: s 是否為空? // 判斷字串是否為空  \n  Yes → Step 2: 回傳 0 // 空字串無法解碼  \n  No → Continue  \n→ Step 3: 設定 n ← length(s) // 字串長度  \n→ Step 4: 建立 dp 陣列長度 n+1，全部初始化為 0 // dp[i] 代表前 i 個字符的解碼方式數  \n→ Step 5: 設定 dp[0] ← 1 // 空前綴有一種解碼方式（空解）  \n→ Decision: s[0] 是否為 '0'? // 單位碼不能以 0 開頭  \n  Yes → Step 6: 回傳 0 // 字串以 0 開頭無法解碼  \n  No → Step 7: 設定 dp[1] ← 1 // 第一個字符可合法解碼  \n→ Decision: n 是否等於 1? // 只剩一個字符已處理完畢  \n  Yes → Step 8: 回傳 dp[1] // 結束並回傳結果  \n  No → Continue  \n→ Step 9: 從 i = 2 到 n 進行迴圈 // 逐步考慮前 i 個字符  \n  → Decision: s[i-1] 是否為 '0'? // 單位碼為 0 時不能單獨解碼  \n   Yes → Step 10: dp[i] ← dp[i] + 0 // 不增加任何解碼方式  \n   No → Step 11: dp[i] ← dp[i] + dp[i-1] // 單位碼合法，累加前一個位置的解碼數  \n  → Step 12: 取 substring two ← s[i-2]s[i-1] // 兩位數字  \n  → Decision: two 是否在範圍 \"10\" 到 \"26\"? // 兩位數字合法  \n   Yes → Step 13: dp[i] ← dp[i] + dp[i-2] // 累加前兩個位置的解碼數  \n  No → No operation // 不合法則不加  \n→ Step 14: 回傳 dp[n] // 完整字串的解碼方式數  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def numDecodings(self, s: str) -> int:\n        if not s or s[0] == '0':\n            return 0\n        n = len(s)\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        dp[1] = 1\n        for i in range(2, n + 1):\n            if s[i - 1] != '0':\n                dp[i] += dp[i - 1]\n            two_digit = int(s[i - 2:i])\n            if 10 <= two_digit <= 26:\n                dp[i] += dp[i - 2]\n        return dp[n]\n\nif __name__ == \"__main__\":\n    # Read entire input, remove whitespace\n    raw_input = sys.stdin.read().strip()\n    # Extract the string between double quotes\n    try:\n        s = raw_input.split('\"')[1]\n    except IndexError:\n        # If format is not as expected, treat whole input as the string\n        s = raw_input\n    result = Solution().numDecodings(s)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"12\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "s = \"226\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 2,
          "input": "s = \"06\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode523.json",
    "problem_index_in_file": 0,
    "title": "Continuous Subarray Sum",
    "description_snippet": "Given an integer array nums and an integer k, return true if nums has a good subarray or false other...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode line by line with explanations. Task: determine if array has subarray length >=2 whose sum is multiple of k. Standard algorithm: prefix sum modulo k. Keep map of first occurrence of mod value. For each index i, compute prefix sum modulo k. If mod seen before and difference length >=2? Actually we store earliest index for each mod. When encountering same mod at i, difference length = i - prevIndex. Need >=2. Also handle k=0 separately: check if any two consecutive numbers sum to 0? Actually subarray sum multiple of 0 only when sum==0. So check any subarray of length >=2 with sum zero. Use sliding window? But simpler: compute prefix sums and check if any two equal prefix sums with distance >=2. Because sum diff zero. That works. So general algorithm: map mod->firstIndex. For i from 0 to n-1: prefix += nums[i]; mod = (k==0? prefix : prefix % k); if mod in map: if i - map[mod] >= 2 -> true; else continue; else store map[mod]=i. But also need to handle mod 0 first? Actually we need subarray of length >=2. So we should initialize map with mod 0 at index -1? For sum of first two elements? Wait typical approach for length>=2: store first occurrence. For index i, if mod seen before at index j: length = i-j; need >=2. Works. If not seen, store mod at index i. No need for index -1.\n\nEdge case: subarray starting at 0: need mod seen before? For subarray from 0 to i, sum is prefix. To have sum multiple of k, need prefix % k == 0 and length>=2 -> i>=1. So when we compute prefix at i, mod==0: check if i>=1? but map may not have mod 0. We could set map[0] = -1 initially to allow. Then length = i-(-1)=i+1, need >=2 => i>=1. Works. For k==0: we want prefix difference zero: use map of prefix sums. We can treat mod as prefix itself; but we need to check same prefix sum at distance >=2. So map of prefix sum to earliest index. Start with prefix=0 at index -1. Works.\n\nThus pseudocode lines: Start, initialize sum=0, map, add base. Loop indices. Compute sum, mod, Decision on k==0? Actually we can unify by if k==0 then mod = sum; else mod = sum%k. Then check if mod in map and i - map[mod] >=2 -> return true. If not, if mod not in map: map[mod]=i. After loop, return false.\n\nWe need to produce lines with arrows and decisions. Provide comments. Use virtual code with arrows. Provide each line.\n\nLet's create:\n\nStart // 程式開始\n\n→ Step 1: sum ← 0 // 初始化累加和\n\n→ Step 2: map ← {} // 建立空字典存儲第一次出現的模值\n\n→ Decision: k = 0? // 判斷 k 是否為 0，以決定模運算方式\n\n    Yes → Step 3a: baseMod ← 0 // k 為 0 時，模值為累加和本身，基底設為 0\n    No  → Step 3b: baseMod ← 0 // k 不為 0 時，基底也為 0，方便存儲模值\n\n→ Step 4: map[baseMod] ← -1 // 把基底模值對應的索引設為 -1，代表前置位置\n\n→ For i from 0 to n-1: // 遍歷數組\n\n    → Step 5: sum ← sum + nums[i] // 更新累加和\n\n    → Decision: k = 0? // 根據 k 是否為 0 計算模值\n\n        Yes → Step 6a: mod ← sum // k=0 時，模值直接為累加和\n        No  → Step 6b: mod ← sum mod k // k≠0 時，取餘數\n\n    → Decision: mod 存於 map 且 i - map[mod] ≥ 2? // 檢查是否已見過此模值且距離 ≥2\n\n        Yes → Step 7: return true // 找到符合條件的子陣列\n\n        No  → Decision: mod 是否已存在於 map? // 若尚未存儲，將此索引記錄\n\n            Yes → Step 8: // 已存在但距離 <2，跳過\n                // 何不做任何操作\n            No  → Step 9: map[mod] ← i // 記錄首次出現的索引\n\n→ Step 10: return false // 完全遍歷後未找到符合條件的子陣列\n\nEnd // 程式結束\n\nWe must include arrow and comments after each line. Let's format exactly as example. Use \"→\" before each step, indent decisions properly. Use `Decision:`. Also must use [空格] before comment. Provide each line.\n\nEnsure each line includes virtual code then space then comment. Use indentation lines inside decision blocks but keep `→` for each line. Use proper indentation like example. Provide explanation.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: sum ← 0 // 初始化累加和為 0  \n→ Step 2: map ← {} // 建立空字典用於儲存第一次出現的模值  \n→ Decision: k = 0? // 判斷 k 是否為 0，以決定後續模運算方式  \n Yes → Step 3a: baseMod ← 0 // k 為 0 時，模值直接為累加和，基底設為 0  \n No  → Step 3b: baseMod ← 0 // k ≠ 0 時，基底也設為 0，方便存儲模值  \n→ Step 4: map[baseMod] ← -1 // 把基底模值對應的索引設為 -1，代表前置位置  \n→ For i from 0 to n-1: // 遍歷數組的每個索引  \n → Step 5: sum ← sum + nums[i] // 更新累加和  \n → Decision: k = 0? // 根據 k 是否為 0 計算模值  \n  Yes → Step 6a: mod ← sum // k=0 時，模值直接為累加和  \n  No  → Step 6b: mod ← sum mod k // k≠0 時，取餘數  \n → Decision: mod 存於 map 且 i - map[mod] ≥ 2? // 檢查是否已見過此模值且距離 ≥2  \n  Yes → Step 7: return true // 找到符合條件的子陣列，直接返回 true  \n  No  → Decision: mod 是否已存在於 map? // 若尚未存儲，將此索引記錄  \n   Yes → Step 8: // 已存在但距離 <2，跳過不做任何操作  \n   No  → Step 9: map[mod] ← i // 記錄此模值首次出現的索引  \n→ Step 10: return false // 完全遍歷後仍未找到符合條件的子陣列，返回 false  \nEnd // 程式結束執行",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def checkSubarraySum(self, nums, k):\n        \"\"\"\n        判斷 nums 是否存在長度至少 2 的子陣列，其和為 k 的倍數。\n        \"\"\"\n        mod_map = {0: -1}          # 將模值 0 的索引初始化為 -1，方便處理從頭開始的子陣列\n        total = 0\n        for i, num in enumerate(nums):\n            total += num\n            if k != 0:            # k = 0 時，模值直接為總和\n                total %= k\n            if total in mod_map:\n                if i - mod_map[total] > 1:  # 長度至少 2\n                    return True\n            else:\n                mod_map[total] = i\n        return False\n\ndef parse_input(raw_input: str):\n    \"\"\"\n    從輸入字串中解析出整數陣列 nums 與整數 k。\n    支援以下兩種常見輸入格式：\n        1. '[1,2,3], 6'\n        2. [1,2,3]\\n6\n    \"\"\"\n    raw_input = raw_input.strip()\n    # 找到第一個 '[' 與第一個 ']' 之間的子字串作為陣列\n    try:\n        start = raw_input.index('[')\n        end = raw_input.index(']', start)\n    except ValueError:\n        raise ValueError(\"無法辨識陣列格式\")\n    list_str = raw_input[start+1:end]\n    nums = [int(x.strip()) for x in list_str.split(',') if x.strip()]\n    # 取得 ']' 之後的字串作為 k\n    k_part = raw_input[end+1:].strip()\n    # 可能以逗號分隔\n    if k_part.startswith(','):\n        k_part = k_part[1:].strip()\n    if not k_part:\n        raise ValueError(\"無法辨識 k 的值\")\n    k = int(k_part.split()[0])   # 只取第一個整數\n    return nums, k\n\nif __name__ == \"__main__\":\n    raw = sys.stdin.read()\n    nums, k = parse_input(raw)\n    solution = Solution()\n    result = solution.checkSubarraySum(nums, k)\n    print(str(result).lower())",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[23,2,4,6,7], 6",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "[23,2,6,4,7], 6",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "[23,2,6,4,7], 13",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode41.json",
    "problem_index_in_file": 0,
    "title": "First Missing Positive",
    "description_snippet": "Given an unsorted integer array nums. Return the smallest positive integer that is not present in nu...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps with comments explaining each line. The algorithm: find smallest missing positive. Approach: place each number in correct index by swapping, then scan for first index where value != index+1, return index+1; else return n+1.\n\nNeed to output steps line by line with arrows and decisions. Each line: \"虛擬碼步驟\" space \"// 解釋\".\n\nLet's craft the steps. Starting with Start. Then Step 1: let n = length of nums. Step 2: iterate i from 0 to n-1. Within, while nums[i] in [1,n] and nums[i] != nums[nums[i]-1], swap. Step 3: after placement, iterate again to find first index where nums[i] != i+1. Return i+1. If none, return n+1. End.\n\nAlso include Decision to check swapping condition, etc.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: n ← length(nums) // 獲取陣列長度\n→ Step 2: i ← 0 // 初始化索引\n→ Decision: i < n? // 是否還有元素要處理？\n    Yes → Step 3: curr ← nums[i] // 取得目前元素\n    → Decision: 1 ≤ curr ≤ n AND curr ≠ nums[curr-1]? // 檢查是否能放到正確位置\n        Yes → Step 4: swap(nums[i], nums[curr-1]) // 交換到正確位置\n        No → Step 5: i ← i + 1 // 跳過此索引\n    No → // 完成位置調整\n→ Step 6: i ← 0 // 重新從頭開始檢查\n→ Decision: i < n? // 檢查陣列中是否有缺失正整數\n    Yes → Decision: nums[i] ≠ i+1? // 索引對應的值是否正確？\n        Yes → Step 7: return i+1 // 找到第一個缺失正整數\n        No  → Step 8: i ← i + 1 // 繼續檢查\n    No → Step 9: return n+1 // 所有正整數都存在，返回 n+1\nEnd // 程式執行結束\n\nWe need to ensure every line has arrow and comment. For decisions, we need indentation. Use \"→ Decision:\" lines.\n\nAlso, note that we used Step 2: i ← 0. That might need to be Start of loop. Might need to show while loop with decision.\n\nBetter to structure as:\n\nStart\n→ Step 1: n ← length(nums)\n→ Step 2: i ← 0\n→ Decision: i < n?\n    Yes → Step 3: curr ← nums[i]\n    → Decision: 1 ≤ curr ≤ n AND curr ≠ nums[curr-1]?\n        Yes → Step 4: swap(nums[i], nums[curr-1])\n        No  → Step 5: i ← i + 1\n    No → // finished first pass\n→ Step 6: i ← 0\n→ Decision: i < n?\n    Yes → Decision: nums[i] ≠ i+1?\n        Yes → Step 7: return i+1\n        No  → Step 8: i ← i + 1\n    No → Step 9: return n+1\nEnd\n\nLet's output accordingly. Use Chinese comments. Ensure each line has \"虛擬碼步驟\" plus comment. We'll keep step numbers and decisions. No actual code. Let's deliver.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← length(nums) // 取得陣列長度  \n→ Step 2: i ← 0 // 初始化索引  \n→ Decision: i < n? // 是否還有元素需要調整？  \n Yes → Step 3: curr ← nums[i] // 取得目前元素  \n  → Decision: 1 ≤ curr ≤ n AND curr ≠ nums[curr-1]? // 檢查元素是否在可用範圍且不在正確位置  \n   Yes → Step 4: swap(nums[i], nums[curr-1]) // 交換至正確位置，保持 curr 不變以便再次檢查  \n   No → Step 5: i ← i + 1 // 進到下一個索引  \n No → // 第一輪位置調整完成  \n→ Step 6: i ← 0 // 重新從頭開始檢查缺失值  \n→ Decision: i < n? // 是否還有索引未檢查？  \n Yes → Decision: nums[i] ≠ i+1? // 索引對應的值是否正確？  \n  Yes → Step 7: return i+1 // 找到第一個缺失正整數  \n  No → Step 8: i ← i + 1 // 進到下一個索引  \n No → Step 9: return n+1 // 所有正整數皆存在，返回 n+1  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def firstMissingPositive(self, nums):\n        n = len(nums)\n        for i in range(n):\n            while 1 <= nums[i] <= n and nums[nums[i]-1] != nums[i]:\n                nums[nums[i]-1], nums[i] = nums[i], nums[nums[i]-1]\n        for i in range(n):\n            if nums[i] != i + 1:\n                return i + 1\n        return n + 1\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # If input contains 'nums = ...', strip the variable name\n    if '=' in data:\n        _, part = data.split('=', 1)\n        part = part.strip()\n    else:\n        part = data\n\n    # Safely evaluate the list expression\n    nums = ast.literal_eval(part)\n\n    result = Solution().firstMissingPositive(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,0]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [3,4,-1,1]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "nums = [7,8,9,11,12]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode551.json",
    "problem_index_in_file": 0,
    "title": "Student Attendance Record I",
    "description_snippet": "You are given a string s representing an attendance record for a student where each character signif...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code with explanation lines. The logic: iterate through string s, count A, track consecutive L count. At end, check conditions. Virtual code steps line by line. Use Start, Decision, etc. Use arrows. Ensure each line: \"虛擬碼步驟 // 解釋\". So maybe:\n\nStart // 程式開始\n→ Step 1: 初始化 absentCount = 0, consecutiveLate = 0, maxConsecutiveLate = 0 // 設定計數器\n→ Step 2: 對於每個字符 c in s 遍歷 // 逐日檢查\n   → Decision: 如果 c == 'A'? // 檢查缺席\n       Yes → Step 3: absentCount += 1 // 計算缺席天數\n   → Decision: 如果 c == 'L'? // 檢查遲到\n       Yes → Step 4: consecutiveLate += 1 // 連續遲到天數累加\n       No  → Step 5: consecutiveLate = 0 // 遲到結束，重置\n   → Step 6: 更新 maxConsecutiveLate = max(maxConsecutiveLate, consecutiveLate) // 更新最大連續遲到\n→ Decision: absentCount < 2? // 檢查缺席天數\n    Yes → Step 7: Decision: maxConsecutiveLate < 3? // 檢查遲到連續天數\n        Yes → Step 8: Output true // 兩條件滿足\n        No  → Step 9: Output false // 連續遲到太多\n    No  → Step 10: Output false // 缺席太多\nEnd // 程式結束\n\nWe should format each line accordingly. Use \"Step X:\" or just \"Step X\". Use \"Decision:\" lines. Use arrows \"→\" and \"Yes →\" etc. Need to ensure each line has a single statement. For the for-loop we might need nested steps. Let's structure:\n\nStart\n→ Step 1: 初始化 absentCount = 0, consecutiveLate = 0, maxConsecutiveLate = 0\n→ Step 2: 對 s 進行逐字符遍歷\n   → Decision: 如果 c == 'A'?\n       Yes → Step 3: absentCount += 1\n       No →\n   → Decision: 如果 c == 'L'?\n       Yes → Step 4: consecutiveLate += 1\n       No  → Step 5: consecutiveLate = 0\n   → Step 6: maxConsecutiveLate = max(maxConsecutiveLate, consecutiveLate)\n→ Decision: absentCount < 2?\n    Yes → Decision: maxConsecutiveLate < 3?\n        Yes → Step 7: 輸出 true\n        No  → Step 8: 輸出 false\n    No  → Step 9: 輸出 false\nEnd\n\nWe need to ensure each line has \"虛擬碼步驟 // 解釋\". The lines include indentation? It's okay to indent for readability. Each line we output must contain a virtual code step, space, then comment. So let's produce accordingly. Use \"Start // 程式開始執行\". For each step include comment. For loops use \"Step 2: 對 s 進行逐字符遍歷\" with explanation. For decisions we include decision and Yes/No branches. Let's output.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 absentCount = 0, consecutiveLate = 0, maxConsecutiveLate = 0 // 設置缺席、連續遲到與最大遲到天數計數器  \n→ Step 2: 對 s 進行逐字符遍歷 // 逐日檢查每個出勤狀態  \n   → Decision: 如果 c == 'A'？ // 檢查當天是否缺席  \n       Yes → Step 3: absentCount += 1 // 計算缺席天數  \n       No → // 不做任何事，保持計數不變  \n   → Decision: 如果 c == 'L'？ // 檢查當天是否遲到  \n       Yes → Step 4: consecutiveLate += 1 // 連續遲到天數累加  \n       No  → Step 5: consecutiveLate = 0 // 遲到結束，重置連續遲到計數器  \n   → Step 6: maxConsecutiveLate = max(maxConsecutiveLate, consecutiveLate) // 更新最大連續遲到天數  \n→ Decision: absentCount < 2？ // 檢查缺席天數是否符合條件  \n    Yes → Decision: maxConsecutiveLate < 3？ // 檢查最大連續遲到天數是否符合條件  \n        Yes → Step 7: 輸出 true // 同時滿足兩個條件，授予獎勵  \n        No  → Step 8: 輸出 false // 連續遲到天數過多，未符合條件  \n    No  → Step 9: 輸出 false // 缺席天數過多，未符合條件  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def checkRecord(self, s: str) -> bool:\n        # 若缺席次數大於1或有三連遲到，則不符合條件\n        return s.count('A') <= 1 and 'LLL' not in s\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    # 若輸入為帶引號的字串，去除外層引號\n    if (data.startswith('\"') and data.endswith('\"')) or (data.startswith(\"'\") and data.endswith(\"'\")):\n        data = data[1:-1]\n    solution = Solution()\n    result = solution.checkRecord(data)\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "\"PPALLP\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "\"PPALLL\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode26.json",
    "problem_index_in_file": 0,
    "title": "Remove Duplicates from Sorted Array",
    "description_snippet": "Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate pseudocode steps for removing duplicates from sorted array, returning k, in-place. Must be line-by-line with explanation. Use arrows, Start, End, Decision etc. Provide in Traditional Chinese. No actual code, just pseudocode steps.\n\nLet's think about algorithm: use two pointers: i for write position, j for current scanning. Initialize i=0. For each j from 1 to n-1: if nums[j] != nums[i] then i++ and set nums[i]=nums[j]. At end, k=i+1. Return k.\n\nWe need to break into pseudocode lines. Use Start. Use Decision: if j < length? but can just iterate. Use Decision to check if nums[j] != nums[i]. Use Yes → Step. Use No → skip.\n\nWe need to show step for initialization, loop, decision, assignment, final return.\n\nLet's structure:\n\nStart\n→ Initialize n = length(nums) // get array length\n→ Initialize i = 0 // write pointer at first element\n→ For j = 1 to n-1 // scan remaining elements\n    Decision: nums[j] != nums[i] ?\n        Yes → i = i + 1 // move write pointer\n            → nums[i] = nums[j] // copy unique element\n        No → // duplicate, do nothing\n→ End For\n→ Return k = i + 1 // number of unique elements\nEnd\n\nAdd explanations after each line.\n\nUse arrow indent for steps inside for loop. Use Decision lines. Use \"End For\" as step.\n\nWe need \"Start // 程式開始執行\" etc. Let's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n = length(nums) // 取得陣列長度  \n→ Step 2: i = 0 // write pointer 指向第一個元素  \n→ Step 3: For j = 1 to n-1 // 從第二個元素開始掃描  \n&nbsp;&nbsp;&nbsp;&nbsp;Decision: nums[j] != nums[i] ? // 判斷當前元素是否為新值  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → i = i + 1 // 移動 write pointer 到下一個位置  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ nums[i] = nums[j] // 把新值寫入陣列  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → // 重複值，直接跳過  \n→ End For // 迴圈結束  \n→ Step 4: k = i + 1 // 共有 k 個唯一元素  \n→ Step 5: return k // 回傳結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def removeDuplicates(self, nums):\n        \"\"\"移除有序陣列中的重複元素，原地操作，返回唯一元素個數\"\"\"\n        if not nums:\n            return 0\n        slow = 0\n        for fast in range(1, len(nums)):\n            if nums[fast] != nums[slow]:\n                slow += 1\n                nums[slow] = nums[fast]\n        return slow + 1\n\ndef main():\n    # 讀取全部輸入並擷取數字\n    raw_input = sys.stdin.read()\n    if not raw_input.strip():\n        return\n    nums = list(map(int, re.findall(r'-?\\d+', raw_input)))\n    \n    sol = Solution()\n    k = sol.removeDuplicates(nums)\n    \n    # 將多餘的位置用下劃線表示\n    formatted = [str(nums[i]) if i < k else '_' for i in range(len(nums))]\n    result_str = f\"{k}, nums = [{', '.join(formatted)}]\"\n    print(result_str)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,1,2]",
          "expected_output": "2, nums = [1,2,_]",
          "success": true,
          "output": "2, nums = [1, 2, _]"
        },
        {
          "example_index": 1,
          "input": "nums = [0,0,1,1,1,2,2,3,3,4]",
          "expected_output": "5, nums = [0,1,2,3,4,_,_,_,_,_]",
          "success": true,
          "output": "5, nums = [0, 1, 2, 3, 4, _, _, _, _, _]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode414.json",
    "problem_index_in_file": 0,
    "title": "Third Maximum Number",
    "description_snippet": "Given an integer array nums, return the third distinct maximum number in this array. If the third ma...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code lines describing algorithm. Steps: find distinct maximums up to 3, track first, second, third. Use Decision to handle duplicates. At end return third if exists else first. We'll output as per format.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 first, second, third 為 null // 用於存放前三個最大不同數字  \n→ Step 2: 對 nums 中每個元素 num 進行迭代 // 循環遍歷陣列  \n  → Decision: 如果 num 與 first, second, third 中任何一個相等? // 排除重複值  \n    Yes → Skip // 重複項不處理，直接跳到下一個元素  \n    No  → Decision: first 為 null 或 num > first? // 新值是否大於目前最大  \n      Yes → Step 3: third ← second // 先把 second 移到 third  \n         second ← first // 把 first 移到 second  \n         first ← num // 目前值成為第一大  \n      No  → Decision: second 為 null 或 num > second? // 與目前第二大比較  \n         Yes → Step 4: third ← second // 把 second 移到 third  \n            second ← num // 目前值成為第二大  \n         No  → Decision: third 為 null 或 num > third? // 與目前第三大比較  \n            Yes → Step 5: third ← num // 目前值成為第三大  \n            No → Skip // 小於等於第三大，直接跳到下一個元素  \n→ Step 6: Decision: third 為 null? // 檢查是否存在第三大數字  \n    Yes → Step 7: return first // 沒有第三大，返回最大值  \n    No  → Step 8: return third // 有第三大，返回它  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def thirdMax(self, nums):\n        \"\"\"\n        找出陣列中第三大的不同數字。\n        若第三大不存在，則回傳最大數字。\n        \"\"\"\n        # 用負無窮作為初始值，方便比較\n        first = second = third = float('-inf')\n        # 先去除重複值，因為只需要不同的數字\n        unique_nums = set(nums)\n\n        for num in unique_nums:\n            if num > first:          # 更大的數字\n                third = second\n                second = first\n                first = num\n            elif num > second:       # 在第一大與第二大之間\n                third = second\n                second = num\n            elif num > third:        # 在第二大與第三大之間\n                third = num\n\n        # 若 distinct 數量不到 3，直接回傳第一大\n        return third if len(unique_nums) >= 3 else first\n\ndef main():\n    \"\"\"\n    讀取 stdin，格式類似：\n        nums = [3,2,1]\n    解析後呼叫 Solution.thirdMax，並將結果輸出。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 只抓取等號右側的列表字串\n    try:\n        _, list_str = data.split('=', 1)\n    except ValueError:\n        # 若沒有等號，直接假設整個輸入就是列表\n        list_str = data\n    list_str = list_str.strip()\n\n    # 使用安全的字面值解析\n    try:\n        nums = ast.literal_eval(list_str)\n    except Exception:\n        print(\"Invalid input format\")\n        return\n\n    # 若解析結果不是列表，或是空列表，直接輸出空值\n    if not isinstance(nums, list):\n        print(\"Input must be a list\")\n        return\n\n    solution = Solution()\n    result = solution.thirdMax(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [3,2,1]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "nums = [2,2,3,1]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode367.json",
    "problem_index_in_file": 0,
    "title": "Valid Perfect Square",
    "description_snippet": "Given a positive integer num, return true if num is a perfect square or false otherwise.\nA perfect s...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate pseudocode (virtual code) step by step. The algorithm: iterate from 1 to sqrt approximation, but without sqrt. Use binary search: left=1, right=num; while left <= right: mid = (left+right)//2; square = mid*mid; if square == num return true; else if square < num left=mid+1; else right=mid-1; after loop return false. Or we can use Newton's method. Binary search simpler.\n\nWe need to output each line with virtual code and explanation. Use arrow →, Start, End, Decision: etc.\n\nMake sure each line has \"虛擬碼步驟\" plus space plus // explanation.\n\nWe should include Start, End, Decision. Use appropriate indentation for decisions. Provide step names.\n\nLet's construct:\n\nStart\n→ Step 1: 設定 left = 1, right = num // 初始化搜尋範圍\n→ Decision: 是否 left <= right? // 判斷是否還有搜尋區間\n    Yes → Step 2: mid = (left + right) // 2 // 取中點\n    → Step 3: square = mid * mid // 計算中點平方\n    → Decision: square == num? // 是否等於目標\n        Yes → Step 4: 回傳 true // 找到完全平方，結束\n        No  → Decision: square < num? // 小於目標\n            Yes → Step 5: left = mid + 1 // 設定左邊界\n            No  → Step 6: right = mid - 1 // 設定右邊界\n    No → Step 7: 回傳 false // 搜尋完畢未找到\nEnd\n\nWe must include End line. Also include any necessary comments. Each line with virtual code step then space then // explanation.\n\nLet's format accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 left = 1, right = num // 初始化搜尋範圍，左端為 1，右端為目標數  \n→ Decision: 是否 left <= right? // 判斷搜尋區間是否仍有效  \n  Yes → Step 2: mid = (left + right) // 2 // 取搜尋區間中點  \n  → Step 3: square = mid * mid // 計算中點的平方  \n  → Decision: square == num? // 判斷是否正好等於目標數  \n    Yes → Step 4: 回傳 true // 找到完全平方，結束  \n    No → Decision: square < num? // 判斷平方是否小於目標數  \n      Yes → Step 5: left = mid + 1 // 若較小，將左邊界移至 mid 右側  \n      No → Step 6: right = mid - 1 // 若較大，將右邊界移至 mid 左側  \n  No → Step 7: 回傳 false // 搜尋結束仍未找到，返回 false  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def isPerfectSquare(self, num: int) -> bool:\n        if num < 2:\n            return True\n        left, right = 1, num\n        while left <= right:\n            mid = (left + right) // 2\n            square = mid * mid\n            if square == num:\n                return True\n            elif square < num:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return False\n\ndef main():\n    data = sys.stdin.read()\n    match = re.search(r'-?\\d+', data)\n    if not match:\n        return\n    num = int(match.group())\n    sol = Solution()\n    result = sol.isPerfectSquare(num)\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num = 16",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "num = 14",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode53.json",
    "problem_index_in_file": 0,
    "title": "Maximum Subarray",
    "description_snippet": "Given an integer array nums, find the subarray with the largest sum, and return its sum....",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code for Kadane's algorithm. Use Start, Decision, Steps, End. Each line has the code step and explanation after //.\n\nWe'll produce step by step:\n\nStart // start\n\n→ Step 1: Initialize maxSum = nums[0] // current max sum\n\n→ Step 2: Initialize currentSum = nums[0] // current running sum\n\n→ Decision: 循環從 i = 1 to nums.length-1? but need to express as loop.\n\nWe can express loop as:\n\n→ Loop i from 1 to nums.length-1 // 遍歷陣列\n\nInside loop:\n\n→ Decision: currentSum < 0? // 若前一累加值為負\n\n→ If Yes → currentSum = nums[i] // 重新開始子陣列\n\n→ If No → currentSum = currentSum + nums[i] // 加上當前值\n\n→ Decision: currentSum > maxSum? // 是否更新最大值\n\n→ Yes → maxSum = currentSum\n\nAfter loop ends, End: Return maxSum.\n\nWe need to use virtual code arrow lines.\n\nLet's create each line:\n\nStart\n\n→ Step 1: Initialize maxSum ← nums[0] // 設定最大子陣列和為第一個元素\n\n→ Step 2: Initialize currentSum ← nums[0] // 設定當前子陣列和為第一個元素\n\n→ Loop i = 1 to nums.length-1 // 從第二個元素開始遍歷\n\n    → Decision: 如果 currentSum < 0? // 檢查前一累加和是否為負\n\n        Yes → currentSum ← nums[i] // 若為負則以當前元素重新開始\n\n        No  → currentSum ← currentSum + nums[i] // 否則將當前元素加進去\n\n    → Decision: 如果 currentSum > maxSum? // 檢查是否需要更新最大值\n\n        Yes → maxSum ← currentSum // 更新最大值\n\nEnd // 返回 maxSum\n\nBut we also need to return value at End. Could add a Step: Return maxSum.\n\nLet's format with arrows and indentation. Use the required format: Each line \"虛擬碼步驟 [space] // 解釋\". Indent lines under Loop. Use arrow \"→\" for each step. For Decision use \"Decision:\" with Yes → etc.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Initialize maxSum ← nums[0] // 設定最大子陣列和為第一個元素  \n→ Step 2: Initialize currentSum ← nums[0] // 設定當前子陣列和為第一個元素  \n→ Loop i = 1 to nums.length-1 // 從第二個元素開始遍歷陣列  \n → Decision: 如果 currentSum < 0? // 檢查前一累加和是否為負  \n  Yes → currentSum ← nums[i] // 若為負則以當前元素重新開始  \n  No  → currentSum ← currentSum + nums[i] // 否則將當前元素加進去  \n → Decision: 如果 currentSum > maxSum? // 檢查是否需要更新最大值  \n  Yes → maxSum ← currentSum // 更新最大子陣列和  \n→ Step 3: Return maxSum // 回傳最大子陣列和  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef max_subarray_sum(nums):\n    \"\"\"使用 Kadane 演算法求最大子陣列和\"\"\"\n    max_current = max_global = nums[0]\n    for num in nums[1:]:\n        # 重新開始子陣列或繼續累加\n        max_current = max(num, max_current + num)\n        # 更新全局最大值\n        if max_current > max_global:\n            max_global = max_current\n    return max_global\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個內容\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n\n    # 解析輸入格式: 例如 \"nums = [-2,1,-3,4,-1,2,1,-5,4]\"\n    if \"=\" in raw_input:\n        _, nums_part = raw_input.split(\"=\", 1)\n        nums_part = nums_part.strip()\n    else:\n        nums_part = raw_input.strip()\n\n    # 安全地將字串轉成 Python 列表\n    try:\n        nums = ast.literal_eval(nums_part)\n    except Exception:\n        # 若解析失敗，直接終止\n        sys.exit()\n\n    # 計算最大子陣列和並輸出\n    result = max_subarray_sum(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [-2,1,-3,4,-1,2,1,-5,4]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "nums = [1]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "nums = [5,4,-1,7,8]",
          "expected_output": "23",
          "success": true,
          "output": "23"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode14.json",
    "problem_index_in_file": 0,
    "title": "Longest Common Prefix",
    "description_snippet": "Write a function to find the longest common prefix string amongst an array of strings.\n\nIf there is ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code lines, each line with comment. Use Start, End, Decision, etc. Provide steps to find longest common prefix. No actual code. Use arrow. Let's produce algorithm: Start, Step 1: if array empty return \"\", Step 2: set prefix = first string, Step 3: for each string in array, while not startswith(prefix): reduce prefix length by 1, if empty return \"\", Step 4: return prefix. Provide explanation comments. Use \"→\" arrow to next step. For loops and decisions. Let's craft. Use indentation for nested decisions. Use \"Decision:\" lines.\n\nWe need to ensure each line ends with comment. Let's produce:\n\nStart // 程式開始\n→ Step 1: 檢查陣列是否為空 // 若無元素直接回傳空字串\n    Decision: 陣列空？ // 判斷是否為空\n        Yes → Step 2: 回傳 \"\" // 空陣列回傳空字串\n        No  → Step 3: 設定 prefix 為陣列第一個字串 // 用第一個字串作為初始前綴\n→ Step 4: 對陣列中每個字串進行檢查 // 循環檢查每個字串\n    Decision: 字串是否以 prefix 開頭？ // 檢查前綴是否仍然符合\n        Yes → No action // 符合則不做處理\n        No  → Step 5: 將 prefix 截短一個字元 // 截短前綴直到符合\n            Decision: prefix 是否已經為空？ // 檢查前綴是否消失\n                Yes → Step 6: 回傳 \"\" // 沒有共通前綴\n                No  → 回到 Step 4 // 重新檢查下一個字串\n→ Step 7: 回傳 prefix // 所有字串檢查完畢後回傳最長共通前綴\nEnd // 程式執行結束\n\nMake sure each line starts with arrow \"→\". For decisions we use \"Decision:\" with indentation. For branching we use Yes → etc.\n\nWe must use 虛擬碼步驟 + space + // 解釋. Ensure each line ends with comment. Let's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 檢查陣列是否為空 // 若無元素直接回傳空字串  \n    Decision: 陣列空？ // 判斷陣列是否為空  \n        Yes → Step 2: 回傳 \"\" // 空陣列回傳空字串  \n        No  → Step 3: 設定 prefix 為陣列第一個字串 // 用第一個字串作為初始前綴  \n→ Step 4: 對陣列中每個字串進行檢查 // 循環檢查每個字串是否仍以 prefix 開頭  \n    Decision: 字串是否以 prefix 開頭？ // 判斷前綴是否仍然符合  \n        Yes → No action // 符合則不做任何處理  \n        No  → Step 5: 將 prefix 截短一個字元 // 截短前綴直到符合  \n            Decision: prefix 是否已經為空？ // 檢查前綴是否消失  \n                Yes → Step 6: 回傳 \"\" // 沒有共通前綴，直接回傳空字串  \n                No  → 回到 Step 4 // 重新檢查下一個字串  \n→ Step 7: 回傳 prefix // 所有字串檢查完畢後回傳最長共通前綴  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def longestCommonPrefix(self, strs):\n        \"\"\"\n        Find the longest common prefix string amongst an array of strings.\n        If there is no common prefix, return an empty string \"\".\n        \"\"\"\n        if not strs:                     # If the list is empty, no prefix exists\n            return \"\"\n        prefix = strs[0]                 # Use the first string as initial prefix\n        for s in strs[1:]:               # Iterate over the remaining strings\n            # Keep trimming the prefix until it matches the start of the string\n            while not s.startswith(prefix):\n                prefix = prefix[:-1]      # Remove last character\n                if not prefix:            # If prefix becomes empty, no common prefix\n                    return \"\"\n        return prefix                     # All strings share this prefix\n\ndef main():\n    # Read the entire input from stdin\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n\n    # The input format is expected to be something like:\n    #   strs = [\"flower\",\"flow\",\"flight\"]\n    # Extract the part after '=' and evaluate it safely\n    if \"=\" in raw_input:\n        _, expr = raw_input.split(\"=\", 1)\n        expr = expr.strip()\n    else:\n        expr = raw_input\n\n    # Convert the string representation of the list into an actual Python list\n    try:\n        strs = ast.literal_eval(expr)\n    except Exception:\n        # If parsing fails, treat the whole input as a single string list\n        strs = [raw_input]\n\n    # Compute the longest common prefix\n    solution = Solution()\n    result = solution.longestCommonPrefix(strs)\n\n    # Print the result to stdout\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "strs = [\"flower\",\"flow\",\"flight\"]",
          "expected_output": "\"fl\"",
          "success": true,
          "output": "fl"
        },
        {
          "example_index": 1,
          "input": "strs = [\"dog\",\"racecar\",\"car\"]",
          "expected_output": "\"\"",
          "success": true,
          "output": ""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode72.json",
    "problem_index_in_file": 0,
    "title": "Edit Distance",
    "description_snippet": "Given two strings word1 and word2, return the minimum number of operations required to convert word1...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with arrow etc. It's edit distance DP. We'll produce steps: start, read strings, init DP table of size (m+1)*(n+1), fill first row/col, nested loops, decision update min, result. Provide line by line virtual code. Use arrows. Use Decision for min among three operations. Provide explanation.\n\nLet's craft. Use \"Step:\" labels. Use arrow. Eg:\nStart\n→ Step 1: Input word1, word2\n→ Step 2: Set m = length(word1), n = length(word2)\n→ Step 3: Initialize dp matrix (m+1) x (n+1) // etc\nThen loops:\n→ For i from 0 to m:\n   → For j from 0 to n:\n      → Decision: If i==0? // etc\nBut we can compress. Provide line by line.\n\nLet's produce ~20 lines.\n\nMake sure each line includes virtual code + explanation. Use arrow for steps.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Read word1, word2 // 取得兩個待轉換的字串  \n→ Step 2: m ← length(word1) ; n ← length(word2) // 取得字串長度  \n→ Step 3: Create dp[0…m][0…n] // 初始化動態規劃表  \n→ Step 4: For i ← 0 to m: dp[i][0] ← i // 將 word1 轉成空字串需要刪除 i 個字元  \n→ Step 5: For j ← 0 to n: dp[0][j] ← j // 將空字串轉成 word2 需要插入 j 個字元  \n→ Step 6: For i ← 1 to m: // 逐行遍歷 word1  \n→     For j ← 1 to n: // 逐列遍歷 word2  \n→         Decision: word1[i-1] == word2[j-1]? // 比較當前字元  \n→             Yes → dp[i][j] ← dp[i-1][j-1] // 相同，無需操作  \n→             No  → Decision:  \n→                 InsertCost ← dp[i][j-1] + 1 // 插入字元的代價  \n→                 DeleteCost ← dp[i-1][j] + 1 // 刪除字元的代價  \n→                 ReplaceCost ← dp[i-1][j-1] + 1 // 替換字元的代價  \n→                 dp[i][j] ← min(InsertCost, DeleteCost, ReplaceCost) // 選取最小代價  \n→ Step 7: result ← dp[m][n] // 取表格右下角的最小操作數  \n→ Step 8: Output result // 回傳最小編輯距離  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        m, n = len(word1), len(word2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(m + 1):\n            dp[i][0] = i\n        for j in range(n + 1):\n            dp[0][j] = j\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if word1[i - 1] == word2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1])\n        return dp[m][n]\n\ndef parse_input(text: str):\n    # Extract all quoted substrings\n    parts = re.findall(r'\"([^\"]*)\"', text)\n    if len(parts) >= 2:\n        return parts[0], parts[1]\n    # Fallback: split by comma and strip spaces\n    parts = [p.strip() for p in text.split(',')]\n    if len(parts) >= 2:\n        return parts[0].strip('word1 ='), parts[1].strip('word2 =')\n    raise ValueError(\"Invalid input format\")\n\ndef main():\n    raw_input = sys.stdin.read()\n    if not raw_input.strip():\n        return\n    word1, word2 = parse_input(raw_input)\n    sol = Solution()\n    result = sol.minDistance(word1, word2)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "word1 = \"horse\", word2 = \"ros\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "word1 = \"intention\", word2 = \"execution\"",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode374.json",
    "problem_index_in_file": 0,
    "title": "Guess Number Higher or Lower",
    "description_snippet": "We are playing the Guess Game. The game is as follows: \n\nI pick a number from 1 to n. You have to gu...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code that solves the guess game. Use binary search. The user wants virtual code with explanation. Format: each line \"虛擬碼步驟 // 解釋\". Use arrow indicators. Should include Start, End, Decision, etc. Provide step by step algorithm.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 low ← 1, high ← n // 設定搜尋範圍  \n→ Decision: 低於 high? // 判斷範圍是否仍有效  \n Yes → Step 2: mid ← (low + high) / 2 // 計算中點作為猜測值  \n  → Step 3: result ← guess(mid) // 呼叫 API 進行猜測  \n  → Decision: result 等於 0? // 判斷是否猜中  \n   Yes → Step 4: return mid // 成功，回傳答案  \n   No → Decision: result 等於 -1? // 猜的數字太大  \n    Yes → Step 5: high ← mid - 1 // 將上限調整到 mid-1  \n    No → Step 6: low ← mid + 1 // 猜的數字太小，調整下限  \n    → 跳回 Decision: 低於 high? // 重新檢查條件  \n   → End // 若猜中則結束  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\n# Global variable that holds the number to guess.\npick = None\n\ndef guess(num: int) -> int:\n    \"\"\"\n    模擬題目中給出的 API。\n    -1 表示猜測的數字太大 (num > pick)\n     1 表示猜測的數字太小 (num < pick)\n     0 表示猜測正確 (num == pick)\n    \"\"\"\n    global pick\n    if num > pick:\n        return -1\n    elif num < pick:\n        return 1\n    else:\n        return 0\n\nclass Solution:\n    def guessNumber(self, n: int) -> int:\n        \"\"\"\n        使用二分搜尋找出 pick 的值。\n        \"\"\"\n        left, right = 1, n\n        while left <= right:\n            mid = left + (right - left) // 2\n            res = guess(mid)\n            if res == 0:          # 猜對了\n                return mid\n            elif res < 0:         # 猜的大，將上限調整\n                right = mid - 1\n            else:                 # 猜的小，將下限調整\n                left = mid + 1\n        return -1   # 理論上不會到這裡\n\ndef main():\n    # 讀取所有輸入並提取整數\n    data = sys.stdin.read()\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    if len(nums) < 2:\n        return\n    n, global_pick = nums[0], nums[1]\n\n    # 設定全域變數，使 guess() 能正確回傳\n    global pick\n    pick = global_pick\n\n    # 執行猜數字並輸出結果\n    solution = Solution()\n    result = solution.guessNumber(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 10, pick = 6",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "n = 1, pick = 1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "n = 2, pick = 1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode18.json",
    "problem_index_in_file": 0,
    "title": "4Sum",
    "description_snippet": "Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for four sum problem. Provide step by step with arrows, decisions etc. Must be in Traditional Chinese. Output each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision, Yes →, No →, Step, etc.\n\nWe need to outline algorithm: sort array, loop i, j, use two pointers left/right, skip duplicates, check sum compare to target. Return list of quadruplets.\n\nSo produce lines:\n\nStart\n→ Step 1: Sort nums ascending // 排序方便雙指針和跳過重複\n→ Step 2: Initialize result array // 存放所有四元組\n→ Decision: 如果 nums 長度 < 4? // 若不足四個元素則直接返回空\n    Yes → End // 沒有足夠元素\n    No → (continue)\n→ Step 3: For i from 0 to n-4 // 第1個指針\n    // loop body\nWithin loop:\n    Decision: If i>0 且 nums[i]==nums[i-1]? // skip duplicate first element\n        Yes → Continue // 跳過\n        No →\n    → Step 4: For j from i+1 to n-3 // 第2個指針\n        Decision: If j>i+1 且 nums[j]==nums[j-1]? // skip duplicate second element\n            Yes → Continue\n            No →\n        → Step 5: left ← j+1, right ← n-1 // 初始化左右指針\n        → Decision: While left < right?\n            Yes → Step 6: currentSum ← nums[i]+nums[j]+nums[left]+nums[right] // 計算四數之和\n                Decision: If currentSum == target?\n                    Yes → Step 7: Append [nums[i], nums[j], nums[left], nums[right]] to result\n                           → Step 8: Increment left while left<right and nums[left]==nums[left-1] // skip duplicate left\n                           → Step 9: Decrement right while left<right and nums[right]==nums[right+1] // skip duplicate right\n                    No → Decision: If currentSum < target?\n                        Yes → Step 10: left ← left + 1 // 總和太小，左指針往右移\n                        No → Step 11: right ← right - 1 // 總和太大，右指針往左移\n            No → (exit while)\n→ End // 結束所有循環並返回結果\n\nMake sure to label each line properly. Use arrows. Use Chinese. Provide virtual code step names maybe generic. We'll ensure each line ends with // 解釋. Let's craft lines.\n\nWe need to include \"Start\" \"End\". Provide decisions. Use indentation maybe with tab but not necessary. Let's output each line separate. Provide virtual code step names such as \"Step 1: Sort nums ascending\". Let's produce.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort nums ascending // 先將陣列排序，方便後續使用雙指針和跳過重複  \n→ Step 2: Initialize result array // 建立空的結果陣列以儲存所有符合條件的四元組  \n→ Decision: 如果 nums 長度 < 4? // 若元素不足四個，無法組成四元組  \n Yes → End // 直接結束，返回空結果  \n No  → (繼續執行)  \n→ Step 3: For i from 0 to n-4 // 迭代第一個索引 i  \n  Decision: 如果 i > 0 且 nums[i] == nums[i-1]? // 跳過重複的第一個元素  \n   Yes → Continue // 直接進下一次迴圈  \n   No  → (繼續執行)  \n  → Step 4: For j from i+1 to n-3 // 迭代第二個索引 j  \n   Decision: 如果 j > i+1 且 nums[j] == nums[j-1]? // 跳過重複的第二個元素  \n    Yes → Continue // 直接進下一次迴圈  \n    No  → (繼續執行)  \n   → Step 5: left ← j+1, right ← n-1 // 初始化左右指針  \n   → Decision: While left < right? // 只要左右指針未交叉  \n    Yes → Step 6: currentSum ← nums[i] + nums[j] + nums[left] + nums[right] // 計算四數之和  \n     Decision: 如果 currentSum == target? // 是否符合目標和  \n      Yes → Step 7: Append [nums[i], nums[j], nums[left], nums[right]] to result // 將符合的四元組加入結果  \n       → Step 8: Increment left while left < right and nums[left] == nums[left-1] // 跳過重複的左側元素  \n       → Step 9: Decrement right while left < right and nums[right] == nums[right+1] // 跳過重複的右側元素  \n     No → Decision: 如果 currentSum < target? // 和太小，需往右移左指針  \n      Yes → Step 10: left ← left + 1 // 左指針往右移  \n      No → Step 11: right ← right - 1 // 右指針往左移  \n        // 之後繼續 while 迴圈  \n          // 循環結束時回到 Decision: While left < right?  \n          // 進入下一輪或結束內層循環  \n          // 返回上一層循環  \n          // 直到所有 i、j 組合完成  \nEnd // 程式執行結束，返回包含所有唯一四元組的結果陣列",
      "generated_code": "import sys\nimport ast\nimport re\n\nclass Solution:\n    def fourSum(self, nums, target):\n        nums.sort()\n        n = len(nums)\n        res = []\n\n        for i in range(n - 3):\n            if i > 0 and nums[i] == nums[i - 1]:\n                continue\n            for j in range(i + 1, n - 2):\n                if j > i + 1 and nums[j] == nums[j - 1]:\n                    continue\n                left, right = j + 1, n - 1\n                while left < right:\n                    total = nums[i] + nums[j] + nums[left] + nums[right]\n                    if total == target:\n                        res.append([nums[i], nums[j], nums[left], nums[right]])\n                        while left < right and nums[left] == nums[left + 1]:\n                            left += 1\n                        while left < right and nums[right] == nums[right - 1]:\n                            right -= 1\n                        left += 1\n                        right -= 1\n                    elif total < target:\n                        left += 1\n                    else:\n                        right -= 1\n        return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    nums_match = re.search(r'nums\\s*=\\s*(\\[[^\\]]*\\])', data)\n    target_match = re.search(r'target\\s*=\\s*(-?\\d+)', data)\n    if not nums_match or not target_match:\n        return\n    nums = ast.literal_eval(nums_match.group(1))\n    target = int(target_match.group(1))\n    solution = Solution()\n    result = solution.fourSum(nums, target)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,0,-1,0,-2,2], target = 0",
          "expected_output": "[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]",
          "success": true,
          "output": "[[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]]"
        },
        {
          "example_index": 1,
          "input": "nums = [2,2,2,2,2], target = 8",
          "expected_output": "[[2,2,2,2]]",
          "success": true,
          "output": "[[2, 2, 2, 2]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode509.json",
    "problem_index_in_file": 0,
    "title": "Fibonacci Number",
    "description_snippet": "The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such th...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code lines step-by-step for computing Fibonacci. Use arrows and decisions. Not actual code. We need to provide explanation after each line.\n\nWe need to include Start, Step 1 etc.\n\nLet's design algorithm: Input n, if n==0 return 0, if n==1 return 1, else iterate with loop from 2 to n compute fib.\n\nWe can use iterative approach. Steps:\n\nStart\n→ Step 1: 讀取 n\n→ Decision: n == 0 ?\n   Yes → Step 2: 輸出 0\n   No  → Decision: n == 1 ?\n        Yes → Step 3: 輸出 1\n        No  → Step 4: 初始化 prev = 0, curr = 1\n             → Step 5: 設置 index = 2\n             → Decision: index <= n ?\n                Yes → Step 6: temp = prev + curr\n                      → Step 7: prev = curr\n                      → Step 8: curr = temp\n                      → Step 9: index = index + 1\n                      → Back to Decision: index <= n ?\n                No  → Step 10: 輸出 curr\nEnd\n\nNeed to mark loops with arrows maybe \"Loop:\" but just use decision.\n\nAlso we need to use arrow \"→\" for each step. Also include \"Yes →\" and \"No →\" in decisions.\n\nMake sure each line ends with // explanation.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取 n // 從使用者處取得要計算的 Fibonacci 索引  \n→ Decision: n == 0? // 檢查是否為最小特殊情況  \n Yes → Step 2: 輸出 0 // F(0) 為 0，直接輸出  \n No  → Decision: n == 1? // 若不是 0，則檢查是否為 F(1)  \n  Yes → Step 3: 輸出 1 // F(1) 為 1，直接輸出  \n  No  → Step 4: 初始化 prev = 0, curr = 1 // 設定兩個前一個 Fibonacci 數字  \n   → Step 5: 設置 index = 2 // 從第三個位置開始迭代  \n   → Decision: index <= n? // 判斷是否還需計算  \n    Yes → Step 6: temp = prev + curr // 計算下一個 Fibonacci 數字  \n      → Step 7: prev = curr // 更新 prev 為上一個數字  \n      → Step 8: curr = temp // 更新 curr 為新計算出的數字  \n      → Step 9: index = index + 1 // 進一步前進索引  \n      → 回到 Decision: index <= n? // 重複迴圈直到 index 超過 n  \n    No → Step 10: 輸出 curr // 當 index > n 時，curr 即為 F(n)  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef fib(n: int) -> int:\n    \"\"\"計算第 n 個 Fibonacci 數列值（F(0)=0, F(1)=1）。\"\"\"\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    return b\n\ndef main() -> None:\n    \"\"\"從標準輸入讀取 n，計算並輸出 F(n)。\"\"\"\n    data = sys.stdin.read()\n    # 使用正則表達式抓取第一個整數，能處理「n = 2」或「2」等輸入格式\n    match = re.search(r'\\d+', data)\n    if not match:\n        return\n    n = int(match.group())\n    print(fib(n))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 2",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "n = 3",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "n = 4",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode15.json",
    "problem_index_in_file": 0,
    "title": "3Sum",
    "description_snippet": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code algorithm for the classic 3Sum problem: find all unique triplets summing to zero, given integer array. Provide step-by-step virtual code lines with comments. Use the arrow format. Ensure each line includes code step and comment. Use \"Start\", \"End\". Use Decision: etc.\n\nWe should cover sorting, iterating, two-pointer, duplicate skip.\n\nLet's produce a flow.\n\nSteps:\nStart\n→ Step 1: Sort nums ascending // 排序方便移除重複\n→ Step 2: Initialize result list // 儲存所有符合條件的三元組\n→ Decision: If length(nums) < 3? // 不足3個數\n    Yes → Step 3: Return result // 直接返回空列表\n    No  → Step 4: For i from 0 to len(nums)-3 // 外層迴圈選第一個數\n        → Decision: If i > 0 and nums[i] == nums[i-1]? // 跳過重複的第一個數\n            Yes → Step 5: Continue to next i // 跳過\n            No  → Step 6: Set left = i+1, right = len(nums)-1 // 初始化左右指標\n                → Decision: While left < right? // 兩指標搜索\n                    Yes → Step 7: sum = nums[i] + nums[left] + nums[right] // 計算和\n                        → Decision: If sum == 0? // 找到三元組\n                            Yes → Step 8: Append [nums[i], nums[left], nums[right]] to result // 加入結果\n                                → Step 9: While left < right and nums[left] == nums[left+1]? // 跳過相同的左數\n                                    Yes → left += 1\n                                    No  → No action\n                                → Step 10: While left < right and nums[right] == nums[right-1]? // 跳過相同的右數\n                                    Yes → right -= 1\n                                    No  → No action\n                                → Step 11: left += 1; right -= 1 // 移動兩指標\n                            No  → Decision: If sum < 0? // 和小於0\n                                Yes → left += 1 // 左指標右移\n                                No  → right -= 1 // 和大於0，右指標左移\n                → No → End of while loop\n        → No → End of for loop\n→ Step 12: Return result // 回傳所有三元組\nEnd // 程式結束\n\nWe need to keep formatting: each line has virtual code step plus comment. Use arrow \"→\" for step lines. Use \"Decision:\" lines with indentation. Use Yes → and No → for branches.\n\nMake sure each line includes code step, space, // comment.\n\nWe'll produce as specified.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort nums ascending // 對輸入陣列進行排序，方便後續兩指標搜尋與去重  \n→ Step 2: Initialize result list // 建立空清單，用於儲存所有符合條件的三元組  \n→ Decision: 如果 nums 長度小於 3? // 檢查是否足夠進行三元組組合  \n    Yes → Step 3: Return result // 若不足三個元素，直接回傳空清單  \n    No  → Step 4: For i from 0 to len(nums)-3 // 外層迴圈選擇第一個元素  \n        → Decision: 如果 i > 0 且 nums[i] == nums[i-1]? // 跳過重複的第一個元素  \n            Yes → Step 5: Continue to next i // 忽略重複值，避免重複三元組  \n            No  → Step 6: Set left = i+1, right = len(nums)-1 // 初始化左右指標  \n                → Decision: While left < right? // 兩指標搜尋剩餘兩個數  \n                    Yes → Step 7: sum = nums[i] + nums[left] + nums[right] // 計算三數之和  \n                        → Decision: 如果 sum == 0? // 找到合法三元組  \n                            Yes → Step 8: Append [nums[i], nums[left], nums[right]] to result // 加入結果清單  \n                                → Step 9: While left < right and nums[left] == nums[left+1]? // 跳過左邊重複值  \n                                    Yes → left += 1  \n                                    No  → No action  \n                                → Step 10: While left < right and nums[right] == nums[right-1]? // 跳過右邊重複值  \n                                    Yes → right -= 1  \n                                    No  → No action  \n                                → Step 11: left += 1; right -= 1 // 移動兩指標，繼續搜尋  \n                            No  → Decision: 如果 sum < 0? // 和小於 0，需增大總和  \n                                Yes → left += 1 // 左指標右移  \n                                No  → right -= 1 // 和大於 0，右指標左移  \n                → No → // 結束 While 迴圈  \n        → No → // 結束 For 迴圈  \n→ Step 12: Return result // 回傳所有獨特的三元組  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def threeSum(self, nums):\n        nums.sort()\n        res = []\n        n = len(nums)\n        for i in range(n):\n            if i > 0 and nums[i] == nums[i - 1]:\n                continue\n            left, right = i + 1, n - 1\n            while left < right:\n                total = nums[i] + nums[left] + nums[right]\n                if total == 0:\n                    res.append([nums[i], nums[left], nums[right]])\n                    while left < right and nums[left] == nums[left + 1]:\n                        left += 1\n                    while left < right and nums[right] == nums[right - 1]:\n                        right -= 1\n                    left += 1\n                    right -= 1\n                elif total < 0:\n                    left += 1\n                else:\n                    right -= 1\n        return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if data.startswith(\"nums\"):\n        # Remove any leading 'nums ='\n        data = data.split(\"=\", 1)[1].strip()\n    # Parse the list safely\n    try:\n        nums = ast.literal_eval(data)\n    except Exception:\n        # If parsing fails, treat as empty list\n        nums = []\n    solution = Solution()\n    result = solution.threeSum(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [-1,0,1,2,-1,-4]",
          "expected_output": "[[-1,-1,2],[-1,0,1]]",
          "success": true,
          "output": "[[-1, -1, 2], [-1, 0, 1]]"
        },
        {
          "example_index": 1,
          "input": "nums = [0,1,1]",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        },
        {
          "example_index": 2,
          "input": "nums = [0,0,0]",
          "expected_output": "[[0,0,0]]",
          "success": true,
          "output": "[[0, 0, 0]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode474.json",
    "problem_index_in_file": 0,
    "title": "Ones and Zeroes",
    "description_snippet": "You are given an array of binary strings strs and two integers m and n.\n\nReturn the size of the larg...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code for the problem: given array of binary strings, choose largest subset with at most m zeros and n ones. Classic DP 0/1 knapsack with two constraints. So we produce virtual code with DP 3D? Usually 2D DP dp[i][j] max size. We iterate over strings, count zeros and ones. Then for i from m down to zeros, j from n down to ones, dp[i][j] = max(dp[i][j], dp[i-zeros][j-ones]+1). Finally return dp[m][n]. Provide step-by-step.\n\nWe must output line-by-line with \"虛擬碼步驟\" and comment. Use arrows. So:\n\nStart // begin\n→ Step 1: Initialize dp array of size (m+1) x (n+1) with zeros // DP table\n→ Step 2: For each string s in strs: // iterate\n   → Step 2.1: count zeros z and ones o in s // count\n   → Decision: if z > m or o > n? // skip if exceeds capacity\n       No → for i from m down to z: // outer loop\n           → for j from n down to o: // inner loop\n               → Step 2.2: dp[i][j] = max(dp[i][j], dp[i-z][j-o] + 1) // update\n→ Step 3: Return dp[m][n] // result\n\nMake sure to use arrow formatting. Provide each line with comment.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 dp 陣列 (m+1) × (n+1) 全部初始化為 0 // 用來記錄到目前為止可取的最大子集大小  \n→ Step 2: 逐一處理 strs 中的每個字串 s // 主迴圈  \n   → Step 2.1: 計算 s 中 0 的數量 z 與 1 的數量 o // 取得資源需求  \n   → Decision: 若 z > m 或 o > n? // 若單個字串已超過限制直接忽略  \n       No  → for i ← m downto z: // 依照剩餘 0 數量倒序遍歷  \n           → for j ← n downto o: // 依照剩餘 1 數量倒序遍歷  \n               → Step 2.2: dp[i][j] = max(dp[i][j], dp[i-z][j-o] + 1) // 更新 DP：取或不取該字串  \n→ Step 3: Return dp[m][n] // 回傳能在 m 個 0 與 n 個 1 限制下取得的最大子集大小  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def findMaxForm(self, strs, m, n):\n        \"\"\"使用二維 DP，dp[i][j] 表示在使用 i 個 0 和 j 個 1 的限制下\n        可取得的最大字串數量。\"\"\"\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for s in strs:\n            zeros = s.count('0')\n            ones = s.count('1')\n            # 逆序遍歷以避免同一個字串被重複使用\n            for i in range(m, zeros - 1, -1):\n                for j in range(n, ones - 1, -1):\n                    dp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1)\n        return dp[m][n]\n\ndef parse_input(text: str):\n    \"\"\"解析形如\n    strs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m = 5, n = 3\n    的輸入，回傳 (list, m, n)\"\"\"\n    pattern = r'strs\\s*=\\s*(\\[[^\\]]*\\])\\s*,\\s*m\\s*=\\s*(\\d+)\\s*,\\s*n\\s*=\\s*(\\d+)'\n    match = re.search(pattern, text)\n    if not match:\n        raise ValueError(\"Input format is incorrect\")\n    strs = ast.literal_eval(match.group(1))\n    m = int(match.group(2))\n    n = int(match.group(3))\n    return strs, m, n\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n    strs, m, n = parse_input(raw_input)\n    sol = Solution()\n    result = sol.findMaxForm(strs, m, n)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "strs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m = 5, n = 3",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "strs = [\"10\",\"0\",\"1\"], m = 1, n = 1",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode227.json",
    "problem_index_in_file": 0,
    "title": "Basic Calculator II",
    "description_snippet": "Given a string s which represents an expression, evaluate this expression and return its value.\n\nThe...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line for evaluating expression with +,-,*,/ and parentheses? Not specified but typical problem includes +,-,*,/ and parentheses. Need to parse string s evaluate. Use stack for operands and operators. We must handle integer division trunc towards zero. Provide virtual code with arrows and decisions.\n\nWe need to produce virtual code steps with each line: `虛擬碼步驟 // 解釋/說明`. Use Start, End, Decision: etc. Provide line-by-line.\n\nWe'll outline algorithm: use two stacks: operands, operators. Scan through string.\n\nPseudo steps:\n\nStart\n→ Initialize stackOperands, stackOperators\n→ Iterate i from 0 to s.length-1\n    → Get char c = s.charAt(i)\n    → Decision: if c is whitespace? -> skip\n    → Decision: if digit? -> parse full number\n         → Step: accumulate num, push to stackOperands\n    → Decision: if c is '('? -> push to stackOperators\n    → Decision: if c is ')'? -> while top operator != '(' -> apply\n    → Decision: if operator? -> while stackOperators not empty and precedence(top) >= precedence(c) -> apply\n    → Push c to stackOperators\n→ After loop, while stackOperators not empty -> apply\n→ Result = top of stackOperands\n→ End\n\nDefine apply function: pop op, pop two operands, compute result with division truncation.\n\nAlso precedence mapping: * and / =2, + and - =1.\n\nWe need to produce each step as virtual code lines.\n\nWe must use arrows like → and decisions.\n\nWe need to include each line explanation.\n\nWe will use indentation for nested decisions.\n\nOk produce lines.\n\nLet's draft.\n\nStart // 程式開始執行\n→ 初始化 stackOperands 為空堆疊 // 儲存數字\n→ 初始化 stackOperators 為空堆疊 // 儲存運算子\n→ 循環 i 從 0 到 s.length-1 // 逐字符掃描\n    → 取字符 c = s.charAt(i) // 取得當前字符\n    → Decision: 如果 c 為空格? // 跳過空白\n        Yes → i ← i+1 // 進入下一個字符\n        No  → Decision: 如果 c 為數字? // 開始解析整數\n            Yes → \n                → num ← 0 // 初始化整數\n                → While i < s.length 且 s.charAt(i) 為數字\n                    → num ← num*10 + (s.charAt(i)-'0') // 累積\n                    → i ← i+1\n                → Push num 到 stackOperands // 數字入堆疊\n                → i ← i-1 // 因為外層已自增，補正\n            No  → Decision: 如果 c 為 '('? // 進入括號\n                Yes → Push '(' 到 stackOperators // 存儲\n                No  → Decision: 如果 c 為 ')'? // 出括號\n                    Yes → While stackOperators.top() ≠ '('\n                        → Call Apply() // 計算\n                    → Pop '(' from stackOperators // 去除左括號\n                    No  → Decision: 如果 c 為運算子 (+,-,*,/)?\n                        Yes → While stackOperators 不空 且 precedence(stackOperators.top()) ≥ precedence(c)\n                            → Call Apply() // 計算高或等優先級\n                        → Push c 到 stackOperators // 儲存當前運算子\n                        No  → // 其他字符不處理\n→ 循環結束\n→ Decision: 如果 stackOperators 不空?\n    Yes → While stackOperators 不空\n        → Call Apply() // 完成剩餘計算\n    No  → // 無需計算\n→ result ← stackOperands.top() // 最終結果\n→ End // 程式結束\n\nDefine Apply():\n→ 函數 Apply()\n    → op ← Pop stackOperators // 取運算子\n    → right ← Pop stackOperands // 右操作數\n    → left ← Pop stackOperands // 左操作數\n    → Decision: op 為 '+'\n        Yes → res ← left + right\n        No  → Decision: op 為 '-'\n            Yes → res ← left - right\n            No  → Decision: op 為 '*'\n                Yes → res ← left * right\n                No  → // op 為 '/'\n                    → res ← 左除右，向零截斷\n    → Push res 到 stackOperands // 計算結果入堆疊\n\nNeed to include integer division trunc toward zero. Provide explanation.\n\nWe must format each line with arrow then comment.\n\nLet's write final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ 初始化 stackOperands 為空堆疊 // 儲存數字\n→ 初始化 stackOperators 為空堆疊 // 儲存運算子\n→ 循環 i 從 0 到 s.length-1 // 逐字符掃描\n    → 取字符 c = s.charAt(i) // 取得當前字符\n    → Decision: 如果 c 為空格? // 跳過空白\n        Yes → i ← i+1 // 進入下一個字符\n        No  → Decision: 如果 c 為數字? // 開始解析整數\n            Yes →\n                → num ← 0 // 初始化整數\n                → While i < s.length 且 s.charAt(i) 為數字\n                    → num ← num*10 + (s.charAt(i)-'0') // 累積\n                    → i ← i+1\n                → Push num 到 stackOperands // 數字入堆疊\n                → i ← i-1 // 補正外層自增\n            No  → Decision: 如果 c 為 '('? // 進入括號\n                Yes → Push '(' 到 stackOperators // 存儲\n                No  → Decision: 如果 c 為 ')'? // 出括號\n                    Yes → While stackOperators.top() ≠ '('\n                        → Call Apply() // 計算\n                    → Pop '(' from stackOperators // 去除左括號\n                    No  → Decision: 如果 c 為運算子 (+,-,*,/)?\n                        Yes → While stackOperators 不空 且 precedence(stackOperators.top()) ≥ precedence(c)\n                            → Call Apply() // 計算高或等優先級\n                        → Push c 到 stackOperators // 儲存當前運算子\n                        No  → // 其他字符不處理\n→ 循環結束\n→ Decision: 如果 stackOperators 不空?\n    Yes → While stackOperators 不空\n        → Call Apply() // 完成剩餘計算\n    No  → // 無需計算\n→ result ← stackOperands.top() // 最終結果\n→ End // 程式結束\n\n函數 Apply() // 計算單一運算\n    → op ← Pop stackOperators // 取運算子\n    → right ← Pop stackOperands // 右操作數\n    → left ← Pop stackOperands // 左操作數\n    → Decision: op 為 '+'\n        Yes → res ← left + right\n        No  → Decision: op 為 '-'\n            Yes → res ← left - right\n            No  → Decision: op 為 '*'\n                Yes → res ← left * right\n                No  → // op 為 '/'\n                    → res ← int(left / right) // 向零截斷\n    → Push res 到 stackOperands // 將結果入堆疊\n```",
      "generated_code": "import sys\n\nclass Solution:\n    def calculate(self, s: str) -> int:\n        stack = []\n        num = 0\n        sign = '+'\n        s += '+'  # 方便最後處理最後一個數字\n\n        for c in s:\n            if c.isdigit():\n                num = num * 10 + int(c)\n            elif c in '+-*/':\n                if sign == '+':\n                    stack.append(num)\n                elif sign == '-':\n                    stack.append(-num)\n                elif sign == '*':\n                    stack.append(stack.pop() * num)\n                elif sign == '/':\n                    top = stack.pop()\n                    # 向零截斷\n                    if top < 0:\n                        stack.append(-(-top // num))\n                    else:\n                        stack.append(top // num)\n                sign = c\n                num = 0\n            # 其它字符（空格、括號等）直接忽略\n\n        return sum(stack)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 若輸入形如 's = \"3+2*2\"'，先取等號右邊\n    if '=' in data:\n        expr = data.split('=', 1)[1].strip()\n    else:\n        expr = data\n\n    # 移除可能的引號\n    if expr.startswith('\"') and expr.endswith('\"'):\n        expr = expr[1:-1]\n\n    expr = expr.strip()\n    solution = Solution()\n    result = solution.calculate(expr)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"3+2*2\"",
          "expected_output": "7",
          "success": true,
          "output": "7"
        },
        {
          "example_index": 1,
          "input": "s = \" 3/2 \"",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "s = \" 3+5 / 2 \"",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode152.json",
    "problem_index_in_file": 0,
    "title": "Maximum Product Subarray",
    "description_snippet": "Given an integer array nums, find a subarray that has the largest product, and return the product.\n\n...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code lines with comments, using arrow notation. The algorithm: maximum product subarray. We'll use dynamic programming: track max_ending_here, min_ending_here. For each element, compute new max/min considering element, max*element, min*element. Keep global max. Edge cases: negative numbers. We'll write steps accordingly.\n\nNeed to output in line-by-line format with arrows and comments. Ensure we use Start, End, Decision etc. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 nums 為輸入整數陣列 // 取得要分析的數列  \n→ Step 2: 初始化 maxProd, minProd, result 為 nums[0] // 以第一個數為初始值  \n→ Decision: nums 是否為空? // 檢查陣列是否為空  \n    Yes → Step 3: 返回 0 // 空陣列直接返回 0  \n    No → Step 4: 開始遍歷陣列從第二個元素開始 // 若陣列非空，從第二個元素處繼續  \n→ Step 5: 對於每個元素 num in nums[1:]: // 循環遍歷  \n    → Decision: num 為負數? // 需要交換 maxProd 和 minProd  \n        Yes → Step 6: 交換 maxProd 與 minProd // 负数导致最大最小互换  \n        No  →  // 不做任何事  \n    → Step 7: maxProd = max(num, maxProd * num) // 计算新的最大值  \n    → Step 8: minProd = min(num, minProd * num) // 计算新的最小值  \n    → Step 9: result = max(result, maxProd) // 更新全局最大乘积  \n→ Step 10: 返回 result // 处理完所有元素后输出最大乘积  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def maxProduct(self, nums):\n        if not nums:\n            return 0\n\n        max_prod = min_prod = result = nums[0]\n\n        for num in nums[1:]:\n            if num < 0:\n                max_prod, min_prod = min_prod, max_prod\n\n            max_prod = max(num, max_prod * num)\n            min_prod = min(num, min_prod * num)\n\n            result = max(result, max_prod)\n\n        return result\n\ndef parse_input(data: str):\n    \"\"\"\n    將輸入字串 'nums = [2,3,-2,4]' 轉換成 Python list。\n    \"\"\"\n    # 移除可能的前後空白\n    data = data.strip()\n    # 用正則表達式找出中括號內的內容\n    match = re.search(r'\\[(.*?)\\]', data)\n    if not match:\n        return []\n    # 取得中括號內的字串並使用 eval 轉成 list\n    # 這裡假設輸入合法且只含數字和逗號\n    inner = match.group(1)\n    # 如果內部為空，回傳空 list\n    if not inner.strip():\n        return []\n    return [int(x.strip()) for x in inner.split(',')]\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read()\n    nums = parse_input(input_data)\n    sol = Solution()\n    result = sol.maxProduct(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,3,-2,4]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "nums = [-2,0,-1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode494.json",
    "problem_index_in_file": 0,
    "title": "Target Sum",
    "description_snippet": "You are given an integer array nums and an integer target.\n\nYou want to build an expression out of n...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for counting number of expressions that evaluate to target, given array nums. Classic \"target sum\" problem. We can do DFS recursion or DP. Virtual code: start, recursive function, etc. Provide step-by-step explanation. Use decision nodes.\n\nMake sure to output each line with \"→\" or \"Decision:\" etc. The output format requires each line: \"虛擬碼步驟\" + space + \"// 解釋/說明\". So for each step, we write e.g., \"Start // 程式開始執行\". Then use arrows for steps. For decision: \"Decision: ...\" and then indent for Yes → and No → branches.\n\nWe need to include all steps: read input, define recursive function, base case, recursion, count result, output.\n\nUse indentation for nested. Use \"→\" lines. Also decision nodes with \"Decision:\".\n\nLet's produce. Ensure each line separate. Use proper Chinese explanation. Use 虛擬碼. Example: \"→ Function: Count(index, currentSum) // 定義遞迴函式\" etc.\n\nBe careful to include all lines, no extra code. Let's produce.\n\nAlso might mention use memoization? But we can keep simple. Provide recursion.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Read array nums 和目標值 target // 從輸入取得數字列與目標值  \n→ Step 2: 定義遞迴函式 Count(index, currentSum) // 用來探索所有符號組合  \n→ Decision: 是否已經處理完所有數字? // 判斷遞迴結束條件  \n  Yes → Step 3: If currentSum equals target? // 檢查目前總和是否達到目標  \n    Yes → Step 4: Return 1 // 找到一個符合條件的表達式，回傳 1  \n    No  → Step 5: Return 0 // 未達到目標，回傳 0  \n  No  → Step 6: currentNum ← nums[index] // 取得目前處理的數字  \n    → Step 7: resultPlus ← Count(index + 1, currentSum + currentNum) // 加上正號遞迴  \n    → Step 8: resultMinus ← Count(index + 1, currentSum - currentNum) // 加上負號遞迴  \n    → Step 9: Return resultPlus + resultMinus // 合併兩個分支的結果  \n→ Step 10: totalCount ← Count(0, 0) // 從第一個數字開始，初始總和為 0  \n→ Step 11: Output totalCount // 顯示符合目標的不同表達式數量  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import defaultdict\n\ndef find_target_sum_ways(nums, target):\n    dp = defaultdict(int)\n    dp[0] = 1\n    for num in nums:\n        next_dp = defaultdict(int)\n        for s, cnt in dp.items():\n            next_dp[s + num] += cnt\n            next_dp[s - num] += cnt\n        dp = next_dp\n    return dp[target]\n\ndef parse_input(data: str):\n    \"\"\"解析形如 'nums = [1,1,1,1,1], target = 3' 的輸入字串。\"\"\"\n    pattern = re.compile(r'nums\\s*=\\s*(\\[[^\\]]*\\])\\s*,\\s*target\\s*=\\s*(-?\\d+)', re.S)\n    match = pattern.search(data)\n    if match:\n        nums_str, target_str = match.groups()\n        nums = ast.literal_eval(nums_str)\n        target = int(target_str)\n        return nums, target\n    # 若輸入格式不符合預期，嘗試使用 exec 解析\n    local = {}\n    try:\n        exec(data, {}, local)\n        return local.get('nums', []), local.get('target', 0)\n    except Exception:\n        return [], 0\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    nums, target = parse_input(raw_input)\n    result = find_target_sum_ways(nums, target)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,1,1,1,1], target = 3",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "nums = [1], target = 1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode447.json",
    "problem_index_in_file": 0,
    "title": "Number of Boomerangs",
    "description_snippet": "You are given n points in the plane that are all distinct, where points[i] = [x_i, y_i]. A boomerang...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce pseudocode steps for counting boomerangs. Outline algorithm: For each point i, compute distances to all other points j. Count frequency of each distance. For each distance group count m points, number of boomerangs with i as pivot = m*(m-1). Sum over all i. Return total.\n\nNeed to produce line by line virtual code with explanation. Use arrows, decisions. Provide no actual code. Provide steps with explanation. Let's craft lines:\n\nStart\n→ Step 1: Initialize total_boomerangs to 0 // accumulator\n→ For each point index i from 0 to n-1 // iterate pivot\n    → Step 2: Create empty map distanceCount // counts per distance\n    → For each point index j from 0 to n-1, j != i // compute distances\n        → Step 3: Compute squared distance d = (x_i - x_j)^2 + (y_i - y_j)^2 // avoid sqrt\n        → Step 4: Increment distanceCount[d] by 1 // group by distance\n    → Step 5: For each distance value m in distanceCount values // group size\n        → Step 6: Add m * (m - 1) to total_boomerangs // permutations of two distinct points\n→ End // return total_boomerangs\n\nAlso may include decision: check if m>1? Because m*(m-1) zero if <=1. But not necessary.\n\nLet's produce in required format with arrows and explanation. Use \"→\" for each line. Include indent with spaces? The example uses spaces before Yes/No. We'll use consistent indentation. Provide decision maybe.\n\nBut the instruction: Use virtual code's arrows (→, Yes →, No →) and structure (Start, End, Decision:). We can include Decision for m>1 maybe.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: total_boomerangs ← 0 // 初始化累加器\n→ For i = 0 to n-1 // i 為「中心」點\n    → Step 2: distanceCount ← empty map // 以距離為鍵、計數為值\n    → For j = 0 to n-1, j ≠ i // 其他點\n        → Step 3: d ← (x[i] - x[j])^2 + (y[i] - y[j])^2 // 計算平方距離\n        → Step 4: distanceCount[d] ← distanceCount.get(d, 0) + 1 // 更新計數\n    → Decision: 有無距離出現多於一次? // 判斷是否能形成 boomerang\n        Yes → For each m in distanceCount.values()\n            → Step 5: total_boomerangs ← total_boomerangs + m * (m - 1) // 加入本中心點的組合數\n        No  → // 沒有重複距離，無法形成 boomerang，直接跳過\nEnd // 程式結束，返回 total_boomerangs\n\nBut we must maintain structure: Decision: ... Yes → ... No → ... However, we also need End. Provide final return.\n\nWe need to include returning value after loop. So we can add after loop:\n\n→ Step 6: return total_boomerangs // 結果\n\nAdd to End. Might combine.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: total_boomerangs ← 0 // 初始化累加器  \n→ For i = 0 to n-1 // i 為「中心」點  \n → Step 2: distanceCount ← empty map // 以距離為鍵、計數為值  \n → For j = 0 to n-1, j ≠ i // 其他點  \n  → Step 3: d ← (x[i] - x[j])^2 + (y[i] - y[j])^2 // 計算平方距離  \n  → Step 4: distanceCount[d] ← distanceCount.get(d, 0) + 1 // 更新計數  \n → Decision: 有無距離出現多於一次? // 判斷是否能形成 boomerang  \n  Yes → For each m in distanceCount.values()  \n   → Step 5: total_boomerangs ← total_boomerangs + m * (m - 1) // 加入本中心點的組合數  \n  No  → // 沒有重複距離，無法形成 boomerang，直接跳過  \n→ Step 6: return total_boomerangs // 結果  \nEnd // 程式結束，返回計算結果",
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\ndef number_of_boomerangs(points):\n    \"\"\"Return the number of boomerangs in the list of points.\"\"\"\n    total = 0\n    for x1, y1 in points:\n        dist_count = defaultdict(int)\n        for x2, y2 in points:\n            if (x1, y1) != (x2, y2):\n                d = (x1 - x2) ** 2 + (y1 - y2) ** 2\n                dist_count[d] += 1\n        for cnt in dist_count.values():\n            total += cnt * (cnt - 1)\n    return total\n\ndef parse_input(input_str):\n    \"\"\"Extract a list of points from the raw input string.\"\"\"\n    # Find the first '[' and take the substring from there to the last ']'\n    start = input_str.find('[')\n    end = input_str.rfind(']')\n    if start == -1 or end == -1:\n        return []\n    try:\n        return ast.literal_eval(input_str[start:end+1])\n    except Exception:\n        return []\n\nif __name__ == \"__main__\":\n    raw = sys.stdin.read().strip()\n    points = parse_input(raw)\n    result = number_of_boomerangs(points)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "points = [[0,0],[1,0],[2,0]]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "points = [[1,1],[2,2],[3,3]]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "points = [[1,1]]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode384.json",
    "problem_index_in_file": 0,
    "title": "Shuffle an Array",
    "description_snippet": "Given an integer array nums, design an algorithm to randomly shuffle the array. All permutations of ...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code in steps. We need to include Start, End, Decision lines. Provide lines for initializing, reset, shuffle with Fisher-Yates. Use arrays. Provide simple structure. Use arrow symbol '→'. Each line with // explanation. Provide multiple lines. Ensure each line has a virtual code step then space then comment.\n\nLet's craft:\n\nStart // begin\n\n→ Step 1: store original array in field 'original' // keep copy\n→ Step 2: copy original into 'current' // working array\n\nImplement methods:\n\n→ Step 3: Method reset() // reset to original\n    → Return clone of original // return copy\n\n→ Step 4: Method shuffle() // random shuffle\n    → Initialize result = clone of original // start with copy\n    → For i from 0 to len-1:\n        → Generate random index j between i and len-1\n        → Swap result[i] and result[j]\n    → Return result\n\nAlso include random generator.\n\nLet's format with lines. Use 'Decision' maybe not needed. But we can include decision for loop? Not necessary. Just step loops.\n\nWe should follow arrow for each line. Use '→'. For loops we can use Step: For i... But we may include a Decision inside loop to decide swap? Maybe not.\n\nBetter to have lines:\n\n→ Step 5: For i in 0..len-1 // iterate over array\n    → Step 6: j = random(i, len-1) // pick random index\n    → Step 7: Swap result[i], result[j] // swap\n\nMake sure indentation: Use spaces.\n\nAlso need to start class and methods.\n\nBut we cannot output actual code, only virtual steps. So we can represent methods as Step 3: Method reset() ... etc.\n\nLet's produce output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 將傳入的數字陣列 nums 複製為 original // 儲存原始順序  \n→ Step 2: 將 original 複製為 current // 供後續操作使用  \n\n→ Step 3: Method reset() // 重設方法  \n    → Step 3.1: Return original.clone() // 以副本回傳原始陣列，避免外部改動  \n\n→ Step 4: Method shuffle() // 洗牌方法  \n    → Step 4.1: result ← original.clone() // 先以原始陣列副本開始  \n    → Step 4.2: len ← result.length // 取得陣列長度  \n    → Step 4.3: For i ← 0 To len-1 Do // 遍歷每個位置  \n        → Step 4.3.1: j ← random(i, len-1) // 產生 i 到 len-1 的隨機索引  \n        → Step 4.3.2: Swap result[i], result[j] // 交換兩個位置的值  \n    → Step 4.4: Return result // 回傳洗牌後的陣列  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, nums):\n        self.original = list(nums)\n\n    def reset(self):\n        return self.original\n\n    def shuffle(self):\n        arr = self.original[:]\n        n = len(arr)\n        for i in range(n):\n            j = random.randint(i, n - 1)\n            arr[i], arr[j] = arr[j], arr[i]\n        return arr\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        sys.exit(0)\n    ops = json.loads(data[0])\n    args = json.loads(data[1])\n\n    results = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            obj = Solution(arg)\n            results.append(None)\n        elif op == \"reset\":\n            results.append(obj.reset())\n        elif op == \"shuffle\":\n            results.append(obj.shuffle())\n\n    print(json.dumps(results))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"], [[[1, 2, 3]], [], [], []]",
          "expected_output": "[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmp4in5bdqi.py\", line 24, in <module>\n    ops = json.loads(data[0])\n          ^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 44 (char 43)"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode405.json",
    "problem_index_in_file": 0,
    "title": "Convert a Number to Hexadecimal",
    "description_snippet": "Given a 32-bit integer num, return a string representing its hexadecimal representation. For negativ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for converting 32-bit integer to hex string, handling negative using two's complement, no built-in conversion. Use bit masking and shifting. Steps: handle zero separately, determine if negative by sign bit, compute two's complement by bitwise NOT and add 1 for negative, but easier: if negative, treat as unsigned 32-bit value: num & 0xffffffff. Then while value>0: hex_digit = value & 0xf, map to char, prepend or accumulate reversed, value >>=4. Finally reverse or build string accordingly. Ensure lowercase. No leading zeros.\n\nNeed virtual code with arrows. Use Start, Step, Decision etc. Provide each line. Ensure we cover all logic. Also include loop.\n\nLet's craft.\n\nVirtual code:\n\nStart\n→ Step 1: If num == 0 → Step 2: Output \"0\" // handle zero case\n→ Decision: If num < 0? // check negativity\n    Yes → Step 3: Set value = num & 0xffffffff // convert to unsigned 32-bit two's complement\n    No  → Step 4: Set value = num // use as is\n→ Step 5: Initialize empty string result // store hex digits in reverse order\n→ Step 6: While value > 0? // process each 4-bit nibble\n    Yes → Step 7: digit = value & 0xf // get lowest 4 bits\n    → Step 8: Map digit to hex character // 0-9 or a-f\n    → Step 9: Append character to result // prepend or add to string\n    → Step 10: value = value >> 4 // shift to next nibble\n    No  → // loop exit\n→ Step 11: Reverse result string // to correct order\n→ Step 12: Output result // final hexadecimal representation\nEnd\n\nWe need to include comments after each line.\n\nAlso need to show mapping step? Provide mapping via conditional? Could show: Step 8: If digit < 10 then char = '0' + digit else char = 'a' + (digit-10). Provide in two steps.\n\nLet's structure accordingly.\n\nLet's produce each line with //.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: If num == 0 → Step 2: Output \"0\" // 直接處理零的情況  \n→ Decision: num < 0? // 判斷是否為負數  \n  Yes → Step 3: Set value = num & 0xffffffff // 取得負數的兩補數 32‑bit 表示  \n  No  → Step 4: Set value = num // 正數直接使用  \n→ Step 5: Initialize empty string result // 用於暫存十六進位字元（倒序）  \n→ Step 6: While value > 0? // 逐四位處理  \n  Yes → Step 7: digit = value & 0xf // 取最低 4 位  \n   → Step 8: If digit < 10? // 判斷是數字還是字母  \n     Yes → Step 9: char = '0' + digit // 對應 '0'~'9'  \n     No  → Step 10: char = 'a' + (digit - 10) // 對應 'a'~'f'  \n     → Step 11: Append char to result // 暫存字元（倒序）  \n    → Step 12: value = value >> 4 // 右移四位，處理下一個 nibble  \n  No → // 退出迴圈  \n→ Step 13: Reverse result // 反轉為正確順序  \n→ Step 14: Output result // 顯示十六進位字串  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def toHex(self, num: int) -> str:\n        \"\"\"\n        Convert a 32‑bit signed integer to its hexadecimal representation.\n        Negative numbers are handled using two's complement.\n        \"\"\"\n        # 零的特例\n        if num == 0:\n            return \"0\"\n\n        # 兩補數：對負數取 32 位 unsigned 表示\n        if num < 0:\n            num &= 0xffffffff  # 等價於 num + 2**32\n\n        hex_digits = \"0123456789abcdef\"\n        res = []\n        while num > 0:\n            # 取最低 4 位\n            digit = num & 0xF\n            res.append(hex_digits[digit])\n            num >>= 4  # 右移 4 位\n\n        # 目前 res 為倒序，需要反轉\n        return ''.join(reversed(res))\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入，並從中擷取第一個符合規則的整數\n    raw_input = sys.stdin.read()\n    match = re.search(r'-?\\d+', raw_input)\n    if not match:\n        print(\"\")  # 若沒有數字，直接輸出空行\n        sys.exit(0)\n\n    num = int(match.group())\n    solution = Solution()\n    print(solution.toHex(num))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num = 26",
          "expected_output": "1a",
          "success": true,
          "output": "1a"
        },
        {
          "example_index": 1,
          "input": "num = -1",
          "expected_output": "ffffffff",
          "success": true,
          "output": "ffffffff"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode292.json",
    "problem_index_in_file": 0,
    "title": "Nim Game",
    "description_snippet": "You are playing the following Nim Game with your friend:\n\nInitially, there is a heap of stones on th...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code steps line by line, with comments, using the arrow notation, decisions, etc. It's basically the Nim game with max 3 removal; the solution: return true if n % 4 != 0. But we need to produce virtual code steps explaining the algorithm. We should provide step-by-step pseudo-code. It should include Start, decisions, loops? We can just have simple steps: compute n mod 4, if 0 then false else true. Provide explanation.\n\nWe need to output in Chinese (繁體中文). Each line: \"虛擬碼步驟 // 解釋\". Use arrow or Decision syntax. Use Start, End. Provide the algorithm.\n\nWe must not output actual code; just the steps. So we can do:\n\nStart // 程式開始\n\n→ Step 1: 取得 n // 讀取堆石數量\n\n→ Decision: 如果 n mod 4 等於 0? // 判斷能否必勝\n\n   Yes → Step 2: 回傳 false // 無法必勝，回傳 false\n\n   No → Step 3: 回傳 true // 能必勝，回傳 true\n\nEnd // 程式結束\n\nBut we might want to incorporate the reasoning that if n % 4 == 0 you lose. Also might include explanation of why. Could add Step 1: Calculate remainder.\n\nLet's create detailed steps:\n\nStart\n\n→ Step 1: 計算 remainder = n mod 4 // 取得石子數量除以 4 的餘數\n\n→ Decision: 如果 remainder == 0? // 判斷是否為 0\n\n    Yes → Step 2: 回傳 false // 你必輸\n\n    No → Step 3: 回傳 true // 你必勝\n\nEnd\n\nBut the instructions: \"逐行產生對應的虛擬碼 (Virtual Code)，並在每行虛擬碼之後立即提供該行的簡短、直觀的解釋。\" So each line has virtual code and comment. So we produce lines as above.\n\nAdd maybe Step 0: Input n.\n\nBut they already say given n. So we start with Start.\n\nBut we need to use arrow for decisions. The arrow for decisions: \"Decision: If remainder == 0? // explanation\". Then \"Yes → Step 2\". So fine.\n\nLet's produce.\n\nAlso might need to include loops? No.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算 remainder = n mod 4 // 取得石子數量除以 4 的餘數  \n→ Decision: remainder == 0? // 判斷堆數是否為 4 的倍數  \n Yes → Step 2: 回傳 false // 若 remainder 為 0，則你必輸  \n No  → Step 3: 回傳 true  // 若 remainder 不為 0，則你必勝  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef can_win_nim(n: int) -> bool:\n    \"\"\"Return True if the first player can force a win with n stones.\"\"\"\n    return n % 4 != 0\n\nif __name__ == \"__main__\":\n    # Read all input and extract the first integer (handles formats like \"n = 4\")\n    data = sys.stdin.read()\n    match = re.search(r\"\\d+\", data)\n    if not match:\n        sys.exit(0)  # No valid number found\n\n    n = int(match.group())\n    result = can_win_nim(n)\n    # Output lowercase 'true' or 'false' to match the expected format\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 4",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "n = 2",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode263.json",
    "problem_index_in_file": 0,
    "title": "Ugly Number",
    "description_snippet": "An ugly number is a positive integer which does not have a prime factor other than 2, 3, and 5.\n\nGiv...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for checking ugly number. Must be line-by-line with arrows, Start, End, Decision: etc. Use Chinese comments.\n\nWe need to check if n>0, then while n%2==0 n/=2; while n%3==0 n/=3; while n%5==0 n/=5; if n==1 return true else false. Include decision to check positive.\n\nLet's create steps:\n\nStart\n→ Step 1: 獲取輸入整數 n // get n\n→ Decision: n 是否大於 0? // check positive\n    No → Step 2: 返回 false // not positive\n    Yes → Step 3: while n 可被 2 整除, n=n/2 // remove factor 2\n    → Step 4: while n 可被 3 整除, n=n/3 // remove factor 3\n    → Step 5: while n 可被 5 整除, n=n/5 // remove factor 5\n    → Decision: n 是否等於 1? // check remaining\n        Yes → Step 6: 返回 true // ugly\n        No → Step 7: 返回 false // not ugly\nEnd\n\nWe need arrow notation: → Step 1: ... etc. For loops maybe as \"While\" steps.\n\nUse proper indentation for decisions.\n\nLet's produce.\n\nEnsure each line ends with // explanation. Use space after arrow.\n\nLet's craft.\n\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 獲取輸入整數 n // 從使用者取得待檢查的數字\n→ Decision: n 是否大於 0? // 只有正整數才可能是 Ugly 數\n    No → Step 2: 返回 false // 非正數即非 Ugly 數\n    Yes → Step 3: While n 可被 2 整除, n = n / 2 // 去除所有 2 的因子\n    → Step 4: While n 可被 3 整除, n = n / 3 // 去除所有 3 的因子\n    → Step 5: While n 可被 5 整除, n = n / 5 // 去除所有 5 的因子\n    → Decision: n 是否等於 1? // 若剩餘只為 1，表示所有因子均為 2、3、5\n        Yes → Step 6: 返回 true // 是 Ugly 數\n        No  → Step 7: 返回 false // 含有其他質因子，非 Ugly 數\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def isUgly(self, n: int) -> bool:\n        \"\"\"\n        判斷 n 是否為 Ugly 數\n        Ugly 數：正整數，且質因子只包含 2、3、5\n        \"\"\"\n        if n <= 0:          # 不是正整數就不是 Ugly 數\n            return False\n        for p in (2, 3, 5): # 依次除去 2、3、5 的因子\n            while n % p == 0:\n                n //= p\n        return n == 1       # 只剩 1 表示所有因子均為 2、3、5\n\ndef parse_n(text: str) -> int | None:\n    \"\"\"\n    從輸入文字中擷取第一個整數（可帶負號）\n    \"\"\"\n    m = re.search(r'-?\\d+', text)\n    return int(m.group()) if m else None\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    n = parse_n(raw_input)\n    if n is None:\n        # 沒有找到數字，直接終止\n        sys.exit(0)\n    solution = Solution()\n    print(\"true\" if solution.isUgly(n) else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 6",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "n = 14",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode78.json",
    "problem_index_in_file": 0,
    "title": "Subsets",
    "description_snippet": "Given an integer array nums of unique elements, return all possible subsets (the power set).\n\nThe so...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for generating all subsets of an array of unique elements, no duplicates, order doesn't matter. It's typical subset generation using recursion/backtracking or iterative bitmask. We'll produce steps: Start, initialize result, define function backtrack(index, current), base: if index == len, add current copy to result; else, include nums[index], call backtrack(index+1, current+[nums[index]]), then exclude, call backtrack(index+1, current). After recursion done, return result.\n\nWe need to produce each line as \"虛擬碼步驟 // 解釋\". Use arrows.\n\nLet's structure:\n\nStart\n→ Step 1: 定義輸入陣列 nums // 從外部取得數組\n→ Step 2: 初始化結果集 result 為空列表 // 用於存放子集\n→ Step 3: 定義遞迴函式 backtrack(idx, current) // 將索引與當前子集作為參數\n    → Decision: 如果 idx 等於 nums 長度? // 判斷是否已遍歷完所有元素\n        Yes → Step 4: 把 current 的複製加入 result // 完整子集加入結果\n        No  → Step 5: 包含 nums[idx]，調用 backtrack(idx+1, current + [nums[idx]]) // 選擇當前元素\n             → Step 6: 排除 nums[idx]，調用 backtrack(idx+1, current) // 不選擇當前元素\n→ Step 7: 調用 backtrack(0, []) // 從起始索引和空子集開始\n→ Step 8: 返回 result // 結果即為所有子集\n\nBut each line should have a step number maybe? They didn't require step number but fine. Provide arrow before each step maybe.\n\nWe need to use \"Start\", \"End\", \"Decision:\" etc.\n\nLet's produce as:\n\nStart // 程式開始\n→ Step 1: 設定輸入陣列 nums // 從外部取得唯一元素的整數陣列\n→ Step 2: 初始化結果集 result 為空列表 // 用於儲存所有子集\n→ Step 3: 定義遞迴函式 backtrack(idx, current) // idx 為目前索引，current 為已選擇元素集合\n    → Decision: idx 是否等於 nums 長度? // 檢查是否已處理完所有元素\n        Yes → Step 4: 把 current 的複製加入 result // 完整子集加入結果\n        No  → Step 5: 包含 nums[idx] 並遞迴調用 backtrack(idx+1, current + [nums[idx]]) // 選擇當前元素\n        No  → Step 6: 排除 nums[idx] 並遞迴調用 backtrack(idx+1, current) // 不選擇當前元素\n→ Step 7: 調用 backtrack(0, []) // 從索引 0 和空子集開始遞迴\n→ Step 8: 返回 result // 回傳所有子集\nEnd // 程式結束\n\nBut we should be careful: In Decision: idx == len? Yes then Step 4, else we should have two branches (include, exclude). We can express as two \"No\" branches maybe with indent. But we can use arrow like:\n\nDecision: idx == len(nums)? \n    Yes → Step 4...\n    No  → Step 5...\n    No  → Step 6...\n\nBut typical representation may be:\n\nDecision: idx == len(nums)? \n    Yes → Step 4: ...\n    No  → Step 5: ...\n    No  → Step 6: ...\n\nBut it's ambiguous. Could also separate as two decisions but better to show as two separate lines under No.\n\nAlternatively:\n\nDecision: idx == len(nums)?\n    Yes → Step 4: add current to result\n    No  → Step 5: include nums[idx]; backtrack(idx+1, current + [nums[idx]])\n    No  → Step 6: exclude nums[idx]; backtrack(idx+1, current)\n\nBut we might need to show the branches properly.\n\nLet's format as:\n\nStart // 程式開始\n→ Step 1: 設定輸入陣列 nums // ...\n→ Step 2: 初始化結果集 result 為空列表 // ...\n→ Step 3: 定義遞迴函式 backtrack(idx, current) // ...\n    → Decision: idx == len(nums)? // ...\n        Yes → Step 4: 把 current 的複製加入 result // ...\n        No  → Step 5: 包含 nums[idx] 並遞迴調用 backtrack(idx+1, current + [nums[idx]]) // ...\n        No  → Step 6: 排除 nums[idx] 並遞迴調用 backtrack(idx+1, current) // ...\n→ Step 7: 調用 backtrack(0, []) // ...\n→ Step 8: 返回 result // ...\nEnd // 程式結束\n\nBut we need each line after the virtual code step include \"//\" and explanation. Provide one line for Start, each step. Indentation maybe with arrows and spaces. We should show indentation like in example: \"    Yes → ...\" etc.\n\nBetter to replicate example style:\n\nStart // 程式開始執行\n→ Step 1: 設定輸入陣列 nums // ...\n→ Step 2: 初始化結果集 result 為空列表 // ...\n→ Step 3: 定義遞迴函式 backtrack(idx, current) // ...\n    → Decision: idx == len(nums)? // ...\n        Yes → Step 4: 把 current 的複製加入 result // ...\n        No  → Step 5: 包含 nums[idx] 並調用 backtrack(idx+1, current + [nums[idx]]) // ...\n        No  → Step 6: 排除 nums[idx] 並調用 backtrack(idx+1, current) // ...\n→ Step 7: 調用 backtrack(0, []) // ...\n→ Step 8: 返回 result // ...\nEnd // 程式結束\n\nBut we need to ensure each line includes the step text and comment. In example, each line shows \"Start // 程式開始執行\". So we need to mimic.\n\nWe need to produce a final answer in Traditional Chinese. Let's craft it.\n\nAlso note: the instruction \"逐行生成虛擬碼\" means each line should be a step. So we should produce one line per step, with appropriate indentation. We should include arrow \"→\" at start of each step line, except Start and End? In example, Start has no arrow. Step lines have arrow. Decision has arrow and then \"Decision: ...\".\n\nSo produce:\n\nStart // 程式開始執行\n→ Step 1: 設定輸入陣列 nums // 從外部取得唯一元素的整數陣列\n→ Step 2: 初始化結果集 result 為空列表 // 用於儲存所有子集\n→ Step 3: 定義遞迴函式 backtrack(idx, current) // idx 為目前索引，current 為已選擇元素集合\n    → Decision: idx 等於 nums 長度嗎？ // 判斷是否已處理完所有元素\n        Yes → Step 4: 把 current 的複製加入 result // 完整子集加入結果\n        No  → Step 5: 包含 nums[idx] 並調用 backtrack(idx+1, current + [nums[idx]]) // 選擇當前元素\n        No  → Step 6: 排除 nums[idx] 並調用 backtrack(idx+1, current) // 不選擇當前元素\n→ Step 7: 調用 backtrack(0, []) // 從索引 0 和空子集開始遞迴\n→ Step 8: 返回 result // 回傳所有子集\nEnd // 程式結束\n\nBut the \"No  → Step 5\" and \"No  → Step 6\" might be confusing. We could also use indentation like:\n\n→ Step 3: 定義遞迴函式 backtrack(idx, current)\n    → Decision: idx == len(nums)?\n        Yes → Step 4: 把 current 的複製加入 result\n        No  → Step 5: 包含 nums[idx]; backtrack(idx+1, current + [nums[idx]])\n        No  → Step 6: 排除 nums[idx]; backtrack(idx+1, current)\n\nThis might be acceptable.\n\nBut we need to include the explanation after each line. So we need to put // explanation for each step.\n\nLet's format each line accordingly:\n\nStart // 程式開始執行\n→ Step 1: 設定輸入陣列 nums // 從外部取得唯一元素的整數陣列\n→ Step 2: 初始化結果集 result 為空列表 // 用於儲存所有子集\n→ Step 3: 定義遞迴函式 backtrack(idx, current) // idx 為目前索引，current 為已選擇元素集合\n    → Decision: idx == len(nums)? // 判斷是否已處理完所有元素\n        Yes → Step 4: 把 current 的複製加入 result // 完整子集加入結果\n        No  → Step 5: 包含 nums[idx] 並調用 backtrack(idx+1, current + [nums[idx]]) // 選擇當前元素\n        No  → Step 6: 排除 nums[idx] 並調用 backtrack(idx+1, current) // 不選擇當前元素\n→ Step 7: 調用 backtrack(0, []) // 從索引 0 和空子集開始遞迴\n→ Step 8: 返回 result // 回傳所有子集\nEnd // 程式結束\n\nBut note: The \"No\" branches may appear twice. However, typical pseudocode uses two separate \"No\" branches but we can combine them: after \"Decision:\" we have Yes branch, No branch where we do include and exclude. But we can't have two \"No\" branches. But we can simply have two separate steps after No. But it's okay.\n\nAlternatively, we can restructure:\n\n→ Step 3: 定義遞迴函式 backtrack(idx, current)\n    → Decision: idx == len(nums)?\n        Yes → Step 4: 把 current 的複製加入 result\n        No  → Step 5: 包含 nums[idx] 並調用 backtrack(idx+1, current + [nums[idx]]) // 選擇當前元素\n        No  → Step 6: 排除 nums[idx] 並調用 backtrack(idx+1, current) // 不選擇當前元素\n\nBut we have to avoid duplicate \"No\" lines maybe; we can have one No line that does both include and exclude calls? In typical pseudocode, we would have:\n\nDecision: idx == len(nums)?\n    Yes -> ...\n    No -> \n        Step 5: 包含 nums[idx] ...\n        Step 6: 排除 nums[idx] ...\n\nBut they want each line with arrow and explanation. So we could do:\n\n→ Step 3: 定義遞迴函式 backtrack(idx, current)\n    → Decision: idx == len(nums)?\n        Yes → Step 4: 把 current 的複製加入 result // 完整子集加入結果\n        No  → Step 5: 包含 nums[idx] 並調用 backtrack(idx+1, current + [nums[idx]]) // 選擇當前元素\n        No  → Step 6: 排除 nums[idx] 並調用 backtrack(idx+1, current) // 不選擇當前元素\n\nOk.\n\nWe need to keep indentation consistent.\n\nThus produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定輸入陣列 nums // 從外部取得唯一元素的整數陣列  \n→ Step 2: 初始化結果集 result 為空列表 // 用於儲存所有子集  \n→ Step 3: 定義遞迴函式 backtrack(idx, current) // idx 為目前索引，current 為已選擇元素集合  \n    → Decision: idx == len(nums)? // 判斷是否已處理完所有元素  \n        Yes → Step 4: 把 current 的複製加入 result // 完整子集加入結果  \n        No  → Step 5: 包含 nums[idx] 並調用 backtrack(idx+1, current + [nums[idx]]) // 選擇當前元素  \n        No  → Step 6: 排除 nums[idx] 並調用 backtrack(idx+1, current) // 不選擇當前元素  \n→ Step 7: 調用 backtrack(0, []) // 從索引 0 和空子集開始遞迴  \n→ Step 8: 返回 result // 回傳所有子集  \nEnd // 程式結束",
      "generated_code": "import sys\nimport ast\nimport json\n\nclass Solution:\n    def subsets(self, nums):\n        res = []\n        def backtrack(start, path):\n            res.append(path[:])\n            for i in range(start, len(nums)):\n                path.append(nums[i])\n                backtrack(i + 1, path)\n                path.pop()\n        backtrack(0, [])\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        print(\"[]\")\n        sys.exit(0)\n    # Extract the list part after '='\n    try:\n        _, list_part = data.split('=', 1)\n    except ValueError:\n        list_part = data\n    list_part = list_part.strip()\n    # Safely evaluate the list using literal_eval\n    try:\n        nums = ast.literal_eval(list_part)\n    except Exception:\n        nums = []\n    solution = Solution()\n    result = solution.subsets(nums)\n    # Output without spaces as in the examples\n    print(json.dumps(result, separators=(',', ':')))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nGot (Norm):      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nRaw Got:      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'"
        },
        {
          "example_index": 1,
          "input": "nums = [0]",
          "expected_output": "[[],[0]]",
          "success": true,
          "output": "[[],[0]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode423.json",
    "problem_index_in_file": 0,
    "title": "Reconstruct Original Digits from English",
    "description_snippet": "Given a string s containing an out-of-order English representation of digits 0-9, return the digits ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the described problem. Must not output actual code. Provide step-by-step algorithm. Use Start, End, Decision:, arrows.\n\nWe need to process a string s containing out-of-order English representation of digits 0-9. The representation means that s is a string that contains letters that form spelled-out digits (like \"one\", \"zero\", etc.), but the letters might be jumbled, but I think the representation is a concatenation of spelled-out numbers, but the digits themselves are out of order. So we need to find which digits appear in s, then return the digits in ascending order. For example, s=\"owoztneoer\" which is \"one\" \"two\" \"zero\" out of order? Actually known Leetcode 423. The algorithm: Count letters, identify digits with unique letters: z (0), w (2), u (4), x (6), g (8). Then subtract counts, identify others: o (1) after 0,2,4 removed, h (3) after 8 removed, f (5) after 4 removed, s (7) after 6 removed, i (9) after 5,6,8 removed.\n\nWe need to produce pseudocode steps accordingly. So:\n\nStart\n→ Step 1: Count frequency of each letter in s // letter frequency map\n→ Decision: if 'z' present? // check digit 0\n    Yes → Step 2: Append '0' count[z] times to result; subtract counts for letters in \"zero\" count[z] times\n    No → ...\nSimilarly for w (2), u (4), x (6), g (8)\nThen process remaining digits 1,3,5,7,9 with unique letters after removal.\n\nReturn sorted digits (which are appended in ascending order already). End.\n\nWe need to provide step-by-step with decisions.\n\nMake each line: virtual code step + // explanation.\n\nWe will produce lines. Let's craft.\n\nLine 1: Start // 程式開始執行\n\nLine 2: → Step 1: 初始化字母頻率表 letterCount ← count每個字母 s // 取得每個字母的出現次數\n\nLine 3: → Decision: 是否存在字母 'z'? // 'z' 唯一屬於數字 0\n\nLine 4:     Yes → Step 2: 為每個 0 的出現次數，將 '0' 加入結果陣列 // 0 的數量等於 letterCount['z']\nLine 5:     Yes → Step 3: 從 letterCount 中減去字母 \"zero\" 的出現次數 × 0 的數量 // 更新頻率表\n\nLine 6: → Decision: 是否存在字母 'w'? // 'w' 唯一屬於數字 2\n\nLine 7:     Yes → Step 4: 為每個 2 的出現次數，將 '2' 加入結果陣列\nLine 8:     Yes → Step 5: 減去字母 \"two\" 的出現次數 × 2 的數量\n\n... and so on.\n\nWe need to include steps for digits 4,6,8 similarly.\n\nThen after unique digits processed, process others.\n\nWe should include decisions for each unique letter.\n\nAfter all unique digits, handle remaining digits:\n\nDecision: 是否存在字母 'o'? // after 0,2,4 removed, remaining 'o' correspond to 1\nYes → Step: append '1' count['o'] times; subtract letters in \"one\".\n\nDecision: 是否存在字母 'h'? // after 8 removed, 'h' corresponds to 3\n...\n\nDecision: 是否存在字母 'f'? // after 4 removed, 'f' corresponds to 5\n...\n\nDecision: 是否存在字母 's'? // after 6 removed, 's' corresponds to 7\n...\n\nDecision: 是否存在字母 'i'? // after 5,6,8 removed, 'i' corresponds to 9\n...\n\nFinally, End // 程式執行結束\n\nAlso mention we will sort the result, but since we append digits in ascending order, final result is sorted.\n\nLet's produce final output.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 初始化字母頻率表 letterCount ← count每個字母 s // 取得每個字母在 s 中的出現次數\n→ Decision: 是否存在字母 'z'? // 'z' 唯一屬於數字 0\n    Yes → Step 2: 取得 countZ ← letterCount['z'] // 0 的數量\n    Yes → Step 3: 將 '0' 加入結果陣列 countZ 次 // 0 的個數\n    Yes → Step 4: 從 letterCount 中減去字母 \"zero\" 的出現次數 × countZ // 更新頻率表\n→ Decision: 是否存在字母 'w'? // 'w' 唯一屬於數字 2\n    Yes → Step 5: 取得 countW ← letterCount['w']\n    Yes → Step 6: 將 '2' 加入結果陣列 countW 次\n    Yes → Step 7: 減去字母 \"two\" 的出現次數 × countW\n→ Decision: 是否存在字母 'u'? // 'u' 唯一屬於數字 4\n    Yes → Step 8: 取得 countU ← letterCount['u']\n    Yes → Step 9: 將 '4' 加入結果陣列 countU 次\n    Yes → Step 10: 減去字母 \"four\" 的出現次數 × countU\n→ Decision: 是否存在字母 'x'? // 'x' 唯一屬於數字 6\n    Yes → Step 11: 取得 countX ← letterCount['x']\n    Yes → Step 12: 將 '6' 加入結果陣列 countX 次\n    Yes → Step 13: 減去字母 \"six\" 的出現次數 × countX\n→ Decision: 是否存在字母 'g'? // 'g' 唯一屬於數字 8\n    Yes → Step 14: 取得 countG ← letterCount['g']\n    Yes → Step 15: 將 '8' 加入結果陣列 countG 次\n    Yes → Step 16: 減去字母 \"eight\" 的出現次數 × countG\n→ Decision: 是否存在字母 'o'? // 'o' 在 0、2、4 移除後只剩 1\n    Yes → Step 17: 取得 countO ← letterCount['o']\n    Yes → Step 18: 將 '1' 加入結果陣列 countO 次\n    Yes → Step 19: 減去字母 \"one\" 的出現次數 × countO\n→ Decision: 是否存在字母 'h'? // 'h' 在 8 移除後只剩 3\n    Yes → Step 20: 取得 countH ← letterCount['h']\n    Yes → Step 21: 將 '3' 加入結果陣列 countH 次\n    Yes → Step 22: 減去字母 \"three\" 的出現次數 × countH\n→ Decision: 是否存在字母 'f'? // 'f' 在 4 移除後只剩 5\n    Yes → Step 23: 取得 countF ← letterCount['f']\n    Yes → Step 24: 將 '5' 加入結果陣列 countF 次\n    Yes → Step 25: 減去字母 \"five\" 的出現次數 × countF\n→ Decision: 是否存在字母 's'? // 's' 在 6 移除後只剩 7\n    Yes → Step 26: 取得 countS ← letterCount['s']\n    Yes → Step 27: 將 '7' 加入結果陣列 countS 次\n    Yes → Step 28: 減去字母 \"seven\" 的出現次數 × countS\n→ Decision: 是否存在字母 'i'? // 'i' 在 5、6、8 移除後只剩 9\n    Yes → Step 29: 取得 countI ← letterCount['i']\n    Yes → Step 30: 將 '9' 加入結果陣列 countI 次\n    Yes → Step 31: 減去字母 \"nine\" 的出現次數 × countI\n→ Step 32: 將結果陣列轉換成字串並返回 // 由於依次加入的順序已是升序，最終字串即為升序排列\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\nclass Solution:\n    def originalDigits(self, s: str) -> str:\n        # 計算每個字母出現的頻率\n        count = Counter(s)\n\n        # 依據唯一字母判斷數字\n        out = {}\n        out['0'] = count['z']\n        out['2'] = count['w']\n        out['4'] = count['u']\n        out['6'] = count['x']\n        out['8'] = count['g']\n\n        # 依序減去已確定的數字\n        out['3'] = count['h'] - out['8']\n        out['5'] = count['f'] - out['4']\n        out['7'] = count['s'] - out['6']\n        out['1'] = count['o'] - out['0'] - out['2'] - out['4']\n        out['9'] = count['i'] - out['5'] - out['6'] - out['8']\n\n        # 產生升序的數字字串\n        res = [k * out[k] for k in sorted(out.keys())]\n        return ''.join(res)\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入，提取字母部分作為 s\n    raw = sys.stdin.read()\n    match = re.search(r's\\s*=\\s*\"([^\"]*)\"', raw)\n    if match:\n        s = match.group(1)\n    else:\n        # 如果沒有明確的 s = \"...\"，就直接取所有英文字母\n        s = re.sub(r'[^a-zA-Z]', '', raw).lower()\n\n    sol = Solution()\n    result = sol.originalDigits(s)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"owoztneoer\"",
          "expected_output": "\"012\"",
          "success": true,
          "output": "012"
        },
        {
          "example_index": 1,
          "input": "s = \"fviefuro\"",
          "expected_output": "\"45\"",
          "success": true,
          "output": "45"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode479.json",
    "problem_index_in_file": 0,
    "title": "Largest Palindrome Product",
    "description_snippet": "Given an integer n, return the largest palindromic integer that can be represented as the product of...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code for algorithm: find largest palindrome from product of two n-digit numbers modulo 1337.\n\nStandard solution: generate largest palindrome less than upper bound of product of two n-digit numbers (9...9). Use math to find candidate palindrome by mirroring. Check if it can be factorized by two n-digit numbers.\n\nPseudo: start from max product (10^n -1)^2. Generate palindrome candidates by constructing first half digits of length n, then reverse etc. For each candidate palindrome from largest to smallest, try to find factor in range [10^(n-1), 10^n-1]. If found return palindrome % 1337.\n\nEdge cases: n=1 -> return 9.\n\nWe need to produce step-by-step virtual code. Each line with explanation. Use arrow syntax.\n\nLet's produce:\n\nStart\n→ Step: Compute lower and upper bounds for n-digit numbers // lower = 10^(n-1), upper = 10^n -1\n→ Decision: n==1? // special case for single digit\n    Yes → Step: Return 9 % 1337 // return 9\n    No → Step: Set max_product = upper * upper // maximum possible product\n→ Step: Build palindrome candidates by iterating first_half from upper down to lower\n    // iterate over all possible first halves in descending order\n    → For loop: first_half in range(upper, lower-1, -1)\n        → Step: Convert first_half to string, reverse to get second half, combine to form palindrome\n        → Step: candidate = int(str_first + reversed_str)\n        → Decision: candidate <= max_product? // ensures within product bounds\n            Yes → Decision: check_factorization(candidate)? // try to factorize\n                Yes → Step: Return candidate % 1337 // found largest palindrome\n                No → Step: Continue // next first_half\n            No → Step: Continue // next first_half\n→ End // no palindrome found (should not happen)\n\nNeed to incorporate check_factorization: iterate divisor from upper down to lower, check candidate % divisor == 0 and candidate/divisor between lower and upper.\n\nAdd loop.\n\nWe need to output each line with comment.\n\nLet's craft lines.\n\nMake sure each line has \"虛擬碼步驟 [空格] // 解釋\".\n\nUse arrows: \"→\" indicates next step.\n\nAlso \"Decision:\" lines.\n\nOk produce.\n\nLet's output final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: lower = 10^(n-1) // 最小的 n 位數字  \n→ Step: upper = 10^n - 1 // 最大的 n 位數字  \n→ Decision: n == 1? // 單一位數特殊處理  \n  Yes → Step: Return 9 % 1337 // 9 是最大的 1 位數乘法回文  \n  No → Step: max_product = upper * upper // 兩個 n 位數字的最大乘積  \n→ Step: for first_half from upper down to lower step -1 // 生成可能的前半部分  \n  → Step: str_half = String(first_half) // 將前半部分轉為字串  \n  → Step: rev_half = Reverse(str_half) // 取得反向字串  \n  → Step: candidate = Int(str_half + rev_half) // 組合得到完整回文數  \n  → Decision: candidate <= max_product? // 是否在合法乘積範圍內  \n    Yes → Step: divisor = upper // 從最大因數開始嘗試分解  \n     → Step: while divisor >= lower: // 範圍內所有可能因數  \n       → Decision: candidate % divisor == 0? // 能否整除  \n         Yes → Step: other = candidate / divisor // 獲得另一因數  \n           → Decision: lower <= other <= upper? // 另一因數是否也是 n 位數  \n              Yes → Step: Return candidate % 1337 // 找到最大回文，返回結果  \n              No  → Step: divisor = divisor - 1 // 其他因數不合適，繼續嘗試  \n         No  → Step: divisor = divisor - 1 // 無法整除，繼續嘗試  \n       → Step: Continue // 完成所有因數嘗試後回到下一個 first_half  \n      → Step: Continue // 若無合法因數，繼續下一個 first_half  \n    → Step: Continue // 若候選值超過最大乘積，繼續下一個 first_half  \n→ End // 程式執行結束（理論上此行永遠不會被執行，因為總能找到回文）",
      "generated_code": "import sys\nimport re\nimport math\n\n# 主要的解法類別\nclass Solution:\n    def largestPalindrome(self, n: int) -> int:\n        \"\"\"\n        計算能由兩個 n 位數字相乘得到的最大回文數，並回傳其對 1337 的餘數。\n        \"\"\"\n        # 單一位數的特例：9 就是最大的 1 位數乘積回文\n        if n == 1:\n            return 9 % 1337\n\n        # 兩個 n 位數字的範圍\n        lower = 10 ** (n - 1)          # 最小 n 位數\n        upper = 10 ** n - 1            # 最大 n 位數\n        max_product = upper * upper    # 兩個最大 n 位數字相乘的結果\n\n        # 從最大的可能前半部分往下枚舉\n        for first in range(upper, lower - 1, -1):\n            s = str(first)\n            # 把前半部分鏡像得到完整的回文數\n            pal = int(s + s[::-1])\n\n            # 如果回文超過可達到的最大乘積，直接跳過\n            if pal > max_product:\n                continue\n\n            # 將因數範圍限制在 [lower, upper]，且至少有一個因數不小於 sqrt(pal)\n            sqrt_pal = int(math.isqrt(pal))\n            # 只需檢查 d >= max(lower, sqrt_pal)，其餘情況已被更大的 d 覆蓋\n            for d in range(upper, max(lower, sqrt_pal), -1):\n                if pal % d == 0:\n                    other = pal // d\n                    if lower <= other <= upper:\n                        # 找到符合條件的最大回文，直接返回其餘數\n                        return pal % 1337\n\n        # 若沒找到符合條件的回文（理論上不會發生）\n        return 0\n\ndef main():\n    # 讀取整個輸入，並從中擷取第一個整數 n\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    m = re.search(r'\\d+', data)\n    n = int(m.group()) if m else 0\n\n    sol = Solution()\n    print(sol.largestPalindrome(n))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 2",
          "expected_output": "987",
          "success": true,
          "output": "987"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "9",
          "success": true,
          "output": "9"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode2410.json",
    "problem_index_in_file": 0,
    "title": "Maximum Matching of Players With Trainers",
    "description_snippet": "You are given a 0-indexed integer array players, where players[i] represents the ability of the i^th...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps line by line with comments. It's a matching problem: given ability array players and capacity array trainers, each player can match with trainer if ability <= capacity. One-to-one matching, want maximum matches. Classic greedy: sort both arrays ascending, two pointers. Count matches when ability <= capacity.\n\nWe need to output virtual code lines with comments in Chinese. Each line: \"虛擬碼步驟 // 解釋\". Use arrows: Start, →, Decision: etc.\n\nLet's craft steps:\n\nStart\n→ Sort players ascending\n→ Sort trainers ascending\n→ Initialize i=0, j=0, matches=0 // pointers\n→ Decision: i < len(players) AND j < len(trainers)? // loop condition\n    Yes → Decision: players[i] <= trainers[j]? // check if current player can match\n        Yes → matches++ // increment match count\n                i++ // move to next player\n                j++ // move to next trainer\n        No → j++ // trainer too weak, try next trainer\n    No → End loop\nEnd\n\nReturn matches.\n\nWe might add Return step: Step: Return matches.\n\nOk produce each line accordingly. Use Start, End etc. Each line include comment. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort players ascending // 將玩家能力值由小到大排序  \n→ Step 2: Sort trainers ascending // 將訓練師容量值由小到大排序  \n→ Step 3: Initialize i = 0, j = 0, matches = 0 // 指標 i 指向玩家, j 指向訓練師, matches 記錄已匹配數量  \n→ Decision: i < len(players) AND j < len(trainers) ? // 當還有未處理的玩家與訓練師時繼續  \n    Yes → Decision: players[i] <= trainers[j] ? // 當玩家能力小於等於訓練師容量可匹配  \n        Yes → matches++ // 成功匹配一次  \n                i++ // 移至下一位玩家  \n                j++ // 移至下一位訓練師  \n        No → j++ // 訓練師容量不足，嘗試下一位訓練師  \n    No → End // 所有玩家或訓練師已處理完畢  \n→ Step 4: Return matches // 回傳最大可匹配數量  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport re\n\nclass Solution:\n    def matchPlayersAndTrainers(self, players, trainers):\n        # 將玩家與訓練師能力分別從小到大排序\n        players.sort()\n        trainers.sort()\n        i = j = matches = 0\n        # 同時遍歷兩個列表\n        while i < len(players) and j < len(trainers):\n            if players[i] <= trainers[j]:\n                matches += 1\n                i += 1\n            j += 1\n        return matches\n\ndef parse_input(data: str):\n    \"\"\"\n    解析輸入文字，支持以下兩種格式：\n    1) 多行，每行僅包含一個列表，例如：\n        [4,7,9]\n        [8,2,5,8]\n    2) 單行，包含兩個列表，格式類似：\n        players = [4,7,9], trainers = [8,2,5,8]\n    \"\"\"\n    data = data.strip()\n    if not data:\n        return [], []\n\n    # 嘗試從多行格式讀取\n    lines = [line.strip() for line in data.splitlines() if line.strip()]\n    if len(lines) >= 2:\n        try:\n            players = ast.literal_eval(lines[0])\n            trainers = ast.literal_eval(lines[1])\n            return players, trainers\n        except Exception:\n            pass\n\n    # 如果不是多行，則搜尋兩個列表\n    lists = re.findall(r'\\[.*?\\]', data)\n    if len(lists) >= 2:\n        players = ast.literal_eval(lists[0])\n        trainers = ast.literal_eval(lists[1])\n        return players, trainers\n\n    # 若仍未解析成功，返回空列表\n    return [], []\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    players, trainers = parse_input(raw_input)\n    solution = Solution()\n    result = solution.matchPlayersAndTrainers(players, trainers)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "players = [4,7,9], trainers = [8,2,5,8]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "players = [1,1,1], trainers = [10]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode461.json",
    "problem_index_in_file": 0,
    "title": "Hamming Distance",
    "description_snippet": "The Hamming distance between two integers is the number of positions at which the corresponding bits...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code with line by line steps, each line: \"虛擬碼步驟 // 解釋\". Use arrows etc. Provide steps: start, XOR, count bits, return.\n\nWe'll structure: Start, Step1: input x, y, Step2: XOR = x ^ y, Step3: count=0, Step4: While XOR>0: Step5: if XOR & 1: count++, Step6: XOR>>=1, Step7: return count, End.\n\nAdd Decision: While XOR > 0? Yes -> loop else exit.\n\nLet's produce accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入整數 x 與 y // 取得兩個要計算 Hamming 距離的整數  \n→ Step 2: XOR = x XOR y // 取兩數的 XOR，得到所有不同位元的位置  \n→ Step 3: Count = 0 // 初始化計數器，準備統計不同位元個數  \n→ Decision: 是否還有位元需要檢查? (XOR > 0) // 判斷是否仍有剩餘位元  \n    Yes → Step 4: If (XOR AND 1) == 1 // 檢查最低位元是否為 1，代表不同  \n        Yes → Step 5: Count = Count + 1 // 若最低位元為 1，計數器加一  \n    No  → // 最高位元已為 0，結束此迴圈步驟  \n→ Step 6: XOR = XOR >> 1 // 右移一位，移除已檢查的最低位元  \n→ Decision: 是否還有位元需要檢查? (XOR > 0) // 重新判斷是否需要繼續迴圈  \n    Yes → 迴圈回 Step 4  \n    No  → Step 7: 回傳 Count // 所有位元檢查完畢，回傳 Hamming 距離  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def hammingDistance(self, x: int, y: int) -> int:\n        \"\"\"計算兩個整數的 Hamming 距離\"\"\"\n        xor = x ^ y          # 取 XOR，得到所有不同位元的位置\n        distance = 0\n        while xor:           # 只要還有位元未檢查\n            distance += xor & 1   # 若最低位元為 1，則不同位元數 +1\n            xor >>= 1           # 右移一位，檢查下一位元\n        return distance\n\ndef main() -> None:\n    data = sys.stdin.read()\n    numbers = list(map(int, re.findall(r'-?\\d+', data)))  # 取得輸入中的所有整數\n    if len(numbers) < 2:\n        return\n    x, y = numbers[0], numbers[1]\n    solution = Solution()\n    print(solution.hammingDistance(x, y))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "x = 1, y = 4",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "x = 3, y = 1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode621.json",
    "problem_index_in_file": 0,
    "title": "Task Scheduler",
    "description_snippet": "You are given an array of CPU tasks, each labeled with a letter from A to Z, and a number n. Each CP...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps for the algorithm that solves this problem: \"CPU task scheduling with cooling interval n\". Classic problem: find max frequency, compute idle slots. Steps: count frequencies, find max frequency, count how many tasks have that max freq, compute empty slots = (maxFreq-1)*(n+1) - (sum of tasks except max ones). Actually formula: partCount = maxFreq - 1, emptySlots = partCount * (n - (maxFreqCount-1)), but we can produce simpler: compute idle slots = (maxFreq-1)*(n+1) - (totalTasks - maxFreqCount). If idleSlots<0 set 0. result = totalTasks + idleSlots. We'll produce virtual code.\n\nNeed to output each line: 虛擬碼步驟 + // 解釋\n\nUse arrow. Start, End, Decision.\n\nLet's produce algorithm in pseudocode lines.\n\nWe'll break into steps: Start, Step 1: Count frequencies. Step 2: Find maxFreq and count of maxFreq. Step 3: Compute emptySlots. Step 4: Compute idle = max(0, emptySlots). Step 5: Return totalTasks + idle.\n\nAlso decision: if idle < 0 -> set idle=0.\n\nLet's produce line-by-line:\n\nStart // 程式開始執行\n→ Step 1: Count occurrences of each task letter // 建立頻率表\n→ Step 2: Find max frequency (maxFreq) and number of letters with this frequency (maxCount) // 確定最頻繁任務\n→ Step 3: totalTasks ← length of tasks array // 任務總數\n→ Step 4: partCount ← maxFreq - 1 // 需要分隔的部分數\n→ Decision: 如果 partCount <= 0? // 沒有重複任務\n    Yes → idleSlots ← 0 // 沒有空閒時間\n    No  → Step 5: emptySlots ← partCount * (n + 1) // 先算理想空閒槽數\n        → Step 6: occupiedSlots ← totalTasks - maxCount // 這些槽已被其他任務佔據\n        → Step 7: idleSlots ← emptySlots - occupiedSlots // 真正需要的空閒時間\n        → Decision: 如果 idleSlots < 0? // 超過任務可填充\n            Yes → idleSlots ← 0 // 無需空閒\n            No  → // idleSlots 保持原值\n→ Step 8: result ← totalTasks + idleSlots // 最少 CPU 間隔數\nEnd // 程式執行結束\n\nBut we should reflect typical formula: idleSlots = max(0, (maxFreq-1)*(n+1) - (totalTasks - maxCount)). We can combine steps.\n\nLet's produce final answer accordingly.\n\nAlso need to ensure each line has \"虛擬碼步驟\" with arrow etc.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立一個字典 freq，並統計每個任務字母在 tasks 陣列中的出現次數 // 建立頻率表  \n→ Step 2: 找出頻率表中最大的頻率 maxFreq，並計算有多少個任務字母達到這個頻率，記為 maxCount // 確定最頻繁任務數量  \n→ Step 3: totalTasks ← tasks 的長度 // 任務總數  \n→ Step 4: partCount ← maxFreq - 1 // 需要分隔的部分數（每個最頻繁任務之間至少一個間隔）  \n→ Decision: 如果 partCount ≤ 0? // 沒有重複任務可分隔  \n    Yes → idleSlots ← 0 // 無需空閒時間  \n    No  → Step 5: emptySlots ← partCount * (n + 1) // 先算理想的空閒槽數  \n        → Step 6: occupiedSlots ← totalTasks - maxCount // 已被其他任務佔據的槽數  \n        → Step 7: idleSlots ← emptySlots - occupiedSlots // 真正需要的空閒時間  \n        → Decision: 如果 idleSlots < 0? // 超過可填充的任務數量  \n            Yes → idleSlots ← 0 // 無需額外空閒  \n            No  → // idleSlots 保持計算值  \n→ Step 8: result ← totalTasks + idleSlots // 最少 CPU 間隔數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import Counter\n\ndef least_interval(tasks, n):\n    \"\"\"\n    計算完成所有任務所需的最少 CPU 間隔數。\n    \"\"\"\n    # 統計每個任務的出現頻率\n    task_counts = Counter(tasks)\n    # 找到最高頻率\n    max_freq = max(task_counts.values())\n    # 有多少個任務達到這個最高頻率\n    max_count = sum(1 for cnt in task_counts.values() if cnt == max_freq)\n    # 計算理想情況下的空閒時間\n    empty_slots = (max_freq - 1) * (n + 1)\n    # 已經占用的槽數 (除去最高頻率任務)\n    occupied_slots = len(tasks) - max_count\n    idle_slots = empty_slots - occupied_slots\n    if idle_slots < 0:\n        idle_slots = 0\n    # 最終間隔數 = 任務總數 + 必須的空閒時間\n    return len(tasks) + idle_slots\n\ndef parse_input(input_str):\n    \"\"\"\n    從給定的輸入字串中解析 tasks 列表和 n 整數。\n    支援格式類似於:\n        tasks = [\"A\",\"A\",\"B\"], n = 2\n    \"\"\"\n    # 尋找 tasks 列表\n    tasks_match = re.search(r'tasks\\s*=\\s*(\\[[^\\]]*\\])', input_str)\n    # 尋找 n 整數\n    n_match = re.search(r'n\\s*=\\s*(-?\\d+)', input_str)\n    if not tasks_match or not n_match:\n        raise ValueError(\"輸入格式不正確\")\n    tasks_str = tasks_match.group(1)\n    n_str = n_match.group(1)\n    # 用 literal_eval 解析列表，確保安全\n    tasks = ast.literal_eval(tasks_str)\n    n = int(n_str)\n    return tasks, n\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw_input = sys.stdin.read()\n    # 解析出 tasks 和 n\n    tasks, n = parse_input(raw_input)\n    # 計算並輸出結果\n    result = least_interval(tasks, n)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 2",
          "expected_output": "8",
          "success": true,
          "output": "8"
        },
        {
          "example_index": 1,
          "input": "tasks = [\"A\",\"C\",\"A\",\"B\",\"D\",\"B\"], n = 1",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 2,
          "input": "tasks = [\"A\",\"A\",\"A\", \"B\",\"B\",\"B\"], n = 3",
          "expected_output": "10",
          "success": true,
          "output": "10"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode355.json",
    "problem_index_in_file": 0,
    "title": "Design Twitter",
    "description_snippet": "Design a simplified version of Twitter where users can post tweets, follow/unfollow another user, an...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code, line by line, with \"→\" and such. We must cover initialization, data structures, methods, and steps. For each line, include comment. Let's craft pseudocode. Use Start, End. Use Decision. Use simple operations: maintain map userId->list of tweet ids, map userId->set of followees. For getNewsFeed: gather tweets from user and followees, sort by time descending, pick top 10. Use a global timestamp counter to preserve order.\n\nWe must produce only virtual code lines, not actual code. Use arrow lines. Provide explanation.\n\nLet's craft:\n\nStart // Initialize\n→ Declare class Twitter // Main class\n→ Define variable timestamp = 0 // Global timestamp for ordering\n→ Define Map<Integer, List<Tweet>> tweetsByUser // Stores tweets per user\n→ Define Map<Integer, Set<Integer>> followees // Stores follow relationships\n\nConstructor:\n→ Step: Twitter() // 初始化\n    → Initialize tweetsByUser as empty map\n    → Initialize followees as empty map\n    → Add default self follow? maybe not\n\npostTweet:\n→ Step: postTweet(userId, tweetId)\n    → Increment timestamp\n    → Create Tweet object (id, timestamp)\n    → If user not in tweetsByUser, create list\n    → Append Tweet to user's list\n    → // Add to feed? no\n\ngetNewsFeed:\n→ Step: getNewsFeed(userId)\n    → Initialize min-heap of size 10 (or list)\n    → For each uid in [userId] + followees[userId]\n        → If uid in tweetsByUser\n            → For each tweet in tweetsByUser[uid] (reverse iterate)\n                → Add to heap; if size >10 remove smallest\n    → Extract from heap to list sorted descending\n    → Return list of tweetIds\n\nfollow:\n→ Step: follow(followerId, followeeId)\n    → If followerId == followeeId, return\n    → If followerId not in followees, create set\n    → Add followeeId to followerId's set\n\nunfollow:\n→ Step: unfollow(followerId, followeeId)\n    → If followerId in followees, remove followeeId\n\nEnd.\n\nBut must provide step per line with comment. Use arrow.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Define Class Twitter // 建立 Twitter 物件的類別\n→ Define Integer timestamp ← 0 // 全域時間戳，確保 Tweet 的先後順序\n→ Define Map<Integer, List<Tweet>> tweetsByUser // 每個使用者對應的所有 Tweet (含 id 與時間戳)\n→ Define Map<Integer, Set<Integer>> followees // 每個使用者對應的關注者集合\n\n→ Step: Twitter() // 建構子，初始化資料結構\n    → Initialize tweetsByUser ← Empty Map // 為每個使用者建立空清單\n    → Initialize followees ← Empty Map // 為每個使用者建立空集合\n→ End // 建構子結束\n\n→ Step: postTweet(userId, tweetId) // 發佈新 Tweet\n    → Increment timestamp by 1 // 時間戳遞增\n    → Create Tweet ← (id: tweetId, time: timestamp) // 產生 Tweet 物件\n    → If userId not in tweetsByUser, then add new empty list // 若使用者首次發佈，先建立清單\n    → Append Tweet to tweetsByUser[userId] // 將 Tweet 加入使用者清單\n→ End // 發佈 Tweet 結束\n\n→ Step: getNewsFeed(userId) // 取得最新 10 個 Tweet\n    → Initialize List<Integer> newsFeed ← Empty // 用來存放最終結果\n    → Initialize MinHeap<Pair<time, tweetId>> heap ← size 10 // 儲存最近 10 個 Tweet，按時間戳排序\n    → Define Set<Integer> sources ← followees.getOrDefault(userId, Empty Set) // 取得關注者集合\n    → Add userId to sources // 也要包含自己的 Tweet\n    → For each srcId in sources\n        → If srcId in tweetsByUser\n            → For each tweet in tweetsByUser[srcId] (從最新到最舊遍歷)\n                → heap.offer((tweet.time, tweet.id)) // 加入堆疊\n                → If heap.size > 10, heap.poll() // 超過 10 則移除最舊的\n    → While heap not empty\n        → Remove top = heap.poll() // 取出最舊（因為是最小堆）\n        → Insert top.tweetId at front of newsFeed // 依時間倒序加入\n    → Return newsFeed // 返迴結果\n→ End // 取得 News Feed 結束\n\n→ Step: follow(followerId, followeeId) // 開始關注\n    → If followerId == followeeId, return // 自己不能關注自己\n    → If followerId not in followees, then add new empty Set // 初始化關注集合\n    → Add followeeId to followees[followerId] // 加入關注關係\n→ End // 關注操作結束\n\n→ Step: unfollow(followerId, followeeId) // 解除關注\n    → If followerId in followees\n        → Remove followeeId from followees[followerId] // 刪除關注關係\n→ End // 解除關注操作結束\n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\nimport heapq\nfrom collections import defaultdict\n\nclass Twitter:\n    def __init__(self):\n        self.timestamp = 0\n        self.tweets = defaultdict(list)     # userId -> list of (time, tweetId)\n        self.followees = defaultdict(set)   # userId -> set of followed userIds\n\n    def postTweet(self, userId: int, tweetId: int) -> None:\n        self.timestamp += 1\n        self.tweets[userId].append((self.timestamp, tweetId))\n        # 每個人自動關注自己，確保自己的推文能出現在自己的新聞訂閱中\n        self.followees[userId].add(userId)\n\n    def getNewsFeed(self, userId: int) -> list[int]:\n        res = []\n        if userId not in self.followees:\n            return res\n        heap = []  # max‑heap by timestamp\n        # 先把每個關注者最新的一條推文放進堆疊\n        for fid in self.followees[userId]:\n            user_tweets = self.tweets.get(fid)\n            if user_tweets:\n                idx = len(user_tweets) - 1\n                ts, tid = user_tweets[idx]\n                heapq.heappush(heap, (-ts, tid, fid, idx))\n        # 取出最多 10 條最新推文\n        while heap and len(res) < 10:\n            neg_ts, tid, fid, idx = heapq.heappop(heap)\n            res.append(tid)\n            if idx - 1 >= 0:\n                ts, prev_tid = self.tweets[fid][idx - 1]\n                heapq.heappush(heap, (-ts, prev_tid, fid, idx - 1))\n        return res\n\n    def follow(self, followerId: int, followeeId: int) -> None:\n        if followerId == followeeId:\n            return\n        self.followees[followerId].add(followeeId)\n\n    def unfollow(self, followerId: int, followeeId: int) -> None:\n        if followerId == followeeId:\n            return\n        self.followees[followerId].discard(followeeId)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Split the two JSON arrays\n    first_close = data.find(']')\n    first = json.loads(data[:first_close + 1])\n    second = json.loads(data[first_close + 2:])  # skip ], space\n    ops = first\n    args_list = second\n\n    results = []\n    twitter_obj = None\n\n    for op, args in zip(ops, args_list):\n        if op == \"Twitter\":\n            twitter_obj = Twitter()\n            results.append(None)\n        elif op == \"postTweet\":\n            twitter_obj.postTweet(args[0], args[1])\n            results.append(None)\n        elif op == \"getNewsFeed\":\n            results.append(twitter_obj.getNewsFeed(args[0]))\n        elif op == \"follow\":\n            twitter_obj.follow(args[0], args[1])\n            results.append(None)\n        elif op == \"unfollow\":\n            twitter_obj.unfollow(args[0], args[1])\n            results.append(None)\n\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"Twitter\", \"postTweet\", \"getNewsFeed\", \"follow\", \"postTweet\", \"getNewsFeed\", \"unfollow\", \"getNewsFeed\"], [[], [1, 5], [1], [1, 2], [2, 6], [1], [1, 2], [1]]",
          "expected_output": "[null, null, [5], null, null, [6, 5], null, [5]]",
          "success": true,
          "output": "[null, null, [5], null, null, [6, 5], null, [5]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode303.json",
    "problem_index_in_file": 0,
    "title": "Range Sum Query - Immutable",
    "description_snippet": "Given an integer array nums, handle multiple queries of the following type:\n\nCalculate the sum of th...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to explain algorithm: prefix sum array. So steps: initialization: compute prefix sum array; sumRange returns prefix[right+1] - prefix[left]. Use virtual code with Start, End, Decision maybe not needed. Just linear steps. Provide each line with arrow and comment. Probably include class definition etc. Use \"Step\" etc. Should be simple.\n\nLet's produce lines:\n\nStart // program start\n→ Step 1: Define class NumArray // declare class\n→ Step 2: Define property prefixSum as integer array // store prefix sums\n→ Step 3: Constructor NumArray(nums) // initialize\n→ Step 4: Initialize prefixSum[0] = 0 // prefix of empty\n→ Decision: For i from 0 to nums.length-1? // iterate\n    Yes → Step 5: prefixSum[i+1] = prefixSum[i] + nums[i] // compute cumulative\n    No  → // end loop\n→ End of constructor // finish init\n→ Step 6: Define method sumRange(left, right) // method signature\n→ Step 7: Return prefixSum[right+1] - prefixSum[left] // compute sum\nEnd // program end\n\nNeed to put comment after each line. Ensure format exactly: \"虛擬碼步驟 // 解釋\". Use arrow \"→\" for lines after Start maybe. The decision block: Indent and use Yes → etc. Let's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Define class NumArray // 建立 NumArray 類別  \n→ Step 2: Define property prefixSum as integer array // 用於存儲前綴和  \n→ Step 3: Constructor NumArray(nums) // 初始化時傳入原始陣列  \n→ Step 4: Set prefixSum[0] = 0 // 前綴和起始為 0  \n→ Decision: For i from 0 to nums.length-1? // 逐元素計算前綴和  \n  Yes → Step 5: Set prefixSum[i+1] = prefixSum[i] + nums[i] // 更新累積和  \n  No  → // 迴圈結束  \n→ End of constructor // 完成建構  \n→ Step 6: Define method sumRange(left, right) // 回傳指定區間總和  \n→ Step 7: Return prefixSum[right+1] - prefixSum[left] // 利用前綴和計算區間和  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport json\n\nclass NumArray:\n    def __init__(self, nums):\n        # 建立前綴和陣列，prefix_sums[i] 表示 nums[0:i] 的和\n        self.prefix_sums = [0]\n        for num in nums:\n            self.prefix_sums.append(self.prefix_sums[-1] + num)\n\n    def sumRange(self, left, right):\n        # 利用前綴和計算區間和：sum(nums[left:right+1]) = prefix[right+1] - prefix[left]\n        return self.prefix_sums[right + 1] - self.prefix_sums[left]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 將輸入包裝成元組以方便解析\n    ops, args = ast.literal_eval(f'({data})')\n\n    result = []\n    instance = None\n\n    for i, op in enumerate(ops):\n        if op == \"NumArray\":\n            # args[i] 是一個包含一個 list 的 list，例如 [[-2,0,3,-5,2,-1]]\n            instance = NumArray(args[i][0])\n            result.append(None)          # 對應 LeetCode 的 null\n        elif op == \"sumRange\":\n            left, right = args[i]\n            result.append(instance.sumRange(left, right))\n\n    # json.dumps 將 None 轉成 null，符合範例輸出格式\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"NumArray\", \"sumRange\", \"sumRange\", \"sumRange\"], [[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]",
          "expected_output": "[null, 1, -1, -3]",
          "success": true,
          "output": "[null, 1, -1, -3]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode80.json",
    "problem_index_in_file": 0,
    "title": "Remove Duplicates from Sorted Array II",
    "description_snippet": "Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such tha...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines step by step for the algorithm to remove duplicates allowing at most two copies. Use two pointers. Let's craft pseudocode.\n\nStart\nInitialize writeIndex=2 // because first two elements always allowed\nFor i from 2 to len-1\n    If nums[i] != nums[writeIndex-2] // ensure not third duplicate\n        nums[writeIndex] = nums[i]\n        writeIndex++\nEnd\nReturn writeIndex\n\nAlso handle case len <= 2 return len.\n\nWe need each line with arrow and explanation. Use Decision block. Provide start and end.\n\nLet's produce step lines. Ensure each line has virtual code then // explanation.\n\nWe need arrow for flow. Use → lines for sequential. Use Decision: for condition.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← length(nums) // 取得陣列長度  \n→ Decision: 如果 n ≤ 2? // 只要兩個或更少元素不需要處理  \n    Yes → Step 2: Return n // 返回原長度，結束  \n    No  → Step 3: writeIndex ← 2 // 第三個位置開始寫入  \n→ Step 4: i ← 2 // 從第三個元素開始掃描  \n→ Decision: i < n? // 是否還有元素可掃描？  \n    Yes → Step 5: nums[writeIndex] ← nums[i] // 假設可寫入  \n        → Decision: nums[i] == nums[writeIndex-2]? // 檢查是否為第三個相同值  \n            Yes → Step 6: // 這個元素是第三個重複項，跳過寫入  \n                → Step 7: i ← i + 1 // 移動到下一個元素  \n            No  → Step 8: writeIndex ← writeIndex + 1 // 允許寫入，移動寫指標  \n                → Step 9: i ← i + 1 // 移動到下一個元素  \n        No → Step 7: i ← i + 1 // 如果條件未滿足，直接往後掃描  \n    No → Step 10: Return writeIndex // 所有元素掃描完畢，返回有效長度  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def removeDuplicates(self, nums):\n        \"\"\"Remove duplicates in-place so each element appears at most twice.\"\"\"\n        n = len(nums)\n        if n <= 2:\n            return n\n        write = 2  # next position to write to\n        for i in range(2, n):\n            # If current element is not the same as the element two places before\n            # the write position, it is allowed (second or first occurrence).\n            if nums[i] != nums[write - 2]:\n                nums[write] = nums[i]\n                write += 1\n        return write\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Extract the list literal from input like 'nums = [1,1,1,2,2,3]'\n    match = re.search(r'\\[.*\\]', data, re.S)\n    if not match:\n        print(\"0, nums = []\")\n        return\n    list_str = match.group(0)\n    try:\n        nums = ast.literal_eval(list_str)\n    except Exception:\n        print(\"0, nums = []\")\n        return\n    if not isinstance(nums, list):\n        print(\"0, nums = []\")\n        return\n\n    sol = Solution()\n    k = sol.removeDuplicates(nums)\n\n    # Build the output representation\n    elements = [str(x) for x in nums[:k]] + ['_' for _ in range(len(nums) - k)]\n    output = f\"{k}, nums = [{','.join(elements)}]\"\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,1,1,2,2,3]",
          "expected_output": "5, nums = [1,1,2,2,3,_]",
          "success": true,
          "output": "5, nums = [1,1,2,2,3,_]"
        },
        {
          "example_index": 1,
          "input": "nums = [0,0,1,1,1,1,2,3,3]",
          "expected_output": "7, nums = [0,0,1,1,2,3,3,_,_]",
          "success": true,
          "output": "7, nums = [0,0,1,1,2,3,3,_,_]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode29.json",
    "problem_index_in_file": 0,
    "title": "Divide Two Integers",
    "description_snippet": "Given two integers dividend and divisor, divide two integers without using multiplication, division,...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step, with comments in Chinese. The logic: perform division via bit shifts and subtraction, handle overflow, sign. Provide steps like Start, Decision, etc. Use arrow notation. Provide each line with comment. No actual code. Should be virtual. Let's craft.\n\nWe'll produce algorithm:\n\n- Determine sign: positive if dividend and divisor same sign.\n- Convert to long for absolute values to avoid overflow.\n- While abs(dividend) >= abs(divisor): shift divisor left until greater, subtract, accumulate quotient.\n- Return sign * quotient with bounds.\n\nAlso handle special case: dividend == INT_MIN and divisor == -1 -> overflow.\n\nImplement steps with Start, End, Decision, etc.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 INT_MAX = 2^31 - 1, INT_MIN = -2^31 // 取 32 位整數上限與下限  \n→ Step 2: 若 dividend == INT_MIN 且 divisor == -1 → Step 3: 輸出 INT_MAX // 超過上限，直接返回最大值  \n→ Decision: 判斷 dividend 與 divisor 符號是否相同? // 確定結果正負  \n    Yes → Step 4: isPositive = true // 符號相同，結果為正  \n    No  → Step 4: isPositive = false // 符號不同，結果為負  \n→ Step 5: dividendAbs = abs(dividend) // 取得 dividend 的絕對值  \n→ Step 6: divisorAbs = abs(divisor) // 取得 divisor 的絕對值  \n→ Step 7: quotient = 0 // 初始化商  \n→ Step 8: tempDivisor = divisorAbs // 將除數複製至暫存變數  \n→ Step 9: shiftCount = 0 // 用於記錄左移位數  \n→ Decision: tempDivisor ≤ dividendAbs? // 判斷能否進行左移以逼近 dividend  \n    Yes → Step 10: tempDivisor <<= 1 // 左移一位（乘 2）  \n          → Step 11: shiftCount++ // 追蹤位數  \n          → Decision: tempDivisor ≤ dividendAbs? // 仍能左移？  \n              Yes → 進入同上  \n              No  → Step 12: tempDivisor >>= 1 // 回退至最後一次可行左移  \n                    → Step 13: shiftCount-- // 對應回退位數  \n                    → Step 14: dividendAbs -= tempDivisor // 從 dividend 中減去已經匹配的部分  \n                    → Step 15: quotient += 1 << shiftCount // 將對應位數加到商  \n                    → Step 16: tempDivisor = divisorAbs // 重置除數以便再次左移  \n                    → Step 17: shiftCount = 0 // 重置位數  \n                    → Decision: dividendAbs ≥ divisorAbs? // 是否還能繼續減去？  \n                        Yes → 回到 Step 8  \n                        No  → Step 18: If isPositive? // 檢查符號  \n                               Yes → Step 19: If quotient > INT_MAX? // 防止溢出  \n                                        Yes → Step 20: Output INT_MAX  \n                                        No  → Step 21: Output quotient  \n                               No  → Step 22: If quotient > INT_MAX? // 取負號時仍需檢查上限  \n                                        Yes → Step 23: Output -INT_MAX - 1 // INT_MIN  \n                                        No  → Step 24: Output -quotient  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def divide(self, dividend: int, divisor: int) -> int:\n        \"\"\"\n        Divide two integers without using multiplication, division, or modulo operators.\n        The division truncates toward zero and respects 32-bit signed integer limits.\n        \"\"\"\n        INT_MAX = 2**31 - 1\n        INT_MIN = -2**31\n\n        # Special overflow case: INT_MIN / -1 would exceed INT_MAX\n        if dividend == INT_MIN and divisor == -1:\n            return INT_MAX\n\n        # Determine the sign of the result\n        negative = (dividend < 0) != (divisor < 0)\n\n        # Work with absolute values to simplify the loop\n        a = abs(dividend)\n        b = abs(divisor)\n\n        quotient = 0\n\n        # Repeatedly subtract the largest shifted divisor\n        while a >= b:\n            temp = b\n            multiple = 1\n            # Shift the divisor left until it just fits into the current dividend\n            while a >= (temp << 1):\n                temp <<= 1\n                multiple <<= 1\n            # Subtract the found multiple and add to the quotient\n            a -= temp\n            quotient += multiple\n\n        # Apply the sign\n        if negative:\n            quotient = -quotient\n\n        # Clamp to 32-bit signed integer range\n        if quotient < INT_MIN:\n            return INT_MIN\n        if quotient > INT_MAX:\n            return INT_MAX\n        return quotient\n\n\ndef main() -> None:\n    \"\"\"\n    Read input of the form:\n        dividend = <int>, divisor = <int>\n    Compute the division result and print it.\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Extract all integers from the input string\n    numbers = list(map(int, re.findall(r'-?\\d+', data)))\n    if len(numbers) != 2:\n        raise ValueError(\"Input must contain exactly two integers: dividend and divisor.\")\n\n    dividend, divisor = numbers\n    result = Solution().divide(dividend, divisor)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "dividend = 10, divisor = 3",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "dividend = 7, divisor = -3",
          "expected_output": "-2",
          "success": true,
          "output": "-2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode290.json",
    "problem_index_in_file": 0,
    "title": "Word Pattern",
    "description_snippet": "Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match,...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a step-by-step virtual code for solving the \"Word Pattern\" problem. Provide each line with the format: \"虛擬碼步驟 // 解釋\". Use arrows etc.\n\nWe need to outline algorithm: Use two dictionaries: patternToWord, wordToPattern. Split string s into words. Check lengths. Iterate. For each pair, verify mapping consistency. If all pass, return true. else false. End.\n\nWe must produce virtual code lines. Use Start, End, Decision, Step, etc.\n\nMake sure each line contains \"虛擬碼步驟\" and comment.\n\nLet's produce lines like:\n\nStart // 程式開始執行\n→ Step 1: Split s by space into words list // 將 s 拆分成單詞列表\n→ Decision: 如果 pattern.length != words.length? // 檢查 pattern 與 words 數量是否一致\n    Yes → Step 2: Return false // 數量不符，直接返回 false\n    No  → Step 3: Initialize map patternToWord = {} // 建立 pattern 到 word 的映射\n    No  → Step 4: Initialize map wordToPattern = {} // 建立 word 到 pattern 的映射\n→ Decision: For each index i from 0 to pattern.length-1? // 逐個遍歷 pattern 和 words\n    Yes → Step 5: curPattern = pattern[i] // 取當前 pattern 字母\n    Yes → Step 6: curWord = words[i] // 取當前 word\n    Yes → Decision: 是否已存在 patternToWord[curPattern]? // 檢查 pattern 是否已映射\n        Yes → Step 7: if patternToWord[curPattern] != curWord? // 若映射的 word 不同\n            Yes → Step 8: Return false // 不匹配，返回 false\n        No  → Decision: 是否已存在 wordToPattern[curWord]? // pattern 未映射，檢查 word 是否已映射\n            Yes → Step 9: if wordToPattern[curWord] != curPattern? // 若映射的 pattern 不同\n                Yes → Step 10: Return false // 不匹配，返回 false\n            No  → Step 11: patternToWord[curPattern] = curWord // 建立 pattern->word 映射\n            No  → Step 12: wordToPattern[curWord] = curPattern // 建立 word->pattern 映射\n→ Step 13: Return true // 所有檢查通過，返回 true\nEnd // 程式執行結束\n\nBut we need each line with \"虛擬碼步驟\" (some Chinese word). Let's keep as \"Step X: ...\" etc. Use arrow \"→\". For Decision lines we should indent children with spaces. Use \"Yes →\" etc.\n\nWe must not output actual code. Use just virtual steps.\n\nLet's format each line as \"虛擬碼步驟 // 解釋\" exactly. So start with \"Start\". Then \"→ Step 1: ...\". Indent decisions: \"Decision: ...\" and children \"Yes → ...\" and \"No → ...\".\n\nAlso we need to show for loop? Might represent as \"Decision: 是否已遍歷完所有字符?\" but easier: \"Decision: for i in 0..pattern.length-1?\".\n\nBut to keep simple, use \"Decision: 遍歷每個索引 i 進行?\".\n\nOk produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 將 s 用空格拆分成 words 列表 // 將輸入字串切割成單詞  \n→ Decision: pattern.length 與 words.length 是否相等? // 檢查長度是否一致  \n Yes → Step 2: 返回 false // 長度不一致直接失敗  \n No → Step 3: 初始化 patternToWord 映射表 // 建立 pattern 到 word 的對應  \n No → Step 4: 初始化 wordToPattern 映射表 // 建立 word 到 pattern 的對應  \n→ Decision: 逐個索引 i 從 0 到 pattern.length-1? // 開始逐位比對  \n Yes → Step 5: curPattern = pattern[i] // 取目前的 pattern 字母  \n Yes → Step 6: curWord = words[i] // 取目前的單詞  \n Yes → Decision: curPattern 是否已在 patternToWord? // pattern 是否已有映射  \n  Yes → Step 7: 若 patternToWord[curPattern] != curWord? // 映射的 word 不同  \n   Yes → Step 8: 返回 false // 失配，直接失敗  \n  No → Decision: curWord 是否已在 wordToPattern? // pattern 未映射，檢查 word 是否已有映射  \n   Yes → Step 9: 若 wordToPattern[curWord] != curPattern? // 映射的 pattern 不同  \n    Yes → Step 10: 返回 false // 失配，直接失敗  \n   No → Step 11: patternToWord[curPattern] = curWord // 建立 pattern→word 映射  \n   No → Step 12: wordToPattern[curWord] = curPattern // 建立 word→pattern 映射  \n→ Step 13: 返回 true // 所有檢查通過，模式匹配成功  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def wordPattern(self, pattern: str, s: str) -> bool:\n        words = s.split()\n        if len(pattern) != len(words):\n            return False\n\n        char_to_word = {}\n        word_to_char = {}\n\n        for c, w in zip(pattern, words):\n            if c in char_to_word:\n                if char_to_word[c] != w:\n                    return False\n            else:\n                char_to_word[c] = w\n\n            if w in word_to_char:\n                if word_to_char[w] != c:\n                    return False\n            else:\n                word_to_char[w] = c\n\n        return True\n\ndef parse_input(data: str):\n    # Try to extract pattern=\"...\" and s=\"...\"\n    pattern_match = re.search(r'pattern\\s*=\\s*\"([^\"]+)\"', data)\n    s_match = re.search(r's\\s*=\\s*\"([^\"]+)\"', data)\n    if pattern_match and s_match:\n        return pattern_match.group(1), s_match.group(1)\n\n    # Fallback: two lines input\n    lines = data.strip().splitlines()\n    if len(lines) >= 2:\n        return lines[0].strip(), lines[1].strip()\n\n    # Fallback: first token is pattern, rest is s\n    parts = data.strip().split(None, 1)\n    if len(parts) == 2:\n        return parts[0], parts[1]\n\n    # Unable to parse\n    return '', ''\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    pattern, s = parse_input(raw_input)\n    result = Solution().wordPattern(pattern, s)\n    print(str(result).lower())",
      "validation_results": [
        {
          "example_index": 0,
          "input": "pattern = \"abba\", s = \"dog cat cat dog\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "pattern = \"abba\", s = \"dog cat cat fish\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "pattern = \"aaaa\", s = \"dog cat cat dog\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode400.json",
    "problem_index_in_file": 0,
    "title": "Nth Digit",
    "description_snippet": "Given an integer n, return the n^th digit of the infinite integer sequence [1, 2, 3, 4, 5, 6, 7, 8, ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps that given integer n returns nth digit of infinite integer sequence [1,2,3,...]. Need to explain each line. Use virtual code arrows and decision etc. Each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision. Provide step-by-step.\n\nWe need algorithm: find which number contains nth digit. Approach: iterate lengths: 1-digit numbers 1-9, 2-digit 10-99, etc. Subtract count * digits until find. Then compute the exact number and digit. Steps:\n\nStart\n→ Input n\n→ Set remaining = n\n→ Set digitLen = 1\n→ Set startNum = 1\n→ Decision: While remaining > digitLen * (10^digitLen - 10^(digitLen-1))? but easier: while remaining > count*digitLen where count = 9*10^(digitLen-1). So Decision: If remaining > count*digitLen? else break. \nIn each iteration: subtract count*digitLen from remaining, increment digitLen, startNum = 10^(digitLen-1). Continue.\nAfter loop: Determine index = remaining -1 (0-based). Number = startNum + index / digitLen. DigitIndex = index % digitLen. Extract digit by converting to string or division. Output digit.\n\nWe'll produce virtual steps accordingly.\n\nLet's write each line with explanation.\n\nAlso include End.\n\nLet's create steps:\n\nStart // 程式開始執行\n→ Step 1: 輸入整數 n // 取得使用者想要的第 n 位數字\n→ Step 2: 設定 remaining ← n // 仍未定位到的數字位數\n→ Step 3: 設定 digitLen ← 1 // 當前考慮的數字位數\n→ Step 4: 設定 startNum ← 1 // 目前位數段的第一個數字\n→ Decision: 是否還有足夠位數的數字在這個位數段? // 檢查剩餘位數是否超過此段可提供的總位數\n    Yes → Step 5: 計算 count ← 9 × 10^(digitLen-1) // 本段數字個數\n        → Step 6: remaining ← remaining – count × digitLen // 把本段的所有位數扣除\n        → Step 7: digitLen ← digitLen + 1 // 進入下一位數段\n        → Step 8: startNum ← 10^(digitLen-1) // 更新本段起始數字\n        → Decision: 重複決策 // 重新判斷是否仍需要跳過下一段\n    No  → Step 9: // 目前已定位到正確的位數段\n→ Step 10: index ← remaining – 1 // 0 為起始位置\n→ Step 11: number ← startNum + floor(index / digitLen) // 找到包含目標位的數字\n→ Step 12: digitIdx ← index mod digitLen // 目標位在該數字中的位置\n→ Step 13: digit ← 數字 number 轉成字串後取第 digitIdx 位 // 取得目標數字\n→ Step 14: 輸出 digit // 回傳結果\nEnd // 程式執行結束\n\nWe need to be consistent with virtual code syntax. Use \"Step\" label maybe. Also using arrows. Example: \"→ Step 1: ...\" etc.\n\nWe also need decision syntax: \"Decision:\" lines.\n\nLet's format each line: \"→ Step X: ...\" with comment. For decision we can write:\n\n→ Decision: if remaining > count * digitLen? // comment\n\nBut we need to include Yes →, No → lines.\n\nLet's rewrite.\n\nStart // 程式開始執行\n→ Step 1: 輸入 n // 取得使用者想要的第 n 位數字\n→ Step 2: 設定 remaining ← n // 剩餘未定位的位數\n→ Step 3: 設定 digitLen ← 1 // 當前處理的數字位數\n→ Step 4: 設定 startNum ← 1 // 本段第一個數字\n→ Decision: remaining > 9 × 10^(digitLen-1) × digitLen? // 檢查是否要跳過本段\n    Yes → Step 5: 計算 count ← 9 × 10^(digitLen-1) // 本段數字個數\n        → Step 6: remaining ← remaining – count × digitLen // 減去本段所有位數\n        → Step 7: digitLen ← digitLen + 1 // 進入下一位數段\n        → Step 8: startNum ← 10^(digitLen-1) // 更新起始數字\n        → Decision: remaining > 9 × 10^(digitLen-1) × digitLen? // 再次判斷是否還需要跳過\n    No  → Step 9: // 找到目標位數段\n→ Step 10: index ← remaining – 1 // 0 基位計算\n→ Step 11: number ← startNum + floor(index / digitLen) // 找到包含目標位的數字\n→ Step 12: digitIdx ← index mod digitLen // 目標位在數字中的位置\n→ Step 13: digit ← string(number)[digitIdx] // 取得該位數字\n→ Step 14: 輸出 digit // 回傳結果\nEnd // 程式執行結束\n\nBut the decision arrow maybe should indent. Use indentation lines with spaces.\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 輸入 n // 取得使用者想要的第 n 位數字\n→ Step 2: 設定 remaining ← n // 剩餘未定位的位數\n→ Step 3: 設定 digitLen ← 1 // 當前處理的數字位數\n→ Step 4: 設定 startNum ← 1 // 本段第一個數字\n→ Decision: remaining > 9 × 10^(digitLen-1) × digitLen? // 檢查是否要跳過本段\n    Yes → Step 5: 計算 count ← 9 × 10^(digitLen-1) // 本段數字個數\n        → Step 6: remaining ← remaining – count × digitLen // 減去本段所有位數\n        → Step 7: digitLen ← digitLen + 1 // 進入下一位數段\n        → Step 8: startNum ← 10^(digitLen-1) // 更新起始數字\n        → Decision: remaining > 9 × 10^(digitLen-1) × digitLen? // 再次判斷是否還需要跳過\n    No  → Step 9: // 找到目標位數段\n→ Step 10: index ← remaining – 1 // 0 基位計算\n→ Step 11: number ← startNum + floor(index / digitLen) // 找到包含目標位的數字\n→ Step 12: digitIdx ← index mod digitLen // 目標位在數字中的位置\n→ Step 13: digit ← string(number)[digitIdx] // 取得該位數字\n→ Step 14: 輸出 digit // 回傳結果\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\nimport re\n\ndef find_nth_digit(n: int) -> int:\n    \"\"\"Return the n-th digit in the infinite sequence 1,2,3,4,...\"\"\"\n    length = 1          # current digit length\n    count = 9           # numbers with this digit length\n    start = 1           # first number of this digit length\n\n    # Skip whole blocks of numbers until the target falls into one block\n    while n > length * count:\n        n -= length * count\n        length += 1\n        count *= 10\n        start *= 10\n\n    # Determine the exact number that contains the n-th digit\n    start += (n - 1) // length\n    s = str(start)\n    return int(s[(n - 1) % length])\n\ndef main() -> None:\n    data = sys.stdin.read()\n    # Extract the first integer found in the input (handles formats like \"n = 3\")\n    match = re.search(r'-?\\d+', data)\n    if not match:\n        return\n    n = int(match.group())\n    result = find_nth_digit(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 3",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "n = 11",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode504.json",
    "problem_index_in_file": 0,
    "title": "Base 7",
    "description_snippet": "Given an integer num, return a string of its base 7 representation....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations. The requirement: \"Use virtual code arrow →, Yes →, No → and structure Start, End, Decision:\". Each line: \"虛擬碼步驟 [space] // 解釋/說明\". Use Chinese.\n\nTask: Given an integer num, return a string of its base 7 representation.\n\nSo we need to outline algorithm: handle zero, handle negative sign, convert positive number to base7 via division by 7, collecting digits, reverse.\n\nSo we produce steps: Start, Input num, Decision: if num==0? If yes return \"0\". Else Decision: if num<0? If yes, set negative flag, num = -num. Then loop: While num>0: digit = num % 7, push to array, num = num / 7 integer. Then reverse array, build string. If negative flag, prepend '-'. Return string. End.\n\nWe output each line as virtual code with arrow. Ensure each line has explanation comment. Use proper indentation maybe but just lines. We can indent inside decisions.\n\nExample:\n\nStart // 程式開始執行\n→ Step 1: 取得輸入整數 num // 從使用者或呼叫取得整數\n→ Decision: 如果 num 等於 0? // 檢查是否為 0\n    Yes → Step 2: 回傳字串 \"0\" // 直接回傳 0 的 base7 表示\n    No  → Decision: 如果 num 小於 0? // 判斷是否為負數\n        Yes → Step 3: 設定 flag negative = True // 記錄負號\n            → Step 4: 取 num = -num // 轉成正整數\n            → Step 5: 設定空陣列 digits // 用來存放每一位\n        No  → Step 3: 設定 flag negative = False // 正數\n            → Step 4: 設定空陣列 digits\n→ Step 6: While num > 0: // 轉換至 base7\n        → Step 6a: digit = num % 7\n        → Step 6b: digits.append(digit)\n        → Step 6c: num = num // 7\n→ Step 7: 將 digits 逆序 // 取出正確順序\n→ Step 8: 將 digits 轉成字串 result // 連結數字\n→ Decision: 如果 negative 為 True? // 若原本為負數\n    Yes → Step 9: result = \"-\" + result // 加上負號\n    No  → // 無需變動\n→ Step 10: 回傳 result // 最終 base7 字串\nEnd // 程式執行結束\n\nBut need each line to be \"虛擬碼步驟 // 解釋\" So each line is one instruction. So we can't split into many substeps in same line. However we can have multiple lines: Each line should be step or decision. The example had Step 1, Decision, Yes, No, etc. So we can break each substep. Use indent maybe, but each line independent.\n\nNeed to maintain arrow direction for decisions.\n\nLet's format accordingly:\n\nStart // 程式開始執行\n→ Step 1: 讀取整數 num // 從使用者或函式取得輸入\n→ Decision: num == 0? // 判斷輸入是否為 0\n    Yes → Step 2: 回傳 \"0\" // 0 的 base7 仍為 \"0\"\n    No  → Decision: num < 0? // 判斷是否為負數\n        Yes → Step 3: 設定 flag negative = True // 記錄負號\n            → Step 4: num = -num // 轉為正數\n            → Step 5: 建立空陣列 digits // 用於存放每一位\n        No  → Step 3: 設定 flag negative = False // 正數\n            → Step 4: 建立空陣列 digits\n→ Step 6: 重複 while num > 0: // 轉換為 base7\n    → Step 6a: digit = num % 7\n    → Step 6b: digits.append(digit)\n    → Step 6c: num = num // 7\n→ Step 7: 逆轉陣列 digits // 使最高位在前\n→ Step 8: 將 digits 轉為字串 result // 將每個數字轉為字元並連結\n→ Decision: flag negative? // 判斷是否需要負號\n    Yes → Step 9: result = \"-\" + result // 加上負號\n    No  → // 不變\n→ Step 10: 回傳 result // 回傳最終 base7 字串\nEnd // 程式執行結束\n\nBut we need each line separate. So maybe we break Step 6 into three lines. But Step 6 is a while loop with body of three lines. We can represent as:\n\n→ Step 6: while num > 0: // 轉換為 base7\n    → Step 6a: digit = num % 7\n    → Step 6b: digits.append(digit)\n    → Step 6c: num = num // 7\n\nBut each line must start with \"→\" arrow or Decision etc. For Step 6a, we also use \"→\". But the indentation might not be necessary but it's clearer.\n\nMake sure each line is \"虛擬碼步驟 // 解釋\". Example: \"→ Step 6a: digit = num % 7 // 計算當前最低位的值\".\n\nAlso need to note that virtual code may use arrows for decisions. For loops, we can just use arrow. We can also use \"Loop\" but not specified. Use \"Step\" and \"Decision\".\n\nWe should produce output lines in order.\n\nOk produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取整數 num // 從使用者或函式取得輸入  \n→ Decision: num == 0? // 判斷輸入是否為 0  \n Yes → Step 2: 回傳 \"0\" // 0 的 base7 仍為 \"0\"  \n No → Decision: num < 0? // 判斷是否為負數  \n  Yes → Step 3: 設定 flag negative = True // 記錄負號  \n   → Step 4: num = -num // 轉為正數  \n   → Step 5: 建立空陣列 digits // 用於存放每一位  \n  No  → Step 3: 設定 flag negative = False // 正數  \n   → Step 4: 建立空陣列 digits  \n→ Step 6: while num > 0: // 轉換為 base7  \n  → Step 6a: digit = num % 7 // 取得最低位的數字  \n  → Step 6b: digits.append(digit) // 存進陣列  \n  → Step 6c: num = num // 7 // 除以 7 進行下一輪  \n→ Step 7: 逆轉陣列 digits // 使最高位在前  \n→ Step 8: 將 digits 轉為字串 result // 將每個數字轉成字元並連結  \n→ Decision: flag negative? // 判斷是否需要負號  \n Yes → Step 9: result = \"-\" + result // 加上負號  \n No  → // 無需變動  \n→ Step 10: 回傳 result // 回傳最終 base7 字串  \nEnd // 程式執行結束",
      "generated_code": "class Solution:\n    def convertToBase7(self, num: int) -> str:\n        # 處理 0 的特殊情況\n        if num == 0:\n            return \"0\"\n        # 判斷是否為負數，並取絕對值進行轉換\n        neg = num < 0\n        num = abs(num)\n        digits = []\n        # 逐位取模並存入陣列\n        while num > 0:\n            digits.append(str(num % 7))\n            num //= 7\n        # 若原來為負數，將負號加入\n        if neg:\n            digits.append('-')\n        # 逆序組合成最終字串\n        return ''.join(digits[::-1])\n\nif __name__ == \"__main__\":\n    import sys\n    data = sys.stdin.read().strip()\n    if data:\n        try:\n            num = int(data)\n        except ValueError:\n            # 若輸入不是合法整數，直接結束\n            sys.exit(1)\n        sol = Solution()\n        result = sol.convertToBase7(num)\n        print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "100",
          "expected_output": "\"202\"",
          "success": true,
          "output": "202"
        },
        {
          "example_index": 1,
          "input": "-7",
          "expected_output": "\"-10\"",
          "success": true,
          "output": "-10"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode460.json",
    "problem_index_in_file": 0,
    "title": "LFU Cache",
    "description_snippet": "Design and implement a data structure for a Least Frequently Used (LFU) cache.\n\nImplement the LFUCac...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for implementing LFUCache in O(1). Provide virtual code steps line by line with explanation. Use virtual code arrows etc.\n\nWe must not output actual code. Just pseudocode with steps and explanation.\n\nWe need to structure: Start, steps: initialize capacity, minFreq, hash maps, freq lists, etc. For get and put logic.\n\nWe must produce line by line. Use decision arrows.\n\nLet's produce a high-level algorithm:\n\nData structures: key to node map, freq to doubly linked list of nodes, minFreq variable.\n\nNode contains key, value, freq.\n\nOperations: get(key): if not exist return -1; else update freq: remove from old list, increment freq, add to new list; if old list empty and freq==minFreq, increment minFreq; return value.\n\nput(key,value): if capacity==0 return; if key exists: update value, then call get to update freq. else if cache size==capacity: evict node from minFreq list's head (LRU). Remove from key map. Then create new node freq=1, add to freq list 1, set minFreq=1, add to key map.\n\nNeed O(1). Use hashmap for freq list head/tail.\n\nWe produce steps accordingly.\n\nWe'll produce steps:\n\nStart\n\n→ Initialize capacity, keyMap, freqMap, minFreq\n\n→ Decision: capacity <=0? → End with error or ignore\n\nDefine Node structure (key,value,freq)\n\nDefine functions: addNode, removeNode, etc.\n\nBut need to produce step-by-step for get and put. So produce separate sections.\n\nMaybe separate pseudo code for class initialization, get, put.\n\nLet's produce virtual code steps as sequence of steps, maybe with sections:\n\nStart\n\n→ Initialize LFUCache with capacity\n\n→ Function get(key)\n\n→ Function put(key,value)\n\nEnd\n\nBut each function must be detailed.\n\nWe need to use arrow lines.\n\nWe can use nested decision arrows.\n\nOk let's write.\n\nBe careful to include explanation after //.\n\nAlso maintain O(1) average time complexity explanation not needed.\n\nWe'll produce lines like:\n\nStart // 程式開始執行\n\n→ Step 1: 初始化 LFUCache(capacity) // 建立容量、最小頻率、映射表\n\n...\n\nLet's produce.\n\nWe'll include explanation in Chinese.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n\n→ Step 1: 建立容量變數 capacity // 用來限制快取大小\n→ Step 2: 建立 keyMap : Map<key, Node> // 存放 key 到 Node 的映射\n→ Step 3: 建立 freqMap : Map<freq, DoubleLinkedList> // 存放頻率到包含該頻率所有 Node 的雙向鏈表\n→ Step 4: 設定 minFreq = 0 // 目前最小使用頻率\n→ Step 5: 建立 Node 結構 (key, value, freq) // 每個快取項目\n\n// -------------------- Get --------------------\nStart get(key) // 開始執行 get 方法\n→ Decision: key 在 keyMap? // 檢查 key 是否存在\n    Yes → Step 6: node = keyMap[key] // 取得對應 Node\n    No  → Step 7: Return -1 // 不存在，直接回傳 -1\n→ Step 8: freq = node.freq // 取得舊頻率\n→ Step 9: oldList = freqMap[freq] // 取得舊頻率的鏈表\n→ Step 10: oldList.remove(node) // 從舊頻率列表移除 Node\n→ Decision: oldList.isEmpty()? // 檢查舊頻率列表是否空\n    Yes → Step 11: 若 freq == minFreq，則 minFreq += 1 // 更新最小頻率\n→ Step 12: node.freq += 1 // 頻率加 1\n→ Step 13: newList = freqMap.getOrCreate(node.freq) // 取得或建立新頻率列表\n→ Step 14: newList.append(node) // 將 Node 加入新頻率列表\n→ Step 15: Return node.value // 回傳值\nEnd get // get 方法結束\n\n// -------------------- Put --------------------\nStart put(key, value) // 開始執行 put 方法\n→ Decision: capacity == 0? // 檢查容量是否為零\n    Yes → End put // 無法存放，直接結束\n→ Decision: key 在 keyMap? // 檢查 key 是否已存在\n    Yes → Step 16: node = keyMap[key] // 取得已存在的 Node\n    No  → Step 17: 若 keyMap.size() == capacity，則 // 快取已滿\n        → Step 18: minList = freqMap[minFreq] // 取得最小頻率的列表\n        → Step 19: evictNode = minList.popHead() // 移除 LRU Node\n        → Step 20: keyMap.remove(evictNode.key) // 刪除映射\n    → Step 21: node = new Node(key, value, 1) // 新建 Node，頻率為 1\n    → Step 22: keyMap[key] = node // 新增映射\n    → Step 23: minFreq = 1 // 新 Node 的頻率為 1，更新最小頻率\n    → Step 24: freqList = freqMap.getOrCreate(1) // 取得或建立頻率為 1 的列表\n    → Step 25: freqList.append(node) // 加入列表\n→ Decision: key 之前存在? // 如果已存在則需更新值\n    Yes → Step 26: node.value = value // 更新值\n    No  → // 已於 Step 21-25 處理\n→ Step 27: // 若 key 已存在，則需要像 get 那樣提升頻率\n    Yes → \n        → Step 28: freq = node.freq // 取得舊頻率\n        → Step 29: oldList = freqMap[freq] // 取得舊頻率列表\n        → Step 30: oldList.remove(node) // 移除\n        → Decision: oldList.isEmpty()? // 是否為 minFreq\n            Yes → Step 31: 若 freq == minFreq，則 minFreq += 1\n        → Step 32: node.freq += 1 // 提升頻率\n        → Step 33: newList = freqMap.getOrCreate(node.freq) // 取得新頻率列表\n        → Step 34: newList.append(node) // 加入新列表\n→ End put // put 方法結束\n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict, OrderedDict\n\nclass LFUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.min_freq = 0\n        self.key_to_val_freq = {}          # key -> (value, freq)\n        self.freq_to_keys = defaultdict(OrderedDict)  # freq -> OrderedDict of keys\n\n    def _update(self, key: int):\n        \"\"\"Increase frequency of key by 1.\"\"\"\n        value, freq = self.key_to_val_freq[key]\n        # Remove key from current freq list\n        del self.freq_to_keys[freq][key]\n        if not self.freq_to_keys[freq]:\n            del self.freq_to_keys[freq]\n            if self.min_freq == freq:\n                self.min_freq += 1\n        # Add key to next freq list\n        self.freq_to_keys[freq + 1][key] = None\n        self.key_to_val_freq[key] = (value, freq + 1)\n\n    def get(self, key: int) -> int:\n        if key not in self.key_to_val_freq:\n            return -1\n        self._update(key)\n        return self.key_to_val_freq[key][0]\n\n    def put(self, key: int, value: int) -> None:\n        if self.capacity == 0:\n            return\n        if key in self.key_to_val_freq:\n            # Update value and frequency\n            self.key_to_val_freq[key] = (value, self.key_to_val_freq[key][1])\n            self._update(key)\n            return\n        if len(self.key_to_val_freq) >= self.capacity:\n            # Evict least frequently used key (LRU within that freq)\n            evict_key, _ = self.freq_to_keys[self.min_freq].popitem(last=False)\n            del self.key_to_val_freq[evict_key]\n            if not self.freq_to_keys[self.min_freq]:\n                del self.freq_to_keys[self.min_freq]\n        # Insert new key\n        self.key_to_val_freq[key] = (value, 1)\n        self.freq_to_keys[1][key] = None\n        self.min_freq = 1\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # Parse input like: '[\"LFUCache\",\"put\",...],[[2],[1,1],...]'\n    ops, args = ast.literal_eval(f'({data})')\n    results = []\n    cache = None\n    for op, arg in zip(ops, args):\n        if op == \"LFUCache\":\n            cache = LFUCache(arg[0])\n            results.append(None)\n        elif op == \"put\":\n            cache.put(arg[0], arg[1])\n            results.append(None)\n        elif op == \"get\":\n            val = cache.get(arg[0])\n            results.append(val)\n    # Format output like LeetCode: [null, null, 1, ...]\n    output = '[' + ', '.join('null' if r is None else str(r) for r in results) + ']'\n    print(output)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"LFUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"get\", \"put\", \"get\", \"get\", \"get\"], [[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]",
          "expected_output": "[null, null, null, 1, null, -1, 3, null, -1, 3, 4]",
          "success": true,
          "output": "[null, null, null, 1, null, -1, 3, null, -1, 3, 4]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode241.json",
    "problem_index_in_file": 0,
    "title": "Different Ways to Add Parentheses",
    "description_snippet": "Given a string expression of numbers and operators, return all possible results from computing all t...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to generate pseudocode for algorithm: given string expression of numbers and operators (+,-,*), return all possible results from different parenthesizations. This is classic LeetCode 241. Use divide and conquer / recursion with memoization. We'll produce step-by-step pseudocode lines.\n\nWe'll create Start, parse input expression string, define recursive function diffWays(index start, end) that returns list of results. Use memoization dict. For each operator in substring, split left and right, get results recursively, combine. If no operator, parse number. Return results. Then call with full string.\n\nWe must output line-by-line pseudocode with comments. Use \"→\" arrow. Also use Decision: etc.\n\nLet's design.\n\nStart // Start program\n→ Input: expression // Receive string expression\n→ Step 1: Define memo dict // Cache results for substrings\n→ Step 2: Define recursive function diffWays(startIdx, endIdx) // compute results for substring\n    → Decision: startIdx > endIdx? // invalid substring\n        No → continue\n    → Decision: substring contains no operator? // all digits\n        Yes → Step 3: Parse number, return [number] // single result\n        No → Step 4: Initialize results list // to collect combinations\n            → Loop i from startIdx to endIdx\n                → Decision: char at i is operator? // '+', '-', '*'\n                    Yes → Step 5: left = diffWays(startIdx, i-1) // left part\n                            Step 6: right = diffWays(i+1, endIdx) // right part\n                            → Loop l in left\n                                → Loop r in right\n                                    → Step 7: compute l op r\n                                    → Step 8: Append to results\n                No → continue loop\n            → Return results\n→ Step 9: Call diffWays(0, length-1) // compute all results\n→ Step 10: Return list from step9\nEnd // Program finished\n\nWe must use \"→\" arrow for each step. Ensure each line includes explanation comment after //.\n\nAlso need decision lines with Yes→ and No→ etc.\n\nLet's format.\n\nWe'll produce lines like:\n\nStart // 程式開始執行\n→ Input: expression // 取得輸入字串\n→ Step 1: Define memo = {} // 用於快取子表達式結果\n\nDefine diffWays function: we need to include within step? We'll show nested steps with indentation maybe.\n\nWe need to keep each line with arrow and comment. Use \"Decision:\" for branching.\n\nLet's craft lines:\n\nStart // 程式開始執行\n→ Input: expression // 取得輸入字串\n→ Step 1: Define memo = {} // 快取已計算的子表達式結果\n\n→ Function diffWays(start, end) // 重新呼叫自分以計算子表達式\n    → Decision: start > end? // 子表達式無效\n        Yes → Return [] // 返空結果\n        No →\n    → Decision: substring [start:end+1] contains no operator? // 只剩數字\n        Yes →\n            → Step 2: num = int(substring) // 轉成整數\n            → Return [num] // 直接回傳\n        No →\n            → Step 3: results = [] // 儲存所有計算結果\n            → Loop i from start to end\n                → Decision: expression[i] is operator? // '+', '-', '*'\n                    Yes →\n                        → left = diffWays(start, i-1) // 計算左半部\n                        → right = diffWays(i+1, end) // 計算右半部\n                        → Loop l in left\n                            → Loop r in right\n                                → Step 4: if operator '+': val = l + r\n                                    → Step 5: else if '-': val = l - r\n                                    → Step 6: else '*': val = l * r\n                                → Append val to results\n                    No →\n            → Return results\n\n→ Step 7: finalResults = diffWays(0, len(expression)-1) // 計算整個表達式\n→ Return finalResults // 將所有可能結果回傳\nEnd // 程式執行結束\n\nBut we need each line in single line with arrow. For nested lines, we can prefix arrow, maybe use indentation? In example they used \"→ Decision:\" with indented sub-lines. We'll replicate that style.\n\nThus each line must be like:\n\nStart // 程式開始執行\n→ Input: expression // 取得輸入字串\n→ Step 1: Define memo = {} // 快取已計算的子表達式結果\n\n→ Function diffWays(start, end) // 計算子表達式的所有結果\n    → Decision: start > end? // 子表達式無效\n        Yes → Return [] // 返空結果\n        No →\n    → Decision: substring(start, end) contains no operator? // 只剩數字\n        Yes →\n            → Step 2: num = int(substring) // 轉成整數\n            → Return [num] // 直接回傳\n        No →\n            → Step 3: results = [] // 儲存所有計算結果\n            → Loop i = start to end\n                → Decision: expression[i] is operator? // '+', '-', '*'\n                    Yes →\n                        → left = diffWays(start, i-1) // 計算左半部\n                        → right = diffWays(i+1, end) // 計算右半部\n                        → Loop l in left\n                            → Loop r in right\n                                → Step 4: if expression[i] == '+': val = l + r\n                                    → Step 5: else if expression[i] == '-': val = l - r\n                                    → Step 6: else: val = l * r\n                                → Append val to results\n                    No →\n            → Return results\n\nBut must ensure each line has arrow and comment. The nested lines might need multiple arrows. The example shows each nested line still starts with arrow, e.g., \"Yes → Step 2: ...\". So we can replicate that.\n\nThus we need to produce a list of lines:\n\n1. Start // 程式開始執行\n2. → Input: expression // 取得輸入字串\n3. → Step 1: Define memo = {} // 快取已計算的子表達式結果\n\n4. → Function diffWays(start, end) // 計算子表達式的所有結果\n5.     → Decision: start > end? // 子表達式無效\n6.         Yes → Return [] // 回傳空結果\n7.         No →\n8.     → Decision: substring(start, end) contains no operator? // 只剩數字\n9.         Yes →\n10.             → Step 2: num = int(substring) // 轉成整數\n11.             → Return [num] // 回傳單一結果\n12.         No →\n13.             → Step 3: results = [] // 儲存所有計算結果\n14.             → Loop i = start to end\n15.                 → Decision: expression[i] is operator? // '+', '-', '*'\n16.                     Yes →\n17.                         → left = diffWays(start, i-1) // 計算左半部\n18.                         → right = diffWays(i+1, end) // 計算右半部\n19.                         → Loop l in left\n20.                             → Loop r in right\n21.                                 → Step 4: if expression[i] == '+': val = l + r\n22.                                 → Step 5: else if expression[i] == '-': val = l - r\n23.                                 → Step 6: else: val = l * r\n24.                                 → Append val to results\n25.                     No →\n26.             → Return results\n\n27. → Step 7: finalResults = diffWays(0, len(expression)-1) // 計算整個表達式\n28. → Return finalResults // 將所有可能結果回傳\n29. End // 程式執行結束\n\nHowever each line must include the arrow only once. For nested lines we need to keep arrow indentation. Example shows:\n\n→ Decision: ... \n    Yes → ...\n    No  → ...\n\nSo indent accordingly. We'll use same pattern. So we need to include indentation spaces before \"Yes →\". The example uses 4 spaces for indentation? They used 4 spaces before \"Yes →\". We'll follow.\n\nThus lines 5-7: \"→ Decision:\" line then sub-lines.\n\nLine 5: \"→ Decision: start > end? // 子表達式無效\"\nLine 6: \"    Yes → Return [] // 回傳空結果\"\nLine 7: \"    No →\"\n\nSimilar for line 8-12.\n\nNow we need to ensure each line has only one arrow. For sub-lines, use indentation but arrow.\n\nNow produce final answer.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Input: expression // 取得輸入字串  \n→ Step 1: Define memo = {} // 快取已計算的子表達式結果  \n\n→ Function diffWays(start, end) // 計算子表達式的所有結果  \n→ Decision: start > end? // 子表達式無效  \n    Yes → Return [] // 回傳空結果  \n    No →  \n→ Decision: substring(start, end) contains no operator? // 只剩數字  \n    Yes →  \n        → Step 2: num = int(substring) // 轉成整數  \n        → Return [num] // 回傳單一結果  \n    No →  \n        → Step 3: results = [] // 儲存所有計算結果  \n        → Loop i = start to end  \n            → Decision: expression[i] is operator? // '+', '-', '*',  \n                Yes →  \n                    → left = diffWays(start, i-1) // 計算左半部  \n                    → right = diffWays(i+1, end) // 計算右半部  \n                    → Loop l in left  \n                        → Loop r in right  \n                            → Step 4: if expression[i] == '+': val = l + r  \n                            → Step 5: else if expression[i] == '-': val = l - r  \n                            → Step 6: else: val = l * r  \n                            → Append val to results  \n                No →  \n        → Return results  \n\n→ Step 7: finalResults = diffWays(0, len(expression)-1) // 計算整個表達式  \n→ Return finalResults // 將所有可能結果回傳  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def diffWaysToCompute(self, expression: str):\n        memo = {}\n\n        def ways(expr: str):\n            if expr in memo:\n                return memo[expr]\n            res = []\n            for i, ch in enumerate(expr):\n                if ch in '+-*':\n                    left = ways(expr[:i])\n                    right = ways(expr[i+1:])\n                    for l in left:\n                        for r in right:\n                            if ch == '+':\n                                res.append(l + r)\n                            elif ch == '-':\n                                res.append(l - r)\n                            else:\n                                res.append(l * r)\n            if not res:\n                res.append(int(expr))\n            memo[expr] = res\n            return res\n\n        return ways(expression)\n\ndef main():\n    data = sys.stdin.read()\n    if not data:\n        return\n    # 將輸入中雙引號內的內容作為表達式\n    match = re.search(r'\"([^\"]*)\"', data)\n    if match:\n        expr = match.group(1)\n    else:\n        # 若未找到雙引號，嘗試直接取等號右側\n        parts = data.split('=', 1)\n        expr = parts[1].strip() if len(parts) > 1 else data.strip()\n    solution = Solution()\n    results = solution.diffWaysToCompute(expr)\n    print(results)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "expression = \"2-1-1\"",
          "expected_output": "[0,2]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[0,2]'\nGot (Norm):      '[2,0]'\n--- (Raw) ---\nRaw Expected: '[0,2]'\nRaw Got:      '[2, 0]'"
        },
        {
          "example_index": 1,
          "input": "expression = \"2*3-4*5\"",
          "expected_output": "[-34,-14,-10,-10,10]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[-34,-14,-10,-10,10]'\nGot (Norm):      '[-34,-10,-14,-10,10]'\n--- (Raw) ---\nRaw Expected: '[-34,-14,-10,-10,10]'\nRaw Got:      '[-34, -10, -14, -10, 10]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode260.json",
    "problem_index_in_file": 0,
    "title": "Single Number III",
    "description_snippet": "Given an integer array nums, in which exactly two elements appear only once and all the other elemen...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code (algorithm steps) to solve problem: find two unique numbers in array where others appear twice. Use XOR, find first differing bit, partition, XOR each partition to get the two numbers. Complexity O(n) and constant space.\n\nWe must output line by line with \"虛擬碼步驟 // 解釋\". Use Start, End, Decision, arrows. Let's craft steps.\n\nLine 1: Start // start\nLine 2: → Step 1: Initialize xor_all = 0 // accumulate XOR of all numbers\nLine 3: → Step 2: For each num in nums: xor_all = xor_all XOR num // compute XOR of all\nLine 4: → Step 3: Find rightmost set bit: diff_bit = xor_all AND -xor_all // isolate lowest set bit\nLine 5: → Step 4: Initialize num1 = 0, num2 = 0 // placeholders for unique numbers\nLine 6: → Step 5: For each num in nums:\nLine 7: → Decision: If (num AND diff_bit) != 0? // test bit\nLine 8: Yes → Step 6: num1 = num1 XOR num // XOR into first group\nLine 9: No  → Step 7: num2 = num2 XOR num // XOR into second group\nLine 10: → Step 8: Output num1, num2 // result\nLine 11: End\n\nBut need arrow for nested loops? Use → Step 5: For each num in nums: → ... inside. Format maybe: \n→ Step 5: For each num in nums: \n   → Decision: ...\n        Yes → ...\n        No  → ...\nBut arrow lines inside? In example they used indentation and arrows inside block: \n→ Decision: ...\n    Yes → ...\n    No  → ...\nLet's emulate.\n\nFor Step 2 loop, we could write similar but simpler: \n→ Step 2: For each num in nums: xor_all = xor_all XOR num // etc\nBut we might need to show loop inside. But the requirement: \"逐行地產生虛擬碼\" so we must output each line with explanation. We can combine loop as a single line with comment. That's acceptable. Or we can show separate lines inside loop with indentation and arrows. The example shows they used \"→ Step 1: ...\". For decision they indent nested. So we can do:\n\n→ Step 2: For each num in nums: xor_all = xor_all XOR num // compute XOR\nYes? no need.\n\nBut the example uses \"→ Step 1:\" and inside loops they might separate? It's okay.\n\nBetter: use arrow \"→ Step 2: For each num in nums: xor_all = xor_all XOR num // XOR each number\".\n\nWe must use Decision arrow for test bit.\n\nWe need constant space. Already.\n\nReturn answer order arbitrary.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: Initialize xor_all = 0 // 用來累積所有數字的 XOR\n→ Step 2: For each num in nums: xor_all = xor_all XOR num // 先計算所有元素 XOR 的結果\n→ Step 3: diff_bit = xor_all AND (-xor_all) // 找到 xor_all 低位的第一個 1，作為分割位\n→ Step 4: Initialize num1 = 0, num2 = 0 // 用來儲存兩個唯一數字\n→ Step 5: For each num in nums:\n    → Decision: (num AND diff_bit) != 0? // 判斷 num 在分割位是 0 還是 1\n        Yes → num1 = num1 XOR num // 若位為 1，將 num XOR 到 num1\n        No  → num2 = num2 XOR num // 若位為 0，將 num XOR 到 num2\n→ Step 6: Output num1, num2 // 兩個唯一數字已得到\nEnd // 程式執行結束\n\nWe need each line with \"虛擬碼步驟 [space] // 解釋\". So we should format accordingly. Also we must keep the arrows \"→\". For indentation, we can indent lines under Step 5 and Decision. We'll maintain indentation with spaces.\n\nEnsure no actual code. Provide virtual steps only.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Initialize xor_all = 0 // 用來累積所有數字的 XOR  \n→ Step 2: For each num in nums: xor_all = xor_all XOR num // 先計算所有元素 XOR 的結果  \n→ Step 3: diff_bit = xor_all AND (-xor_all) // 找到 xor_all 低位的第一個 1，作為分割位  \n→ Step 4: Initialize num1 = 0, num2 = 0 // 用來儲存兩個唯一數字  \n→ Step 5: For each num in nums:  \n  → Decision: (num AND diff_bit) != 0? // 判斷 num 在分割位是 0 還是 1  \n   Yes → num1 = num1 XOR num // 若位為 1，將 num XOR 到 num1  \n   No  → num2 = num2 XOR num // 若位為 0，將 num XOR 到 num2  \n→ Step 6: Output num1, num2 // 兩個唯一數字已得到  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef find_two_unique(nums):\n    # XOR of all numbers\n    xor_all = 0\n    for num in nums:\n        xor_all ^= num\n\n    # Isolate the rightmost set bit\n    diff_bit = xor_all & -xor_all\n\n    # Separate numbers into two groups based on diff_bit\n    a = b = 0\n    for num in nums:\n        if num & diff_bit:\n            a ^= num\n        else:\n            b ^= num\n\n    return [a, b]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Extract the list part from the input string\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1:\n        print(\"[]\")\n        return\n\n    list_str = data[start:end+1]\n    try:\n        nums = ast.literal_eval(list_str)\n    except Exception:\n        print(\"[]\")\n        return\n\n    result = find_two_unique(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,1,3,2,5]",
          "expected_output": "[3,5]",
          "success": true,
          "output": "[3, 5]"
        },
        {
          "example_index": 1,
          "input": "nums = [-1,0]",
          "expected_output": "[-1,0]",
          "success": true,
          "output": "[-1, 0]"
        },
        {
          "example_index": 2,
          "input": "nums = [0,1]",
          "expected_output": "[1,0]",
          "success": true,
          "output": "[1, 0]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode224.json",
    "problem_index_in_file": 0,
    "title": "Basic Calculator",
    "description_snippet": "Given a string s representing a valid expression, implement a basic calculator to evaluate it, and r...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code for evaluating an expression string with +, -, *, /, parentheses? The requirement says valid expression, but likely typical LeetCode 227 Basic Calculator II? But includes parentheses maybe? It's unspecified but \"basic calculator\" suggests support for +, -, *, /, parentheses and spaces.\n\nWe'll produce algorithm using stack: iterate char, handle numbers, operators, parentheses by recursive or stack.\n\nWe'll write virtual steps: Start, parse string, maintain stack, current number, last operator, handle parentheses recursion.\n\nWe'll produce step-by-step pseudo-code with explanation.\n\nLet's produce general algorithm: iterate over string, when encounter digit build num, when encounter operator or end or '(', push last operator with num; when '(' push marker onto stack and reset; when ')' pop until marker, compute subexpression result, push result onto stack; after loop, sum stack.\n\nWe need to use virtual code lines with arrows. Provide each step with explanation.\n\nLet's craft.\n\nAlso handle division truncating toward zero.\n\nOk.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化變數 `num = 0`, `lastOp = '+'`, `stack = []` // 用來累積數字、上一次運算符、以及中間結果  \n→ Step 2: 將輸入字串 `s` 轉為字符陣列 `chars`  \n→ Decision: 對於每個字符 `c` 在 `chars` 中進行循環  \n    → Step 3: 如果 `c` 是數字字符  \n        → Update `num = num * 10 + int(c)` // 解析多位數  \n    → Decision: 如果 `c` 是 '('  \n        → Step 4: 呼叫 `parseSubExpression` 並把返回值賦給 `num` // 重新解析括號內子表達式  \n    → Decision: 如果 `c` 是運算符 (`+`, `-`, `*`, `/`) 或 `c` 為 ')' 或已到字串結尾  \n        → Step 5: 根據 `lastOp` 對 `num` 做運算並推入 `stack`  \n            → Decision: `lastOp == '+'`  \n                → Push `num`  \n            → Decision: `lastOp == '-'`  \n                → Push `-num`  \n            → Decision: `lastOp == '*'`  \n                → Pop `prev = stack.pop()`  \n                → Push `prev * num`  \n            → Decision: `lastOp == '/'`  \n                → Pop `prev = stack.pop()`  \n                → Push `int(prev / num)` // 整數除法向零取整  \n        → Step 6: 更新 `lastOp = c`  \n        → Step 7: 重設 `num = 0`  \n→ End // 已完成主循環  \n→ Step 8: 計算 `stack` 之和作為最終結果  \n→ Step 9: 返回結果  \n\n**子函式 `parseSubExpression`**  \n→ Start // 進入子表達式解析  \n→ Step 1: 初始化 `num = 0`, `lastOp = '+'`, `subStack = []`  \n→ Step 2: 移動到下一個字符，直到遇到 ')'  \n    → 其餘邏輯與主循環相同，只是結束條件為 `c == ')'`  \n→ End // 子表達式解析結束  \n→ Step 3: 計算 `subStack` 之和並返回  \n(Note: 本虛擬碼示意了主要流程，具體實作時需處理空格忽略與迴圈索引同步。)",
      "generated_code": "import sys\n\nclass Solution:\n    def calculate(self, s: str) -> int:\n        \"\"\"\n        Evaluate a simple arithmetic expression containing +, -, and parentheses.\n        Spaces are ignored. The algorithm uses a stack to handle parentheses.\n        \"\"\"\n        stack = []          # stack for intermediate results and signs\n        res = 0             # current result\n        num = 0             # current number being parsed\n        sign = 1            # 1 for '+', -1 for '-'\n\n        for c in s:\n            if c.isdigit():\n                num = num * 10 + int(c)\n            elif c in '+-':\n                res += sign * num\n                num = 0\n                sign = 1 if c == '+' else -1\n            elif c == '(':\n                # push the result and sign before '(' onto the stack\n                stack.append(res)\n                stack.append(sign)\n                # reset for the sub‑expression\n                res = 0\n                sign = 1\n            elif c == ')':\n                res += sign * num\n                num = 0\n                # multiply by the sign before the '('\n                res *= stack.pop()\n                # add the result before '('\n                res += stack.pop()\n        # add the last parsed number\n        res += sign * num\n        return res\n\n\nif __name__ == \"__main__\":\n    # Read the entire input\n    raw_input = sys.stdin.read().strip()\n\n    # Try to extract the expression after 's ='\n    if raw_input.lower().startswith('s ='):\n        # split on '=' and take the right part\n        expr = raw_input.split('=', 1)[1].strip()\n    else:\n        expr = raw_input\n\n    # Remove surrounding quotes if present\n    if (expr.startswith('\"') and expr.endswith('\"')) or \\\n       (expr.startswith(\"'\") and expr.endswith(\"'\")):\n        expr = expr[1:-1]\n\n    # Evaluate the expression\n    result = Solution().calculate(expr)\n\n    # Output the result\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"1 + 1\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "s = \" 2-1 + 2 \"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 2,
          "input": "s = \"(1+(4+5+2)-3)+(6+8)\"",
          "expected_output": "23",
          "success": true,
          "output": "23"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode55.json",
    "problem_index_in_file": 0,
    "title": "Jump Game",
    "description_snippet": "You are given an integer array nums. You are initially positioned at the array's first index, and ea...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for the Jump Game problem. We'll produce step-by-step algorithm: greedy: maintain maxReach. For i from 0 to len-1, if i > maxReach -> false. else update maxReach = max(maxReach, i+nums[i]). At end return true.\n\nWe need to output each line with virtual code step and comment. Use arrow syntax. Start, End, Decision. Also use Yes→, No→ for branches. Each line should be one step.\n\nWe should produce steps like:\n\nStart\n→ Step 1: 初始化 maxReach = 0 // 初始化可達最大索引\n→ For i from 0 to length-1: // 遍歷陣列\n    → Decision: 如果 i > maxReach? // 若當前索引超出可達範圍\n        Yes → Return False // 直接返回假\n        No  → Step 2: 更新 maxReach = max(maxReach, i + nums[i]) // 更新可達最大索引\n→ End // 所有索引可達，返回真\n\nBut need to keep step numbers maybe.\n\nLet's produce virtual code with each line.\n\nUse \"→\" to indicate next step. For loops and decisions, use indent. Provide explanation after \"//\".\n\nNeed to not output actual code. Just virtual steps.\n\nLet's output:\n\nStart // 程式開始\n\n→ Step 1: 設定 maxReach = 0 // 初始化可達最遠索引\n\n→ Decision: 迴圈 i 取值 0 到 len(nums)-1? // 遍歷每個索引\n\n    Yes → Step 2: 若 i > maxReach? // 判斷是否已超過可達範圍\n\n        Yes → Return False // 無法再往前，直接返回假\n\n        No  → Step 3: 計算 newReach = i + nums[i] // 可能可達到的新索引\n\n        No  → Step 4: 設定 maxReach = max(maxReach, newReach) // 更新最大可達索引\n\n→ End // 所有索引皆可達，返回真\n\nBut we need to include the final return true. Let's add after loop:\n\n→ Step 5: Return True // 所有索引可達，返回真\n\nBut we need to incorporate after loop. So use loop: Step 2 inside decision? We'll structure: \"Decision: 迴圈結束?\".\n\nBetter: Use a loop structure. Virtual code typical: \"Decision: i < len(nums)?\".\n\nWe can produce like:\n\nStart\n→ Step 1: 設定 maxReach = 0 // 初始可達索引為 0\n→ Decision: i = 0 < len(nums)? // 開始迴圈\n    Yes → Step 2: If i > maxReach? // 檢查是否超過可達範圍\n        Yes → Return False // 不可達到最後一個\n        No  → Step 3: maxReach = max(maxReach, i + nums[i]) // 更新可達範圍\n        No  → Step 4: i = i + 1 // 前進到下一個索引\n        No  → Decision: i < len(nums)? // 判斷是否還有未處理的索引\n            Yes → 跳回到 Step 2\n            No  → Step 5: Return True // 所有索引可達，返回真\nEnd\n\nBut we need to produce each step line by line.\n\nLet's produce as:\n\nStart // 程式開始執行\n\n→ Step 1: 設定 maxReach = 0 // 初始化可達最遠索引\n\n→ Decision: i = 0 < len(nums)? // 開始迴圈\n\n    Yes → Step 2: 如果 i > maxReach? // 檢查當前索引是否已超出可達範圍\n\n        Yes → Return False // 無法繼續，直接返回假\n\n        No  → Step 3: maxReach = max(maxReach, i + nums[i]) // 更新可達最遠索引\n\n        No  → Step 4: i = i + 1 // 前進到下一個索引\n\n        No  → Decision: i < len(nums)? // 判斷是否還有索引未處理\n\n            Yes → 跳回到 Step 2 // 繼續迴圈\n\n            No  → Step 5: Return True // 所有索引可達，返回真\n\nEnd // 程式結束\n\nWe need to include arrow indent. The \"→\" arrow should be used before each step. Use indentation for nested decisions.\n\nThus each line: \"→ Step X: ... // 解釋\".\n\nBut decisions: \"→ Decision: ...\". Then indent for Yes/No branches: \"    Yes → ...\" \"    No  → ...\".\n\nWe need to produce lines accordingly.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 maxReach = 0 // 初始化可達最遠索引為 0  \n→ Decision: i = 0 < len(nums)? // 開始迴圈，判斷是否還有索引未處理  \n  Yes → Step 2: 如果 i > maxReach? // 檢查目前索引是否已超出可達範圍  \n   Yes → Return False // 無法再往前，直接返回 False  \n   No  → Step 3: maxReach = max(maxReach, i + nums[i]) // 更新可達最遠索引  \n   No  → Step 4: i = i + 1 // 前進到下一個索引  \n   No  → Decision: i < len(nums)? // 判斷是否還有索引未處理  \n    Yes → 跳回到 Step 2 // 繼續迴圈  \n    No  → Step 5: Return True // 所有索引皆可達，返回 True  \nEnd // 程式結束執行",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def canJump(self, nums):\n        max_reach = 0\n        n = len(nums)\n        for i in range(n):\n            if i > max_reach:\n                return False\n            max_reach = max(max_reach, i + nums[i])\n        return True\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    # Extract all integers from the input (handles formats like 'nums = [2,3,1,1,4]' or just '[2,3,1,1,4]')\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    solution = Solution()\n    result = solution.canJump(nums)\n    print('true' if result else 'false')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,3,1,1,4]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "nums = [3,2,1,0,4]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode220.json",
    "problem_index_in_file": 0,
    "title": "Contains Duplicate III",
    "description_snippet": "You are given an integer array nums and two integers indexDiff and valueDiff.\n\nFind a pair of indice...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for the problem: check if array has pair within index difference <= indexDiff and value difference <= valueDiff. We can implement sliding window with balanced BST or hash map. But pseudocode may illustrate approach.\n\nWe produce step-by-step pseudocode with explanation. Use arrows etc. Provide each line as: 虛擬碼步驟 [space] // explanation.\n\nWe need Start/End and Decision.\n\nLet's outline algorithm: For each index i, maintain window of indices [i-indexDiff, i-1]. Use sorted list of values. For each i, we need to check if any value within [nums[i]-valueDiff, nums[i]+valueDiff] exists in window. If yes return true. After processing, add nums[i] to window, remove nums[i-indexDiff] when window size > indexDiff. At end return false.\n\nAlternatively use hash map with bucket size = valueDiff+1 for O(1). But for pseudocode we can use simpler approach.\n\nWe produce lines: Start, → Step 1: Initialize empty sorted list window. → Step 2: For i from 0 to length-1: inside loop: → Step 3: Determine low = nums[i]-valueDiff, high = nums[i]+valueDiff. → Step 4: If window contains any value between low and high: return true. → Step 5: Add nums[i] to window. → Step 6: If i >= indexDiff: Remove nums[i-indexDiff] from window. End of loop → Step 7: Return false. End.\n\nNeed to show Decision nodes. For check if exists. For remove condition. Provide arrow indentation.\n\nWe'll produce lines with arrows.\n\nLet's craft pseudocode:\n\nStart // 程式開始執行\n→ Step 1: 初始化空的排序集合 window // 用於快速查找區間內的值\n→ Step 2: 對 i 從 0 到 nums.length - 1 迭代 // 遍歷每個索引\n    → Step 3: 計算 low = nums[i] - valueDiff, high = nums[i] + valueDiff // 定義值差範圍\n    → Decision: window 是否包含任何值在 [low, high]？ // 檢查是否存在符合條件的值\n        Yes → Step 4: 返回 true // 找到合法對，結束\n        No  → Step 5: 將 nums[i] 插入 window // 將當前值加入滑動窗口\n    → Decision: i >= indexDiff ? // 判斷是否需要移除最舊的值\n        Yes → Step 6: 從 window 刪除 nums[i - indexDiff] // 使窗口大小不超過 indexDiff\n        No  → // 不執行任何操作\nEnd // 程式執行結束\n→ Step 7: 返回 false // 未找到符合條件的對\n\nBut we need to align indentation properly. Use arrow '→' for steps, 'Yes →', 'No →' inside decision.\n\nAlso we might need to include \"Step 4\" after removal? Actually after removal we still continue loop. So the Step 4 is return true, but we need to use return true as part of algorithm. We might want to place return true as separate step after decision. We'll produce as Step 4: 返回 true // 結束\n\nBut if return inside loop, we don't need further steps. Provide a step to continue loop after removal.\n\nLet's produce final pseudocode with indentation: Use '→' before each step.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空的排序集合 window // 用於快速查找區間內的值  \n→ Step 2: 對 i 從 0 到 nums.length - 1 迭代 // 遍歷每個索引  \n  → Step 3: 計算 low = nums[i] - valueDiff, high = nums[i] + valueDiff // 定義值差範圍  \n  → Decision: window 是否包含任何值在 [low, high]？ // 檢查是否存在符合條件的值  \n   Yes → Step 4: 返回 true // 找到合法對，結束程序  \n   No  → Step 5: 將 nums[i] 插入 window // 將當前值加入滑動窗口  \n  → Decision: i >= indexDiff ? // 判斷是否需要移除最舊的值  \n   Yes → Step 6: 從 window 刪除 nums[i - indexDiff] // 使窗口大小不超過 indexDiff  \n   No  → // 不執行任何操作  \nEnd // 程式執行結束  \n→ Step 7: 返回 false // 未找到符合條件的對，程式結束",
      "generated_code": "import sys\nimport re\nimport ast\nfrom bisect import bisect_left, insort\n\nclass Solution:\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\n        if k <= 0 or t < 0:\n            return False\n\n        window = []\n        for i, num in enumerate(nums):\n            # 找到可能符合值差條件的位置\n            pos = bisect_left(window, num - t)\n            # 在 [num-t, num+t] 之內有任何元素就直接返回 True\n            while pos < len(window) and window[pos] <= num + t:\n                return True\n\n            # 將當前數字加入窗口\n            insort(window, num)\n\n            # 若窗口大小超過 k，則移除最舊的元素\n            if len(window) > k:\n                remove_val = nums[i - k]\n                idx = bisect_left(window, remove_val)\n                # 由於可能有重複值，找到正確的位置\n                while idx < len(window) and window[idx] != remove_val:\n                    idx += 1\n                if idx < len(window):\n                    window.pop(idx)\n\n        return False\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析 nums 列表\n    nums_match = re.search(r'\\[.*?\\]', data, re.S)\n    nums = ast.literal_eval(nums_match.group(0)) if nums_match else []\n\n    # 解析 indexDiff\n    index_match = re.search(r'indexDiff\\s*=\\s*(-?\\d+)', data)\n    indexDiff = int(index_match.group(1)) if index_match else 0\n\n    # 解析 valueDiff\n    value_match = re.search(r'valueDiff\\s*=\\s*(-?\\d+)', data)\n    valueDiff = int(value_match.group(1)) if value_match else 0\n\n    result = Solution().containsNearbyAlmostDuplicate(nums, indexDiff, valueDiff)\n    print(str(result).lower())\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,1], indexDiff = 3, valueDiff = 0",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "nums = [1,5,9,1,5,9], indexDiff = 2, valueDiff = 3",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode229.json",
    "problem_index_in_file": 0,
    "title": "Majority Element II",
    "description_snippet": "Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times....",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for majority element > n/3 times. Use Boyer-Moore generalization with up to 2 candidates. Steps: initialize candidate1, candidate2 and count1, count2. First pass to find candidates. Second pass to count and output those with frequency > n/3. Use virtual code with arrows.\n\nWe must produce each line: virtual code step + space + // explanation. Format uses Start, End, Decision: with Yes→, No→.\n\nSo produce lines: Start, → Step 1: 初始化 candidate1、candidate2 和 counter1、counter2 // 设为None和0\n\nThen loop over array index: Use Decision to check candidate matches etc.\n\nWe need to produce pseudocode in lines.\n\nWe must be careful: Use indentation lines with arrows and Decision: etc. The example shows each line like \"→ Step 1: 輸入使用者數字 // ...\". For decisions, they indent lines under the Decision. We'll mimic that.\n\nLet's create structure:\n\nStart\n→ Step 1: 初始化候選人1、候選人2、計數1、計數2 // 設為 null 和 0\n→ For each element num in array:\n    → Decision: num 等於候選人1? // 判斷是否為第一個候選人\n        Yes → Step 2: 計數1 加 1 // 增加第一個候選人計數\n        No  → Decision: num 等於候選人2? // 判斷是否為第二個候選人\n            Yes → Step 3: 計數2 加 1 // 增加第二個候選人計數\n            No  → Decision: 計數1 為 0? // 沒有候選人，嘗試替換\n                Yes → Step 4: 候選人1 = num, 計數1 = 1 // 設為新候選人1\n                No  → Decision: 計數2 為 0? // 嘗試替換第二個候選人\n                    Yes → Step 5: 候選人2 = num, 計數2 = 1 // 設為新候選人2\n                    No  → Step 6: 計數1 減 1, 計數2 減 1 // 兩個計數同時減 1\nEnd for\n\nThen Second pass:\n\n→ Step 7: 重設計數1、計數2 為 0 // 重新計算實際出現次數\n→ For each element num in array:\n    → Decision: num 等於候選人1?\n        Yes → Step 8: 計數1 加 1\n        No  → Decision: num 等於候選人2?\n            Yes → Step 9: 計數2 加 1\n            No  → // do nothing\n\nEnd for\n\n→ Step 10: 初始化結果列表 // 用來儲存符合條件的元素\n→ Decision: 計數1 > n/3?\n    Yes → Step 11: 將 候選人1 加入結果\n    No  → // do nothing\n\n→ Decision: 計數2 > n/3?\n    Yes → Step 12: 將 候選人2 加入結果\n    No  → // do nothing\n\n→ Step 13: 輸出結果 // 返回符合條件的所有元素\n\nEnd\n\nMake sure each line has // explanation. The decisions with Yes and No must have lines.\n\nCheck formatting: Use arrow '→', and indent under Decision. Example shows indent with two spaces? They used 4 spaces indent? In example, they had indentation with 4 spaces before Yes→ line. We'll follow same.\n\nThus produce:\n\nStart // 程式開始執行\n→ Step 1: 初始化候選人1、候選人2、計數1、計數2 // 設為 null 與 0\n→ For each element num in array:\n    → Decision: num 等於 候選人1? // 判斷是否為第一候選人\n        Yes → Step 2: 計數1 加 1 // 增加第一候選人計數\n        No  → Decision: num 等於 候選人2? // 判斷是否為第二候選人\n            Yes → Step 3: 計數2 加 1 // 增加第二候選人計數\n            No  → Decision: 計數1 為 0? // 嘗試替換第一候選人\n                Yes → Step 4: 候選人1 = num, 計數1 = 1 // 設為新候選人1\n                No  → Decision: 計數2 為 0? // 嘗試替換第二候選人\n                    Yes → Step 5: 候選人2 = num, 計數2 = 1 // 設為新候選人2\n                    No  → Step 6: 計數1 減 1, 計數2 減 1 // 兩個計數同時減 1\n→ End for // 第一趟遍歷結束\n→ Step 7: 重設 計數1、計數2 為 0 // 重新計算實際出現次數\n→ For each element num in array:\n    → Decision: num 等於 候選人1?\n        Yes → Step 8: 計數1 加 1\n        No  → Decision: num 等於 候選人2?\n            Yes → Step 9: 計數2 加 1\n            No  → // 無需處理\n→ End for // 第二趟遍歷結束\n→ Step 10: 初始化結果列表 // 用於儲存符合條件的元素\n→ Decision: 計數1 > ⌊n/3⌋?\n    Yes → Step 11: 將 候選人1 加入結果\n    No  → // 不加入\n→ Decision: 計數2 > ⌊n/3⌋?\n    Yes → Step 12: 將 候選人2 加入結果\n    No  → // 不加入\n→ Step 13: 輸出結果 // 返回所有出現次數大於 n/3 的元素\nEnd // 程式執行結束\n\nNeed to ensure arrows after End for etc. Use correct indentation.\n\nMake sure each line includes a space between code and // explanation. Also include arrows after Decision etc. Provide lines accordingly.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化候選人1、候選人2、計數1、計數2 // 設為 null 與 0  \n→ For each element num in array:  \n    → Decision: num 等於 候選人1? // 判斷是否為第一候選人  \n        Yes → Step 2: 計數1 加 1 // 增加第一候選人計數  \n        No  → Decision: num 等於 候選人2? // 判斷是否為第二候選人  \n            Yes → Step 3: 計數2 加 1 // 增加第二候選人計數  \n            No  → Decision: 計數1 為 0? // 嘗試替換第一候選人  \n                Yes → Step 4: 候選人1 = num, 計數1 = 1 // 設為新候選人1  \n                No  → Decision: 計數2 為 0? // 嘗試替換第二候選人  \n                    Yes → Step 5: 候選人2 = num, 計數2 = 1 // 設為新候選人2  \n                    No  → Step 6: 計數1 減 1, 計數2 減 1 // 兩個計數同時減 1  \n→ End for // 第一趟遍歷結束  \n→ Step 7: 重設 計數1、計數2 為 0 // 重新計算實際出現次數  \n→ For each element num in array:  \n    → Decision: num 等於 候選人1?  \n        Yes → Step 8: 計數1 加 1  \n        No  → Decision: num 等於 候選人2?  \n            Yes → Step 9: 計數2 加 1  \n            No  → // 無需處理  \n→ End for // 第二趟遍歷結束  \n→ Step 10: 初始化結果列表 // 用於儲存符合條件的元素  \n→ Decision: 計數1 > ⌊n/3⌋?  \n    Yes → Step 11: 將 候選人1 加入結果 // 這個元素出現次數大於 n/3  \n    No  → // 不加入  \n→ Decision: 計數2 > ⌊n/3⌋?  \n    Yes → Step 12: 將 候選人2 加入結果 // 這個元素出現次數大於 n/3  \n    No  → // 不加入  \n→ Step 13: 輸出結果 // 返回所有出現次數大於 n/3 的元素  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def majorityElement(self, nums):\n        if not nums:\n            return []\n        candidate1, candidate2 = None, None\n        count1, count2 = 0, 0\n        for num in nums:\n            if candidate1 == num:\n                count1 += 1\n            elif candidate2 == num:\n                count2 += 1\n            elif count1 == 0:\n                candidate1, count1 = num, 1\n            elif count2 == 0:\n                candidate2, count2 = num, 1\n            else:\n                count1 -= 1\n                count2 -= 1\n        result = []\n        n = len(nums)\n        count1 = count2 = 0\n        for num in nums:\n            if num == candidate1:\n                count1 += 1\n            elif num == candidate2:\n                count2 += 1\n        if count1 > n // 3:\n            result.append(candidate1)\n        if count2 > n // 3:\n            result.append(candidate2)\n        return result\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Expect input like \"nums = [1,2,3]\" or just \"[1,2,3]\"\n    if '=' in data:\n        _, list_part = data.split('=', 1)\n        list_part = list_part.strip()\n    else:\n        list_part = data.strip()\n    try:\n        nums = ast.literal_eval(list_part)\n    except Exception:\n        nums = []\n    solution = Solution()\n    result = solution.majorityElement(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [3,2,3]",
          "expected_output": "[3]",
          "success": true,
          "output": "[3]"
        },
        {
          "example_index": 1,
          "input": "nums = [1]",
          "expected_output": "[1]",
          "success": true,
          "output": "[1]"
        },
        {
          "example_index": 2,
          "input": "nums = [1,2]",
          "expected_output": "[1,2]",
          "success": true,
          "output": "[1, 2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode136.json",
    "problem_index_in_file": 0,
    "title": "Single Number",
    "description_snippet": "Given a non-empty array of integers nums, every element appears twice except for one. Find that sing...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation, no actual code. For the problem: find single number where all others appear twice, linear time, constant space. Usually XOR approach. Virtual code should represent algorithm. Each line with virtual code step + explanation. Use arrow symbols.\n\nLet's produce: Start, Step: Initialize result=0, Iterate over nums, result XOR= num, End. Add decision? Not needed. But we can show that result holds the single number. Let's produce multiple lines.\n\nWe should include Start, End. Use arrow.\n\nLet's produce:\n\nStart\n→ Step 1: result ← 0 // 初始化結果為 0\n→ Step 2: For each num in nums: // 遍歷數組\n    → Step 3: result ← result XOR num // 對結果進行 XOR\n→ End // result 即為單獨出現的數字\n\nAdd explanation lines.\n\nAlso maybe show decision? Not necessary.\n\nLet's comply.\n\nWe should output each line as \"虛擬碼步驟 // 解釋\". Use arrow in code. Provide each line.\n\nWe need to ensure no code actual, but pseudocode is okay.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: result ← 0 // 初始化結果為 0\n→ Step 2: For each num in nums: // 遍歷每個數字\n    → Step 3: result ← result XOR num // 透過 XOR 消除出現兩次的數字\n→ End // result 現在是唯一出現一次的數字\n\nCheck formatting: Each line must have virtual code step followed by space then comment.\n\nYes.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: result ← 0 // 初始化結果為 0  \n→ Step 2: For each num in nums: // 遍歷每個數字  \n  → Step 3: result ← result XOR num // 透過 XOR 消除出現兩次的數字  \n→ End // result 現在是唯一出現一次的數字",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def singleNumber(self, nums):\n        \"\"\"Return the element that appears only once using XOR.\"\"\"\n        result = 0\n        for num in nums:\n            result ^= num\n        return result\n\nif __name__ == \"__main__\":\n    # Read the entire input from stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # Extract the list after the '=' sign\n    try:\n        _, list_str = data.split('=', 1)\n    except ValueError:\n        list_str = data  # If no '=' present, treat whole input as the list\n\n    # Convert the string representation of the list into a Python list\n    nums = ast.literal_eval(list_str.strip())\n\n    # Compute the single number and print it\n    solution = Solution()\n    print(solution.singleNumber(nums))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,2,1]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "nums = [4,1,2,1,2]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "nums = [1]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode520.json",
    "problem_index_in_file": 0,
    "title": "Detect Capital",
    "description_snippet": "We define the usage of capitals in a word to be right when one of the following cases holds:\n\nAll le...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps with explanations in Chinese. We need to follow the example format exactly. Let's produce a flow chart style: Start, Step 1: Input word, Step 2: Determine if word length 1 -> true. Step 3: Check if all letters are uppercase. Step 4: Check if all letters are lowercase. Step 5: Check if first is uppercase and rest lowercase. Decision nodes accordingly. We'll use Decision: If word length 1? etc. Use arrow \"→\" for steps, \"Decision:\" for decisions, \"Yes →\" and \"No →\" for branches.\n\nWe need to include \"Start // 程式開始執行\" and \"End // 程式執行結束\". Let's produce step lines. Each line: \"虛擬碼步驟 // 解釋/說明\".\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 輸入字串 word // 取得待檢查的字串\n→ Decision: 字串長度是否為 1? // 單字母自動符合規則\n    Yes → Step 2: 返回 true // 直接返回正確\n    No  → Decision: 所有字母是否全大寫? // 檢查是否為全大寫\n        Yes → Step 3: 返回 true // 全大寫符合規則\n        No  → Decision: 所有字母是否全小寫? // 檢查是否為全小寫\n            Yes → Step 4: 返回 true // 全小寫符合規則\n            No  → Decision: 第一個字母是否大寫且其餘字母全小寫? // 檢查首字母大寫其餘小寫\n                Yes → Step 5: 返回 true // 首字母大寫其餘小寫符合規則\n                No  → Step 6: 返回 false // 不符合任何規則\nEnd // 程式執行結束\n\nWe should use correct indentation? The example uses indentation for nested decisions. We'll follow that. Use spaces maybe 4 for each nested level. Also we need to use \"→\" arrow at the start of each step line. For decisions, we use \"Decision:\" lines.\n\nWe must ensure each line ends with \"// 解釋\". Provide explanation in Chinese. Use \"返回\" instead of \"輸出\". The user wants \"true\" or \"false\" return. Let's produce final output.\n\nEnsure we not output actual code. Just virtual steps.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入字串 word // 取得待檢查的字串  \n→ Decision: 字串長度是否為 1? // 單字母自動符合規則  \n    Yes → Step 2: 返回 true // 直接返回正確  \n    No  → Decision: 所有字母是否全大寫? // 檢查是否為全大寫  \n        Yes → Step 3: 返回 true // 全大寫符合規則  \n        No  → Decision: 所有字母是否全小寫? // 檢查是否為全小寫  \n            Yes → Step 4: 返回 true // 全小寫符合規則  \n            No  → Decision: 第一個字母是否大寫且其餘字母全小寫? // 檢查首字母大寫其餘小寫  \n                Yes → Step 5: 返回 true // 首字母大寫其餘小寫符合規則  \n                No  → Step 6: 返回 false // 不符合任何規則  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef detectCapitalUse(word: str) -> bool:\n    \"\"\"判斷字串的大小寫使用是否符合題目規則。\"\"\"\n    return word.isupper() or word.islower() or word.istitle()\n\ndef main() -> None:\n    # 從標準輸入讀取整個內容，去除首尾空白\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n\n    # 若輸入被單引號或雙引號包起來，移除外層引號\n    if len(raw_input) >= 2 and raw_input[0] == raw_input[-1] and raw_input[0] in {\"'\", '\"'}:\n        word = raw_input[1:-1]\n    else:\n        word = raw_input\n\n    # 判斷規則並輸出結果，符合 LeetCode 的輸出風格\n    print(str(detectCapitalUse(word)).lower())\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "\"USA\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "\"FlaG\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode171.json",
    "problem_index_in_file": 0,
    "title": "Excel Sheet Column Number",
    "description_snippet": "Given a string columnTitle that represents the column title as appears in an Excel sheet, return its...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps line by line with explanation. The requirement: input string columnTitle, return number. We need to produce algorithm. Steps: initialize result 0, iterate each char in string, convert char to value (A=1...). Multiply result by 26 and add char value. Return result. Also start, end, decision. Provide each step line. No actual code, just virtual. Provide arrows and decisions maybe not needed. Just linear algorithm. But include Start, End. Use → and explanation. Also decision: maybe check if char within 'A'-'Z'. But not necessary. But we can include decision: if character not valid, error. Provide steps.\n\nWe need to output like:\n\nStart // 程式開始執行\n→ Step 1: 初始化 result = 0 // 準備累積結果\n→ Step 2: 將 columnTitle 轉成字元列表 // 逐字處理\n→ Decision: 是否已經遍歷完所有字元？ // 判斷是否結束迴圈\n    Yes → Step 3: 返回 result // 返回最終列號\n    No → Step 4: 取下一個字元 currentChar // 取當前字元\n→ Step 5: 轉換 currentChar 為數值 value (A=1...Z=26) // 字母轉數字\n→ Step 6: result = result * 26 + value // 更新累積值\n→ Step 7: 回到 Decision // 重新判斷是否結束\nEnd // 程式執行結束\n\nBut the decision loop should include loop. But we can phrase: Decision: 是否到最後一個字元? else loop.\n\nWe must include arrows and explanation after each line. Use appropriate arrow format.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: result ← 0 // 初始化累積結果為 0  \n→ Step 2: chars ← 取得 columnTitle 的所有字元序列 // 方便逐字處理  \n→ Decision: 已經處理完所有字元？ // 判斷是否完成迴圈  \n    Yes → Step 3: 返回 result // 完成後輸出列號  \n    No → Step 4: currentChar ← 取下一個未處理的字元 // 取得目前要處理的字母  \n→ Step 5: value ← (ASCII 值 of currentChar) - (ASCII 值 of 'A') + 1 // 把字母轉成對應數值 1~26  \n→ Step 6: result ← result × 26 + value // 更新累積值，左移 26 位再加上當前字母數值  \n→ Step 7: 回到 Decision // 重新判斷是否已處理完所有字元  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def titleToNumber(self, columnTitle: str) -> int:\n        \"\"\"\n        將 Excel 標題字串轉成對應的列號。\n        演算法：從左到右遍歷字元，累加 result = result * 26 + (char_value)\n        其中 char_value = ord(char) - ord('A') + 1\n        \"\"\"\n        result = 0\n        for char in columnTitle:\n            result = result * 26 + (ord(char) - ord('A') + 1)\n        return result\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取全部資料\n    data = sys.stdin.read().strip()\n    # 先嘗試在單引號內抓取 columnTitle\n    match = re.search(r\"'([^']*)'\", data)\n    if match:\n        title = match.group(1)\n    else:\n        # 若沒有單引號，直接把整行作為 title（去除空白）\n        title = data.replace(\"columnTitle =\", \"\").strip().strip(\"'\").strip('\"')\n    # 計算並輸出結果\n    sol = Solution()\n    print(sol.titleToNumber(title))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "columnTitle = 'A'",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "columnTitle = 'AB'",
          "expected_output": "28",
          "success": true,
          "output": "28"
        },
        {
          "example_index": 2,
          "input": "columnTitle = 'ZY'",
          "expected_output": "701",
          "success": true,
          "output": "701"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode39.json",
    "problem_index_in_file": 0,
    "title": "Combination Sum",
    "description_snippet": "Given an array of distinct integers candidates and a target integer target, return a list of all uni...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for the problem: combination sum. Need to output step-by-step pseudo-code. Should use Start, End, Decision, etc. Each line: virtual code + // explanation. Must not output actual code. Provide step-by-step algorithm.\n\nWe can outline: Sort candidates, backtrack recursion, build path, if sum==target add copy of path, if sum>target return. Use unlimited usage so we can stay at same index. Provide steps.\n\nWe need to produce each line with a step.\n\nWe need to ensure we respect output format: each line: 虛擬碼步驟 [space] // 解釋/說明\n\nUse arrow \"→\" and indent decisions.\n\nProbably like:\n\nStart // 程式開始執行\n→ Step 1: Sort candidates ascending // 方便剪枝\n→ Step 2: Initialize result list // 用來存所有組合\n→ Step 3: Define recursive function Backtrack(start, currentSum, currentCombination) // 回溯核心\n    → Decision: currentSum == target? // 檢查是否達到目標\n        Yes → Add copy of currentCombination to result // 找到一組解\n        No  → Decision: currentSum > target? // 超過目標則回溯\n            Yes → Return // 截斷\n            No  → For i from start to length-1 // 遍歷剩餘候選數\n                → Step 4: Add candidates[i] to currentCombination // 選擇此數\n                → Step 5: Call Backtrack(i, currentSum + candidates[i], currentCombination) // 允許重複\n                → Step 6: Remove last element from currentCombination // 回溯\n→ Call Backtrack(0, 0, empty list) // 開始回溯\n→ End // 程式結束\n\nWe must use virtual code steps with arrows. Format each line with `→` arrow. Use indentation? In example, indent decisions and nested lines. We can replicate.\n\nWe need to include virtual code step: maybe \"Start\" as top line. Then \"→ Step 1: ...\" etc. Indent inside decisions with four spaces? The example uses two spaces indent for nested lines? Actually example shows:\n\nStart // 程式開始執行\n→ Step 1: 輸入使用者數字 // ...\n→ Decision: 如果數字大於 0? // ...\n    Yes → Step 2: 輸出 '正數' // ...\n    No  → Decision: 如果數字等於 0? // ...\n        Yes → Step 3: 輸出 '零' // ...\n        No  → Step 4: 輸出 '負數' // ...\n\nSo indentation uses four spaces for nested lines. And \"Yes →\" has two spaces? Actually \"Yes →\" has two spaces before arrow? It shows \"Yes → Step 2\". Indent 4 spaces then Yes arrow.\n\nWe replicate that.\n\nLet's write final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort candidates ascending // 先排序以方便剪枝  \n→ Step 2: Initialize result list // 用來儲存所有合法組合  \n→ Step 3: 定義遞迴函式 Backtrack(start, currentSum, currentCombination) // 回溯核心  \n    → Decision: currentSum == target? // 檢查是否已達目標和  \n        Yes → Add copy of currentCombination to result // 找到一組合法組合  \n        No  → Decision: currentSum > target? // 是否已超過目標  \n            Yes → Return // 超過目標直接回溯  \n            No  → For i from start to length-1 // 循環剩餘候選數  \n                → Step 4: Append candidates[i] to currentCombination // 選擇此數  \n                → Step 5: Call Backtrack(i, currentSum + candidates[i], currentCombination) // 允許重複使用同一數字  \n                → Step 6: Remove last element from currentCombination // 回溯到上一狀態  \n→ Call Backtrack(0, 0, empty list) // 開始回溯搜尋  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def combinationSum(self, candidates, target):\n        res = []\n\n        def backtrack(start, path, total):\n            if total == target:\n                res.append(list(path))\n                return\n            if total > target:\n                return\n            for i in range(start, len(candidates)):\n                path.append(candidates[i])\n                backtrack(i, path, total + candidates[i])\n                path.pop()\n\n        backtrack(0, [], 0)\n        return res\n\ndef parse_input(data: str):\n    \"\"\"解析輸入字串，返回 candidates 與 target。\"\"\"\n    parts = data.split(\", target = \")\n    if len(parts) != 2:\n        return [], 0\n    cand_part = parts[0].strip()\n    target_part = parts[1].strip()\n\n    # 從候選人字串中擷取列表\n    start = cand_part.find('[')\n    end = cand_part.find(']')\n    if start == -1 or end == -1:\n        return [], 0\n    list_str = cand_part[start:end + 1]\n    candidates = ast.literal_eval(list_str)\n    target = int(target_part)\n    return candidates, target\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    candidates, target = parse_input(raw_input)\n    solution = Solution()\n    result = solution.combinationSum(candidates, target)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "candidates = [2,3,6,7], target = 7",
          "expected_output": "[[2,2,3],[7]]",
          "success": true,
          "output": "[[2, 2, 3], [7]]"
        },
        {
          "example_index": 1,
          "input": "candidates = [2,3,5], target = 8",
          "expected_output": "[[2,2,2,2],[2,3,3],[3,5]]",
          "success": true,
          "output": "[[2, 2, 2, 2], [2, 3, 3], [3, 5]]"
        },
        {
          "example_index": 2,
          "input": "candidates = [2], target = 1",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode525.json",
    "problem_index_in_file": 0,
    "title": "Contiguous Array",
    "description_snippet": "Given a binary array nums, return the maximum length of a contiguous subarray with an equal number o...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines describing the algorithm for maximum length contiguous subarray with equal number of 0 and 1. Classic solution: convert 0 to -1, track prefix sum, map first occurrence of each sum, compute max length. Provide step-by-step. Use Start, Decision etc. Each line: \"虛擬碼步驟 // 解釋\". Need to adhere to format: \"虛擬碼步驟 [space] // 解釋\". Use arrow symbol \"→\" before step, \"Decision:\" with Yes/No. Provide structure. Ensure no real code. Provide algorithmic steps.\n\nWe must not output actual code. Just virtual pseudocode steps. Eg:\n\nStart // 程式開始\n→ Step 1: 初始化映射 sumToIndex，將 0 映射到 -1 // 記錄前綴和第一次出現的位置\n→ Step 2: 設置變數 sum = 0, maxLen = 0 // 前綴和與最大長度\n→ Step 3: 遍歷陣列 nums，對於每個元素 num // 逐個處理\n    → Decision: 如果 num 等於 0? // 判斷 0/1\n        Yes → sum = sum - 1 // 0 視為 -1\n        No  → sum = sum + 1 // 1 視為 +1\n    → Decision: sum 是否已存在於 sumToIndex? // 判斷是否已見過此前綴和\n        Yes → length = currentIndex - sumToIndex[sum] // 計算子陣列長度\n              → Decision: length > maxLen? // 更新最大長度\n                  Yes → maxLen = length // 更新\n        No  → sumToIndex[sum] = currentIndex // 記錄首次出現位置\n→ End // 回傳 maxLen\n\nWe should include indices. Use \"currentIndex\" variable. Ensure each step is a line. Use proper indentation. For decision branches, we need sub-steps. We'll use indentation with tabs or spaces? Format not strict. Use arrow for sub-steps inside Decision. We can show:\n\n→ Decision: if num == 0? // 判斷\n    Yes → sum = sum - 1 // 0 轉 -1\n    No  → sum = sum + 1 // 1 轉 +1\n\nAlso for sum existence decision:\n\n→ Decision: if sum already in map? // 判斷是否已經出現過\n    Yes → length = idx - sumToIndex[sum] // 計算長度\n          → Decision: if length > maxLen? // 是否更新最大長度\n              Yes → maxLen = length // 更新\n    No  → sumToIndex[sum] = idx // 記錄\n\nWe must ensure each line ends with \"// 解釋\". So each line must have comment.\n\nWe also include Start and End lines. Let's produce.\n\nRemember to output in Chinese. Provide \"虛擬碼步驟\" and comment.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化映射 sumToIndex，將 0 映射到 -1 // 以 0 為前綴和，起始位置設為 -1  \n→ Step 2: 設置變數 sum = 0, maxLen = 0, idx = 0 // 前綴和、最大長度與索引  \n→ Step 3: 遍歷陣列 nums，對每個元素 num // 逐一處理每個位元  \n    → Decision: 如果 num 等於 0? // 判斷 0 或 1  \n        Yes → sum = sum - 1 // 將 0 視為 -1，更新前綴和  \n        No  → sum = sum + 1 // 將 1 視為 +1，更新前綴和  \n    → Decision: 前綴和 sum 是否已存在於 sumToIndex? // 判斷是否已見過此和  \n        Yes → length = idx - sumToIndex[sum] // 計算以此和結尾的子陣列長度  \n               → Decision: length 大於 maxLen? // 檢查是否更新最大長度  \n                 Yes → maxLen = length // 更新最大長度  \n        No  → sumToIndex[sum] = idx // 記錄此前綴和首次出現的位置  \n    → idx = idx + 1 // 移動到下一個索引  \nEnd // 程式執行結束，回傳 maxLen 以得到最大長度子陣列的長度",
      "generated_code": "import sys\nimport ast\n\ndef findMaxLength(nums):\n    \"\"\"\n    以 0 視為 -1，1 視為 +1，計算前綴和並利用哈希表記錄首次出現的位置。\n    若相同前綴和再次出現，則之間的子陣列兩端數 0 與 1 的數量相等。\n    \"\"\"\n    count_map = {0: -1}   # 前綴和 0 的首次出現索引為 -1（方便計算整個子陣列）\n    max_len = 0\n    count = 0\n\n    for i, num in enumerate(nums):\n        count += 1 if num == 1 else -1\n\n        if count in count_map:\n            max_len = max(max_len, i - count_map[count])\n        else:\n            count_map[count] = i\n\n    return max_len\n\ndef main():\n    # 從 stdin 讀取整個輸入字串\n    data = sys.stdin.read().strip()\n    if not data:\n        # 若沒有輸入，直接輸出 0\n        print(0)\n        return\n\n    # 解析輸入成列表\n    try:\n        nums = ast.literal_eval(data)\n    except Exception:\n        # 若輸入不符合 list 語法，嘗試直接將空白分隔的整數轉為列表\n        nums = list(map(int, data.split()))\n\n    result = findMaxLength(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[0,1]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "[0,1,0]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "[0,1,1,1,1,1,0,0,0]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode207.json",
    "problem_index_in_file": 0,
    "title": "Course Schedule",
    "description_snippet": "There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code (pseudo) for checking if all courses can be finished given prerequisites, essentially cycle detection in directed graph. We should produce step-by-step with Start, Decision, arrows. Probably using DFS or Kahn's algorithm. Provide simple algorithm: Build adjacency, compute indegree, queue. We'll produce virtual code steps.\n\nMake sure to include lines like:\n\nStart // program start\n\n→ Step 1: Build adjacency list and indegree array // Build graph.\n\n→ Step 2: Initialize queue with courses having indegree 0 // courses with no prerequisites.\n\n→ Decision: 是否有課程可入 queue? // check if queue non-empty.\n\n    Yes → Step 3: 取出一課程, 進行 BFS.\n\n    No → Decision: 是否已處理完所有課程? // If processed count equals numCourses\n\n        Yes → Step 4: Return true // All courses finished\n\n        No  → Step 5: Return false // cycle detected\n\nBut we need to capture loop: while queue not empty, pop, increment processed, reduce indegree of neighbors, enqueue if indegree 0. After loop, check processed == numCourses.\n\nLet's produce lines:\n\nStart // 程式開始執行\n\n→ Step 1: 初始化 adjacency list 及 indegree 陣列 // 建立圖與入度\n\n→ Step 2: 對於每個 (a,b) in prerequisites:  adjacency[b].append(a); indegree[a] += 1 // 設定邊\n\n→ Step 3: 建立 queue，將 indegree 為 0 的課程加入 // 找到無前置課程的課程\n\n→ Step 4: processed = 0 // 記錄已完成課程數\n\n→ Decision: queue 是否非空? // 判斷是否仍有課程可處理\n\n    Yes → Step 5: 取出 queue 的第一個課程 cur // 從 queue 取\n\n    → Step 6: processed += 1 // 這門課已完成\n\n    → Step 7: 對於每個 neighbour in adjacency[cur]:\n\n        → Step 8: indegree[neighbour] -= 1 // 減少入度\n\n        → Decision: indegree[neighbour] == 0? // 是否現在可處理\n\n            Yes → Step 9: queue.append(neighbour) // 加入 queue\n\n    → Decision: queue 是否非空? // 重新判斷是否還有課程\n\n        Yes → 回到 Step 5\n\n        No  → Decision: processed == numCourses? // 判斷是否完成全部課程\n\n            Yes → Step 10: Return true // 可以完成\n\n            No  → Step 11: Return false // 有循環\n\n→ End // 程式結束\n\nBut we need to structure with proper arrows: Use arrow for sequence. Maybe nested decisions.\n\nLet's produce final answer accordingly.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 初始化 adjacency list 與 indegree 陣列 // 建立圖與入度\n→ Step 2: 對於每個 (a,b) in prerequisites:\n    adjacency[b].append(a) // b → a\n    indegree[a] += 1 // a 的入度加一\n→ Step 3: 建立 queue，將 indegree 為 0 的課程加入 // 無前置課程\n→ Step 4: processed = 0 // 記錄已完成課程數\n→ Decision: queue 是否非空? // 是否還有課程可處理\n    Yes →\n        → Step 5: cur = queue.pop_front() // 取出一課程\n        → Step 6: processed += 1 // 已完成 cur\n        → Step 7: 對於每個 neighbour in adjacency[cur]:\n            → Step 8: indegree[neighbour] -= 1 // 減少入度\n            → Decision: indegree[neighbour] == 0?\n                Yes → Step 9: queue.append(neighbour) // 可進一步處理\n        → Decision: queue 是否非空? // 仍有課程待處理嗎？\n            Yes → 回到 Step 5\n            No  →\n                → Decision: processed == numCourses? // 是否已完成所有課程？\n                    Yes → Step 10: Return true // 可以完成所有課程\n                    No  → Step 11: Return false // 存在循環，無法完成\n→ End // 程式結束執行\n```",
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import deque\n\nclass Solution:\n    def canFinish(self, numCourses, prerequisites):\n        graph = [[] for _ in range(numCourses)]\n        indegree = [0] * numCourses\n\n        for dest, src in prerequisites:\n            graph[src].append(dest)\n            indegree[dest] += 1\n\n        queue = deque([i for i in range(numCourses) if indegree[i] == 0])\n        visited = 0\n\n        while queue:\n            node = queue.popleft()\n            visited += 1\n            for neighbor in graph[node]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    queue.append(neighbor)\n\n        return visited == numCourses\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    # 尋找 numCourses 與 prerequisites\n    pattern = r'numCourses\\s*=\\s*(\\d+)\\s*,\\s*prerequisites\\s*=\\s*(\\[.*\\])'\n    match = re.search(pattern, data, re.DOTALL)\n    if not match:\n        # 若輸入格式不符合，直接輸出 false\n        print(\"false\")\n        sys.exit(0)\n\n    numCourses = int(match.group(1))\n    prereq_str = match.group(2)\n    # 使用 literal_eval 以安全方式解析列表\n    prerequisites = ast.literal_eval(prereq_str)\n\n    solution = Solution()\n    result = solution.canFinish(numCourses, prerequisites)\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "numCourses = 2, prerequisites = [[1,0]]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "numCourses = 2, prerequisites = [[1,0],[0,1]]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode459.json",
    "problem_index_in_file": 0,
    "title": "Repeated Substring Pattern",
    "description_snippet": "Given a string s, check if it can be constructed by taking a substring of it and appending multiple ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines following format. The requirement: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together. So typical algorithm: Find minimal period using s + s trick. Approach: if (s + s).indexOf(s, 1) < s.length, true else false. Or loop over length divisor. We'll produce virtual steps.\n\nNeed to produce each line: \"虛擬碼步驟 // 解釋\".\n\nWe should use Start, End, Decision. Also use arrows.\n\nLet's design:\n\nStart // 程式開始執行\n→ Step 1: 定義輸入字符串 s // 取得待判斷的字串\n→ Step 2: 計算字符串長度 n = s.length // 取得字串長度\n→ Decision: n 是否等於 0? // 空字串特殊情況\n    Yes → Step 3: 回傳 True // 空字串可視為重複子字串\n    No  → Step 4: 計算 s + s 並搜尋 s 在位置 1 後的第一次出現 // 檢查重複模式\n→ Step 5: 如果搜尋結果 index < n? // 若在內部出現，表示可重複子字串\n    Yes → Step 6: 回傳 True // 可由子字串構成\n    No  → Step 7: 回傳 False // 不能由子字串構成\nEnd // 程式執行結束\n\nBut need to use Decision and arrows. For each decision we need indent lines. Use indentation with 4 spaces maybe.\n\nAlso need to maintain arrow lines: \"→ Decision: ...\" and \"Yes →\" and \"No →\".\n\nAlso each line must end with // explanation.\n\nWe also need step numbering maybe. But format example uses \"Step 1:\" etc. So we can follow that.\n\nAlso Step 5: Decision? Actually Step 5 should be decision, not step. Use Decision: \"If index < n?\" yes.\n\nSo produce:\n\nStart // 程式開始執行\n→ Step 1: 輸入字串 s // 取得待判斷的字串\n→ Step 2: 計算長度 n = s.length // 取得字串長度\n→ Decision: n 是否等於 0? // 檢查空字串情況\n    Yes → Step 3: 回傳 True // 空字串視為重複子字串\n    No  → Step 4: 計算 concat = s + s 並搜尋 s 在位置 1 之後的首次出現 // 檢查重複模式\n→ Decision: index < n? // 若在內部出現，表示可重複子字串\n    Yes → Step 5: 回傳 True // 可由子字串構成\n    No  → Step 6: 回傳 False // 不能由子字串構成\nEnd // 程式執行結束\n\nBut we need to compute index. So Step 4 should compute index. So Step 4: find index. Then Decision uses that index.\n\nSo modify:\n\nStep 4: 取得 index = concat.indexOf(s, 1) // 搜尋 s 在 concat 從位置1起的首次出現\n\nDecision uses index.\n\nThus produce lines:\n\nStart // 程式開始執行\n→ Step 1: 輸入字串 s // 取得待判斷的字串\n→ Step 2: 計算長度 n = s.length // 取得字串長度\n→ Decision: n 是否等於 0? // 檢查空字串情況\n    Yes → Step 3: 回傳 True // 空字串視為重複子字串\n    No  → Step 4: 取得 concat = s + s // 建立字串連接\n→ Step 5: 取得 index = concat.indexOf(s, 1) // 搜尋 s 在 concat 從位置1的首次出現\n→ Decision: index < n? // 若在內部出現，表示可重複子字串\n    Yes → Step 6: 回傳 True // 可由子字串構成\n    No  → Step 7: 回傳 False // 不能由子字串構成\nEnd // 程式執行結束\n\nHowever need to use arrows for decisions properly: \"Yes →\" lines and \"No →\" lines after Decision. Format example shows \"Yes → Step 2:\" etc. So we need indent under Decision.\n\nSo for Decision: n 是否等於 0? need lines under it: Yes and No.\n\nBut we have Step 4 under No.\n\nAlso for Decision: index < n? again Yes and No lines.\n\nThus final output.\n\nEnsure each line includes \"虛擬碼步驟\" which is the text before comment. No extra spaces? Use exactly one space between step and comment.\n\nMake sure each line ends with comment.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入字串 s // 取得待判斷的字串  \n→ Step 2: 計算長度 n = s.length // 取得字串長度  \n→ Decision: n 是否等於 0? // 檢查空字串情況  \n  Yes → Step 3: 回傳 True // 空字串視為重複子字串  \n  No  → Step 4: 取得 concat = s + s // 建立字串連接  \n→ Step 5: 取得 index = concat.indexOf(s, 1) // 搜尋 s 在 concat 從位置1的首次出現  \n→ Decision: index < n? // 若在內部出現，表示可重複子字串  \n  Yes → Step 6: 回傳 True // 可由子字串構成  \n  No  → Step 7: 回傳 False // 不能由子字串構成  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef repeated_substring_pattern(s: str) -> bool:\n    \"\"\"\n    判斷是否能由一個子字串重複多次構成整個字串。\n    使用「雙倍字串」技巧：若 s 在 s + s 的中間位置 (不等於 0) 出現，\n    則說明 s 具有重複子字串結構。\n    \"\"\"\n    if not s:  # 空字串視為可重複\n        return True\n    doubled = s + s\n    # 在位置 1 後搜尋首次出現\n    idx = doubled.find(s, 1)\n    return idx < len(s)\n\ndef main() -> None:\n    \"\"\"\n    主函式：從標準輸入讀取資料、處理、輸出結果。\n    支援兩種輸入格式：\n        1. 直接給字串，如: abab\n        2. 帶前綴的格式，如: s = \"abab\"\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 如果包含 '='，則嘗試解析成 s = \"value\"\n    if '=' in data:\n        _, val = data.split('=', 1)\n        s = val.strip()\n        # 移除可能存在的引號\n        if (s.startswith('\"') and s.endswith('\"')) or (s.startswith(\"'\") and s.endswith(\"'\")):\n            s = s[1:-1]\n    else:\n        s = data\n\n    result = repeated_substring_pattern(s)\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"abab\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "s = \"aba\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "s = \"abcabcabcabc\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode528.json",
    "problem_index_in_file": 0,
    "title": "Random Pick with Weight",
    "description_snippet": "You are given a 0-indexed array of positive integers w where w[i] describes the weight of the ith in...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for implementing pickIndex function with weighted random selection. Provide steps: Start, build prefix sums array in constructor, pickIndex generates random number between 0 and total sum, binary search on prefix sums to find index. Provide explanation. Use virtual code syntax as per requirement. Let's craft.\n\nEnsure each line ends with // explanation. Use arrow arrows etc.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 宣告變數 prefixSum 為空陣列 // 用來存前綴和\n→ Step 2: 宣告變數 totalSum 為 0 // 用來記錄所有權重之和\n→ Decision: w 是否為空陣列? // 檢查輸入合法性\n    Yes → End // 若無權重，直接結束 (可選)\n    No  →  \n→ Step 3: 針對每個索引 i 從 0 到 w.length-1 執行\n    → Step 3a: totalSum ← totalSum + w[i] // 更新總和\n    → Step 3b: prefixSum.append(totalSum) // 將前綴和存入陣列\n→ Step 4: 定義函式 pickIndex() // 建立隨機選取的功能\n    → Step 4a: randomValue ← Random(0, totalSum) // 產生 0~totalSum 的隨機數\n    → Decision: randomValue 與 prefixSum 進行二分搜尋? // 找到最小索引使 prefixSum[i] > randomValue\n        Yes → Step 4b: 找到索引 i 並回傳 i // 返回隨機選取的索引\n        No  → Step 4b: (若未找到，回傳最後一個索引) // 處理極端情況\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\nimport random\nimport bisect\n\nclass Solution:\n    \"\"\"\n    建構子接收一個正整數陣列 w，計算前綴和並存起來。\n    pickIndex() 隨機產生一個 1~total 的數字，使用二分搜尋找出最小索引，\n    使 prefix_sum[idx] >= target，回傳該索引。\n    \"\"\"\n    def __init__(self, w):\n        self.prefix_sum = []\n        total = 0\n        for weight in w:\n            total += weight\n            self.prefix_sum.append(total)\n        self.total = total\n\n    def pickIndex(self):\n        target = random.randint(1, self.total)\n        return bisect.bisect_left(self.prefix_sum, target)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    # 解析輸入為兩個列表：方法名和對應參數\n    methods, args_list = json.loads(data)\n    instance = None\n    results = []\n\n    for method, args in zip(methods, args_list):\n        if method == \"Solution\":\n            # 建構子，args 為 [[w]]\n            instance = Solution(*args[0])\n            results.append(None)  # 建構子不回傳值\n        elif method == \"pickIndex\":\n            results.append(instance.pickIndex())\n        else:\n            # 若有其他方法，先假設不存在\n            results.append(None)\n\n    # 輸出結果，None 會轉成 JSON 的 null\n    print(json.dumps(results))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"Solution\",\"pickIndex\"], [[[1]],[]]",
          "expected_output": "[null,0]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpafyqwour.py\", line 29, in <module>\n    methods, args_list = json.loads(data)\n                         ^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 25 (char 24)"
        },
        {
          "example_index": 1,
          "input": "[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"], [[[1,3]],[],[],[],[],[]]",
          "expected_output": "[null,1,1,1,1,0]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpo3lf_du3.py\", line 29, in <module>\n    methods, args_list = json.loads(data)\n                         ^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 73 (char 72)"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode394.json",
    "problem_index_in_file": 0,
    "title": "Decode String",
    "description_snippet": "Given an encoded string, return its decoded string.\n\nThe encoding rule is: k[encoded_string], where ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode with explanation for decoding string with patterns like 3[a2[c]] => accaccacc. Use stack. Steps: iterate over string, if digit, build num; if '[' push current string and current num; reset; if letter, append; if ']' pop num and previous string, append current repeated times, set current string. At end return current. Provide lines. Use Start, End, Decision. Ensure each line includes explanation. Provide step lines. Let's write.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空字串 current, 空堆疊 stack, 數字累積器 num = 0 // 用於儲存目前拼接的字串與重複次數  \n→ Decision: 遍歷輸入字串每個字符 c? // 進行字元逐一處理  \n  Yes → Decision: c 是數字? // 判斷是否為重複次數的部分  \n    Yes → Step 2: num = num * 10 + (c - '0') // 解析多位數  \n    No  → Decision: c 是 '['? // 判斷是否進入括號區塊  \n      Yes → Step 3: 將 (current, num) 推入 stack // 暫存目前字串與重複次數  \n         current = \"\" // 清空字串，準備拼接括號內的內容  \n         num = 0 // 重置數字累積器  \n      No  → Decision: c 是 ']'? // 判斷是否離開括號區塊  \n        Yes → Step 4: pop (prev, repeat) 從 stack // 取得上一層字串與重複次數  \n         current = prev + current repeated repeat 次 // 將括號內部重複後合併回上一層  \n        No  → Step 5: current = current + c // 普通字母直接拼接  \nEnd // 程式執行結束，current 為解碼後的字串\n\n**說明**：  \n- Step 1 先準備工作變數。  \n- Step 2 解析數字，支持多位數。  \n- Step 3 進入新層次時，把目前狀態入棧，並重置。  \n- Step 4 出棧時把已完成的內層字串重複後與上一層合併。  \n- Step 5 直接處理普通字母。  \n- 最終 `current` 即為解碼結果。",
      "generated_code": "import sys\n\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        current_num = 0\n        current_str = ''\n        for char in s:\n            if char.isdigit():\n                current_num = current_num * 10 + int(char)\n            elif char == '[':\n                stack.append((current_str, current_num))\n                current_str = ''\n                current_num = 0\n            elif char == ']':\n                prev_str, num = stack.pop()\n                current_str = prev_str + current_str * num\n            else:\n                current_str += char\n        return current_str\n\ndef main():\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n    # 如果輸入類似 's = \"3[a]2[bc]\"'，取等號右側的內容\n    if '=' in raw_input:\n        _, part = raw_input.split('=', 1)\n        raw_input = part.strip()\n    # 去除可能存在的雙引號或單引號\n    if (raw_input.startswith('\"') and raw_input.endswith('\"')) or \\\n       (raw_input.startswith(\"'\") and raw_input.endswith(\"'\")):\n        raw_input = raw_input[1:-1]\n    solution = Solution()\n    result = solution.decodeString(raw_input)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"3[a]2[bc]\"",
          "expected_output": "\"aaabcbc\"",
          "success": true,
          "output": "aaabcbc"
        },
        {
          "example_index": 1,
          "input": "s = \"3[a2[c]]\"",
          "expected_output": "\"accaccacc\"",
          "success": true,
          "output": "accaccacc"
        },
        {
          "example_index": 2,
          "input": "s = \"2[abc]3[cd]ef\"",
          "expected_output": "\"abcabccdcdcdef\"",
          "success": true,
          "output": "abcabccdcdcdef"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode191.json",
    "problem_index_in_file": 0,
    "title": "Number of 1 Bits",
    "description_snippet": "Given a positive integer n, write a function that returns the number of set bits in its binary repre...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step, each line with \"虛擬碼步驟\" and // explanation. Use arrow arrows. Need to produce algorithm for counting set bits (Hamming weight). Provide steps: start, input n, set count =0, while n>0, check n & 1, increment count, shift n right by 1, loop, output count, end. Could also mention decision to check if bit is 1. Use decision and yes/no arrows. Let's produce:\n\nStart\n→ Step 1: 取得輸入整數 n // get n\n→ Step 2: 設定 count = 0 // initialize counter\n→ Decision: n 是否為 0? // check if no bits left\n    Yes → Step 3: 輸出 count // output\n    No  → Decision: (n & 1) 是否為 1? // check LSB\n        Yes → Step 4: count = count + 1 // increment\n        No  → (no change)\n    → Step 5: n = n >> 1 // shift right\n    → Goto Decision: n 是否為 0? // loop\nEnd\n\nNeed to use arrow syntax. Ensure each line has \"虛擬碼步驟\" + space + \"// 解釋\". The virtual code part could be like \"Start\", \"→ Step 1: 取得輸入整數 n\". Provide as per example. Let's produce accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得輸入整數 n // 從使用者取得正整數  \n→ Step 2: 設定 count = 0 // 初始化計數器  \n→ Decision: n 是否為 0? // 檢查是否已處理完所有位元  \n  Yes → Step 3: 輸出 count // 若 n 為 0，直接回傳計數結果  \n  No → Decision: (n & 1) 是否為 1? // 檢查最低位元是否為 1  \n    Yes → Step 4: count = count + 1 // 若是 1，累加計數  \n    No  → // 若不是 1，計數不變  \n  → Step 5: n = n >> 1 // 右移一位，丟棄已處理的位元  \n  → Goto Decision: n 是否為 0? // 回到判斷是否還有位元需要處理  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef hamming_weight(n: int) -> int:\n    \"\"\"\n    Return the number of 1-bits in the binary representation of n.\n    \"\"\"\n    count = 0\n    while n:\n        # Count the least significant bit and shift right\n        count += n & 1\n        n >>= 1\n    return count\n\nif __name__ == \"__main__\":\n    # Read the entire input from stdin\n    data = sys.stdin.read()\n    # Extract the first integer found in the input\n    match = re.search(r'\\d+', data)\n    if not match:\n        raise ValueError(\"No integer found in input\")\n    n = int(match.group())\n    # Compute Hamming weight and output the result\n    print(hamming_weight(n))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 11",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "n = 128",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "n = 2147483645",
          "expected_output": "30",
          "success": true,
          "output": "30"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode1337.json",
    "problem_index_in_file": 0,
    "title": "The K Weakest Rows in a Matrix",
    "description_snippet": "You are given an m x n binary matrix mat of 1's (representing soldiers) and 0's (representing civili...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, each line with \"虛擬碼步驟 // 解釋\". Use Start, End, Decision, etc. For binary matrix. Outline: read mat, compute soldier counts via binary search or linear. Create list of (count, index). Sort by count, then index. Take first k. Return indices.\n\nWe need to produce step-by-step. Use \"Start\". \"→ Step 1: Initialize list rows = []\". etc. Use Decision.\n\nWe need to include arrow symbol \"→\" each line. Also \"Yes →\" \"No →\".\n\nMake sure each line has code and comment separated by space? Format: \"虛擬碼步驟 // 解釋\". The virtual code step can include \"→\". Example: \"→ Step 1: 初始化行數組 rows = [] // ...\".\n\nAlso decisions lines: \"→ Decision: 是否已遍歷所有行?\" etc.\n\nWe need to produce code in steps, not actual code but pseudo.\n\nLet's draft steps:\n\nStart\n→ Step 1: 定義 function findWeakestRows(mat, k) // 主入口\n→ Step 2: rows = [] // 用於儲存 (soldierCount, index)\n→ Step 3: nRows = len(mat) // 行數\n→ Step 4: nCols = len(mat[0]) // 列數\n→ Step 5: For i from 0 to nRows-1 // 遍歷每一行\n    → Decision: 是否需要計算第 i 行的士兵數量? // 是\n        → Step 6: count = 0\n        → Step 7: For j from 0 to nCols-1\n            → Decision: mat[i][j] == 1?\n                Yes → count += 1\n                No  → No change // 0 表示停止計算？\n            // Actually we can break on 0 due to all 1's left\n        → Step 8: rows.append((count, i))\n→ Step 9: Sort rows by count ascending, then index ascending // 先根據士兵數量，再根據原始索引\n→ Step 10: result = [] // 儲存最弱的 k 行索引\n→ Step 11: For t from 0 to k-1\n    → Step 12: result.append(rows[t][1])\n→ End // 返回 result\n\nBut we need to use Decision arrow lines maybe.\n\nMake sure to output each line with \"→\" at start, except Start/End? Example from spec: \"Start // 程式開始執行\". So Start line has no arrow. Then \"→ Step 1\". Use arrows. Decision lines should be \"→ Decision: ...\".\n\nLet's craft final.\n\nNeed to use \"虛擬碼步驟\" maybe with Chinese text. Eg \"Step 1: ...\" But we need to use arrow arrow.\n\nWe might need to include loops with Decision arrow too.\n\nBetter to produce:\n\nStart // 程式開始執行\n→ Step 1: 定義函式 findWeakestRows(mat, k) // 主入口\n→ Step 2: rows = [] // 儲存 (士兵數量, 行索引)\n→ Step 3: nRows = len(mat) // 取得行數\n→ Step 4: nCols = len(mat[0]) // 取得列數\n→ Step 5: For i in 0 .. nRows-1 // 遍歷每一行\n    → Decision: 需要計算第 i 行的士兵數量? // 是\n        → Step 6: count = 0\n        → Step 7: For j in 0 .. nCols-1\n            → Decision: mat[i][j] == 1? // 是\n                Yes → count += 1\n                No  → Break // 0 開始，已無更多士兵\n        → Step 8: rows.append((count, i)) // 把計算結果加入\n→ Step 9: Sort rows by (count, index) ascending // 先士兵數量，再原始順序\n→ Step 10: result = [] // 儲存答案\n→ Step 11: For t in 0 .. k-1\n    → Step 12: result.append(rows[t][1]) // 取最弱的行索引\n→ End // 返回結果\n\nBut need to show returning result. Add Step 13: Return result // 最終返回\n\nAlso we need to mention returning result at End maybe.\n\nAlso we need to mention that result will be array of indices.\n\nWe also need to use \"→\" before each line inside loops; indentation maybe not needed.\n\nUse \"Yes →\" \"No →\".\n\nThe spec says: \"使用虛擬碼的箭頭 (`→`, `Yes →`, `No →`) 和結構 (`Start`, `End`, `Decision:`)。\"\n\nSo we must use arrow for steps, and decision. Provide the explanation after \"//\".\n\nLet's produce final.\n\nMake sure each line is like:\n\n→ Step 1: ... // explanation\n\nDecision line:\n\n→ Decision: 需要計算第 i 行的士兵數量? // 是\n\nYes and No lines:\n\nYes → count += 1 // etc\n\nNo  → Break // 0 開始，已無更多士兵\n\nLet's craft final output.\n\nAlso we might need to indicate that we break from inner loop once we hit 0.\n\nAlso note that we can use binary search but we can just loop. Let's keep simple.\n\nEdge cases: k <= nRows.\n\nLet's produce.\n\nMake sure to not include actual code but still pseudo code style.\n\nWe'll produce a list of lines, each line with arrow at start (except Start and End). Each line ends with comment. Ensure each line is separate line. Use Chinese explanation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義函式 findWeakestRows(mat, k) // 主入口，輸入矩陣與需要找出的最弱行數  \n→ Step 2: rows = [] // 建立空清單，用於儲存 (士兵數量, 行索引)  \n→ Step 3: nRows = len(mat) // 取得矩陣的行數  \n→ Step 4: nCols = len(mat[0]) // 取得矩陣的列數  \n→ Step 5: For i 在 0 .. nRows-1 // 循環遍歷每一行  \n    → Decision: 需要計算第 i 行的士兵數量? // 是  \n        → Step 6: count = 0 // 初始化當前行的士兵計數  \n        → Step 7: For j 在 0 .. nCols-1 // 循環遍歷列  \n            → Decision: mat[i][j] == 1? // 是  \n                Yes → count += 1 // 找到士兵，計數加一  \n                No  → Break // 遇到 0 時停止，因為 1 只會出現在左側  \n        → Step 8: rows.append((count, i)) // 把計算得到的 (士兵數量, 行索引) 加入清單  \n→ Step 9: rows.sort(key = lambda x: (x[0], x[1])) // 按士兵數量升序，再按行索引升序排序  \n→ Step 10: result = [] // 建立空清單，用於儲存最弱的 k 行索引  \n→ Step 11: For t 在 0 .. k-1 // 取排序後前 k 個元素  \n    → Step 12: result.append(rows[t][1]) // 取出行索引並加入結果  \n→ Step 13: Return result // 回傳最弱的 k 行索引清單  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def kWeakestRows(self, mat, k):\n        # Helper to count soldiers in a row using binary search\n        def count_soldiers(row):\n            left, right = 0, len(row)\n            while left < right:\n                mid = (left + right) // 2\n                if row[mid] == 1:\n                    left = mid + 1\n                else:\n                    right = mid\n            return left\n\n        soldiers = [(count_soldiers(row), i) for i, row in enumerate(mat)]\n        soldiers.sort()                 # sort by (soldier count, row index)\n        return [i for _, i in soldiers[:k]]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Expected input format: \"mat = [[...]], k = X\"\n    if ', k =' in data:\n        mat_part, k_part = data.split(', k =', 1)\n        mat = eval(mat_part.replace('mat =', '').strip())\n        k = int(eval(k_part.strip()))\n    else:\n        # Fallback: assume first line is n m, then matrix rows, then k\n        lines = data.splitlines()\n        n, m = map(int, lines[0].split())\n        mat = [list(map(int, line.split())) for line in lines[1:n+1]]\n        k = int(lines[n+1])\n    solution = Solution()\n    result = solution.kWeakestRows(mat, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "mat = [[1,1,0,0,0],[1,1,1,1,0],[1,0,0,0,0],[1,1,0,0,0],[1,1,1,1,1]], k = 3",
          "expected_output": "[2,0,3]",
          "success": true,
          "output": "[2, 0, 3]"
        },
        {
          "example_index": 1,
          "input": "mat = [[1,0,0,0],[1,1,1,1],[1,0,0,0],[1,0,0,0]], k = 2",
          "expected_output": "[0,2]",
          "success": true,
          "output": "[0, 2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode753.json",
    "problem_index_in_file": 0,
    "title": "Cracking the Safe",
    "description_snippet": "There is a safe protected by a password. The password is a sequence of n digits where each digit can...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for generating a minimal string that contains all possible sequences of length n over alphabet [0,k-1] as subsequences? Actually we want to produce a string such that the password of length n is a substring somewhere in the typed string. The goal: minimal length string that contains every possible n-digit sequence as substring. That's the classic De Bruijn sequence problem: shortest string that contains all possible k-ary n-length strings exactly once as substrings. That string length is k^n + n - 1. We need to produce algorithm: generate De Bruijn sequence via Eulerian cycle in De Bruijn graph. Provide virtual code steps: Build graph nodes of length n-1 strings, edges represent adding a digit. Perform Hierholzer. Append starting node + edges. Provide steps. Also consider example.\n\nWe'll output virtual code line by line with explanation.\n\nNeed to follow format: \"虛擬碼步驟 // 解釋\". Include Start, End, Decision, arrow.\n\nLet's produce steps: Start → Step 1: input n,k. → Step 2: initialize adjacency list for each node of length n-1. → For each node, push digits 0..k-1 edges. → Step 3: initialize stack and circuit list. → Step 4: perform DFS (Hierholzer) to get Eulerian cycle. → Step 5: construct sequence: start node string + for each edge, append digit of edge. → Step 6: output string. End.\n\nWe also need to mention we can handle n=1 separately: sequence of 0..k-1. Provide decision branches.\n\nLet's format accordingly.\n\nWe need to include virtual code arrow. Eg:\n\nStart // 程式開始\n\n→ Step 1: 輸入 n, k // 讀取位數與數字範圍\n\n→ Decision: 如果 n == 1? // n=1 情況特殊\n\n    Yes → Step 2: 組成 '012...k-1' // 只需列出所有單一位數\n\n    No → Step 3: 建立節點集 // 生成所有長度 n-1 的字串\n\n...\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始\n\n→ Step 1: 輸入 n, k // 讀取密碼長度與數字範圍\n\n→ Decision: 如果 n == 1? // n=1 的情況可直接列出所有單一位數\n    Yes → Step 2: 組成結果字符串為 \"012…(k-1)\" // 只需輸出 0~k-1\n    No  → Step 3: 建立所有長度 n-1 的節點 // 節點是所有 (n-1)-位數字串\n\n→ Step 4: 為每個節點建立鄰接列表\n    // 每個節點都有 k 條出邊，對應尾部加 0~k-1\n\n→ Step 5: 初始化空堆疊 Stack 和空路徑 Circuit\n    // 用於 Hierholzer 演算法\n\n→ Step 6: 定義函式 DFS(v)\n    → Decision: 如果 v 的鄰接列表非空? // 還有未走的邊\n        Yes → pop 頂端字元 d 從 v 的鄰接列表\n             → DFS( v 的後 (n-2) 個字 + d ) // 走下一條邊\n        No  → 將 v 推入 Circuit\n    // DFS 遞迴結束後返回，完成 Eulerian 循環\n\n→ Step 7: 呼叫 DFS(任意起點) // 例如全 0 字串\n\n→ Step 8: Circuit 現在包含逆序的節點序列\n    // 逆序取回正確的 Eulerian 循環\n\n→ Step 9: 建構最短序列\n    → Step 9a: 取 Circuit 最後一個節點作為起始節點 str\n    → Step 9b: 依次對每條邊（即兩節點之間的最後一位）將尾位 d 附加至結果\n    // 結果長度為 k^n + n - 1\n\n→ Step 10: 輸出結果字符串 // 這段文字在某處一定包含正確密碼\n\nEnd // 程式結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def crackSafe(self, n: int, k: int) -> str:\n        seen = set()\n        res = []\n\n        def dfs(node: str):\n            for digit in map(str, range(k)):\n                nei = node + digit\n                if nei not in seen:\n                    seen.add(nei)\n                    dfs(nei[1:])\n                    res.append(digit)\n\n        start = \"0\" * (n - 1)\n        dfs(start)\n        return \"\".join(res) + start\n\nif __name__ == \"__main__\":\n    # 讀取所有輸入，並從中擷取 n 與 k\n    data = sys.stdin.read()\n    nums = list(map(int, re.findall(r'\\d+', data)))\n    if len(nums) >= 2:\n        n, k = nums[0], nums[1]\n    else:\n        # 若輸入格式不符，直接終止\n        sys.exit(0)\n\n    sol = Solution()\n    result = sol.crackSafe(n, k)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 1, k = 2",
          "expected_output": "\"10\"",
          "success": true,
          "output": "10"
        },
        {
          "example_index": 1,
          "input": "n = 2, k = 2",
          "expected_output": "\"01100\"",
          "success": true,
          "output": "01100"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode172.json",
    "problem_index_in_file": 0,
    "title": "Factorial Trailing Zeroes",
    "description_snippet": "Given an integer n, return the number of trailing zeroes in n!. \n\nNote that n! = n * (n - 1) * (n - ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps that compute number of trailing zeroes in n!. That is count of factors 10 = 2*5, limited by 5s. So algorithm: while n>0, n/=5, add n to count. Provide step by step.\n\nWe need to output step by step with arrow syntax. Must be in Chinese (繁體). Each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision, Step etc. Should not output actual code. Just pseudocode steps.\n\nWe need to be careful to use \"→\" arrow for steps. Format:\n\nStart // 程式開始執行\n→ Step 1: 讀取輸入整數 n // 從使用者取得 n\n→ Step 2: 初始化 count 為 0 // 用於累計尾零數量\n→ Decision: n 是否大於 0? // 判斷是否還有要除以 5 的階段\n   Yes → Step 3: n ← n ÷ 5 // 除以 5，得到下一個階段的 n\n   Yes → Step 4: count ← count + n // 加上剛剛得到的 n\n   Yes → Decision: n 是否大於 0? // 重新判斷是否還要繼續\n   No → Step 5: 輸出 count // 結果輸出\nEnd\n\nBut we need to structure loops. Could use a While loop: Decision: n > 0? Yes -> Step: n = n /5 ; count += n ; repeat. End after loop.\n\nLet's craft:\n\nStart\n→ Step 1: 讀取輸入整數 n\n→ Step 2: 設定 count ← 0\n→ Decision: n > 0? // 是否還有可除以 5 的數值\n    Yes → Step 3: n ← n ÷ 5 // 取下一個五倍級\n    Yes → Step 4: count ← count + n // 累加尾零數量\n    Yes → Decision: n > 0? // 重新判斷是否要繼續\n    No  → Step 5: 輸出 count\nEnd\n\nBut maybe better: Use while loop. Format:\n\nStart\n→ Step 1: 讀取整數 n\n→ Step 2: 設 count ← 0\n→ Decision: n > 0? // 判斷是否仍有除以 5 的需要\n    Yes → Step 3: n ← n ÷ 5\n    Yes → Step 4: count ← count + n\n    Yes → Decision: n > 0? // 重新檢查\n    No  → Step 5: 輸出 count\nEnd\n\nHowever need to avoid infinite loop: After n ← n ÷ 5, n becomes floor division. So check again.\n\nBetter format: Use while loop representation: Decision: n > 0? Yes → ... Yes → Decision again. Might be fine.\n\nBut we should include \"Decision:\" for the while condition. The pseudocode should be clear.\n\nAlso we might add Step 0: maybe input prompt. But fine.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取整數 n // 從使用者取得需要計算尾零的 n  \n→ Step 2: 設定 count ← 0 // 用於累計尾零個數  \n→ Decision: n > 0? // 判斷是否還有可除以 5 的階段  \n Yes → Step 3: n ← n ÷ 5 // 將 n 除以 5（取整）  \n Yes → Step 4: count ← count + n // 加上剛剛得到的 n，累加尾零數量  \n Yes → Decision: n > 0? // 重新判斷是否要繼續除以 5  \n No → Step 5: 輸出 count // 顯示最終的尾零個數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef trailing_zeroes(n: int) -> int:\n    \"\"\"\n    計算 n! 的尾零數量。\n    尾零由因子 10（即 2 × 5）決定，因子 2 的數量遠多於 5，\n    因此只需計算 5 的個數即可。\n    \"\"\"\n    count = 0\n    while n > 0:\n        n //= 5          # 將 n 除以 5，得到下一個階段\n        count += n       # 累加該階段的 5 的個數\n    return count\n\ndef main() -> None:\n    \"\"\"\n    讀取輸入、計算尾零並輸出結果。\n    輸入可能是「n = 5」或僅「5」等形式。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 從輸入中提取第一個數字\n    numbers = re.findall(r'\\d+', data)\n    if not numbers:\n        return\n    n = int(numbers[0])\n\n    result = trailing_zeroes(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 3",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 1,
          "input": "n = 5",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "n = 0",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode131.json",
    "problem_index_in_file": 0,
    "title": "Palindrome Partitioning",
    "description_snippet": "Given a string s, partition s such that every substring of the partition is a palindrome. Return all...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm that given string s returns all possible palindrome partitions. We need to output in requested format: each line with virtual code step and comment. Use Start, End, Decision. Must not output real code, just pseudo steps.\n\nWe need to plan algorithm: backtracking with palindrome check.\n\nWe produce step-by-step algorithm: start, define function partition(s) returns list. Use helper backtrack(start, path). If start == len(s), add path copy. Else loop i from start+1 to len(s). substring = s[start:i]. If palindrome, backtrack(i, path + substring). After loop. End.\n\nWe need virtual code lines accordingly.\n\nUse indentation maybe but must follow arrow structure: \"→\" lines. For loops and recursion use appropriate indentation.\n\nAlso Decision: If start == len(s)? yes. Also if substring is palindrome? Yes/No.\n\nWe must avoid actual code, use pseudo names. Each line: \"虛擬碼步驟 // 解釋\". Use Start and End. Use arrows.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 定義函式 partition(s) // 主入口\n→ Step 2: 初始化結果 list = [] // 用於儲存所有 partition\n→ Step 3: 呼叫 backtrack(0, []) // 從索引 0 開始回溯\n→ Step 4: 回傳 list // 返回所有 partition\n\nDefine backtrack(current_index, path):\n→ Step 5: Decision: 如果 current_index == len(s)? // 檢查是否已遍歷完字串\n    Yes → Step 6: 把 path 的複製加入 list // 完整 partition 加入結果\n    No  → Step 7: 迴圈 i 從 current_index+1 到 len(s) // 選擇可能的子字串\n        → Step 8: substring = s[current_index:i] // 取子字串\n        → Step 9: Decision: 是否為回文? // 檢查 substring 是否回文\n            Yes → Step 10: 呼叫 backtrack(i, path + [substring]) // 進行遞迴\n            No  → // 跳過\nEnd // 程式結束\n\nWe need to produce virtual code lines: For nested, we indent? But requirement: each line must include arrow. Use \"→\" for each step. Use indent via spaces? It's fine.\n\nBut we need to produce each line of virtual code: Should include \"Start\" and \"End\". For the function definitions, maybe we do \"Step 1: 定義函式 partition(s)\". That's ok.\n\nMake sure each line has a space between code and comment. Provide explanation.\n\nWe might also need to include the list initialization and backtrack call. Provide details.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義函式 partition(s) // 主入口，接收輸入字串  \n→ Step 2: 初始化結果 list = [] // 用於儲存所有可能的回文分割  \n→ Step 3: 呼叫 backtrack(0, []) // 從索引 0 開始回溯搜索  \n→ Step 4: 回傳 list // 返回所有已收集的分割結果  \n\n→ Step 5: 定義函式 backtrack(current_index, path) // 回溯核心函式  \n    → Decision: current_index 是否等於 len(s)? // 檢查是否已遍歷完字串  \n        Yes → Step 6: 把 path 的複製加入 list // 完整分割加入結果  \n        No  → Step 7: 迴圈 i 從 current_index+1 到 len(s) // 選擇可能的子字串  \n            → Step 8: substring = s[current_index:i] // 取子字串  \n            → Decision: substring 是否為回文? // 判斷子字串是否回文  \n                Yes → Step 9: 呼叫 backtrack(i, path + [substring]) // 進行遞迴  \n                No  → // 不回文，跳過此子字串  \n\nEnd // 程式結束執行",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def partition(self, s):\n        res = []\n\n        def is_palindrome(sub):\n            return sub == sub[::-1]\n\n        def dfs(start, path):\n            if start == len(s):\n                res.append(path[:])\n                return\n            for end in range(start + 1, len(s) + 1):\n                if is_palindrome(s[start:end]):\n                    dfs(end, path + [s[start:end]])\n\n        dfs(0, [])\n        return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Extract the string inside quotes (double or single)\n    match = re.search(r'\"([^\"]*)\"', data)\n    if match:\n        s = match.group(1)\n    else:\n        match = re.search(r\"'([^']*)'\", data)\n        s = match.group(1) if match else data\n    sol = Solution()\n    result = sol.partition(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"aab\"",
          "expected_output": "[[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]",
          "success": true,
          "output": "[['a', 'a', 'b'], ['aa', 'b']]"
        },
        {
          "example_index": 1,
          "input": "s = \"a\"",
          "expected_output": "[[\"a\"]]",
          "success": true,
          "output": "[['a']]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode43.json",
    "problem_index_in_file": 0,
    "title": "Multiply Strings",
    "description_snippet": "Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code algorithm for multiplying two big integer strings without using built-in BigInteger. Standard approach: simulate grade-school multiplication: multiply each digit of num1 by each digit of num2, accumulate partial sums in array of digits. Complexity: O(m*n). Steps: reverse strings or iterate from end. Use int arrays. Implementation steps:\n\nStart\n→ Step: If either string is \"0\" return \"0\" // handle zero\n→ Step: Determine lengths m, n\n→ Step: Create result array of size m+n, initialized to zeros // holds digits\n→ Step: For i from m-1 down to 0: // digit of num1\n    → Step: For j from n-1 down to 0: // digit of num2\n        → Step: Multiply digits: mul = (num1[i]-'0') * (num2[j]-'0')\n        → Step: Sum with existing: sum = mul + result[i+j+1]\n        → Step: Set result[i+j+1] = sum % 10 // store current digit\n        → Step: result[i+j] += sum / 10 // carry to next\n→ Step: Build result string, skipping leading zeros\n→ End\n\nBut need to produce virtual code lines, each line with arrow or decision.\n\nWe also need to explain each line.\n\nLet's craft the virtual code:\n\nStart // program starts\n\n→ Decision: 是否其中一個數字為 \"0\"? // check if any operand is zero\n    Yes → Step: Return \"0\" // if zero, product zero\n    No  → Continue\n\n→ Step: 設定 m = len(num1) // length of first number\n→ Step: 設定 n = len(num2) // length of second number\n\n→ Step: 建立陣列 result[m+n]，所有元素初值 0 // result digits\n\n→ Step: 從右至左遍歷 num1 的每一位 i\n    → Step: 從右至左遍歷 num2 的每一位 j\n        → Step: 乘法 mul = (num1[i]-'0') * (num2[j]-'0') // 乘兩位數\n        → Step: 加上前一位 result[i+j+1] 的累積 sum = mul + result[i+j+1]\n        → Step: result[i+j+1] = sum % 10 // 設置此位數\n        → Step: result[i+j] += sum / 10 // 將進位加到更高位\n\n→ Step: 建立字串 builder\n→ Step: 從 result 開始跳過前導零\n    → Step: 將每個非零數字加入 builder\n→ Step: 若 builder 為空，返回 \"0\" // 若全零\n→ Step: Return builder 轉為字串 // 最終結果\n\nEnd\n\nNeed to maintain arrow notation: Start, Decision, Yes →, No →, etc.\n\nMake sure each line ends with comment after //.\n\nWe need to include \"虛擬碼步驟\" preceding comment. Use \"Step:\" prefix.\n\nBetter to keep consistent:\n\nStart\n→ Decision: 如果 num1 == \"0\" 或 num2 == \"0\"？ \n    Yes → Step: Return \"0\"\n    No  → Step: 繼續\n→ Step: m ← len(num1)\n→ Step: n ← len(num2)\n→ Step: result ← int[m+n] all 0\n→ Step: i ← m-1 從右至左遍歷 num1\n    → Step: j ← n-1 從右至左遍歷 num2\n        → Step: mul ← (num1[i]-'0') * (num2[j]-'0')\n        → Step: sum ← mul + result[i+j+1]\n        → Step: result[i+j+1] ← sum % 10\n        → Step: result[i+j] ← result[i+j] + sum / 10\n→ Step: builder ← 空字串\n→ Step: idx ← 0\n→ Step: While idx < len(result) 且 result[idx] == 0 // skip leading zeros\n    → Step: idx ← idx + 1\n→ Step: If idx == len(result) 則 builder ← \"0\"\n    → Step: 否則\n        → Step: While idx < len(result)\n            → Step: builder ← builder + str(result[idx])\n            → Step: idx ← idx + 1\n→ Step: Return builder\nEnd\n\nBut the format requires each line \"虛擬碼步驟\" + space + \"// 解釋\". We can keep \"Step:\" as part of virtual code.\n\nThus produce lines like:\n\nStart // 程式開始執行\n\n→ Decision: num1 == \"0\" 或 num2 == \"0\"? // 判斷是否任一為 0\n\nYes → Step: Return \"0\" // 直接回傳 0\n\nNo → // 繼續以下步驟\n\nBut after No we don't have a \"Step:\"? In sample, after No they indent Decision etc. We can use indentation. But for simplicity, we can put:\n\n→ Decision: If num1 == \"0\" or num2 == \"0\"? // ...\n    Yes → Step: Return \"0\" // ...\n    No  → // proceed\n\nBut we need to continue with Steps.\n\nLet's produce final output accordingly.\n\nEnsure every line includes code and comment. Use spaces. Provide arrow and decisions.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Decision: num1 == \"0\" 或 num2 == \"0\"? // 檢查任一數字是否為 0\n    Yes → Step: Return \"0\" // 直接回傳 \"0\"\n    No  → // 繼續以下步驟\n→ Step: m ← len(num1) // 取得第一個數字的長度\n→ Step: n ← len(num2) // 取得第二個數字的長度\n→ Step: result ← int[m+n] all 0 // 初始化長度為 m+n 的結果陣列，全部設為 0\n→ Step: i ← m-1 從右至左遍歷 num1 的每一位\n    → Step: j ← n-1 從右至左遍歷 num2 的每一位\n        → Step: mul ← (num1[i]-'0') * (num2[j]-'0') // 兩位數相乘\n        → Step: sum ← mul + result[i+j+1] // 加上前一次累積的值\n        → Step: result[i+j+1] ← sum % 10 // 取餘數作為本位數\n        → Step: result[i+j] ← result[i+j] + sum / 10 // 進位加入前一位\n→ Step: builder ← 空字串 // 用於組裝最終結果字串\n→ Step: idx ← 0 // 索引從陣列開頭開始\n→ Step: While idx < len(result) 且 result[idx] == 0 // 跳過前導零\n    → Step: idx ← idx + 1\n→ Step: If idx == len(result) 則 builder ← \"0\" // 若全部為零\n    → Step: 否則\n        → Step: While idx < len(result)\n            → Step: builder ← builder + str(result[idx]) // 把每位數字轉成字串加入\n            → Step: idx ← idx + 1\n→ Step: Return builder // 回傳乘積的字串表示\nEnd // 程式執行結束",
      "generated_code": "class Solution:\n    def multiply(self, num1: str, num2: str) -> str:\n        # 若任一數字為 0，直接返回 0\n        if num1 == \"0\" or num2 == \"0\":\n            return \"0\"\n\n        m, n = len(num1), len(num2)\n        # 結果位數最多為 m + n\n        result = [0] * (m + n)\n\n        # 從右到左遍歷兩個數字\n        for i in range(m - 1, -1, -1):\n            for j in range(n - 1, -1, -1):\n                mul = (ord(num1[i]) - 48) * (ord(num2[j]) - 48)\n                p1, p2 = i + j, i + j + 1\n                sum_ = mul + result[p2]\n                result[p2] = sum_ % 10\n                result[p1] += sum_ // 10\n\n        # 把結果轉成字串，去掉前導零\n        result_str = ''.join(map(str, result)).lstrip('0')\n        return result_str if result_str else \"0\"\n\n\ndef main():\n    import sys, re\n    data = sys.stdin.read()\n    # 先嘗試從單引號內抓取數字\n    nums = re.findall(r\"'(\\d+)'\", data)\n    if not nums:\n        # 再嘗試直接抓取數字\n        nums = re.findall(r\"(\\d+)\", data)\n    if len(nums) >= 2:\n        num1, num2 = nums[0], nums[1]\n    else:\n        # 如果還沒有，使用空白分隔的前兩個 token\n        parts = data.strip().split()\n        if len(parts) >= 2:\n            num1, num2 = parts[0], parts[1]\n        else:\n            return\n\n    solver = Solution()\n    result = solver.multiply(num1, num2)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num1 = '2', num2 = '3'",
          "expected_output": "'6'",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "num1 = '123', num2 = '456'",
          "expected_output": "'56088'",
          "success": true,
          "output": "56088"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode539.json",
    "problem_index_in_file": 0,
    "title": "Minimum Time Difference",
    "description_snippet": "Given a list of 24-hour clock time points in \"HH:MM\" format, return the minimum minutes difference b...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step. Requirements: Output each line as \"虛擬碼步驟 // 解釋/說明\" with arrow and structure. Need to implement algorithm: given list of time strings, find min difference minutes between any two times. Classic problem: convert to minutes, sort, find min difference between adjacent and wrap around last and first across midnight. So produce steps.\n\nWe need to output step by step with Start, End, Decision, etc.\n\nWe need to use arrow \"→\" to indicate step transitions. Provide explanation after //.\n\nLet's produce steps:\n\nStart\n→ Step 1: 把時間列表轉成分鐘值 // 先把每個 \"HH:MM\" 轉成自午夜以來的分鐘數\n→ Step 2: 將分鐘列表排序 // 讓相鄰時間差小，方便比較\n→ Step 3: 初始化 minDiff 為 24*60 // 最大可能差距\n→ Decision: 是否有重複時間? // 若有，最小差為 0\n    Yes → Step 4: 設 minDiff = 0 // 直接返回 0\n    No → Step 5: 循環遍歷排序後的分鐘列表\n        → Decision: 迴圈變數 i 在 0 到 n-2? // 比較相鄰時間\n            Yes → Step 6: 計算 diff = minutes[i+1] - minutes[i]\n            → Decision: diff < minDiff? // 更新最小差\n                Yes → Step 7: 設 minDiff = diff\n                No  → // 何也不變\n            No → Step 8: 計算 wrapDiff = 24*60 - minutes[n-1] + minutes[0]\n            → Decision: wrapDiff < minDiff? // 包含跨午夜\n                Yes → Step 9: 設 minDiff = wrapDiff\n                No  → // 何也不變\nEnd // 回傳 minDiff\n\nNeed to ensure correct flow of steps. But we need to maintain structure with Start, End, Decision, arrows.\n\nLet's produce lines with arrows for each step. We need to include \"Start\" line. Use \"→\" preceding steps. For decisions, use \"Decision:\" lines, with indent to show sub-branches? The example shows indenting with spaces. Provide indentation using spaces.\n\nAlso each line must include arrow, step or decision, plus explanation. Let's produce:\n\nStart // 程式開始執行\n→ Step 1: Convert each \"HH:MM\" to total minutes since midnight // 把時間轉成分鐘\n→ Step 2: Sort the minute list ascending // 方便找相鄰差距\n→ Step 3: Set minDiff to 1440 (24*60) // 初始為最大可能差距\n→ Decision: 是否存在重複時間點? // 若有重複則最小差為0\n    Yes → Step 4: minDiff = 0 // 直接設定\n    No  → Step 5: For i from 0 to n-2, compute diff = minutes[i+1] - minutes[i] // 比較相鄰差距\n        → Decision: diff < minDiff? // 判斷是否更小\n            Yes → Step 6: minDiff = diff // 更新最小差距\n            No  → // 不更新\n        No → Step 7: Compute wrapDiff = 1440 - minutes[n-1] + minutes[0] // 兩端跨午夜差距\n            → Decision: wrapDiff < minDiff? // 判斷是否更小\n                Yes → Step 8: minDiff = wrapDiff // 更新\n                No  → // 不更新\nEnd // 結束並返回 minDiff\n\nBut need each line as \"虛擬碼步驟 // 解釋\" exactly. Let's produce each line separately.\n\nMake sure each line ends with // explanation.\n\nWe need arrow \"→\" before each step. For Decision lines use \"Decision:\" no arrow? Example shows \"Decision: 如果數字大於 0? // ...\" so no arrow before decision. But we can maintain arrow maybe. The example uses \"Decision:\" without arrow. We'll follow.\n\nThus lines:\n\nStart // 程式開始執行\n→ Step 1: Convert each \"HH:MM\" to total minutes since midnight // 把時間轉成分鐘\n→ Step 2: Sort the minute list ascending // 方便找相鄰差距\n→ Step 3: Set minDiff to 1440 // 初始為最大可能差距\nDecision: 是否存在重複時間點? // 若有重複則最小差為 0\n    Yes → Step 4: minDiff = 0 // 設為 0\n    No  → Step 5: For i from 0 to n-2, compute diff = minutes[i+1] - minutes[i] // 比較相鄰差距\n        Decision: diff < minDiff? // 判斷是否更小\n            Yes → Step 6: minDiff = diff // 更新最小差距\n            No  → // 不更新\n        No → Step 7: Compute wrapDiff = 1440 - minutes[n-1] + minutes[0] // 跨午夜差距\n            Decision: wrapDiff < minDiff? // 判斷是否更小\n                Yes → Step 8: minDiff = wrapDiff // 更新\n                No  → // 不更新\nEnd // 程式執行結束，返回 minDiff\n\nBut we need to indicate loops. In Step 5 we need loop: For i from 0 to n-2. Could represent as Step 5: Start loop over i... The example doesn't show loops. We can write Step 5: 循環遍歷排序後的分鐘列表，計算相鄰差。 Then step 6 inside loop? It's okay. But we need to maintain clarity.\n\nSimplify: Step 5: 循環遍歷相鄰兩個時間點，計算差距並更新 minDiff // loop\n\nThen Step 6 inside loop? But we need to handle each iteration. We can just treat Step 5 as performing loop, with internal decisions.\n\nLet's rewrite:\n\nStep 5: For each adjacent pair (i,i+1), compute diff and compare to minDiff // loop\n\nWithin Step 5 we can embed Decision.\n\nBut to keep simple, we may use:\n\nStep 5: 循環 i=0 到 n-2，計算 diff = minutes[i+1]-minutes[i]，並比較更新 minDiff // loop\n\nDecision: diff < minDiff? // inside loop\n\nYes → Step 6: minDiff = diff\n\nNo → // nothing\n\nThen after loop, Step 7: Compute wrapDiff = 1440 - minutes[n-1] + minutes[0] // cross midnight\n\nDecision: wrapDiff < minDiff? // compare\n\nYes → Step 8: minDiff = wrapDiff\n\nNo → // nothing\n\nThen End.\n\nThus produce lines accordingly.\n\nMake sure indentation is correct: For Yes/No branches, indent two spaces? Example uses 4 spaces maybe. We'll use two spaces indent.\n\nLet's generate final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 把時間列表中的每個 \"HH:MM\" 轉成自午夜以來的分鐘數 // 先將時間轉為數值  \n→ Step 2: 將得到的分鐘列表進行升序排序 // 方便後續比較相鄰時間差  \n→ Step 3: 初始化 minDiff 為 1440（24×60） // 最大可能的時間差  \nDecision: 是否存在重複的時間點? // 若有重複則最小差距為 0  \n  Yes → Step 4: 設置 minDiff = 0 // 直接回傳 0  \n  No  → Step 5: 循環遍歷排序後的分鐘列表，對於每個相鄰對 (i,i+1)  \n    → Decision: diff = minutes[i+1] - minutes[i] < minDiff? // 判斷是否更新  \n      Yes → Step 6: minDiff = diff // 更新最小差距  \n      No  → // 無需更新  \n  → Step 7: 計算跨午夜的差距 wrapDiff = 1440 - minutes[n-1] + minutes[0] // 兩端時間差  \n  → Decision: wrapDiff < minDiff? // 比較是否為更小差距  \n    Yes → Step 8: minDiff = wrapDiff // 更新最小差距  \n    No  → // 無需更新  \nEnd // 程式執行結束，返回 minDiff 作为最小分钟差距",
      "generated_code": "import sys\nimport json\n\nclass Solution:\n    def findMinDifference(self, timePoints):\n        minutes = []\n        for t in timePoints:\n            h, m = map(int, t.split(':'))\n            minutes.append(h * 60 + m)\n        minutes.sort()\n        min_diff = 1440  # maximum possible difference\n        for i in range(1, len(minutes)):\n            diff = minutes[i] - minutes[i - 1]\n            if diff < min_diff:\n                min_diff = diff\n        wrap_diff = 1440 - (minutes[-1] - minutes[0])  # across midnight\n        if wrap_diff < min_diff:\n            min_diff = wrap_diff\n        return min_diff\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if data:\n        time_points = json.loads(data)\n        solution = Solution()\n        result = solution.findMinDifference(time_points)\n        print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"23:59\",\"00:00\"]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "[\"00:00\",\"23:59\",\"00:00\"]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode446.json",
    "problem_index_in_file": 0,
    "title": "Arithmetic Slices II - Subsequence",
    "description_snippet": "Given an integer array nums, return the number of all the arithmetic subsequences of nums.\n\nA sequen...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code for problem: Count arithmetic subsequences. Classic solution: DP with map per index mapping difference to count of subsequences ending at that index with that diff. For each pair (i,j), diff = nums[i]-nums[j], update counts. Use long for intermediate.\n\nWe need to produce step-by-step virtual code lines with explanations. Use Start, End, Decision, arrows. Each line: \"虛擬碼步驟 // 解釋\". Must use arrow symbol for flow. Provide lines that show algorithm.\n\nLet's craft steps:\n\nStart\n→ Initialize result = 0 // total arithmetic subsequences count\n→ For each index i from 0 to n-1: // iterate array\n    → Initialize map_i = empty map diff->count // counts of subsequences ending at i\n    → For each index j from 0 to i-1:\n        → Compute diff = nums[i] - nums[j]\n        → Get count_j = map_j[diff] or 0 // number of subsequences ending at j with this diff\n        → Update map_i[diff] += count_j + 1 // extend subsequences + new pair\n        → result += count_j // only existing subsequences of length>=3 counted\n    → End inner loop\n→ End outer loop\n→ Return result\nEnd\n\nNeed to incorporate decision? Not needed but we can use Decision to show if map_j contains diff? We can incorporate if.\n\nBut output format requires each line with arrow or decision. We'll include Decision lines for getting count_j? Let's just keep straightforward.\n\nWe'll produce lines with \"→\" prefix each step. Use indentation for inner loops? In example they used indentation with spaces. We'll emulate.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ result ← 0 // 初始化答案為 0，表示目前已找到的等差子序列數目  \n→ For i ← 0 to n-1: // 從前往後遍歷每個元素，作為子序列最後一項  \n  → map_i ← {} // 為第 i 個元素建立一個空的差值-計數映射  \n  → For j ← 0 to i-1: // 依次考慮之前所有元素作為前一項  \n    → diff ← nums[i] - nums[j] // 計算兩個元素之間的差值  \n    → Decision: map_j 含有 diff? // 判斷第 j 個位置是否已有以此差值結束的子序列  \n      Yes → count_j ← map_j[diff] // 若存在，取得已有的子序列數量  \n      No  → count_j ← 0 // 若不存在，則此差值下的子序列數為 0  \n    → map_i[diff] ← map_i.get(diff, 0) + count_j + 1 // 更新第 i 個位置的映射：延長已有子序列 + 新的兩元素序列  \n    → result ← result + count_j // 只將已存在的子序列（長度至少 3）累加到答案中  \n  → End inner loop  \n→ End outer loop  \n→ Return result // 回傳最終計算得到的等差子序列數目  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom collections import defaultdict\n\nclass Solution:\n    def numberOfArithmeticSlices(self, nums):\n        n = len(nums)\n        dp = [defaultdict(int) for _ in range(n)]\n        total = 0\n        for i in range(n):\n            for j in range(i):\n                diff = nums[i] - nums[j]\n                count = dp[j][diff]\n                dp[i][diff] += count + 1\n                total += count\n        return total\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    data = sys.stdin.read()\n    # 從輸入中提取所有整數（支援負數）\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    # 建立解決方案實例並計算答案\n    solution = Solution()\n    result = solution.numberOfArithmeticSlices(nums)\n    # 輸出結果\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,4,6,8,10]",
          "expected_output": "7",
          "success": true,
          "output": "7"
        },
        {
          "example_index": 1,
          "input": "nums = [7,7,7,7,7]",
          "expected_output": "16",
          "success": true,
          "output": "16"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode309.json",
    "problem_index_in_file": 0,
    "title": "Best Time to Buy and Sell Stock with Cooldown",
    "description_snippet": "You are given an array prices where prices[i] is the price of a given stock on the ith day.\n\nFind th...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for solving the stock problem with cooldown. Use Start, Decision, etc. Must be line-by-line. Provide short explanation. Each line: virtual code step + space + // explanation.\n\nWe'll produce algorithm: DP with states: hold, sold, rest. Typical solution: iterate days, maintain hold, sold, rest. At each day: new_hold = max(prev_hold, prev_rest - price) (can't buy after sold). new_sold = prev_hold + price (sell today). new_rest = max(prev_rest, prev_sold) (cooldown). Finally max(sold, rest). Use arrays.\n\nWe must produce pseudo steps line-by-line.\n\nLet's craft.\n\nStart // 程式開始執行\n→ Step 1: If prices list empty then Return 0 // 沒有交易，直接返回0\n→ Step 2: Initialize variable n = length of prices // 取得天數\n→ Step 3: Initialize hold = -prices[0] // 第一天買入股價\n→ Step 4: Initialize sold = 0 // 第一天未賣出，利潤為0\n→ Step 5: Initialize rest = 0 // 第一天休息，利潤為0\n→ Step 6: For i from 1 to n-1 // 迭代每天\n    → Decision:  // 進入循環\n        → Step 6a: temp_hold = max(hold, rest - prices[i]) // 保持持股或今天買入\n        → Step 6b: temp_sold = hold + prices[i] // 今天賣出\n        → Step 6c: temp_rest = max(rest, sold) // 今天休息或從已賣休息\n        → Step 6d: hold = temp_hold // 更新持股狀態\n        → Step 6e: sold = temp_sold // 更新已賣狀態\n        → Step 6f: rest = temp_rest // 更新休息狀態\n→ Step 7: Return max(sold, rest) // 最大利潤是已賣或休息時的利潤\nEnd // 程式結束\n\nBut need to follow format: each line must have virtual code step and explanation. For loops we can embed lines with indentation maybe, but each line still separate.\n\nWe can indent with arrows and spaces. Use \"→ Step\" etc.\n\nNeed to keep each line separate, even inside loop. Use \"→ Decision:\" for if.\n\nWe need to incorporate loop. Might need to represent loop with \"→ For i in range 1 to n-1:\" and inside block with indentation and arrow.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Step 1: If prices array is empty then Return 0 // 無股票價格時利潤為 0\n→ Step 2: Set n = length(prices) // 獲取天數\n→ Step 3: Set hold = -prices[0] // 第一天購買股票\n→ Step 4: Set sold = 0 // 第一天尚未賣出，利潤為 0\n→ Step 5: Set rest = 0 // 第一天處於休息狀態，利潤為 0\n→ Step 6: For i = 1 to n-1 // 逐天迭代\n    → Decision: // 進入迴圈內部\n        → Step 6a: temp_hold = max(hold, rest - prices[i]) // 持股：保留前一天持股或今天買入\n        → Step 6b: temp_sold = hold + prices[i] // 賣出：前一天持股加上今天價格\n        → Step 6c: temp_rest = max(rest, sold) // 休息：保留前一天休息或從賣出後休息\n        → Step 6d: hold = temp_hold // 更新持股狀態\n        → Step 6e: sold = temp_sold // 更新賣出狀態\n        → Step 6f: rest = temp_rest // 更新休息狀態\n→ Step 7: Return max(sold, rest) // 最高利潤為已賣或休息時的最大值\nEnd // 程式結束\n\nBut need each line separate, no indentation? It says use virtual code arrow and structure. Indentation okay but each line separate. We can use \"→\" on each line.\n\nLet's produce exactly:\n\nStart // 程式開始執行\n→ Step 1: If prices is empty then Return 0 // 沒有價格數據，直接返回 0\n→ Step 2: Set n = length(prices) // 取得天數\n→ Step 3: Set hold = -prices[0] // 第一天買入股價\n→ Step 4: Set sold = 0 // 第一天未賣出，利潤為 0\n→ Step 5: Set rest = 0 // 第一天休息，利潤為 0\n→ Step 6: For i = 1 to n-1 // 逐日迭代\n    → Decision: // 進入迴圈內部\n        → Step 6a: temp_hold = max(hold, rest - prices[i]) // 持股：保留前一天持股或今天買入\n        → Step 6b: temp_sold = hold + prices[i] // 賣出：前一天持股加上今天價格\n        → Step 6c: temp_rest = max(rest, sold) // 休息：保留前一天休息或從賣出後休息\n        → Step 6d: hold = temp_hold // 更新持股狀態\n        → Step 6e: sold = temp_sold // 更新賣出狀態\n        → Step 6f: rest = temp_rest // 更新休息狀態\n→ Step 7: Return max(sold, rest) // 最終最大利潤\nEnd // 程式結束\n\nNeed to ensure no actual code but virtual. It's okay.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: If prices is empty then Return 0 // 沒有價格資料，直接回傳 0  \n→ Step 2: Set n = length(prices) // 取得天數  \n→ Step 3: Set hold = -prices[0] // 第一天買進一股，持股狀態為 -價格  \n→ Step 4: Set sold = 0 // 第一天未賣出，已賣狀態為 0  \n→ Step 5: Set rest = 0 // 第一天休息，休息狀態為 0  \n→ Step 6: For i = 1 to n-1 // 逐日處理  \n  → Decision: // 進入迴圈內部  \n   → Step 6a: temp_hold = max(hold, rest - prices[i]) // 持股：保留前一天持股或今天以價格買進  \n   → Step 6b: temp_sold = hold + prices[i] // 賣出：前一天持股加上今天價格  \n   → Step 6c: temp_rest = max(rest, sold) // 休息：保留前一天休息或從賣出後休息  \n   → Step 6d: hold = temp_hold // 更新持股狀態  \n   → Step 6e: sold = temp_sold // 更新已賣狀態  \n   → Step 6f: rest = temp_rest // 更新休息狀態  \n→ Step 7: Return max(sold, rest) // 最終最大利潤為已賣或休息時的較大值  \nEnd // 程式結束",
      "generated_code": "import sys\nimport ast\n\ndef max_profit_with_cooldown(prices):\n    \"\"\"計算在冷卻期限制下能取得的最大利潤。\"\"\"\n    if not prices:\n        return 0\n\n    hold = -prices[0]   # 持有股票的最大利潤\n    sold = 0            # 剛賣出股票的最大利潤\n    rest = 0            # 休息狀態的最大利潤\n\n    for price in prices[1:]:\n        prev_sold = sold\n        sold = hold + price           # 今天賣出\n        hold = max(hold, rest - price)  # 今天持股或買入\n        rest = max(rest, prev_sold)      # 今天休息\n\n    return max(sold, rest)\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        print(0)\n        sys.exit(0)\n\n    # 如果輸入以 \"prices\" 開頭，去掉前綴並提取列表\n    if raw_input.lower().startswith(\"prices\"):\n        idx = raw_input.find('[')\n        if idx != -1:\n            raw_input = raw_input[idx:]\n\n    try:\n        prices = ast.literal_eval(raw_input)\n    except Exception:\n        # 解析失敗時視作空列表\n        prices = []\n\n    result = max_profit_with_cooldown(prices)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "prices = [1,2,3,0,2]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "prices = [1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode275.json",
    "problem_index_in_file": 0,
    "title": "H-Index II",
    "description_snippet": "Given an array of integers citations where citations[i] is the number of citations a researcher rece...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need produce pseudocode lines explaining algorithm for h-index with sorted citations ascending. Need log time algorithm: binary search to find first index where citations[i] >= n - i. Wait typical: array sorted ascending, length n. We want maximum h such that at least h papers have >= h citations. Equivalent to find smallest i such that citations[i] >= n - i, then h = n - i. Or binary search for boundary.\n\nWe produce steps: Start; define n; low=0 high=n-1; result=0; while low<=high: mid=(low+high)/2; if citations[mid] >= n-mid: result = n-mid; low = mid+1 else high = mid-1; After loop End. Provide explanation each line. Let's craft virtual code accordingly.\n\nWe need use \"Decision:\" lines etc. Use \"Yes →\" and \"No →\" accordingly. Provide line numbers maybe not required. Just sequential.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: 設定 n = citations 的長度 // 取得陣列長度\n→ Step 2: 設定 low = 0, high = n-1, h = 0 // 初始化二分搜尋變數\n→ Decision: 是否還有未檢查區間 (low <= high)? // 判斷是否繼續搜尋\n    Yes → Step 3: 計算 mid = (low + high) // 2 // 取中間索引\n    → Decision: citations[mid] 是否大於等於 (n - mid)? // 判斷是否符合 h 指標\n        Yes → Step 4: 設定 h = n - mid // 更新可能的 h 指標\n            → Step 5: low = mid + 1 // 向右搜尋更大 h\n        No  → Step 6: high = mid - 1 // 向左搜尋較小索引\n    No  → End // 搜尋完成\nEnd // 程式執行結束\n\nBut need \"Yes →\" \"No →\" inside decisions. Use indentation. Provide explanation after //.\n\nLet's produce final output accordingly. Ensure each line ends with // explanation. Use 虛擬碼步驟.\n\nLet's finalize.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 n = citations 的長度 // 取得陣列長度  \n→ Step 2: 設定 low = 0, high = n-1, h = 0 // 初始化二分搜尋變數  \n→ Decision: 是否還有未檢查區間 (low <= high)? // 判斷是否繼續搜尋  \n&nbsp;&nbsp;Yes → Step 3: 計算 mid = (low + high) // 2 // 取中間索引  \n&nbsp;&nbsp;&nbsp;&nbsp;Decision: citations[mid] 是否大於等於 (n - mid)? // 判斷是否符合 h 指標  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 4: 設定 h = n - mid // 更新可能的 h 指標  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 5: low = mid + 1 // 向右搜尋更大 h  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 6: high = mid - 1 // 向左搜尋較小索引  \n&nbsp;&nbsp;No  → End // 搜尋完成  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def hIndex(self, citations):\n        \"\"\"\n        Compute the h-index for a sorted list of citations in O(log n) time.\n        The algorithm uses binary search to find the smallest index i such that\n        citations[i] >= n - i, where n is the number of papers.\n        The corresponding h-index is then n - i.\n        \"\"\"\n        n = len(citations)\n        left, right = 0, n - 1\n        h = 0\n        while left <= right:\n            mid = (left + right) // 2\n            # n - mid is the number of papers from mid to end\n            if citations[mid] >= n - mid:\n                h = n - mid\n                left = mid + 1          # try to find a larger h\n            else:\n                right = mid - 1         # need more citations\n        return h\n\ndef parse_input(line: str):\n    \"\"\"\n    Parse a single line of input of the form 'citations = [a, b, c]'.\n    \"\"\"\n    if '=' in line:\n        _, expr = line.split('=', 1)\n        return ast.literal_eval(expr.strip())\n    return ast.literal_eval(line.strip())\n\nif __name__ == \"__main__\":\n    # Read the entire input from stdin\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    # Support both single-line and multi-line inputs\n    lines = raw_input.splitlines()\n    if len(lines) == 1:\n        citations = parse_input(lines[0])\n    else:\n        # If multiple lines, assume the first non-empty line contains the list\n        for line in lines:\n            if line.strip():\n                citations = parse_input(line)\n                break\n\n    solution = Solution()\n    result = solution.hIndex(citations)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "citations = [0,1,3,5,6]",
          "expected_output": "3",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '3'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: '3'\nRaw Got:      '1'"
        },
        {
          "example_index": 1,
          "input": "citations = [1,2,100]",
          "expected_output": "2",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '1'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode403.json",
    "problem_index_in_file": 0,
    "title": "Frog Jump",
    "description_snippet": "A frog is crossing a river. The river is divided into some number of units, and at each unit, there ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code line by line, with explanation. The user wants to determine if frog can cross given stone positions. This is classic frog crossing problem. We need to produce algorithm steps: start, iterate over stones, use DP or set to track possible jump lengths at each stone. We'll produce steps with decision arrows. Since it's virtual code, no actual code. Just steps. We'll outline Start, read input, create map of stone positions to sets of possible jump lengths, iterate over stones, update, final decision. We need to use arrows and decisions. Provide explanation after each line. Should be structured. Use Start, End. Let's produce lines:\n\nStart\n→ Step 1: Initialize a dictionary mapping each stone to an empty set // Setup storage for possible jump lengths\n→ Step 2: Add 0 to the set of the first stone // initial jump length is 0 before first jump\n→ Step 3: For each stone in sorted list // iterate over stones in order\n→ Decision: Is stone present in dictionary? // always true but we can skip\n→ Step 4: For each jump length k in the set of current stone // explore all possible previous jumps\n→ Decision: If k+1 > 0 and next stone (current + k+1) exists? // check forward jumps\n→ Yes → Step 5: Add k+1 to the set of next stone // record possible jump length\n→ No → // nothing\n→ Decision: If k > 0 and next stone (current + k) exists? // check same length\n→ Yes → Step 6: Add k to the set of next stone\n→ Decision: If k-1 > 0 and next stone (current + k-1) exists? // check smaller jump\n→ Yes → Step 7: Add k-1 to the set of next stone\n→ End of loops\n→ Step 8: After processing all stones, check if set of last stone is non-empty // if any jump length leads to last stone\n→ Decision: If non-empty? // can cross\n→ Yes → Step 9: Output 'True' // frog can cross\n→ No → Step 10: Output 'False' // cannot cross\nEnd\n\nBut we need to adhere to arrow syntax exactly. The arrow symbol \"→\" used before each step, indentation for nested decisions.\n\nLet's craft more precise steps.\n\nAlso ensure each line ends with `// 解釋/說明` in Chinese.\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 初始化一個字典 stoneJumpMap，鍵為石頭位置，值為可達的跳躍長度集合 // 建立每塊石頭可用的跳躍長度集合\n→ Step 2: 把第一塊石頭的集合設為 {0} // 第一次跳前的距離視為 0，允許第一次跳 1 單位\n→ Step 3: 依序遍歷所有石頭位置 positions // 逐一處理每塊石頭\n    → Step 4: 取得當前石頭位置 curr\n    → Step 5: 取得 curr 的跳躍長度集合 jumps // 先前可能的跳距\n    → Decision: 如果 jumps 為空，則跳過此石頭 // 無法從此石頭跳出，直接往下\n        No  → // 跳過\n    → Step 6: 針對 jumps 中的每個 k\n        → Decision: 如果 k + 1 > 0 且存在下一石頭 next = curr + k + 1\n            Yes → Step 7: 把 k + 1 加入 next 的集合 // 記錄可能的下一跳長度\n        → Decision: 如果 k > 0 且存在下一石頭 next = curr + k\n            Yes → Step 8: 把 k 加入 next 的集合 // 同距離跳\n        → Decision: 如果 k - 1 > 0 且存在下一石頭 next = curr + k - 1\n            Yes → Step 9: 把 k - 1 加入 next 的集合 // 小一跳\n→ Step 10: 取得最後一塊石頭 last 的跳躍長度集合 lastJumps\n→ Decision: 如果 lastJumps 非空，則可成功跨越\n    Yes → Step 11: 輸出 'True' // 跨越成功\n    No  → Step 12: 輸出 'False' // 無法跨越\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def canCross(self, stones):\n        # 將石頭位置放進集合，方便快速判斷下一跳是否落在石頭上\n        stone_set = set(stones)\n        last_stone = stones[-1]\n\n        # 建立每個石頭對應的可能跳距集合\n        jumps = {stone: set() for stone in stones}\n        jumps[0].add(0)  # 起始點的跳距為 0，方便第一次跳 1 單位\n\n        for stone in stones:\n            for k in jumps[stone]:\n                for step in (k - 1, k, k + 1):  # 可能的下一跳長度\n                    if step > 0 and stone + step in stone_set:\n                        jumps[stone + step].add(step)\n\n        return bool(jumps[last_stone])\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 從輸入字串中擷取石頭位置的列表\n    l = data.find('[')\n    r = data.rfind(']')\n    if l == -1 or r == -1:\n        print(\"false\")\n        sys.exit()\n    try:\n        stones = ast.literal_eval(data[l:r+1])\n    except Exception:\n        print(\"false\")\n        sys.exit()\n\n    result = Solution().canCross(stones)\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "stones = [0,1,3,5,6,8,12,17]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "stones = [0,1,2,3,4,8,9,11]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  }
]