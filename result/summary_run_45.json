{
  "run_index": 45,
  "total_files_found": 391,
  "total_files_processed": 323,
  "files_skipped": 68,
  "files_failed_load": 0,
  "---": "--- (以下基於 *題目* 總數) ---",
  "total_problems_attempted": 334,
  "generation_and_validation_success_count": 298,
  "generation_or_validation_failure_count": 36,
  "failed_cases_details": [
    {
      "title": "統計文字行數",
      "source_file": "900.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "（假設 data.txt 內容如下）\\nHello\\nPython\\nWorld",
          "expected_output": "檔案共有 3 行",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '檔案共有3行'\nGot (Norm):      '檔案共有1行'\n--- (Raw) ---\nRaw Expected: '檔案共有 3 行'\nRaw Got:      '檔案共有 1 行'"
        }
      ],
      "generated_code": "import sys\n\ndef main():\n    # 從標準輸入讀取資料，並寫入 data.txt\n    data = sys.stdin.read()\n    with open('data.txt', 'w', encoding='utf-8') as f:\n        f.write(data)\n\n    # 以 try / except 搭配 with 語法讀取檔案並計算行數\n    try:\n        with open('data.txt', 'r', encoding='utf-8') as f:\n            lines = f.readlines()\n        print(f'檔案共有 {len(lines)} 行')\n    except FileNotFoundError:\n        print('找不到檔案！')\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code step by step. Use the arrow syntax. Each line: \"虛擬碼步驟 // 解釋\". Must use Start, End, Decision, Yes →, No →. Must incorporate with, try/except. For file not found error. The program opens data.txt, read lines, count lines, print count. If file not found print message. Use try: open file. Then with. Then readlines. Count. Print. except FileNotFoundError: print message. No other errors. So steps: Start, Decision: file exists? Use try/except. Actually use Decision for whether try succeeded. Might do:\n\nStart\n→ Step 1: 嘗試使用 with 開啟 'data.txt' 並讀取內容 // 進行檔案開啟操作\n→ Decision: try 成功? // 判斷檔案是否成功開啟\n    Yes → Step 2: 讀取所有行並存入 lines // 讀取檔案內容\n    No  → Step 3: 輸出 '找不到檔案！' // 檔案不存在時顯示錯誤訊息\n→ Decision: 若成功，計算行數並輸出 // 只有成功時才進行統計\n    Yes → Step 4: 計算 len(lines) // 計算行數\n    Yes → Step 5: 輸出行數 // 顯示行數\nEnd\n\nBut need to maintain arrow syntax: The \"Yes →\" and \"No →\" inside Decision. The Decision lines themselves use a colon. Example:\n\nDecision: 是否成功? // ...\n\nYes → Step 2: ...\nNo  → Step 3: ...\n\nBut we need to combine reading within with. Could do:\n\nStep 1: with open('data.txt', 'r') as file: // 以 with 語法開啟檔案\n\nBut virtual code: we need to indicate nested structure. Could use indentation? The sample shows indentation for nested steps. We'll use indentation with spaces.\n\nThe try/except: We might write:\n\n→ Decision: 嘗試開啟檔案? // 以 try / except 檢查檔案存在\n\n    Yes → Step 1: with open('data.txt', 'r') as file: // 開啟檔案\n    No  → Step 2: 輸出 '找不到檔案！' // 檔案不存在\n\nBut then we need to read lines. So after opening file, we read lines. Could embed inside Step 1? Use nested steps: inside Step 1's block, we have Step 1.1: lines = file.readlines() // 讀取所有行\n\nThen count and output.\n\nBut the virtual code requires each line to have \"虛擬碼步驟 // 解釋\". We'll need to indicate indentation using spaces maybe. Use 4 spaces for nested.\n\nWe need to output each line exactly as required.\n\nLet's craft final output:\n\nStart // 程式開始執行\n→ Decision: 嘗試開啟 'data.txt'? // 進入 try/except 檢查檔案是否存在\n    Yes → Step 1: with open('data.txt', 'r') as file: // 使用 with 語法開啟檔案\n        → Step 1.1: lines = file.readlines() // 讀取檔案所有行\n        → Step 1.2: line_count = len(lines) // 計算行數\n        → Step 1.3: print(line_count) // 輸出行數\n    No  → Step 2: print('找不到檔案！') // 檔案不存在時顯示錯誤訊息\nEnd // 程式執行結束\n\nBut we didn't include actual try/except. We used Decision: 嘗試開啟 'data.txt'? This implies try. That's okay. But maybe we need to reflect try/except structure explicitly: \"try\" step then \"except\" step. Use Decision: 進入 try? but not needed. Could do:\n\n→ Step 1: try: // 開始 try 區塊\n    → Step 1.1: with open('data.txt', 'r') as file: // 開啟檔案\n        → Step 1.1.1: lines = file.readlines() // 讀取\n        → Step 1.1.2: line_count = len(lines) // 計算\n        → Step 1.1.3: print(line_count) // 輸出\n    → Step 1.2: except FileNotFoundError: // 檔案不存在\n        → Step 1.2.1: print('找不到檔案！') // 顯示訊息\n\nBut need to format arrow lines. For \"except\", we may write \"→ Exception: FileNotFoundError\" or \"→ Decision: 檔案不存在?\".\n\nSimplest: Use Decision: try 成功? No/Yes. But the instruction: use with syntax, try/except. So we can represent try/except by Decision.\n\nLet's do:\n\nStart // 程式開始執行\n→ Decision: 嘗試以 with 開啟 'data.txt'? // 進入 try/except\n    Yes → Step 1: with open('data.txt', 'r') as file: // 使用 with 語法開啟檔案\n        → Step 1.1: lines = file.readlines() // 讀取所有行\n        → Step 1.2: line_count = len(lines) // 計算行數\n        → Step 1.3: print(line_count) // 輸出行數\n    No  → Step 2: print('找不到檔案！') // 檔案不存在時顯示錯誤訊息\nEnd // 程式執行結束\n\nBut we also want to mention try/except. The decision \"嘗試以 with 開啟 'data.txt'?\" implicitly means try/except.\n\nAlternatively, we can explicitly show try/except by including \"try:\" and \"except FileNotFoundError:\" steps:\n\nStart\n→ Step 1: try: // 開始 try 區塊\n    → Step 1.1: with open('data.txt', 'r') as file: // 使用 with 語法開啟檔案\n        → Step 1.1.1: lines = file.readlines() // 讀取檔案所有行\n        → Step 1.1.2: line_count = len(lines) // 計算行數\n        → Step 1.1.3: print(line_count) // 輸出行數\n    → Step 1.2: except FileNotFoundError: // 檔案不存在\n        → Step 1.2.1: print('找不到檔案！') // 顯示錯誤訊息\nEnd\n\nBut the sample uses Decision with Yes/No. However, we can still use the explicit try/except lines. The requirement says \"請使用 with 語法搭配 try / except\". So we need to show that. We can do:\n\nStart // 程式開始執行\n→ Step 1: try: // 開始 try 區塊\n    → Step 1.1: with open('data.txt', 'r') as file: // 使用 with 語法開啟檔案\n        → Step 1.1.1: lines = file.readlines() // 讀取所有行\n        → Step 1.1.2: line_count = len(lines) // 計算行數\n        → Step 1.1.3: print(line_count) // 輸出行數\n    → Step 1.2: except FileNotFoundError: // 檔案不存在\n        → Step 1.2.1: print('找不到檔案！') // 顯示錯誤訊息\nEnd // 程式執行結束\n\nThis is fine. The indentation indicates block structure. Each line uses arrow? For steps 1.1 and 1.2 we may indent with spaces but keep arrow at start? Sample uses \"→ Step\" for each step. For nested steps we can indent and keep \"→\". That is okay.\n\nThus final output: list lines with arrow and explanation.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: try: // 開始 try 區塊  \n    → Step 1.1: with open('data.txt', 'r') as file: // 使用 with 語法開啟檔案  \n        → Step 1.1.1: lines = file.readlines() // 讀取檔案所有行  \n        → Step 1.1.2: line_count = len(lines) // 計算行數  \n        → Step 1.1.3: print(line_count) // 輸出行數  \n    → Step 1.2: except FileNotFoundError: // 檔案不存在時進入 except 區塊  \n        → Step 1.2.1: print('找不到檔案！') // 顯示錯誤訊息  \nEnd // 程式執行結束"
    },
    {
      "title": "模擬擲骰子遊戲",
      "source_file": "800.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "print(roll_dice(5))",
          "expected_output": "[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,6,1,4,2]#(結果會隨機，每次可能不同)'\nGot (Norm):      '[5,4,6,2,6]'\n--- (Raw) ---\nRaw Expected: '[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)'\nRaw Got:      '[5, 4, 6, 2, 6]'"
        }
      ],
      "generated_code": "import random\nimport sys\n\ndef roll_dice(n):\n    \"\"\"擲 n 次六面骰，回傳結果串列。\"\"\"\n    results = []\n    for _ in range(n):\n        results.append(random.randint(1, 6))\n    return results\n\nif __name__ == \"__main__\":\n    # 讀取 stdin，並執行其中的程式碼\n    code = sys.stdin.read()\n    exec(code, globals())",
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line with explanation, following format: each line: \"虛擬碼步驟 // 解釋/說明\". Use Start, End, Decision, arrow. Need to produce virtual code for function roll_dice(n) that simulates rolling n six-sided dice using random module, returns list of results.\n\nWe must not output actual code. So we use virtual code steps. We should include import random at start? Might be part of function. In pseudocode we can include step: Import random module. Then define function. Then create empty list, loop n times, generate random integer 1-6, append, return list. Then End. We'll use arrow notation.\n\nNeed to follow output format: Start, End, Decision. For loops we might use \"Loop n times\". Could use \"Iteration:\".\n\nLet's produce:\n\nStart\n→ Step 1: Import random module // 引入 random 模組以產生隨機數\n→ Step 2: 定義函數 roll_dice(n) // 宣告 roll_dice，接受骰子擲次數 n\n→ Step 3: 建立空串列 results = [] // 用於儲存每次擲骰結果\n→ Step 4: For i from 1 to n: // 迭代 n 次擲骰\n    → Step 5: 產生 random integer 1~6 // 用 random.randint(1,6) 模擬六面骰\n    → Step 6: 將結果加入 results // results.append(roll)\n→ Step 7: 回傳 results // 函數結束並返回所有結果\nEnd\n\nBut must use virtual code arrows and structure: Use → for steps. Use Decision? Not needed. Use Loop? We'll indicate \"Loop n times\" maybe \"Repeat n times\". We'll use \"Repeat n times:\" and indent following steps.\n\nWe also need to mark \"Start\" and \"End\".\n\nLet's produce.\n\nMake sure each line includes the step and // explanation. Also ensure arrow symbol at start of each step. For nested steps, indent with 4 spaces? In format example, indent uses 4 spaces for nested lines. We'll follow.\n\nAlso we might need to include \"Decision\" not necessary.\n\nLet's craft.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Import random module // 引入 random 模組以產生隨機數  \n→ Step 2: Define function roll_dice(n) // 宣告 roll_dice，接受骰子擲次數 n  \n→ Step 3: Create empty list results = [] // 用於儲存每次擲骰結果  \n→ Step 4: Repeat n times: // 迭代 n 次擲骰  \n  → Step 5: Generate random integer 1~6 // 用 random.randint(1,6) 模擬六面骰  \n  → Step 6: Append the integer to results // 將本次擲骰結果加入列表  \n→ Step 7: Return results // 函式結束並返回所有擲骰結果  \nEnd // 程式執行結束"
    },
    {
      "title": "計算程式執行時間",
      "source_file": "800.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "import time\n\ndef slow_add(a, b):\n    time.sleep(2)\n    return a + b\n\nprint(measure_time(slow_add, 3, 5))",
          "expected_output": "約 2.0 秒 (依電腦執行環境略有差異)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '約2.0秒(依電腦執行環境略有差異)'\nGot (Norm):      '2.0'\n--- (Raw) ---\nRaw Expected: '約 2.0 秒 (依電腦執行環境略有差異)'\nRaw Got:      '2.0'"
        }
      ],
      "generated_code": "import time\nimport sys\n\ndef measure_time(func, *args):\n    \"\"\"\n    計算 func(*args) 的執行時間，並回傳四捨五入至小數點第三位的秒數。\n    \"\"\"\n    start = time.perf_counter()\n    func(*args)\n    end = time.perf_counter()\n    return round(end - start, 3)\n\ndef main():\n    \"\"\"\n    讀取 stdin 的程式碼並以此環境執行。\n    \"\"\"\n    code = sys.stdin.read()\n    # exec 使用此模組的全域環境，讓 measure_time 在執行的程式碼中可用\n    exec(code, globals())\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line, with \"虛擬碼步驟\" and explanation. Must use arrow symbols. Use time module, measure_time(func, *args). Steps: import time, define function, record start, call func with args, record end, compute elapsed, round to 3 decimals, return result. Also maybe return time? Problem says \"回傳結果 (四捨五入到小數點 3 位)\" I think return the elapsed time. So final function returns the rounded elapsed seconds. Provide virtual code.\n\nFormat:\n\nStart // ...\n→ Step 1: import time // 引入 time 模組\n→ Step 2: 定義函數 measure_time(func, *args) // 定義測量時間的函式\n→ Step 3: 记录 start = time.perf_counter() // 記錄開始時間\n→ Step 4: 调用 func(*args) // 執行傳入的函式\n→ Step 5: 记录 end = time.perf_counter() // 記錄結束時間\n→ Step 6: 计算 elapsed = end - start // 計算耗時\n→ Step 7: 四舍五入 elapsed 到 3 位 -> rounded = round(elapsed, 3) // 四捨五入\n→ Step 8: return rounded // 回傳結果\nEnd // 程式執行結束\n\nBut we need to use virtual code arrows. Could use \"Step 1:\" etc. But the format example uses \"Step 1:\" after arrow. So we need something like \"→ Step 1: import time // ...\". Use Decision? None needed.\n\nLet's produce. Ensure each line ends with comment. Use space after arrow. Provide line per step. Use \"Start\" and \"End\". Good.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: import time // 引入 time 模組以便取得高精度時間  \n→ Step 2: 定義函數 measure_time(func, *args) // 建立用於測量函式執行時間的函式  \n→ Step 3: 记录 start = time.perf_counter() // 取得開始時間（高解析度計時器）  \n→ Step 4: 執行 func(*args) // 呼叫傳入的函式，並傳遞所有參數  \n→ Step 5: 记录 end = time.perf_counter() // 取得結束時間  \n→ Step 6: 计算 elapsed = end - start // 計算兩次計時差，即函式執行所需秒數  \n→ Step 7: 四舍五入 elapsed 到 3 位 → rounded = round(elapsed, 3) // 以小數點後三位進行四捨五入  \n→ Step 8: return rounded // 回傳四捨五入後的秒數結果  \nEnd // 程式執行結束"
    },
    {
      "title": "學生資料類別設計",
      "source_file": "1100.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "Alice 的分數是 90\nBob 的分數是 80",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'Alice的分數是90\\nBob的分數是80'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: 'Alice 的分數是 90\\nBob 的分數是 80'\nRaw Got:      ''"
        }
      ],
      "generated_code": "import sys\n\nclass Student:\n    \"\"\"\n    學生類別，擁有姓名 (name) 與分數 (score)。\n    \"\"\"\n    def __init__(self, name, score):\n        self.name = name\n        self.score = score\n\n    def show_info(self):\n        \"\"\"輸出「姓名 的分數是 分數」的訊息。\"\"\"\n        print(f'{self.name} 的分數是 {self.score}')\n\n\ndef main():\n    # 讀取所有非空白的輸入行\n    raw_lines = [line.strip() for line in sys.stdin if line.strip() != '']\n\n    # 若沒有任何輸入，使用預設的兩個學生\n    if not raw_lines:\n        s1 = Student('Alice', 90)\n        s2 = Student('Bob', 80)\n        s1.show_info()\n        s2.show_info()\n        return\n\n    # 嘗試把第一行當作學生數量\n    try:\n        num_students = int(raw_lines[0])\n        data_lines = raw_lines[1:]\n    except ValueError:\n        # 第一行不是整數，則假設所有行都是「姓名 分數」\n        num_students = len(raw_lines)\n        data_lines = raw_lines\n\n    students = []\n\n    # 解析每個學生的資料\n    for i in range(min(num_students, len(data_lines))):\n        parts = data_lines[i].split()\n        if len(parts) >= 2:\n            name = parts[0]\n            try:\n                score = int(parts[1])\n            except ValueError:\n                score = 0  # 無法轉成整數時預設為 0\n            students.append(Student(name, score))\n\n    # 顯示所有學生的資訊\n    for stu in students:\n        stu.show_info()\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code line by line with explanation. Use Start, →, Decision: but no decision needed. Just simple class definition, methods, instantiation. Format: each line: \"虛擬碼步驟 // 解釋\". Use arrow for steps. Eg:\n\nStart // 程式開始執行\n→ Define Class Student // 定義 Student 類別\n→     Step 1: 定義 __init__(self, name, score) // 建構子初始化姓名與分數\n→     Step 2: set self.name = name // 設定姓名\n→     Step 3: set self.score = score // 設定分數\n→     Step 4: 定義 show_info(self) // 定義顯示方法\n→         Output f\"{self.name} 的分數是 {self.score}\" // 輸出資訊\n→ Instantiate student1 = Student(\"Alice\", 90) // 建立第一個學生物件\n→ Call student1.show_info() // 呼叫顯示方法\n→ Instantiate student2 = Student(\"Bob\", 75) // 建立第二個學生物件\n→ Call student2.show_info() // 呼叫顯示方法\nEnd // 程式執行結束\n\nMake sure format: arrow lines start with →. Use indentation? In virtual code we can indent with spaces. Use // after line. Good.\n...done thinking.\n\nStart // 程式開始執行  \n→ Define Class Student // 定義 Student 類別  \n→     Step 1: 定義 __init__(self, name, score) // 建構子，接收姓名與分數  \n→         Set self.name = name // 將姓名存入物件屬性  \n→         Set self.score = score // 將分數存入物件屬性  \n→     Step 2: 定義 show_info(self) // 定義顯示資訊的方法  \n→         Output f\"{self.name} 的分數是 {self.score}\" // 輸出『姓名 的分數是 分數』  \n→ Instantiate student1 = Student(\"Alice\", 90) // 建立第一個 Student 物件  \n→ Call student1.show_info() // 呼叫第一個物件的顯示方法  \n→ Instantiate student2 = Student(\"Bob\", 75) // 建立第二個 Student 物件  \n→ Call student2.show_info() // 呼叫第二個物件的顯示方法  \nEnd // 程式執行結束"
    },
    {
      "title": "集合函數練習",
      "source_file": "600.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "{'apple', 'orange', 'grape', 'melon'}",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '{\"apple\",\"orange\",\"grape\",\"melon\"}'\nGot (Norm):      '{\"apple\",\"melon\",\"orange\",\"grape\"}'\n--- (Raw) ---\nRaw Expected: \"{'apple', 'orange', 'grape', 'melon'}\"\nRaw Got:      \"{'apple', 'melon', 'orange', 'grape'}\""
        }
      ],
      "generated_code": "import sys\n\ndef main() -> None:\n    # 讀取所有輸入（如果有的話），但本程式不依賴任何輸入\n    sys.stdin.read()\n\n    # 初始化集合\n    fruits = {'apple', 'banana'}\n\n    # 1. 使用 add() 新增 'orange'\n    fruits.add('orange')\n\n    # 2. 使用 update() 一次新增 'grape' 與 'melon'\n    fruits.update({'grape', 'melon'})\n\n    # 3. 使用 remove() 移除 'banana'\n    fruits.remove('banana')\n\n    # 4. 使用 discard() 嘗試移除 'pineapple'（不存在的元素）\n    fruits.discard('pineapple')\n\n    # 輸出最終集合\n    print(fruits)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output in the required format: each line \"虛擬碼步驟 // 解釋\". Use Start, End, Decision, arrows. Since no decision needed, just sequential steps. But could include decisions for remove? Remove will error if element missing; we are told to use remove() to remove banana, which exists. So no error. Discard removes if exists, else no error. So just steps. Need to follow format: \"Start\" then \"→ Step X: ...\" etc.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 建立 fruits = {'apple', 'banana'} // 初始化集合\n→ Step 2: fruits.add('orange') // 使用 add() 新增元素\n→ Step 3: fruits.update({'grape', 'melon'}) // 使用 update() 一次新增多個元素\n→ Step 4: fruits.remove('banana') // 移除存在的元素\n→ Step 5: fruits.discard('pineapple') // 嘗試移除不存在的元素，無效但不錯誤\n→ Step 6: 輸出 fruits // 顯示最終集合\nEnd // 程式結束\n\nNeed to match format exactly. Each line with \"虛擬碼步驟 // 解釋\". Use arrow \"→\". Also \"Start\" and \"End\". The virtual code steps may include the arrow and colon. Provide explanation after //.\n\nLet's produce accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立 fruits = {'apple', 'banana'} // 初始化集合\n→ Step 2: fruits.add('orange') // 使用 add() 新增 'orange'\n→ Step 3: fruits.update({'grape', 'melon'}) // 使用 update() 一次新增 'grape' 與 'melon'\n→ Step 4: fruits.remove('banana') // 移除 'banana'\n→ Step 5: fruits.discard('pineapple') // 嘗試移除不存在的 'pineapple'，不會產生錯誤\n→ Step 6: 輸出 fruits // 顯示最終集合\nEnd // 程式執行結束"
    },
    {
      "title": "即時匯率查詢小工具",
      "source_file": "1200.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "按下「更新匯率」按鈕",
          "expected_output": "目前美元匯率：約 32.5 TWD",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '目前美元匯率：約32.5TWD'\nGot (Norm):      '目前美元匯率：約30.6000TWD'\n--- (Raw) ---\nRaw Expected: '目前美元匯率：約 32.5 TWD'\nRaw Got:      '目前美元匯率：約 30.6000 TWD'"
        }
      ],
      "generated_code": "import sys\nimport requests\nimport tkinter as tk\nfrom tkinter import messagebox\n\n# -----------------------------------------------\n# 取得 USD 兌 TWD 的匯率\n# -----------------------------------------------\ndef fetch_rate() -> float:\n    \"\"\"\n    從 exchangerate-api 取得最新 USD→TWD 匯率。\n    成功時回傳浮點數匯率；失敗時回傳 None。\n    \"\"\"\n    url = \"https://api.exchangerate-api.com/v4/latest/USD\"\n    try:\n        resp = requests.get(url, timeout=10)\n        resp.raise_for_status()\n        data = resp.json()\n        return float(data[\"rates\"][\"TWD\"])\n    except Exception:\n        return None\n\n# -----------------------------------------------\n# GUI 相關\n# -----------------------------------------------\ndef create_gui():\n    \"\"\"\n    建立 tkinter 視窗，提供按鈕更新匯率並顯示結果。\n    \"\"\"\n    win = tk.Tk()\n    win.title(\"美元兌換台幣匯率\")\n\n    # 文字顯示區\n    label = tk.Label(win, text=\"請按下『更新匯率』按鈕\", font=(\"Arial\", 12))\n    label.pack(pady=10)\n\n    # 按鈕：點擊時更新匯率\n    def on_update():\n        rate = fetch_rate()\n        if rate is None:\n            messagebox.showerror(\"錯誤\", \"無法取得匯率，請檢查網路\")\n            label.config(text=\"更新失敗\")\n        else:\n            label.config(text=f\"目前美元匯率：約 {rate:.4f} TWD\")\n\n    tk.Button(win, text=\"更新匯率\", command=on_update, width=15).pack(pady=5)\n\n    win.mainloop()\n\n# -----------------------------------------------\n# main 區塊：處理 stdin，並在適當時候啟動 GUI\n# -----------------------------------------------\ndef main():\n    \"\"\"\n    主程式入口。\n    1. 先從標準輸入讀取文字。\n    2. 若文字包含「更新匯率」關鍵字，則取得匯率並輸出。\n    3. 若沒有輸入，則啟動 tkinter GUI。\n    \"\"\"\n    input_text = sys.stdin.read().strip()\n    if input_text:\n        # 若輸入文字中有「更新匯率」相關關鍵字，回傳匯率資訊\n        if \"更新匯率\" in input_text or \"按下\" in input_text:\n            rate = fetch_rate()\n            if rate is not None:\n                print(f\"目前美元匯率：約 {rate:.4f} TWD\")\n            else:\n                print(\"無法取得匯率，請檢查網路\")\n        else:\n            # 其餘輸入直接不做處理\n            pass\n    else:\n        # 沒有輸入時顯示 GUI\n        create_gui()\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations. Format: Each line: \"虛擬碼步驟 // 解釋\". Using arrows, Start, End, Decision. The code should describe steps: import modules, create Tk window, define function to fetch rate, update label, button to trigger, mainloop. Use decision? maybe check response status. We'll produce step by step.\n\nWe must not output actual code, only virtual steps. Let's produce lines.\n\nWe need to use arrow symbols, \"→\". Use \"Start // 程式開始執行\". Then lines.\n\nWe'll also include Decision for HTTP status code? Yes: check if status 200.\n\nAlso Decision for if response has \"rates\" and \"TWD\".\n\nUse Yes → ... No → ... to show error.\n\nAlso step to parse JSON.\n\nAdd step to update label text.\n\nLet's craft.\n\nRemember each line must be: \"虛擬碼步驟 // 解釋\". So include arrow. We'll write \"→ Step 1: 載入 requests 與 tkinter // 引入所需模組\".\n\nAlso note that the arrow leads to next step.\n\nWe also need to handle main loop.\n\nLet's produce.\n\nMake sure formatting correct.\n\nLet's start.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Step 1: 載入 requests 與 tkinter // 引入 HTTP 與 GUI 所需模組\n→ Step 2: 建立 Tkinter 視窗 window, 設定標題 // 初始化 GUI 視窗\n→ Step 3: 新增 Label label_rate 用於顯示匯率 // 準備顯示匯率的文字\n→ Step 4: 新增 Button btn_update 觸發 fetch_rate // 按鈕觸發匯率更新\n→ Step 5: 定義函式 fetch_rate() // 取得匯率的邏輯\n→     → Decision: 是否有網路連線？ // 檢查能否發送 HTTP 請求\n→         Yes → Step 6: 使用 requests.get('https://api.exchangerate-api.com/v4/latest/USD') // 送出 GET 請求\n→         No  → Step 7: 將 label_rate 顯示 '無法連線' // 顯示錯誤訊息\n→ Step 8: Decision: 回傳碼 status_code 是否為 200? // 確認請求成功\n→     Yes → Step 9: 解析 JSON 內容 data = response.json() // 轉換回應為字典\n→     No  → Step 10: 將 label_rate 顯示 '請求失敗' // 顯示失敗訊息\n→ Step 11: Decision: data 中是否含有 'rates' 且 'TWD'？ // 檢查資料結構\n→     Yes → Step 12: rate = data['rates']['TWD'] // 取得台幣匯率\n→     No  → Step 13: 將 label_rate 顯示 '資料格式錯誤' // 顯示錯誤訊息\n→ Step 14: 更新 label_rate 內容為 f'1 USD = {rate} TWD' // 顯示匯率\n→ Step 15: 把 btn_update 綁定到 fetch_rate // 連結按鈕與函式\n→ Step 16: 進入 Tkinter 主循環 window.mainloop() // 開始 GUI 事件處理\nEnd // 程式執行結束\n\nNeed to include \"→\" before Step 15? In our formatting each line must be \"虛擬碼步驟 // 解釋\". We can just start each line with \"→\". However the Start line should not have arrow? In example Start is just \"Start // 程式開始執行\". We'll follow that.\n\nAlso we need to indent nested decisions maybe not needed. We can represent by indenting spaces before lines. But maybe simpler to keep all lines at same level. The example used indentation in nested steps. We'll do same.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 載入 requests 與 tkinter // 引入 HTTP 與 GUI 所需模組  \n→ Step 2: 建立 Tkinter 視窗 window, 設定標題 // 初始化 GUI 視窗  \n→ Step 3: 新增 Label label_rate 用於顯示匯率 // 準備顯示匯率的文字  \n→ Step 4: 新增 Button btn_update 觸發 fetch_rate // 按鈕觸發匯率更新  \n→ Step 5: 定義函式 fetch_rate() // 取得匯率的邏輯  \n  → Decision: 是否有網路連線？ // 檢查能否發送 HTTP 請求  \n   Yes → Step 6: 使用 requests.get('https://api.exchangerate-api.com/v4/latest/USD') // 送出 GET 請求  \n   No  → Step 7: 將 label_rate 顯示 '無法連線' // 顯示錯誤訊息  \n  → Step 8: Decision: 回傳碼 status_code 是否為 200? // 確認請求成功  \n   Yes → Step 9: 解析 JSON 內容 data = response.json() // 轉換回應為字典  \n   No  → Step 10: 將 label_rate 顯示 '請求失敗' // 顯示失敗訊息  \n  → Step 11: Decision: data 中是否含有 'rates' 且 'TWD'？ // 檢查資料結構  \n   Yes → Step 12: rate = data['rates']['TWD'] // 取得台幣匯率  \n   No  → Step 13: 將 label_rate 顯示 '資料格式錯誤' // 顯示錯誤訊息  \n  → Step 14: 更新 label_rate 內容為 f'1 USD = {rate} TWD' // 顯示匯率  \n→ Step 15: 把 btn_update 綁定到 fetch_rate // 連結按鈕與函式  \n→ Step 16: 進入 Tkinter 主循環 window.mainloop() // 開始 GUI 事件處理  \nEnd // 程式執行結束"
    },
    {
      "title": "Heaters",
      "source_file": "Leetcode/leetcode475.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "houses = [1,2,3], heaters = [2]",
          "expected_output": "1",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpuwhtygo5.py\", line 33, in <module>\n    houses = [int(x) for x in parts[0].strip('[]').split(',')] if parts else []\n              ^^^^^^\nValueError: invalid literal for int() with base 10: 'houses'"
        },
        {
          "example_index": 1,
          "input": "houses = [1,2,3,4], heaters = [1,4]",
          "expected_output": "1",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpcvpnz8zj.py\", line 33, in <module>\n    houses = [int(x) for x in parts[0].strip('[]').split(',')] if parts else []\n              ^^^^^^\nValueError: invalid literal for int() with base 10: 'houses'"
        },
        {
          "example_index": 2,
          "input": "houses = [1,5], heaters = [2]",
          "expected_output": "3",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpoi28z2dm.py\", line 33, in <module>\n    houses = [int(x) for x in parts[0].strip('[]').split(',')] if parts else []\n              ^^^^^^\nValueError: invalid literal for int() with base 10: 'houses'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findRadius(self, houses, heaters):\n        houses.sort()\n        heaters.sort()\n        res = 0\n        i = 0  # 最近的右邊暖氣器索引\n\n        for house in houses:\n            # 將 i 移動到離 house 最近的暖氣器\n            while i < len(heaters) - 1 and abs(heaters[i + 1] - house) <= abs(heaters[i] - house):\n                i += 1\n            # 取距離最大值\n            res = max(res, abs(heaters[i] - house))\n        return res\n\ndef parse_list(expr: str):\n    \"\"\"將類似 'houses = [1,2,3]' 的字串轉成 list。\"\"\"\n    _, value = expr.split('=', 1)\n    return ast.literal_eval(value.strip())\n\nif __name__ == \"__main__\":\n    # 讀取所有非空行\n    raw_lines = [line.strip() for line in sys.stdin if line.strip()]\n    if len(raw_lines) >= 2:\n        houses = parse_list(raw_lines[0])\n        heaters = parse_list(raw_lines[1])\n    else:\n        # 若只有一行，假設用空格分隔兩組數據\n        parts = raw_lines[0].split()\n        houses = [int(x) for x in parts[0].strip('[]').split(',')] if parts else []\n        heaters = [int(x) for x in parts[1].strip('[]').split(',')] if len(parts) > 1 else []\n\n    solution = Solution()\n    radius = solution.findRadius(houses, heaters)\n    print(radius)",
      "virtual_code": "Thinking...\nWe need to produce pseudocode step by step with explanation per line. Task: design algorithm to find minimal radius to cover all houses with heaters positions. Standard problem: houses sorted, heaters sorted; for each house, find nearest heater distance. Minimal radius is max of these distances. Approach: sort houses and heaters. For each house, binary search to find nearest heater, compute distance. Keep max. Return max. Complexity O((n+m) log m). Provide pseudocode.\n\nWe need to output step-by-step lines: Start, Step lines, Decision lines etc. Use arrow. Each line includes code step + comment.\n\nWe'll produce pseudocode lines:\n\nStart\n→ Step 1: Sort houses ascending // sort house positions\n→ Step 2: Sort heaters ascending // sort heater positions\n→ Step 3: Initialize maxRadius = 0 // track maximum minimal distance\n→ Step 4: For each house in houses // iterate houses\n    → Step 5: Find index of first heater >= house using binary search // lower_bound\n    → Decision: If index == length(heaters) // no heater to the right\n        Yes → Step 6: distance = house - heaters[index-1] // only left heater\n        No  → Decision: If index == 0 // no heater to left\n            Yes → Step 7: distance = heaters[0] - house // only right heater\n            No  → Step 8: distance = min(house - heaters[index-1], heaters[index] - house) // both sides\n    → Step 9: If distance > maxRadius // update max\n        Yes → Step 10: maxRadius = distance\nEnd // return maxRadius\n\nNeed to include return line before End.\n\nAdd Return statement: → Step 11: Return maxRadius // minimal required radius\n\nWe need to ensure correct formatting: each line ends with // comment. Use \"→\" arrows.\n\nAlso decisions indentation. Use spaces.\n\nLet's produce final.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: Sort houses ascending // 將所有房屋位置由小到大排序\n→ Step 2: Sort heaters ascending // 將所有暖氣位置由小到大排序\n→ Step 3: Initialize maxRadius = 0 // 用於儲存目前需要的最大暖氣半徑\n→ Step 4: For each house in houses // 逐一處理每一個房屋\n    → Step 5: Find index = lower_bound(heaters, house) // 找到第一個暖氣位置不小於房屋的位置\n    → Decision: 如果 index 等於 heaters 的長度? // 沒有右側暖氣可用\n        Yes → Step 6: distance = house - heaters[index-1] // 只可用左側暖氣，計算距離\n        No  → Decision: 如果 index 等於 0? // 沒有左側暖氣可用\n            Yes → Step 7: distance = heaters[0] - house // 只可用右側暖氣，計算距離\n            No  → Step 8: distance = min(house - heaters[index-1], heaters[index] - house) // 兩側都有暖氣，取最近距離\n    → Step 9: If distance 大於 maxRadius? // 更新目前所需的最大半徑\n        Yes → Step 10: maxRadius = distance // 將較大值存回\n→ Step 11: Return maxRadius // 回傳最小可覆蓋所有房屋的暖氣半徑\nEnd // 程式執行結束\n```"
    },
    {
      "title": "License Key Formatting",
      "source_file": "Leetcode/leetcode482.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"5F3Z-2e-9-w\", k = 4",
          "expected_output": " \"5F3Z-2E9W\"",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp0ret2wwx.py\", line 24, in <module>\n    k = int(parts[1].strip())\n        ^^^^^^^^^^^^^^^^^^^^^\nValueError: invalid literal for int() with base 10: 'k = 4'"
        },
        {
          "example_index": 1,
          "input": "s = \"2-5g-3-J\", k = 2",
          "expected_output": "\"2-5G-3J\"",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp11u9x9cv.py\", line 24, in <module>\n    k = int(parts[1].strip())\n        ^^^^^^^^^^^^^^^^^^^^^\nValueError: invalid literal for int() with base 10: 'k = 2'"
        }
      ],
      "generated_code": "class Solution:\n    def licenseKeyFormatting(self, S: str, K: int) -> str:\n        # 移除所有 '-' 並轉為大寫\n        S = S.replace('-', '').upper()\n        n = len(S)\n        if n == 0:\n            return \"\"\n        # 第一組長度，若 n%K 為 0 則整個為 K\n        first_group_len = n % K or K\n        # 組裝結果\n        res = [S[:first_group_len]]\n        for i in range(first_group_len, n, K):\n            res.append(S[i:i+K])\n        return '-'.join(res)\n\nif __name__ == \"__main__\":\n    import sys\n\n    data = sys.stdin.read().strip().splitlines()\n    if len(data) < 2:\n        # 如果輸入格式只有一行，嘗試用逗號分割\n        parts = data[0].split(',')\n        s = parts[0].strip().strip('\"').strip(\"'\")\n        k = int(parts[1].strip())\n    else:\n        s = data[0].strip()\n        k = int(data[1].strip())\n\n    solution = Solution()\n    result = solution.licenseKeyFormatting(s, k)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps for license key formatting.\n\nWe need to output each line as \"虛擬碼步驟 // 解釋\".\n\nWe must use arrows and structure Start, End, Decision: etc. Use \"→\" for step lines, \"Yes →\" and \"No →\" for decision branches.\n\nWe need to generate a logical step-by-step algorithm: remove dashes, convert to uppercase, then create groups of size k from end, etc.\n\nSteps: Start. Step1: remove dashes and convert to uppercase. Step2: compute length L. Step3: determine first group size = L % k if non-zero else k. Step4: build result string: take first group, then for i from first_size to L, step k: add '-' + substring. Step5: return result. End.\n\nNeed to produce line by line, with explanation. Use virtual code arrow. For loops and decisions use appropriate format. We should include Decision: if length>0 etc.\n\nLet's produce.\n\nStart // 程式開始執行\n→ Step 1: 清除 s 中的 '-' 並轉為大寫，結果存於 cleaned // 移除破折號並統一大寫\n→ Step 2: 計算 cleaned 的長度 L // 獲得純文字長度\n→ Decision: L == 0? // 檢查是否為空字串\n    Yes → Step 3: 回傳空字串 // 空輸入直接返回\n    No  → Step 4: 計算 firstGroup = L % k，若 firstGroup == 0 則 firstGroup = k // 決定第一組長度\n→ Step 5: 初始化 result 為 cleaned 的前 firstGroup 字元 // 取得第一組\n→ Decision: firstGroup == L? // 是否已覆蓋整個字串\n    Yes → Step 6: 回傳 result // 若已完整，直接回傳\n    No  → Step 7: 從 i = firstGroup 到 L-1 以步進 k 進行迴圈\n        → Step 8: 在 result 末尾追加 '-' + cleaned 的子字串從 i 到 i+k-1 // 加入後續組\n→ Step 9: 回傳 result // 完成格式化\nEnd // 程式執行結束\n\nBut need arrow for Step 7 loop; we can write as \"→ Step 7: for i in range(firstGroup, L, k) // 迴圈從第一個完整組開始\". Then inside loop Step 8. Provide explanation.\n\nAlso, we need to include virtual code arrows; \"→\" for step lines. For decision we use \"Decision:\" etc. Provide arrow after decision lines \"Yes →\" \"No →\".\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 清除 s 中的 '-' 並轉為大寫，結果存於 cleaned // 移除破折號並統一大寫  \n→ Step 2: 計算 cleaned 的長度 L // 獲得純文字長度  \n→ Decision: L == 0? // 檢查是否為空字串  \n  Yes → Step 3: 回傳空字串 // 空輸入直接返回  \n  No  → Step 4: 計算 firstGroup = L % k，若 firstGroup == 0 則 firstGroup = k // 決定第一組長度  \n→ Step 5: 初始化 result 為 cleaned 的前 firstGroup 字元 // 取得第一組  \n→ Decision: firstGroup == L? // 是否已覆蓋整個字串  \n  Yes → Step 6: 回傳 result // 若已完整，直接回傳  \n  No  → Step 7: 從 i = firstGroup 到 L-1 以步進 k 進行迴圈 // 從第二組開始處理  \n    → Step 8: 在 result 末尾追加 '-' + cleaned 的子字串從 i 到 i+k-1 // 加入後續組  \n→ Step 9: 回傳 result // 完成格式化  \nEnd // 程式執行結束"
    },
    {
      "title": "Find All Anagrams in a String",
      "source_file": "Leetcode/leetcode438.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"cbaebabacd\", p = \"abc\"",
          "expected_output": "[0,6]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[0,6]'\nGot (Norm):      '[0]'\n--- (Raw) ---\nRaw Expected: '[0,6]'\nRaw Got:      '[0]'"
        },
        {
          "example_index": 1,
          "input": "s = \"abab\", p = \"ab\"",
          "expected_output": "[0,1,2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[0,1,2]'\nGot (Norm):      '[0]'\n--- (Raw) ---\nRaw Expected: '[0,1,2]'\nRaw Got:      '[0]'"
        }
      ],
      "generated_code": "import sys\nfrom collections import Counter\n\nclass Solution:\n    def findAnagrams(self, s: str, p: str) -> list[int]:\n        ns, np = len(s), len(p)\n        if ns < np:\n            return []\n\n        p_count = Counter(p)\n        s_count = Counter(s[:np])\n        res = []\n\n        if s_count == p_count:\n            res.append(0)\n\n        for i in range(1, ns - np + 1):\n            # Remove the leftmost character of the previous window\n            left_char = s[i - 1]\n            s_count[left_char] -= 1\n            if s_count[left_char] == 0:\n                del s_count[left_char]\n            # Add the new character entering the window\n            right_char = s[i + np - 1]\n            s_count[right_char] += 1\n\n            if s_count == p_count:\n                res.append(i)\n\n        return res\n\ndef parse_input(data: str) -> tuple[str, str]:\n    \"\"\"\n    Try to parse input that can be in one of two common formats:\n    1. s = \"string\", p = \"string\"\n    2. two lines: first line is s, second line is p\n    \"\"\"\n    data = data.strip()\n    if ',' in data:\n        parts = data.split(',', 1)\n        s_part, p_part = parts[0], parts[1]\n        s = ''.join(part for part in s_part.split('=') if '\"' in part).strip('\"')\n        p = ''.join(part for part in p_part.split('=') if '\"' in part).strip('\"')\n        return s, p\n    else:\n        lines = [line.strip() for line in data.splitlines() if line.strip()]\n        if len(lines) >= 2:\n            return lines[0], lines[1]\n        raise ValueError(\"Input format not recognized\")\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    try:\n        s, p = parse_input(raw_input)\n    except Exception:\n        # Fallback: treat entire input as two space separated strings\n        parts = raw_input.strip().split()\n        s, p = parts[0], parts[1] if len(parts) > 1 else ''\n    solution = Solution()\n    result = solution.findAnagrams(s, p)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for algorithm: sliding window, counting frequency of p and window of s, moving window, checking equality.\n\nOutput each line: \"虛擬碼步驟 // 解釋\" with arrow etc. Use Start, End, Decision. Each step: maybe variables: startIndex, windowCounts, pCounts, result array.\n\nWe must not output actual code, only structure. Provide line by line.\n\nLet's craft:\n\nStart // Start\n→ Step 1: Initialize result array // store indices\n→ Step 2: If s length < p length → No → End // no anagrams possible\n→ Decision: Initialize frequency maps for p and first window of s // maps\n    Yes → Step 3: Build pCounts from p\n    Yes → Step 4: Build windowCounts from first p length of s\n→ Step 5: If windowCounts equals pCounts → Yes → Step 6: Append 0 to result\n→ Decision: For i from p.length to s.length-1\n    Yes → Step 7: Add s[i] to windowCounts\n    Yes → Step 8: Remove s[i - p.length] from windowCounts\n    Yes → Step 9: If windowCounts equals pCounts → Yes → Step 10: Append i - p.length +1 to result\n→ End // finished\n\nBut need arrows and proper formatting: Use \"→\" for sequence, \"Decision:\" for decision point, indent Yes/No arrows.\n\nLet's produce each line.\n\nLine 1: Start // 程式開始執行\n\nLine 2: → Step 1: 初始化結果陣列 result // 用於儲存所有符合的起始索引\n\nLine 3: → Step 2: 檢查 s 與 p 的長度是否符合 // 若 s 長度小於 p，無法找到任何字母重組\n\nLine 4:    Decision: 如果 s.length < p.length? // 判斷長度關係\n\nLine 5:        No  → End // 不足長度直接結束程式\n\nLine 6:    Yes → Step 3: 建立 p 的字母頻率表 pCount // 記錄 p 中每個字母出現的次數\n\nLine 7:    Yes → Step 4: 建立 s 前 p.length 個字母的頻率表 windowCount // 初始滑動窗口\n\nLine 8: → Step 5: 比較 windowCount 與 pCount 是否相等 // 判斷首個窗口是否為字母重組\n\nLine 9:    Decision: 如果相等? // 是否為字母重組\n\nLine 10:        Yes → Step 6: 將 0 加入 result // 第一個窗口的起始索引\n\nLine 11:    No  → // 若不相等，繼續後續步驟\n\nLine 12: → Step 7: 將指標 i 從 p.length 開始遍歷至 s.length-1 // 滑動窗口移動\n\nLine 13:    Decision: For i = p.length; i < s.length; i++ // 循環條件\n\nLine 14:        Yes → Step 8: 增加 s[i] 的計數至 windowCount // 新進字母進入窗口\n\nLine 15:        Yes → Step 9: 減少 s[i - p.length] 的計數於 windowCount // 退出字母離開窗口\n\nLine 16:        Yes → Step 10: 比較 windowCount 與 pCount 是否相等 // 判斷新窗口是否為字母重組\n\nLine 17:            Decision: 如果相等? // 是否為字母重組\n\nLine 18:                Yes → Step 11: 將 i - p.length + 1 加入 result // 新窗口起始索引\n\nLine 19:                No  → // 若不相等，繼續下一個 i\n\nLine 20: → End // 程式執行結束\n\nBut need to align indent with Yes/No. Provide arrow indent. Also use consistent \"→\" before each step; for decision, indent the Yes/No.\n\nBetter:\n\nStart // 程式開始執行\n→ Step 1: 初始化 result // 用於儲存所有符合的起始索引\n→ Step 2: 檢查 s 與 p 的長度是否符合 // 若 s 長度小於 p，無法找到任何字母重組\n    Decision: 如果 s.length < p.length? // 判斷長度關係\n        No  → End // 不足長度直接結束程式\n        Yes → Step 3: 建立 p 的字母頻率表 pCount // 記錄 p 中每個字母出現的次數\n        Yes → Step 4: 建立 s 前 p.length 個字母的頻率表 windowCount // 初始滑動窗口\n→ Step 5: 比較 windowCount 與 pCount 是否相等 // 判斷首個窗口是否為字母重組\n    Decision: 如果相等?\n        Yes → Step 6: 將 0 加入 result // 第一個窗口的起始索引\n        No  → // 若不相等，繼續後續步驟\n→ Step 7: 循環 i 從 p.length 開始至 s.length-1 // 滑動窗口移動\n    Decision: i < s.length? // 循環條件\n        Yes → Step 8: 增加 s[i] 的計數至 windowCount // 新進字母進入窗口\n        Yes → Step 9: 減少 s[i - p.length] 的計數於 windowCount // 退出字母離開窗口\n        Yes → Step 10: 比較 windowCount 與 pCount 是否相等 // 判斷新窗口是否為字母重組\n            Decision: 如果相等?\n                Yes → Step 11: 將 i - p.length + 1 加入 result // 新窗口起始索引\n                No  → // 若不相等，繼續下一個 i\n→ End // 程式執行結束\n\nWe need to keep arrow for each line. Ensure each line ends with \"// 解釋\".\n\nCheck lines: line 2,3,4,5 etc.\n\nAlso we might want to avoid repeating \"Yes →\" for each step, but we can keep.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 result // 用於儲存所有符合的起始索引  \n→ Step 2: 檢查 s 與 p 的長度是否符合 // 若 s 長度小於 p，無法找到任何字母重組  \n Decision: 如果 s.length < p.length? // 判斷長度關係  \n  No  → End // 不足長度直接結束程式  \n  Yes → Step 3: 建立 p 的字母頻率表 pCount // 記錄 p 中每個字母出現的次數  \n  Yes → Step 4: 建立 s 前 p.length 個字母的頻率表 windowCount // 初始滑動窗口  \n→ Step 5: 比較 windowCount 與 pCount 是否相等 // 判斷首個窗口是否為字母重組  \n Decision: 如果相等? // 是否為字母重組  \n  Yes → Step 6: 將 0 加入 result // 第一個窗口的起始索引  \n  No  → // 若不相等，繼續後續步驟  \n→ Step 7: 循環 i 從 p.length 開始至 s.length-1 // 滑動窗口移動  \n Decision: i < s.length? // 循環條件  \n  Yes → Step 8: 增加 s[i] 的計數至 windowCount // 新進字母進入窗口  \n  Yes → Step 9: 減少 s[i - p.length] 的計數於 windowCount // 退出字母離開窗口  \n  Yes → Step 10: 比較 windowCount 與 pCount 是否相等 // 判斷新窗口是否為字母重組  \n   Decision: 如果相等? // 是否為字母重組  \n    Yes → Step 11: 將 i - p.length + 1 加入 result // 新窗口起始索引  \n    No  → // 若不相等，繼續下一個 i  \n→ End // 程式執行結束"
    },
    {
      "title": "Intersection of Two Arrays",
      "source_file": "Leetcode/leetcode349.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "nums1 = [4,9,5], nums2 = [9,4,9,8,4]",
          "expected_output": "[9,4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[9,4]'\nGot (Norm):      '[4,9]'\n--- (Raw) ---\nRaw Expected: '[9,4]'\nRaw Got:      '[4, 9]'"
        }
      ],
      "generated_code": "class Solution:\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        返回 nums1 與 nums2 的唯一交集元素列表。\n        \"\"\"\n        return list(set(nums1) & set(nums2))\n\nif __name__ == \"__main__\":\n    import sys\n    import re\n\n    # 讀取整個標準輸入\n    data = sys.stdin.read()\n\n    # 透過正則表達式抓取第一個與第二個中括號內的內容\n    lists = re.findall(r'\\[.*?\\]', data)\n\n    # 若成功抓到兩個列表，則使用 eval 轉為 Python list\n    if len(lists) >= 2:\n        nums1 = eval(lists[0])\n        nums2 = eval(lists[1])\n    else:\n        nums1, nums2 = [], []\n\n    # 執行交集計算\n    solution = Solution()\n    result = solution.intersection(nums1, nums2)\n\n    # 讓輸出順序可預期，若不需要可以註解此行\n    result.sort()\n\n    # 將結果列印到標準輸出\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line. For the problem: intersection of two integer arrays, unique elements. Likely steps: create set from nums1, create set from nums2, compute intersection, convert to list, return. Steps in virtual code: Start, Step1: create setA from nums1, Step2: create setB from nums2, Step3: compute intersectionSet = setA ∩ setB, Step4: convert to array/list, End. We need arrow syntax. Provide explanation after each line. Use \"→\" arrow. Use Decision? maybe not necessary. Provide simple sequential steps. Use Start and End. Use [space] between code and comment. Example format: \"Start // 程式開始執行\".\n\nWe should use Chinese explanation. Each line has virtual code step then // explanation.\n\nWe need to show each step: Step 1: Initialize setA from nums1 // convert array to set to remove duplicates.\n\nStep 2: Initialize setB from nums2 // convert array to set.\n\nStep 3: Compute intersectionSet = setA ∩ setB // set intersection to get unique common elements.\n\nStep 4: Convert intersectionSet to list/array // prepare result.\n\nStep 5: Return result // end.\n\nWe could use \"→ Step 1: ...\" but we also need Start arrow? Usually we start with \"Start\". Then arrow to Step 1. Then arrow to Step 2, etc. Each arrow line with code.\n\nWe must not include any actual code like setA = new HashSet<>(nums1). But \"Step 1: 建立 nums1 的集合 setA\" is fine. Use \"→\" arrow. Format: \"→ Step 1: ... // ...\". So produce like:\n\nStart // 程式開始執行\n→ Step 1: 建立 nums1 的集合 setA // 轉換第一個陣列為集合，去除重複\n→ Step 2: 建立 nums2 的集合 setB // 轉換第二個陣列為集合，去除重複\n→ Step 3: 計算集合相交 intersectionSet = setA ∩ setB // 取得兩集合共有的唯一元素\n→ Step 4: 將 intersectionSet 轉為陣列 resultArray // 方便回傳\n→ Step 5: 回傳 resultArray // 程式結束\nEnd // 程式執行結束\n\nBut need \"→\" arrow from Start to Step1. Use arrow after Start? The example shows \"→ Step 1:\". So Start line separate. Then arrow lines. After last step arrow to End? The example does not show arrow before End. End is separate line. Good.\n\nMake sure each line includes code and // explanation.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 nums1 的集合 setA // 轉換第一個陣列為集合，去除重複  \n→ Step 2: 建立 nums2 的集合 setB // 轉換第二個陣列為集合，去除重複  \n→ Step 3: 計算集合相交 intersectionSet = setA ∩ setB // 取得兩集合共有的唯一元素  \n→ Step 4: 將 intersectionSet 轉為陣列 resultArray // 方便回傳  \n→ Step 5: 回傳 resultArray // 程式結束  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick Index",
      "source_file": "Leetcode/leetcode398.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\"], [[[1, 2, 3, 3, 3]], [3], [1], [3]]",
          "expected_output": "[null, 4, 0, 2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,4,0,2]'\nGot (Norm):      '[null,2,0,3]'\n--- (Raw) ---\nRaw Expected: '[null, 4, 0, 2]'\nRaw Got:      '[null, 2, 0, 3]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, nums):\n        # Store the original array; no extra preprocessing needed\n        self.nums = nums\n\n    def pick(self, target):\n        # Reservoir sampling: each matching index has equal chance to be chosen\n        result = -1\n        count = 0\n        for i, num in enumerate(self.nums):\n            if num == target:\n                count += 1\n                # With probability 1/count pick the current index\n                if random.randint(1, count) == 1:\n                    result = i\n        return result\n\nif __name__ == \"__main__\":\n    # Read the entire input from stdin\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n\n    # Parse the input into two parts: commands and arguments\n    # Input format: [\"Command1\", \"Command2\", ...], [args1, args2, ...]\n    # Wrap with parentheses to make it a tuple for literal_eval\n    commands, args_list = ast.literal_eval(\"(\" + raw_input + \")\")\n\n    instance = None\n    outputs = []\n\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"Solution\":\n            # Initialize the Solution object\n            instance = Solution(*args)\n            outputs.append(None)\n        else:\n            # Call the corresponding method on the instance\n            method = getattr(instance, cmd)\n            result = method(*args)\n            outputs.append(result)\n\n    # Convert Python None to JSON null and print the result list\n    print(json.dumps(outputs))",
      "virtual_code": "Thinking...\nWe need to output virtual code steps for this algorithm. We need to describe the logic for constructor and pick method. Use Start/End, Decision, arrow. Provide explanation comments. No actual code.\n\nWe need to think algorithm: We need to randomly pick index with equal probability. Approach: In constructor, store array and maybe a mapping from target to list of indices, but that would be extra memory. Alternatively, pick method can use reservoir sampling: iterate over array, if nums[i]==target, increment count and pick index with probability 1/count. That ensures equal probability.\n\nSo steps: In constructor: store nums array. In pick: initialize count=0, chosenIndex=-1; for i from 0 to len-1: if nums[i]==target: count++; if random() < 1/count: chosenIndex = i; return chosenIndex.\n\nWe need to produce virtual code step by step with explanation. Use decision? Possibly for random choice. Use Start/End.\n\nLet's craft virtual code lines. Use arrow for steps. Provide comments after //.\n\nNeed to ensure each line has \"虛擬碼步驟\" then space then comment. Use Start, End. Use Decision if needed.\n\nWe can break into sections: constructor and pick method.\n\nUse lines like:\n\nStart // 程式開始執行\n→ Step 1: Solution(nums) // 建構子，接收陣列\n→ Step 2: Store nums into instance variable // 讓物件能存取陣列\n→ Step 3: End // 建構子結束\n\nBut we should separate methods. We can do:\n\nStart // 程式開始執行\n→ Step 1: Define class Solution // 建立類別\n    → Step 2: Constructor: Solution(nums) // 初始化\n        → Step 3: Assign instance variable nums = nums // 存儲原陣列\n        → Step 4: End // 退出建構子\n    → Step 5: Method: pick(target) // 產生隨機索引\n        → Step 6: Initialize count = 0 // 目標元素出現次數\n        → Step 7: Initialize result = -1 // 儲存被選中的索引\n        → Step 8: For i from 0 to length(nums)-1 // 遍歷陣列\n            → Decision: If nums[i] == target? // 判斷是否為目標\n                Yes → Step 9: Increment count // 增加計數\n                → Step 10: Generate random number r in [0,1) // 產生隨機數\n                → Decision: If r < 1/count? // 決定是否挑選此索引\n                    Yes → Step 11: Set result = i // 選中此索引\n                    No  → Step 12: Do nothing // 保持目前索引\n        → Step 13: Return result // 返回隨機選中的索引\n        → Step 14: End // 退出 pick 方法\n→ End // 程式結束\n\nNeed to follow arrow style: use \"→\" for sequential. For decisions, use \"Decision:\" with indentation and Yes/No.\n\nAlso each line needs comment after //.\n\nMake sure each line contains virtual code step. Ensure we don't output actual code like \"int\". Just describe. The format: \"虛擬碼步驟\" + space + comment. We can write like \"Start\" etc.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類別 Solution // 建立解題類別  \n  → Step 2: 建構子 Solution(nums) // 接收整數陣列  \n   → Step 3: 將傳入的 nums 存入實例變數 // 方便後續存取  \n   → Step 4: End // 結束建構子  \n  → Step 5: 方法 pick(target) // 隨機挑選目標值的索引  \n   → Step 6: 初始化 count = 0 // 目標值出現的次數  \n   → Step 7: 初始化 result = -1 // 儲存目前被選中的索引  \n   → Step 8: 循環 i 從 0 到 nums.length-1 // 遍歷整個陣列  \n    → Decision: 如果 nums[i] 等於 target? // 判斷是否為目標值  \n     Yes → Step 9: count += 1 // 目標值出現一次  \n      → Step 10: 產生隨機數 r 在 [0,1) // 生成隨機數  \n      → Decision: 如果 r < 1/count? // 決定是否挑選此索引  \n       Yes → Step 11: result = i // 選中此索引  \n       No  → Step 12: 什麼都不做 // 保持現有 result  \n   → Step 13: 返回 result // 回傳隨機選中的索引  \n   → Step 14: End // 結束 pick 方法  \n→ End // 程式結束執行"
    },
    {
      "title": "Word Break",
      "source_file": "Leetcode/leetcode139.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"leetcode\", wordDict = [\"leet\",\"code\"]",
          "expected_output": "true",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'true'\nGot (Norm):      'false'\n--- (Raw) ---\nRaw Expected: 'true'\nRaw Got:      'false'"
        },
        {
          "example_index": 1,
          "input": "s = \"applepenapple\", wordDict = [\"apple\",\"pen\"]",
          "expected_output": "true",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'true'\nGot (Norm):      'false'\n--- (Raw) ---\nRaw Expected: 'true'\nRaw Got:      'false'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def wordBreak(self, s: str, wordDict: list[str]) -> bool:\n        # 將字典轉為集合，提升搜尋速度\n        word_set = set(wordDict)\n        # dp[i] 代表 s[0:i] 是否可以被拆分為字典詞\n        dp = [False] * (len(s) + 1)\n        dp[0] = True  # 空字串總是可拆分\n\n        # 逐個長度檢查\n        for i in range(1, len(s) + 1):\n            # 針對每個可能的切分點 j\n            for j in range(i):\n                if dp[j] and s[j:i] in word_set:\n                    dp[i] = True\n                    break  # 找到一個合法切分即可\n        return dp[len(s)]\n\n\ndef parse_input(raw: str):\n    \"\"\"\n    解析類似於\n    's = \"leetcode\", wordDict = [\"leet\",\"code\"]'\n    的輸入字串，返回 (s, wordDict)。\n    \"\"\"\n    raw = raw.strip()\n    if not raw:\n        return \"\", []\n    # 找出 s 與 wordDict 的分隔位置\n    parts = raw.split(\"wordDict =\")\n    s_part = parts[0].replace(\"s =\", \"\").strip()\n    dict_part = parts[1].strip() if len(parts) > 1 else \"[]\"\n    # 使用 ast.literal_eval 以安全方式解析\n    s = ast.literal_eval(s_part)\n    word_dict = ast.literal_eval(dict_part)\n    return s, word_dict\n\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取所有內容\n    raw_input = sys.stdin.read()\n    s, word_dict = parse_input(raw_input)\n\n    solution = Solution()\n    result = solution.wordBreak(s, word_dict)\n    # 以小寫字串輸出符合範例\n    print(str(result).lower())",
      "virtual_code": "Thinking...\nWe need to produce virtual code for word break problem. Use dynamic programming. Provide step-by-step with decision. Each line: virtual step + // explanation. Format with arrows.\n\nWe must avoid actual code, only pseudo. We must not use actual code, but structure. Let's craft.\n\nWe need Start, End. Steps: read s, read wordDict, set n. Initialize DP array of size n+1 with false. DP[0] = true. Iterate i from 1 to n. For each i, iterate j from 0 to i-1. If DP[j] and substring s[j:i] in wordDict, set DP[i]=true break. After loops, return DP[n]. Also need to show decision if DP[i] is true or false. Provide explanation.\n\nWe need each line with arrow. Use \"→\" to show next step. Use Decision: etc.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 讀取字串 s 與字典 wordDict // 取得輸入資料\n→ Step 2: 計算 s 的長度 n // 用於設定 DP 陣列大小\n→ Step 3: 建立 DP 陣列 size n+1，全部設為 False // DP[i] 代表 s[0:i] 是否可拆分\n→ Step 4: 設定 DP[0] = True // 空字串總是可拆分\n→ Decision: 是否已經遍歷完 i 從 1 到 n? // 判斷是否進入主迴圈\n    No  → Step 5: 取 i = 1 到 n // 逐位檢查是否可拆分\n        → Step 6: 取 j = 0 到 i-1 // 針對每個分割點\n            → Decision: DP[j] 為 True 且 s[j:i] 在 wordDict? // 檢查前半段可拆分且後半段為字典詞\n                Yes → Step 7: 設定 DP[i] = True // 找到合法拆分，標記\n                → Decision: 是否已找到合法拆分? // 早停避免不必要的檢查\n                    Yes → Step 8: 跳過剩餘 j 迴圈 // 進入下一個 i\n                    No  → Step 6: j = j+1 // 繼續檢查下一個 j\n            No  → Step 6: j = j+1 // 繼續檢查下一個 j\n        → Decision: 是否完成 j 迴圈? // 進行完所有 j\n            Yes → Step 5: i = i+1 // 進入下一個 i\n            No  → Step 6: j = j+1 // 重新檢查 j\n    Yes → Step 9: 回傳 DP[n] // 根據 DP[n] 判斷整串是否可拆分\nEnd // 程式執行結束"
    },
    {
      "title": "Palindrome Pairs",
      "source_file": "Leetcode/leetcode336.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "words = [\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]",
          "expected_output": "[[0,1],[1,0],[3,2],[2,4]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0],[3,2],[2,4]]'\nGot (Norm):      '[[0,1],[1,0],[2,4],[3,2]]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0],[3,2],[2,4]]'\nRaw Got:      '[[0, 1], [1, 0], [2, 4], [3, 2]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def palindromePairs(self, words):\n        # 將每個單字的逆序存入字典，方便 O(1) 查找\n        reverse_map = {word[::-1]: i for i, word in enumerate(words)}\n        res_set = set()\n\n        # 判斷字串是否為回文\n        def is_palindrome(s):\n            return s == s[::-1]\n\n        for i, word in enumerate(words):\n            # 空字串特殊處理：任何回文單字與空字串皆能成對\n            # 這在後續的 split 處理已涵蓋，故此處可選擇忽略\n\n            # 對每個可能的分割位置進行檢查\n            for j in range(len(word) + 1):\n                prefix = word[:j]\n                suffix = word[j:]\n\n                # 情況 1：prefix 為回文，尋找 suffix 的逆序字串\n                if is_palindrome(prefix):\n                    target = reverse_map.get(suffix)\n                    if target is not None and target != i:\n                        res_set.add((target, i))\n\n                # 情況 2：suffix 為回文且 j 不是整個字串（避免重複）\n                if j != len(word) and is_palindrome(suffix):\n                    target = reverse_map.get(prefix)\n                    if target is not None and target != i:\n                        res_set.add((i, target))\n\n        # 轉成列表並排序以保持輸出一致\n        res = [list(pair) for pair in sorted(res_set)]\n        return res\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整行資料\n    data = sys.stdin.read().strip()\n    # 移除可能的前綴文字\n    if '=' in data:\n        data = data.split('=', 1)[1].strip()\n    # 解析字串成 Python list\n    try:\n        words = ast.literal_eval(data)\n    except Exception:\n        words = []\n    sol = Solution()\n    result = sol.palindromePairs(words)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm to find palindrome pairs. Requirements: O(total length). Approach: use hashmap of reversed words with index. For each word, consider all splits, check prefix palindrome, suffix palindrome. Use dictionary. Also handle empty string. Need steps in virtual code line by line with explanation.\n\nWe'll produce algorithm steps:\n\nStart\n→ Build map: reversed word to index\n→ For each word with index i\n    → If word is palindrome and empty string exists\n        → add pair (i, emptyIndex)\n    → For each split position from 0 to len(word)\n        → prefix = word[0:split]\n        → suffix = word[split:]\n        → If prefix is palindrome\n            → target = reversed suffix\n            → if target exists and targetIndex != i\n                → add (targetIndex, i)\n        → If suffix is palindrome and split != len(word) (to avoid duplicates)\n            → target = reversed prefix\n            → if target exists and targetIndex != i\n                → add (i, targetIndex)\nEnd.\n\nExplain each line. Use virtual code with arrows. Let's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立字典 reverseMap，key 為 words[j] 的逆序字串，value 為 j // 為快速查找逆序字串做映射  \n→ Decision: 迭代每個單字 words[i]， i 從 0 到 words.length-1 // 逐個檢查每個單字  \n    → Step 2: 若 words[i] 為回文且 reverseMap 含空字串  \n        → Decision: 若空字串存在，空字串索引為 emptyIndex  \n            → Yes → Step 3: 將 (i, emptyIndex) 加入結果 // 空字串 + 回文 = 回文  \n            → No → // 空字串不存在，跳過  \n    → Step 4: 為每個可能的切分位置 split 從 0 到 words[i].length  \n        → Step 5: 計算 prefix = words[i][0:split]，suffix = words[i][split:] // 切分字串  \n        → Decision: 若 prefix 為回文  \n            → Yes → Step 6: target = reverseMap.get(suffix) // 找到 suffix 的逆序字串索引  \n                → Decision: 若 target 不是 null 且 target != i  \n                    → Yes → Step 7: 將 (target, i) 加入結果 // target + words[i] 形成回文  \n                    → No → // 同一索引或不存在，跳過  \n            → No → // prefix 不是回文，跳過  \n        → Decision: 若 suffix 為回文且 split != words[i].length（避免重複）  \n            → Yes → Step 8: target = reverseMap.get(prefix) // 找到 prefix 的逆序字串索引  \n                → Decision: 若 target 不是 null 且 target != i  \n                    → Yes → Step 9: 將 (i, target) 加入結果 // words[i] + target 形成回文  \n                    → No → // 同一索引或不存在，跳過  \n            → No → // suffix 不是回文，跳過  \nEnd // 程式執行結束，返回所有 palindrome pair。"
    },
    {
      "title": "Implement Queue using Stacks",
      "source_file": "Leetcode/leetcode232.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "Input\n[\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]\n[[], [1], [2], [], [], []]",
          "expected_output": "[null, null, null, 1, 1, false]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpafaxbk0v.py\", line 34, in <module>\n    ops = ast.literal_eval(data[0].strip())\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 112, in literal_eval\n    return _convert(node_or_string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 111, in _convert\n    return _convert_signed_num(node)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 85, in _convert_signed_num\n    return _convert_num(node)\n           ^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 76, in _convert_num\n    _raise_malformed_node(node)\n  File \"/usr/lib/python3.12/ast.py\", line 73, in _raise_malformed_node\n    raise ValueError(msg + f': {node!r}')\nValueError: malformed node or string on line 1: <ast.Name object at 0x783866b2ad10>"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\n\nclass MyQueue:\n    def __init__(self):\n        self.stack_in = []\n        self.stack_out = []\n\n    def push(self, x):\n        self.stack_in.append(x)\n\n    def pop(self):\n        if not self.stack_out:\n            while self.stack_in:\n                self.stack_out.append(self.stack_in.pop())\n        return self.stack_out.pop()\n\n    def peek(self):\n        if not self.stack_out:\n            while self.stack_in:\n                self.stack_out.append(self.stack_in.pop())\n        return self.stack_out[-1]\n\n    def empty(self):\n        return not self.stack_in and not self.stack_out\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        sys.exit()\n\n    # Parse operations and arguments from input lines\n    ops = ast.literal_eval(data[0].strip())\n    args = ast.literal_eval(data[1].strip()) if len(data) > 1 else []\n\n    obj = None\n    results = []\n\n    for op, arg in zip(ops, args):\n        if op == \"MyQueue\":\n            obj = MyQueue()\n            results.append(None)\n        elif op == \"push\":\n            obj.push(arg[0])  # arg is a list with a single element\n            results.append(None)\n        elif op == \"pop\":\n            results.append(obj.pop())\n        elif op == \"peek\":\n            results.append(obj.peek())\n        elif op == \"empty\":\n            results.append(obj.empty())\n        else:\n            results.append(None)\n\n    # Output in JSON-like format (null for None, false for False)\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation. The virtual code is a flow diagram style with Start, Decision, arrow steps, etc. The code should implement a queue using two stacks. Need to define push, pop, peek, empty. We'll outline operations. Use two stacks: stack_in for pushes, stack_out for pops/peeks. When popping or peeking, if stack_out is empty, transfer all from stack_in to stack_out. Then pop or peek from stack_out.\n\nWe need to produce steps: maybe initialization of stacks, push function steps, pop function steps, peek, empty. Use decision points for transferring when needed.\n\nWe'll produce the entire algorithm as virtual code steps. Each line with arrow and comment. Let's craft.\n\nWe must not output actual code. Use virtual code style. Each line \"虛擬碼步驟 // 解釋\".\n\nWe start with class init: Start. Then steps: Initialize stack_in, stack_out.\n\nThen push function: Step: push x to stack_in.\n\nPop function: Decision: If stack_out empty? Yes → transfer all from stack_in to stack_out. Then pop top of stack_out.\n\nPeek function similar but peek instead of pop.\n\nEmpty: Decision: If stack_in empty AND stack_out empty? Return true else false.\n\nWe need to present steps for each function maybe as separate sections with labels. Could include function header lines. Eg: Function push(x). We might denote it as \"Function push(x)\".\n\nWe'll include all steps.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Initialize stack_in // 建立一個空的進入堆疊  \n→ Initialize stack_out // 建立一個空的退出堆疊  \n\n// ---------------------- push(x) ----------------------\n→ Function push(x) // 定義 push 方法，接受元素 x  \n    → Push x onto stack_in // 將元素 x 放入 stack_in 的頂部  \nEnd // push 方法結束  \n\n// ---------------------- pop() ----------------------\n→ Function pop() // 定義 pop 方法，移除並返回隊列前端元素  \n    → Decision: If stack_out is empty? // 判斷 stack_out 是否為空  \n        Yes → Transfer All from stack_in to stack_out // 將 stack_in 的所有元素倒入 stack_out（逆序）  \n        No  → // 若不為空，直接使用 stack_out  \n    → Pop top from stack_out // 從 stack_out 的頂部彈出元素  \n    → Return popped element // 回傳彈出的元素  \nEnd // pop 方法結束  \n\n// ---------------------- peek() ----------------------\n→ Function peek() // 定義 peek 方法，返回隊列前端元素但不移除  \n    → Decision: If stack_out is empty? // 判斷 stack_out 是否為空  \n        Yes → Transfer All from stack_in to stack_out // 將 stack_in 的所有元素倒入 stack_out  \n        No  → // 若不為空，直接使用 stack_out  \n    → Peek top from stack_out // 取得 stack_out 的頂部元素  \n    → Return peeked element // 回傳此元素  \nEnd // peek 方法結束  \n\n// ---------------------- empty() ----------------------\n→ Function empty() // 定義 empty 方法，檢查隊列是否為空  \n    → Decision: If stack_in is empty AND stack_out is empty? // 判斷兩個堆疊是否都為空  \n        Yes → Return true // 隊列為空  \n        No  → Return false // 隊列不為空  \nEnd // empty 方法結束  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Permutations",
      "source_file": "Leetcode/leetcode46.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nGot (Norm):      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nRaw Got:      '[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 2, 1], [3, 1, 2]]'"
        }
      ],
      "generated_code": "import sys, ast, json\n\nclass Solution:\n    def permute(self, nums):\n        res = []\n        def backtrack(start):\n            if start == len(nums):\n                res.append(nums[:])\n                return\n            for i in range(start, len(nums)):\n                nums[start], nums[i] = nums[i], nums[start]\n                backtrack(start+1)\n                nums[start], nums[i] = nums[i], nums[start]\n        backtrack(0)\n        return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    l = data.find('[')\n    r = data.rfind(']')\n    if l != -1 and r != -1:\n        nums_str = data[l:r+1]\n    else:\n        nums_str = data\n    try:\n        nums = ast.literal_eval(nums_str)\n    except Exception:\n        nums = []\n    sol = Solution()\n    result = sol.permute(nums)\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate pseudocode step by step, with explanations after each line, using arrow syntax. We must output virtual code, not actual code. Use Start, Decision, etc. The task: generate all permutations of distinct integers array. Use backtracking. Provide steps: start, input array, result list, helper function, backtrack, base case, add permutation, iterate each element not visited, mark visited, append, recurse, unmark, remove last. End. Must be line by line. Use arrows and explanation.\n\nWe need to produce virtual code. Let's produce something like:\n\nStart // 程式開始執行\n→ Step 1: 初始化 result 為空列表 // 用於存儲所有排列\n→ Step 2: 初始化 visited 為全 false 列表 // 追蹤哪些元素已被使用\n→ Step 3: 定義遞迴函式 backtrack(current) // current 為目前已構造的排列\n→ Decision: 如果 current 長度等於 nums 長度? // 判斷是否已形成完整排列\n    Yes → Step 4: 複製 current 並加入 result // 完整排列加入結果\n    No  → Decision: 遍歷 nums 中每個索引 i\n            Yes → Step 5: 如果 visited[i] 為 false? // 尚未使用\n                Yes → Step 6: 設置 visited[i] = true // 標記為已使用\n                → Step 7: 將 nums[i] 加入 current // 加入元素\n                → Step 8: 呼叫 backtrack(current) // 進一步遞迴\n                → Step 9: 從 current 移除最後一個元素 // 回溯\n                → Step 10: 設置 visited[i] = false // 回復未使用狀態\n            No  → Step 11: 繼續下一個 i\n→ End // 程式結束\n\nBut we need to keep arrow format consistent. Maybe we should indent the steps. Use \"Decision:\" and \"Yes →\" \"No →\". For loops, we can represent as Decision: For each index i? But maybe better to use \"Decision: For each i in range(len(nums))?\" Not standard but we can treat it as decision block. But we should maintain proper indentation.\n\nSimplify: Use \"Decision: For each index i?\" not a decision. We can use \"Decision: 目前未達到完整長度?\" then \"Yes/No\".\n\nBut need to maintain arrow format. Let's produce:\n\nStart // 程式開始執行\n→ Step 1: 輸入陣列 nums // 取得輸入數字\n→ Step 2: 初始化 result 為空陣列 // 用於存儲所有排列\n→ Step 3: 初始化 visited 為全 false 陣列 // 追蹤元素是否已被使用\n→ Step 4: 定義遞迴函式 backtrack(current) // current 是已組好的排列\n→ Decision: 是否 current 長度等於 nums 長度? // 檢查是否完成排列\n    Yes → Step 5: 複製 current 並加入 result // 完整排列加入結果\n    No  → Decision: 對於每個索引 i 從 0 到 len(nums)-1? // 依次嘗試未使用的元素\n        Yes → Decision: visited[i] 是否為 false? // 尚未使用\n            Yes → Step 6: visited[i] = true // 標記為已使用\n            → Step 7: current.append(nums[i]) // 加入元素\n            → Step 8: backtrack(current) // 進一步遞迴\n            → Step 9: current.pop() // 回溯移除元素\n            → Step 10: visited[i] = false // 解除標記\n            No  → Step 11: 繼續下一個 i\n        No  → Step 12: 繼續下一個 i\n→ End // 程式結束\n\nBut this representation may be ambiguous. We need a clear arrow structure.\n\nMaybe use a simpler representation:\n\nStart // 程式開始執行\n→ Step 1: 輸入陣列 nums // 取得輸入\n→ Step 2: result ← [] // 用於存放排列\n→ Step 3: visited ← [false]*len(nums) // 標記元素是否已被使用\n→ Step 4: 定義函式 backtrack(current) // current 為已構造的排列\n→ Decision: current.len == nums.len? // 判斷是否完成\n    Yes → Step 5: result.add(copy of current) // 加入結果\n    No  → Decision: for i in 0..len(nums)-1? // 迭代所有索引\n        Yes → Decision: visited[i] == false? // 未使用\n            Yes → Step 6: visited[i] = true\n            → Step 7: current.append(nums[i])\n            → Step 8: backtrack(current)\n            → Step 9: current.pop()\n            → Step 10: visited[i] = false\n            No  → Step 11: // 直接跳到下一 i\n        No  → Step 12: // 直接跳到下一 i\n→ End // 程式結束\n\nWe need to output line by line with arrow after each step. We must not produce code, only virtual code.\n\nLet's format each line like:\n\nStart // 程式開始執行\n→ Step 1: nums ← 輸入陣列 // 取得輸入\n→ Step 2: result ← [] // 初始化結果列表\n→ Step 3: visited ← [false]*len(nums) // 初始化訪問標記\n→ Step 4: 定義函式 backtrack(current) // 開始遞迴\n→ Decision: current.len == nums.len? // 檢查是否已完成排列\n    Yes → Step 5: result.add(copy of current) // 完整排列加入結果\n    No  → Decision: for i in 0..len(nums)-1? // 逐一嘗試每個索引\n        Yes → Decision: visited[i] == false? // 未使用\n            Yes → Step 6: visited[i] = true // 標記已使用\n            → Step 7: current.append(nums[i]) // 加入元素\n            → Step 8: backtrack(current) // 進一步遞迴\n            → Step 9: current.pop() // 回溯移除元素\n            → Step 10: visited[i] = false // 解除標記\n            No  → Step 11: // 跳過已使用的元素\n        No  → Step 12: // 跳過此 i\n→ End // 程式結束\n\nBut maybe we need to show indentation: Use \"→\" for each step, indent sub-steps.\n\nWe should produce each line separately. Let's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: nums ← 輸入陣列 // 取得使用者提供的整數列表  \n→ Step 2: result ← [] // 初始化用於存放所有排列的結果陣列  \n→ Step 3: visited ← [false] * len(nums) // 建立訪問標記陣列，標記每個元素是否已被使用  \n→ Step 4: 定義函式 backtrack(current) // 建立遞迴函式，current 為目前已構造的排列  \n→ Decision: current.len == nums.len? // 判斷是否已形成完整排列  \n Yes → Step 5: result.add(copy of current) // 完整排列加入結果陣列  \n No  → Decision: for i in 0 .. len(nums)-1? // 逐一嘗試每個索引  \n  Yes → Decision: visited[i] == false? // 該索引對應的元素是否尚未使用  \n   Yes → Step 6: visited[i] = true // 標記此元素已使用  \n    → Step 7: current.append(nums[i]) // 將元素加入目前排列  \n    → Step 8: backtrack(current) // 進一步遞迴構造剩餘部分  \n    → Step 9: current.pop() // 回溯：移除最後加入的元素  \n    → Step 10: visited[i] = false // 解除標記，讓該元素可再次使用  \n    No  → Step 11: // 跳過已使用的元素，直接處理下一個 i  \n  No  → Step 12: // 直接跳過此索引，處理下一個 i  \n→ End // 程式執行結束，result 即為所有可能的排列集合"
    },
    {
      "title": "Insert Delete GetRandom O(1) - Duplicates allowed",
      "source_file": "Leetcode/leetcode381.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedCollection\", \"insert\", \"insert\", \"insert\", \"getRandom\", \"remove\", \"getRandom\"], [[], [1], [1], [2], [], [1], []]",
          "expected_output": "[null, true, false, true, 2, true, 1]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpks524g39.py\", line 81, in <module>\n    main()\n  File \"/tmp/tmpks524g39.py\", line 53, in main\n    commands, args = parse_input(raw)\n                     ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpks524g39.py\", line 45, in parse_input\n    commands = eval(parts[0])\n               ^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [\"RandomizedCollection\"\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport random\nimport collections\n\nclass RandomizedCollection:\n    def __init__(self):\n        # 用 list 存放所有元素\n        self.data = []\n        # map: val -> set of indices where val appears in self.data\n        self.idx_map = collections.defaultdict(set)\n\n    def insert(self, val: int) -> bool:\n        \"\"\"插入元素 val，若第一次出現則回傳 True，否則 False。\"\"\"\n        self.data.append(val)\n        self.idx_map[val].add(len(self.data) - 1)\n        return len(self.idx_map[val]) == 1\n\n    def remove(self, val: int) -> bool:\n        \"\"\"移除一個 val，若存在則回傳 True，否則 False。\"\"\"\n        if not self.idx_map[val]:\n            return False\n        # 取出一個要移除的索引\n        remove_idx = self.idx_map[val].pop()\n        last_val = self.data[-1]\n        # 把最後一個元素搬到 remove_idx\n        self.data[remove_idx] = last_val\n        # 更新最後一個元素的索引集合\n        self.idx_map[last_val].add(remove_idx)\n        self.idx_map[last_val].discard(len(self.data) - 1)\n        # 刪除最後一個元素\n        self.data.pop()\n        # 若 val 已無任何索引，移除該鍵\n        if not self.idx_map[val]:\n            del self.idx_map[val]\n        return True\n\n    def getRandom(self) -> int:\n        \"\"\"隨機回傳一個元素。\"\"\"\n        return random.choice(self.data)\n\ndef parse_input(s: str):\n    \"\"\"將輸入字串解析為兩個 list。\"\"\"\n    # 直接使用 eval 解析，輸入格式為合法的 Python 字面量\n    parts = s.strip().split(',', 1)\n    commands = eval(parts[0])\n    args = eval(parts[1])\n    return commands, args\n\ndef main():\n    raw = sys.stdin.read()\n    if not raw.strip():\n        return\n    commands, args = parse_input(raw)\n    outputs = []\n    obj = None\n    for cmd, arg in zip(commands, args):\n        if cmd == \"RandomizedCollection\":\n            obj = RandomizedCollection()\n            outputs.append(None)        # constructor 的結果為 null\n        elif cmd == \"insert\":\n            res = obj.insert(arg[0])\n            outputs.append(res)\n        elif cmd == \"remove\":\n            res = obj.remove(arg[0])\n            outputs.append(res)\n        elif cmd == \"getRandom\":\n            res = obj.getRandom()\n            outputs.append(res)\n    # 將結果轉換為期望的字串格式\n    out_strs = []\n    for v in outputs:\n        if v is None:\n            out_strs.append(\"null\")\n        elif isinstance(v, bool):\n            out_strs.append(\"true\" if v else \"false\")\n        else:\n            out_strs.append(str(v))\n    print(\"[\" + \", \".join(out_strs) + \"]\")\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code lines with explanation. It's algorithm for RandomizedCollection: use vector to store elements, and hash map from value to set of indices (unordered_set). Insert: push_back, add index to map; return true if first time. Remove: if map empty for val -> false; else get an index from set, remove from vector: swap last element into that index, update its index set, pop_back, erase index from val set, if empty remove key; return true. getRandom: pick random index within vector length and return element.\n\nWe need to produce step by step virtual code. Each line has virtual code plus comment. Use Start, End, Decision: etc. For loops, etc.\n\nLet's write structure:\n\nStart\n→ Step: Initialize data structures // vector arr, map val→set of indices\n\nInsert(val):\n→ Decision: Is val in map? // check if exists\n   Yes → Step: Add new index to val's set // record\n       Step: Append val to arr // store\n       Step: Return false // val existed\n   No  → Step: Add new index to val's set\n       Step: Append val to arr\n       Step: Return true // first insertion\n\nRemove(val):\n→ Decision: Is val in map? // exists\n   No  → Step: Return false\n   Yes → Step: Get any index idx from val's set\n       Step: Remove idx from val's set\n       Step: If idx != last index:\n               Step: Move last element to idx in arr\n               Step: Update last element's index set (remove last idx, add idx)\n           End\n       Step: Pop last element from arr\n       Step: If val's set empty:\n               Step: Remove val from map\n       Step: Return true\n\ngetRandom():\n→ Step: Choose random index r in [0, arr.size()-1]\n→ Step: Return arr[r]\n\nWe must adhere to format: each line: \"虛擬碼步驟 // 解釋\". Use arrows, decisions.\n\nWe also need to include Start and End. Probably one Start for overall program, and maybe separate sub-functions? But we can represent functions as steps with labels.\n\nMaybe format:\n\nStart // 程式開始執行\n→ Step: 初始化 arr, map // 建立空結構\n→ Function: insert(val) // 插入函式\n    ...\n→ Function: remove(val)\n    ...\n→ Function: getRandom()\n    ...\nEnd // 程式結束\n\nWithin each function we use Decision: ... Yes → ... No → ... etc.\n\nWe need to use \"→\" for each step. Indentation maybe for nested.\n\nLet's produce.\n\nWe need to keep each line distinct; maybe no blank lines.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: 初始化 arr (空 vector)，map (空 hash map) // 建立兩個資料結構  \n→ Function: insert(val) // 插入函式開始  \n    → Decision: 是否存在 map[val]？ // 檢查 val 是否已在集合中  \n        Yes → Step: 將 newIndex 加入 map[val] 的索引集合 // 記錄新位置  \n            Step: arr.push_back(val) // 把 val 加到陣列尾端  \n            Step: Return false // val 已存在，插入失敗  \n        No  → Step: 建立 map[val] 的索引集合並加入 newIndex // 第一次出現  \n            Step: arr.push_back(val) // 把 val 加到陣列尾端  \n            Step: Return true // val 不存在，插入成功  \n→ Function: remove(val) // 刪除函式開始  \n    → Decision: 是否存在 map[val]？ // 判斷 val 是否在集合中  \n        No  → Step: Return false // 無此元素，刪除失敗  \n        Yes → Step: 從 map[val] 取出任一索引 idx // 取得要移除的位置  \n            Step: 從 map[val] 移除 idx // 刪除索引紀錄  \n            → Decision: idx 是否等於 arr.size()-1？ // 是否是最後一個元素  \n                Yes → Step: arr.pop_back() // 直接刪除最後元素  \n                No  → Step: lastVal = arr.back() // 取得最後元素  \n                    Step: arr[idx] = lastVal // 把最後元素移到 idx  \n                    Step: arr.pop_back() // 刪除最後元素  \n                    Step: 更新 lastVal 在 map 的索引集合：移除舊索引 (arr.size())，加入新索引 idx // 調整索引  \n            Step: 若 map[val] 為空集合，→ Step: 刪除 map[val] // 清除空鍵  \n            Step: Return true // 成功刪除一個元素  \n→ Function: getRandom() // 取得隨機元素函式  \n    → Step: r = 隨機數 [0, arr.size()-1] // 隨機產生索引  \n    → Step: Return arr[r] // 回傳對應元素  \nEnd // 程式結束執行"
    },
    {
      "title": "Find Median from Data Stream",
      "source_file": "Leetcode/leetcode295.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"], [[], [1], [2], [], [3], []]",
          "expected_output": "[null, null, null, 1.5, null, 2.0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,1.5,null,2.0]'\nGot (Norm):      '[null,null,null,1.5,null,2]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, 1.5, null, 2.0]'\nRaw Got:      '[null, null, null, 1.5, null, 2]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport heapq\n\nclass MedianFinder:\n    \"\"\"\n    用兩個堆來維持中位數：\n    - small (max-heap)：儲存較小的一半，實際使用負值模擬最大堆\n    - large (min-heap)：儲存較大的一半\n    \"\"\"\n    def __init__(self):\n        self.small = []  # max-heap（以負值存儲）\n        self.large = []  # min-heap\n\n    def addNum(self, num: int) -> None:\n        # 先把新數插進 small\n        heapq.heappush(self.small, -num)\n\n        # 保持 small 的最大值不大於 large 的最小值\n        if self.small and self.large and (-self.small[0] > self.large[0]):\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n\n        # 平衡兩堆大小\n        if len(self.small) > len(self.large) + 1:\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        elif len(self.large) > len(self.small):\n            val = heapq.heappop(self.large)\n            heapq.heappush(self.small, -val)\n\n    def findMedian(self) -> float:\n        if len(self.small) > len(self.large):\n            return -self.small[0]\n        return (-self.small[0] + self.large[0]) / 2.0\n\n\ndef parse_input(data: str):\n    \"\"\"\n    解析 LeetCode 類似輸入格式：\n    '[\"MedianFinder\", \"addNum\", ...], [[], [1], ...]'\n    或者分行的兩個列表。\n    返回 ops, args\n    \"\"\"\n    data = data.strip()\n    if not data:\n        return [], []\n\n    # 如果包含換行，直接按行解析\n    if '\\n' in data:\n        lines = data.splitlines()\n        ops = ast.literal_eval(lines[0].strip())\n        args = ast.literal_eval(lines[1].strip())\n        return ops, args\n\n    # 否則在 '], [' 位置拆分\n    split_idx = data.find('], [')\n    if split_idx != -1:\n        ops_str = data[:split_idx + 1]   # 包含結尾的 ]\n        args_str = data[split_idx + 3:]  # 跳過 '], [' 後的 [\n        ops = ast.literal_eval(ops_str)\n        args = ast.literal_eval(args_str)\n    else:\n        # 無法解析時返回空\n        ops, args = [], []\n    return ops, args\n\n\ndef main():\n    raw_input = sys.stdin.read()\n    ops, args = parse_input(raw_input)\n\n    res = []\n    mf = None\n    for cmd, arg in zip(ops, args):\n        if cmd == \"MedianFinder\":\n            mf = MedianFinder()\n            res.append(None)          # constructor 沒有返回值\n        elif cmd == \"addNum\":\n            mf.addNum(arg[0])         # arg 是單元素列表\n            res.append(None)\n        elif cmd == \"findMedian\":\n            res.append(mf.findMedian())\n        else:\n            res.append(None)\n\n    # 將結果轉換為 LeetCode 樣式輸出：None -> null\n    out = []\n    for v in res:\n        if v is None:\n            out.append(\"null\")\n        else:\n            out.append(str(v))\n    print(\"[\" + \", \".join(out) + \"]\")\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for implementing MedianFinder, using two heaps method. We must follow format: each line has \"虛擬碼步驟\" + space + \"// 解釋\". Use arrows and decision structures. Need to describe steps: initialization, addNum, findMedian. Use virtual code steps like \"Start\", \"→ Step X\". Use Decision etc.\n\nWe can break into class definition, constructor, addNum, findMedian. We'll use two heaps: maxHeap for lower half, minHeap for upper half. Steps: compare number to maxHeap top; push accordingly; balance sizes; then find median: if sizes equal return mean of tops; else return top of larger heap.\n\nWe'll produce each line accordingly. Ensure no actual code. Just pseudocode steps. Let's produce:\n\nStart\n→ Step 1: Define class MedianFinder // Class definition\n→ Step 2: Initialize maxHeap as max priority queue // stores smaller half\n→ Step 3: Initialize minHeap as min priority queue // stores larger half\n→ Step 4: End constructor // constructor finished\n→ Step 5: Define method addNum(num) // add number\n→ Decision: Is maxHeap empty or num ≤ top(maxHeap)? // decide which heap\n    Yes → Step 6: Insert num into maxHeap // lower half\n    No  → Step 7: Insert num into minHeap // upper half\n→ Decision: Size(maxHeap) > Size(minHeap) + 1? // balance left heap too large\n    Yes → Step 8: Move top(maxHeap) to minHeap // rebalance\n    No  → Decision: Size(minHeap) > Size(maxHeap) + 1? // balance right heap too large\n        Yes → Step 9: Move top(minHeap) to maxHeap // rebalance\n        No → Step 10: // heaps balanced\n→ Step 11: End addNum // method finished\n→ Step 12: Define method findMedian() // compute median\n→ Decision: Size(maxHeap) == Size(minHeap)? // even number of elements\n    Yes → Step 13: Return (top(maxHeap) + top(minHeap)) / 2.0 // average of two middles\n    No  → Decision: Size(maxHeap) > Size(minHeap)? // which heap larger\n        Yes → Step 14: Return top(maxHeap) // median is top of larger heap\n        No  → Step 15: Return top(minHeap) // median is top of larger heap\n→ End // end of class\n\nAdd comments accordingly.\n\nWe need each line as per format. Let's craft.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義類別 MedianFinder // 定義 MedianFinder 類別\n→ Step 2: 初始化 maxHeap 為最大堆 // 儲存較小的一半數值\n→ Step 3: 初始化 minHeap 為最小堆 // 儲存較大的一半數值\n→ Step 4: End // 建構子結束\n\n→ Step 5: 定義方法 addNum(num) // 新增數字進資料流\n→ Decision: maxHeap 為空 或 num ≤ top(maxHeap)? // 判斷應放入哪一個堆\n    Yes → Step 6: 將 num 插入 maxHeap // 放進較小的一半\n    No  → Step 7: 將 num 插入 minHeap // 放進較大的一半\n→ Decision: size(maxHeap) > size(minHeap) + 1? // maxHeap 是否過大\n    Yes → Step 8: 移動 top(maxHeap) 至 minHeap // 重新平衡\n    No  → Decision: size(minHeap) > size(maxHeap) + 1? // minHeap 是否過大\n        Yes → Step 9: 移動 top(minHeap) 至 maxHeap // 重新平衡\n        No  → Step 10: // 堆已平衡\n→ Step 11: End // addNum 方法結束\n\n→ Step 12: 定義方法 findMedian() // 取得目前的中位數\n→ Decision: size(maxHeap) == size(minHeap)? // 元素個數是否為偶數\n    Yes → Step 13: 回傳 (top(maxHeap) + top(minHeap)) / 2.0 // 兩中位數平均\n    No  → Decision: size(maxHeap) > size(minHeap)? // 判斷哪個堆較大\n        Yes → Step 14: 回傳 top(maxHeap) // maxHeap 為較大堆，取其頂端\n        No  → Step 15: 回傳 top(minHeap) // minHeap 為較大堆，取其頂端\n→ End // 程式執行結束"
    },
    {
      "title": "Reorganize String",
      "source_file": "Leetcode/leetcode767.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "s = \"aaab\"",
          "expected_output": "\"\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): ''\nGot (Norm):      'abaa'\n--- (Raw) ---\nRaw Expected: '\"\"'\nRaw Got:      '\"abaa\"'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport heapq\nfrom collections import Counter\n\nclass Solution:\n    def reorganizeString(self, s: str) -> str:\n        if not s:\n            return \"\"\n\n        # Count frequency of each character\n        freq = Counter(s)\n\n        # Build a max-heap using negative frequencies\n        max_heap = [(-cnt, ch) for ch, cnt in freq.items()]\n        heapq.heapify(max_heap)\n\n        res = []\n\n        # While there are still characters to place\n        while max_heap:\n            # Pop the most frequent character\n            cnt1, ch1 = heapq.heappop(max_heap)\n            # Place it\n            res.append(ch1)\n            # Decrease its count (since cnt1 is negative)\n            cnt1 += 1  # e.g., -5 -> -4\n\n            # If there is another character to avoid adjacency\n            if max_heap:\n                cnt2, ch2 = heapq.heappop(max_heap)\n                res.append(ch2)\n                cnt2 += 1  # decrease\n                # Push back if still remaining\n                if cnt2 < 0:\n                    heapq.heappush(max_heap, (cnt2, ch2))\n            # Push back first character if still remaining\n            if cnt1 < 0:\n                heapq.heappush(max_heap, (cnt1, ch1))\n\n        rearranged = \"\".join(res)\n        # Check if rearrangement is valid\n        if len(rearranged) != len(s):\n            return \"\"\n        return rearranged\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # Try to extract string inside double quotes, otherwise take whole input\n    match = re.search(r'\"([^\"]*)\"', data)\n    if match:\n        s = match.group(1)\n    else:\n        s = data.strip()\n\n    solution = Solution()\n    result = solution.reorganizeString(s)\n\n    # Output format: if empty string, print two double quotes\n    if result == \"\":\n        print('\"\"')\n    else:\n        print(f'\"{result}\"')",
      "virtual_code": "Thinking...\nWe need to produce virtual code for reorganizing string so no adjacent same. Standard algorithm: Count freq, use max heap to pick most freq chars, ensure not adjacent. If impossible return \"\". Provide steps.\n\nWe output lines with virtual code and comment.\n\nLet's craft:\n\nStart\n\n→ Step 1: Count frequency of each character // build frequency map\n\n→ Step 2: Build a max-heap of (freq, char) // sort by freq\n\n→ Decision: If top freq > (len(s)+1)/2? // check impossible condition\n\n    Yes → Step 3: Return \"\" // impossible, return empty\n\n    No  → Step 4: Initialize result list // result string builder\n\n→ Step 5: While heap not empty // main loop\n\n    → Decision: If heap has at least 2 elements? // need to pick two distinct chars\n\n        Yes → Step 6: Pop two top elements (c1, f1) and (c2, f2)\n\n              → Step 7: Append c1 and c2 to result // add them\n\n              → Step 8: Decrement f1, f2\n\n              → Step 9: If f1 > 0 push back (f1, c1)\n\n              → Step 10: If f2 > 0 push back (f2, c2)\n\n        No  → Step 11: Pop remaining element (c, f)\n\n              → Decision: If f > 1? // cannot place more than one\n\n                  Yes → Step 12: Return \"\" // impossible\n\n                  No  → Step 13: Append c to result // single char left\n\n→ Step 14: Return result as string // finished\n\nEnd\n\nMake sure each line follows format with \"虛擬碼步驟 // 解釋\".\n\nAlso use arrow \"→\" for steps. Use Decision.\n\nLet's craft accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Count frequency of each character in s // 建立每個字元的出現次數表\n→ Step 2: Build a max-heap of (frequency, character) // 以頻率排序，方便取出最常見字元\n→ Decision: If top frequency > (len(s)+1)/2? // 判斷是否無法重新排列（最常字元太多）\n    Yes → Step 3: Return \"\" // 直接返回空字串，表示不可行\n    No  → Step 4: Initialize result list // 用於儲存重新排列後的字元序列\n→ Step 5: While heap not empty // 進入主迴圈，逐步取出字元\n    → Decision: If heap has at least 2 elements? // 判斷是否可以同時取兩個不同字元\n        Yes → Step 6: Pop two top elements (c1, f1) and (c2, f2) // 取出頻率最高的兩個字元\n        → Step 7: Append c1 and c2 to result // 將兩個字元加入結果，確保不相鄰\n        → Step 8: Decrement f1, f2 // 依次減少已使用的字元頻率\n        → Step 9: If f1 > 0 push back (f1, c1) // 若還有剩餘，重新放回堆疊\n        → Step 10: If f2 > 0 push back (f2, c2) // 同上\n        No  → Step 11: Pop remaining element (c, f) // 僅剩下單一字元時處理\n        → Decision: If f > 1? // 若剩餘字元超過一個，無法放置於最後\n            Yes → Step 12: Return \"\" // 無法完成，返回空字串\n            No  → Step 13: Append c to result // 只剩一個字元，直接加入\n→ Step 14: Return result as string // 將結果列表轉成字串返回\nEnd // 程式執行結束"
    },
    {
      "title": "Burst Balloons",
      "source_file": "Leetcode/leetcode312.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [3,1,5,8]",
          "expected_output": "167",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '167'\nGot (Norm):      '135'\n--- (Raw) ---\nRaw Expected: '167'\nRaw Got:      '135'"
        },
        {
          "example_index": 1,
          "input": "nums = [1,5]",
          "expected_output": "10",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '10'\nGot (Norm):      '0'\n--- (Raw) ---\nRaw Expected: '10'\nRaw Got:      '0'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def maxCoins(self, nums):\n        # 在前後加 1 方便計算\n        nums = [1] + nums + [1]\n        n = len(nums)\n        # dp[i][j] 代表在區間 (i, j) 內，已經彈完且不再彈的氣球，所能得到的最大硬幣\n        dp = [[0] * n for _ in range(n)]\n\n        # 遍歷所有長度，從 2 開始（至少包含一個真正的氣球）\n        for length in range(2, n):\n            # i 為左端索引\n            for left in range(0, n - length):\n                right = left + length\n                # 選擇最後彈的氣球 k（k 必須在 (left, right) 之間）\n                for k in range(left + 1, right):\n                    # 目前 k 作為最後彈的氣球，獲得的硬幣\n                    coins = nums[left] * nums[k] * nums[right]\n                    # 加上左右子區間已經最佳的收益\n                    coins += dp[left][k] + dp[k][right]\n                    # 更新 dp[left][right] 為目前最好的值\n                    if coins > dp[left][right]:\n                        dp[left][right] = coins\n        # 原始區間是從 1 到 n-2（剛好去掉兩端的 1）\n        return dp[1][n - 2]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 從輸入字串中尋找方括號內的內容並 eval 成 list\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1:\n        nums = []\n    else:\n        nums_str = data[start:end + 1]\n        try:\n            nums = eval(nums_str)\n        except:\n            nums = []\n    # 如果不是 list，嘗試使用正則抽取整數\n    if not isinstance(nums, list):\n        nums = list(map(int, re.findall(r'\\d+', data)))\n    sol = Solution()\n    result = sol.maxCoins(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm to maximize coins. Classic DP on intervals. We'll generate steps.\n\nWe need line by line, each with comment.\n\nWe'll produce Start, then prepare extended array with 1 at ends, dp 2D array, iterate lengths, etc.\n\nMake sure to use Decision, arrows.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 取得輸入數組 nums // 從使用者處取得氣球數值\n→ Step 2: 建立陣列 extended = [1] + nums + [1] // 在兩端加 1 以處理邊界\n→ Step 3: 設定 n = extended 長度 // 包含兩端 1 的總長度\n→ Step 4: 建立 2D 陣列 dp[n][n] 且全部初始化為 0 // dp[i][j] 代表在區間 (i, j) 內最大硬幣\n→ Decision: 是否需要計算所有子區間? // 我們需要對所有長度的子區間進行 DP\n    Yes → Step 5: 針對 length 從 2 到 n-1 逐步增加 // length 為子區間長度，至少包含一個實際氣球\n        → Step 6: 針對 i 從 1 到 n - length - 1 迴圈 // i 為子區間左端索引\n            → Step 7: 設定 j = i + length // j 為子區間右端索引\n            → Step 8: 設定 maxCoins = 0 // 用於找出此子區間最佳結果\n            → Step 9: 針對 k 從 i 到 j-1 迴圈 // k 為在此區間最後被彈的氣球\n                → Step 10: 計算 coins = extended[i-1] * extended[k] * extended[j] // 最後彈 k 的硬幣收益\n                → Step 11: 加上左側子區間收益 coins += dp[i][k] // 左側已經最優\n                → Step 12: 加上右側子區間收益 coins += dp[k+1][j] // 右側已經最優\n                → Step 13: Decision: 如果 coins > maxCoins? // 判斷是否為目前最佳\n                    Yes → Step 14: 設定 maxCoins = coins // 更新最佳\n                    No  → // 不更新\n                → Step 15: End // 完成對 k 的迴圈\n            → Step 16: 設定 dp[i][j] = maxCoins // 記錄此子區間最優收益\n            → Step 17: End // 完成對 i 的迴圈\n        → Step 18: End // 完成對 length 的迴圈\n    No  → // 若無需計算，直接跳至輸出\n→ Step 19: 回傳 dp[1][n-2] // 整個原始區間（去除兩端 1）最大硬幣\nEnd // 程式執行結束"
    },
    {
      "title": "Substring with Concatenation of All Words",
      "source_file": "Leetcode/leetcode30.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]",
          "expected_output": "[0,9]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[0,9]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[0,9]'\nRaw Got:      '[]'"
        },
        {
          "example_index": 2,
          "input": "s = \"barfoofoobarthefoobarman\", words = [\"bar\",\"foo\",\"the\"]",
          "expected_output": "[6,9,12]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[6,9,12]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[6,9,12]'\nRaw Got:      '[]'"
        }
      ],
      "generated_code": "import sys\nimport re\nfrom collections import defaultdict\n\nclass Solution:\n    def findSubstring(self, s, words):\n        \"\"\"\n        Find all starting indices of substring(s) in s that is a concatenation of all words in any order.\n        \"\"\"\n        if not s or not words:\n            return []\n\n        word_len = len(words[0])\n        num_words = len(words)\n        total_len = word_len * num_words\n        n = len(s)\n        if n < total_len:\n            return []\n\n        # Frequency map of words\n        freq = defaultdict(int)\n        for w in words:\n            freq[w] += 1\n\n        result = []\n\n        # Iterate over possible starting positions\n        for i in range(n - total_len + 1):\n            seen = defaultdict(int)\n            j = 0\n            while j < num_words:\n                start = i + j * word_len\n                word = s[start:start + word_len]\n                if word not in freq:\n                    break\n                seen[word] += 1\n                if seen[word] > freq[word]:\n                    break\n                j += 1\n            if j == num_words:\n                result.append(i)\n\n        return result\n\n\ndef parse_input(text):\n    \"\"\"\n    Parse input of the form: s = \"string\", words = [\"w1\",\"w2\",...]\n    \"\"\"\n    # Extract the string s\n    s_match = re.search(r's\\s*=\\s*\"([^\"]*)\"', text)\n    s = s_match.group(1) if s_match else \"\"\n\n    # Extract all quoted words\n    words = re.findall(r'[\"\\']([^\"\\']+)[\"\\']', text)\n    return s, words\n\n\ndef main():\n    # Read entire stdin\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        print([])\n        return\n\n    s, words = parse_input(raw_input)\n    sol = Solution()\n    res = sol.findSubstring(s, words)\n    print(res)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm. This is Leetcode problem: find all concatenated substring starting indices. Standard solution: sliding window with hash map counts. Steps: Preprocess words frequencies. Determine word length and total length. Iterate over s positions, using sliding window of size totalLen. For each start i, check using dictionary. Implementation: For each i from 0 to s.length-totalLen, use a map seen; iterate j from i to i+totalLen step wordLen; word = s.substr(j, wordLen); if word not in freq, break; increment seen[word]; if seen[word]>freq[word] break; If finish loop without break, record i. Complexity O(n * m). But we must produce virtual code steps line by line with comments. Format: Start, steps, Decision blocks. Use arrow notation.\n\nWe need to output step lines: each line as \"虛擬碼步驟 // 解釋\". Use Chinese explanation. Ensure we don't output actual code, just virtual steps.\n\nLet's produce steps:\n\nStart\n→ Step 1: Compute word length (wlen) and total length (totalLen) // 確定單詞長度與整體拼接長度\n→ Step 2: Build frequency map freq from words // 统计每个单词出现次数\n→ Step 3: Initialize result list res // 用于存储起始索引\n→ Decision: s 的长度是否小于 totalLen? // 判断是否有足够长度的子串\n    Yes → End // 如果太短，直接结束\n    No  →\n→ Step 4: For each start index i from 0 to s.length - totalLen // 逐个尝试起始位置\n    → Step 4.1: Initialize seen map empty // 记录本次窗口出现的单词\n    → Step 4.2: Initialize flag ok = true // 标记是否成功匹配\n    → Step 4.3: For j from i to i+totalLen in steps of wlen // 逐词检查\n        → Step 4.3.1: word = s.substr(j, wlen) // 取当前单词\n        → Decision: word 是否在 freq? // 判断是否是合法单词\n            Yes →\n                → Step 4.3.2: seen[word]++ // 记录出现次数\n                → Decision: seen[word] > freq[word]? // 过多出现\n                    Yes → \n                        → Step 4.3.3: ok = false // 设为失败\n                        → Step 4.3.4: break // 跳出内层循环\n                    No  →\n            No →\n                → Step 4.3.5: ok = false // 非法单词\n                → Step 4.3.6: break // 跳出内层循环\n    → Decision: ok 为 true? // 检查整个窗口是否符合\n        Yes → \n            → Step 4.4: res.append(i) // 记录起始索引\n        No  →\n→ End // 返回结果\n\nWe should output each line separate with // explanation. Use arrow arrows: Start, Step, Decision: block. The inner decisions should indent? The example shows indentation with 4 spaces, but we can just produce lines accordingly. We'll use indentation to show hierarchy.\n\nMake sure each line is \"虛擬碼步驟 // 解釋\". Eg: \"Start // 程式開始執行\". We need to reflect steps. Let's craft final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得單詞長度 wlen = words[0].length // 確定每個單詞的長度  \n→ Step 2: 計算總長度 totalLen = wlen * words.length // 拼接後子串的完整長度  \n→ Step 3: 建立頻率表 freq，記錄 words 中每個單詞的出現次數 // 用於比對  \n→ Step 4: 初始化結果清單 res // 用來存放符合條件的起始索引  \n→ Decision: s.length 是否小於 totalLen? // 判斷是否有足夠長度的子串  \n  Yes → End // s 太短，直接結束，返回空結果  \n  No  →  \n   → Step 5: 從 i = 0 到 i ≤ s.length - totalLen 逐個嘗試起始位置  \n    → Step 5.1: 建立空的 seen 字典 // 記錄本窗口中單詞的出現次數  \n    → Step 5.2: 設 flag ok = true // 標記本窗口是否符合  \n    → Step 5.3: 從 j = i 開始，每次遞增 wlen 直到 j < i + totalLen  \n      → Step 5.3.1: 取子串 word = s.substr(j, wlen) // 取得當前單詞  \n      → Decision: word 是否在 freq 中? // 判斷是否是合法單詞  \n        Yes →  \n          → Step 5.3.2: seen[word] = (seen[word] || 0) + 1 // 更新出現次數  \n          → Decision: seen[word] > freq[word]? // 過度重複  \n            Yes →  \n              → Step 5.3.3: ok = false // 設為失敗  \n              → Step 5.3.4: break // 跳出內層 for 循環  \n            No  →  \n              ← 仍然執行下一個單詞  \n        No →  \n          → Step 5.3.5: ok = false // 非法單詞  \n          → Step 5.3.6: break // 跳出內層 for 循環  \n      → Decision: ok 為 true? // 檢查整個窗口是否符合  \n        Yes →  \n          → Step 5.4: res.push(i) // 將起始索引加入結果  \n        No  →  \n        ← 進入下一個 i  \n→ End // 程式執行結束，返回 res 其中包含所有起始索引"
    },
    {
      "title": "Combination Sum IV",
      "source_file": "Leetcode/leetcode377.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3], target = 4",
          "expected_output": "7",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '7'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: '7'\nRaw Got:      ''"
        },
        {
          "example_index": 1,
          "input": "nums = [9], target = 3",
          "expected_output": "0",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '0'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: '0'\nRaw Got:      ''"
        }
      ],
      "generated_code": "import sys\n\ndef solve() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入：預期形如 \"nums = [1,2,3], target = 4\"\n    try:\n        # 把 \"=\" 轉成 \":\"，再包裝成 dict 的字串並 eval\n        parsed = eval('{' + data.replace('=', ':') + '}')\n        nums = parsed.get('nums')\n        target = parsed.get('target')\n    except Exception:\n        # 若解析失敗，可嘗試其他簡單格式\n        parts = data.splitlines()\n        if len(parts) >= 2:\n            nums = eval(parts[0].strip())\n            target = int(parts[1].strip())\n        else:\n            return\n\n    # 動態規劃：dp[i] 表示達到總和 i 的組合數\n    dp = [0] * (target + 1)\n    dp[0] = 1  # 基本情況：只有一種方式組成 0\n\n    for i in range(1, target + 1):\n        for num in nums:\n            if i - num >= 0:\n                dp[i] += dp[i - num]\n\n    print(dp[target])\n\nif __name__ == \"__main__\":\n    solve()",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code steps. The problem: count number of combinations that sum to target from distinct integers array nums. Order matters? The typical \"combination sum IV\" problem: count number of possible combinations where order matters. So algorithm: DP target+1, dp[0]=1. For i from 1 to target, for each num in nums: if i>=num, dp[i]+=dp[i-num]. Return dp[target]. Need to produce pseudo-code with Start, End, Decision etc. Use arrow notation. Provide each line with comment. So:\n\nStart\n→ Step 1: Initialize dp array of size target+1 with zeros // create DP table\n→ Step 2: Set dp[0] = 1 // base case: one way to make zero sum\n→ Step 3: For sum from 1 to target // iterate over all sub-targets\n    → For each num in nums // iterate over each number\n        → Decision: if sum >= num? // can we use this number\n            Yes → Step 4: dp[sum] = dp[sum] + dp[sum-num] // add combinations\n        No  → (do nothing)\n→ Step 5: Return dp[target] // result\nEnd\n\nBut need to format exactly with each line like \"Start // comment\" etc. Use arrows for nested loops? Might need indent or arrow? The example uses arrow \"→ Step 1:\" and \"→ Decision:\" etc. For loops we can use \"→ For sum from 1 to target:\" etc.\n\nMake sure each line ends with // comment.\n\nUse \"→ For sum from 1 to target:\" but then inside need to use arrow again.\n\nCould use indentation like:\n\n→ For sum from 1 to target:\n    → For each num in nums:\n        → Decision: if sum >= num?\n            Yes → Step: dp[sum] = dp[sum] + dp[sum-num]\n            No  → (nothing)\n\nBut the requirement: Each line must contain \"虛擬碼步驟 [空格] // 解釋/說明\". So each line should be a single line; we cannot embed multiple lines inside. We might need to write each nested line separately with indent or arrow. Could use \"→ For sum from 1 to target:\" and then next line \"→   For each num in nums:\" but arrow? The example uses indentation with spaces? In example they used \"→ Decision:\" with nested \"Yes →\" and \"No →\" on separate lines.\n\nThus for loops, we can treat \"For sum from 1 to target:\" as a step; then inside we add nested steps with indentation maybe \"→   For each num in nums:\".\n\nBut the requirement didn't specify indentation, but we can mimic example. Use spaces before arrow for nested lines.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 初始化 dp 陣列長度 target+1，所有值設為 0 // 建立 DP 表格\n→ Step 2: dp[0] = 1 // 基本情況：一種方式組成 0\n→ Step 3: For sum 1 到 target\n    → Step 4: For 每個 num 在 nums\n        → Decision: sum >= num? // 判斷是否可用此數字\n            Yes → Step 5: dp[sum] = dp[sum] + dp[sum-num] // 加上使用此數字的組合數\n            No  → (不做任何事)\n→ Step 6: Return dp[target] // 回傳總組合數\nEnd // 程式執行結束\n\nBut need to ensure each line has \"虛擬碼步驟 // 解釋\". So we need to include comment on each line. Use \"Step 3: For sum 1 到 target\" etc. For nested loops, we can indent with spaces before arrow. Eg:\n\n→ Step 3: For sum 1 到 target // 遍歷所有子目標\n    → Step 4: For 每個 num 在 nums // 遍歷每個可用數字\n        → Decision: sum >= num? // 判斷是否可用此數字\n            Yes → Step 5: dp[sum] = dp[sum] + dp[sum-num] // 更新 DP\n            No  → (不做任何事)\n\nBut each line still follows pattern: \"虛擬碼步驟 // 解釋\".\n\nThus line \"→ Step 3: For sum 1 到 target\" has comment.\n\nBut for \"→ Step 4: For 每個 num 在 nums\" also comment.\n\nThen \"→ Decision: sum >= num?\" comment.\n\nThen Yes branch: \"Yes → Step 5: dp[sum] = dp[sum] + dp[sum-num]\" comment.\n\nNo branch: \"No  → (不做任何事)\" comment.\n\nHowever, the \"No  → (不做任何事)\" still needs comment; we can say \"// 不做任何事\".\n\nAlso the line \"End // 程式執行結束\" is fine.\n\nLet's produce final output with each line accordingly. Ensure use of Chinese characters. Use arrow signs as in example. Let's produce.\n\nAlso note that each line must have a space after the arrow? In example they had \"→ Step 1:\" etc. So we'll do same.\n\nLet's craft final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 dp 陣列長度 target+1，所有值設為 0 // 建立 DP 表格  \n→ Step 2: dp[0] = 1 // 基本情況：一種方式組成 0  \n→ Step 3: For sum 1 到 target // 遍歷所有子目標  \n    → Step 4: For 每個 num 在 nums // 遍歷每個可用數字  \n        → Decision: sum >= num? // 判斷是否可用此數字  \n            Yes → Step 5: dp[sum] = dp[sum] + dp[sum-num] // 更新 DP  \n            No  → (不做任何事) // 不符合條件時不進行累加  \n→ Step 6: Return dp[target] // 回傳總組合數  \nEnd // 程式執行結束"
    },
    {
      "title": "Implement Rand10() Using Rand7()",
      "source_file": "Leetcode/leetcode470.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 1",
          "expected_output": "[2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2]'\nGot (Norm):      '[10]'\n--- (Raw) ---\nRaw Expected: '[2]'\nRaw Got:      '[10]'"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[2,8]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,8]'\nGot (Norm):      '[3,4]'\n--- (Raw) ---\nRaw Expected: '[2,8]'\nRaw Got:      '[3,4]'"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "[3,8,10]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,8,10]'\nGot (Norm):      '[9,10,7]'\n--- (Raw) ---\nRaw Expected: '[3,8,10]'\nRaw Got:      '[9,10,7]'"
        }
      ],
      "generated_code": "import random\nimport sys\nimport re\n\n# 假設已經有一個 API rand7() 可用\ndef rand7() -> int:\n    \"\"\"返回 1~7 的均勻隨機整數。\"\"\"\n    return random.randint(1, 7)\n\nclass Solution:\n    def rand10(self) -> int:\n        \"\"\"使用 rand7() 生成 1~10 的均勻隨機整數。\"\"\"\n        while True:\n            # 兩次 rand7() 組合得到 1~49 的均勻分布\n            num = (rand7() - 1) * 7 + rand7()  # 1~49\n            if num <= 40:  # 40 可以被 10 整除，剩餘 9 號會被拒絕\n                return 1 + (num - 1) % 10\n\ndef main() -> None:\n    \"\"\"主函式：讀取輸入，產生並輸出結果。\"\"\"\n    # 讀取整個輸入並解析數字\n    data = sys.stdin.read()\n    # 提取所有數字，取最後一個作為 n\n    nums = re.findall(r'\\d+', data)\n    if not nums:\n        return\n    n = int(nums[-1])\n\n    sol = Solution()\n    results = [sol.rand10() for _ in range(n)]\n\n    # 按要求輸出列表，無空格\n    output = '[' + ','.join(map(str, results)) + ']'\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code steps for implementing rand10() using rand7() with uniform distribution. We need to produce step-by-step, each line with 虛擬碼步驟 and // 解釋. Use arrows, Decision, etc.\n\nWe should design algorithm: use rejection sampling, convert two rand7() calls to a range 1-49, then reject >40. That yields uniform 1-10. Or use 7*7=49; 49/10=4 with remainder 9. Accept numbers 1-40, map to 1-10 by mod 10. Use loop until accept.\n\nAlso might consider using more efficient approach: Use 3 calls: 7^2=49, 7^3=343, but simple is fine.\n\nThus steps: Start, call rand7() twice, compute val = (a-1)*7 + b (range 1-49). If val <= 40, then output (val-1)%10 +1 else repeat. Use loop.\n\nWrite virtual code:\n\nStart\n→ Step 1: LoopStart // Begin while loop\n    → Step 2: a = rand7() // first random from 1-7\n    → Step 3: b = rand7() // second random from 1-7\n    → Step 4: val = (a-1)*7 + b // convert to 1-49\n    → Decision: if val <= 40? // check acceptance\n        Yes → Step 5: result = (val-1)%10 + 1 // map to 1-10\n        Yes → Step 6: return result // return uniform 1-10\n        No  → Step 7: Go back to LoopStart // reject and retry\nEnd\n\nWe should follow format: each line: virtual step and // explanation.\n\nUse arrows for step indentation.\n\nNeed to show the loop. Could denote Start loop as \"→ Loop:\".\n\nBetter: \"→ Decision: loop condition?\".\n\nSimplify: \"→ Step 1: while true:\"? But we need to use 虛擬碼 arrow.\n\nWe can have:\n\nStart\n→ Step 1: Repeat // 無窮迴圈開始\n    → Step 2: a ← rand7() // 取得第一個隨機數\n    → Step 3: b ← rand7() // 取得第二個隨機數\n    → Step 4: val ← (a-1)*7 + b // 將兩個 1-7 映射到 1-49\n    → Decision: val ≤ 40? // 判斷是否可接受\n        Yes → Step 5: result ← (val-1) mod 10 + 1 // 轉換到 1-10\n        Yes → Step 6: Return result // 回傳均勻結果\n        No  → Step 7: Continue // 跳回迴圈重試\n\nEnd\n\nNeed to ensure formatting: Each line \"→\" maybe nested. For decision branches, indent further with Yes →, No →. We need to use arrow.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Repeat // 開始無窮迴圈，直到得到有效結果  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 2: a ← rand7() // 取得第一個 1~7 的隨機數  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 3: b ← rand7() // 取得第二個 1~7 的隨機數  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 4: val ← (a-1)*7 + b // 把兩個隨機數映射到 1~49  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: val ≤ 40? // 檢查是否在可接受的 1~40 範圍  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 5: result ← (val-1) mod 10 + 1 // 轉換到 1~10  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 6: Return result // 回傳均勻分佈的數字  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 7: Continue // 跳回迴圈重試  \nEnd // 程式執行結束"
    },
    {
      "title": "Rotate Function",
      "source_file": "Leetcode/leetcode396.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [4,3,2,6]",
          "expected_output": "26",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '26'\nGot (Norm):      '34'\n--- (Raw) ---\nRaw Expected: '26'\nRaw Got:      '34'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\ndef max_rotate_function(nums):\n    n = len(nums)\n    if n == 0:\n        return 0\n    total = sum(nums)\n    current = sum(i * num for i, num in enumerate(nums))\n    max_val = current\n    for i in range(n - 1):\n        current = current + total - n * nums[i]\n        if current > max_val:\n            max_val = current\n    return max_val\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # Extract the list of numbers from the input, e.g. \"nums = [4,3,2,6]\"\n    if '=' in data:\n        _, rhs = data.split('=', 1)\n        list_str = rhs.strip()\n    else:\n        list_str = data.strip()\n    nums = ast.literal_eval(list_str)\n    result = max_rotate_function(nums)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm: find maximum rotation function. Classic problem: compute sum and rotate formula. Approach: compute initial sum of arr[0]*0... arr[n-1]*(n-1). Then iteratively update using relation F(k+1)=F(k)+sum - n*arr[k]. Actually formula: F(k+1)=F(k)+totalSum - n*arr[k]. Keep max. Complexity O(n). Virtual code line by line with explanations.\n\nWe must follow format: each line with virtual code step and comment. Use arrows. We need to include Start and End. Use Decision for max tracking.\n\nLet's craft.\n\nStart\n→ Step 1: Input array nums // 取得輸入陣列\n→ Step 2: n ← length(nums) // 取得陣列長度\n→ Step 3: totalSum ← 0 // 初始化總和\n    → For i from 0 to n-1:\n        totalSum ← totalSum + nums[i] // 計算總和\n→ Step 4: currentF ← 0 // 初始化旋轉函數 F(0)\n    → For i from 0 to n-1:\n        currentF ← currentF + i * nums[i] // 計算 F(0)\n→ Step 5: maxF ← currentF // 設定最大值為 F(0)\n→ Decision: 是否還有下一個 k? // 檢查是否有剩下的旋轉\n    Yes → Step 6: k ← 0 // 設定 k\n        → While k < n-1:\n            currentF ← currentF + totalSum - n * nums[k] // 更新 F(k+1)\n            k ← k + 1 // 前進至下一個 k\n            Decision: currentF > maxF? // 判斷是否為新最大\n                Yes → maxF ← currentF // 更新最大值\n                No → // 保持原值\n            → Loop end\n        → End while\n    No → // 只一個 k\n→ End // 回傳 maxF\n\nNeed to use Decision syntax exactly: Decision: ...? then Yes → ... No → ... lines. Use indentation. Also Start, End.\n\nLet's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: nums ← 輸入陣列 // 取得輸入的整數陣列  \n→ Step 2: n ← length(nums) // 獲取陣列長度  \n→ Step 3: totalSum ← 0 // 初始化總和  \n    → For i from 0 to n-1:  \n        totalSum ← totalSum + nums[i] // 累加所有元素得到總和  \n→ Step 4: currentF ← 0 // 初始化旋轉函數 F(0)  \n    → For i from 0 to n-1:  \n        currentF ← currentF + i * nums[i] // 計算 F(0) 的值  \n→ Step 5: maxF ← currentF // 設定最大值為 F(0)  \n→ Decision: 是否還有 k 需要計算? // 檢查是否有剩餘旋轉  \n    Yes → Step 6: k ← 0 // 從第 0 次旋轉開始  \n        → While k < n-1:  \n            currentF ← currentF + totalSum - n * nums[k] // 更新到 F(k+1)  \n            k ← k + 1 // 前進到下一個 k  \n            Decision: currentF > maxF? // 判斷是否為新的最大值  \n                Yes → maxF ← currentF // 更新最大值  \n                No  → // 保持原最大值  \n            → End While  \n        → End While  \n    No → // 只計算一次 F(0)，不需要迴圈  \n→ End // 程式執行結束，返回 maxF"
    },
    {
      "title": "Range Sum Query - Mutable",
      "source_file": "Leetcode/leetcode307.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"NumArray\", \"sumRange\", \"update\", \"sumRange\"], [[[1, 3, 5]], [0, 2], [1, 2], [0, 2]]",
          "expected_output": "[null, 9, null, 8]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp5m0kb4j7.py\", line 56, in <module>\n    main()\n  File \"/tmp/tmp5m0kb4j7.py\", line 41, in main\n    ops, args = json.loads(data)   # 解析輸入，ops 是操作列表，args 是對應參數列表\n                ^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 47 (char 46)"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass NumArray:\n    def __init__(self, nums):\n        self.n = len(nums)\n        self.nums = nums[:]                      # keep a copy of the original array\n        self.tree = [0] * (self.n + 1)           # Fenwick Tree, 1-indexed\n        for i in range(self.n):\n            self._update_tree(i + 1, nums[i])    # build the tree\n\n    def _update_tree(self, i, val):\n        \"\"\"內部方法，將 val 加到第 i 個位置（1-indexed）及其父節點上\"\"\"\n        while i <= self.n:\n            self.tree[i] += val\n            i += i & -i\n\n    def update(self, index, val):\n        \"\"\"把 nums[index] 更新成 val，並同步更新 Fenwick Tree\"\"\"\n        diff = val - self.nums[index]\n        self.nums[index] = val\n        self._update_tree(index + 1, diff)\n\n    def _query(self, i):\n        \"\"\"取得前 i 個元素的和（i 為 1-indexed）\"\"\"\n        res = 0\n        while i > 0:\n            res += self.tree[i]\n            i -= i & -i\n        return res\n\n    def sumRange(self, left, right):\n        \"\"\"回傳左右範圍內的和（0-indexed）\"\"\"\n        return self._query(right + 1) - self._query(left)\n\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    ops, args = json.loads(data)   # 解析輸入，ops 是操作列表，args 是對應參數列表\n    result = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"NumArray\":\n            obj = NumArray(arg[0])\n            result.append(None)\n        elif op == \"update\":\n            obj.update(arg[0], arg[1])\n            result.append(None)\n        elif op == \"sumRange\":\n            result.append(obj.sumRange(arg[0], arg[1]))\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce a virtual code step by step explaining. The user requirement: implement NumArray class with constructor, update, sumRange. Should use a data structure like Fenwick tree or segment tree. We produce virtual code with steps. We need to output each line with arrow or decision structure. Use \"Start\" and \"End\". Also we need to show steps for class initialization, update, sumRange. Also maybe include internal representation of BIT or segment tree. Provide virtual code lines sequentially. We will structure as:\n\nStart // 程式開始執行\n→ Step: 定義類別 NumArray // 定義主類\n→ Step: 初始化樹陣列 bit // 使用 BIT\n→ Step: 將輸入 nums 存儲為 array // 原始資料\n→ Step: 迭代 idx from 0 to n-1 // 初始化 BIT\n    → Step: bit[idx+1] += nums[idx]\n    → Step: j = idx+1 + (idx+1 & - (idx+1))\n    → Decision: If j <= n? // 將累加到父節點\n        Yes → bit[j] += bit[idx+1]\n        No  →\n...\n\nBut we might condense: Provide pseudo-code lines for each method: constructor, update, sumRange, prefixSum helper. We should also include decision steps for index boundaries.\n\nThus produce lines:\n\nStart // 程式開始執行\n→ Step 1: 定義類別 NumArray // 主類別\n→ Step 2: 在類別內部宣告兩個屬性：array // 原始資料、bit // BIT 陣列\n→ Step 3: 定義建構子 NumArray(nums) // 初始化\n    → Step 4: array ← nums\n    → Step 5: n ← length(nums)\n    → Step 6: bit ← new int[n+1]\n    → Step 7: For i from 0 to n-1\n        → Step 8: bit[i+1] ← nums[i]\n        → Step 9: j ← i+1 + ((i+1) & -(i+1))\n        → Decision: 如果 j <= n\n            Yes → bit[j] ← bit[j] + bit[i+1]\n            No  →\n→ Step 10: End of constructor // 完成初始化\n→ Step 11: 定義函式 update(index, val) // 更新\n    → Step 12: delta ← val - array[index]\n    → Step 13: array[index] ← val\n    → Step 14: i ← index+1\n    → Decision: 當 i <= n\n        Yes → bit[i] ← bit[i] + delta\n        No  →\n        → i ← i + (i & -i)\n        → Repeat until i > n\n→ Step 15: End of update // 更新完成\n→ Step 16: 定義函式 prefixSum(idx) // 取得前 idx 的和\n    → Step 17: sum ← 0\n    → Step 18: i ← idx\n    → Decision: i > 0\n        Yes → sum ← sum + bit[i]\n        No  →\n        → i ← i - (i & -i)\n        → Repeat until i == 0\n    → Step 19: Return sum\n→ Step 20: End of prefixSum // 完成前綴和\n→ Step 21: 定義函式 sumRange(left, right) // 範圍和\n    → Step 22: return prefixSum(right+1) - prefixSum(left)\n→ Step 23: End of sumRange // 返回結果\n→ End // 程式執行結束\n\nBut we need to show arrow for each step. Use \"→\" for each line. Use \"Decision:\" lines. Provide simple comments.\n\nWe should ensure each line includes the code and comment.\n\nWe must adhere to format: each line \"虛擬碼步驟 [space] // 解釋\". Use arrow arrow.\n\nWe need to produce lines, each with virtual code. For decision lines we need indent? Not required but can show nested.\n\nWe can represent decisions with indent indentation or line numbers. The example shows indentation for nested decisions.\n\nWe should maintain consistent style: Use \"Decision:\" lines with \"Yes →\" and \"No →\". Example from requirement.\n\nThus produce final answer.\n\nLet's craft final content.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類別 NumArray // 主類別  \n→ Step 2: 在類別內部宣告兩個屬性：array // 原始資料，bit // BIT 陣列  \n→ Step 3: 定義建構子 NumArray(nums) // 初始化  \n&nbsp;&nbsp;→ Step 4: array ← nums  \n&nbsp;&nbsp;→ Step 5: n ← length(nums)  \n&nbsp;&nbsp;→ Step 6: bit ← new int[n+1]  \n&nbsp;&nbsp;→ Step 7: For i from 0 to n-1 // 循環填充 BIT  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 8: bit[i+1] ← nums[i]  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 9: j ← i+1 + ((i+1) & -(i+1))  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: 如果 j <= n? // 將值累加到父節點  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → bit[j] ← bit[j] + bit[i+1]  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → // 不做任何事  \n&nbsp;&nbsp;→ Step 10: End of constructor // 完成初始化  \n→ Step 11: 定義函式 update(index, val) // 更新值  \n&nbsp;&nbsp;→ Step 12: delta ← val - array[index]  \n&nbsp;&nbsp;→ Step 13: array[index] ← val  \n&nbsp;&nbsp;→ Step 14: i ← index+1  \n&nbsp;&nbsp;→ Decision: 當 i <= n? // 更新 BIT  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes →  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bit[i] ← bit[i] + delta  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i ← i + (i & -i)  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Repeat while i <= n  \n&nbsp;&nbsp;&nbsp;&nbsp;No  → // 結束更新  \n&nbsp;&nbsp;→ Step 15: End of update // 更新完成  \n→ Step 16: 定義函式 prefixSum(idx) // 計算前綴和（idx 為 1‑based 索引）  \n&nbsp;&nbsp;→ Step 17: sum ← 0  \n&nbsp;&nbsp;→ Step 18: i ← idx  \n&nbsp;&nbsp;→ Decision: i > 0? // 迭代累加  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes →  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sum ← sum + bit[i]  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i ← i - (i & -i)  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Repeat while i > 0  \n&nbsp;&nbsp;&nbsp;&nbsp;No  → // 結束計算  \n&nbsp;&nbsp;→ Step 19: Return sum  \n&nbsp;&nbsp;→ Step 20: End of prefixSum // 完成前綴和  \n→ Step 21: 定義函式 sumRange(left, right) // 取得區間和  \n&nbsp;&nbsp;→ Step 22: Return prefixSum(right+1) - prefixSum(left) // 轉為 1‑based  \n&nbsp;&nbsp;→ Step 23: End of sumRange // 返回結果  \nEnd // 程式執行結束"
    },
    {
      "title": "Word Ladder II",
      "source_file": "Leetcode/leetcode126.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
          "expected_output": "[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]'\nGot (Norm):      '[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]'\nRaw Got:      \"[['hit', 'hot', 'dot', 'dog', 'cog']]\""
        }
      ],
      "generated_code": "import sys\nimport re\nfrom collections import defaultdict, deque\n\nclass Solution:\n    def findLadders(self, beginWord: str, endWord: str, wordList: list[str]) -> list[list[str]]:\n        wordSet = set(wordList)\n        if endWord not in wordSet:\n            return []\n\n        layer = {beginWord: 0}            # 存儲每個單詞到 beginWord 的最短距離\n        parents = defaultdict(list)       # 存儲符合最短路徑的前驅單詞\n        queue = deque([beginWord])\n        found = False\n\n        while queue and not found:\n            word = queue.popleft()\n            step = layer[word]\n            for i in range(len(word)):\n                for c in 'abcdefghijklmnopqrstuvwxyz':\n                    new_word = word[:i] + c + word[i+1:]\n                    if new_word in wordSet:\n                        if new_word not in layer:\n                            layer[new_word] = step + 1\n                            queue.append(new_word)\n                            parents[new_word].append(word)\n                            if new_word == endWord:\n                                found = True\n                        elif layer[new_word] == step + 1:\n                            parents[new_word].append(word)\n\n        res = []\n        if endWord in parents:\n            def dfs(path, word):\n                if word == beginWord:\n                    res.append(path[::-1])   # 逆序回傳完整路徑\n                    return\n                for prev in parents[word]:\n                    dfs(path + [prev], prev)\n            dfs([endWord], endWord)\n\n        return res\n\ndef parse_input(data: str):\n    pattern = r'beginWord\\s*=\\s*\"([^\"]*)\",\\s*endWord\\s*=\\s*\"([^\"]*)\",\\s*wordList\\s*=\\s*\\[([^\\]]*)\\]'\n    m = re.search(pattern, data)\n    if not m:\n        return None, None, []\n    beginWord = m.group(1)\n    endWord = m.group(2)\n    list_items = re.findall(r'\"([^\"]*)\"', m.group(3))\n    return beginWord, endWord, list_items\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    begin, end, words = parse_input(raw_input)\n    if begin is None:\n        print([])\n    else:\n        sol = Solution()\n        result = sol.findLadders(begin, end, words)\n        print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for the algorithm. Classic problem: Word Ladder II. We need to produce all shortest transformation sequences. Approach: BFS to find shortest distances; then DFS/backtrack to find all paths. Or use BFS to build adjacency graph of nodes with shortest distance. We'll produce high-level pseudo-code lines.\n\nWe need to output line by line: Start, then each step. We need to include arrow lines, decisions, etc.\n\nLet's outline:\n\nStart\n→ Step 1: Initialize set wordSet from wordList // Convert to set for O(1) lookups\n→ Decision: If endWord not in wordSet? // Check if possible\n    No  → End // Return empty list\n\n→ Step 2: BFS from beginWord to compute distance map and build adjacency list (neighbors that are one letter apart and part of wordSet) for shortest paths only\n\nDuring BFS: use queue, distance dict.\n\n→ Step 3: Initialize empty adjacency dict neighbors.\n\n→ Step 4: While queue not empty:\n    → Step 5: Pop current word\n    → Step 6: For each position i in word:\n        → Step 7: For each letter a-z:\n            → Step 8: Generate newWord\n            → Decision: If newWord in wordSet?\n                → Yes:\n                    → Decision: If newWord not visited? // first time visited\n                        → Yes:\n                            → Step 9: set distance[newWord] = distance[current]+1\n                            → Step 10: enqueue newWord\n                            → Step 11: add newWord to neighbors[current]\n                        → No:\n                            → Decision: If distance[newWord] == distance[current]+1?\n                                → Yes:\n                                    → Step 12: add newWord to neighbors[current]\n                                → No:\n                                    → Step 13: ignore // longer path\n→ Decision: After BFS, if endWord not in distance? // unreachable\n    → Yes: End // return empty\n\n→ Step 14: Prepare result list\n→ Step 15: DFS backtracking from beginWord to endWord using neighbors to collect all shortest paths\n    → Recursive function backtrack(current, path)\n        → Decision: If current == endWord?\n            → Yes:\n                → Step 16: append copy of path to result\n                → Return\n        → For each nextWord in neighbors[current]:\n            → Step 17: append nextWord to path\n            → Step 18: backtrack(nextWord, path)\n            → Step 19: pop last word from path // backtrack\n\n→ Step 20: Return result\n\nWe need to produce each line in format \"虛擬碼步驟 // 解釋\". Use arrows and indent decisions.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: 將 wordList 轉換為集合 wordSet // 方便 O(1) 查找\n→ Decision: 若 endWord 不在 wordSet? // 若終點不存在則無路徑\n    Yes → End // 直接結束，回傳空清單\n    No  →  // 繼續\n\n→ Step 2: 初始化距離映射 distance，將 beginWord 的距離設為 0 // 用於 BFS 追蹤層距\n→ Step 3: 初始化鄰接字典 neighbors 為空集合 // 存儲符合最短路徑的相鄰詞\n→ Step 4: 初始化 BFS 隊列 queue，加入 beginWord // 開始 BFS\n→ Step 5: 開始 BFS 主循環\n    While queue 不是空:\n        → Step 6: 取出 queue 前端 currentWord // 當前處理詞\n        → Step 7: 針對 currentWord 的每個位置 i:\n            → Step 8: 針對每個字母 a 到 z:\n                → Step 9: 產生 newWord 替換第 i 個字母\n                → Decision: 若 newWord 在 wordSet? // 只考慮字典內的詞\n                    Yes:\n                        → Decision: 若 newWord 尚未被訪問? // 首次遇到\n                            Yes:\n                                → Step 10: 設置 distance[newWord] = distance[currentWord] + 1\n                                → Step 11: 將 newWord 加入 queue\n                                → Step 12: 在 neighbors[currentWord] 加入 newWord // 記錄相鄰關係\n                            No:\n                                → Decision: 若 distance[newWord] == distance[currentWord] + 1? // 仍是最短距離\n                                    Yes:\n                                        → Step 13: 在 neighbors[currentWord] 加入 newWord // 同層相鄰\n                                    No:\n                                        → Step 14: 跳過 // 不是最短路徑\n                    No: // newWord 不在字典\n                        → Step 15: 跳過\n→ Decision: 若 endWord 不在 distance? // BFS 未達到終點\n    Yes → End // 直接結束，回傳空清單\n    No  → // 繼續\n\n→ Step 16: 初始化結果列表 result = []\n→ Step 17: 定義遞迴函式 backtrack(current, path)\n    → Decision: 若 current == endWord? // 到達終點\n        Yes:\n            → Step 18: 把 path 的拷貝加入 result // 收集一條完整路徑\n            → Step 19: 返回\n        No:\n            → Step 20: 對於 neighbors[current] 的每個 nextWord:\n                → Step 21: path.append(nextWord)\n                → Step 22: backtrack(nextWord, path)\n                → Step 23: path.pop() // 回溯\n\n→ Step 24: 調用 backtrack(beginWord, [beginWord]) // 開始回溯\n→ Step 25: End // 返回結果 list\n\nBut we must adhere to the format: each line has code step + space + comment. Use arrows appropriately. Also indent decisions.\n\nLet's produce a more detailed step-by-step code lines, making sure to use proper indentation.\n\nWe need to output lines like:\n\nStart // 程式開始執行\n→ Step 1: wordSet ← Set(wordList) // 轉成集合\n→ Decision: endWord ∉ wordSet? // 若終點不存在\n    Yes → End // 無路徑\n    No\n\nBut we must not use actual code symbols like ← etc. But it's pseudo, so okay.\n\nLet's produce final output.\n\nNote: The code steps should follow the pattern. Use \"→\" to show arrows. \"Decision:\" lines.\n\nWe'll include indentation by spaces.\n\nLet's craft the final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: wordSet ← Set(wordList) // 轉成集合，方便 O(1) 查找\n→ Decision: endWord ∉ wordSet? // 檢查終點是否在字典內\n    Yes → End // 無路徑，直接結束\n    No  // 繼續執行\n\n→ Step 2: distance ← {beginWord: 0} // 存放每個詞到 beginWord 的最短距離\n→ Step 3: neighbors ← {} // 建立鄰接字典，儲存符合最短路徑的相鄰詞\n→ Step 4: queue ← [beginWord] // BFS 隊列\n\n→ Step 5: while queue 非空: // BFS 主循環\n    → Step 6: current ← queue.pop_front() // 取得當前詞\n    → Step 7: for i from 0 to len(current)-1: // 遍歷每個位置\n        → Step 8: for c in 'a'..'z': // 逐字母嘗試\n            → Step 9: newWord ← replace(current, i, c) // 產生新詞\n            → Decision: newWord ∈ wordSet? // 只考慮字典內的詞\n                Yes:\n                    → Decision: newWord ∉ distance? // 首次遇到\n                        Yes:\n                            → Step 10: distance[newWord] ← distance[current] + 1\n                            → Step 11: queue.append(newWord)\n                            → Step 12: if current ∉ neighbors: neighbors[current] ← []\n                            → Step 13: neighbors[current].append(newWord) // 記錄相鄰關係\n                        No:\n                            → Decision: distance[newWord] == distance[current] + 1? // 仍是最短路徑\n                                Yes:\n                                    → Step 14: if current ∉ neighbors: neighbors[current] ← []\n                                    → Step 15: neighbors[current].append(newWord) // 同層相鄰\n                                No:\n                                    → Step 16: // 跳過，因為不是最短路徑\n                No:\n                    → Step 17: // 跳過，因為詞不在字典內\n\n→ Decision: endWord ∉ distance? // BFS 未達到終點\n    Yes → End // 無路徑，直接結束\n    No  // 繼續\n\n→ Step 18: result ← [] // 儲存所有最短路徑\n\n→ Step 19: define backtrack(current, path):\n    → Decision: current == endWord? // 到達終點\n        Yes:\n            → Step 20: result.append(copy(path)) // 收集完整路徑\n            → Step 21: return\n        No:\n            → Step 22: if current ∈ neighbors:\n                → for nextWord in neighbors[current]: // 遍歷相鄰詞\n                    → Step 23: path.append(nextWord)\n                    → Step 24: backtrack(nextWord, path)\n                    → Step 25: path.pop() // 回溯\n\n→ Step 26: backtrack(beginWord, [beginWord]) // 開始回溯\n\nEnd // 程式執行結束，返回 result"
    },
    {
      "title": "Generate Random Point in a Circle",
      "source_file": "Leetcode/leetcode478.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]",
          "expected_output": "[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[-0.02493,-0.38077],[0.82314,0.38945],[0.36572,0.17248]]'\nGot (Norm):      '[null,[0.49189353611455383,0.5921294242023397],[-0.5506057723561439,0.16064570109577872],[0.6617913193894396,-0.2653050136589802]]'\n--- (Raw) ---\nRaw Expected: '[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]'\nRaw Got:      '[null, [0.49189353611455383, 0.5921294242023397], [-0.5506057723561439, 0.16064570109577872], [0.6617913193894396, -0.2653050136589802]]'"
        }
      ],
      "generated_code": "import sys\nimport math\nimport random\nimport json\nimport ast\n\nclass Solution:\n    def __init__(self, radius: float, x_center: float, y_center: float):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n\n    def randPoint(self):\n        # 使用極座標生成均勻分布的隨機點\n        r = self.radius * math.sqrt(random.random())          # 半徑 r 的分布\n        theta = random.uniform(0, 2 * math.pi)                # 角度 θ\n        x = self.x_center + r * math.cos(theta)               # x 座標\n        y = self.y_center + r * math.sin(theta)               # y 座標\n        return [x, y]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        sys.exit()\n    # 第一行：方法名稱列表\n    ops = ast.literal_eval(data[0])\n    # 第二行：每個方法的參數列表\n    params = ast.literal_eval(data[1])\n\n    obj = None\n    results = []\n\n    for op, par in zip(ops, params):\n        if op == \"Solution\":\n            obj = Solution(*par)\n            results.append(None)          # 在 JSON 中會轉成 null\n        elif op == \"randPoint\":\n            if obj is None:\n                results.append(None)\n            else:\n                results.append(obj.randPoint())\n        else:\n            results.append(None)\n\n    # 輸出 JSON 格式的結果，保持與範例相同的 null 表示\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step with explanations, no actual code. Provide for class initialization and randPoint method. Use Start, End, Decision. Provide steps. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類別 Solution // 建立一個類別來封裝圓的資料  \n→ Step 2: 建構子 Solution(radius, x_center, y_center)  \n  → Store radius, x_center, y_center  // 儲存圓的半徑與中心座標  \n→ Step 3: 定義方法 randPoint()  \n  → Decision: 是否需要新的隨機點? // 確認每次呼叫都生成新點  \n   Yes → Step 4: 隨機產生 r (0 ≤ r ≤ radius)  \n     → 用平方根技巧: r = radius × sqrt(random_uniform(0,1)) // 保證面積均勻分布  \n     → Decision: 隨機產生 θ (0 ≤ θ < 2π)  \n      Yes → Step 5: θ = 2π × random_uniform(0,1) // 均勻角度  \n      Yes → Step 6: 計算點座標  \n       x = x_center + r × cos(θ) // 圓上點的 x 座標  \n       y = y_center + r × sin(θ) // 圓上點的 y 座標  \n       → Step 7: 回傳 [x, y] // 回傳隨機點  \n      No → End // 若角度決策失敗，結束  \n   No → End // 若不需要新點，結束  \nEnd // 程式執行結束"
    },
    {
      "title": "Count Numbers with Unique Digits",
      "source_file": "Leetcode/leetcode357.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 2",
          "expected_output": "91",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '91'\nGot (Norm):      '82'\n--- (Raw) ---\nRaw Expected: '91'\nRaw Got:      '82'"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef count_numbers_with_unique_digits(n: int) -> int:\n    \"\"\"\n    計算 0 <= x < 10**n 且 x 內的每個數位都不重複的數字總數。\n    \"\"\"\n    if n == 0:\n        return 1  # 只有 0\n    # 超過 10 位時，最多只有 10 個不同數位\n    n = min(n, 10)\n\n    count = 1          # 包含 0\n    available = 9      # 第一位可選 1~9\n    permutations = 9   # 第一位的排列數\n\n    for i in range(1, n + 1):\n        if i == 1:\n            count += permutations\n        else:\n            available -= 1\n            permutations *= available\n            count += permutations\n    return count\n\ndef main() -> None:\n    # 讀取整個輸入，從中提取第一個整數\n    data = sys.stdin.read()\n    nums = re.findall(r'-?\\d+', data)\n    if not nums:\n        return\n    n = int(nums[0])\n    result = count_numbers_with_unique_digits(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm: count numbers with unique digits less than 10^n. Known solution: if n==0 return 1; else count =1; permutations: 9 * 9 * 8 * ... up to n. Actually count of unique-digit numbers <= 10^n -1. For n>=10, maximum unique digits is 10 (0-9). So answer = 10! + sum for i=1..10: 9*P(9, i-1). But easier: iterate i from 1 to n: if i==1: count+=9; else if i>10: break; else count+=9*P(9, i-1). Add 1 for zero. Provide steps.\n\nWe need to produce virtual code line by line with explanation. Use Start, End, Decision.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 接收整數 n // 取得輸入的位數上限\n→ Decision: n 是否小於等於 0? // 檢查特殊情況\n    Yes → Step 2: 回傳 1 // 只有數字 0 符合條件\n    No  → Step 3: 初始化 count 為 1 // 計算中包含 0\n→ Step 4: 初始化 permutations 為 9 // 第一位可選 1-9\n→ Step 5: 初始化 i 為 1 // 目前處理的位數\n→ Decision: i 是否小於等於 n? // 循環處理每一位\n    Yes → Decision: i 是否等於 1? // 第一位的特殊處理\n        Yes → Step 6: 加總 count += permutations // 加入第一位可選的 9 個數字\n        No  → Decision: i 是否大於 10? // 超過 10 位時無法再有唯一數字\n            Yes → Step 7: 退出循環 // 之後所有位數都不可能有唯一數字\n            No  → Step 8: 計算 permutations *= (10 - i) // 下一位可選數量\n                    → Step 9: 加總 count += permutations // 加入新位數可選的數量\n    No  → Step 10: 跳出循環 // 已處理完所有位數\n→ Step 11: 回傳 count // 結果即為唯一數字的個數\nEnd // 程式執行結束"
    },
    {
      "title": "Shuffle an Array",
      "source_file": "Leetcode/leetcode384.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"], [[[1, 2, 3]], [], [], []]",
          "expected_output": "[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[3,1,2],[1,2,3],[1,3,2]]'\nGot (Norm):      '[null,[3,2,1],[1,2,3],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]'\nRaw Got:      '[null, [3, 2, 1], [1, 2, 3], [3, 1, 2]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, nums):\n        # 存儲原始陣列，確保不被後續操作改變\n        self.original = list(nums)\n\n    def reset(self):\n        # 回傳原始陣列\n        return list(self.original)\n\n    def shuffle(self):\n        # 使用 Fisher‑Yates 洗牌演算法\n        arr = list(self.original)\n        n = len(arr)\n        for i in range(n - 1, 0, -1):\n            j = random.randint(0, i)\n            arr[i], arr[j] = arr[j], arr[i]\n        return arr\n\nif __name__ == \"__main__\":\n    # 讀取完整輸入\n    raw = sys.stdin.read().strip()\n    if not raw:\n        sys.exit(0)\n\n    # 把輸入包裝成一個外層列表，便於 json 解析\n    data = json.loads(f'[{raw}]')\n    methods, args_list = data[0], data[1]\n\n    outputs = []\n    obj = None\n\n    for method, args in zip(methods, args_list):\n        if method == \"Solution\":\n            obj = Solution(args[0])\n            outputs.append(None)\n        elif method == \"reset\":\n            outputs.append(obj.reset())\n        elif method == \"shuffle\":\n            outputs.append(obj.shuffle())\n\n    # 使用 json.dumps 以得到符合 LeetCode 風格的輸出\n    print(json.dumps(outputs))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. Need to outline algorithm: store original copy, reset returns original, shuffle uses Fisher-Yates. Steps: initialization, reset, shuffle. Use Start End, Decision. Provide line by line.\n\nWe should produce virtual code for class, constructor, reset, shuffle. Use pseudo code. Provide explanation after each line.\n\nLet's create lines:\n\nStart // program start (not needed maybe for class?). But for algorithm.\n\nBut we need to produce step by step algorithm for entire solution.\n\nWe can structure:\n\nStart // Initialize Solution with array\n\n→ Step 1: Store original array copy in variable original // keep original state\n\n→ Step 2: Set current array reference to original // for operations\n\n→ Step 3: End constructor // finished\n\nReset function:\n\nStart // reset function\n\n→ Step 1: Set current array reference to original // restore\n\n→ Step 2: Return current array // return reset\n\n→ End // end of reset\n\nShuffle function:\n\nStart // shuffle function\n\n→ Step 1: Copy current array to temp array // work on copy\n\n→ Step 2: For i from temp length-1 down to 1: // Fisher-Yates\n\n    → Decision: Generate random index j between 0 and i inclusive\n\n        Yes → Step 3: Swap temp[i] and temp[j] // swap elements\n\n    → Next iteration\n\n→ Step 4: Return temp // shuffled array\n\n→ End // end shuffle\n\nBut we need arrow format: →, Yes →, No →. For loop we can use Decision: \"i>0\"? But better use for loop. But we can represent as Decision: i>0? Yes→ iterate else end.\n\nWe'll produce pseudocode with loops and decisions.\n\nLet's craft final output with each line and explanation. Ensure each line ends with // 解釋/說明.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 設定變數 original 為 nums 的深複製 // 保留原始陣列\n→ Step 2: 設定變數 current 為 original 的引用 // 以備後續操作\n→ End // 建構子結束，物件已初始化\n\nStart // reset 函式開始執行\n→ Step 1: 將 current 設為 original 的引用 // 重設為原始配置\n→ Step 2: 回傳 current // 回傳已重設的陣列\n→ End // reset 函式結束\n\nStart // shuffle 函式開始執行\n→ Step 1: 取得 current 的複製，存入 temp // 為了保證原陣列不變\n→ Decision: i = temp.length - 1 是否大於 0? // 判斷是否需要進行洗牌\n    Yes → Step 2: 進入 for 迴圈，從 i = temp.length - 1 迭代至 1\n        → Step 3: 生成隨機整數 j，範圍為 0~i // 隨機選擇交換位置\n        → Step 4: 交換 temp[i] 與 temp[j] // 執行 Fisher‑Yates 交換\n        → Next iteration // i 自減 1，繼續迴圈\n    No  → Step 5: 跳過迴圈 // 若陣列長度為 0 或 1，直接回傳\n→ Step 6: 回傳 temp // 回傳已洗牌的陣列\n→ End // shuffle 函式結束"
    },
    {
      "title": "Subsets",
      "source_file": "Leetcode/leetcode78.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nGot (Norm):      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nRaw Got:      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport ast\n\ndef subsets(nums):\n    \"\"\"回傳 nums 的所有子集（冪集）。\"\"\"\n    res = []\n\n    def backtrack(start, path):\n        res.append(path[:])          # 目前子集加入結果\n        for i in range(start, len(nums)):\n            path.append(nums[i])     # 選取 nums[i]\n            backtrack(i + 1, path)   # 進入下一層\n            path.pop()               # 回溯，移除 nums[i]\n\n    backtrack(0, [])\n    return res\n\ndef parse_input(s: str):\n    \"\"\"解析輸入字串得到整數列表。\"\"\"\n    s = s.strip()\n    if '=' in s:\n        _, arr_str = s.split('=', 1)\n        arr_str = arr_str.strip()\n    else:\n        arr_str = s\n    # 安全評估字串為列表\n    try:\n        return ast.literal_eval(arr_str)\n    except Exception:\n        return []\n\ndef main():\n    data = sys.stdin.read()\n    nums = parse_input(data)\n    result = subsets(nums)\n    # 用逗號和冒號沒有空格的格式輸出，符合範例要求\n    print(json.dumps(result, separators=(',', ':')))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode for generating power set of unique elements array. Should produce all subsets. Use backtracking. Each step. Use Start, End, Decision. Each line with explanation. We'll produce algorithm.\n\nWe'll include steps: start, input array, initialize result, start backtracking with index 0 and empty subset, recursion, add subset to result, decision whether to include element or not, proceed.\n\nNeed to produce each line as \"虛擬碼步驟 // 解釋\". Use arrows. Use 'Decision:' for if. Indent for nested. Provide Start and End.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入唯一整數陣列 nums // 取得輸入資料  \n→ Step 2: 初始化結果列表 subsets 為空集合 // 用於存放所有子集  \n→ Step 3: 呼叫 backtrack(0, []) // 從索引 0 開始遞迴，當前子集為空  \n→ Step 4: 回傳 subsets // 結束前輸出所有子集  \n\n→ Subroutine backtrack(idx, current) // idx 為當前處理元素索引，current 為已選取元素集合  \n    → Decision: idx 是否已達陣列長度？ // 判斷是否已處理完所有元素  \n        Yes → Step 5: 將 current 加入 subsets // 目前子集為一個合法子集  \n        No  → Step 6: Step 7 → Step 8  \n            → Step 7: 將 current 複製並加入 subsets // 保存目前子集（不包含 nums[idx]）  \n            → Decision: 是否將 nums[idx] 加入 current？ // 再決定是否選取當前元素  \n                Yes → Step 9: current.append(nums[idx]) // 將 nums[idx] 加入子集  \n                    → backtrack(idx+1, current) // 進入下一層遞迴  \n                    → Step 10: current.pop() // 從 current 中移除 nums[idx]，回溯  \n                No  → backtrack(idx+1, current) // 直接跳到下一層遞迴，保持 current 不變  \n    → End // 回到上一層遞迴  \nEnd // 程式執行結束"
    },
    {
      "title": "Task Scheduler",
      "source_file": "Leetcode/leetcode621.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 2",
          "expected_output": "8",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '8'\nGot (Norm):      '7'\n--- (Raw) ---\nRaw Expected: '8'\nRaw Got:      '7'"
        },
        {
          "example_index": 2,
          "input": "tasks = [\"A\",\"A\",\"A\", \"B\",\"B\",\"B\"], n = 3",
          "expected_output": "10",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '10'\nGot (Norm):      '9'\n--- (Raw) ---\nRaw Expected: '10'\nRaw Got:      '9'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import Counter\n\ndef least_interval(tasks, n):\n    \"\"\"\n    計算完成所有任務所需的最小 CPU 週期數。\n    \"\"\"\n    # 1. 統計每個任務類型的頻率\n    freq = Counter(tasks)\n\n    # 2. 找出最高頻率以及有多少種類型達到這個最高頻率\n    max_freq = max(freq.values())\n    max_count = sum(1 for c in freq.values() if c == max_freq)\n\n    # 3. 根據「最頻繁任務」計算所需的空格數\n    #    空格數 = (max_freq - 1) * n\n    #    最終間隔 = 空格數 + total_tasks\n    #    若空格足以被其他任務填滿，則不需要額外的 idle 時間\n    idle_slots = (max_freq - 1) * n\n    remaining_tasks = len(tasks) - max_freq\n    idle = max(0, idle_slots - remaining_tasks)\n\n    return len(tasks) + idle\n\ndef main():\n    # 從標準輸入讀取整個內容\n    data = sys.stdin.read()\n    if not data:\n        return\n\n    # 使用正則表達式抽取 tasks 列表和 n 的值\n    tasks_match = re.search(r'tasks\\s*=\\s*(\\[[^\\]]*\\])', data)\n    n_match = re.search(r'n\\s*=\\s*(-?\\d+)', data)\n\n    # 若解析失敗則直接返回\n    if not tasks_match or not n_match:\n        print(\"0\")\n        return\n\n    # 使用 ast.literal_eval 解析列表字面量，確保安全\n    tasks = ast.literal_eval(tasks_match.group(1))\n    n = int(n_match.group(1))\n\n    # 計算並輸出結果\n    result = least_interval(tasks, n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce a step-by-step pseudo-code algorithm for the described problem: scheduling tasks with cooldown n between same task types, minimal intervals. Standard solution: count frequencies, find max frequency, compute idle slots, etc. Let's produce algorithm steps:\n\n1. Count frequencies of each task label.\n2. Find max frequency (maxCount) and number of tasks that have that frequency (maxCountTasks).\n3. Compute idle slots: (maxCount -1) * n - (total tasks - maxCountTasks)\n4. If idle slots < 0, return total tasks else return total tasks + idle slots.\n\nWe need to output each step as a line with explanation. Use arrow, Decision etc. Let's craft:\n\nStart\n→ Step 1: Count frequencies of each task label // Build a map of task counts\n→ Step 2: Find maxCount = maximum frequency among all labels // Highest occurrence\n→ Step 3: Count maxCountTasks = number of labels that appear maxCount times // Handles ties\n→ Step 4: Calculate emptySlots = (maxCount - 1) * n // Number of gaps between the most frequent tasks\n→ Decision: emptySlots < total tasks - maxCountTasks? // Are there enough tasks to fill gaps?\n    Yes → Step 5: idle = emptySlots - (total tasks - maxCountTasks) // Idle slots after filling\n    No → Step 5: idle = 0 // No idle needed\n→ Step 6: Return total tasks + idle // Minimum intervals\n\nBut we need to use Decision: and Yes/No arrow. Provide explanation for each.\n\nAlso mention total tasks variable as sum of frequencies.\n\nLet's produce lines:\n\nStart // Program starts\n→ Step 1: totalTasks = sum of all task counts // Count all tasks\n→ Step 2: maxCount = max frequency among tasks // Highest frequency\n→ Step 3: maxCountTasks = count of tasks having frequency == maxCount // How many reach max\n→ Step 4: emptySlots = (maxCount - 1) * n // Slots between max tasks\n→ Decision: emptySlots > totalTasks - maxCountTasks? // Determine if gaps are larger than other tasks\n    Yes → Step 5: idle = emptySlots - (totalTasks - maxCountTasks) // Remaining idle slots after filling\n    No  → Step 5: idle = 0 // No idle slots needed\n→ Step 6: minIntervals = totalTasks + idle // Total intervals needed\nEnd // Program ends\n\nAlso we might add Step 0: Build frequency map but that's Step 1? Let's include Step 0: freqMap = map tasks to counts. But we can keep.\n\nMake sure each line has \"虛擬碼步驟\" and comment.\n\nAlso ensure arrow lines use \"→\".\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 0: freqMap = count frequency of each task label // 建立每個字母的出現次數  \n→ Step 1: totalTasks = sum of all frequencies in freqMap // 取得所有任務總數  \n→ Step 2: maxCount = maximum frequency value in freqMap // 找出最頻繁的任務類型  \n→ Step 3: maxCountTasks = number of labels whose frequency == maxCount // 計算達到最大頻率的類型數  \n→ Step 4: emptySlots = (maxCount - 1) * n // 在最頻繁任務之間的可空間數  \n→ Decision: emptySlots > (totalTasks - maxCountTasks) ? // 判斷空間是否還有多餘  \n    Yes → Step 5: idle = emptySlots - (totalTasks - maxCountTasks) // 需要的閒置時間  \n    No  → Step 5: idle = 0 // 無閒置時間  \n→ Step 6: minIntervals = totalTasks + idle // 最少 CPU 週期數  \nEnd // 程式執行結束"
    },
    {
      "title": "Range Sum Query - Immutable",
      "source_file": "Leetcode/leetcode303.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"NumArray\", \"sumRange\", \"sumRange\", \"sumRange\"], [[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]",
          "expected_output": "[null, 1, -1, -3]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpo7_99y4m.py\", line 43, in <module>\n    main()\n  File \"/tmp/tmpo7_99y4m.py\", line 20, in main\n    ops = json.loads(data[0].strip())\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 49 (char 48)"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass NumArray:\n    def __init__(self, nums):\n        # 建立前綴和陣列，prefix_sums[0] 為 0，方便區間求和\n        self.prefix_sums = [0]\n        for num in nums:\n            self.prefix_sums.append(self.prefix_sums[-1] + num)\n\n    def sumRange(self, left, right):\n        # 区间和 = prefix_sums[right+1] - prefix_sums[left]\n        return self.prefix_sums[right + 1] - self.prefix_sums[left]\n\ndef main():\n    # 讀取所有輸入，預期兩行：操作名與對應參數\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    ops = json.loads(data[0].strip())\n    args = json.loads(data[1].strip()) if len(data) > 1 else []\n\n    obj = None\n    outputs = []\n\n    for op, arg in zip(ops, args):\n        if op == \"NumArray\":\n            # arg 為 [[...]]，取第一個元素作為初始陣列\n            nums = arg[0] if isinstance(arg, list) else arg\n            obj = NumArray(nums)\n            outputs.append(None)  # NumArray 建構子返回 null\n        elif op == \"sumRange\":\n            # arg 為 [left, right]\n            left, right = arg\n            outputs.append(obj.sumRange(left, right))\n        else:\n            outputs.append(None)  # 未知操作，回傳 null\n\n    # 將結果轉成 JSON 字串並輸出\n    print(json.dumps(outputs))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the task. So steps: Start, initialize array, compute prefix sums perhaps, or use fenwick tree. We just need to illustrate design.\n\nWe need to output line-by-line virtual code with explanations. Let's produce:\n\nStart // 程式開始\n→ Step 1: 建立 NumArray 類別並定義建構子 // 定義類別及建構子\n→ Step 2: 在建構子內宣告 private int[] nums; private int[] prefix; // 儲存原始陣列與前綴和\n→ Step 3: Copy nums 到 this.nums; // 複製輸入陣列\n→ Step 4: 初始化 prefix[0] = 0; // 前綴和第一個為 0\n→ Step 5: 循環 i 0 to nums.length-1: prefix[i+1] = prefix[i] + nums[i]; // 計算前綴和\n→ Step 6: 結束建構子 // 建構完畢\n→ Step 7: 定義 sumRange 方法 // 進行區間求和\n→ Step 8: 取得 sum = prefix[right+1] - prefix[left]; // 前綴和差值即為區間和\n→ Step 9: 回傳 sum; // 返回結果\nEnd // 程式結束\n\nBut we need \"Decision\" maybe not necessary. Just linear steps.\n\nMake sure each line: \"虛擬碼步驟 // 解釋\" So we should include the step lines like \"Start\", \"→ NumArray Constructor ...\", etc.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 NumArray 類別 // 建立類別框架  \n→ Step 2: 宣告 private int[] nums, prefix // 用於儲存原始陣列與前綴和  \n→ Step 3: NumArray(int[] nums) { // 建構子開始  \n→ Decision: 如果 nums 為 null? // 檢查輸入陣列是否有效  \n  Yes → prefix = new int[0]; // 若為 null，前綴和空陣列  \n  No → Step 4: this.nums = nums.clone(); // 複製輸入陣列到實例變數  \n  No → Step 5: prefix = new int[nums.length + 1]; // 初始化前綴和陣列  \n  No → Step 6: prefix[0] = 0; // 前綴和第一個元素為 0  \n  No → Step 7: for (int i = 0; i < nums.length; i++) { // 迴圈計算前綴和  \n    prefix[i + 1] = prefix[i] + nums[i]; // 前綴和累加  \n   } // 迴圈結束  \n  No → End // 建構子結束  \n→ Step 8: int sumRange(int left, int right) { // sumRange 方法開始  \n→ Decision: 是否 left <= right? // 確認索引合法  \n  No → throw new IllegalArgumentException(\"left must be <= right\"); // 非法索引  \n  Yes → Step 9: int sum = prefix[right + 1] - prefix[left]; // 使用前綴和求區間和  \n  Yes → Step 10: return sum; // 回傳計算結果  \n  Yes → End // 方法結束  \nEnd // 程式執行結束"
    },
    {
      "title": "LFU Cache",
      "source_file": "Leetcode/leetcode460.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"LFUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"get\", \"put\", \"get\", \"get\", \"get\"], [[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]",
          "expected_output": "[null, null, null, 1, null, -1, 3, null, -1, 3, 4]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpbb3u8zjn.py\", line 54, in <module>\n    commands, values = json.loads(raw_input)\n                       ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 83 (char 82)"
        }
      ],
      "generated_code": "import sys\nimport json\nfrom collections import defaultdict, OrderedDict\n\nclass LFUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.min_freq = 0\n        self.key_to_val_freq = {}               # key -> (value, freq)\n        self.freq_to_keys = defaultdict(OrderedDict)  # freq -> OrderedDict of keys\n\n    def _update(self, key: int):\n        value, freq = self.key_to_val_freq[key]\n        # Remove key from its current frequency list\n        del self.freq_to_keys[freq][key]\n        if not self.freq_to_keys[freq]:\n            del self.freq_to_keys[freq]\n            if self.min_freq == freq:\n                self.min_freq += 1\n        # Add key to the next frequency list\n        self.freq_to_keys[freq + 1][key] = None\n        self.key_to_val_freq[key] = (value, freq + 1)\n\n    def get(self, key: int) -> int:\n        if key not in self.key_to_val_freq:\n            return -1\n        self._update(key)\n        return self.key_to_val_freq[key][0]\n\n    def put(self, key: int, value: int) -> None:\n        if self.capacity == 0:\n            return\n        if key in self.key_to_val_freq:\n            # Update value and frequency\n            self.key_to_val_freq[key] = (value, self.key_to_val_freq[key][1])\n            self._update(key)\n            return\n        if len(self.key_to_val_freq) >= self.capacity:\n            # Evict least frequently used key\n            evict_key, _ = self.freq_to_keys[self.min_freq].popitem(last=False)\n            del self.key_to_val_freq[evict_key]\n            if not self.freq_to_keys[self.min_freq]:\n                del self.freq_to_keys[self.min_freq]\n        # Insert new key with frequency 1\n        self.key_to_val_freq[key] = (value, 1)\n        self.freq_to_keys[1][key] = None\n        self.min_freq = 1\n\nif __name__ == \"__main__\":\n    # Read entire input (JSON formatted list of commands and args)\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n    commands, values = json.loads(raw_input)\n    res = []\n    cache = None\n    for cmd, args in zip(commands, values):\n        if cmd == \"LFUCache\":\n            cache = LFUCache(args[0])\n            res.append(None)\n        elif cmd == \"put\":\n            cache.put(args[0], args[1])\n            res.append(None)\n        elif cmd == \"get\":\n            res.append(cache.get(args[0]))\n    # Output results in JSON format (None -> null)\n    print(json.dumps(res))",
      "virtual_code": "Thinking...\nWe need to produce virtual code for LFU cache algorithm. Use O(1). Use frequency map, key->node, freq list of doubly linked lists. Provide step-by-step algorithm lines with explanations. Use Start, End, Decision, etc. Each line: virtual code + // explanation.\n\nWe need to design a virtual code for initialization, get, put, helper to increase freq, evict.\n\nWe need to output line by line. Let's produce the overall structure: Start -> Initialize LFUCache: capacity, minFreq, keyToNode, freqToDLL. For get: Decision if key exists, else return -1. If exists, increase frequency, return value. For put: if capacity zero, return. If key exists, update value and increase freq. Else if size==capacity, evict minFreq LRU. Then insert new node with freq 1, minFreq=1. Increase size. Provide explanation.\n\nAlso need functions: increaseFreq(key) moves node from freq list to freq+1 list, update minFreq if needed. EvictNode: remove LRU from minFreq list, remove from keyToNode, decrement size.\n\nLet's structure lines accordingly. Use arrow lines. Let's produce about 30-40 lines.\n\nEnsure each line ends with comment. Provide decision indent. Use indentation like 4 spaces? The example uses spaces before Yes → etc. We'll replicate.\n\nLet's write:\n\nStart // 程式開始\n→ Initialize LFUCache(capacity) // 建構子: 初始化容量與資料結構\n    Key: capacity ← capacity // 儲存最大容量\n    Key: size ← 0 // 現有鍵數量\n    Key: minFreq ← 0 // 最小頻率\n    Key: keyToNode ← new HashMap // key → Node\n    Key: freqToDLL ← new HashMap // freq → DoublyLinkedList\n\nDefine Node structure: key, value, freq, prev, next // 节点结构\n\nDefine DoublyLinkedList with head/tail dummy nodes, size // 频率链表\n\nDefine get(key)\n→ Decision: 如果 key 不在 keyToNode? // 判断键是否存在\n    Yes → Return -1 // 不存在则返回 -1\n    No  → Node ← keyToNode[key] // 获取节点\n    → IncreaseFreq(Node) // 更新频率\n    → Return Node.value // 返回值\n\nDefine put(key, value)\n→ Decision: 如果 capacity == 0? // 容量为0直接返回\n    Yes → End // 结束\n    No  →\n→ Decision: 如果 key 在 keyToNode? // 键已存在\n    Yes →\n        Node ← keyToNode[key]\n        Node.value ← value\n        → IncreaseFreq(Node) // 更新频率\n    No →\n        → Decision: 如果 size == capacity? // 是否需要驱逐\n            Yes →\n                → EvictLFU() // 移除最少频率最久未使用键\n            No  →\n        → Node ← new Node(key, value, freq=1)\n        → keyToNode[key] ← Node\n        → freqToDLL[1].addLast(Node) // 添加到 freq=1 列表\n        → size ← size + 1\n        → minFreq ← 1 // 新插入键的频率为1，重置最小频率\n\nDefine IncreaseFreq(node)\n→ Remove node from freqToDLL[node.freq] // 从旧频率链表移除\n→ If freqToDLL[node.freq].size == 0? // 列表为空\n    Yes →\n        → Remove freqToDLL[node.freq]\n        → Decision: 如果 node.freq == minFreq? // 旧最小频率已空\n            Yes → minFreq ← minFreq + 1\n            No  →\n    No  →\n→ node.freq ← node.freq + 1\n→ freqToDLL[node.freq] ← freqToDLL.getOrDefault(node.freq, new DoublyLinkedList)\n→ freqToDLL[node.freq].addLast(node) // 添加到新频率链表\n\nDefine EvictLFU()\n→ List ← freqToDLL[minFreq] // 最小频率链表\n→ Node ← List.head.next // LRU 节点\n→ Remove node from List\n→ Delete keyToNode[node.key]\n→ size ← size - 1\n→ Decision: 如果 List.size == 0? // 列表为空后需更新最小频率\n    Yes →\n        → Remove freqToDLL[minFreq]\n        // minFreq will be updated in put when new node inserted\n    No  →\nEnd // 程式結束\n\nMake sure each line is separate. Ensure proper indentation for decisions and Yes/No arrows.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始\n→ Initialize LFUCache(capacity) // 建構子: 初始化容量與資料結構\n    Key: capacity ← capacity // 儲存最大容量\n    Key: size ← 0 // 現有鍵數量\n    Key: minFreq ← 0 // 最小頻率\n    Key: keyToNode ← new HashMap // key → Node\n    Key: freqToDLL ← new HashMap // freq → DoublyLinkedList\n\n// 節點結構\n→ Node(key, value, freq=1, prev=null, next=null) // 每個節點含鍵、值、頻率與鏈表指標\n\n// 雙向鏈表結構（頻率鏈表）\n→ DoublyLinkedList() // 以 dummy head/tail 形式存儲節點，保持插入順序\n\n// ==================== get 操作 ====================\n→ get(key) // 取得鍵對應值\n    → Decision: 如果 key 不在 keyToNode? // 判斷鍵是否存在\n        Yes → Return -1 // 不存在則回傳 -1\n        No  → Node ← keyToNode[key] // 取得節點\n        → IncreaseFreq(Node) // 更新頻率\n        → Return Node.value // 回傳對應值\n\n// ==================== put 操作 ====================\n→ put(key, value) // 插入或更新鍵\n    → Decision: 如果 capacity == 0? // 容量為 0 時直接返回\n        Yes → End // 結束\n        No  →\n    → Decision: 如果 key 在 keyToNode? // 鍵已存在\n        Yes →\n            Node ← keyToNode[key]\n            Node.value ← value\n            → IncreaseFreq(Node) // 更新頻率\n        No →\n            → Decision: 如果 size == capacity? // 是否需要驅逐\n                Yes →\n                    → EvictLFU() // 移除最少頻率最久未使用鍵\n                No  →\n            Node ← new Node(key, value, freq=1)\n            → keyToNode[key] ← Node\n            → freqToDLL[1].addLast(Node) // 加入 freq=1 列表\n            → size ← size + 1\n            → minFreq ← 1 // 新插入鍵的頻率為 1，重置最小頻率\n\n// ==================== 內部輔助函式 ====================\n→ IncreaseFreq(node) // 將節點頻率加 1\n    → Remove node from freqToDLL[node.freq] // 從舊頻率列表移除\n    → Decision: 如果 freqToDLL[node.freq].size == 0? // 列表是否空\n        Yes →\n            → Remove freqToDLL[node.freq] // 刪除空頻率列表\n            → Decision: 如果 node.freq == minFreq? // 旧最小頻率已空\n                Yes → minFreq ← minFreq + 1 // 更新最小頻率\n                No  →\n        No  →\n    node.freq ← node.freq + 1\n    → freqToDLL[node.freq] ← freqToDLL.getOrDefault(node.freq, new DoublyLinkedList)\n    → freqToDLL[node.freq].addLast(node) // 加入新頻率列表\n\n→ EvictLFU() // 驅逐最少頻率、最久未使用的節點\n    → List ← freqToDLL[minFreq] // 取最小頻率列表\n    → Node ← List.head.next // 最久未使用節點（最近一次操作最少）\n    → Remove node from List\n    → Delete keyToNode[node.key]\n    → size ← size - 1\n    → Decision: 如果 List.size == 0? // 列表空後需更新 minFreq\n        Yes →\n            → Remove freqToDLL[minFreq] // 刪除空列表\n            // minFreq 將在 put 時被重設為 1\n        No  →\n\nEnd // 程式結束"
    },
    {
      "title": "Contains Duplicate III",
      "source_file": "Leetcode/leetcode220.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,1], indexDiff = 3, valueDiff = 0",
          "expected_output": "true",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpezifoo0z.py\", line 47, in <module>\n    nums, index_diff, value_diff = parse_input(input_text)\n                                   ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpezifoo0z.py\", line 40, in parse_input\n    parsed[key] = eval(val)  # safely evaluate list of integers\n                  ^^^^^^^^^\n  File \"<string>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "nums = [1,5,9,1,5,9], indexDiff = 2, valueDiff = 3",
          "expected_output": "false",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpywsu869m.py\", line 47, in <module>\n    nums, index_diff, value_diff = parse_input(input_text)\n                                   ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpywsu869m.py\", line 40, in parse_input\n    parsed[key] = eval(val)  # safely evaluate list of integers\n                  ^^^^^^^^^\n  File \"<string>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport re\nfrom bisect import bisect_left, insort\n\ndef contains_nearby_almost_duplicate(nums, k, t):\n    if k <= 0 or t < 0:\n        return False\n    window = []  # sorted list of current window elements\n    for i, num in enumerate(nums):\n        # check for an element within [num - t, num + t]\n        pos = bisect_left(window, num - t)\n        if pos < len(window) and abs(window[pos] - num) <= t:\n            return True\n        # insert current number into the sorted window\n        insort(window, num)\n        # maintain window size <= k\n        if len(window) > k:\n            # remove the element that is now out of the window\n            out_val = nums[i - k]\n            idx = bisect_left(window, out_val)\n            # skip duplicates until we find the exact value\n            while idx < len(window) and window[idx] != out_val:\n                idx += 1\n            if idx < len(window):\n                window.pop(idx)\n    return False\n\ndef parse_input(data_str):\n    \"\"\"\n    Expected format:\n    nums = [1,2,3,1], indexDiff = 3, valueDiff = 0\n    \"\"\"\n    parts = [p.strip() for p in data_str.split(',')]\n    parsed = {}\n    for part in parts:\n        if not part:\n            continue\n        key, val = [x.strip() for x in part.split('=', 1)]\n        if key == 'nums':\n            parsed[key] = eval(val)  # safely evaluate list of integers\n        else:\n            parsed[key] = int(val)\n    return parsed['nums'], parsed['indexDiff'], parsed['valueDiff']\n\nif __name__ == \"__main__\":\n    input_text = sys.stdin.read().strip()\n    nums, index_diff, value_diff = parse_input(input_text)\n    result = contains_nearby_almost_duplicate(nums, index_diff, value_diff)\n    print(\"true\" if result else \"false\")",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to solve the problem. It's essentially a typical algorithm: sliding window + hashset / balanced BST to check difference. But we just need virtual steps, not actual code. Just pseudocode-like steps. Use Start, Decision etc.\n\nWe need to generate step-by-step, line-by-line, each with explanation. Ensure each line contains \"虛擬碼步驟 [space] // 解釋/說明\". Use arrows.\n\nWe can outline algorithm:\n\nStart\nInitialize empty sorted set or map\nLoop over i from 0 to n-1:\n    While i - oldestIndex > indexDiff: remove nums[oldestIndex] from set, increment oldestIndex\n    Check if there exists value in set within valueDiff of nums[i] (e.g., find lowerBound nums[i]-valueDiff, if <= nums[i]+valueDiff)\n    If found: return true\n    Insert nums[i] into set\nReturn false\n\nWe need to produce virtual code lines like:\n\nStart\n→ Initialize set S ← empty // 用於儲存窗口內的數值\n→ Initialize left ← 0 // 左邊界\n→ Decision: For i from 0 to length(nums)-1? // 迴圈遍歷每個索引\n    → Step: While i - left > indexDiff: remove nums[left] from S; left++ // 讓窗口大小 <= indexDiff\n    → Step: If exists value in S such that abs(value - nums[i]) <= valueDiff: return true // 判斷是否符合 valueDiff\n    → Step: Insert nums[i] into S // 將當前值加入窗口\nEnd\n\nBut we need more detailed lines with decisions.\n\nLet's produce pseudo code line by line:\n\nStart // 程式開始執行\n→ Initialize S ← empty // 建立用於查找差值的資料結構\n→ Initialize left ← 0 // 設定滑動窗口左端\n→ Decision: for i from 0 to nums.length-1? // 遍歷每個索引\n    Yes → Step: While i - left > indexDiff: // 確保窗口長度不超過 indexDiff\n        → Step: Remove nums[left] from S\n        → Step: left ← left + 1\n    → Step: Find candidate in S where abs(candidate - nums[i]) <= valueDiff // 搜尋符合差值的元素\n        Yes → Step: Return true // 找到符合條件的索引對\n        No  → Step: Insert nums[i] into S // 將當前元素加入窗口以備後續比對\nEnd // 程式結束，若未找到則回傳 false\n\nBut the Decision for for-loop? It's not typical; we might express loop as Step: For each i, do steps. Might not need decision.\n\nBetter structure:\n\nStart\n→ Initialize S ← empty\n→ Initialize left ← 0\n→ Step: For i from 0 to length(nums)-1:\n    → Step: While i - left > indexDiff:\n        → Step: Remove nums[left] from S\n        → Step: left ← left + 1\n    → Decision: 是否存在值在 S 且 abs(value - nums[i]) ≤ valueDiff? \n        Yes → Step: Return true\n        No  → Step: Insert nums[i] into S\n→ Step: Return false\n\nBut we need each line with \"虛擬碼步驟\" text; we can just use \"Step:\" or \"Decision:\".\n\nMake sure arrow formatting: \"→\". The arrow for steps inside loop: we can indent by spaces.\n\nLet's produce final answer with lines.\n\nAlso ensure no actual code like array indexing, just pseudocode.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Initialize S ← empty // 建立用於查找符合 valueDiff 的資料結構  \n→ Initialize left ← 0 // 滑動窗口左端索引  \n\n→ Step: For i from 0 to length(nums)-1: // 遍歷每個索引 i  \n    → Step: While i - left > indexDiff: // 保持窗口長度不超過 indexDiff  \n        → Step: Remove nums[left] from S // 從集合中移除最左端元素  \n        → Step: left ← left + 1 // 將左端索引右移  \n    → Decision: 是否存在 value 在 S 使得 abs(value - nums[i]) ≤ valueDiff? // 檢查是否已有符合條件的元素  \n        Yes → Step: Return true // 找到符合條件的索引對，直接回傳 true  \n        No  → Step: Insert nums[i] into S // 將當前元素加入集合，準備與未來元素比對  \n\n→ Step: Return false // 若完整遍歷後仍未找到，回傳 false  \nEnd // 程式結束執行"
    },
    {
      "title": "Random Pick with Weight",
      "source_file": "Leetcode/leetcode528.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"], [[[1,3]],[],[],[],[],[]]",
          "expected_output": "[null,1,1,1,1,0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,1,1,1,1,0]'\nGot (Norm):      '[null,0,1,1,1,1]'\n--- (Raw) ---\nRaw Expected: '[null,1,1,1,1,0]'\nRaw Got:      '[null, 0, 1, 1, 1, 1]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport bisect\n\nclass Solution:\n    def __init__(self, w):\n        self.prefix_sum = []\n        total = 0\n        for weight in w:\n            total += weight\n            self.prefix_sum.append(total)\n        self.total = total\n\n    def pickIndex(self):\n        target = random.randint(1, self.total)\n        return bisect.bisect_left(self.prefix_sum, target)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 將輸入包裝成合法的 JSON，然後解析\n    wrapped = '[' + data + ']'\n    ops, args = json.loads(wrapped)\n\n    results = []\n    obj = None\n    for i, op in enumerate(ops):\n        if op == \"Solution\":\n            obj = Solution(*args[i])\n            results.append(None)\n        elif op == \"pickIndex\":\n            results.append(obj.pickIndex())\n        else:\n            # 若有其他方法，可以在此處擴充\n            results.append(None)\n\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce step-by-step virtual code for implementation of pickIndex function using weighted random selection. Provide algorithm: precompute prefix sums, total sum; then for pickIndex, generate random number between 0 and total-1, binary search in prefix array to find index where random <= prefix[i].\n\nWe must output each line: \"虛擬碼步驟 // 解釋\". Use arrows. Should start with Start, maybe \"Initialize weighted picker\" etc.\n\nThe algorithm: class WeightedRandom { w; prefix; total; constructor(w) -> compute prefix sums and total; pickIndex() -> random between 0 and total-1, binary search.\n\nWe should produce step by step. Also, for binary search we can do while low<high etc.\n\nWe must use \"Start\", \"End\", \"Decision:\" lines.\n\nOk produce.\n\nEnsure each line is separate with newline. Provide arrow after Start? Format example: Start // 程式開始執行. Then arrow lines with \"→\".\n\nSo produce:\n\nStart // 程式開始執行\n→ Initialize class WeightedRandom with array w // 建構函式接受權重陣列\n→ Step 1: 建立 prefixSum 陣列 // 儲存累積權重\n→ Step 2: total = 0 // 初始總重量\n→ Decision: 迴圈遍歷 w? // 逐一處理每個權重\n   Yes → Step 3: total += w[i] // 累加至總重量\n   Yes → Step 4: prefixSum[i] = total // 存入累積值\n   No → End // 完成初始化\n→ Function pickIndex() // 定義隨機選取方法\n→ Step 5: randVal = randomInt(0, total-1) // 產生隨機整數\n→ Decision: 二分搜尋 prefixSum? // 在累積陣列中尋找位置\n   Yes → Step 6: low = 0, high = len(prefixSum)-1 // 二分範圍\n   Yes → Step 7: while low < high: mid = (low+high)//2 // 計算中點\n   Yes → Step 8: Decision: randVal < prefixSum[mid]? // 判斷是否落在左半\n      Yes → high = mid // 移動右邊界\n      No → low = mid + 1 // 移動左邊界\n   No → Step 9: return low // 找到對應索引\nEnd // 程式執行結束\n\nMake sure lines with arrows. Provide correct indentation? The sample uses arrow before Step lines. Provide indentation with tab? It's fine.\n\nAlso we must include // 解釋. Use Chinese. Good.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Initialize class WeightedRandom with array w // 建構函式接受權重陣列  \n→ Step 1: 建立 prefixSum 陣列 // 儲存累積權重  \n→ Step 2: total = 0 // 初始總重量  \n→ Decision: 迴圈遍歷 w? // 逐一處理每個權重  \n Yes → Step 3: total += w[i] // 累加至總重量  \n Yes → Step 4: prefixSum[i] = total // 存入累積值  \n No → End // 完成初始化  \n→ Function pickIndex() // 定義隨機選取方法  \n→ Step 5: randVal = randomInt(0, total-1) // 產生隨機整數  \n→ Decision: 二分搜尋 prefixSum? // 在累積陣列中尋找位置  \n Yes → Step 6: low = 0, high = len(prefixSum)-1 // 二分範圍  \n Yes → Step 7: while low < high: mid = (low+high)//2 // 計算中點  \n Yes → Step 8: Decision: randVal < prefixSum[mid]? // 判斷是否落在左半  \n  Yes → high = mid // 移動右邊界  \n  No → low = mid + 1 // 移動左邊界  \n No → Step 9: return low // 找到對應索引  \nEnd // 程式執行結束"
    },
    {
      "title": "The K Weakest Rows in a Matrix",
      "source_file": "Leetcode/leetcode1337.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "mat = [[1,1,0,0,0],[1,1,1,1,0],[1,0,0,0,0],[1,1,0,0,0],[1,1,1,1,1]], k = 3",
          "expected_output": "[2,0,3]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp17g61qsd.py\", line 32, in <module>\n    main()\n  File \"/tmp/tmp17g61qsd.py\", line 23, in main\n    exec(data, {}, local_vars)\n  File \"<string>\", line 1\n    mat = [[1,1,0,0,0],[1,1,1,1,0],[1,0,0,0,0],[1,1,0,0,0],[1,1,1,1,1]], k = 3\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "mat = [[1,0,0,0],[1,1,1,1],[1,0,0,0],[1,0,0,0]], k = 2",
          "expected_output": "[0,2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpkj7a2q37.py\", line 32, in <module>\n    main()\n  File \"/tmp/tmpkj7a2q37.py\", line 23, in main\n    exec(data, {}, local_vars)\n  File \"<string>\", line 1\n    mat = [[1,0,0,0],[1,1,1,1],[1,0,0,0],[1,0,0,0]], k = 2\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def kWeakestRows(self, mat, k):\n        def count_soldiers(row):\n            left, right = 0, len(row)\n            while left < right:\n                mid = (left + right) // 2\n                if row[mid] == 1:\n                    left = mid + 1\n                else:\n                    right = mid\n            return left\n\n        soldiers = [(count_soldiers(row), i) for i, row in enumerate(mat)]\n        soldiers.sort()\n        return [idx for _, idx in soldiers[:k]]\n\ndef main():\n    data = sys.stdin.read()\n    # Execute the input string which defines 'mat' and 'k'\n    local_vars = {}\n    exec(data, {}, local_vars)\n    mat = local_vars['mat']\n    k = local_vars['k']\n\n    solution = Solution()\n    weakest_rows = solution.kWeakestRows(mat, k)\n    print(weakest_rows)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code lines describing algorithm to find k weakest rows. We must not output real code, only pseudo code. We must adhere to format: each line with virtual code step and comment. Use arrows and Decision. Provide explanation. Use \"Start\" etc.\n\nWe need to describe algorithm: For each row count number of 1s (binary matrix, all 1s left). Use binary search to count. Then create list of pairs (rowIndex, soldierCount). Sort by count ascending, then index ascending. Then take first k indices. Output. We'll express steps in virtual code lines.\n\nWe must do step by step: Start, read matrix, maybe loop over rows, compute soldiers, store. Then sort. Then select k. Then output.\n\nWe need to use virtual code arrow '→' for steps, and 'Decision:' for decisions. Must include 'Start', 'End'.\n\nLet's craft:\n\nStart\n→ Step 1: 獲取矩陣 mat 的尺寸 m, n // 取得行列數\n→ Step 2: 初始化空列表 rows // 用來儲存 (rowIndex, soldierCount)\n→ Decision: 是否已遍歷完所有行？ // 檢查是否完成\n    No  → Step 3: 對於當前行 i，執行 BinarySearchOnRow(mat[i]) 找到 1 的數量 // 取得第 i 行的士兵數\n    → Step 4: Append (i, count) 到 rows // 保存結果\n    → Step 5: 轉到下一行 // 移動到下一行\n    Yes → Decision: 是否所有行已處理？ // 確認完成\n        Yes → Step 6: 對 rows 進行排序，先按 soldierCount 升序，再按 rowIndex 升序 // 排序弱到強\n        Yes → Step 7: 取 rows 的前 k 個元素的 rowIndex 作為答案 // 選取最弱的 k 行\n        Yes → Step 8: 輸出答案 // 回傳結果\nEnd\n\nBut we need to be more explicit about binary search algorithm. Maybe we can add steps inside binary search.\n\nLet's propose:\n\n→ Step 3: BinarySearchOnRow(row)\n    → Step 3.1: low = 0, high = n-1\n    → Decision: low <= high ?\n        Yes → Step 3.2: mid = (low+high)//2\n        → Decision: row[mid] == 1 ?\n            Yes → Step 3.3: low = mid + 1 // 將搜尋區間右移\n            No  → Step 3.4: high = mid - 1 // 將搜尋區間左移\n        No → Step 3.5: return low // low 為 1 的數量\nBut we can keep simple: use linear scan? But requirement: all 1s left. Could use binary search.\n\nHowever the instruction: \"虛擬碼\" can be simplified. They didn't specify we must use binary search, but typical solution uses binary search to count soldiers. So we can include. But we need to keep lines minimal.\n\nBetter: Provide pseudo steps as:\n\nStart\n→ Step 1: m = number of rows in mat, n = number of columns // 獲取尺寸\n→ Step 2: rows = [] // 初始化儲存結果\n→ Step 3: for i from 0 to m-1 // 遍歷每一行\n    → Step 4: count = BinaryCount(mat[i]) // 取得第 i 行的 1 的數量\n    → Step 5: rows.append((i, count)) // 存入元組\n→ Step 6: Sort rows by (count ascending, index ascending) // 排序\n→ Step 7: weakest = [row[0] for row in rows[0:k]] // 取前 k 行索引\n→ Step 8: Output weakest // 回傳結果\nEnd\n\nBut we need to add virtual code for BinaryCount function.\n\nDefine:\n\nBinaryCount(row):\n    low=0, high=len(row)-1\n    while low <= high\n        mid = (low+high)//2\n        if row[mid] == 1\n            low = mid + 1\n        else\n            high = mid - 1\n    return low\n\nBut we need to write in virtual code lines. Let's break.\n\nDefine BinaryCount(row):\n    Start // 函式開始\n    → Step 1: low = 0, high = len(row)-1 // 初始化\n    → Decision: low <= high ?\n        Yes → Step 2: mid = (low+high)//2\n        → Decision: row[mid] == 1 ?\n            Yes → Step 3: low = mid + 1 // 1 在左側，往右搜尋\n            No  → Step 4: high = mid - 1 // 0 在右側，往左搜尋\n        No  → Step 5: Return low // low 為 1 的數量\n    End // 函式結束\n\nBut we need to integrate into main flow. So we can have:\n\n→ Step 4: count = BinaryCount(mat[i]) // 取得第 i 行的 1 的數量\n\nBut we need to keep the virtual code lines separate; maybe treat BinaryCount as separate block. Let's produce final answer: a series of lines with Start/End and steps and decisions.\n\nMake sure to have arrows '→' at start of each step line. Use Decision: for decisions.\n\nAlso ensure each line includes comment after //.\n\nWe must ensure we don't output actual code. But this is pseudocode, but it's allowed.\n\nLet's craft final answer.\n\nWe'll output the virtual code in Chinese comments.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: m = mat 的行數, n = mat 的列數 // 取得矩陣尺寸\n→ Step 2: rows = [] // 用來存放 (行索引, 士兵數量)\n→ Step 3: for i = 0 to m-1 // 遍歷每一行\n    → Decision: i < m ?\n        Yes → Step 3.1: count = BinaryCount(mat[i]) // 計算第 i 行的士兵數\n        → Step 3.2: rows.append((i, count)) // 儲存結果\n        → Step 3.3: i = i + 1 // 進入下一行\n        No → Decision: 是否已處理完所有行？ // 確認是否完成\n            Yes → Step 4: rows.sort(key = (count, index)) // 先按士兵數升序，再按索引升序\n            Yes → Step 5: weakest = [] // 用來儲存最弱的 k 行索引\n            Yes → for j = 0 to k-1\n                → Step 5.1: weakest.append(rows[j][0]) // 取第 j 個最弱行的索引\n            Yes → Step 6: Output weakest // 回傳答案\nEnd // 程式結束\n\nBut this may not be perfect. We need to keep lines separate; each line should be a step or decision. But the loop lines can be grouped. Maybe simpler: Use nested loops with decisions.\n\nBetter to structure as:\n\nStart\n→ Step 1: m, n = size(mat)\n→ Step 2: rows = []\n→ Decision: 是否遍歷完所有行？\n    No → Step 3: i = 0 // 初始化行索引\n    → Decision: i < m ?\n        Yes → Step 3.1: count = BinaryCount(mat[i]) // 計算士兵數\n        → Step 3.2: rows.append((i, count))\n        → Step 3.3: i = i + 1\n        No → Decision: 是否已完成所有行？\n            Yes → Step 4: rows.sort(key = (count, index))\n            Yes → Step 5: result = []\n            Yes → for j = 0 to k-1\n                → Step 5.1: result.append(rows[j][0])\n            Yes → Step 6: Output result\nEnd\n\nBut still we need to define BinaryCount.\n\nDefine BinaryCount(row):\n    Start\n    → Step 1: low = 0, high = len(row)-1\n    → Decision: low <= high ?\n        Yes → Step 2: mid = (low+high)//2\n        → Decision: row[mid] == 1 ?\n            Yes → Step 3: low = mid + 1\n            No  → Step 4: high = mid - 1\n        No → Step 5: Return low\n    End\n\nBut we have to incorporate this inside main.\n\nLet's produce final answer with lines separated and comments. We'll avoid duplication.\n\nMaybe we can produce as:\n\nStart // 程式開始執行\n→ Step 1: m, n = mat.shape // 取得矩陣尺寸\n→ Step 2: rows = [] // 初始化結果列表\n→ Decision: 是否已處理完所有行？ // 檢查是否完成\n    No → Step 3: i = 0 // 行索引初始化\n    → Decision: i < m ?\n        Yes → Step 3.1: count = BinaryCount(mat[i]) // 計算第 i 行的士兵數量\n        → Step 3.2: rows.append((i, count)) // 儲存\n        → Step 3.3: i = i + 1 // 進入下一行\n        No → Decision: 是否所有行已處理？\n            Yes → Step 4: rows.sort(key=lambda x: (x[1], x[0])) // 排序，先士兵數再索引\n            Yes → Step 5: weakest = [] // 產生答案\n            Yes → for j = 0 to k-1\n                → Step 5.1: weakest.append(rows[j][0]) // 取最弱行索引\n            Yes → Step 6: Output weakest // 回傳結果\nEnd // 程式結束\n\nDefine BinaryCount(row):\n    Start // BinaryCount 函式開始\n    → Step 1: low = 0, high = len(row) - 1 // 初始化搜尋範圍\n    → Decision: low <= high ?\n        Yes → Step 2: mid = (low + high) // 2\n        → Decision: row[mid] == 1 ?\n            Yes → Step 3: low = mid + 1 // 1 在左側，搜尋右半部\n            No  → Step 4: high = mid - 1 // 0 在右側，搜尋左半部\n        No → Step 5: Return low // low 為 1 的個數\n    End // BinaryCount 函式結束\n\nWe need to output each line separated. The instructions: \"逐行輸出\" and \"每行必須包含：虛擬碼步驟 + [空格] + // 解釋/說明\". So each line must be separate with virtual code step and comment. But in our above we used block lines inside decision. But we need each line separate. So we can use indentation for readability but still each line is a separate line.\n\nWe can format as:\n\nStart // 程式開始執行\n→ Step 1: m, n = mat.shape // 取得矩陣尺寸\n→ Step 2: rows = [] // 初始化結果列表\n→ Decision: 是否已處理完所有行？ // 檢查是否完成\n    No → Step 3: i = 0 // 行索引初始化\n    → Decision: i < m ?\n        Yes → Step 3.1: count = BinaryCount(mat[i]) // 計算第 i 行的士兵數量\n        → Step 3.2: rows.append((i, count)) // 儲存\n        → Step 3.3: i = i + 1 // 進入下一行\n        No → Decision: 是否所有行已處理？\n            Yes → Step 4: rows.sort(key=lambda x: (x[1], x[0])) // 排序，先士兵數再索引\n            Yes → Step 5: weakest = [] // 產生答案\n            Yes → for j = 0 to k-1\n                → Step 5.1: weakest.append(rows[j][0]) // 取最弱行索引\n            Yes → Step 6: Output weakest // 回傳結果\nEnd // 程式結束\n\nBut each step line must be separate; but we have nested decisions. We can maintain each line separately.\n\nLet's break decisions into separate lines. Use indentation optional.\n\nWe can write:\n\nStart // 程式開始執行\n→ Step 1: m, n = mat.shape // 取得矩陣尺寸\n→ Step 2: rows = [] // 初始化結果列表\n→ Decision: 是否已處理完所有行？ // 檢查是否完成\n    No → Step 3: i = 0 // 行索引初始化\n    → Decision: i < m ?\n        Yes → Step 3.1: count = BinaryCount(mat[i]) // 計算第 i 行的士兵數量\n        → Step 3.2: rows.append((i, count)) // 儲存\n        → Step 3.3: i = i + 1 // 進入下一行\n        No → Decision: 是否所有行已處理？\n            Yes → Step 4: rows.sort(key=lambda x: (x[1], x[0])) // 排序，先士兵數再索引\n            Yes → Step 5: weakest = [] // 產生答案\n            Yes → for j = 0 to k-1\n                → Step 5.1: weakest.append(rows[j][0]) // 取最弱行索引\n            Yes → Step 6: Output weakest // 回傳結果\nEnd // 程式結束\n\nNow define BinaryCount as separate block:\n\nBinaryCount(row) // BinaryCount 函式開始\n→ Step 1: low = 0, high = len(row) - 1 // 初始化搜尋範圍\n→ Decision: low <= high ?\n    Yes → Step 2: mid = (low + high) // 2\n    → Decision: row[mid] == 1 ?\n        Yes → Step 3: low = mid + 1 // 1 在左側，搜尋右半部\n        No  → Step 4: high = mid - 1 // 0 在右側，搜尋左半部\n    No → Step 5: Return low // low 為 1 的個數\nEnd // BinaryCount 函式結束\n\nBut each line must have virtual code step + comment. The BinaryCount block lines can be considered separate lines.\n\nWe must ensure each line ends with comment. Good.\n\nHowever the instructions: \"使用虛擬碼的箭頭 (→, Yes →, No →) 和結構 (Start, End, Decision:)\" We have used those. Good.\n\nBut we used lambda syntax; but it's okay.\n\nWe also used \"Return low\" but may treat as step. Acceptable.\n\nBut we need to ensure \"每行虛擬碼步驟 + [空格] + // 解釋/說明\" and each line starts with virtual code step. We must not include other text like \"BinaryCount(row)\" as a line? It's part of the function definition. Might need to use \"Start BinaryCount(row)\"? But we can treat \"BinaryCount(row)\" as a step: \"→ BinaryCount(row) // BinaryCount 函式開始\" but the arrow is before. However typical pseudo code: \"BinaryCount(row)\" no arrow. But we can treat \"→ BinaryCount(row) // BinaryCount 函式開始\". But the instructions say each line must have virtual code step. The step may be the function call or start. For clarity, we can add \"→ BinaryCount(row) // 函式開始\" maybe. But we can also include \"Start BinaryCount(row)\" but the format didn't specify \"Start FunctionName\". Might be okay to use \"Start BinaryCount(row)\". But we can keep as \"→ BinaryCount(row) // BinaryCount 函式開始\". But the arrow indicates this is a step. It's fine.\n\nBut we have nested decisions; each step after decision lines must start with arrow. Eg \"Yes → Step 3.1:\" etc. Already good.\n\nBut the \"Decision: 是否已處理完所有行？\" should not have arrow. Good.\n\nBut we also have \"Decision: i < m ?\" after \"No → Step 3: i = 0\". That line starts with arrow? In our format it's \"→ Decision: i < m ?\" but we need to indent. But we already wrote \"→ Decision: i < m ?\" preceded by arrow? We wrote \"→ Decision: i < m ?\" after \"No → Step 3: i = 0\". But we need to ensure each decision line starts with \"Decision:\" without arrow? But earlier we used \"Decision:\" lines preceded by arrow. The instruction: \"使用虛擬碼的箭頭 (→, Yes →, No →) 和結構 (Start, End, Decision:)\" So Decision lines do not start with arrow. They just start with \"Decision:\". So we should not prefix with arrow. So modify: we need to ensure that \"Decision:\" lines have no arrow. The lines \"Decision: 是否已處理完所有行？\" has no arrow. Good. But in our current block we had \"→ Decision: i < m ?\" - that has arrow incorrectly. So correct that: It should be \"Decision: i < m ?\" without arrow. Similarly, \"Decision: row[mid] == 1 ?\" also no arrow. So adjust.\n\nAlso \"→ Decision: row[mid] == 1 ?\" must be without arrow. So we should correct.\n\nAlso \"→ Decision: 是否所有行已處理？\" no arrow.\n\nAlso \"→ Decision: low <= high ?\" no arrow.\n\nLet's reformat accordingly.\n\nLet's craft final answer with proper formatting.\n\nWe should separate each line with newline.\n\nWe'll produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: m, n = mat.shape // 取得矩陣尺寸  \n→ Step 2: rows = [] // 初始化結果列表  \nDecision: 是否已處理完所有行？ // 檢查是否完成  \n    No → Step 3: i = 0 // 行索引初始化  \n    Decision: i < m ? // 判斷是否還有行未處理  \n        Yes → Step 3.1: count = BinaryCount(mat[i]) // 計算第 i 行的士兵數量  \n        → Step 3.2: rows.append((i, count)) // 儲存結果  \n        → Step 3.3: i = i + 1 // 進入下一行  \n        No → Decision: 是否所有行已處理？ // 確認所有行已經遍歷完  \n            Yes → Step 4: rows.sort(key=lambda x: (x[1], x[0])) // 排序，先按士兵數再按索引  \n            Yes → Step 5: weakest = [] // 用於儲存最弱的 k 行索引  \n            Yes → for j = 0 to k-1  \n                → Step 5.1: weakest.append(rows[j][0]) // 取第 j 個最弱行的索引  \n            Yes → Step 6: Output weakest // 回傳答案  \nEnd // 程式結束  \n\n// ----------------- BinaryCount 函式 -----------------  \nBinaryCount(row) // BinaryCount 函式開始  \n→ Step 1: low = 0, high = len(row) - 1 // 初始化搜尋範圍  \nDecision: low <= high ? // 判斷搜尋區間是否有效  \n    Yes → Step 2: mid = (low + high) // 2 // 取中點  \n    Decision: row[mid] == 1 ? // 判斷中點是否為 1  \n        Yes → Step 3: low = mid + 1 // 1 在左側，搜尋右半部  \n        No → Step 4: high = mid - 1 // 0 在右側，搜尋左半部  \n    No → Step 5: Return low // low 為 1 的個數  \nEnd // BinaryCount 函式結束"
    },
    {
      "title": "Multiply Strings",
      "source_file": "Leetcode/leetcode43.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "num1 = '2', num2 = '3'",
          "expected_output": "'6'",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '6'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: \"'6'\"\nRaw Got:      '2'"
        },
        {
          "example_index": 1,
          "input": "num1 = '123', num2 = '456'",
          "expected_output": "'56088'",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '56088'\nGot (Norm):      '123'\n--- (Raw) ---\nRaw Expected: \"'56088'\"\nRaw Got:      '123'"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef multiply(num1: str, num2: str) -> str:\n    \"\"\"把兩個字串形式的非負整數相乘，返回字串形式的乘積。\"\"\"\n    if num1 == '0' or num2 == '0':\n        return '0'\n    m, n = len(num1), len(num2)\n    pos = [0] * (m + n)                      # 用來存放各位相乘的結果\n\n    for i in range(m - 1, -1, -1):           # 從低位開始遍歷 num1\n        for j in range(n - 1, -1, -1):       # 從低位開始遍歷 num2\n            mul = int(num1[i]) * int(num2[j])   # 兩位相乘\n            p1, p2 = i + j, i + j + 1           # 位置指標\n            s = mul + pos[p2]                    # 加上先前累積的值\n            pos[p1] += s // 10                  # 進位\n            pos[p2] = s % 10                    # 取餘數\n\n    # 把結果拼成字串，去掉前導零\n    result = ''.join(map(str, pos)).lstrip('0')\n    return result\n\ndef main():\n    \"\"\"從 stdin 讀取兩個數字，輸出它們的乘積。\"\"\"\n    data = sys.stdin.read()\n    nums = re.findall(r'\\d+', data)   # 取得所有數字字串\n    if len(nums) < 2:\n        return\n    num1, num2 = nums[0], nums[1]\n    print(multiply(num1, num2))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. For multiplication of two numbers as strings, simulate long multiplication. Steps: handle zero. Prepare result array size len1+len2. For each digit from right to left, multiply and add to result with carry. Then build string skipping leading zeros.\n\nWe need to output line by line, with arrow and comments. Use Start, End, Decision. Provide explanation comments.\n\nLet's create steps:\n\nStart\n→ Check if num1 == \"0\" or num2 == \"0\" → If yes, return \"0\"\n→ Convert strings to reversed arrays of digits\n→ Initialize result array of size len1+len2 with zeros\n→ For i from 0 to len1-1:\n    For j from 0 to len2-1:\n        Multiply digit i of num1_rev with digit j of num2_rev → sum = product + result[i+j]\n        result[i+j] = sum % 10\n        result[i+j+1] += sum / 10\n→ Build string from result array reversed, skip leading zeros\n→ Return the string\n\nBut need to include Decision structure for zero check.\n\nAlso each line should be \"虛擬碼步驟 // 解釋\". Use \"→\" arrow for steps.\n\nWe can break nested loops as steps maybe: \"→ Loop over i\" etc.\n\nWe must not output actual code, just steps.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Decision: 如果 num1 為 '0' 或 num2 為 '0'? // 檢查任何一個數字為零\n    Yes → Step: 返回 '0' // 直接輸出零\n    No  → Step: 將 num1 和 num2 轉成反向數字陣列 // 方便從最低位開始計算\n→ Step: 初始化 result 陣列，大小為 len(num1)+len(num2)，所有元素設為 0 // 用於儲存乘法結果\n→ Step: 從 i = 0 到 len(num1)-1 逐位遍歷 num1_rev\n    → Step: 從 j = 0 到 len(num2)-1 逐位遍歷 num2_rev\n        → Step: 計算 product = num1_rev[i] * num2_rev[j] // 兩位相乘\n        → Step: 加入現有 result[i+j] 並處理進位\n            → Decision: 若 product + result[i+j] ≥ 10? // 檢查是否需要進位\n                Yes → Step: result[i+j] = (product + result[i+j]) % 10\n                No  → Step: result[i+j] = product + result[i+j]\n            → Step: result[i+j+1] += (product + result[i+j]) / 10 // 將進位加入下一位\n→ Step: 將 result 陣列倒轉並轉為字串，同時去除前導零 // 構造最終結果\n→ End // 程式執行結束\n\nBut note we used nested decision inside loops maybe too many. We can simplify: after sum we just set result[i+j] = sum % 10; result[i+j+1] += sum / 10.\n\nWe also need to output the string. Provide step: build result string.\n\nLet's produce final virtual code accordingly.\n\nWe need each line with arrow. Use indentation for nested decisions.\n\nOk produce output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: 如果 num1 為 '0' 或 num2 為 '0'? // 檢查任何一個數字為零  \n  Yes → Step: 返回 '0' // 直接輸出零  \n  No  → Step: 將 num1 和 num2 轉成反向數字陣列 // 方便從最低位開始計算  \n→ Step: 初始化 result 陣列，大小為 len(num1)+len(num2)，所有元素設為 0 // 用於儲存乘法結果  \n→ Step: 從 i = 0 到 len(num1)-1 逐位遍歷 num1_rev  \n  → Step: 從 j = 0 到 len(num2)-1 逐位遍歷 num2_rev  \n    → Step: 計算 product = num1_rev[i] * num2_rev[j] // 兩位相乘  \n    → Step: sum = product + result[i+j] // 加上先前累積的值  \n    → Step: result[i+j] = sum % 10 // 取低位數字  \n    → Step: result[i+j+1] += sum / 10 // 把進位累加到下一位  \n→ Step: 將 result 陣列倒轉並轉為字串，同時去除前導零 // 構造最終結果  \n→ Step: 返回最終結果字串 // 完成乘法運算  \nEnd // 程式執行結束"
    }
  ]
}