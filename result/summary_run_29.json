{
  "run_index": 29,
  "total_files_found": 391,
  "total_files_processed": 323,
  "files_skipped": 68,
  "files_failed_load": 0,
  "---": "--- (以下基於 *題目* 總數) ---",
  "total_problems_attempted": 334,
  "generation_and_validation_success_count": 295,
  "generation_or_validation_failure_count": 39,
  "failed_cases_details": [
    {
      "title": "統計文字行數",
      "source_file": "900.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "（假設 data.txt 內容如下）\\nHello\\nPython\\nWorld",
          "expected_output": "檔案共有 3 行",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '檔案共有3行'\nGot (Norm):      '檔案共有1行'\n--- (Raw) ---\nRaw Expected: '檔案共有 3 行'\nRaw Got:      '檔案共有 1 行'"
        }
      ],
      "generated_code": "import sys\n\ndef main():\n    # 讀取 stdin 以符合題目規範（雖然此題不需要輸入）\n    _ = sys.stdin.read()\n\n    try:\n        with open('data.txt', 'r', encoding='utf-8') as f:\n            lines = f.readlines()\n            print('檔案共有', len(lines), '行')\n    except FileNotFoundError:\n        print('找不到檔案！')\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code line by line with comments. Use Start, End, Decision: etc. Steps: Start, try open file with with, read lines, count lines, output count. If file not found, except block prints message. Use with syntax. We must show try/except structure. Use Decision for file existence? Actually try catches FileNotFoundError. So Decision after reading? But we can have Decision: Count lines? But simpler: after reading, count lines and output. In except, output message. Provide virtual code lines. Use \"Start\" at top, \"End\" at bottom. Each line includes virtual code step and // explanation. Provide arrow for flow.\n\nLet's write:\n\nStart\n→ Step 1: 用 try 來處理可能的 FileNotFoundError // 嘗試執行以下程式碼，若有錯誤則跳轉到 except\n    → Step 2: with open('data.txt', 'r') as file: // 以只讀模式開啟檔案\n        → Step 3: lines = file.readlines() // 讀取所有行並存成列表\n        → Decision: 是否成功讀取? // 確認是否讀取到內容\n            Yes → Step 4: line_count = len(lines) // 計算行數\n            Yes → Step 5: print('總行數:', line_count) // 輸出行數\n    → Decision: 讀取完成? // 完成後離開 with 區塊\n    No  → Decision: 讀取失敗? // 這裡不會發生\n→ Except: FileNotFoundError: // 檔案不存在時執行\n    → Step 6: print('找不到檔案！') // 顯示錯誤訊息\nEnd\n\nBut must use proper syntax for decision lines. Also, arrow for flow inside try block. Let's produce a more structured pseudocode:\n\nStart\n→ Decision: 是否執行 try? // 進入 try 區塊\n    Yes → Step 1: 用 try 捕捉 FileNotFoundError // 建立 try 句子\n        → Step 2: with open('data.txt', 'r') as file: // 開啟檔案\n            → Step 3: lines = file.readlines() // 讀取所有行\n            → Step 4: line_count = len(lines) // 計算行數\n            → Step 5: print('總行數:', line_count) // 輸出行數\n        → End of try block\n    No → End // 這裡沒有 else\n→ Decision: 是否發生 FileNotFoundError? // 進入 except\n    Yes → Step 6: print('找不到檔案！') // 顯示錯誤訊息\n    No  → End\nEnd\n\nBut we need to use arrow \"Yes →\", \"No →\". For try/except, we need to express the decision after try. Might not be necessary but we can keep simple: \"Try: ...\" \"Except: ...\".\n\nBetter:\n\nStart\n→ Step 1: 進入 try 區塊 // 嘗試執行以下程式碼\n    → Step 2: with open('data.txt', 'r') as file: // 開啟檔案\n        → Step 3: lines = file.readlines() // 讀取全部行\n        → Step 4: line_count = len(lines) // 計算行數\n        → Step 5: print('總行數:', line_count) // 輸出行數\n→ Decision: 是否發生 FileNotFoundError? // 捕捉檔案不存在的例外\n    Yes → Step 6: print('找不到檔案！') // 顯示錯誤訊息\nEnd\n\nBut we need to show \"except\" part explicitly.\n\nLet's produce:\n\nStart\n→ Step 1: Begin try block // 進入 try 區塊\n    → Step 2: with open('data.txt', 'r') as file: // 使用 with 開啟檔案\n        → Step 3: lines = file.readlines() // 讀取所有行\n        → Step 4: line_count = len(lines) // 計算行數\n        → Step 5: print('總行數:', line_count) // 輸出行數\n→ Decision: 是否觸發 FileNotFoundError? // 判斷是否發生例外\n    Yes → Step 6: print('找不到檔案！') // 顯示錯誤訊息\nEnd\n\nBut we need to mention except block. Let's do:\n\nStart\n→ Step 1: Try: // 開始嘗試區塊\n    → Step 2: with open('data.txt', 'r') as file: // 開啟檔案\n        → Step 3: lines = file.readlines() // 讀取所有行\n        → Step 4: line_count = len(lines) // 計算行數\n        → Step 5: print('總行數:', line_count) // 輸出行數\n→ Decision: 是否發生 FileNotFoundError? // 若發生例外則跳至 except\n    Yes → Step 6: Except FileNotFoundError: // 捕捉檔案不存在的例外\n        → Step 7: print('找不到檔案！') // 顯示錯誤訊息\nEnd\n\nThis is ok. Use arrow for decisions: Yes →, No → but we don't have No case.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Try: // 進入 try 區塊，準備捕捉可能發生的例外\n    → Step 2: with open('data.txt', 'r') as file: // 以只讀模式開啟檔案，並自動關閉\n        → Step 3: lines = file.readlines() // 讀取檔案中所有行並存成列表\n        → Step 4: line_count = len(lines) // 計算列表中行數，得到總行數\n        → Step 5: print('總行數:', line_count) // 輸出總行數資訊\n→ Decision: 是否發生 FileNotFoundError? // 檢查是否拋出了「找不到檔案」例外\n    Yes → Step 6: Except FileNotFoundError: // 捕捉 FileNotFoundError 例外\n        → Step 7: print('找不到檔案！') // 顯示錯誤訊息\nEnd // 程式執行結束"
    },
    {
      "title": "模擬擲骰子遊戲",
      "source_file": "800.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "print(roll_dice(5))",
          "expected_output": "[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,6,1,4,2]#(結果會隨機，每次可能不同)'\nGot (Norm):      '[1,6,3,3,5]'\n--- (Raw) ---\nRaw Expected: '[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)'\nRaw Got:      '[1, 6, 3, 3, 5]'"
        }
      ],
      "generated_code": "import random\nimport sys\n\ndef roll_dice(n):\n    \"\"\"\n    擲 n 次六面骰子，回傳結果列表。\n    \"\"\"\n    results = []\n    for _ in range(n):\n        results.append(random.randint(1, 6))\n    return results\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取完整程式碼並執行\n    code = sys.stdin.read()\n    exec(code, globals())",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines. Each line: virtual code step + space + // explanation. Use arrows, Start, End, Decision. The function: roll_dice(n) uses random module to simulate n dice rolls, return list of results.\n\nWe should break into steps: Start, Step 1: Import random, Step 2: Define function roll_dice(n), Step 3: Initialize empty list results, Step 4: Loop i from 1 to n, Step 5: generate random integer 1-6, append to results, Step 6: return results, End. Also maybe handle error: if n <=0? but not necessary.\n\nWe'll produce code lines accordingly.\n\nMake sure each line is a virtual step: \"Start\", \"→ Step 1: Import random // ...\" etc.\n\nWe must include decisions? None needed. But we can include a decision to check n > 0? but not required.\n\nWill produce:\n\nStart // 程式開始執行\n→ Step 1: Import random module // 引入 random 套件\n→ Step 2: Define function roll_dice(n) // 建立 roll_dice 函式\n→ Step 3: 初始化空列表 results // 用來儲存擲骰結果\n→ Step 4: For i in range(n): // 依次擲 n 次骰子\n    → Step 5: roll = random.randint(1, 6) // 產生 1~6 的隨機數\n    → Step 6: Append roll to results // 將結果加入列表\n→ Step 7: Return results // 回傳所有結果\nEnd // 程式執行結束\n\nBut we need to format: each line with arrow, etc. Indentation? The example shows indentation. Use '→' to show arrow. For nested lines use indentation. Ensure each line has code then comment.\n\nLet's output accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Import random // 引入 random 套件\n→ Step 2: Define function roll_dice(n) // 建立 roll_dice 函式\n→ Step 3: 初始化空列表 results // 用來儲存擲骰結果\n→ Step 4: For i in range(n): // 依次擲 n 次骰子\n    → Step 5: roll = random.randint(1, 6) // 產生 1~6 的隨機數\n    → Step 6: Append roll to results // 將結果加入列表\n→ Step 7: Return results // 回傳所有結果\nEnd // 程式執行結束"
    },
    {
      "title": "計算程式執行時間",
      "source_file": "800.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "import time\n\ndef slow_add(a, b):\n    time.sleep(2)\n    return a + b\n\nprint(measure_time(slow_add, 3, 5))",
          "expected_output": "約 2.0 秒 (依電腦執行環境略有差異)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '約2.0秒(依電腦執行環境略有差異)'\nGot (Norm):      '2.0'\n--- (Raw) ---\nRaw Expected: '約 2.0 秒 (依電腦執行環境略有差異)'\nRaw Got:      '2.0'"
        }
      ],
      "generated_code": "import sys\nimport time\n\ndef measure_time(func, *args):\n    \"\"\"\n    計算 func(*args) 執行所需秒數，並四捨五入到小數點三位後回傳。\n    \"\"\"\n    start = time.time()\n    func(*args)\n    end = time.time()\n    return round(end - start, 3)\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整段程式碼\n    code = sys.stdin.read()\n\n    # 建立執行環境，將 measure_time 放進全域命名空間\n    namespace = {\n        \"measure_time\": measure_time,\n        \"time\": time,          # 方便使用者直接 import time\n    }\n\n    # 執行使用者輸入的程式碼\n    exec(code, namespace)",
      "virtual_code": "Thinking...\nWe need to produce virtual code, step by step, with each line containing \"虛擬碼步驟\" and comment. Use arrows, Start, End, Decision: etc.\n\nTask: use time module, write function measure_time(func, *args) to measure seconds executed, round to 3 decimals, return result. So steps: Start, import time, define function measure_time, inside: start time, call func(*args), end time, compute elapsed, round to 3 decimals, return elapsed. End.\n\nWe need virtual code lines, each with explanation. Use arrow style.\n\nLet's produce:\n\nStart\n→ Import time module // 引入時間功能\n→ Define function measure_time(func, *args) // 宣告測量函式\n    → Record start_time = time.time() // 取得開始時間\n    → Call result = func(*args) // 執行傳入函式並存取其回傳值\n    → Record end_time = time.time() // 取得結束時間\n    → 計算 elapsed = end_time - start_time // 計算耗時\n    → 取 round_elapsed = round(elapsed, 3) // 四捨五入到三位小數\n    → Return round_elapsed // 回傳測量結果\nEnd\n\nBut we need to include decision? There's no decision. But we can include an optional decision about maybe no arguments? Not necessary.\n\nLet's follow format: Each line \"虛擬碼步驟 [space] // 解釋\". Use arrow \"→\". Start and End.\n\nWe should include import time as a step. Provide explanation.\n\nLet's produce accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Import time module // 引入 time 模組以取得時間功能  \n→ Define function measure_time(func, *args) // 宣告測量函式，接收待測函式與可變參數  \n    → Record start_time = time.time() // 取得執行前的時間點  \n    → Call result = func(*args) // 執行傳入函式並取得其回傳值（若需要可使用 result）  \n    → Record end_time = time.time() // 取得執行後的時間點  \n    → 計算 elapsed = end_time - start_time // 計算函式執行所耗費的秒數  \n    → 取 round_elapsed = round(elapsed, 3) // 將耗時四捨五入至小數點 3 位  \n    → Return round_elapsed // 回傳四捨五入後的耗時  \nEnd // 程式執行結束"
    },
    {
      "title": "學生資料類別設計",
      "source_file": "1100.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "Alice 的分數是 90\nBob 的分數是 80",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'Alice的分數是90\\nBob的分數是80'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: 'Alice 的分數是 90\\nBob 的分數是 80'\nRaw Got:      ''"
        }
      ],
      "generated_code": "import sys\n\nclass Student:\n    \"\"\"學生類別，包含姓名與分數。\"\"\"\n    def __init__(self, name: str, score: int):\n        self.name = name\n        self.score = score\n\n    def show_info(self) -> None:\n        \"\"\"輸出『姓名 的分數是 分數』的資訊。\"\"\"\n        print(f\"{self.name} 的分數是 {self.score}\")\n\n\ndef main() -> None:\n    \"\"\"主程式：從標準輸入讀取學生資料並顯示。\"\"\"\n    raw_input = sys.stdin.read().strip().splitlines()\n    students = []\n\n    # 若沒有輸入，使用預設兩位學生\n    if not raw_input:\n        students.append(Student(\"Alice\", 90))\n        students.append(Student(\"Bob\", 80))\n    else:\n        # 嘗試判斷第一行是否為學生數量\n        try:\n            n = int(raw_input[0].strip())\n            idx = 1\n            for _ in range(n):\n                if idx >= len(raw_input):\n                    break\n                parts = raw_input[idx].strip().split()\n                idx += 1\n                if len(parts) >= 2:\n                    name, score_str = parts[0], parts[1]\n                    try:\n                        score = int(score_str)\n                        students.append(Student(name, score))\n                    except ValueError:\n                        continue\n        except ValueError:\n            # 若第一行不是整數，則把每一行都視為姓名與分數\n            for line in raw_input:\n                parts = line.strip().split()\n                if len(parts) >= 2:\n                    name, score_str = parts[0], parts[1]\n                    try:\n                        score = int(score_str)\n                        students.append(Student(name, score))\n                    except ValueError:\n                        continue\n\n    # 顯示所有學生資訊\n    for student in students:\n        student.show_info()\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line, with each line like \"虛擬碼步驟 // 解釋\". Need to use arrow symbols, decisions. But this is a straightforward definition, not much branching. But we can still show steps: Start, define class, init, method, create objects, call method, End. Must include arrow '→'. Should we include arrow before each line? Example shows each step preceded by arrow. We can use '→ Class: Student // 定義 Student 類別'. Then inside class we need arrow indent? In example, they used indentation like '    Yes → Step 2: ...'. We can use '→ Class: Student // 定義 Student 類別' then '    → Step: __init__() // 建構子' etc. But we need to maintain arrow lines. Use indentation with spaces? It's fine.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Class: Student // 定義 Student 類別\n    → Method: __init__(self, name, score) // 建構子：初始化姓名與分數\n        → Set: self.name = name // 存儲姓名\n        → Set: self.score = score // 存儲分數\n    → Method: show_info(self) // 定義顯示資訊的方法\n        → Print: f\"{self.name} 的分數是 {self.score}\" // 輸出格式化字串\n→ Step: student1 = Student(\"Alice\", 95) // 建立第一個 Student 物件\n→ Step: student2 = Student(\"Bob\", 88) // 建立第二個 Student 物件\n→ Step: student1.show_info() // 呼叫第一個物件的 show_info\n→ Step: student2.show_info() // 呼叫第二個物件的 show_info\nEnd // 程式執行結束\n\nBut each line must have \"虛擬碼步驟 [空格] // 解釋\". Also arrow at start of each step. Should indent inside class? Example: they indent with 4 spaces. We'll maintain that.\n\nSo final answer will have each line with arrow. For example:\n\nStart // 程式開始執行\n→ Class: Student // 定義 Student 類別\n    → Method: __init__(self, name, score) // 建構子：初始化姓名與分數\n        → Set: self.name = name // 儲存姓名\n        → Set: self.score = score // 儲存分數\n    → Method: show_info(self) // 定義顯示資訊的方法\n        → Print: f\"{self.name} 的分數是 {self.score}\" // 輸出姓名與分數\n→ Step: student1 = Student(\"Alice\", 95) // 建立第一個 Student 物件\n→ Step: student2 = Student(\"Bob\", 88) // 建立第二個 Student 物件\n→ Step: student1.show_info() // 呼叫第一個物件的 show_info\n→ Step: student2.show_info() // 呼叫第二個物件的 show_info\nEnd // 程式執行結束\n\nMake sure each line includes // after code. Provide indentation. Done.\n...done thinking.\n\nStart // 程式開始執行\n→ Class: Student // 定義 Student 類別\n    → Method: __init__(self, name, score) // 建構子：初始化姓名與分數\n        → Set: self.name = name // 儲存姓名\n        → Set: self.score = score // 儲存分數\n    → Method: show_info(self) // 定義顯示資訊的方法\n        → Print: f\"{self.name} 的分數是 {self.score}\" // 輸出姓名與分數\n→ Step: student1 = Student(\"Alice\", 95) // 建立第一個 Student 物件\n→ Step: student2 = Student(\"Bob\", 88) // 建立第二個 Student 物件\n→ Step: student1.show_info() // 呼叫第一個物件的 show_info\n→ Step: student2.show_info() // 呼叫第二個物件的 show_info\nEnd // 程式執行結束"
    },
    {
      "title": "集合函數練習",
      "source_file": "600.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "{'apple', 'orange', 'grape', 'melon'}",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '{\"apple\",\"orange\",\"grape\",\"melon\"}'\nGot (Norm):      '{\"orange\",\"grape\",\"melon\",\"apple\"}'\n--- (Raw) ---\nRaw Expected: \"{'apple', 'orange', 'grape', 'melon'}\"\nRaw Got:      \"{'orange', 'grape', 'melon', 'apple'}\""
        }
      ],
      "generated_code": "import sys\n\ndef main():\n    # 讀取並忽略標準輸入，符合「從 stdin 讀取」的要求\n    _ = sys.stdin.read()\n\n    # 依照需求操作集合\n    fruits = {'apple', 'banana'}          # 建立初始集合\n    fruits.add('orange')                  # 新增 'orange'\n    fruits.update(['grape', 'melon'])     # 一次新增 'grape' 與 'melon'\n    fruits.remove('banana')               # 移除 'banana'\n    fruits.discard('pineapple')           # 嘗試移除不存在的 'pineapple'\n\n    # 輸出最終結果\n    print(fruits)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code line by line, each line: \"虛擬碼步驟 // 解釋\". Use arrows etc. Should include Start, End, Decision maybe not needed as straightforward.\n\nWe have to show steps for creating set, add, update, remove, discard, print. So:\n\nStart // start program\n→ Step 1: Set fruits = {'apple', 'banana'} // create set\n→ Step 2: fruits.add('orange') // add orange\n→ Step 3: fruits.update({'grape', 'melon'}) // add grape and melon\n→ Step 4: fruits.remove('banana') // remove banana\n→ Step 5: fruits.discard('pineapple') // try discard nonexistent\n→ Step 6: print(fruits) // output\nEnd // end\n\nEach line with arrow, but after Start maybe not arrow. Use \"→\" for steps. Provide comments. Let's produce.\n\nUse Start // 程式開始執行\n→ Step 1: fruits = {'apple', 'banana'} // 建立集合 fruits\n→ Step 2: fruits.add('orange') // 使用 add() 新增橘子\n→ Step 3: fruits.update({'grape', 'melon'}) // 使用 update() 新增葡萄和哈密瓜\n→ Step 4: fruits.remove('banana') // 移除香蕉\n→ Step 5: fruits.discard('pineapple') // 嘗試移除不存在的鳳梨，無錯誤\n→ Step 6: print(fruits) // 輸出最終集合\nEnd // 程式結束\n\nMake sure each line with a space after arrow? The format: \"虛擬碼步驟 [空格] // 解釋\". So \"Start // 解釋\" has no arrow. For arrow lines: \"→ Step 1: ...\" etc. Should have a space between arrow and Step.\n\nReturn this as final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: fruits = {'apple', 'banana'} // 建立集合 fruits  \n→ Step 2: fruits.add('orange') // 使用 add() 新增橘子  \n→ Step 3: fruits.update({'grape', 'melon'}) // 使用 update() 同時新增葡萄與哈密瓜  \n→ Step 4: fruits.remove('banana') // 移除香蕉  \n→ Step 5: fruits.discard('pineapple') // 嘗試移除不存在的鳳梨，程式不會拋錯  \n→ Step 6: print(fruits) // 輸出最終集合  \nEnd // 程式結束"
    },
    {
      "title": "即時匯率查詢小工具",
      "source_file": "1200.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "按下「更新匯率」按鈕",
          "expected_output": "目前美元匯率：約 32.5 TWD",
          "actual_output_or_error": "[Validation Error] Code execution timed out (10s)."
        }
      ],
      "generated_code": "import sys\nimport requests\nimport tkinter as tk\n\ndef fetch_rate() -> float:\n    \"\"\"\n    向 exchangerate-api 取得 USD 對 TWD 的匯率。\n    若請求失敗則拋出例外。\n    \"\"\"\n    url = \"https://api.exchangerate-api.com/v4/latest/USD\"\n    try:\n        resp = requests.get(url, timeout=5)\n        resp.raise_for_status()\n        data = resp.json()\n        return data[\"rates\"][\"TWD\"]\n    except Exception:\n        raise RuntimeError(\"無法取得匯率，請檢查網路或 API\")\n\ndef update_label() -> None:\n    \"\"\"\n    更新 tkinter 視窗中的匯率標籤。\n    \"\"\"\n    try:\n        rate = fetch_rate()\n        label.config(text=f\"目前美元匯率：約 {round(rate, 1)} TWD\")\n    except Exception:\n        label.config(text=\"更新失敗，請檢查網路連線\")\n\ndef main() -> None:\n    \"\"\"\n    主程式入口，先從 stdin 讀取指令並輸出結果，接著啟動 GUI。\n    \"\"\"\n    # 讀取標準輸入，避免硬編碼範例輸入\n    command = sys.stdin.read().strip()\n    if \"更新匯率\" in command:\n        try:\n            rate = fetch_rate()\n            print(f\"目前美元匯率：約 {round(rate, 1)} TWD\")\n        except Exception:\n            print(\"更新失敗，請檢查網路連線\")\n\n    # ---------- 建立 tkinter GUI ----------\n    global win, label\n    win = tk.Tk()\n    win.title(\"匯率查詢\")\n\n    label = tk.Label(win, text=\"請按下按鈕更新匯率\", font=(\"Arial\", 12))\n    label.pack(pady=10)\n\n    tk.Button(win, text=\"更新匯率\", command=update_label).pack(pady=5)\n\n    win.mainloop()\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line with explanation. Need to output in Traditional Chinese. Use Start, End, Decision. Use arrows. For requests call. Use tkinter window, button to refresh. So steps: Start, import modules, define function fetch_rate, define function update_label, setup tkinter root, label, button, initial call, mainloop, End. Use Decision for error handling maybe. Use arrow notation. Ensure each line ends with // explanation. Use spaces appropriately.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Import 需求模組: requests, tkinter // 導入請求與 GUI 套件  \n→ Define Function: fetch_rate() → // 定義取得匯率的函式  \n    → Try: requests.get('https://api.exchangerate-api.com/v4/latest/USD') // 送出 GET 請求  \n    → Decision: 如果回傳狀態 200? // 檢查是否成功  \n        Yes → Parse JSON: data = response.json() // 解析回應  \n        Yes → Return data['rates']['TWD'] // 取得 TWD 匯率  \n        No  → Raise Exception('API Error') // 回傳錯誤  \n→ Define Function: update_label() → // 更新 GUI 標籤的函式  \n    → Call fetch_rate() → rate // 取得最新匯率  \n    → Update Label Text: label.config(text=f'USD → TWD: {rate}') // 顯示匯率  \n→ Initialize tkinter 視窗: root = Tk() // 建立主視窗  \n→ Create Label: label = Label(root, text='Loading...') // 顯示文字的標籤  \n→ Pack Label: label.pack() // 放置標籤  \n→ Create Button: button = Button(root, text='Refresh Rate', command=update_label) // 建立按鈕並綁定函式  \n→ Pack Button: button.pack() // 放置按鈕  \n→ 初次呼叫更新: update_label() // 顯示初始匯率  \n→ Run GUI 主迴圈: root.mainloop() // 進入事件循環  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Flip Matrix",
      "source_file": "Leetcode/leetcode519.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"flip\", \"flip\", \"flip\", \"reset\", \"flip\"], [[3, 1], [], [], [], [], []]",
          "expected_output": "[null, [1,0], [2,0], [0,0], null, [2,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[1,0],[2,0],[0,0],null,[2,0]]'\nGot (Norm):      '[null,[0,0],[1,0],[2,0],null,[2,0]]'\n--- (Raw) ---\nRaw Expected: '[null, [1,0], [2,0], [0,0], null, [2,0]]'\nRaw Got:      '[null, [0, 0], [1, 0], [2, 0], null, [2, 0]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, m, n):\n        self.rows = m\n        self.cols = n\n        self.total = m * n\n        self.flipped = {}\n\n    def flip(self):\n        r = random.randint(0, self.total - 1)\n        x = self.flipped.get(r, r)\n        self.total -= 1\n        self.flipped[r] = self.flipped.get(self.total, self.total)\n        return [x // self.cols, x % self.cols]\n\n    def reset(self):\n        self.total = self.rows * self.cols\n        self.flipped.clear()\n\nif __name__ == \"__main__\":\n    # Read all input from stdin\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n\n    # The input is two JSON arrays separated by a comma, e.g.\n    # [\"Solution\", \"flip\", ...], [[3,1], [], ...]\n    # Wrap them in brackets to parse as a single JSON array\n    data = json.loads(f'[{raw_input}]')\n    ops, args_list = data[0], data[1]\n\n    result = []\n    obj = None\n    for op, args in zip(ops, args_list):\n        if op == \"Solution\":\n            obj = Solution(*args)\n            result.append(None)\n        elif op == \"flip\":\n            result.append(obj.flip())\n        elif op == \"reset\":\n            obj.reset()\n            result.append(None)\n        else:\n            # Unknown operation; ignore or handle error\n            result.append(None)\n\n    # Output the results as a JSON array\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps, not actual code, for the described problem. Provide step-by-step algorithm. Need to use virtual code lines with arrow. Must include explanation comment each line. Should design algorithm: using reservoir sampling? The known solution: maintain list of available indices as flat array of size m*n, track mapping from index to actual position. Each flip picks random from remaining; swap with last; reduce count. Reset clears mapping.\n\nWe'll produce pseudocode with classes etc.\n\nWe'll need to handle random calls minimal: each flip uses one random call to choose index from remaining. Complexity: O(1) time per flip, O(m*n) space? But we can use dictionary for mapping of used indices. Use dictionary mapping from index to actual index. So space O(k) for flipped cells. Provide pseudocode accordingly.\n\nWe'll produce Start, Step lines.\n\nLet's craft:\n\nStart // 程式開始\n→ Step 1: 初始化 m, n, total = m*n, remaining = total // 設置矩陣尺寸與可用空位總數\n→ Step 2: 建立空映射 dict // 用於記錄已被翻轉的位置映射\nEnd // constructor finished\n\nFlip method:\nStart // flip 方法開始\n→ Step 1: 隨機選擇 r = randomInt(0, remaining-1) // 從剩餘空位中挑選一個索引\n→ Step 2: 將 r 轉換為實際位置 actual = dict.get(r, r) // 若 r 已映射則取映射值，否則用 r\n→ Step 3: 找到 last = dict.get(remaining-1, remaining-1) // 取最後一個空位的位置\n→ Step 4: dict[r] = last // 將 r 的位置更新為 last，將 r 從可用集合中移除\n→ Step 5: 下降 remaining = remaining - 1 // 更新剩餘空位數\n→ Step 6: 計算 i = actual // m, j = actual % m // 將一維索引轉為行列\n→ Step 7: 返回 [i, j] // 將隨機位置返回\nEnd // flip 方法結束\n\nReset method:\nStart // reset 方法開始\n→ Step 1: 重設 remaining = total // 重設剩餘空位數\n→ Step 2: 清空 dict // 清除所有映射\nEnd // reset 方法結束\n\nThat's the virtual code. Need to include each line with arrow and explanation.\n\nAlso ensure each line of pseudocode has comment after //.\n\nLet's produce.\n\nAlso maybe include 'Decision:' for random? Not necessary.\n\nWe'll produce step by step. Use indentation to indicate nested. For each method, maybe separate.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行\n\n→ Step 1: 初始化變數 m, n, total ← m × n, remaining ← total // 設定矩陣尺寸與可用空位總數  \n→ Step 2: 建立空字典 mapping ← {} // 用於記錄已翻轉位置的映射  \n\nEnd // 建構子完成  \n\n---  \n\nStart // flip() 方法開始  \n\n→ Step 1: r ← randomInt(0, remaining - 1) // 隨機挑選一個剩餘空位的索引（只呼叫一次 random）  \n→ Step 2: actual ← mapping.get(r, r) // 若 r 已映射，取映射值；否則使用 r 本身作為實際位置  \n→ Step 3: last ← mapping.get(remaining - 1, remaining - 1) // 取得最後一個可用空位的位置  \n→ Step 4: mapping[r] ← last // 用 last 替代 r，將 r 從可用集合中移除  \n→ Step 5: remaining ← remaining - 1 // 更新剩餘空位數量  \n→ Step 6: i ← actual // m, j ← actual % m // 將一維索引轉為行列座標  \n→ Step 7: return [i, j] // 返回隨機且均勻的 0 位點並將其翻轉為 1  \n\nEnd // flip() 方法結束  \n\n---  \n\nStart // reset() 方法開始  \n\n→ Step 1: remaining ← total // 重設剩餘空位數量為全體  \n→ Step 2: mapping.clear() // 清空所有映射，回復所有位置為 0  \n\nEnd // reset() 方法結束"
    },
    {
      "title": "Remove Invalid Parentheses",
      "source_file": "Leetcode/leetcode301.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"()())()\"",
          "expected_output": "[\"(())()\",\"()()()\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"(())()\",\"()()()\"]'\nGot (Norm):      '[\"()()()\",\"(())()\"]'\n--- (Raw) ---\nRaw Expected: '[\"(())()\",\"()()()\"]'\nRaw Got:      '[\"()()()\", \"(())()\"]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport re\nfrom collections import deque\n\ndef remove_invalid_parentheses(s: str):\n    \"\"\"Return all possible valid strings after removing the minimal number of\n    invalid parentheses. The result list is unique and unsorted.\"\"\"\n    # Helper to check validity of a string\n    def is_valid(st: str) -> bool:\n        bal = 0\n        for ch in st:\n            if ch == '(':\n                bal += 1\n            elif ch == ')':\n                bal -= 1\n                if bal < 0:\n                    return False\n        return bal == 0\n\n    # BFS over levels of removal\n    visited = {s}\n    queue = deque([s])\n    while queue:\n        level_size = len(queue)\n        found_valid = []\n        for _ in range(level_size):\n            cur = queue.popleft()\n            if is_valid(cur):\n                found_valid.append(cur)\n            # generate next level only if no valid found yet\n            if not found_valid:\n                for i in range(len(cur)):\n                    if cur[i] in ('(', ')'):\n                        nxt = cur[:i] + cur[i+1:]\n                        if nxt not in visited:\n                            visited.add(nxt)\n                            queue.append(nxt)\n        if found_valid:\n            # remove duplicates by converting to set then back to list\n            return list(set(found_valid))\n    return []\n\ndef parse_input(data: str) -> str:\n    \"\"\"Extract the string value from input. Supports formats like:\n       s = \"()())()\"\n       \"()())()\"\n    \"\"\"\n    # Try to find quoted substring\n    m = re.search(r'\"([^\"]*)\"', data)\n    if m:\n        return m.group(1)\n    # If no quotes, strip whitespace and possible assignment\n    data = data.strip()\n    if '=' in data:\n        # take part after '=' and strip spaces\n        return data.split('=', 1)[1].strip()\n    return data\n\nif __name__ == \"__main__\":\n    raw = sys.stdin.read()\n    s = parse_input(raw)\n    res = remove_invalid_parentheses(s)\n    print(json.dumps(res))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the problem: remove minimum number of invalid parentheses to get all valid strings. This is classic Leetcode 301. We need algorithm: BFS or DFS with pruning. Provide pseudo-code step by step. Use Start, Decision, etc. Must be line by line with explanation. No actual code. So produce steps: start, compute left removal count, right removal count, define DFS function, recursively iterate characters, skip, add, keep track of stack. Add result set. Finally output list. Ensure uniqueness. Use BFS alternative. Let's produce DFS algorithm. Steps: 1. count mismatches. 2. dfs function: parameters index, leftCount, rightCount, path, resultSet. 3. Base case when index==len. 4. Decision on char type. 5. skip or keep logic. Provide unique result. End.\n\nLet's produce lines. Use \"Start\", \"→\" arrows, \"Decision:\", \"Yes →\", \"No →\". Ensure each line has explanation after //. Provide step numbers? Not required but can include. Provide only pseudo steps.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得輸入字串 s // 從使用者處取得要處理的字串  \n→ Step 2: 計算需要刪除的左括號數 leftRemove 與右括號數 rightRemove  \n  Decision: 逐個檢查字元  \n   Yes → If char == '(' → leftRemove++ // 左括號累計  \n   No → If char == ')'  \n    Decision: 右括號是否能配對  \n     Yes → If leftRemove > 0 → leftRemove-- // 與已計算的左括號配對  \n     No → rightRemove++ // 無法配對，右括號需要刪除  \n\n→ Step 3: 建立空集合 resultSet 用於儲存唯一的合法字串  \n→ Step 4: 定義遞迴函式 dfs(index, leftCount, rightCount, path)  \n  Start // 進入遞迴  \n  → Decision: index == len(s)?  \n   Yes → Decision: leftCount == 0 AND rightCount == 0?  \n    Yes → Add path to resultSet // 所有刪除需求滿足，存入結果  \n    No → Return // 不合法，回傳  \n   No → Step 5: 取得當前字元 c = s[index]  \n\n  → Decision: c is letter?  \n   Yes → dfs(index+1, leftCount, rightCount, path + c) // 字母直接保留  \n   No → Decision: c == '('?  \n    Yes → // 處理左括號  \n     Decision: leftCount > 0?  \n      Yes → dfs(index+1, leftCount-1, rightCount, path) // 刪除此左括號  \n      No → dfs(index+1, leftCount, rightCount, path + c) // 保留並遞進左計數  \n     No → Decision: c == ')'  \n      Decision: rightCount > 0?  \n       Yes → dfs(index+1, leftCount, rightCount-1, path) // 刪除此右括號  \n       No → dfs(index+1, leftCount, rightCount, path + c) // 保留並遞進右計數  \n  End // 結束遞迴  \n\n→ Step 6: 呼叫 dfs(0, leftRemove, rightRemove, \"\") // 從頭開始搜尋  \n→ Step 7: 將 resultSet 轉成列表並回傳 // 確保唯一性已由集合保證  \nEnd // 程式執行結束"
    },
    {
      "title": "Scramble String",
      "source_file": "Leetcode/leetcode87.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s1 = \"great\", s2 = \"rgeat\"",
          "expected_output": "true",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp8xx4n6_5.py\", line 59, in <module>\n    main()\n  File \"/tmp/tmp8xx4n6_5.py\", line 53, in main\n    s1, s2 = parse_input()\n             ^^^^^^^^^^^^^\n  File \"/tmp/tmp8xx4n6_5.py\", line 38, in parse_input\n    raise ValueError(\"Input must contain two lines.\")\nValueError: Input must contain two lines."
        },
        {
          "example_index": 1,
          "input": "s1 = \"abcde\", s2 = \"caebd\"",
          "expected_output": "false",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpso71ucqr.py\", line 59, in <module>\n    main()\n  File \"/tmp/tmpso71ucqr.py\", line 53, in main\n    s1, s2 = parse_input()\n             ^^^^^^^^^^^^^\n  File \"/tmp/tmpso71ucqr.py\", line 38, in parse_input\n    raise ValueError(\"Input must contain two lines.\")\nValueError: Input must contain two lines."
        },
        {
          "example_index": 2,
          "input": "s1 = \"a\", s2 = \"a\"",
          "expected_output": "true",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmppagd104v.py\", line 59, in <module>\n    main()\n  File \"/tmp/tmppagd104v.py\", line 53, in main\n    s1, s2 = parse_input()\n             ^^^^^^^^^^^^^\n  File \"/tmp/tmppagd104v.py\", line 38, in parse_input\n    raise ValueError(\"Input must contain two lines.\")\nValueError: Input must contain two lines."
        }
      ],
      "generated_code": "import sys\nfrom typing import Dict, Tuple\n\nclass Solution:\n    def isScramble(self, s1: str, s2: str) -> bool:\n        memo: Dict[Tuple[str, str], bool] = {}\n\n        def dfs(x: str, y: str) -> bool:\n            if (x, y) in memo:\n                return memo[(x, y)]\n            if x == y:\n                memo[(x, y)] = True\n                return True\n            if sorted(x) != sorted(y):\n                memo[(x, y)] = False\n                return False\n\n            n = len(x)\n            for i in range(1, n):\n                # same order\n                if dfs(x[:i], y[:i]) and dfs(x[i:], y[i:]):\n                    memo[(x, y)] = True\n                    return True\n                # swapped order\n                if dfs(x[:i], y[-i:]) and dfs(x[i:], y[:-i]):\n                    memo[(x, y)] = True\n                    return True\n\n            memo[(x, y)] = False\n            return False\n\n        return dfs(s1, s2)\n\ndef parse_input() -> Tuple[str, str]:\n    \"\"\"Read two strings from stdin, strip optional formatting.\"\"\"\n    lines = [line.strip() for line in sys.stdin if line.strip()]\n    if len(lines) < 2:\n        raise ValueError(\"Input must contain two lines.\")\n    s1 = lines[0]\n    s2 = lines[1]\n    # Remove 's1 =', 's2 =' prefixes if present\n    if '=' in s1:\n        s1 = s1.split('=', 1)[1].strip()\n    if '=' in s2:\n        s2 = s2.split('=', 1)[1].strip()\n    # Strip surrounding quotes and trailing commas\n    for ch in ('\"', \"'\", ','):\n        s1 = s1.strip(ch)\n        s2 = s2.strip(ch)\n    return s1, s2\n\ndef main() -> None:\n    s1, s2 = parse_input()\n    sol = Solution()\n    result = sol.isScramble(s1, s2)\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode for checking if s2 is a scramble of s1. It's classic LeetCode 87. We need to output line-by-line with \"虛擬碼步驟 // 解釋\". Use Start, Decision, End, arrow etc. No actual code. Provide recursion or DP. We'll produce algorithm using recursion with memoization. Steps: start, input s1, s2, if equal return true. If length 0 return false. Check if sorted(s1) != sorted(s2) => false. Then loop split positions, recursively check two possibilities. Use memo map. We'll produce pseudocode. Also we might include a helper function. We'll output step lines. Let's generate:\n\nStart\n→ Step 1: 定義函式 IsScramble(s1, s2) // 判斷兩字串是否互為亂碼\n    → Decision: 若 s1 與 s2 相同? // 基本情況\n        Yes → Step 2: 返回 true // 完全相同即為亂碼\n        No  → Decision: 若長度為 0? // 空字串處理\n            Yes → Step 3: 返回 false // 不相同但長度為 0 無法再分割\n            No  → Decision: 若 s1 與 s2 字母頻率不同? // 快速剪枝\n                Yes → Step 4: 返回 false // 字母組成不同不能為亂碼\n                No  → Step 5: 若 (s1, s2) 已在 memo? // 迴圈記錄\n                    Yes → Step 6: 返回 memo[(s1,s2)] // 直接取值\n                    No  → Step 7: 設定 flag = false // 預設為非亂碼\n                        → For i from 1 to len(s1)-1: // 嘗試所有切分\n                            → Step 8: x1 = s1[0:i], y1 = s1[i:]\n                            → Step 9: x2 = s2[0:i], y2 = s2[i:]\n                            → Decision: 若 IsScramble(x1, x2) 且 IsScramble(y1, y2)? // 同順序\n                                Yes → Step 10: flag = true; 退出迴圈\n                                No  → Step 11: y2_swapped = s2[len(s2)-i:]; x2_swapped = s2[0:len(s2)-i];\n                                    → Decision: 若 IsScramble(x1, y2_swapped) 且 IsScramble(y1, x2_swapped)? // 交叉順序\n                                        Yes → Step 12: flag = true; 退出迴圈\n                                        No  → 繼續迴圈\n                        → Step 13: memo[(s1,s2)] = flag // 記錄結果\n                        → Step 14: 返回 flag // 回傳\n→ End\n\nBut must keep format: each line start with arrow? They show \"Start\" as a line. Then \"→ Step 1:\" etc. So maintain pattern.\n\nNeed to indent decisions with arrows. For nested decisions, indent with spaces? Example in prompt: \n    Yes → Step 2:\nSo we'll do same.\n\nWe also need to handle the helper function but we can treat it inside main? Could do main function that calls IsScramble.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義函式 IsScramble(s1, s2) // 用於判斷兩字串是否互為亂碼  \n    → Decision: 若 s1 與 s2 相同? // 基本相等判斷  \n        Yes → Step 2: 返回 true // 完全相同即為亂碼  \n        No  → Decision: 若長度為 0? // 空字串處理  \n            Yes → Step 3: 返回 false // 不相同但長度為 0 直接 false  \n            No  → Decision: 若 s1 與 s2 字母頻率不同? // 快速剪枝  \n                Yes → Step 4: 返回 false // 字母組成不同無法為亂碼  \n                No  → Step 5: 若 (s1, s2) 已在 memo? // 檢查記憶化結果  \n                    Yes → Step 6: 返回 memo[(s1, s2)] // 直接取已計算結果  \n                    No  → Step 7: 設定 flag = false // 預設為非亂碼  \n                        → For i 從 1 到 len(s1)-1: // 嘗試所有切分位置  \n                            → Step 8: x1 = s1[0:i], y1 = s1[i:] // 切分 s1  \n                            → Step 9: x2 = s2[0:i], y2 = s2[i:] // 切分 s2（同順序）  \n                            → Decision: 若 IsScramble(x1, x2) 且 IsScramble(y1, y2)? // 同順序遞迴  \n                                Yes → Step 10: flag = true; 退出迴圈 // 成功則記錄  \n                                No  → Step 11: y2_swapped = s2[len(s2)-i:], x2_swapped = s2[0:len(s2)-i] // 交叉切分  \n                                    → Decision: 若 IsScramble(x1, y2_swapped) 且 IsScramble(y1, x2_swapped)? // 交叉遞迴  \n                                        Yes → Step 12: flag = true; 退出迴圈 // 成功則記錄  \n                                        No  → 繼續迴圈 // 其他切分嘗試  \n                        → Step 13: memo[(s1, s2)] = flag // 記錄結果到 memo  \n                        → Step 14: 返回 flag // 回傳是否為亂碼  \nEnd // 程式執行結束"
    },
    {
      "title": "Bulls and Cows",
      "source_file": "Leetcode/leetcode299.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "secret = \"1807\", guess = \"7810\"",
          "expected_output": "\"1A3B\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '1A3B'\nGot (Norm):      '0A0B'\n--- (Raw) ---\nRaw Expected: '\"1A3B\"'\nRaw Got:      '0A0B'"
        },
        {
          "example_index": 1,
          "input": "secret = \"1123\", guess = \"0111\"",
          "expected_output": "\"1A1B\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '1A1B'\nGot (Norm):      '0A0B'\n--- (Raw) ---\nRaw Expected: '\"1A1B\"'\nRaw Got:      '0A0B'"
        }
      ],
      "generated_code": "import sys\nfrom collections import Counter\n\nclass Solution:\n    def getHint(self, secret: str, guess: str) -> str:\n        bulls = 0\n        cows = 0\n\n        secret_count = Counter(secret)\n        guess_count = Counter(guess)\n\n        # first pass: count bulls and decrement counts\n        for s, g in zip(secret, guess):\n            if s == g:\n                bulls += 1\n                secret_count[s] -= 1\n                guess_count[g] -= 1\n\n        # second pass: count cows from remaining digits\n        for digit in guess_count:\n            if digit in secret_count:\n                cows += min(secret_count[digit], guess_count[digit])\n\n        return f\"{bulls}A{cows}B\"\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    # Filter out empty lines\n    lines = [line for line in data if line.strip() != \"\"]\n    if len(lines) >= 2:\n        secret = lines[0].strip()\n        guess = lines[1].strip()\n    else:\n        # fallback: assume space-separated or comma-separated in one line\n        parts = lines[0].replace(',', ' ').split()\n        secret, guess = parts[0], parts[1]\n\n    solution = Solution()\n    hint = solution.getHint(secret, guess)\n    print(hint)",
      "virtual_code": "Thinking...\nWe need to produce pseudocode lines with explanations, for the Bulls and Cows problem. Virtual code lines with arrows, decisions, etc. Let's produce step-by-step algorithm: iterate over digits, count bulls, store counts of digits not bulls in arrays/dictionaries for secret and guess, then compute cows as min of counts for each digit. Provide virtual code. We'll use Start, → Step, Decision etc. Each line must be like \"Start // ...\" etc. Use arrows. Ensure no actual code. Use natural language. Provide explanation after each line. Let's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化 bulls = 0, cows = 0 // 記錄牛和奶的數量\n→ Step 2: 初始化 secretCount[0-9] = 0, guessCount[0-9] = 0 // 用於統計非牛位的數字頻率\n→ Step 3: 取得 secret 與 guess 的長度 n // 假設兩者長度相同\n→ Decision: n > 0? // 確保輸入非空\n    Yes →\n        → For i from 0 to n-1: // 遍歷每一個位置\n            → Decision: secret[i] == guess[i]? // 檢查是否為牛\n                Yes →\n                    → bulls = bulls + 1 // 增加牛的計數\n                No →\n                    → secretCount[secret[i]] = secretCount[secret[i]] + 1 // 統計秘密數字頻率\n                    → guessCount[guess[i]] = guessCount[guess[i]] + 1 // 統計猜測數字頻率\n    No → // 如果長度為0，直接跳到輸出\n→ Step 4: 針對每個數字 d (0~9): // 計算奶的數量\n    → cows = cows + min(secretCount[d], guessCount[d]) // 奶是非牛位置的匹配數量\n→ Step 5: 組合 hint = bulls + 'A' + cows + 'B' // 按照格式拼接結果\n→ Step 6: 回傳 hint // 將提示回傳給使用者\nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick Index",
      "source_file": "Leetcode/leetcode398.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\"], [[[1, 2, 3, 3, 3]], [3], [1], [3]]",
          "expected_output": "[null, 4, 0, 2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,4,0,2]'\nGot (Norm):      '[null,4,0,3]'\n--- (Raw) ---\nRaw Expected: '[null, 4, 0, 2]'\nRaw Got:      '[null, 4, 0, 3]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, nums):\n        \"\"\"把每個數字對應的所有索引存入字典，方便隨機挑選。\"\"\"\n        self.indices = {}\n        for i, num in enumerate(nums):\n            self.indices.setdefault(num, []).append(i)\n\n    def pick(self, target):\n        \"\"\"隨機挑選 target 的一個索引，所有索引機率相等。\"\"\"\n        return random.choice(self.indices[target])\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個輸入，並去除首尾空白\n    raw = sys.stdin.read().strip()\n    if not raw:\n        sys.exit()\n\n    # 將兩個獨立的 JSON 陣列包裝成一個陣列，方便解析\n    data = json.loads(f'[{raw}]')\n    ops, args_list = data[0], data[1]\n\n    results = []\n    obj = None\n\n    for op, args in zip(ops, args_list):\n        if op == \"Solution\":\n            # args 是一個包含 nums 的列表，例如 [[1,2,3,3,3]]\n            obj = Solution(args[0])\n            results.append(None)  # 代表 null\n        else:\n            # 其他方法通常只有一個參數\n            func = getattr(obj, op)\n            results.append(func(args[0]))\n\n    # 輸出結果，使用 json 以獲得符合範例的 null 表示\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to output virtual code line by line with explanation. Need to design algorithm: pre-process map of target to list of indices. In pick, randomly select index from list. Use random generator.\n\nWe must output only virtual code, no real code. Each line: \"虛擬碼步驟 // 解釋\". Use arrow etc. We have Start, Decision, etc. So we need to describe steps.\n\nImplementation:\n\nStart\n→ Step 1: 建立空字典 idx_map // Map from number to list of indices\n→ Step 2: For i in range length(nums) // 逐個處理每個元素\n    → Step 2.1: current = nums[i] // 取得當前元素\n    → Decision: 是否已存在於 idx_map?\n        Yes → Step 2.1.1: Append i to idx_map[current] // 添加索引\n        No → Step 2.1.2: idx_map[current] = [i] // 新建列表\n→ Step 3: 儲存 idx_map 成物件屬性 // ready for pick\n\nThen pick method:\n\nStart pick\n→ Step 1: list_indices = idx_map[target] // 取得目標索引列表\n→ Step 2: random_index = RandomInteger(0, length(list_indices)-1) // 隨機選擇位置\n→ Step 3: return list_indices[random_index] // 返回選中索引\n\nWe also need random generator initialization? maybe not.\n\nLet's produce virtual code lines with arrow. Use \"→\" arrow. Use indenting with tabs maybe but fine. Use \"Decision:\" lines. Provide explanation.\n\nEnsure each line includes code + space + \"// 解釋\". Provide step numbering or not; but example uses \"Step 1:\". Use \"Start\" etc. Let's format.\n\nWe should produce lines like:\n\nStart // 程式開始執行\n→ Step 1: 初始化 idx_map 為空字典 // 用於儲存每個數字對應的索引列表\n→ Step 2: 對 nums 進行遍歷\n    → Step 2.1: current = nums[i] // 取得目前索引 i 的元素\n    → Decision: idx_map 是否已包含 current？\n        Yes → Step 2.1.1: idx_map[current].append(i) // 將索引加入已存在的列表\n        No  → Step 2.1.2: idx_map[current] = [i] // 建立新的列表並加入索引\n→ Step 3: 存儲 idx_map 為物件屬性 // 為 pick 方法做準備\nEnd // 物件初始化結束\n\nThen pick method block:\n\nStart pick // pick 方法開始\n→ Step 1: indices = idx_map[target] // 取得所有符合 target 的索引\n→ Step 2: rand_pos = RandomInteger(0, len(indices)-1) // 隨機選擇位置\n→ Step 3: return indices[rand_pos] // 返回隨機選中的索引\nEnd // pick 方法結束\n\nBut we need each line as per requirement. We need to include arrow for each step. Let's create a list.\n\nWe must include \"Start\" and \"End\" lines as per example. Provide each line as \"虛擬碼步驟 // 解釋\".\n\nLet's generate final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 idx_map 為空字典 // 用於儲存每個數字對應的索引列表  \n→ Step 2: 對 nums 進行遍歷  \n    → Step 2.1: current = nums[i] // 取得目前索引 i 的元素  \n    → Decision: idx_map 是否已包含 current？  \n        Yes → Step 2.1.1: idx_map[current].append(i) // 將索引加入已存在的列表  \n        No  → Step 2.1.2: idx_map[current] = [i] // 建立新的列表並加入索引  \n→ Step 3: 存儲 idx_map 為物件屬性 // 為 pick 方法做準備  \nEnd // 物件初始化結束  \n\n---  \n\nStart pick // pick 方法開始  \n→ Step 1: indices = idx_map[target] // 取得所有符合 target 的索引  \n→ Step 2: rand_pos = RandomInteger(0, len(indices)-1) // 隨機選擇位置  \n→ Step 3: return indices[rand_pos] // 返回隨機選中的索引  \nEnd // pick 方法結束"
    },
    {
      "title": "Sort Characters By Frequency",
      "source_file": "Leetcode/leetcode451.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"tree\"",
          "expected_output": "\"eert\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'eert'\nGot (Norm):      'eetr'\n--- (Raw) ---\nRaw Expected: '\"eert\"'\nRaw Got:      'eetr'"
        },
        {
          "example_index": 1,
          "input": "s = \"cccaaa\"",
          "expected_output": "\"aaaccc\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'aaaccc'\nGot (Norm):      'cccaaa'\n--- (Raw) ---\nRaw Expected: '\"aaaccc\"'\nRaw Got:      'cccaaa'"
        }
      ],
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\ndef frequency_sort(s: str) -> str:\n    \"\"\"Return a string sorted by descending character frequency.\"\"\"\n    freq = Counter(s)\n    # most_common returns list of (char, count) sorted by count desc\n    return ''.join(char * count for char, count in freq.most_common())\n\ndef main() -> None:\n    # Read all input from stdin\n    data = sys.stdin.read()\n    # Extract the string value inside double quotes\n    match = re.search(r'\"([^\"]*)\"', data)\n    s = match.group(1) if match else \"\"\n    # Compute and print the result\n    result = frequency_sort(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code for sorting string by frequency. Provide line by line virtual code with explanation. Use Start, Decision, End, arrows. No actual code. Use virtual steps: Input string, count frequencies, sort by freq desc, build output string, return. For multiple answers, any is fine.\n\nWe produce lines like:\n\nStart // 開始\n\n→ Step 1: 取得輸入字符串 s // get input\n\n→ Step 2: 建立頻率映射 freq // create frequency map\n\n→ Step 3: 將字符串中的每個字符迭代並更新 freq // count\n\n→ Step 4: 取得 freq.entries() 作為 (char, count) 陣列 // get entries\n\n→ Step 5: 以 count 降序排序 entries // sort\n\n→ Step 6: 初始化結果字符串 res = \"\" // init\n\n→ Step 7: 對於排序後的每個 (char, count)：\n    → Step 7a: 將 char 重複 count 次並追加到 res // build\n\n→ Step 8: 回傳 res // return\n\nBut we need to use arrow formatting exactly: \"→ Step ...\" each line. For loop: use Decision? Might use \"Decision: 是否有更多字符?\" or just use \"→ For each entry: ...\" Provide explanation.\n\nLet's produce a structured algorithm.\n\nMake sure each line has virtual code + space + comment. Use Chinese explanation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得輸入字串 s // 從使用者取得待排序的字串  \n→ Step 2: 建立空頻率映射 freq // 用於儲存每個字符的出現次數  \n→ Step 3: 對 s 中的每個字符 c 進行迭代  \n  → Step 3a: 若 c 未在 freq 中，將 freq[c] 設為 0  \n  → Step 3b: 將 freq[c] 加 1 // 更新字符頻率  \n→ Step 4: 取得 freq 的 entries() 作為 (char, count) 陣列 arr // 方便排序  \n→ Step 5: 按照 count 降序對 arr 進行排序 // 高頻字符排前面  \n→ Step 6: 初始化空字串 res = \"\" // 用於累積最終結果  \n→ Step 7: 對於排序後的每個 (char, count) 在 arr  \n  → Step 7a: 將 char 重複 count 次後追加到 res // 形成輸出  \n→ Step 8: 回傳 res // 返回根據頻率降序排列的字串  \nEnd // 程式執行結束"
    },
    {
      "title": "Implement Queue using Stacks",
      "source_file": "Leetcode/leetcode232.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "Input\n[\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]\n[[], [1], [2], [], [], []]",
          "expected_output": "[null, null, null, 1, 1, false]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpib59saif.py\", line 30, in <module>\n    commands = json.loads(data[0])\n               ^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 337, in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 355, in raw_decode\n    raise JSONDecodeError(\"Expecting value\", s, err.value) from None\njson.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass MyQueue:\n    def __init__(self):\n        self.stack_in = []\n        self.stack_out = []\n\n    def push(self, x):\n        self.stack_in.append(x)\n\n    def pop(self):\n        self.peek()\n        return self.stack_out.pop()\n\n    def peek(self):\n        if not self.stack_out:\n            while self.stack_in:\n                self.stack_out.append(self.stack_in.pop())\n        return self.stack_out[-1]\n\n    def empty(self):\n        return not self.stack_in and not self.stack_out\n\nif __name__ == \"__main__\":\n    data = [line.strip() for line in sys.stdin if line.strip()]\n    if len(data) < 2:\n        sys.exit()\n\n    commands = json.loads(data[0])\n    args_list = json.loads(data[1])\n\n    results = []\n    obj = None\n\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"MyQueue\":\n            obj = MyQueue()\n            results.append(None)\n        else:\n            method = getattr(obj, cmd)\n            if isinstance(args, list):\n                res = method(*args)\n            else:\n                res = method(args)\n            results.append(res)\n\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for implementing MyQueue using two stacks. Each line: \"虛擬碼步驟 // 解釋\". Use arrows and Decision etc. Provide algorithm: maintain stack1 for incoming, stack2 for outgoing. push: push onto stack1. peek/pop: if stack2 empty, move all from stack1 to stack2. Then pop/peek from stack2. empty: return stack1 empty and stack2 empty.\n\nWe need to produce step-by-step pseudocode lines. Each line include virtual code step and comment. Use \"Start\", \"End\". Use arrows. For decisions use Decision:.\n\nLet's craft lines:\n\nStart // 程式開始執行\n→ Define Class MyQueue // 宣告 MyQueue 類別\n    → 初始化 stack1 為空 // 用於入列\n    → 初始化 stack2 為空 // 用於出列\n→ Function push(x) // 推送元素\n    → stack1 push x // 把元素推進 stack1\n→ Function pop() // 出列\n    → Decision: 如果 stack2 為空? // 需要把元素從 stack1 移動\n        Yes → While stack1 非空\n                → temp = stack1.pop() // 取出 stack1 的頂部\n                → stack2 push temp // 推入 stack2\n        No  → // 不做移動\n    → result = stack2.pop() // 從 stack2 弹出元素\n    → Return result\n→ Function peek() // 查看前端元素\n    → Decision: 如果 stack2 為空? // 同樣需要移動\n        Yes → While stack1 非空\n                → temp = stack1.pop()\n                → stack2 push temp\n        No  →\n    → Return stack2.peek() // 返回 stack2 的頂部\n→ Function empty() // 判斷是否空\n    → Return stack1.empty() AND stack2.empty() // 若兩個都空則為空\nEnd // 程式結束\n\nNeed to ensure each line uses \"虛擬碼步驟\". Each line maybe one instruction. For loops maybe multiple lines. Use arrow \"→\" for sequence. Provide decisions with indentation.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Define Class MyQueue // 宣告 MyQueue 類別  \n    → 初始化 stack1 為空 // 用於入列的堆疊  \n    → 初始化 stack2 為空 // 用於出列的堆疊  \n→ Function push(x) // 推送元素到佇列  \n    → stack1 push x // 把元素放進 stack1  \n→ Function pop() // 從佇列前端彈出元素並返回  \n    → Decision: 如果 stack2 為空? // 判斷是否需要搬移元素  \n        Yes → While stack1 非空  \n                → temp = stack1.pop() // 取出 stack1 的頂部元素  \n                → stack2 push temp // 推入 stack2  \n        No  → // 若 stack2 不空，直接跳過搬移  \n    → result = stack2.pop() // 從 stack2 彈出前端元素  \n    → Return result // 回傳彈出的元素  \n→ Function peek() // 查看佇列前端元素而不移除  \n    → Decision: 如果 stack2 為空? // 同樣需要搬移元素  \n        Yes → While stack1 非空  \n                → temp = stack1.pop()  \n                → stack2 push temp  \n        No  → // 若 stack2 已有元素，直接使用  \n    → Return stack2.peek() // 回傳 stack2 的頂部元素  \n→ Function empty() // 判斷佇列是否為空  \n    → Return stack1.empty() AND stack2.empty() // 兩個堆疊皆空即佇列空  \nEnd // 程式執行結束"
    },
    {
      "title": "Longest Uncommon Subsequence II",
      "source_file": "Leetcode/leetcode522.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"aaa\",\"aaa\",\"aa\"]",
          "expected_output": "-1",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '-1'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: '-1'\nRaw Got:      '2'"
        }
      ],
      "generated_code": "import sys\nimport json\nfrom collections import Counter\n\nclass Solution:\n    \"\"\"\n    這個類別實作求「長度最大的非通用子序列」的演算法。\n    主要思路：\n    1. 若有字串只出現一次，則它不可能是其他字串的子序列（因為等長的字串不相同）。\n    2. 只要找出所有唯一字串中的長度最大者即可。\n    3. 若所有字串都重複，則不存在非通用子序列，回傳 -1。\n    \"\"\"\n    def findLUSlength(self, strs):\n        # 計算每個字串的出現次數\n        freq = Counter(strs)\n        max_len = -1\n        for s in strs:\n            # 只考慮出現次數為 1 的字串\n            if freq[s] == 1:\n                max_len = max(max_len, len(s))\n        return max_len\n\ndef main():\n    # 從標準輸入讀取整個內容，並解析成 Python list\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        print(-1)\n        return\n    try:\n        strs = json.loads(raw_input)\n    except json.JSONDecodeError:\n        # 若輸入格式不合法，直接輸出 -1\n        print(-1)\n        return\n\n    sol = Solution()\n    result = sol.findLUSlength(strs)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for solving longest uncommon subsequence problem. Approach: Check for each string, if unique among array, then its length is candidate; else -1. Because longest uncommon subsequence between array equals length of longest string that is not equal to any other string. Explanation: If any string appears only once, then it's not a subsequence of any other identical string? Actually property: if a string is not equal to any other string, then it can't be a subsequence of any other longer string? Wait: For LUS, the longest uncommon subsequence is just the longest string that doesn't appear in others. If all strings equal, answer -1. Else answer max length of unique strings. Implementation: Count frequencies. Then for each string if freq==1, consider len. Return max length or -1.\n\nEdge: if string length zero? Not needed.\n\nSo produce steps:\n\nStart\n→ Input array strs\n→ Count frequencies for each string\n→ Initialize maxLen = -1\n→ For each string s in strs:\n   → If freq[s]==1:\n        → Update maxLen = max(maxLen, len(s))\n→ End\n→ Output maxLen\n\nProvide explanation comments.\n\nMake sure each line has arrow. For loops, decisions. Use Start, End. Use Decision for freq==1.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 取得輸入陣列 strs // 從使用者處取得字串陣列\n→ Step 2: 初始化空字典 count // 用來記錄每個字串出現的頻率\n→ Step 3: 對於每個字串 s in strs:\n    → Step 4: 取得 count[s] 或 0 // 取得目前已計數的次數\n    → Step 5: 將 count[s] 加 1 // 更新頻率\n→ Step 6: 初始化 maxLen 為 -1 // 預設答案為不存在\n→ Step 7: 對於每個字串 s in strs:\n    → Decision: 是否 count[s] 等於 1? // 判斷 s 是否唯一\n        Yes → Step 8: 計算 len_s = 長度(s) // 獲取字串長度\n        Yes → Step 9: 更新 maxLen = max(maxLen, len_s) // 取最大長度\n        No  → // 若不是唯一，忽略\n→ End // 程式執行結束\n→ Step 10: 輸出 maxLen // 回傳最長不相同子序列長度，若不存在則為 -1"
    },
    {
      "title": "Permutations",
      "source_file": "Leetcode/leetcode46.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nGot (Norm):      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nRaw Got:      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\n\nclass Solution:\n    def permute(self, nums):\n        res = []\n\n        def backtrack(start):\n            if start == len(nums):\n                res.append(nums[:])\n                return\n            for i in range(start, len(nums)):\n                nums[start], nums[i] = nums[i], nums[start]\n                backtrack(start + 1)\n                nums[start], nums[i] = nums[i], nums[start]\n\n        backtrack(0)\n        return res\n\nif __name__ == \"__main__\":\n    # Read entire input from stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # Extract the list part after \"nums =\"\n    try:\n        _, list_part = data.split('=', 1)\n    except ValueError:\n        list_part = data  # fallback if no \"=\" present\n    list_part = list_part.strip()\n\n    # Safely evaluate the list\n    nums = ast.literal_eval(list_part)\n\n    # Compute permutations\n    solution = Solution()\n    result = solution.permute(nums)\n\n    # Output in JSON format without spaces\n    print(json.dumps(result, separators=(',', ':')))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for generating all permutations of array of distinct integers. We need to output in format:\n\nStart\n→ Step 1: ...\n→ Decision: ...\nYes → ...\nNo → ...\nEnd\n\nWe should describe the backtracking algorithm.\n\nWe should break into steps: start, initialize result list, call backtrack, backtrack function: if current permutation size equals length, add to result; else iterate over nums, if not used, add to permutation, mark used, backtrack, unmark. Provide steps.\n\nWe should produce each line of virtual code step with comment.\n\nWe should ensure \"逐行\" meaning each line. The algorithm steps should be high-level.\n\nLet's outline:\n\nStart // 程式開始執行\n→ Step 1: 定義空結果陣列 result // 用來存所有排列\n→ Step 2: 定義空暫存陣列 path // 存目前的排列\n→ Step 3: 定義布林陣列 used，長度等於 nums  // 標記每個數是否已被使用\n→ Step 4: 呼叫 backtrack() // 開始回溯\n\nBacktrack procedure:\n→ Step 5: Decision: 若 path 長度等於 nums 長度? // 判斷是否已組成完整排列\n    Yes → Step 6: 把 path 複製加入 result // 加入到結果\n    No  → Decision: 遍歷 nums 的每個索引 i\n        → Step 7: Decision: 若 used[i] 為 false? // 檢查此數是否已使用\n            Yes → Step 8: 把 nums[i] 加到 path // 添加數到暫存\n            → Step 9: Decision: 設置 used[i] 為 true // 標記已使用\n                → Step 10: 呼叫 backtrack() // 進入下一層遞迴\n                → Step 11: Decision: 回到上一層後，從 path 中移除最後一個元素 // 回溯\n                → Step 12: Decision: 設置 used[i] 為 false // 取消標記\n            No  → Step 13: 跳過 // 如果已使用，直接繼續下一個\n\nEnd // 程式執行結束\n\nBut we must format each line like \"→ Step 1: ...\" etc. We also need to include decision lines properly.\n\nWe need to maintain indent: For nested decisions, maybe indent or list with spaces. But we can just indent lines after decision.\n\nWe should ensure each line ends with comment.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義空結果陣列 result // 用來存所有排列  \n→ Step 2: 定義空暫存陣列 path // 存目前的排列  \n→ Step 3: 定義布林陣列 used，長度等於 nums 長度 // 標記每個數是否已被使用  \n→ Step 4: 呼叫 backtrack() // 開始回溯  \n\nStep 5: Decision: 若 path 長度等於 nums 長度? // 判斷是否已組成完整排列  \n Yes → Step 6: 把 path 複製加入 result // 加入到結果  \n No  → Decision: 遍歷 nums 的每個索引 i  \n  → Step 7: Decision: 若 used[i] 為 false? // 檢查此數是否已使用  \n   Yes → Step 8: 把 nums[i] 加到 path // 添加數到暫存  \n    → Step 9: 設置 used[i] 為 true // 標記已使用  \n     → Step 10: 呼叫 backtrack() // 進入下一層遞迴  \n     → Step 11: 從 path 中移除最後一個元素 // 回溯  \n     → Step 12: 設置 used[i] 為 false // 取消標記  \n   No  → Step 13: 跳過 // 若已使用則繼續下一個 i  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Sliding Window Maximum",
      "source_file": "Leetcode/leetcode239.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,3,-1,-3,5,3,6,7], k = 3",
          "expected_output": "[3,3,5,5,6,7]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp2l83pbvt.py\", line 44, in <module>\n    nums, k = parse_input(data)\n              ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp2l83pbvt.py\", line 36, in parse_input\n    k_part = parts[1].split('=', 1)[1].strip()\n             ~~~~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        }
      ],
      "generated_code": "import sys\nfrom collections import deque\n\nclass Solution:\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        Return a list of the maximums of each sliding window of size k.\n        \"\"\"\n        if not nums or k == 0:\n            return []\n\n        deq = deque()\n        res = []\n\n        for i, val in enumerate(nums):\n            # Remove indices outside the current window\n            while deq and deq[0] <= i - k:\n                deq.popleft()\n            # Remove smaller numbers from the back\n            while deq and nums[deq[-1]] <= val:\n                deq.pop()\n            deq.append(i)\n            # Append current max to results\n            if i >= k - 1:\n                res.append(nums[deq[0]])\n        return res\n\ndef parse_input(data: str):\n    \"\"\"\n    Parse the input string in the format:\n    'nums = [1,2,3], k = 2'\n    Returns the list of integers and the integer k.\n    \"\"\"\n    parts = data.split(',')\n    nums_part = parts[0].split('=', 1)[1].strip()\n    k_part = parts[1].split('=', 1)[1].strip()\n    nums = eval(nums_part, {\"__builtins__\": None}, {})\n    k = int(k_part)\n    return nums, k\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if data:\n        nums, k = parse_input(data)\n        solution = Solution()\n        result = solution.maxSlidingWindow(nums, k)\n        print(result)",
      "virtual_code": "Thinking...\nWe need to produce a step-by-step virtual code in traditional Chinese, with each line containing \"虛擬碼步驟\" and after a space \"// 解釋/說明\". Use arrows and decisions. Provide a virtual algorithm for sliding window maximum. Use deques concept. So steps: Start, initialize deque, iterate i over nums, maintain window, push index, pop older indices, pop smaller values, etc.\n\nWe must output line by line. Let's design:\n\nStart\n→ Step 1: 初始化一個空佇列 deque 用於存儲索引 // 用於跟踪窗口內最大值索引\n→ Step 2: 初始化空結果列表 result // 存放每個窗口的最大值\n→ Step 3: 遍歷 nums 的每個索引 i 從 0 到 len(nums)-1 // 開始滑動窗口\n    → Decision: 當 i >= k-1? // 窗口已滿，可以記錄最大值\n        Yes → Step 4: 結果添加 nums[deque[0]] // deque 首元素對應窗口最大值\n    → Decision: deque 是否為空? // 確保後續操作安全\n        No  → Step 5: 當 deque[0] <= i - k? // 移除已離開窗口的索引\n            Yes → Step 6: 將 deque[0] 從佇列中移除 // 先前的最大值不在窗口\n    → Decision: deque 是否為空? // 再次檢查是否需要進行比較\n        No  → Step 7: 當 nums[i] <= nums[deque[-1]]? // 右邊較小值\n            Yes → Step 8: 將 deque[-1] 從佇列中移除 // 這個索引不可能成為最大值\n            No  → No operation\n    → Step 9: 將索引 i 添加到 deque 的尾部 // 新元素進入窗口\nEnd\n\nBut ensure correct ordering: typical algorithm:\n\nFor i in range(len(nums)):\n    while deque and deque[0] <= i - k: pop left\n    while deque and nums[i] >= nums[deque[-1]]: pop right\n    deque.append(i)\n    if i >= k-1: result.append(nums[deque[0]])\n\nWe should reflect this. Provide decisions and steps accordingly.\n\nLet's produce virtual code lines:\n\nStart\n→ Step 1: 初始化一個空佇列 deque // 用來存儲窗口內可能成為最大值的索引\n→ Step 2: 初始化空列表 result // 用於保存每個窗口的最大值\n→ Step 3: 取得陣列長度 n = len(nums) // 用於迴圈控制\n→ Step 4: 遍歷索引 i 從 0 到 n-1 // 逐一處理每個元素\n    → Decision: deque 是否不空且 deque[0] <= i - k? // 檢查左端索引是否已離開窗口\n        Yes → Step 5: 從左端移除 deque[0] // 刪除已不在窗口的索引\n    → Decision: deque 是否不空且 nums[i] >= nums[deque[-1]]? // 從右端刪除較小的索引\n        Yes → Step 6: 從右端移除 deque[-1] // 這些索引不可能成為最大值\n    → Step 7: 將 i 加入 deque 的右端 // 新索引進入窗口\n    → Decision: i >= k-1? // 窗口已滿，可以記錄最大值\n        Yes → Step 8: 將 nums[deque[0]] 添加到 result // deque 的左端索引對應最大值\nEnd\n\nWe need to include \"Yes →\" and \"No →\" lines? In above decisions we only used Yes →. We can also have No → for clarity. For each decision, include No branch doing nothing or skip. But they might not require No branch if no action. But it's okay.\n\nBetter produce:\n\nStart\n→ Step 1: 初始化空佇列 deque // 用來存儲可能是窗口最大值的索引\n→ Step 2: 初始化空列表 result // 保存每個窗口的最大值\n→ Step 3: 計算 n = len(nums) // 獲取陣列長度\n→ Step 4: 循環遍歷索引 i 從 0 到 n-1 // 逐個元素處理\n    → Decision: deque 不為空 且 deque[0] <= i - k? // 最左索引是否已離開窗口\n        Yes → Step 5: 從左側移除 deque[0] // 刪除已離開窗口的索引\n        No  → // 無操作\n    → Decision: deque 不為空 且 nums[i] >= nums[deque[-1]]? // 右端較小值是否需要移除\n        Yes → Step 6: 從右側移除 deque[-1] // 刪除較小索引\n        No  → // 無操作\n    → Step 7: 將 i 加入 deque 的右側 // 新元素進入窗口\n    → Decision: i >= k-1? // 窗口已滿，能獲取最大值\n        Yes → Step 8: 把 nums[deque[0]] 加入 result // 取左端索引對應的最大值\n        No  → // 無操作\nEnd\n\nLet's ensure each line has \"虛擬碼步驟\" and space then comment. Provide arrow formatting.\n\nWe'll output as per example: \"Start // 程式開始執行\". Each line with arrow \"→\" indent as needed. Ensure correct syntax. Use \"Yes →\" \"No →\".\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空佇列 deque // 用來存儲可能是窗口最大值的索引  \n→ Step 2: 初始化空列表 result // 保存每個窗口的最大值  \n→ Step 3: 計算 n = len(nums) // 獲取陣列長度  \n→ Step 4: 循環遍歷索引 i 從 0 到 n-1 // 逐個元素處理  \n  → Decision: deque 不為空 且 deque[0] <= i - k? // 最左索引是否已離開窗口  \n   Yes → Step 5: 從左側移除 deque[0] // 刪除已離開窗口的索引  \n   No  → // 無操作  \n  → Decision: deque 不為空 且 nums[i] >= nums[deque[-1]]? // 右端較小值是否需要移除  \n   Yes → Step 6: 從右側移除 deque[-1] // 刪除較小索引  \n   No  → // 無操作  \n  → Step 7: 將 i 加入 deque 的右側 // 新元素進入窗口  \n  → Decision: i >= k-1? // 窗口已滿，能獲取最大值  \n   Yes → Step 8: 把 nums[deque[0]] 加入 result // 取左端索引對應的最大值  \n   No  → // 無操作  \nEnd // 程式執行結束"
    },
    {
      "title": "Find the Duplicate Number",
      "source_file": "Leetcode/leetcode287.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "nums = [3,1,3,4,2]",
          "expected_output": "O3",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'O3'\nGot (Norm):      '3'\n--- (Raw) ---\nRaw Expected: 'O3'\nRaw Got:      '3'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def findDuplicate(self, nums):\n        # Floyd's Tortoise and Hare algorithm\n        slow = fast = nums[0]\n        # Phase 1: Find the intersection point in the cycle\n        while True:\n            slow = nums[slow]\n            fast = nums[nums[fast]]\n            if slow == fast:\n                break\n        # Phase 2: Find the entrance to the cycle (the duplicate number)\n        slow = nums[0]\n        while slow != fast:\n            slow = nums[slow]\n            fast = nums[fast]\n        return slow\n\nif __name__ == \"__main__\":\n    # Read all input from stdin\n    data = sys.stdin.read()\n    # Extract all integers from the input (handles formats like \"nums = [1,3,4,2,2]\")\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    if not nums:\n        # If no numbers found, exit gracefully\n        sys.exit()\n    result = Solution().findDuplicate(nums)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce a virtual code with each line having \"虛擬碼步驟\" plus comment. Need to follow the format exactly. Use Start, Decision, etc. Should not output actual code. Provide pseudocode steps for solving the problem: find duplicate in array of size n+1 with numbers 1..n. Use Floyd's Tortoise and Hare algorithm. Steps: Start, set slow=nums[0], fast=nums[0], move slow=nums[slow], fast=nums[nums[fast]] until they meet, then reset slow=nums[0] and keep fast same, move both by one until equal, that is duplicate. Use constant space, no modification. Provide explanation after each line.\n\nWe need to produce each line with \"虛擬碼步驟\" then a space then \"// 解釋/說明\". Use arrows for steps, decision, etc. Use '→' for moving.\n\nWe also need to use Decision: ...? for conditional checks.\n\nLet's design lines:\n\n1. Start // 程式開始執行\n2. → Step 1: 設定 slow = nums[0] // 初始化慢指標\n3. → Step 2: 設定 fast = nums[0] // 初始化快指標\n4. → Decision: 是否 slow 等於 fast? // 判斷兩指標是否已相遇\n5.    Yes → End // 兩指標已相遇，跳出迴圈 (但此時未確定重複數，需進一步)\n   Actually we need loop until they meet. So maybe better: use While slow != fast loop. So we can have:\n4. → Decision: slow ≠ fast? // 檢查慢快指標是否未相遇\n5.    Yes → Step 3: slow = nums[slow] // 慢指標移動一步\n6.    Yes → Step 4: fast = nums[nums[fast]] // 快指標移動兩步\n7.    No → Step 5: // 相遇，進入下一階段\n8. → Step 6: slow = nums[0] // 把慢指標重新設定為起點\n9. → Decision: slow ≠ fast? // 檢查是否已相遇\n10.    Yes → Step 7: slow = nums[slow] // 慢指標移動一步\n11.    Yes → Step 8: fast = nums[fast] // 快指標移動一步\n12.    No → Step 9: 重複數 = slow // 找到重複數\n13. → Step 10: 輸出 重複數 // 回傳結果\n14. End // 程式執行結束\n\nBut we need to ensure the structure uses Start, End, Decision:, and arrows. For loops, we can use Decision: while condition? Yes → ... No → ... and we need to loop back to Decision.\n\nSo we might need to indicate looping back arrow. Eg:\n\n→ Decision: slow ≠ fast? // 檢查慢快指標是否未相遇\n    Yes → Step 3: slow = nums[slow] // 慢指標移動一步\n    Yes → Step 4: fast = nums[nums[fast]] // 快指標移動兩步\n    No  → // 相遇，進入下一階段\n\nBut to loop, we need to have an arrow back to the decision. We can include a line like → Decision: 循環? etc. But to keep simple, we can denote a loop with a Decision that continues to itself.\n\nAlternatively, we can represent while loop as:\n\n→ Decision: slow ≠ fast? // 檢查慢快指標是否未相遇\n    Yes → Step 3: slow = nums[slow] // 慢指標移動一步\n          → Step 4: fast = nums[nums[fast]] // 快指標移動兩步\n          → Decision: slow ≠ fast? // 重新檢查條件\n              (this arrow indicates loop)\n    No → // 結束循環\n\nBut that would be a nested decision. Perhaps easier to just use the style:\n\n→ Decision: slow ≠ fast? // 判斷是否已相遇\n    Yes → Step 3: slow = nums[slow] // 慢指標移動一步\n          → Step 4: fast = nums[nums[fast]] // 快指標移動兩步\n          → // 重新回到決策點（表示循環）\n    No → // 相遇，進入下一階段\n\nBut the arrow for re-entering decision is ambiguous.\n\nAlternatively, we can use a \"Loop\" label: Use \"While slow ≠ fast:\" as a step. But requirement: Use Decision: ...? etc. But we can incorporate \"Decision:\" inside loop.\n\nMaybe we can produce simpler representation:\n\nStart\n→ Step 1: 設定 slow = nums[0]\n→ Step 2: 設定 fast = nums[0]\n→ Decision: slow ≠ fast? // 開始尋找相遇點\n    Yes → Step 3: slow = nums[slow]\n          → Step 4: fast = nums[nums[fast]]\n          → // 回到 Decision (迴圈)\n    No  → // 相遇點已找到\n→ Step 5: slow = nums[0]\n→ Decision: slow ≠ fast? // 開始尋找入口\n    Yes → Step 6: slow = nums[slow]\n          → Step 7: fast = nums[fast]\n          → // 回到 Decision\n    No  → // 入口相遇\n→ Step 8: 重複數 = slow\n→ Step 9: 輸出 重複數\nEnd\n\nWe need to explicitly indicate that after Step 4 we loop back to Decision. Could use arrow \"← Decision:\" but not specified. But we can use \"→ Decision:\" again.\n\nWe should keep consistent arrow usage: \"→\" for moving to next step. For decisions, we use \"Decision:\" then indent Yes → and No → lines.\n\nWe also need to include comments. Ensure each line ends with \"// 解釋/說明\".\n\nLet's craft the final output:\n\n```\nStart // 程式開始執行\n→ Step 1: 設定 slow = nums[0] // 初始化慢指標\n→ Step 2: 設定 fast = nums[0] // 初始化快指標\n→ Decision: slow ≠ fast? // 開始尋找相遇點\n    Yes → Step 3: slow = nums[slow] // 慢指標移動一步\n          → Step 4: fast = nums[nums[fast]] // 快指標移動兩步\n          → // 回到決策點以繼續迴圈\n    No  → // slow 和 fast 相遇，進入下一階段\n→ Step 5: slow = nums[0] // 將慢指標重新設為起點\n→ Decision: slow ≠ fast? // 開始尋找入口點\n    Yes → Step 6: slow = nums[slow] // 慢指標移動一步\n          → Step 7: fast = nums[fast] // 快指標移動一步\n          → // 回到決策點以繼續迴圈\n    No  → // slow 和 fast 相遇，找到重複數\n→ Step 8: 重複數 = slow // 取得重複數值\n→ Step 9: 輸出 重複數 // 回傳結果\nEnd // 程式執行結束\n```\n\nWe need to ensure each line ends with comment. The line with \"→ // 回到決策點以繼續迴圈\" is not a step but an arrow; but still must have comment. But requirement: each line must contain `虛擬碼步驟` + space + `// 解釋/說明`. So we need a step part even if it's just comment. Maybe use \"→ Loop Back\" as step: \"→ Loop Back: 回到 Decision\" but not necessary. We can just use \"→ // 回到決策點以繼續迴圈\" which satisfies? The part before // is \"→\" which is not a step phrase. Might violate format. Better to use \"→ Step X: //\".\n\nLet's adjust: Use a dummy step \"→ Step X: 回到 Decision\". But that might confuse.\n\nAlternatively, we can indicate loop by re-indenting the Decision block and not requiring explicit back arrow. Many pseudocode examples simply repeat the decision block without explicit loop arrow. But our format expects each line to be a step or decision. We can incorporate the loop by using \"→ Decision: slow ≠ fast?\" repeated within indentation. The arrow to Decision is just the same line; after the Yes branch we finish the step block and then the decision line will be repeated again? But it's not repeated in the text. We can indicate that after performing Step 3 and Step 4 we should go back to Decision. That is already covered by the Yes branch ending at \"→ // 回到決策點以繼續迴圈\". But to avoid ambiguous step, we could use \"→ Step 3b: 回到決策點\" as a step. Let's incorporate a step \"→ Step 3b: 回到決策點 // 回到 Decision 以繼續迴圈\".\n\nSo we can do:\n\nYes → Step 3: slow = nums[slow]\n     → Step 4: fast = nums[nums[fast]]\n     → Step 3b: 回到決策點 // 重新檢查相遇條件\n\nSimilarly for second loop:\n\nYes → Step 6: slow = nums[slow]\n     → Step 7: fast = nums[fast]\n     → Step 6b: 回到決策點 // 重新檢查相遇條件\n\nNow each line has a step. Good.\n\nLet's produce final output accordingly.\n\nAlso we should ensure the \"Decision\" lines are properly indented with Yes/No lines.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 slow = nums[0] // 初始化慢指標  \n→ Step 2: 設定 fast = nums[0] // 初始化快指標  \n→ Decision: slow ≠ fast? // 開始尋找相遇點  \n Yes → Step 3: slow = nums[slow] // 慢指標移動一步  \n  → Step 4: fast = nums[nums[fast]] // 快指標移動兩步  \n  → Step 3b: 回到決策點 // 重新檢查相遇條件  \n No  → // slow 和 fast 相遇，進入下一階段  \n→ Step 5: slow = nums[0] // 將慢指標重新設為起點  \n→ Decision: slow ≠ fast? // 開始尋找入口點  \n Yes → Step 6: slow = nums[slow] // 慢指標移動一步  \n  → Step 7: fast = nums[fast] // 快指標移動一步  \n  → Step 6b: 回到決策點 // 重新檢查相遇條件  \n No  → // slow 和 fast 相遇，找到重複數  \n→ Step 8: 重複數 = slow // 取得重複數值  \n→ Step 9: 輸出 重複數 // 回傳結果  \nEnd // 程式執行結束"
    },
    {
      "title": "Insert Delete GetRandom O(1) - Duplicates allowed",
      "source_file": "Leetcode/leetcode381.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedCollection\", \"insert\", \"insert\", \"insert\", \"getRandom\", \"remove\", \"getRandom\"], [[], [1], [1], [2], [], [1], []]",
          "expected_output": "[null, true, false, true, 2, true, 1]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,false,true,2,true,1]'\nGot (Norm):      '[null,true,false,true,1,true,1]'\n--- (Raw) ---\nRaw Expected: '[null, true, false, true, 2, true, 1]'\nRaw Got:      '[null, true, false, true, 1, true, 1]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nfrom collections import defaultdict\n\nclass RandomizedCollection:\n    def __init__(self):\n        # 存放所有元素的列表\n        self.data = []\n        # 值 -> 索引集合\n        self.idx_map = defaultdict(set)\n\n    def insert(self, val: int) -> bool:\n        \"\"\"插入元素，返回是否為首次插入。\"\"\"\n        self.data.append(val)\n        self.idx_map[val].add(len(self.data) - 1)\n        # 若集合大小為1，表示首次插入\n        return len(self.idx_map[val]) == 1\n\n    def remove(self, val: int) -> bool:\n        \"\"\"移除一個 val，若存在則返回 True，否則 False。\"\"\"\n        if not self.idx_map[val]:\n            return False\n\n        # 取任意一個要刪除的位置\n        remove_idx = self.idx_map[val].pop()\n        last_val = self.data[-1]\n        last_idx = len(self.data) - 1\n\n        # 用最後一個元素覆蓋被刪除的位置\n        self.data[remove_idx] = last_val\n        # 更新最後一個元素的索引集合\n        self.idx_map[last_val].add(remove_idx)\n        self.idx_map[last_val].discard(last_idx)\n\n        # 刪除最後一個元素\n        self.data.pop()\n\n        # 若該值沒有剩餘索引，從字典中移除\n        if not self.idx_map[val]:\n            del self.idx_map[val]\n\n        return True\n\n    def getRandom(self) -> int:\n        \"\"\"隨機返回一個元素。\"\"\"\n        return random.choice(self.data)\n\ndef main():\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n\n    # 將兩個列表包裝成一個列表後使用 json.loads 解析\n    try:\n        ops, args = json.loads('[' + raw_input + ']')\n    except json.JSONDecodeError:\n        # 如果解析失敗，直接結束\n        return\n\n    obj = RandomizedCollection()\n    results = [None]  # constructor returns null\n\n    for op, arg in zip(ops[1:], args[1:]):\n        if op == 'insert':\n            results.append(obj.insert(arg[0]))\n        elif op == 'remove':\n            results.append(obj.remove(arg[0]))\n        elif op == 'getRandom':\n            results.append(obj.getRandom())\n\n    # 輸出符合 LeetCode 樣式的 JSON\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code steps. We need to produce step-by-step algorithm for RandomizedCollection with insert, remove, getRandom. Use data structures: vector (array) for elements, hashmap val->set of indices. For O(1) operations.\n\nWe need to provide each line: \"虛擬碼步驟 // 解釋\".\n\nUse Start, End, Decision.\n\nLet's craft algorithm:\n\nStart\n→ Step 1: Initialize empty array `nums` // 存放所有元素\n→ Step 2: Initialize empty hashmap `idxMap` mapping value to set of indices // 追蹤每個值在 nums 中的位置\n→ Step 3: Function `insert(val)`:\n    → Decision: If val not in idxMap? // 判斷值是否第一次插入\n        Yes → Step: Add new empty set for val in idxMap // 建立索引集合\n    → Step: Append val to nums // 把新值放到陣列尾端\n    → Step: Add index (size of nums -1) to idxMap[val] // 更新索引集合\n    → Step: If size of idxMap[val] ==1? // 如果之前不存在\n        Yes → Step: Return true // 首次插入返回 true\n        No  → Step: Return false // 不是首次插入返回 false\n→ Step 4: Function `remove(val)`:\n    → Decision: If val not in idxMap or idxMap[val] empty? // 判斷是否存在\n        Yes → Step: Return false // 沒有該值\n    → Step: Get any index `removeIdx` from idxMap[val] // 取其中一個位置\n    → Step: Get last element `lastVal` and last index `lastIdx` = nums.size() -1 // 取得陣列最後元素\n    → Step: Overwrite nums[removeIdx] with lastVal // 用最後元素填補被刪除位置\n    → Step: Update idxMap[lastVal]:\n        → Remove lastIdx from idxMap[lastVal]\n        → If removeIdx != lastIdx: Add removeIdx to idxMap[lastVal] // 更新索引\n    → Step: Remove removeIdx from idxMap[val] // 刪除被移除元素的索引\n    → Step: Pop last element from nums // 刪除陣列尾端\n    → Decision: If idxMap[val] now empty? // 判斷是否還有此值\n        Yes → Step: Remove val entry from idxMap // 清理空集合\n    → Step: Return true // 成功移除\n→ Step 5: Function `getRandom()`:\n    → Step: Generate random integer r in [0, nums.size()-1] // 隨機索引\n    → Step: Return nums[r] // 返回對應元素\nEnd\n\nNow we need to format each line: \"虛擬碼步驟 // 解釋\".\n\nWe need arrow \"→\" lines. Also decisions with \"Yes →\" and \"No →\".\n\nWe need to keep line by line with each step. We need to maintain indentation maybe using spaces? The example uses indentation but not necessary.\n\nLet's output lines as described.\n\nWe should include Start and End.\n\nLet's craft the final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空陣列 `nums` // 用於儲存所有插入的元素  \n→ Step 2: 初始化空映射 `idxMap` (val → 集合 of 索引) // 用於快速查找每個值在 `nums` 中的位置  \n\n// ------------- Insert 函式 -------------  \n→ Step 3: 定義函式 `insert(val)`  \n→ Decision: 如果 `val` 不在 `idxMap`？ // 判斷是否首次插入此值  \n  Yes → Step 4: 在 `idxMap` 中為 `val` 建立一個空集合 // 準備儲存索引  \n  No  → // 既有集合，直接進行後續步驟  \n→ Step 5: 將 `val` 加入 `nums` 的尾部 // 把新元素加入陣列  \n→ Step 6: 把新索引 (nums.size() - 1) 加入 `idxMap[val]` // 更新索引集合  \n→ Decision: 如果 `idxMap[val]` 的大小等於 1？ // 表示此值之前不存在  \n  Yes → Step 7: 回傳 `true` // 首次插入成功  \n  No  → Step 8: 回傳 `false` // 不是首次插入  \n\n// ------------- Remove 函式 -------------  \n→ Step 9: 定義函式 `remove(val)`  \n→ Decision: 如果 `val` 不在 `idxMap` 或 `idxMap[val]` 為空？ // 判斷是否存在該值  \n  Yes → Step 10: 回傳 `false` // 無法移除  \n  No  → // 進行後續移除操作  \n→ Step 11: 從 `idxMap[val]` 任意取一個索引 `removeIdx` // 選取要移除的位置  \n→ Step 12: 取得最後一個元素 `lastVal` 及其索引 `lastIdx` = nums.size() - 1 // 取陣列尾端元素  \n→ Step 13: 用 `lastVal` 覆蓋 `nums[removeIdx]` // 用尾端元素填補被刪除位置  \n→ Step 14: 在 `idxMap[lastVal]` 中  \n  → 移除 `lastIdx` // 去除舊索引  \n  → 如果 `removeIdx` != `lastIdx` → Step 15: 加入 `removeIdx` 到 `idxMap[lastVal]` // 加入新索引  \n→ Step 16: 從 `idxMap[val]` 中移除 `removeIdx` // 刪除被移除元素的索引  \n→ Step 17: 從 `nums` 刪除最後一個元素 // 完成陣列縮減  \n→ Decision: 如果 `idxMap[val]` 現在為空？ // 檢查此值是否還有剩餘  \n  Yes → Step 18: 從 `idxMap` 中移除 `val` 的條目 // 清理空集合  \n  No  → // 留下集合  \n→ Step 19: 回傳 `true` // 成功移除  \n\n// ------------- getRandom 函式 -------------  \n→ Step 20: 定義函式 `getRandom()`  \n→ Step 21: 產生隨機整數 `r` ∈ [0, nums.size() - 1] // 隨機索引  \n→ Step 22: 回傳 `nums[r]` // 回傳對應元素  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Find Median from Data Stream",
      "source_file": "Leetcode/leetcode295.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"], [[], [1], [2], [], [3], []]",
          "expected_output": "[null, null, null, 1.5, null, 2.0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,1.5,null,2.0]'\nGot (Norm):      '[None,None,None,1.5,None,2]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, 1.5, null, 2.0]'\nRaw Got:      '[None, None, None, 1.5, None, 2]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport heapq\n\nclass MedianFinder:\n    \"\"\"使用兩個堆疊 (max-heap + min-heap) 來維護中位數。\"\"\"\n    def __init__(self):\n        self.small = []  # max-heap（以負數儲存）\n        self.large = []  # min-heap\n\n    def addNum(self, num: int) -> None:\n        \"\"\"將數字加入資料結構並保持兩個堆疊的平衡。\"\"\"\n        # 先把數字放進 max-heap\n        heapq.heappush(self.small, -num)\n\n        # 若兩個堆疊都非空且 max-heap 的最大值大於 min-heap 的最小值，\n        # 需要調整元素使得兩堆的值分布正確\n        if self.small and self.large and (-self.small[0] > self.large[0]):\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n\n        # 平衡堆疊大小：max-heap 的元素數量最多比 min-heap 多 1\n        if len(self.small) > len(self.large) + 1:\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        elif len(self.large) > len(self.small):\n            val = heapq.heappop(self.large)\n            heapq.heappush(self.small, -val)\n\n    def findMedian(self) -> float:\n        \"\"\"返回目前所有數字的中位數。\"\"\"\n        if len(self.small) > len(self.large):\n            return -self.small[0]\n        return (-self.small[0] + self.large[0]) / 2.0\n\ndef main() -> None:\n    \"\"\"讀取標準輸入，執行命令並輸出結果。\"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 例如：'[\"MedianFinder\",\"addNum\",\"addNum\"], [[],[1],[2]]'\n    # 先包裝成合法 JSON，再解析\n    data = '[' + data + ']'\n    commands, args_list = json.loads(data)\n\n    output = []\n    mf = None\n\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"MedianFinder\":\n            mf = MedianFinder()\n            output.append(None)          # 返回 null\n        elif cmd == \"addNum\":\n            mf.addNum(args[0])\n            output.append(None)          # 返回 null\n        elif cmd == \"findMedian\":\n            output.append(mf.findMedian())\n        else:\n            # 任何其他未知命令直接忽略\n            output.append(None)\n\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code, step-by-step, for a solution of MedianFinder with addNum and findMedian. Must output line by line with \"虛擬碼步驟 // 解釋\". Use arrows and Decision etc.\n\nWe must not output actual code; just structured steps.\n\nWe need to design algorithm: typical approach using two heaps: max-heap for lower half, min-heap for upper half. When adding number, push into appropriate heap then rebalance sizes. findMedian uses top of heaps. Provide steps for initializing, adding, rebalancing, find median. Also need to handle empty? The class methods.\n\nLet's produce steps: Start, initialize two heaps, empty.\n\nStep: AddNum: compare with max of left heap if left not empty else push to left.\n\nRebalance: if left size > right size + 1 -> move top of left to right. If right size > left size -> move top of right to left.\n\nFindMedian: if sizes equal -> (topLeft + topRight)/2. Else return topLeft.\n\nWe must output each step with virtual code arrow.\n\nWe need to incorporate \"Start\" and \"End\". We'll use \"Decision:\" lines to check conditions. Provide line numbers? Not necessary but each line.\n\nLet's produce lines.\n\nOk. Let's write.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化空的兩個堆疊 MaxHeap low, MinHeap high // low 儲存較小的一半，high 儲存較大的一半\n→ Decision: 任何動作都要在物件建構完成前進行？ // 確保堆疊已建立\n    Yes → End // 物件建構完成\nEnd // 初始化結束\n\nStart // addNum 方法開始執行\n→ Step 2: 接收輸入值 num // 將要加入的數字\n→ Decision: low 是否為空？ // 判斷低堆是否已有元素\n    Yes → Step 3: 把 num 推入 low // 低堆空時直接加入\n    No  → Step 4: 取 low 的最大值 topLow // 取得低堆頂端\n        Decision: num ≤ topLow? // 判斷 num 是否屬於較小的一半\n            Yes → Step 5: 把 num 推入 low // 屬於較小一半，直接加入低堆\n            No  → Step 6: 把 num 推入 high // 否則加入高堆\n→ Step 7: 重新平衡堆疊 // 確保兩堆大小差不超過 1\n    Decision: low.size() > high.size() + 1? // 低堆過大\n        Yes → Step 8: 把 low.top() 移到 high // 將低堆最大值移到高堆\n        No  → Decision: high.size() > low.size()? // 高堆過大\n            Yes → Step 9: 把 high.top() 移到 low // 將高堆最小值移到低堆\n            No  → Step 10: 兩堆大小已平衡 // 無需移動\n→ End // addNum 方法結束\n\nStart // findMedian 方法開始執行\n→ Step 11: 取得 low.size() 與 high.size() // 檢查堆疊大小\n→ Decision: low.size() == high.size()? // 兩堆大小相等\n    Yes → Step 12: 取 low.top() 與 high.top()，計算 (low.top() + high.top()) / 2.0 // 平均兩中位數\n    No  → Step 13: 回傳 low.top() // 低堆頂端即為中位數\n→ End // findMedian 方法結束\n\nEnd // 程式執行結束"
    },
    {
      "title": "Reorganize String",
      "source_file": "Leetcode/leetcode767.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"aab\"",
          "expected_output": "\"aba\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'aba'\nGot (Norm):      'abas'\n--- (Raw) ---\nRaw Expected: '\"aba\"'\nRaw Got:      'abas'"
        },
        {
          "example_index": 1,
          "input": "s = \"aaab\"",
          "expected_output": "\"\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): ''\nGot (Norm):      'abasa'\n--- (Raw) ---\nRaw Expected: '\"\"'\nRaw Got:      'abasa'"
        }
      ],
      "generated_code": "import sys\nimport heapq\nfrom collections import Counter\n\nclass Solution:\n    def reorganizeString(self, s: str) -> str:\n        # Count frequency of each character\n        freq = Counter(s)\n        # Max-heap: use negative frequencies\n        max_heap = [(-cnt, ch) for ch, cnt in freq.items()]\n        heapq.heapify(max_heap)\n\n        prev_freq, prev_char = 0, ''\n        result = []\n\n        while max_heap:\n            cnt, ch = heapq.heappop(max_heap)  # cnt is negative\n            result.append(ch)\n            # If there was a previous character that still has remaining count, push it back\n            if prev_freq < 0:\n                heapq.heappush(max_heap, (prev_freq, prev_char))\n            # Set current character as previous for next iteration\n            prev_freq, prev_char = cnt + 1, ch  # cnt+1 moves it towards zero\n\n        res = ''.join(result)\n        # If we used all characters, return result; otherwise impossible\n        return res if len(res) == len(s) else \"\"\n\ndef main():\n    # Read all input, keep only alphabetic characters\n    raw = sys.stdin.read()\n    s = ''.join(filter(str.isalpha, raw))\n    sol = Solution()\n    rearranged = sol.reorganizeString(s)\n    print(rearranged)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode for rearranging string so no two adjacent same. It's similar to reorganize string problem. Steps: count frequencies, use max heap or priority queue, pick top two each time, build result, check if possible (max freq <= (n+1)/2). If not possible, return \"\". We'll produce virtual code lines with comments.\n\nWe must output line by line with \"虛擬碼步驟\" + space + \"// 解釋\". Use arrows. Format: Start, Decision, Step, End.\n\nWe need to include each step line by line. Provide comments after each line.\n\nLet's construct:\n\nStart // 程式開始\n\n→ Step 1: Count characters frequency in map // 统计每个字符出现次数\n\n→ Step 2: Build max-heap of (count, char) // 根据频率建立最大堆\n\n→ Decision: 是否存在字符频率 > (len(s)+1)/2? // 检查是否可行\n\n    Yes → Step 3: Return \"\" // 不可能\n\n    No  → Step 4: 初始化 result空字符串 // 开始构建结果\n\n    → While max-heap 不为空\n\n        → Decision: 是否堆顶元素的频率 > 1? // 判断能否取两次\n\n            Yes → Step 5: 取出两个频率最高的字符 a, b\n\n                → Step 6: Append a 到 result\n\n                → Step 7: Append b 到 result\n\n                → Step 8: 减少 a,b 频率并重新插入堆\n\n            No  → Step 9: 取出堆顶元素 a\n\n                → Step 10: Append a 到 result\n\n                → Step 11: 若 a 频率 > 1 重新插入堆\n\n    → Step 12: Return result // 完成\n\nEnd // 程式結束\n\nBut we need more precise lines. We'll break each step. Ensure we use \"Decision:\" arrow and \"Yes →\" \"No →\". Also need to ensure \"虛擬碼步驟\" like \"Step 1:\" etc.\n\nWe'll include comment after // explanation. Let's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Count characters frequency in s, store in map // 先統計每個字元出現的次數  \n→ Step 2: Build a max‑heap (priority queue) of (frequency, character) pairs // 依頻率建立最大堆  \n→ Decision: 是否存在任一字元頻率 > (len(s)+1)/2? // 檢查是否有可能重新排列  \n    Yes → Step 3: Return \"\" // 若不可能，直接回傳空字串  \n    No  → Step 4: 初始化 result 為空字串 // 開始建構結果  \n    → While max‑heap 不為空  \n        → Decision: max‑heap 的頂部元素頻率 > 1? // 判斷能否一次取兩個字元  \n            Yes → Step 5: 取出兩個頻率最高的元素 a, b // 取出 a、b  \n            → Step 6: Append a.char 到 result // 加入 a  \n            → Step 7: Append b.char 到 result // 加入 b  \n            → Step 8: 若 a.frequency > 1，將 (a.frequency-1, a.char) 重新插入堆；若 b.frequency > 1，將 (b.frequency-1, b.char) 重新插入堆 // 更新頻率並回堆  \n            No  → Step 9: 取出堆頂元素 a // 只剩一個字元  \n            → Step 10: Append a.char 到 result // 加入 a  \n            → Step 11: 若 a.frequency > 1，將 (a.frequency-1, a.char) 重新插入堆 // 更新頻率  \n→ Step 12: Return result // 完成重新排列，回傳結果  \nEnd // 程式執行結束"
    },
    {
      "title": "Group Anagrams",
      "source_file": "Leetcode/leetcode49.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]",
          "expected_output": "[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]'\nGot (Norm):      '[[\"eat\",\"tea\",\"ate\"],[\"tan\",\"nat\"],[\"bat\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]'\nRaw Got:      '[[\"eat\", \"tea\", \"ate\"], [\"tan\", \"nat\"], [\"bat\"]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nfrom collections import defaultdict\n\ndef group_anagrams(strs):\n    \"\"\"\n    將字串陣列中的字串分成同為字母重組（anagram）的群組。\n    \"\"\"\n    anagrams = defaultdict(list)\n    for s in strs:\n        # 先將字串排序後轉成 tuple 做為鍵，因為字串本身不可哈希\n        key = tuple(sorted(s))\n        anagrams[key].append(s)\n    return list(anagrams.values())\n\ndef main():\n    \"\"\"\n    讀取標準輸入，解析為 list[str]，呼叫 group_anagrams，並輸出結果。\n    \"\"\"\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n\n    # 若輸入類似 'strs = [\"eat\",\"tea\"]'，先去掉前面的變數名\n    if raw_input.startswith('strs'):\n        raw_input = raw_input.split('=', 1)[1].strip()\n\n    # 用 ast.literal_eval 解析為 Python 資料結構，安全且支援 list、str 等\n    strs = ast.literal_eval(raw_input)\n\n    # 取得分組結果\n    result = group_anagrams(strs)\n\n    # 以 JSON 格式輸出，確保使用雙引號且格式符合範例\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps with explanations. Use Start, Decision, etc. Should not output actual code. Just pseudo steps.\n\nWe need to group anagrams. Approach: For each string, compute sorted representation, use map, add to bucket. At the end output list of buckets.\n\nWe produce steps line by line. Use arrow. For each step we include comment. Use Start, End, Decision.\n\nLet's outline:\n\nStart\n→ Step 1: Initialize empty dictionary map from string to list // 用於存放每組 anagram\n→ Step 2: For each string s in strs // 遍歷輸入\n    → Step 3: Compute key by sorting characters of s // 將 anagram 轉成統一鍵\n    → Decision: 是否已在 map? // 檢查鍵是否存在\n        Yes → Step 4: Append s to map[key] // 已有，加入\n        No → Step 5: map[key] = [s] // 新鍵，新列表\n→ Step 6: Collect all map values into result list // 取出所有 buckets\nEnd\n\nWe can also decide to sort characters. We might need a function sortString(s). But keep simple.\n\nAlso need to show decision arrows.\n\nUse \"Decision:\" and indent steps within.\n\nLet's produce.\n\nNote: Each line needs virtual code step + space + // explanation.\n\nWe need to include arrow (→) before steps except Start and End maybe. Use as shown. Use Decision with Yes→ etc. Provide indentation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空字典 `anagramMap` // 用來存放各組 anagram 的列表  \n→ Step 2: 遍歷輸入陣列 `strs` 中的每個字串 `s` // 逐一處理每個字串  \n    → Step 3: 以 `s` 的字元排序得到 `key` // 排序後的字串作為相同 anagram 的標籤  \n    → Decision: `key` 是否已存在於 `anagramMap`? // 判斷此組別是否已建立  \n        Yes → Step 4: 將 `s` 加入 `anagramMap[key]` // 已有組別，直接追加  \n        No  → Step 5: 建立新組別 `anagramMap[key] = [s]` // 未存在，初始化並加入  \n→ Step 6: 將 `anagramMap` 的所有值收集成 `result` 列表 // 把各組 anagram 取出  \nEnd // 程式執行結束"
    },
    {
      "title": "Gas Station",
      "source_file": "Leetcode/leetcode134.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "gas = [1,2,3,4,5], cost = [3,4,5,1,2]",
          "expected_output": "3",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpqski7knw.py\", line 48, in <module>\n    gas, cost = parse_input(raw_input)\n                ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpqski7knw.py\", line 35, in parse_input\n    cost_part = parts[1].split('=', 1)[1].strip()\n                ~~~~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        },
        {
          "example_index": 1,
          "input": "gas = [2,3,4], cost = [3,4,3]",
          "expected_output": "-1",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpshsbzedm.py\", line 48, in <module>\n    gas, cost = parse_input(raw_input)\n                ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpshsbzedm.py\", line 35, in parse_input\n    cost_part = parts[1].split('=', 1)[1].strip()\n                ~~~~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def canCompleteCircuit(self, gas, cost):\n        # 若總油量不足總成本，無法完成一圈\n        if sum(gas) < sum(cost):\n            return -1\n\n        start = 0   # 可能的起點\n        tank = 0    # 當前油量差\n\n        for i in range(len(gas)):\n            tank += gas[i] - cost[i]  # 更新油量差\n            if tank < 0:              # 油量不足，需重新設定起點\n                start = i + 1\n                tank = 0\n\n        return start\n\n\ndef parse_input(data: str):\n    \"\"\"\n    解析輸入字串，例如：\n        'gas = [1,2,3,4,5], cost = [3,4,5,1,2]'\n    回傳 gas 與 cost 兩個 list。\n    \"\"\"\n    # 去除換行，並拆分兩段\n    data = data.replace('\\n', '').strip()\n    parts = data.split(',')\n    if len(parts) < 2:\n        raise ValueError(\"輸入格式錯誤，無法找到 gas 與 cost\")\n\n    gas_part = parts[0].split('=', 1)[1].strip()\n    cost_part = parts[1].split('=', 1)[1].strip()\n\n    gas = ast.literal_eval(gas_part)\n    cost = ast.literal_eval(cost_part)\n    return gas, cost\n\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取資料\n    raw_input = sys.stdin.read()\n    if not raw_input.strip():\n        sys.exit(0)  # 空輸入直接退出\n\n    gas, cost = parse_input(raw_input)\n\n    sol = Solution()\n    result = sol.canCompleteCircuit(gas, cost)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to output virtual code steps with explanations, following format. We need to design algorithm for classic Gas Station problem. Steps: Start, compute total gas - total cost, if negative return -1. Else find starting index: iterate, maintain curSum, if curSum < 0, set start = i+1, curSum =0. End return start.\n\nWe need to produce virtual code line by line. Use arrows and Decision. Use comments. Must be line by line. Use \"Start\" and \"End\". Use \"Decision:\" with Yes → and No →. Ensure each line ends with // explanation.\n\nWe need to incorporate array indices and loops. Let's produce.\n\nPotential lines:\n\nStart\n→ Step 1: 計算總油量 gas_sum = sum(gas) // 計算所有加油站總油量\n→ Step 2: 計算總路程成本 cost_sum = sum(cost) // 計算往返所需的總油量\n→ Decision: gas_sum < cost_sum? // 檢查是否油量足以完成一圈\n    Yes → Step 3: Return -1 // 沒有足夠油，無法完成一圈\n    No  → \n→ Step 4: 初始化 start = 0, curSum = 0 // 預設起點和目前油量\n→ Step 5: For i from 0 to n-1 // 遍歷每個加油站\n    → curSum += gas[i] - cost[i] // 更新目前油量差\n    → Decision: curSum < 0? // 檢查目前油量是否不足\n        Yes → start = i + 1, curSum = 0 // 將起點設為下一站，重置油量\n        No  → \n→ End // 返回起點\nBut need a Step 6: Return start // 結果\n\nAlso we need to include the for loop body properly. Use indentation.\n\nLet's output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算總油量 gas_sum = sum(gas) // 計算所有加油站總油量  \n→ Step 2: 計算總路程成本 cost_sum = sum(cost) // 計算往返所需的總油量  \n→ Decision: gas_sum < cost_sum? // 檢查油量是否足以完成一圈  \n Yes → Step 3: Return -1 // 沒有足夠油，無法完成一圈  \n No → // 進入下一步驟  \n→ Step 4: 初始化 start = 0, curSum = 0 // 預設起點與目前油量  \n→ Step 5: For i from 0 to n-1 // 遍歷每個加油站  \n  → curSum += gas[i] - cost[i] // 更新目前油量差  \n  → Decision: curSum < 0? // 檢查目前油量是否不足  \n   Yes → start = i + 1, curSum = 0 // 將起點設為下一站，重置油量  \n   No → // 連續油量足夠，繼續迴圈  \n→ Step 6: Return start // 返回找到的唯一起點  \nEnd // 程式執行結束"
    },
    {
      "title": "Design Add and Search Words Data Structure",
      "source_file": "Leetcode/leetcode211.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\"],[[],[\"bad\"],[\"dad\"],[\"mad\"],[\"pad\"],[\"bad\"],[\".ad\"],[\"b..\"]]",
          "expected_output": "[null,null,null,null,false,true,true,true]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp98wfp59e.py\", line 73, in <module>\n    main()\n  File \"/tmp/tmp98wfp59e.py\", line 46, in main\n    args_list = json.loads(arg_str)\n                ^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 337, in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 353, in raw_decode\n    obj, end = self.scan_once(s, idx)\n               ^^^^^^^^^^^^^^^^^^^^^^\njson.decoder.JSONDecodeError: Expecting ',' delimiter: line 1 column 62 (char 61)"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass WordDictionary:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def addWord(self, word):\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                node.children[ch] = TrieNode()\n            node = node.children[ch]\n        node.is_end = True\n\n    def search(self, word):\n        def dfs(node, i):\n            if i == len(word):\n                return node.is_end\n            ch = word[i]\n            if ch == '.':\n                for child in node.children.values():\n                    if dfs(child, i + 1):\n                        return True\n                return False\n            if ch not in node.children:\n                return False\n            return dfs(node.children[ch], i + 1)\n        return dfs(self.root, 0)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Split the two JSON lists\n    parts = data.split('],', 1)\n    cmd_str = parts[0] + ']'\n    arg_str = '[' + parts[1]\n    commands = json.loads(cmd_str)\n    args_list = json.loads(arg_str)\n\n    results = []\n    obj = None\n\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"WordDictionary\":\n            obj = WordDictionary()\n            results.append(None)\n        elif cmd == \"addWord\":\n            obj.addWord(args[0])\n            results.append(None)\n        elif cmd == \"search\":\n            results.append(obj.search(args[0]))\n\n    # Convert results to Leetcode-style string\n    out = []\n    for r in results:\n        if r is None:\n            out.append(\"null\")\n        elif isinstance(r, bool):\n            out.append(str(r).lower())\n        else:\n            out.append(str(r))\n    print('[' + ','.join(out) + ']')\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output step-by-step pseudocode for implementing WordDictionary with addWord and search with '.' support. This is typical Leetcode 211. We'll use Trie node with children array/dict and is_end flag. search recursion to handle '.'.\n\nWe need to produce lines of virtual code each line with arrow or start etc. Use structure Start, End, Decision, etc.\n\nWe must avoid actual code; just pseudocode with arrows.\n\nWe must output line by line:\n\nStart // program starts\n→ Step 1: 定義 TrieNode // 定義 trie 節點結構\n→ Step 2: TrieNode.children // 存放子節點 (map)\n→ Step 3: TrieNode.is_word // 標記單詞結束\n→ Step 4: WordDictionary 初始化 root // 建立根節點\n→ Step 5: addWord(word) // 逐字加入 trie\n    → Decision: 迴圈遍歷 word char // 逐個字符\n        → Step 6: 若 child 不存在 創建新節點 // 建立新節點\n        → Step 7: 移動到 child // 繼續\n    → Step 8: 設置當前節點.is_word = true // 標記單詞結束\n→ Step 9: search(word) // 搜尋\n    → Decision: 若 word 為空\n        → Yes → Return current.is_word // 若達到空字串，檢查是否為單詞\n        → No  → Decision: 若 char != '.' \n            → Yes → 若 child 存在\n                → Step 10: 遞歸 search 於 child 及剩餘字串\n                → Step 11: 若遞歸結果 true → Return true\n            → No  → Return false // 子節點不存在\n            → No -> char == '.' \n                → Step 12: Decision: 是否所有子節點皆遞歸搜尋\n                    → Yes → Step 13: 若任何子節點遞歸返回 true → Return true\n                    → No  → Return false\n→ End // 結束\n\nBut we need to structure using Start, Decision, Yes/No arrows.\n\nWe must produce lines each with `虛擬碼步驟` + ` // 解釋`.\n\nWe should produce each step in separate line. Use arrow `→`. For decisions, indent lines accordingly.\n\nWe need to ensure each line contains code part then comment. Use arrow for each line. Use `Decision:` for branching.\n\nLet's craft the output accordingly. Use Start, End, etc.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 TrieNode // 建立 Trie 節點結構  \n→ Step 2: TrieNode.children = {} // 存放字母到子節點的映射  \n→ Step 3: TrieNode.is_word = False // 標記節點是否為單詞結束  \n→ Step 4: WordDictionary() 初始化 root = TrieNode() // 建立根節點  \n\n→ Step 5: addWord(word) // 將單詞插入 Trie  \n    → Decision: 遍歷 word 的每個字元 ch  \n        → Step 6: 若 root.children[ch] 不存在 創建新 TrieNode()  \n        → Step 7: root = root.children[ch] // 進入下一節點  \n    → Step 8: root.is_word = True // 將終點標記為單詞  \n\n→ Step 9: search(word) // 在 Trie 中搜尋，支援 '.'  \n    → Decision: 若 word 為空字符串  \n        → Yes → Return current.is_word // 到達字串結尾，檢查是否為單詞  \n        → No → Decision: 取得 word[0] 為 ch  \n            → Decision: 若 ch != '.'  \n                → Yes → Decision: 若 current.children[ch] 存在  \n                    → Yes → Step 10: 返回 search(剩餘字串, current.children[ch]) // 針對子節點遞迴搜尋  \n                    → No  → Return False // 該字母不存在，直接失敗  \n                → No → Return False // ch 為 '.' 處理以下  \n            → No (ch == '.')  \n                → Step 11: Decision: 是否有子節點可嘗試  \n                    → Yes → Step 12: For each child in current.children.values()  \n                        → Decision: 若 search(剩餘字串, child) 為 True  \n                            → Yes → Return True // 只要一條路徑成功即成功  \n                        → No → Continue  \n                    → No → Return False // 沒有子節點可嘗試  \nEnd // 程式執行結束"
    },
    {
      "title": "Implement Rand10() Using Rand7()",
      "source_file": "Leetcode/leetcode470.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 1",
          "expected_output": "[2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2]'\nGot (Norm):      '[1]'\n--- (Raw) ---\nRaw Expected: '[2]'\nRaw Got:      '[1]'"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[2,8]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,8]'\nGot (Norm):      '[9,1]'\n--- (Raw) ---\nRaw Expected: '[2,8]'\nRaw Got:      '[9, 1]'"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "[3,8,10]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,8,10]'\nGot (Norm):      '[6,1,6]'\n--- (Raw) ---\nRaw Expected: '[3,8,10]'\nRaw Got:      '[6, 1, 6]'"
        }
      ],
      "generated_code": "import sys\nimport os\nimport re\n\ndef rand7():\n    \"\"\"\n    隨機產生 1~7 的整數，使用 os.urandom 作為真正的亂數來源，\n    並透過拒絕採樣避免 bias。這裡不使用任何語言自帶的\n    隨機 API。\n    \"\"\"\n    while True:\n        byte = os.urandom(1)[0]          # 0 ~ 255\n        if byte < 245:                   # 245 是 7 的倍數，避免 bias\n            return byte % 7 + 1          # 1 ~ 7\n\ndef rand10():\n    \"\"\"\n    透過兩次 rand7() 產生 1~49 的均勻分布，\n    再將前 40 個映射為 1~10，若落在 41~49\n    則重複嘗試（拒絕採樣）。\n    \"\"\"\n    while True:\n        # 組合兩次 rand7()，得到 1~49\n        num = (rand7() - 1) * 7 + rand7()   # 1 ~ 49\n        if num <= 40:                      # 40 能被 10 整除\n            return 1 + (num - 1) % 10      # 1 ~ 10\n\ndef main():\n    \"\"\"\n    主程式：從標準輸入讀取 'n = X' 形式的資料，\n    呼叫 rand10() n 次，將結果存入清單並印出。\n    \"\"\"\n    data = sys.stdin.read()\n    numbers = re.findall(r'\\d+', data)\n    if not numbers:\n        return\n    n = int(numbers[0])\n\n    results = [rand10() for _ in range(n)]\n    print(results)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code with explanation per line. The requirement: \"Use only rand7(), cannot call other APIs, no built-in random\". We need to write algorithm for rand10() using rand7(). Standard solution: Use rejection sampling with two calls: rand7() returns 1-7. Use two to create 49 possibilities, map first 40 to 1-10 (4 each). Rejection for 41-49. Alternatively use 3 calls to get 343, but we can just use two.\n\nWe need to output virtual code lines, each line: code step [space] // explanation.\n\nWe also need to use virtual arrows and structure: Start, End, Decision. Let's craft step-by-step:\n\nStart // program starts\n\n→ Step 1: repeat\n   → Step 1.1: a ← rand7() // generate first random\n   → Step 1.2: b ← rand7() // generate second random\n   → Step 1.3: num ← (a-1)*7 + b // combine to range 1-49\n   → Decision: 如果 num <= 40? // check if within usable range\n       Yes → Step 1.4: result ← ((num-1) mod 10) + 1 // map to 1-10\n       No  → Step 1 → (repeat) // if not, loop again\n\n→ Step 2: Return result // output\n\nEnd // end\n\nBut we need to produce each line as separate. We can use indentation? The example uses spaces and indentation. We should follow similar style.\n\nImportant: \"每行必須包含：虛擬碼步驟 + [空格] + // 解釋/說明\" So each line is separate line.\n\nWe need to use \"Start\" and \"End\". \"Decision:\" and arrows \"Yes →\", \"No →\". Also \"→ Step X:\".\n\nWe can structure as:\n\nStart // 程式開始執行\n→ Step 1: repeat // 進入重複區塊，直到產生有效值\n    → Step 1.1: a ← rand7() // 取得第一個隨機數\n    → Step 1.2: b ← rand7() // 取得第二個隨機數\n    → Step 1.3: num ← (a-1)*7 + b // 組合成 1-49 的數字\n    → Decision: num <= 40? // 判斷是否在可用範圍內\n        Yes → Step 1.4: result ← ((num-1) mod 10) + 1 // 轉換為 1-10\n        No  → Step 1 → repeat // 若超過 40，重新開始\n→ Step 2: return result // 回傳產生的隨機數\nEnd // 程式結束\n\nBut we need to use \"Yes →\" arrow with indentation. In example they indent lines inside Decision.\n\nThus final output should have each line on its own line. Let's produce that.\n\nLet's ensure no actual code, only virtual steps. So we don't use actual syntax. \"Step 1.1:\" is okay. But we need to use \"→\" before each step except Start and End. Use \"Decision:\" lines. After \"Decision:\" we indent Yes and No lines with arrows. Use indentation maybe 4 spaces. The example shows indentation inside Decision.\n\nWe need to maintain that format. Let's produce:\n\nStart // 程式開始執行\n→ Step 1: repeat // 進入重複區塊，直到產生有效值\n    → Step 1.1: a ← rand7() // 取得第一個隨機數 (1-7)\n    → Step 1.2: b ← rand7() // 取得第二個隨機數 (1-7)\n    → Step 1.3: num ← (a-1)*7 + b // 組合成 1-49\n    → Decision: num <= 40? // 判斷是否在可用範圍內\n        Yes → Step 1.4: result ← ((num-1) mod 10) + 1 // 將 1-40 映射到 1-10\n        No  → Step 1 → repeat // 超過 40，重新開始\n→ Step 2: return result // 回傳隨機數\nEnd // 程式結束\n\nCheck: lines: Start, Step1, indent Step1.1, Step1.2, Step1.3, Decision, Yes, No, Step2, End.\n\nWe need to ensure each line ends with \"// 解釋\". Use short explanation. Provide Chinese explanations.\n\nLet's output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: repeat // 進入重複區塊，直到產生有效值  \n  → Step 1.1: a ← rand7() // 取得第一個隨機數 (1-7)  \n  → Step 1.2: b ← rand7() // 取得第二個隨機數 (1-7)  \n  → Step 1.3: num ← (a-1)*7 + b // 組合成 1-49 的數字  \n  → Decision: num <= 40? // 判斷是否在可用範圍內  \n   Yes → Step 1.4: result ← ((num-1) mod 10) + 1 // 將 1-40 映射到 1-10  \n   No  → Step 1 → repeat // 超過 40，重新開始  \n→ Step 2: return result // 回傳隨機數  \nEnd // 程式結束"
    },
    {
      "title": "Reverse Integer",
      "source_file": "Leetcode/leetcode7.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "x = -123",
          "expected_output": "-321",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '-321'\nGot (Norm):      '0'\n--- (Raw) ---\nRaw Expected: '-321'\nRaw Got:      '0'"
        }
      ],
      "generated_code": "#!/usr/bin/env python3\n\"\"\"\nReverse a signed 32‑bit integer.\nIf the reversed integer overflows, return 0.\nThe program reads an integer from standard input (e.g. \"x = 123\")\nand prints the reversed value.\n\"\"\"\n\nimport sys\nimport re\n\nclass Solution:\n    INT_MAX = 2 ** 31 - 1\n    INT_MIN = -2 ** 31\n\n    def reverse(self, x: int) -> int:\n        rev = 0\n        while x != 0:\n            pop = x % 10          # get last digit\n            x //= 10              # remove last digit\n\n            # check overflow before multiplying and adding\n            if rev > self.INT_MAX // 10 or \\\n               (rev == self.INT_MAX // 10 and pop > 7):\n                return 0\n            if rev < self.INT_MIN // 10 or \\\n               (rev == self.INT_MIN // 10 and pop < -8):\n                return 0\n\n            rev = rev * 10 + pop\n        return rev\n\ndef main() -> None:\n    # read the whole input, e.g. \"x = 123\"\n    data = sys.stdin.read()\n    # extract the signed integer from the input\n    match = re.search(r'-?\\d+', data)\n    if not match:\n        # no integer found; nothing to do\n        return\n    x = int(match.group())\n\n    sol = Solution()\n    result = sol.reverse(x)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for reversing digits of a 32-bit signed integer with overflow handling, no 64-bit integers. So typical algorithm: handle sign, extract digits via mod 10, build reversed number, check overflow before multiplication/addition. We should not use 64-bit types; so we must use 32-bit operations. To check overflow: before adding digit, check if rev > INT_MAX/10 or rev == INT_MAX/10 and digit > 7; for negative, similar with INT_MIN.\n\nWe'll produce step by step: Start, decide sign, initialize rev = 0, loop while x != 0, get pop = x % 10, x = x / 10; check overflow: if rev > INT_MAX/10 or rev == INT_MAX/10 and pop > 7: return 0; if rev < INT_MIN/10 or rev == INT_MIN/10 and pop < -8: return 0; rev = rev * 10 + pop. End. Also need to handle sign: we can work with negative x and pop will be negative.\n\nBut we cannot use 64-bit. We'll use 32-bit signed int variables.\n\nNow produce virtual code lines with arrows. Let's design:\n\nStart // 程式開始執行\n→ Step 1: 定義常數 INT_MAX = 2147483647, INT_MIN = -2147483648 // 定義32位整數極值\n→ Step 2: 讀入輸入整數 x // 取得要反轉的數字\n→ Step 3: 初始化 rev = 0 // 儲存反轉後的結果\n→ Decision: 只要 x ≠ 0? // 只要還有位數未處理\n    Yes → Step 4: pop = x % 10 // 取出 x 最右邊的數字\n    → Step 5: x = x / 10 // 去掉已取出的數字\n    → Decision: 檢查正向溢出？ // 若 rev > INT_MAX/10 或 rev == INT_MAX/10 且 pop > 7\n        Yes → Step 6: 回傳 0 // 超出範圍，結束\n        No  → Decision: 檢查負向溢出？ // 若 rev < INT_MIN/10 或 rev == INT_MIN/10 且 pop < -8\n            Yes → Step 7: 回傳 0\n            No  → Step 8: rev = rev * 10 + pop // 追加新位\n    → 回到 Decision: x ≠ 0? // 迴圈\n→ Step 9: 回傳 rev // 反轉完成\nEnd // 程式結束\n\nBut we need to ensure we include the flow arrow for decisions, and steps.\n\nAlso each line should be like \"虛擬碼步驟 // 解釋\". Use arrow symbols for decisions and branches. Should include \"Yes →\" or \"No →\".\n\nLet's craft carefully. We'll use \"Start\", \"End\", \"Decision:\".\n\nWe need to start: \"Start // 程式開始執行\"\n\nThen arrow \"→ Step 1: ...\" etc.\n\nUse Decision: if x ≠ 0? etc. Then inside branches.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 INT_MAX = 2147483647, INT_MIN = -2147483648 // 32 位整數極值  \n→ Step 2: 讀入輸入整數 x // 取得要反轉的數字  \n→ Step 3: 初始化 rev = 0 // 用於儲存反轉後的結果  \n→ Decision: x ≠ 0? // 只要還有位數未處理  \n    Yes → Step 4: pop = x % 10 // 取出 x 最右邊的數字  \n    → Step 5: x = x / 10 // 去掉已取出的數字  \n    → Decision: rev > INT_MAX/10 或 (rev = INT_MAX/10 且 pop > 7)? // 檢查正向溢出  \n        Yes → Step 6: 回傳 0 // 超出範圍，結束  \n        No → Decision: rev < INT_MIN/10 或 (rev = INT_MIN/10 且 pop < -8)? // 檢查負向溢出  \n            Yes → Step 7: 回傳 0  \n            No → Step 8: rev = rev * 10 + pop // 追加新位數  \n    → 回到 Decision: x ≠ 0? // 迴圈繼續  \n→ Step 9: 回傳 rev // 反轉完成  \nEnd // 程式結束"
    },
    {
      "title": "Wiggle Sort II",
      "source_file": "Leetcode/leetcode324.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,5,1,1,6,4]",
          "expected_output": "[1,6,1,5,1,4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[1,6,1,5,1,4]'\nGot (Norm):      '[1,5,1,6,1,4]'\n--- (Raw) ---\nRaw Expected: '[1,6,1,5,1,4]'\nRaw Got:      '[1, 5, 1, 6, 1, 4]'"
        },
        {
          "example_index": 1,
          "input": "nums = [1,3,2,2,3,1]",
          "expected_output": "[2,3,1,3,1,2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,3,1,3,1,2]'\nGot (Norm):      '[1,3,2,3,1,2]'\n--- (Raw) ---\nRaw Expected: '[2,3,1,3,1,2]'\nRaw Got:      '[1, 3, 2, 3, 1, 2]'"
        }
      ],
      "generated_code": "import sys, ast\n\nclass Solution:\n    def wiggleSort(self, nums):\n        for i in range(1, len(nums)):\n            if (i % 2 == 1 and nums[i] < nums[i-1]) or (i % 2 == 0 and nums[i] > nums[i-1]):\n                nums[i], nums[i-1] = nums[i-1], nums[i]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    if '=' in data:\n        _, list_part = data.split('=', 1)\n    else:\n        list_part = data\n    nums = ast.literal_eval(list_part.strip())\n    Solution().wiggleSort(nums)\n    print(nums)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for the wiggle sort. For an integer array nums, reorder such that nums[0] < nums[1] > nums[2] < nums[3]... The assumption is input always has valid answer. We need to produce step-by-step algorithm. One approach: iterate over array, for each odd index i, ensure nums[i-1] < nums[i] else swap; for each even index i, ensure nums[i] > nums[i+1] else swap. Actually standard wiggle sort algorithm: for i from 1 to n-1: if (i%2==1 and nums[i] < nums[i-1]) or (i%2==0 and nums[i] > nums[i-1]) then swap. But careful: we want < > < > pattern starting with < at index 0<1. So at odd indices, nums[i-1] < nums[i]; at even indices, nums[i-1] > nums[i]. Equivalent condition: if (i%2==1 && nums[i] < nums[i-1]) or (i%2==0 && nums[i] > nums[i-1]) then swap.\n\nAlternatively we can sort then use virtual indexing but no need. Provide simple algorithm.\n\nNeed to produce each line with virtual code and explanation.\n\nLet's produce:\n\nStart\n→ Step 1: Initialize i = 1 // start from second element\n→ Decision: i < length(nums)? // loop condition\n    Yes → Step 2: If (i mod 2 == 1 AND nums[i] < nums[i-1]) OR (i mod 2 == 0 AND nums[i] > nums[i-1])? // check wiggle condition\n        Yes → Step 3: Swap nums[i] and nums[i-1] // swap to satisfy pattern\n        No  → // nothing\n    No  → // exit loop\n→ Step 4: i = i + 1 // move to next element\n→ Step 5: Go back to Decision: i < length(nums)? // loop\nEnd\n\nBut need to follow virtual code format precisely: Use arrow \"→\" and \"Yes →\", \"No →\". Also \"Decision:\" before decision.\n\nAlso include step numbers or labels. Format: \"Step 1: ...\". Use arrows for flow.\n\nLet's produce final answer accordingly.\n\nAlso ensure to include comments after each line after space.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: i ← 1 // 初始化索引為第二個元素\n→ Decision: i < length(nums) ? // 判斷是否還有未處理的元素\n    Yes → Step 2: If (i mod 2 == 1 AND nums[i] < nums[i-1]) OR (i mod 2 == 0 AND nums[i] > nums[i-1]) ? // 檢查是否違反 wiggle 需求\n        Yes → Step 3: Swap(nums[i], nums[i-1]) // 交換兩個元素以滿足 < > 交替\n        No  → // 不需要交換，保持現狀\n    No  → // 已經處理完所有元素\n→ Step 4: i ← i + 1 // 移動到下一個位置\n→ Step 5: Go back to Decision: i < length(nums) ? // 重複處理直到結束\nEnd // 程式執行結束\n\nBut we need to be careful: the loop structure: Step 4 should go back to Decision. So we need to reflect loop: after Step 4 we go back to Decision. But the pseudo-code could show \"→ Step 4: i ← i + 1 // 移動到下一個位置\" and then \"→ Go back to Decision: i < length(nums) ?\" but this might duplicate Decision. Alternatively we can combine Step 4 and loop.\n\nWe can restructure as:\n\nStart\n→ Step 1: i ← 1\n→ Decision: i < length(nums) ?\n    Yes → Step 2: If (i mod 2 == 1 AND nums[i] < nums[i-1]) OR (i mod 2 == 0 AND nums[i] > nums[i-1]) ?\n        Yes → Step 3: Swap(nums[i], nums[i-1])\n        No  → // do nothing\n    No  → // done\n→ Step 4: i ← i + 1\n→ Step 5: Go back to Decision: i < length(nums) ?\nEnd\n\nBut we need to ensure that after Step 4 we go back to Decision. So maybe combine Step 4 and Step 5 as \"→ Step 4: i ← i + 1 // 移動到下一個位置\" then \"→ Go back to Decision: i < length(nums) ?\". But the format demands \"Decision:\" preceding decisions. So we can do \"→ Decision: i < length(nums) ?\" after Step 4. That works.\n\nThus final answer: produce lines.\n\nLet's craft final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: i ← 1 // 初始化索引為第二個元素  \n→ Decision: i < length(nums) ? // 判斷是否還有未處理的元素  \n    Yes → Step 2: If (i mod 2 == 1 AND nums[i] < nums[i-1]) OR (i mod 2 == 0 AND nums[i] > nums[i-1]) ? // 檢查是否違反 wiggle 需求  \n        Yes → Step 3: Swap(nums[i], nums[i-1]) // 交換兩個元素以滿足 < > 交替  \n        No → // 不需要交換，保持現狀  \n    No → // 已經處理完所有元素  \n→ Step 4: i ← i + 1 // 移動到下一個位置  \n→ Decision: i < length(nums) ? // 回到循環判斷  \nEnd // 程式執行結束"
    },
    {
      "title": "Evaluate Division",
      "source_file": "Leetcode/leetcode399.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]",
          "expected_output": "[6.00000,0.50000,-1.00000,1.00000,-1.00000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpoa2d5gks.py\", line 54, in <module>\n    main()\n  File \"/tmp/tmpoa2d5gks.py\", line 49, in main\n    ans = sol.calcEquation(equations, values, queries)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpoa2d5gks.py\", line 9, in calcEquation\n    graph[a][b] = val\n    ~~~~~^^^\nTypeError: unhashable type: 'list'"
        },
        {
          "example_index": 1,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1.5,2.5,5.0], queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]",
          "expected_output": "[3.75000,0.40000,5.00000,0.20000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpbi77c28i.py\", line 54, in <module>\n    main()\n  File \"/tmp/tmpbi77c28i.py\", line 49, in main\n    ans = sol.calcEquation(equations, values, queries)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpbi77c28i.py\", line 8, in calcEquation\n    for (a, b), val in zip(equations, values):\n        ^^^^^^\nValueError: too many values to unpack (expected 2)"
        },
        {
          "example_index": 2,
          "input": "equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]",
          "expected_output": "[0.50000,2.00000,-1.00000,-1.00000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp1pajmixe.py\", line 54, in <module>\n    main()\n  File \"/tmp/tmp1pajmixe.py\", line 49, in main\n    ans = sol.calcEquation(equations, values, queries)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp1pajmixe.py\", line 8, in calcEquation\n    for (a, b), val in zip(equations, values):\n        ^^^^^^\nValueError: not enough values to unpack (expected 2, got 1)"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def calcEquation(self, equations, values, queries):\n        graph = defaultdict(dict)\n        for (a, b), val in zip(equations, values):\n            graph[a][b] = val\n            graph[b][a] = 1 / val\n\n        def dfs(src, dst, visited):\n            if src not in graph or dst not in graph:\n                return -1.0\n            if src == dst:\n                return 1.0\n            visited.add(src)\n            for neighbor, weight in graph[src].items():\n                if neighbor not in visited:\n                    res = dfs(neighbor, dst, visited)\n                    if res != -1.0:\n                        return weight * res\n            return -1.0\n\n        results = []\n        for u, v in queries:\n            results.append(dfs(u, v, set()))\n        return results\n\ndef main():\n    data = sys.stdin.read()\n    if not data:\n        return\n    # 移除所有空白字元，簡化切割\n    s = ''.join(data.split())\n\n    idx_values = s.find('values=')\n    idx_queries = s.find('queries=')\n\n    eq_part = s[:idx_values].replace('equations=', '', 1)\n    values_part = s[idx_values + len('values='):idx_queries]\n    queries_part = s[idx_queries + len('queries='):]\n\n    equations = ast.literal_eval(eq_part)\n    values = ast.literal_eval(values_part)\n    queries = ast.literal_eval(queries_part)\n\n    sol = Solution()\n    ans = sol.calcEquation(equations, values, queries)\n    output = '[' + ','.join(f'{x:.5f}' for x in ans) + ']'\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step: reading equations and values, building graph, handling queries with BFS/DFS, returning -1.0 if undefined. Provide explanation each line. Use Start, End, Decision, arrows. Provide steps for building graph, then each query.\n\nLet's write pseudocode:\n\nStart // program start\n→ Build graph: For each equation i: add edge Ai->Bi weight values[i] and Bi->Ai weight 1/values[i] // build adjacency list\n→ For each query j: \n    Decision: if either Cj or Dj not in graph? // check defined\n        Yes → Step: output -1.0\n        No  → Step: perform DFS from Cj to find path to Dj\n              Decision: if path found?\n                 Yes → Step: compute product of weights along path\n                      Output product\n                 No  → Step: output -1.0\n→ End\n\nBut need line by line virtual code: include Step numbers or labels. Provide explanations.\n\nLet's produce detailed steps:\n\nStart\n→ Step 1: Initialize adjacency list graph // store variable relations\n→ Step 2: For i in 0..equations.length-1:\n   → Step 2.1: Ai ← equations[i][0]; Bi ← equations[i][1]; val ← values[i]\n   → Step 2.2: Add edge Ai -> Bi with weight val // Ai / Bi = val\n   → Step 2.3: Add edge Bi -> Ai with weight 1/val // Bi / Ai = 1/val\n→ Step 3: Initialize result array res\n→ Step 4: For each query [C, D] in queries:\n   → Decision: If C not in graph or D not in graph? // undefined variables\n       Yes → Step 4.1: Append -1.0 to res // cannot determine\n       No  → Step 4.2: Perform DFS search from C to find D\n            → Step 4.2.1: Initialize stack with (C, 1.0) // current product\n            → Step 4.2.2: Initialize visited set\n            → While stack not empty:\n                → Step 4.2.2.1: Pop (node, prod)\n                → Step 4.2.2.2: If node == D? // reached target\n                    Yes → Step 4.2.2.3: Append prod to res\n                           Break loop\n                    No  → Decision: For each neighbor of node:\n                           If neighbor not visited:\n                               Push (neighbor, prod * weight(node,neighbor))\n                               Mark visited\n            → Decision: If loop finished without finding D?\n                Yes → Step 4.2.3: Append -1.0 to res\n→ End\n\nNeed to adhere to format: Each line: virtual code step [space] // explanation.\n\nWe should not include actual code but steps. Use arrow \"→\". Include Decision blocks.\n\nAlso we can number steps but not necessary. Use \"Step\" names. Provide explanation. We'll produce each line.\n\nEnsure no actual code. Use \"→ Step ...\" lines. For loops, maybe \"→ For i in 0..len-1:\". Provide explanation. For stack operations, maybe \"→ While stack not empty:\". Provide explanation. For DFS recursion, maybe \"→ Recursive DFS function\".\n\nSimplify: Provide iterative DFS. But we can use recursion.\n\nBetter: Provide function DFS(node, target, prod). But we need pseudocode. Let's produce lines:\n\nStart // Program begins\n→ Step 1: Create empty adjacency map graph // stores neighbours and ratios\n→ Step 2: For each index i from 0 to equations.length-1:\n   → Step 2.1: Ai ← equations[i][0]; Bi ← equations[i][1]; val ← values[i] // extract parts\n   → Step 2.2: Add edge Ai → Bi with weight val // Ai / Bi = val\n   → Step 2.3: Add edge Bi → Ai with weight 1/val // Bi / Ai = 1/val\n→ Step 3: Initialize array answers // to hold results for queries\n→ Step 4: For each query q in queries:\n   → Step 4.1: C ← q[0]; D ← q[1] // query variables\n   → Decision: If C not in graph OR D not in graph? // variable missing\n       Yes → Step 4.1.1: Append -1.0 to answers // cannot compute\n       No  → Step 4.1.2: Call DFS(C, D, 1.0, empty set) // search path\n           → Decision: If DFS returns a value v?\n               Yes → Step 4.1.3: Append v to answers // found ratio\n               No  → Step 4.1.4: Append -1.0 to answers // no path\n→ End // Program finishes\n\nNow we need to describe DFS function:\n\n→ Function DFS(current, target, prod, visited) // DFS to find ratio\n   → Decision: If current == target? // reached target\n       Yes → Return prod // product along path\n       No  → Mark current as visited\n   → For each neighbour n of current with weight w:\n       → Decision: If n not in visited? // avoid cycles\n           Yes → Call DFS(n, target, prod * w, visited)\n               → Decision: If result != -1? // found\n                   Yes → Return result // propagate back\n   → Return -1.0 // no path from current to target\n\nThis can be integrated.\n\nBut format: Each line must include virtual code step + explanation. So we need to produce each line. We can number functions.\n\nWe can use \"→ Function DFS(...)\" line.\n\nLet's produce full pseudocode step by step.\n\nNeed to adhere to the sample format: \"Start // 程式開始執行\" etc. Use arrow for steps inside.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: graph ← empty map // 建立鄰接表\n→ Step 2: For i ← 0 to equations.length - 1:\n   → Step 2.1: Ai ← equations[i][0]; Bi ← equations[i][1]; val ← values[i] // 取得方程式與值\n   → Step 2.2: graph[Ai][Bi] ← val // Ai / Bi = val\n   → Step 2.3: graph[Bi][Ai] ← 1 / val // Bi / Ai = 1/val\n→ Step 3: answers ← empty list // 存放查詢結果\n→ Step 4: For each query in queries:\n   → Step 4.1: C ← query[0]; D ← query[1] // 取得查詢變數\n   → Decision: C not in graph OR D not in graph? // 變數未定義\n       Yes → Step 4.1.1: answers.append(-1.0) // 不能計算\n       No  → Step 4.1.2: ratio ← DFS(C, D, 1.0, empty set) // 搜尋路徑\n           → Decision: ratio == -1.0? // 未找到路徑\n               Yes → Step 4.1.3: answers.append(-1.0)\n               No  → Step 4.1.4: answers.append(ratio)\n→ End // 程式結束\n\nNow function:\n\n→ Function DFS(curr, target, prod, visited):\n   → Decision: curr == target? // 到達目標\n       Yes → Return prod // 成功\n       No  → visited.add(curr) // 標記已訪問\n   → For each (nbr, w) in graph[curr].items():\n       → Decision: nbr not in visited? // 避免循環\n           Yes → result ← DFS(nbr, target, prod * w, visited)\n               → Decision: result != -1.0? // 找到路徑\n                   Yes → Return result // 傳回結果\n   → Return -1.0 // 沒有路徑\n\nWe need to ensure each line uses \"→\" and explanation. Should we indent? The sample uses indentation for nested decisions but each line must be separate. We can use multiple lines with indent but still separate lines. We can mimic.\n\nLet's produce final output with each line.\n\nMake sure to use \"Start\" line, then \"→\" lines. Provide Chinese explanation.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: graph ← empty map // 建立鄰接表以儲存變數間的比例  \n→ Step 2: For i ← 0 to equations.length - 1: // 遍歷所有已知方程式  \n → Step 2.1: Ai ← equations[i][0]; Bi ← equations[i][1]; val ← values[i] // 取出方程式兩端與對應值  \n → Step 2.2: graph[Ai][Bi] ← val // Ai / Bi = val  \n → Step 2.3: graph[Bi][Ai] ← 1 / val // Bi / Ai = 1/val  \n→ Step 3: answers ← empty list // 用來收集所有查詢的答案  \n→ Step 4: For each query in queries: // 處理每個查詢  \n → Step 4.1: C ← query[0]; D ← query[1] // 取得查詢變數  \n → Decision: C not in graph OR D not in graph? // 變數未定義時直接返回 -1.0  \n  Yes → Step 4.1.1: answers.append(-1.0) // 無法計算  \n  No  → Step 4.1.2: ratio ← DFS(C, D, 1.0, empty set) // 使用 DFS 搜尋路徑  \n   → Decision: ratio == -1.0? // 未找到有效路徑  \n    Yes → Step 4.1.3: answers.append(-1.0)  \n    No  → Step 4.1.4: answers.append(ratio)  \n→ End // 程式結束  \n\n→ Function DFS(curr, target, prod, visited): // 從 curr 開始尋找 target，prod 為目前乘積  \n → Decision: curr == target? // 到達目標變數  \n  Yes → Return prod // 成功，返回累積比例  \n  No  → visited.add(curr) // 標記已訪問  \n → For each (nbr, w) in graph[curr].items(): // 遍歷相鄰節點  \n  → Decision: nbr not in visited? // 避免循環  \n   Yes → result ← DFS(nbr, target, prod * w, visited) // 進一步搜尋  \n    → Decision: result != -1.0? // 找到路徑  \n     Yes → Return result // 傳回比例  \n → Return -1.0 // 無法從 curr 走到 target 的路徑"
    },
    {
      "title": "Implement Stack using Queues",
      "source_file": "Leetcode/leetcode225.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "Input [\"MyStack\", \"push\", \"push\", \"top\", \"pop\", \"empty\"], [[], [1], [2], [], [], []]",
          "expected_output": "[null, null, null, 2, 2, false]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,2,2,false]'\nGot (Norm):      '[null,null,2,2,false]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, 2, 2, false]'\nRaw Got:      '[null, null, 2, 2, false]'"
        }
      ],
      "generated_code": "import sys\nimport json\nfrom collections import deque\nimport re\n\nclass MyStack:\n    def __init__(self):\n        # 使用兩個佇列，q1 為主要佇列，q2 為臨時佇列\n        self.q1 = deque()\n        self.q2 = deque()\n\n    def push(self, x: int) -> None:\n        \"\"\"將元素加入堆疊頂部（放入 q1）。\"\"\"\n        self.q1.append(x)\n\n    def pop(self) -> int:\n        \"\"\"移除並回傳堆疊頂部元素。\"\"\"\n        if self.empty():\n            return None\n        # 將 q1 內除最後一個之外的所有元素移到 q2\n        while len(self.q1) > 1:\n            self.q2.append(self.q1.popleft())\n        res = self.q1.popleft()   # 最後一個元素即為頂部\n        # 交換兩個佇列，使 q1 再次為主要佇列\n        self.q1, self.q2 = self.q2, self.q1\n        return res\n\n    def top(self) -> int:\n        \"\"\"取得堆疊頂部元素，但不移除。\"\"\"\n        if self.empty():\n            return None\n        # 與 pop 類似，但要把頂部元素先放回 q2\n        while len(self.q1) > 1:\n            self.q2.append(self.q1.popleft())\n        res = self.q1.popleft()\n        self.q2.append(res)        # 再放回\n        self.q1, self.q2 = self.q2, self.q1\n        return res\n\n    def empty(self) -> bool:\n        \"\"\"判斷堆疊是否為空。\"\"\"\n        return not self.q1 and not self.q2\n\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 移除可能的前綴字元\n    if data.lower().startswith('input'):\n        data = data[5:].strip()\n\n    # 將兩個列表包成一個列表再解析\n    try:\n        ops_and_args = json.loads('[' + data + ']')\n    except json.JSONDecodeError:\n        # 若格式不符 JSON，可嘗試使用 eval\n        ops_and_args = eval('[' + data + ']')\n\n    ops, args = ops_and_args[0], ops_and_args[1]\n\n    stack = MyStack()\n    results = []\n\n    for op, arg in zip(ops, args):\n        if op == 'push':\n            results.append(None)  # push 本身不返回值\n            # arg 可能是單值或列表，取首個元素\n            val = arg[0] if isinstance(arg, (list, tuple)) else arg\n            stack.push(val)\n        elif op == 'pop':\n            results.append(stack.pop())\n        elif op == 'top':\n            results.append(stack.top())\n        elif op == 'empty':\n            results.append(stack.empty())\n        else:\n            # 若遇到未知操作，直接忽略或可加入錯誤訊息\n            pass\n\n    # 輸出結果，使用 json.dumps 可得到符合範例的格式\n    print(json.dumps(results))\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code line by line with comments. Use Start, End, Decision: with arrows. For this stack using two queues. Provide step-by-step pseudocode. Let's design:\n\nWe have two queues: q1, q2. For push, we enqueue to q1. For pop/top, we need to move all except last element from q1 to q2, then operate on last, then swap names. Provide empty by checking both empty.\n\nLet's output. Use arrows and indent decisions. Ensure each line has a virtual code step and comment. Use consistent formatting.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立兩個空 Queue q1, q2 // 初始化兩個佇列  \n→ Decision: 程式啟動時先進行操作? // 判斷是否即將收到方法呼叫  \n    Yes → Step 2: 呼叫 MyStack() 建構子 // 建立 Stack 物件  \n        → Step 3: q1 ← 空佇列 // q1 初始為空  \n        → Step 4: q2 ← 空佇列 // q2 初始為空  \n    No  → End // 無操作，程式結束  \n\n// --------- push 操作 ----------\n→ Step 5: push(x) // 接收要進入 Stack 的元素  \n    → Step 6: q1.enqueue(x) // 把 x 加入 q1 的尾部  \n    → Step 7: // push 完成  \n\n// --------- top 操作 ----------\n→ Step 8: top() // 取得 Stack 最上層元素  \n    → Step 9: 若 q1.isEmpty() 或 q2.isEmpty() → Step 10: return null // Stack 為空  \n    → Step 11: 若 q1.isEmpty() →  \n        → Step 12: tmp ← q2  \n        → Step 13: q2 ← q1  \n        → Step 14: q1 ← tmp  \n    → Step 15: 若 q2.isEmpty() →  \n        → Step 16: tmp ← q1  \n        → Step 17: q1 ← q2  \n        → Step 18: q2 ← tmp  \n    → Step 19: // 確保非空佇列為 q1，空佇列為 q2  \n    → Step 20: // 將 q1 內所有元素轉移到 q2，保留最後一個為 top  \n        → Step 21: While q1.size() > 1 →  \n            → Step 22: q2.enqueue(q1.dequeue()) // 移除前端放到 q2  \n    → Step 23: topElement ← q1.dequeue() // 取出最後一個元素  \n    → Step 24: q2.enqueue(topElement) // 將它放回 q2，保持順序  \n    → Step 25: // 交換兩個佇列，讓 q1 再次成為主要佇列  \n        → Step 26: tmp ← q1  \n        → Step 27: q1 ← q2  \n        → Step 28: q2 ← tmp  \n    → Step 29: return topElement // 回傳最上層元素  \n\n// --------- pop 操作 ----------\n→ Step 30: pop() // 移除並回傳 Stack 最上層元素  \n    → Step 31: 若 q1.isEmpty() 或 q2.isEmpty() → Step 32: return null // Stack 為空  \n    → Step 33: 若 q1.isEmpty() →  \n        → Step 34: tmp ← q2  \n        → Step 35: q2 ← q1  \n        → Step 36: q1 ← tmp  \n    → Step 37: 若 q2.isEmpty() →  \n        → Step 38: tmp ← q1  \n        → Step 39: q1 ← q2  \n        → Step 40: q2 ← tmp  \n    → Step 41: // 確保非空佇列為 q1，空佇列為 q2  \n    → Step 42: // 將 q1 內所有元素轉移到 q2，保留最後一個作為要移除的元素  \n        → Step 43: While q1.size() > 1 →  \n            → Step 44: q2.enqueue(q1.dequeue()) // 移除前端放到 q2  \n    → Step 45: poppedElement ← q1.dequeue() // 取出最後一個元素（即 Stack 顶部）  \n    → Step 46: // 交換兩個佇列，讓 q1 再次成為主要佇列  \n        → Step 47: tmp ← q1  \n        → Step 48: q1 ← q2  \n        → Step 49: q2 ← tmp  \n    → Step 50: return poppedElement // 回傳被移除的元素  \n\n// --------- empty 操作 ----------\n→ Step 51: empty() // 判斷 Stack 是否為空  \n    → Step 52: return (q1.isEmpty() AND q2.isEmpty()) // 兩個佇列均空則 Stack 空  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Course Schedule II",
      "source_file": "Leetcode/leetcode210.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]",
          "expected_output": "[0,2,1,3]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[0,2,1,3]'\nGot (Norm):      '[0,1,2,3]'\n--- (Raw) ---\nRaw Expected: '[0,2,1,3]'\nRaw Got:      '[0, 1, 2, 3]'"
        }
      ],
      "generated_code": "import sys\nimport re\nfrom collections import deque\n\nclass Solution:\n    def findOrder(self, numCourses, prerequisites):\n        # 建立鄰接表與入度陣列\n        graph = [[] for _ in range(numCourses)]\n        indegree = [0] * numCourses\n\n        # 建立圖\n        for dest, src in prerequisites:\n            graph[src].append(dest)\n            indegree[dest] += 1\n\n        # 取入度為 0 的節點入隊\n        queue = deque([i for i in range(numCourses) if indegree[i] == 0])\n        order = []\n\n        # Kahn 演算法進行拓樸排序\n        while queue:\n            node = queue.popleft()\n            order.append(node)\n            for neighbor in graph[node]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    queue.append(neighbor)\n\n        return order if len(order) == numCourses else []\n\ndef parse_input(data: str):\n    \"\"\"\n    從輸入字串中擷取 numCourses 與 prerequisites。\n    支援類似 'numCourses = 2, prerequisites = [[1,0]]' 的格式，\n    也可以處理多行或換行的輸入。\n    \"\"\"\n    # 取得 numCourses\n    num_match = re.search(r'numCourses\\s*=\\s*(\\d+)', data)\n    numCourses = int(num_match.group(1)) if num_match else 0\n\n    # 取得 prerequisites\n    prereq_match = re.search(r'prerequisites\\s*=\\s*(\\[\\[.*\\]\\])', data, re.S)\n    if prereq_match:\n        # 使用 eval 解析列表字串（假設輸入安全且符合 Python 語法）\n        prerequisites = eval(prereq_match.group(1))\n    else:\n        prerequisites = []\n\n    return numCourses, prerequisites\n\nif __name__ == \"__main__\":\n    raw_data = sys.stdin.read()\n    if not raw_data.strip():\n        # 若沒有輸入則直接結束\n        sys.exit(0)\n\n    numCourses, prerequisites = parse_input(raw_data)\n\n    solution = Solution()\n    order = solution.findOrder(numCourses, prerequisites)\n\n    # 輸出結果\n    print(order)",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for topological sort. Provide step-by-step algorithm. We'll produce pseudo code. Let's produce:\n\nStart\n→ Step: Build adjacency list and indegree array // from prerequisites\n→ Decision: Check if graph has cycle via Kahn's algorithm\n    Yes → Step: Return [] // cannot finish\n    No  → Step: Initialize queue with nodes indegree 0 // courses with no prereqs\n→ While queue not empty:\n    → Step: Dequeue course // current course to take\n    → Step: Append to order // add to result\n    → Step: For each neighbor in adjacency list[course]:\n        → Step: Decrease indegree[neighbor] // one prereq done\n        → Decision: if indegree[neighbor]==0?\n            Yes → Step: Enqueue neighbor // ready to take\n→ Decision: if order length == numCourses?\n    Yes → Step: Return order // valid ordering\n    No  → Step: Return [] // cycle\n\nWe need each line as a separate virtual code line. Use arrows. Use indentation for nested decisions. Ensure each line ends with // explanation. Let's produce.\n\nMake sure to include Start and End. Use proper indentation for decisions. For each line we need \"虛擬碼步驟\" followed by space and comment. Use arrow or No arrow. We'll maintain same formatting. Let's produce lines:\n\nStart // 程式開始執行\n→ Step: 初始化圖和入度 // 建立鄰接表和入度數\n→ Step: for each pair [a,b] in prerequisites\n    → Step: adj[b].append(a) // b 是 a 的前置課程\n    → Step: indegree[a] += 1 // a 的入度加 1\n→ Decision: 如果有循環? // 檢查是否存在環\n    Yes → Step: Return [] // 不能完成所有課程\n    No  → Step: 初始化隊列 // 找入度為 0 的課程\n        → Step: for each course i from 0 to numCourses-1\n            → Decision: 如果 indegree[i] == 0?\n                Yes → Step: queue.enqueue(i) // 可立即修課\n→ Step: order = [] // 存放修課順序\n→ While queue 不為空:\n    → Step: course = queue.dequeue() // 取出課程\n    → Step: order.append(course) // 加入順序\n    → Step: for each next in adj[course]\n        → Step: indegree[next] -= 1 // 減少下一課的入度\n        → Decision: 如果 indegree[next] == 0?\n            Yes → Step: queue.enqueue(next) // 現已無前置課程\n→ Decision: 如果 order.length == numCourses?\n    Yes → Step: Return order // 成功得到修課順序\n    No  → Step: Return [] // 存在循環\nEnd // 程式執行結束\n\nBut we need to keep each line separate with arrow. Also decisions need nested arrows. Format: Decision: ... Then Yes → and No → lines. Use indentation for Yes/No. Let's ensure each line distinct. Also each line has only one arrow? The example uses \"Yes → Step 2: ...\" with spaces. So we replicate.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: 初始化圖與入度 // 建立鄰接表與入度陣列  \n→ Step: for 每組 [a, b] in prerequisites  \n    → Step: adj[b].append(a) // b 是 a 的前置課程  \n    → Step: indegree[a] += 1 // a 的入度加 1  \n→ Decision: 有循環嗎? // 檢查圖是否存在環  \n    Yes → Step: Return [] // 無法完成所有課程  \n    No  → Step: 初始化隊列 // 找入度為 0 的課程  \n        → Step: for i in 0 .. numCourses-1  \n            → Decision: indegree[i] == 0?  \n                Yes → Step: queue.enqueue(i) // 可立即修課  \n→ Step: order = [] // 存放修課順序  \n→ While queue 不是空  \n    → Step: course = queue.dequeue() // 取出課程  \n    → Step: order.append(course) // 加入順序  \n    → Step: for 每個 next in adj[course]  \n        → Step: indegree[next] -= 1 // 減少下一課的入度  \n        → Decision: indegree[next] == 0?  \n            Yes → Step: queue.enqueue(next) // 現已無前置課程  \n→ Decision: order.length == numCourses?  \n    Yes → Step: Return order // 成功得到修課順序  \n    No  → Step: Return [] // 存在循環  \nEnd // 程式執行結束"
    },
    {
      "title": "Generate Random Point in a Circle",
      "source_file": "Leetcode/leetcode478.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]",
          "expected_output": "[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[-0.02493,-0.38077],[0.82314,0.38945],[0.36572,0.17248]]'\nGot (Norm):      '[null,[0.0082525500566852,-0.04757203684530631],[-0.1435706083850276,0.3570551981603148],[-0.0820471576951257,0.9405228037347939]]'\n--- (Raw) ---\nRaw Expected: '[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]'\nRaw Got:      '[null, [0.0082525500566852, -0.04757203684530631], [-0.1435706083850276, 0.3570551981603148], [-0.0820471576951257, 0.9405228037347939]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport math\n\nclass Solution:\n    def __init__(self, radius, x_center, y_center):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n\n    def randPoint(self):\n        # 以極座標方式產生均勻分布的隨機點\n        r = self.radius * math.sqrt(random.random())\n        theta = random.uniform(0, 2 * math.pi)\n        x = self.x_center + r * math.cos(theta)\n        y = self.y_center + r * math.sin(theta)\n        return [x, y]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    if len(data) < 2:\n        sys.exit()\n    commands = json.loads(data[0])          # [\"Solution\", \"randPoint\", ...]\n    args_list = json.loads(data[1])         # [[1.0, 0.0, 0.0], [], ...]\n\n    obj = None\n    results = []\n\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"Solution\":\n            obj = Solution(*args)\n            results.append(None)           # 對應 null\n        elif cmd == \"randPoint\":\n            results.append(obj.randPoint())\n\n    # 輸出結果，None 會轉成 JSON null\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to generate virtual code step-by-step. The task: generate uniform random point inside circle. Implementation: using polar coordinates with sqrt(r) to adjust radius. Steps: constructor stores radius, center. randPoint: generate random angle 0-2π, generate random radius sqrt(rand() * r^2). Then convert to cartesian: x = center_x + radius* cos(angle), y = center_y + radius* sin(angle). Return array. Use virtual code. Need to produce steps lines. Use Start, End, Decision maybe. Not necessary decisions. But we can include decision on generating random number? Not necessary. Just produce sequential steps.\n\nMake sure each line: virtual code step, then comment. Use arrow →. The first line \"Start\". Next line: → Step 1: Initialize properties. Then Step 2: define randPoint. Inside, Step 3: generate random angle. Step 4: generate random radius. Step 5: compute x. Step 6: compute y. Step 7: return [x,y]. End.\n\nBut we need to show structure. For each method. Maybe use \"Start\" at top of constructor and \"End\" at bottom. Then \"Start\" inside randPoint. Let's produce.\n\nWe need to show virtual code: \"Start // 程式開始執行\" etc. Use arrow.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 Solution 類別並在建構子中存儲半徑與中心座標 // 保存半徑 radius、中心 (x_center, y_center)  \n→ Step 2: 在建構子結束時執行 End // 建構子完成  \n\nStart // randPoint 方法執行  \n→ Step 3: 產生一個 0 到 1 的隨機數 a // 用於計算隨機角度  \n→ Step 4: 計算角度 theta = 2π * a // 均勻分佈於 0~2π  \n→ Step 5: 產生另一個 0 到 1 的隨機數 b // 用於計算半徑  \n→ Step 6: 計算隨機半徑 r = radius * sqrt(b) // 取 sqrt 以確保點均勻分佈  \n→ Step 7: 計算 x 坐標 x = x_center + r * cos(theta) // 將極座標轉為直角座標  \n→ Step 8: 計算 y 坐標 y = y_center + r * sin(theta) // 同上  \n→ Step 9: 回傳 [x, y] 作為隨機點 // 整個方法結束  \nEnd // randPoint 方法結束  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Remove Element",
      "source_file": "Leetcode/leetcode27.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [3,2,2,3], val = 3",
          "expected_output": "2, nums = [2,2,_,_]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2,nums=[2,2,_,_]'\nGot (Norm):      '0,nums=[]'\n--- (Raw) ---\nRaw Expected: '2, nums = [2,2,_,_]'\nRaw Got:      '0, nums = []'"
        },
        {
          "example_index": 1,
          "input": "nums = [0,1,2,2,3,0,4,2], val = 2",
          "expected_output": "5, nums = [0,1,4,0,3,_,_,_]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '5,nums=[0,1,4,0,3,_,_,_]'\nGot (Norm):      '0,nums=[]'\n--- (Raw) ---\nRaw Expected: '5, nums = [0,1,4,0,3,_,_,_]'\nRaw Got:      '0, nums = []'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def removeElement(self, nums, val):\n        \"\"\"移除 nums 中所有等於 val 的元素，返回保留元素個數 k\"\"\"\n        slow = 0\n        for fast in range(len(nums)):\n            if nums[fast] != val:\n                nums[slow] = nums[fast]\n                slow += 1\n        return slow\n\ndef parse_input(data: str):\n    \"\"\"從輸入字串中解析出 nums 與 val\"\"\"\n    # 嘗試用逗號分割，支援「nums = [...], val = ...」形式\n    parts = data.split(',')\n    nums = None\n    val = None\n    for part in parts:\n        part = part.strip()\n        if part.startswith('nums'):\n            # 取得等號後面並 eval 解析 list\n            nums_part = part.split('=', 1)[1].strip()\n            try:\n                nums = eval(nums_part, {}, {})\n            except Exception:\n                nums = []\n        elif part.startswith('val'):\n            val_part = part.split('=', 1)[1].strip()\n            try:\n                val = int(val_part)\n            except Exception:\n                val = 0\n    # 若因為空 list 而沒有 nums，則判斷原始資料中是否有 [] 形式\n    if nums is None:\n        if '[]' in data:\n            nums = []\n        else:\n            # 取所有整數，最後一個視為 val\n            nums_vals = [int(x) for x in re.findall(r'-?\\d+', data)]\n            if nums_vals:\n                val = nums_vals[-1]\n                nums = nums_vals[:-1]\n            else:\n                nums = []\n                val = 0\n    return nums, val\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    nums, val = parse_input(data)\n    sol = Solution()\n    k = sol.removeElement(nums, val)\n\n    # 建立輸出字串：k, nums = [a1, a2, _, ...]\n    out_elements = []\n    for i in range(len(nums)):\n        if i < k:\n            out_elements.append(str(nums[i]))\n        else:\n            out_elements.append('_')\n    out_str = f\"{k}, nums = [{', '.join(out_elements)}]\"\n    print(out_str)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce a virtual code with step-by-step comments. Each line: \"虛擬碼步驟 [space] // 解釋\". Use arrows etc. Should reflect the algorithm to remove element in place and return k. Provide steps. Use start, end, decision. Should be in Traditional Chinese. We'll output each line.\n\nLet's design algorithm: Two-pointer approach: fast pointer i iterate over array; slow pointer j tracks position to write non-val. For each i, if nums[i]!=val, set nums[j]=nums[i], j++. After loop, return j.\n\nAlso need to handle case where array is empty. Also might use while loops. Use Decision for each element.\n\nWe'll produce pseudocode:\n\nStart // 程式開始執行\n→ Step 1: 初始化 j = 0 // 指向寫入位置\n→ Decision: 如果 nums 為空? // 判斷是否有元素\n    Yes → Step 2: 返回 0 // 空陣列直接返回 0\n    No  →\n→ Step 3: For i 從 0 到 nums.length - 1 // 遍歷所有元素\n→ Decision: 如果 nums[i] 不等於 val? // 判斷是否要保留\n    Yes → Step 4: nums[j] = nums[i] // 把非 val 的元素寫入 j\n           → Step 5: j = j + 1 // 移動寫入位置\n    No  → // 跳過，直接下一個 i\n→ Step 6: 返回 j // j 即為保留元素的數量\nEnd // 程式結束\n\nMake sure each line includes comment. Use arrows \"→\". Indent for nested steps.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 j = 0 // 設定寫入位置指標  \n→ Decision: 如果 nums 為空? // 判斷陣列是否為空  \n  Yes → Step 2: 返回 0 // 空陣列直接回傳 0  \n  No  →  \n→ Step 3: For i 從 0 到 nums.length - 1 // 逐個檢查每個元素  \n  Decision: 如果 nums[i] 不等於 val? // 判斷是否要保留  \n   Yes → Step 4: nums[j] = nums[i] // 將非 val 的元素寫回陣列  \n    → Step 5: j = j + 1 // 移動寫入位置指標  \n   No  → // 跳過此元素，直接往下一個 i  \n→ Step 6: 返回 j // j 為保留元素的數量，亦即 k  \nEnd // 程式執行結束"
    },
    {
      "title": "Shuffle an Array",
      "source_file": "Leetcode/leetcode384.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"], [[[1, 2, 3]], [], [], []]",
          "expected_output": "[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[3,1,2],[1,2,3],[1,3,2]]'\nGot (Norm):      '[null,[2,1,3],[1,2,3],[3,2,1]]'\n--- (Raw) ---\nRaw Expected: '[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]'\nRaw Got:      '[null, [2, 1, 3], [1, 2, 3], [3, 2, 1]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, nums):\n        # 儲存原始陣列的副本，避免外部改動影響\n        self.nums = list(nums)\n\n    def reset(self):\n        # 回傳原始陣列\n        return self.nums\n\n    def shuffle(self):\n        # Fisher-Yates 洗牌演算法\n        shuffled = list(self.nums)\n        n = len(shuffled)\n        for i in range(n):\n            j = random.randint(i, n - 1)\n            shuffled[i], shuffled[j] = shuffled[j], shuffled[i]\n        return shuffled\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 依照第一個 '],'\n    idx = data.find('],')\n    if idx == -1:\n        raise ValueError(\"Input format error\")\n    first = data[:idx + 1]            # 包含第一個 list 的 ']'\n    second = data[idx + 2:].strip()   # 跳過 ','\n    ops = json.loads(first)\n    args = json.loads(second)\n\n    obj = None\n    outputs = []\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            # 建構子呼叫，arg 為 [[1,2,3]] 之類\n            obj = Solution(*arg)\n            outputs.append(None)  # 代表 null\n        else:\n            method = getattr(obj, op)\n            result = method(*arg)\n            outputs.append(result)\n\n    print(json.dumps(outputs))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code lines, no actual code. Each line: virtual code step + space + // explanation. Use Start, End, Decision, etc. Should cover initialization, reset, shuffle using Fisher-Yates. Provide steps. Use arrows and indentation for decisions. Provide virtual code. Ensure to reflect methods. Let's produce lines:\n\nStart\n→ Step 1: Store original array copy // keep original order\n→ Step 2: Store current array reference // current state\n→ Decision: When reset() called? // method call\n    Yes → Step 3: Restore current array to copy of original // reset\n    No → Decision: When shuffle() called? // method call\n        Yes → Step 4: For i from 0 to length-1 // loop\n            → Step 5: Generate random index j between i and length-1 // random\n            → Step 6: Swap elements at i and j // Fisher-Yates swap\n        No → Step 7: Return current array // output\nEnd\n\nNeed to format with arrow lines. Use indentation. Provide explanation. Let's craft.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Copy input array to 原始副本 // 以備日後還原\n→ Step 2: 將當前陣列引用設為輸入陣列 // 代表目前狀態\n→ Decision: 呼叫 reset()? // 判斷是否需要還原\n    Yes → Step 3: 把 原始副本 複製回 當前陣列 // 恢復原始順序\n    No  → Decision: 呼叫 shuffle()? // 判斷是否需要隨機打亂\n        Yes → Step 4: 對每個索引 i 從 0 到 n-1 執行\n            → Step 5: 產生隨機整數 j，範圍為 [i, n-1] // 選取可交換位置\n            → Step 6: 交換 當前陣列[i] 與 當前陣列[j] // Fisher‑Yates 交換\n        No  → Step 7: 回傳 當前陣列 // 返回目前狀態\nEnd // 程式執行結束"
    },
    {
      "title": "Subsets",
      "source_file": "Leetcode/leetcode78.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nGot (Norm):      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nRaw Got:      '[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def subsets(self, nums):\n        res = []\n        def backtrack(start, path):\n            res.append(path[:])\n            for i in range(start, len(nums)):\n                path.append(nums[i])\n                backtrack(i + 1, path)\n                path.pop()\n        backtrack(0, [])\n        return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 如果輸入格式類似 'nums = [1,2,3]'，取等號右邊作為列表\n    if '=' in data:\n        _, rhs = data.split('=', 1)\n        rhs = rhs.strip()\n        nums = ast.literal_eval(rhs)\n    else:\n        # 直接就是列表文字\n        nums = ast.literal_eval(data)\n    solution = Solution()\n    result = solution.subsets(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code with line-by-line explanation, using the specified format. We need to describe algorithm: backtracking generating subsets. Each line: \"虛擬碼步驟 // 解釋\". Use arrows. We'll start with Start. Use Step 1 etc. Use Decision for loops. We need to not output actual code. So describe algorithmic steps. Let's produce something like:\n\nStart // 程式開始\n→ Step 1: 輸入陣列 nums // 取得輸入\n→ Step 2: 初始化結果 subsets 為空陣列 // 用於儲存所有子集\n→ Step 3: 定義遞迴函數 backtrack(index, current) // 生成子集\n→ Decision: index 等於 nums 長度? // 判斷是否達到終點\n    Yes → Step 4: 把 current 複製並加入 subsets // 將完整子集加入結果\n    No  → Decision: 是否包含 nums[index]?\n        Yes → Step 5: 加入 nums[index] 到 current // 包含當前元素\n        → Step 6: backtrack(index+1, current) // 遞迴探索包含元素的分支\n        → Step 7: 移除 nums[index] 從 current // 回溯，移除元素\n        → Step 8: backtrack(index+1, current) // 不包含元素的分支\n→ Step 9: 開始 backtrack(0, 空陣列) // 初始化遞迴\n→ Step 10: 返回 subsets // 最終結果\nEnd // 程式執行結束\n\nNeed to ensure each line uses 虛擬碼步驟 + [space] + // 解釋. We need to use arrows properly: \"→\". The Decision lines should have indentation? In example they used indentation for sub steps. We need to match the style.\n\nLet's produce. Use \"Decision:\" with arrow? In example they had \"Decision: 如果數字大於 0?\" with indent then Yes →, No →. We'll follow same.\n\nSo lines:\n\nStart // 程式開始執行\n→ Step 1: 輸入整數陣列 nums // 取得輸入\n→ Step 2: 建立空集合 subsets 用於儲存所有子集 // 初始化結果\n→ Step 3: 定義遞迴函式 backtrack(index, current) // 用於生成子集\n    → Decision: index 是否等於 nums 長度? // 判斷是否已遍歷完所有元素\n        Yes → Step 4: 把 current 複製並加入 subsets // 存入完整子集\n        No  → Decision: 是否考慮把 nums[index] 加入子集? // 探索包含或不包含的兩種情況\n            Yes → Step 5: 把 nums[index] 加入 current // 包含當前元素\n            → Step 6: backtrack(index+1, current) // 進行下一層遞迴\n            → Step 7: 移除 nums[index] 從 current // 回溯，撤回元素\n            → Step 8: backtrack(index+1, current) // 進行不包含當前元素的分支\n→ Step 9: 呼叫 backtrack(0, 空陣列) // 開始遞迴\n→ Step 10: 回傳 subsets // 返回所有子集\nEnd // 程式執行結束\n\nWe need to ensure each line includes a space after virtual code step before // comment. We'll output exactly.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入整數陣列 nums // 取得輸入  \n→ Step 2: 建立空集合 subsets 用於儲存所有子集 // 初始化結果  \n→ Step 3: 定義遞迴函式 backtrack(index, current) 用於生成子集 // 遞迴邏輯  \n  → Decision: index 是否等於 nums 長度? // 判斷是否已遍歷完所有元素  \n   Yes → Step 4: 把 current 複製並加入 subsets // 存入完整子集  \n   No  → Decision: 是否考慮把 nums[index] 加入子集? // 探索包含或不包含的兩種情況  \n    Yes → Step 5: 把 nums[index] 加入 current // 包含當前元素  \n     → Step 6: backtrack(index+1, current) // 進行下一層遞迴  \n     → Step 7: 移除 nums[index] 從 current // 回溯，撤回元素  \n     → Step 8: backtrack(index+1, current) // 進行不包含當前元素的分支  \n→ Step 9: 呼叫 backtrack(0, 空陣列) // 開始遞迴  \n→ Step 10: 回傳 subsets // 返回所有子集  \nEnd // 程式執行結束"
    },
    {
      "title": "Range Sum Query - Immutable",
      "source_file": "Leetcode/leetcode303.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"NumArray\", \"sumRange\", \"sumRange\", \"sumRange\"], [[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]",
          "expected_output": "[null, 1, -1, -3]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpnk_881a8.py\", line 58, in <module>\n    main()\n  File \"/tmp/tmpnk_881a8.py\", line 47, in main\n    obj = NumArray(arg)\n          ^^^^^^^^^^^^^\n  File \"/tmp/tmpnk_881a8.py\", line 10, in __init__\n    self.prefix_sums.append(self.prefix_sums[-1] + num)\n                            ~~~~~~~~~~~~~~~~~~~~~^~~~~\nTypeError: unsupported operand type(s) for +: 'int' and 'list'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\n\nclass NumArray:\n    def __init__(self, nums):\n        # 建立前綴和陣列，prefix_sums[i] = sum(nums[0:i])\n        self.prefix_sums = [0]\n        for num in nums:\n            self.prefix_sums.append(self.prefix_sums[-1] + num)\n\n    def sumRange(self, left, right):\n        # sumRange(left, right) = prefix_sums[right+1] - prefix_sums[left]\n        return self.prefix_sums[right + 1] - self.prefix_sums[left]\n\ndef parse_input(data: str):\n    \"\"\"將輸入字串轉成兩個列表 (ops, args)。\"\"\"\n    data = data.strip()\n    # 若有換行，直接分兩行解析\n    if '\\n' in data:\n        lines = data.splitlines()\n        ops = ast.literal_eval(lines[0].strip())\n        args = ast.literal_eval(lines[1].strip())\n        return ops, args\n\n    # 否則兩個列表以 ', ' 分隔\n    first_bracket = data.find(']')\n    if first_bracket == -1:\n        raise ValueError(\"Invalid input format\")\n    ops_str = data[:first_bracket + 1]\n    rest = data[first_bracket + 1:].strip()\n    if rest.startswith(','):\n        rest = rest[1:].strip()\n    args_str = rest\n    ops = ast.literal_eval(ops_str)\n    args = ast.literal_eval(args_str)\n    return ops, args\n\ndef main():\n    raw_input = sys.stdin.read()\n    ops, args_list = parse_input(raw_input)\n\n    results = []\n    obj = None\n    for op, arg in zip(ops, args_list):\n        if op == \"NumArray\":\n            obj = NumArray(arg)\n            results.append(None)           # 代表 null\n        elif op == \"sumRange\":\n            results.append(obj.sumRange(*arg))\n        else:\n            raise ValueError(f\"Unknown operation: {op}\")\n\n    # 輸出時使用 json.dumps 以得到 null 而非 None\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for implementing a NumArray class with sumRange query. Provide line by line with arrow and decision.\n\nWe need to cover initialization with prefix sums, sumRange method computing sum via prefix. Provide explanation per line.\n\nUse Start, End, Decision.\n\nNo actual code.\n\nLet's craft:\n\nStart\n\n→ Step 1: Define class NumArray // Define the class\n\n→ Step 2: Declare array nums // store original array\n\n→ Step 3: Declare array prefix // prefix sum array\n\n→ Step 4: Constructor NumArray(numsInput) // initialize\n\n    → Step 4a: Set nums = numsInput\n\n    → Step 4b: Create prefix of length nums.length + 1\n\n    → Step 4c: prefix[0] = 0 // initial zero\n\n    → Step 4d: For i from 1 to nums.length\n\n        → Step 4d1: prefix[i] = prefix[i-1] + nums[i-1] // build prefix\n\n→ Step 5: Define method sumRange(left, right) // query method\n\n    → Decision: 是否 left <= right? // ensure valid\n\n        Yes → Step 5a: Return prefix[right+1] - prefix[left] // compute sum\n\n        No  → Step 5b: Return 0 // or handle error\n\nEnd\n\nAdd explanations.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類別 NumArray // 建立 NumArray 類別  \n→ Step 2: 宣告變數 nums // 儲存原始數列  \n→ Step 3: 宣告變數 prefix // 儲存前綴和陣列  \n→ Step 4: 建構子 NumArray(numsInput) // 初始化物件  \n    → Step 4a: 把 numsInput 指派給 nums // 保存輸入陣列  \n    → Step 4b: 建立長度為 nums.length + 1 的 prefix 陣列 // 為前綴和留空間  \n    → Step 4c: prefix[0] = 0 // 前綴和的起始值  \n    → Step 4d: 迴圈 i 從 1 到 nums.length  \n        → Step 4d1: prefix[i] = prefix[i-1] + nums[i-1] // 依序累加計算前綴和  \n→ Step 5: 定義方法 sumRange(left, right) // 計算區間和  \n    → Decision: 左右指標是否合法? // 檢查 left <= right  \n        Yes → Step 5a: 回傳 prefix[right+1] - prefix[left] // 使用前綴和快速得到區間和  \n        No  → Step 5b: 回傳 0 // 或可擲回錯誤訊息  \nEnd // 程式執行結束"
    },
    {
      "title": "Different Ways to Add Parentheses",
      "source_file": "Leetcode/leetcode241.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "expression = \"2-1-1\"",
          "expected_output": "[0,2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[0,2]'\nGot (Norm):      '[2,0]'\n--- (Raw) ---\nRaw Expected: '[0,2]'\nRaw Got:      '[2, 0]'"
        },
        {
          "example_index": 1,
          "input": "expression = \"2*3-4*5\"",
          "expected_output": "[-34,-14,-10,-10,10]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[-34,-14,-10,-10,10]'\nGot (Norm):      '[-34,-10,-14,-10,10]'\n--- (Raw) ---\nRaw Expected: '[-34,-14,-10,-10,10]'\nRaw Got:      '[-34, -10, -14, -10, 10]'"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef main() -> None:\n    data = sys.stdin.read()\n    if not data:\n        return\n\n    # 取得表達式文字，支援 \"expression = \\\"2-1-1\\\"\" 或僅有 2-1-1 的情況\n    match = re.search(r'\\\"([^\"]*)\\\"', data)\n    if match:\n        expression = match.group(1)\n    else:\n        expression = data.strip()\n\n    memo = {}\n\n    def ways(expr: str):\n        if expr in memo:\n            return memo[expr]\n\n        results = []\n        for i, ch in enumerate(expr):\n            if ch in '+-*':\n                left = ways(expr[:i])\n                right = ways(expr[i+1:])\n                for l in left:\n                    for r in right:\n                        if ch == '+':\n                            results.append(l + r)\n                        elif ch == '-':\n                            results.append(l - r)\n                        else:  # '*'\n                            results.append(l * r)\n\n        # 如果沒有發現運算符，直接把整個字串當成數字\n        if not results:\n            results.append(int(expr))\n\n        memo[expr] = results\n        return results\n\n    output = ways(expression)\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code that describes algorithm. The problem: Given string expression of numbers and operators, return all possible results from computing all different ways to group numbers and operators. Essentially \"Different Ways to Add Parentheses\" Leetcode 241. We need to produce virtual code steps.\n\nWe need to use Start, End, Decision, etc. The algorithm: recursively split expression at each operator, compute left and right results, combine. Use memoization to avoid recomputation.\n\nSo we produce lines like:\n\nStart // 程式開始\n\n→ Step 1: 定義遞迴函式 compute(expression) // 函式用於計算子表達式\n\n→ Decision: 是否已經在 memo 中? // 檢查結果是否已計算\n\n...\n\nWill produce all steps.\n\nLet's produce a fairly detailed but not too long algorithm: includes base case when expression is number, parse integer, return list with that number. Recursively for each operator, split left, right, compute leftResults, rightResults, combine results via operator.\n\nAlso store memoization: key expression -> result list.\n\nAlso top-level function to call compute on whole expression and return list.\n\nLet's produce lines.\n\nAlso may include example of stack.\n\nBut produce virtual steps only.\n\nMake sure to use arrow `→` before each step. Indent decisions properly. Use `Yes →`, `No →` etc.\n\nLet's produce around 30 lines.\n\nWe'll start.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 memo = {} // 用於記錄已計算子表達式的結果  \n→ Step 2: 定義遞迴函式 compute(expr) // 計算 expr 的所有可能結果  \n→     Decision: memo 是否已經包含 expr? // 檢查是否已有答案  \n→         Yes → Step 3: return memo[expr] // 直接回傳已存在的結果  \n→         No → Step 4: 初始化 results = [] // 存儲本次 expr 的所有結果  \n→     Decision: expr 是否只含數字? // 判斷是否到達最簡情況  \n→         Yes → Step 5: results ← [int(expr)] // 解析並存入單一結果  \n→         No → Step 6: 遍歷 expr 中每個字符 i  \n→             Decision: expr[i] 是否是運算符 (+,-,*)? // 判斷是否為分割點  \n→                 Yes → Step 7: left = expr[0:i] // 左子表達式  \n→                 Step 8: right = expr[i+1:] // 右子表達式  \n→                 Step 9: leftResults = compute(left) // 計算左子結果  \n→                 Step 10: rightResults = compute(right) // 計算右子結果  \n→                 Step 11: for每個 l in leftResults  \n→                 → Step 12: for每個 r in rightResults  \n→                 →     Step 13: 結合 l, r, expr[i] 根據運算符計算值 → result  \n→                 →     Step 14: results ← results ∪ {result} // 加入計算結果  \n→     Step 15: memo[expr] ← results // 記錄本次 expr 的所有結果  \n→     Step 16: return results // 回傳結果列表  \n→ Step 17: 定義 main(expr)  \n→     → Step 18: return compute(expr) // 取得整個表達式的所有結果  \nEnd // 程式執行結束"
    },
    {
      "title": "Basic Calculator",
      "source_file": "Leetcode/leetcode224.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 2,
          "input": "s = \"(1+(4+5+2)-3)+(6+8)\"",
          "expected_output": "23",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp0sm8yp6c.py\", line 92, in <module>\n    main()\n  File \"/tmp/tmp0sm8yp6c.py\", line 87, in main\n    result = calculate(expr)\n             ^^^^^^^^^^^^^^^\n  File \"/tmp/tmp0sm8yp6c.py\", line 54, in calculate\n    apply_op(ops, vals)\n  File \"/tmp/tmp0sm8yp6c.py\", line 22, in apply_op\n    left = vals.pop()\n           ^^^^^^^^^^\nIndexError: pop from empty list"
        }
      ],
      "generated_code": "import sys\n\ndef calculate(s: str) -> int:\n    \"\"\"Evaluate a mathematical expression containing +, -, *, / and parentheses.\"\"\"\n    s = s.strip()\n    # Handle unary minus by inserting 0 before it\n    if s.startswith('-'):\n        s = '0' + s\n    s = s.replace('(-', '(0-')\n    s = s.replace(' ', '')  # remove all spaces for easier parsing\n\n    def precedence(op: str) -> int:\n        if op in '+-':\n            return 1\n        if op in '*/':\n            return 2\n        return 0\n\n    def apply_op(ops: list[str], vals: list[int]) -> None:\n        op = ops.pop()\n        right = vals.pop()\n        left = vals.pop()\n        if op == '+':\n            vals.append(left + right)\n        elif op == '-':\n            vals.append(left - right)\n        elif op == '*':\n            vals.append(left * right)\n        elif op == '/':\n            # Python's int division truncates toward zero when using int()\n            vals.append(int(left / right))\n\n    ops: list[str] = []\n    vals: list[int] = []\n    num = 0\n    i = 0\n    n = len(s)\n\n    while i < n:\n        ch = s[i]\n        if ch.isdigit():\n            num = num * 10 + int(ch)\n            i += 1\n            continue\n\n        if ch == '(':\n            ops.append(ch)\n            i += 1\n            continue\n\n        if ch == ')':\n            # Resolve until matching '('\n            while ops and ops[-1] != '(':\n                apply_op(ops, vals)\n            ops.pop()  # pop '('\n            i += 1\n            continue\n\n        # Operator encountered: push the current number first\n        vals.append(num)\n        num = 0\n\n        # Resolve operators with higher or equal precedence\n        while ops and ops[-1] != '(' and precedence(ops[-1]) >= precedence(ch):\n            apply_op(ops, vals)\n        ops.append(ch)\n        i += 1\n\n    # Push the last number\n    vals.append(num)\n    while ops:\n        apply_op(ops, vals)\n\n    return vals[0]\n\n\ndef main() -> None:\n    data = sys.stdin.read()\n    # Extract the expression inside quotes if present\n    start = data.find('\"')\n    end = data.rfind('\"')\n    if start != -1 and end != -1 and end > start:\n        expr = data[start + 1:end]\n    else:\n        # Fallback: use the raw input stripped of whitespace\n        expr = data.strip()\n    result = calculate(expr)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for a basic calculator evaluating a string expression, no eval. Use stacks, parse digits, handle +,-,*,/. Also parentheses. We'll produce pseudocode with steps. Each line: \"虛擬碼步驟 // 解釋\". Use arrows.\n\nLet's design:\n\nStart\n→ Initialize stack, current number, sign\n→ Iterate over characters with index i\n   → If digit: build number\n   → If '+': push sign * number onto stack; set sign=1; number=0\n   → If '-': push sign * number; set sign=-1; number=0\n   → If '*': push sign * number; set sign=0? Actually need to handle multiplication: store previous number. But simpler: use stack to hold numbers, and handle operator precedence. Alternative approach: Use two stacks: values and ops. Or use current result and previous number approach: For + and -, we push previous result and update result. For *, /, we compute with top of stack. Implementation: maintain stack. When encountering + or -, push sign*number, set sign accordingly. For * and /, we need to apply to last number on stack: pop stack, compute, push back.\n\nSo steps: When encountering *: pop top, multiply by current number, push result. Similarly /: integer division. Need to handle division truncation.\n\nAlso parentheses: when '(', push current result and sign onto stack? Or use recursion? We'll use stack for values and signs: Use stack for results and signs? Standard approach: use stack for previous result and sign before parentheses. When encountering '(', push current result and sign onto stack, reset result=0, sign=1. When encountering ')', multiply current result by sign from stack? Actually algorithm: use stack for previous result and sign. Implementation: When '(' occurs: push result onto stack, push sign onto stack. reset result=0, sign=1. When ')' occurs: multiply result by sign popped from stack? Actually standard: result = result * sign? Let's recall: For expression with +,- only, we can push (result) and sign onto stack. But with * and / we need stack for values. Simpler: Use stack for numbers and use algorithm: When encountering + or -, push sign * number, set sign. When encountering * or /, pop top, compute with number, push back. For parentheses, we need to evaluate inside parentheses and treat as a number. Approach: When '(' encountered, recursively evaluate substring? But we want iterative.\n\nAlternative: Use two stacks: values and ops. We'll parse and use precedence: if char is digit accumulate number; if operator: while stack top has higher or equal precedence, evaluate. Push operator. If '(' push; if ')' pop until '('.\n\nGiven requirement of pseudocode, we can outline these steps.\n\nLet's produce pseudocode:\n\nStart\n→ Initialize stackOps, stackVals, num=0, i=0\n→ While i < len(s)\n    → If s[i] is digit: build num = num*10 + int(s[i]) ; i++ ; continue\n    → If s[i] is space: i++ ; continue\n    → If s[i] is '(' : push '(' onto stackOps ; i++ ; continue\n    → If s[i] is ')' : while top of stackOps != '(' : applyOp(); pop '(' ; i++ ; continue\n    → Operator encountered: currentOp = s[i]\n        → While stackOps not empty and precedence(stackOps.top) >= precedence(currentOp) and stackOps.top != '('\n            → applyOp()\n        → push currentOp onto stackOps\n        → i++ ; continue\n→ After loop: while stackOps not empty: applyOp()\n→ Result = stackVals.top; End\n\napplyOp():\n    → op = stackOps.pop()\n    → right = stackVals.pop()\n    → left = stackVals.pop()\n    → compute result based on op\n    → push result onto stackVals\n\npredecessence mapping: '+','-' = 1; '*','/' = 2\n\nNeed to handle integer division truncating toward zero.\n\nAlso handle negative numbers: with unary minus at start or after '('? Our algorithm may not support unary. But we can treat as 0-.\n\nSimplify: We'll assume expression may have unary minus. Use flag.\n\nBut for pseudocode, we can outline.\n\nLet's produce step by step with explanation.\n\nMake sure to produce each line with arrow and comment.\n\nWe'll produce \"Start // 開始\" etc.\n\nLet's produce about 40 lines.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ 初始化 stackOps = []，stackVals = []，num = 0，i = 0 // 準備空堆疊與索引變數\n→ Decision: 若 i < len(s) ? // 是否還有字元要處理\n    Yes → Decision: 若 s[i] 為數字 ? // 解析連續數字\n        Yes → Step: num = num * 10 + int(s[i]) // 累積整數\n               i += 1 // 移至下一個字元\n               再次判斷 // 進入下一個字元判斷\n        No → Decision: 若 s[i] 為空白 ? // 跳過空白\n            Yes → i += 1 // 跳過空白並繼續\n            No → Decision: 若 s[i] 為 '(' ? // 開啟括號\n                Yes → stackOps.push('(') // 把 '(' 入堆疊\n                       i += 1 // 移至下一個字元\n                No → Decision: 若 s[i] 為 ')' ? // 關閉括號\n                    Yes → Decision: stackOps.top == '(' ? // 確認括號匹配\n                            Yes → stackOps.pop() // 移除 '('\n                                   i += 1 // 移至下一個字元\n                            No  → Decision: 若 stackOps.top 優先級 >= 1 ? // 先算完內部\n                                    Yes → applyOp() // 執行一次運算\n                                    從上再次判斷 stackOps.top == '('\n                                    No  → stackOps.pop() // 移除 '('\n                                           i += 1\n                    No  → Decision: 若 s[i] 為運算符號 +,-,*,/ ? // 處理運算符\n                        Yes → currentOp = s[i]\n                              // 在堆疊中把優先級較高或相同的運算符先算完\n                              → Decision: stackOps 不是空且 priority(stackOps.top) >= priority(currentOp) 且 stackOps.top != '(' ?\n                                  Yes → applyOp() // 執行一次運算\n                                  再次判斷\n                                  No  → stackOps.push(currentOp) // 把目前運算符入堆疊\n                                       i += 1 // 移至下一個字元\n                        No  → Error // 不是已知字元，略過\n\n→ Decision: i < len(s) ? // 結束判斷循環\n    No → // 所有字元已處理\n→ Decision: stackOps 不是空 ? // 清理剩餘運算符\n    Yes → applyOp()\n    No  → // 目前已無運算符\n→ Result = stackVals.pop() // 最終結果從值堆疊中取出\nEnd // 程式執行結束\n\n// ---------------\n// applyOp() // 執行一次堆疊運算\n→ op = stackOps.pop() // 取出運算符\n→ right = stackVals.pop() // 右邊操作數\n→ left = stackVals.pop() // 左邊操作數\n→ Decision: op 為 '+' ?\n    Yes → stackVals.push(left + right) // 加法\n    No → Decision: op 為 '-' ?\n        Yes → stackVals.push(left - right) // 減法\n        No → Decision: op 為 '*' ?\n            Yes → stackVals.push(left * right) // 乘法\n            No → // op 為 '/'\n                → result = int(left / right) // 除法，向零截斷\n                stackVals.push(result)\n\n// priority(op) // 獲取運算符優先級\n→ Decision: op 為 '+' 或 '-' ?\n    Yes → return 1\n    No → return 2 // '*' 或 '/' 優先級更高\n\n// int(x) // 轉為整數，向零截斷（Python 3 的 int() 會這樣）  \n→ return int(x) // 直接使用語言內建整數轉換"
    },
    {
      "title": "Course Schedule",
      "source_file": "Leetcode/leetcode207.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "numCourses = 2, prerequisites = [[1,0]]",
          "expected_output": "true",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp24hetaxh.py\", line 48, in parse_input\n    data[key] = ast.literal_eval(val)\n                ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[1\n     ^\nSyntaxError: '[' was never closed\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/tmp24hetaxh.py\", line 58, in <module>\n    numCourses, prerequisites = parse_input(raw)\n                                ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp24hetaxh.py\", line 51, in parse_input\n    data[key] = int(val)\n                ^^^^^^^^\nValueError: invalid literal for int() with base 10: '[[1'"
        },
        {
          "example_index": 1,
          "input": "numCourses = 2, prerequisites = [[1,0],[0,1]]",
          "expected_output": "false",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp4l0qvbkh.py\", line 48, in parse_input\n    data[key] = ast.literal_eval(val)\n                ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[1\n     ^\nSyntaxError: '[' was never closed\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/tmp4l0qvbkh.py\", line 58, in <module>\n    numCourses, prerequisites = parse_input(raw)\n                                ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp4l0qvbkh.py\", line 51, in parse_input\n    data[key] = int(val)\n                ^^^^^^^^\nValueError: invalid literal for int() with base 10: '[[1'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import deque\n\nclass Solution:\n    def canFinish(self, numCourses, prerequisites):\n        # 建立鄰接表與入度表\n        graph = [[] for _ in range(numCourses)]\n        indegree = [0] * numCourses\n\n        # 填寫圖結構\n        for dest, src in prerequisites:\n            graph[src].append(dest)\n            indegree[dest] += 1\n\n        # 將所有入度為 0 的課程加入佇列\n        queue = deque([i for i in range(numCourses) if indegree[i] == 0])\n        visited = 0\n\n        # 進行拓樸排序\n        while queue:\n            node = queue.popleft()\n            visited += 1\n            for neighbor in graph[node]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    queue.append(neighbor)\n\n        return visited == numCourses\n\ndef parse_input(text):\n    \"\"\"\n    將輸入字串轉換成 numCourses 與 prerequisites。\n    支援 'numCourses = 2, prerequisites = [[1,0]]'、換行分隔或空白分隔的格式。\n    \"\"\"\n    parts = re.split(r',\\s*|\\n', text.strip())\n    data = {}\n    for part in parts:\n        if not part:\n            continue\n        if '=' not in part:\n            continue\n        key, val = part.split('=', 1)\n        key = key.strip()\n        val = val.strip()\n        try:\n            data[key] = ast.literal_eval(val)\n        except Exception:\n            # 若 eval 失敗則直接轉成 int\n            data[key] = int(val)\n    return data.get('numCourses'), data.get('prerequisites', [])\n\nif __name__ == \"__main__\":\n    raw = sys.stdin.read()\n    if not raw.strip():\n        sys.exit()\n    numCourses, prerequisites = parse_input(raw)\n\n    solution = Solution()\n    result = solution.canFinish(numCourses, prerequisites)\n    print('true' if result else 'false')",
      "virtual_code": "Thinking...\nThe user wants virtual code for checking if all courses can be finished given prerequisites. This is the classic Course Schedule problem: detect cycle in directed graph. We need to produce virtual code with arrows and explanations, line by line, no actual code. Steps: Start, Build adjacency list, in-degree array, queue for zero indegree, count visited, while queue not empty: pop, increase count, for neighbors decrease indegree, if becomes zero add to queue. At end if count == numCourses return true else false. Also maybe handle decision.\n\nWe'll produce lines like:\n\nStart // 程式開始\n→ Step 1: 初始化鄰接表與入度陣列 // 建立圖結構\n→ Step 2: 迭代 prerequisites 填充圖 // 設定邊\n→ Step 3: 建立空隊列 queue // 用於存儲入度為0的節點\n→ Step 4: 將所有入度為0的課程加入 queue // 初始可選課程\n→ Step 5: 設置已完成課程計數 count = 0 // 追蹤已處理節點\n→ Decision: queue 是否為空? // 判斷是否還有可進行的課程\n    Yes → Step 6: 取出一個課程 curr 從 queue // 選擇下一個要完成的課程\n    Yes → Step 7: count++ // 標記該課程已完成\n    Yes → 迭代 curr 的所有相鄰課程 next\n        → Step 8: 將 next 的入度減 1 // 代表一個前置課程已完成\n        → Decision: next 的入度是否為 0? // 新的可完成課程\n            Yes → Step 9: 將 next 加入 queue // 將新的可選課程加入\n    Yes → Go back to Decision: queue 是否為空?\n    No → Decision: count 是否等於 numCourses? // 判斷是否所有課程都完成\n        Yes → Step 10: 返回 true // 可以完成所有課程\n        No → Step 11: 返回 false // 仍有課程無法完成\nEnd // 程式執行結束\n\nWe need to ensure format exactly: \"虛擬碼步驟\" + space + \"// 解釋/說明\". Also use arrows like \"→\", \"Yes →\", \"No →\" indentations. Ensure each line is one virtual code step. The decisions have nested lines, but still one line per step. Might need to indent under Decision. We'll follow example format.\n\nThus produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化鄰接表 graph 以及入度陣列 indegree // 建立圖結構  \n→ Step 2: 迭代 prerequisites，對每個 [a, b]，將 a 加入 graph[b]，並將 indegree[a] 加 1 // 填寫邊與入度  \n→ Step 3: 建立空隊列 queue // 用來儲存入度為 0 的節點  \n→ Step 4: 將所有 indegree 為 0 的課程加入 queue // 初始可選課程  \n→ Step 5: 設置已完成課程計數 count = 0 // 追蹤已處理節點  \n→ Decision: queue 是否為空? // 判斷是否還有可進行的課程  \n Yes → Step 6: 取出一個課程 curr 從 queue // 選擇下一個要完成的課程  \n Yes → Step 7: count++ // 標記該課程已完成  \n Yes → 迭代 curr 的所有相鄰課程 next  \n  → Step 8: 將 next 的 indegree 減 1 // 代表一個前置課程已完成  \n  → Decision: next 的 indegree 是否為 0? // 新的可完成課程  \n   Yes → Step 9: 將 next 加入 queue // 將新的可選課程加入  \n   No  → // 不做任何事  \n  → // 迭代結束  \n  → // 回到 Decision: queue 是否為空?  \n No → Decision: count 是否等於 numCourses? // 判斷是否所有課程都完成  \n  Yes → Step 10: 返回 true // 可以完成所有課程  \n  No → Step 11: 返回 false // 仍有課程無法完成  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick with Weight",
      "source_file": "Leetcode/leetcode528.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"], [[[1,3]],[],[],[],[],[]]",
          "expected_output": "[null,1,1,1,1,0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,1,1,1,1,0]'\nGot (Norm):      '[null,0,0,1,1,1]'\n--- (Raw) ---\nRaw Expected: '[null,1,1,1,1,0]'\nRaw Got:      '[null, 0, 0, 1, 1, 1]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\nimport bisect\nimport json\n\nclass Solution:\n    def __init__(self, w):\n        self.prefix_sum = []\n        total = 0\n        for weight in w:\n            total += weight\n            self.prefix_sum.append(total)\n        self.total = total\n\n    def pickIndex(self):\n        target = random.randint(1, self.total)\n        return bisect.bisect_left(self.prefix_sum, target)\n\ndef main():\n    data_str = sys.stdin.read().strip()\n    if not data_str:\n        return\n    # Wrap the input into a tuple literal so we can parse it safely\n    methods, args_list = ast.literal_eval('(' + data_str + ')')\n    results = []\n    obj = None\n    for method, args in zip(methods, args_list):\n        if method == \"Solution\":\n            # Constructor\n            obj = Solution(*args)\n            results.append(None)\n        elif method == \"pickIndex\":\n            results.append(obj.pickIndex())\n    # Convert Python None to JSON null\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps for implementing pickIndex, given array w of positive ints. Need to generate virtual code line by line, with explanations. Likely steps: build prefix sum array, total weight, random number between 1 and total, binary search to find index. The pseudocode should use arrow, decisions, etc.\n\nMake sure each line has \"虛擬碼步驟\" and then \" // 解釋\". Use Start, End.\n\nWe need to produce the code that outlines constructor and pickIndex. Provide pseudocode lines for building prefix sum, random selection, binary search.\n\nWe need to ensure each line is one step. Might need indentation? Not required.\n\nLet's produce:\n\nStart\n→ Step 1: Build prefix sum array pre where pre[i] = sum of w[0..i] // Compute cumulative weights\n→ Step 2: Let total = pre[w.length-1] // Total weight\n→ Step 3: Initialize random number generator // Prepare RNG\n→ Step 4: Function pickIndex() begin // Define method\n    → Step 4.1: Generate r = random integer between 1 and total inclusive // Random weight selection\n    → Decision: Find smallest index i such that pre[i] >= r // Locate index via binary search\n        Yes → Step 4.2: Return i // Index found\n    → End of Function\nEnd\n\nBut we need each line as single statement. Might need to separate the binary search decision into steps.\n\nLet's do:\n\nStart\n→ Step 1: pre ← new array of size w.length // Prefix sum array\n→ Step 2: cumulative ← 0 // Running total\n→ Step 3: For i from 0 to w.length-1\n    → Step 3.1: cumulative ← cumulative + w[i] // Add current weight\n    → Step 3.2: pre[i] ← cumulative // Store prefix sum\n→ Step 4: total ← cumulative // Total weight\n→ Step 5: rng ← new random number generator // RNG setup\n→ Step 6: Function pickIndex() begin\n    → Step 6.1: r ← rng.randomInt(1, total) // Random number in [1,total]\n    → Step 6.2: low ← 0 // Binary search low bound\n    → Step 6.3: high ← pre.length - 1 // Binary search high bound\n    → Decision: while low <= high\n        → Step 6.3.1: mid ← (low + high) // 2 // Midpoint\n        → Decision: if pre[mid] < r\n            Yes → Step 6.3.1.1: low ← mid + 1 // Move low up\n            No → Step 6.3.1.2: high ← mid - 1 // Move high down\n    → Step 6.4: Return low // low is the index where pre[low] >= r\n    → End\nEnd\n\nWe need arrow for decision loops.\n\nBut we might need to specify loop using Decision: while? The example only uses Decision: for if, but we can use Decision: while? Might just use Decision: low <= high? Actually we can incorporate a loop as Decision.\n\nSimplify: Use Decision: if pre[mid] < r? Yes → low=mid+1 No → high=mid-1. Then after loop ends return low.\n\nAlternatively we can avoid loop and just use binary search function findIndex. But we need to show steps.\n\nWe'll output accordingly.\n\nMake sure each line ends with // 解釋.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: pre ← new array of size w.length // 建立前綴和陣列  \n→ Step 2: cumulative ← 0 // 用來累加權重  \n→ Step 3: For i from 0 to w.length-1  \n    → Step 3.1: cumulative ← cumulative + w[i] // 把目前權重加入累計  \n    → Step 3.2: pre[i] ← cumulative // 將累計值存入前綴和陣列  \n→ Step 4: total ← cumulative // 整體權重總和  \n→ Step 5: rng ← new random number generator // 準備隨機數產生器  \n→ Step 6: Function pickIndex() begin // 定義隨機挑選方法  \n    → Step 6.1: r ← rng.randomInt(1, total) // 產生 1 到 total 之間的隨機整數  \n    → Step 6.2: low ← 0 // 二分搜尋左邊界  \n    → Step 6.3: high ← pre.length - 1 // 二分搜尋右邊界  \n    → Decision: low ≤ high? // 進行二分搜尋  \n        Yes → Step 6.4: mid ← (low + high) // 2 // 計算中間位置  \n            → Decision: pre[mid] < r? // 比較前綴和與隨機數  \n                Yes → Step 6.5: low ← mid + 1 // 若前綴和小於 r，左移左邊界  \n                No  → Step 6.6: high ← mid - 1 // 若前綴和大於等於 r，右移右邊界  \n        No  → // 搜尋結束  \n    → Step 6.7: Return low // low 為符合條件的最小索引  \n    → End // 函式結束  \nEnd // 程式執行結束"
    },
    {
      "title": "H-Index II",
      "source_file": "Leetcode/leetcode275.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "citations = [0,1,3,5,6]",
          "expected_output": "3",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '3'\nGot (Norm):      '0'\n--- (Raw) ---\nRaw Expected: '3'\nRaw Got:      '0'"
        },
        {
          "example_index": 1,
          "input": "citations = [1,2,100]",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '0'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '0'"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def hIndex(self, citations):\n        n = len(citations)\n        left, right = 0, n - 1\n        while left <= right:\n            mid = (left + right) // 2\n            # number of papers with at least citations[mid] citations is n - mid\n            if citations[mid] >= n - mid:\n                # this mid satisfies the condition, try to find a larger h\n                left = mid + 1\n            else:\n                right = mid - 1\n        # left is the smallest index where citations[left] < n - left,\n        # so the h-index is n - left\n        return n - left\n\ndef parse_input(data: str):\n    \"\"\"\n    Parse input of the form: 'citations = [0,1,3,5,6]'\n    \"\"\"\n    # Find the first '[' and the last ']' to extract the list part\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1 or start > end:\n        return []\n    list_str = data[start+1:end].strip()\n    if not list_str:\n        return []\n    # Split by commas and convert to integers\n    return [int(x.strip()) for x in list_str.split(',')]\n\ndef main():\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n    citations = parse_input(raw)\n    sol = Solution()\n    result = sol.hIndex(citations)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code for algorithm to compute h-index given sorted citations array, O(log n). Use binary search. Steps: start, n = len, low=0, high=n-1, ans=0. While low <= high: mid = (low+high)//2. if citations[mid] >= n-mid: ans = n-mid; low=mid+1 else high=mid-1. End. Return ans.\n\nBut the problem states citations sorted in non-descending order (ascending). We can use binary search to find leftmost index where citations[i] >= n-i. That gives h = n-i. We'll produce step-by-step virtual code.\n\nUse decision nodes.\n\nLet's produce virtual code lines accordingly.\n\nMake sure each line has virtual code step and comment.\n\nWe'll use Start, End. Use arrow.\n\nLet's produce.\n\nAlso maybe initial steps: Start, Step 1: Let n = length of citations.\n\nStep 2: low = 0, high = n-1, ans = 0.\n\nDecision: while low <= high?\n\nWe'll produce loop.\n\nWe'll use Decision: low <= high? Yes→ compute mid, else → End loop.\n\nWithin loop, compute mid, then Decision: citations[mid] >= n - mid?\n\nIf Yes: ans = n-mid; low = mid+1.\n\nIf No: high = mid-1.\n\nAfter loop, Step: Return ans.\n\nEnd.\n\nLet's produce.\n\nMake sure each line has arrow '→' to next line. Provide comments.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: let n = length(citations) // 取得資料長度  \n→ Step 2: low = 0, high = n - 1, ans = 0 // 初始化搜尋範圍與答案  \n\n→ Decision: low ≤ high? // 判斷是否還有區間可以搜尋  \n    Yes → Step 3: mid = (low + high) // 2 // 找中間索引  \n    → Decision: citations[mid] ≥ n - mid? // 判斷中點是否滿足 h-index 條件  \n        Yes → Step 4: ans = n - mid // 更新可能的 h-index  \n        → Step 5: low = mid + 1 // 搜尋右半邊以尋找更大的 h-index  \n        No  → Step 6: high = mid - 1 // 搜尋左半邊以尋找更小的索引  \n    No → Step 7: Return ans // 迴圈結束，輸出最終 h-index  \n\nEnd // 程式執行結束"
    }
  ]
}