{
  "run_index": 30,
  "total_files_found": 391,
  "total_files_processed": 323,
  "files_skipped": 68,
  "files_failed_load": 0,
  "---": "--- (以下基於 *題目* 總數) ---",
  "total_problems_attempted": 334,
  "generation_and_validation_success_count": 298,
  "generation_or_validation_failure_count": 36,
  "failed_cases_details": [
    {
      "title": "統計文字行數",
      "source_file": "900.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "（假設 data.txt 內容如下）\\nHello\\nPython\\nWorld",
          "expected_output": "檔案共有 3 行",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '檔案共有3行'\nGot (Norm):      '檔案共有1行'\n--- (Raw) ---\nRaw Expected: '檔案共有 3 行'\nRaw Got:      '檔案共有 1 行'"
        }
      ],
      "generated_code": "import sys\n\ndef main():\n    # 讀取標準輸入的所有內容（如果有）並忽略，滿足「從 stdin 讀取」的要求\n    sys.stdin.read()\n\n    try:\n        with open('data.txt', 'r', encoding='utf-8') as f:\n            lines = f.readlines()\n            print(f'檔案共有 {len(lines)} 行')\n    except FileNotFoundError:\n        print('找不到檔案！')\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line with explanation, using arrows and decision structure, and using Start, End, etc. We need to incorporate try/except and with. Virtual code. Should not output actual code, but pseudo steps. Use virtual code arrow.\n\nLet's produce steps:\n\nStart\n→ Step 1: 定義檔名為 \"data.txt\" // 設定要開啟的檔案名\n→ Step 2: 嘗試執行以下區塊 // 進入 try 區\n    → Decision: 檔案是否存在? // 由 try 的 FileNotFoundError 來捕捉\n        Yes → Step 3: 使用 with open(檔名, 'r') 作為 file // 開啟檔案\n        No  → Step 4: 輸出 '找不到檔案！' // 檔案不存在\n→ Decision: 讀取檔案是否成功? // try 區成功執行\n    Yes → Step 5: 計算 file.readlines() 的長度並存為 line_count // 取得行數\n    → Step 6: 輸出 '總行數: ' + line_count // 顯示行數\n→ Decision: try 區內發生 FileNotFoundError? // except 區\n    Yes → Step 7: 輸出 '找不到檔案！' // 顯示錯誤訊息\nEnd\n\nBut we need to maintain arrow structure. Let's produce like:\n\nStart // 程式開始執行\n→ Step 1: 定義變數 file_path = 'data.txt' // 設定檔案路徑\n→ Step 2: try // 開始 try 區塊\n    → Decision: 是否成功進入 try? // 若檔案存在則進入\n        Yes → Step 3: with open(file_path, 'r') as file // 使用 with 開啟檔案\n        No  → Step 4: // 不進入 with\n→ Step 5: // 讀取檔案內容並計算行數\n    → Decision: 是否捕獲 FileNotFoundError? // except 區塊\n        Yes → Step 6: 輸出 '找不到檔案！' // 顯示錯誤訊息\n        No  → Step 7: line_count = len(file.readlines()) // 計算行數\n        → Step 8: 輸出 '總行數: ' + line_count // 顯示結果\nEnd // 程式結束\n\nBut we need to follow arrow style: Decision lines have indentation. Provide \"Yes →\" and \"No →\".\n\nLet's create final structured pseudo-code:\n\nStart // 程式開始\n→ Step 1: 設定 file_path = 'data.txt' // 準備檔名\n→ Decision: 進入 try? // 進入 try 區塊\n    Yes → Step 2: try // 開始 try\n        → Step 3: with open(file_path, 'r') as file // 用 with 開啟檔案\n        → Step 4: line_count = len(file.readlines()) // 讀取所有行並計算\n        → Step 5: print('總行數: ' + str(line_count)) // 輸出行數\n        → Step 6: End // try 結束\n    No  → Decision: 是否拋出 FileNotFoundError? // 進入 except\n        Yes → Step 7: print('找不到檔案！') // 顯示錯誤訊息\n        No  → End // 其他異常不處理\nEnd // 程式結束\n\nBut we need proper indentation. Maybe better:\n\nStart // 程式開始\n→ Step 1: 定義 file_path = 'data.txt' // 設定檔案名稱\n→ Step 2: try // 開始 try 區塊\n    → Step 3: with open(file_path, 'r') as file // 用 with 開啟檔案\n    → Step 4: line_count = len(file.readlines()) // 讀取行數\n    → Step 5: print('總行數: ' + str(line_count)) // 顯示行數\n→ Step 6: except FileNotFoundError: // 捕捉檔案不存在\n    → Step 7: print('找不到檔案！') // 顯示錯誤訊息\nEnd // 程式結束\n\nBut we need to show decision nodes? The requirement: use Decision: arrow etc. But it's optional? It says \"使用虛擬碼的箭頭 (→, Yes →, No →) 和結構 (Start, End, Decision:).\" So we should include Decision nodes to show branching, though the above pseudo-code can use try/except as decision. But we can still incorporate decision nodes to illustrate.\n\nLet's produce:\n\nStart // 程式開始\n→ Step 1: 設定 file_path = 'data.txt' // 定義檔案名稱\n→ Decision: 試圖開啟檔案? // 進入 try 區塊\n    Yes → Step 2: try // 嘗試開啟檔案\n        → Step 3: with open(file_path, 'r') as file // 使用 with 開啟\n        → Step 4: line_count = len(file.readlines()) // 計算行數\n        → Step 5: print('總行數: ' + str(line_count)) // 輸出結果\n        → Step 6: End // try 成功結束\n    No  → Decision: 是否捕捉到 FileNotFoundError? // 進入 except\n        Yes → Step 7: print('找不到檔案！') // 顯示錯誤訊息\n        No  → End // 其他錯誤不處理\nEnd // 程式結束\n\nBut note: after try block we need except block. We can show as \"Decision: 是否捕捉到 FileNotFoundError?\" but that is not typical. Perhaps simpler: Use Decision at start: if file exists? But we cannot check existence easily. But we can treat try/except as Decision.\n\nLet's produce final pseudo code with appropriate arrows and indentation.\n\nWe need to maintain \"虛擬碼步驟 [space] // 解釋\". Use the format \"Start // 程式開始執行\" then \"→ Step 1: ...\" etc.\n\nThus final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 file_path = 'data.txt' // 定義要開啟的檔案名稱  \n→ Decision: 進入 try 區塊? // 試圖開啟檔案，可能會拋出例外  \n  Yes → Step 2: try // 嘗試執行下列程式碼  \n    → Step 3: with open(file_path, 'r') as file // 使用 with 語法安全開啟檔案  \n    → Step 4: line_count = len(file.readlines()) // 讀取所有行並計算行數  \n    → Step 5: print('總行數: ' + str(line_count)) // 顯示總行數  \n    → Step 6: End // try 區塊正常結束  \n  No  → Decision: 是否捕捉到 FileNotFoundError? // 進入 except 區塊  \n    Yes → Step 7: print('找不到檔案！') // 顯示錯誤訊息  \n    No  → End // 其他未處理的例外不在此範例中處理  \nEnd // 程式執行結束"
    },
    {
      "title": "模擬擲骰子遊戲",
      "source_file": "800.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "print(roll_dice(5))",
          "expected_output": "[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,6,1,4,2]#(結果會隨機，每次可能不同)'\nGot (Norm):      '[5,2,4,4,3]'\n--- (Raw) ---\nRaw Expected: '[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)'\nRaw Got:      '[5, 2, 4, 4, 3]'"
        }
      ],
      "generated_code": "import random\nimport sys\n\ndef roll_dice(n):\n    \"\"\"\n    擲 n 次六面骰子，回傳所有結果的列表。\n    \"\"\"\n    results = []\n    for _ in range(n):\n        results.append(random.randint(1, 6))\n    return results\n\nif __name__ == \"__main__\":\n    # 讀取標準輸入的所有內容並執行\n    # 這樣可以處理像「print(roll_dice(5))」這樣的輸入\n    code = sys.stdin.read()\n    exec(code, globals())",
      "virtual_code": "Thinking...\nWe need to output pseudo-code line by line with comments. We must use virtual code with arrows. We'll need to include import random. Steps: Define function roll_dice(n). Inside: create empty list results. Loop i from 1 to n: generate random.randint(1,6) and append. Return results. End function. Start/End? The example uses Start and End for the entire program. We'll produce pseudo-code:\n\nStart // 程式開始\n→ Import random module // 載入隨機模組\n→ Define function roll_dice(n) // 定義擲骰函式\n    → Step 1: results ← [] // 初始化結果串列\n    → Step 2: For i from 1 to n: // 迭代擲骰\n        → Step 3: roll ← random.randint(1,6) // 產生 1-6 的隨機數\n        → Step 4: Append roll to results // 存儲結果\n    → Step 5: Return results // 回傳所有結果\nEnd // 程式結束\n\nBut we need to use virtual code arrows. Example uses → Step 1: etc. Also Decision lines not needed.\n\nMake sure each line has a single arrow and comment. Use spaces between code and comment. Let's produce:\n\nStart // 程式開始執行\n→ Import random // 載入 random 模組\n→ Define function roll_dice(n) // 定義 roll_dice 函式\n    → Step 1: results ← [] // 初始化空串列\n    → Step 2: For i in range(1, n+1): // 迭代 n 次\n        → Step 3: roll ← random.randint(1, 6) // 產生 1~6 的隨機數\n        → Step 4: Append roll to results // 加入結果串列\n    → Step 5: Return results // 回傳結果串列\nEnd // 程式結束\n\nWe should maintain indentation? In pseudo code it's okay.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Import random // 載入 random 模組  \n→ Define function roll_dice(n) // 定義 roll_dice 函式  \n → Step 1: results ← [] // 初始化空結果串列  \n → Step 2: For i in range(1, n+1): // 迭代擲 n 次  \n  → Step 3: roll ← random.randint(1, 6) // 產生 1~6 的隨機數  \n  → Step 4: Append roll to results // 加入結果串列  \n → Step 5: Return results // 回傳所有結果  \nEnd // 程式結束"
    },
    {
      "title": "計算程式執行時間",
      "source_file": "800.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "import time\n\ndef slow_add(a, b):\n    time.sleep(2)\n    return a + b\n\nprint(measure_time(slow_add, 3, 5))",
          "expected_output": "約 2.0 秒 (依電腦執行環境略有差異)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '約2.0秒(依電腦執行環境略有差異)'\nGot (Norm):      '2.0'\n--- (Raw) ---\nRaw Expected: '約 2.0 秒 (依電腦執行環境略有差異)'\nRaw Got:      '2.0'"
        }
      ],
      "generated_code": "import time\n\ndef measure_time(func, *args):\n    \"\"\"測量 func 執行所需秒數，並回傳四捨五入到小數點三位的結果\"\"\"\n    start = time.time()\n    func(*args)\n    end = time.time()\n    return round(end - start, 3)\n\nif __name__ == \"__main__\":\n    import sys\n    # 讀取標準輸入中的所有程式碼，並在目前命名空間執行\n    code = sys.stdin.read()\n    exec(code)",
      "virtual_code": "Thinking...\nWe need to output pseudocode step by step, with \"虛擬碼步驟\" then comment.\n\nWe need to follow the format example: Start, → Step 1, etc. For measuring time: import time, define function measure_time(func, *args). Inside, record start = time.time(); result = func(*args); end = time.time(); duration = end - start; duration_rounded = round(duration, 3); return result, duration_rounded? The requirement says \"並回傳結果 (四捨五入到小數點 3 位)\". The result likely refers to the function output, not duration? Wait: \"回傳結果 (四捨五入到小數點 3 位)\" – maybe they want to return duration? The phrase \"結果\" ambiguous. Probably they want to return the duration. But it's ambiguous. But usually measure_time returns the duration. But also could return the function's return value. I'd choose to return the duration. But might also return both result and duration. I'd produce code returning duration rounded. Provide explanation each line. We'll produce pseudocode lines: Start, import time, define function, record start time, call func, record end time, compute duration, round, return duration, End.\n\nLet's do.\n\nUse arrow for each step.\n\nWe'll produce in Chinese. We'll include \"Step\" with numbers.\n\nLet's format: \n\nStart // 程式開始執行\n→ import time // 引入 time 模組\n→ Step 1: 定義函數 measure_time(func, *args) // 建立測量時間的函式\n→ Step 2: 記錄 start_time = time.time() // 獲取當前時間作為開始時間\n→ Step 3: 執行 func(*args) 並把回傳值存到 result // 呼叫傳入的函式並取得結果\n→ Step 4: 記錄 end_time = time.time() // 獲取結束時間\n→ Step 5: 計算 duration = end_time - start_time // 計算執行所需秒數\n→ Step 6: duration_rounded = round(duration, 3) // 四捨五入到小數點三位\n→ Step 7: return duration_rounded // 回傳測量的秒數\nEnd // 程式執行結束\n\nAlso mention function return type: number.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ import time // 引入 time 模組  \n→ Step 1: 定義函數 measure_time(func, *args) // 建立測量時間的函式  \n→ Step 2: 記錄 start_time = time.time() // 獲取當前時間作為開始時間  \n→ Step 3: 執行 func(*args) 並把回傳值存到 result // 呼叫傳入的函式並取得結果  \n→ Step 4: 記錄 end_time = time.time() // 獲取結束時間  \n→ Step 5: 計算 duration = end_time - start_time // 計算執行所需秒數  \n→ Step 6: duration_rounded = round(duration, 3) // 四捨五入到小數點三位  \n→ Step 7: return duration_rounded // 回傳測量的秒數  \nEnd // 程式執行結束"
    },
    {
      "title": "學生資料類別設計",
      "source_file": "1100.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "Alice 的分數是 90\nBob 的分數是 80",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'Alice的分數是90\\nBob的分數是80'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: 'Alice 的分數是 90\\nBob 的分數是 80'\nRaw Got:      ''"
        }
      ],
      "generated_code": "class Student:\n    def __init__(self, name, score):\n        self.name = name\n        self.score = score\n\n    def show_info(self):\n        print(f'{self.name} 的分數是 {self.score}')\n\ndef main():\n    import sys\n    data = sys.stdin.read().strip().splitlines()\n    students = []\n    if not data or all(not line.strip() for line in data):\n        # default students\n        students.append(Student('Alice', 90))\n        students.append(Student('Bob', 80))\n    else:\n        for line in data:\n            if not line.strip():\n                continue\n            parts = line.strip().split()\n            if len(parts) >= 2:\n                name = parts[0]\n                try:\n                    score = int(parts[1])\n                except ValueError:\n                    score = float(parts[1])\n                students.append(Student(name, score))\n            else:\n                # ignore invalid lines\n                pass\n    for s in students:\n        s.show_info()\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation, step-by-step. Provide Start, define class, constructor, method, create instances, call method. No actual code. Use arrow and Decision if needed. Not necessary decision. Just sequential steps. Use \"虛擬碼步驟\" and explanation.\n\nWe need to produce lines like:\n\nStart // 程式開始執行\n→ Step 1: 定義 Student 類別 // 定義一個類別\n→ Step 2: 在 Student 中定義 __init__(self, name, score) // 建構子初始化屬性\n→ Step 3: 內部設定 self.name = name // 存儲姓名\n→ Step 4: 內部設定 self.score = score // 存儲分數\n→ Step 5: 定義 show_info(self) 方法 // 定義顯示資訊方法\n→ Step 6: 方法內輸出 'self.name 的分數是 self.score' // 顯示姓名和分數\n→ Step 7: 建立 student1 = Student('Alice', 90) // 創建第一個學生物件\n→ Step 8: 建立 student2 = Student('Bob', 85) // 創建第二個學生物件\n→ Step 9: 呼叫 student1.show_info() // 顯示第一個學生資訊\n→ Step 10: 呼叫 student2.show_info() // 顯示第二個學生資訊\nEnd // 程式執行結束\n\nBut the format expects \"虛擬碼步驟\" maybe the step label. The format example uses \"Step 1:\" etc. So we produce each line.\n\nThe explanation after // must be short. Good.\n\nThus produce:\n\nStart // 程式開始執行\n→ Step 1: 定義 Student 類別 // 建立一個名為 Student 的類別\n→ Step 2: 定義 __init__(self, name, score) // 建構子，接收姓名與分數\n→ Step 3: self.name = name // 初始化姓名屬性\n→ Step 4: self.score = score // 初始化分數屬性\n→ Step 5: 定義 show_info(self) 方法 // 用於顯示學生資訊\n→ Step 6: 輸出 '{self.name} 的分數是 {self.score}' // 顯示姓名與分數\n→ Step 7: student1 = Student('Alice', 90) // 建立第一個 Student 物件\n→ Step 8: student2 = Student('Bob', 85) // 建立第二個 Student 物件\n→ Step 9: student1.show_info() // 呼叫第一個物件的 show_info\n→ Step 10: student2.show_info() // 呼叫第二個物件的 show_info\nEnd // 程式執行結束\n\nEnsure each line has arrow and explanation. The arrow before Step 1? They used \"→ Step 1:\" in example. So we replicate.\n\nThus final output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義 Student 類別 // 建立一個名為 Student 的類別\n→ Step 2: 定義 __init__(self, name, score) // 建構子，接收姓名與分數\n→ Step 3: self.name = name // 初始化姓名屬性\n→ Step 4: self.score = score // 初始化分數屬性\n→ Step 5: 定義 show_info(self) 方法 // 用於顯示學生資訊\n→ Step 6: 輸出 '{self.name} 的分數是 {self.score}' // 顯示姓名與分數\n→ Step 7: student1 = Student('Alice', 90) // 建立第一個 Student 物件\n→ Step 8: student2 = Student('Bob', 85) // 建立第二個 Student 物件\n→ Step 9: student1.show_info() // 呼叫第一個物件的 show_info\n→ Step 10: student2.show_info() // 呼叫第二個物件的 show_info\nEnd // 程式執行結束"
    },
    {
      "title": "集合函數練習",
      "source_file": "600.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "{'apple', 'orange', 'grape', 'melon'}",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '{\"apple\",\"orange\",\"grape\",\"melon\"}'\nGot (Norm):      '{\"apple\",\"grape\",\"melon\",\"orange\"}'\n--- (Raw) ---\nRaw Expected: \"{'apple', 'orange', 'grape', 'melon'}\"\nRaw Got:      \"{'apple', 'grape', 'melon', 'orange'}\""
        }
      ],
      "generated_code": "import sys\n\ndef main() -> None:\n    # 讀取標準輸入（即使本題不需要任何輸入，也要確保程式能正確接受 stdin）\n    sys.stdin.read()\n\n    # 建立初始集合\n    fruits = {'apple', 'banana'}\n\n    # 新增 'orange'\n    fruits.add('orange')\n\n    # 一次新增 'grape' 與 'melon'\n    fruits.update(['grape', 'melon'])\n\n    # 移除 'banana'\n    fruits.remove('banana')\n\n    # 嘗試移除不存在的 'pineapple'（不會拋出錯誤）\n    fruits.discard('pineapple')\n\n    # 輸出最終集合\n    print(fruits)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps following format. Steps: Start, create set, add, update, remove, discard, print, End.\n\nLet's craft lines:\n\nStart // 程式開始執行\n→ Step 1: 定義 fruits 集合為 {'apple', 'banana'} // 建立初始集合\n→ Step 2: fruits.add('orange') // 新增 'orange'\n→ Step 3: fruits.update(['grape', 'melon']) // 同時新增 'grape' 與 'melon'\n→ Step 4: fruits.remove('banana') // 移除 'banana'\n→ Step 5: fruits.discard('pineapple') // 嘗試移除不存在的 'pineapple'\n→ Step 6: print(fruits) // 輸出最終集合\nEnd // 程式結束\n\nWe need ensure each line ends with // 解釋. Also maintain arrows and spacing. Use `→` at start of each step line. Should use `Start` and `End` without arrow? Example shows \"Start // 程式開始執行\" and \"End // 程式執行結束\". Good.\n\nMake sure each step line includes arrow and colon after step number. Provide explanation after space. Let's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 fruits 集合為 {'apple', 'banana'} // 建立初始集合  \n→ Step 2: fruits.add('orange') // 使用 add() 新增 'orange'  \n→ Step 3: fruits.update(['grape', 'melon']) // 使用 update() 同時新增 'grape' 與 'melon'  \n→ Step 4: fruits.remove('banana') // 使用 remove() 移除 'banana'  \n→ Step 5: fruits.discard('pineapple') // 使用 discard() 嘗試移除不存在的 'pineapple'  \n→ Step 6: print(fruits) // 輸出最終集合  \nEnd // 程式結束"
    },
    {
      "title": "即時匯率查詢小工具",
      "source_file": "1200.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "按下「更新匯率」按鈕",
          "expected_output": "目前美元匯率：約 32.5 TWD",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '目前美元匯率：約32.5TWD'\nGot (Norm):      '目前美元匯率：約30.66TWD'\n--- (Raw) ---\nRaw Expected: '目前美元匯率：約 32.5 TWD'\nRaw Got:      '目前美元匯率：約 30.66 TWD'"
        }
      ],
      "generated_code": "import sys\nimport requests\nimport tkinter as tk\n\ndef fetch_rate():\n    \"\"\"\n    向 https://api.exchangerate-api.com/v4/latest/USD 發送 GET 請求\n    並回傳 USD→TWD 的匯率值。若失敗則回傳 None。\n    \"\"\"\n    try:\n        response = requests.get('https://api.exchangerate-api.com/v4/latest/USD', timeout=10)\n        response.raise_for_status()\n        data = response.json()\n        return data['rates']['TWD']\n    except Exception:\n        return None\n\ndef update_label(label):\n    \"\"\"\n    取得匯率後更新 tkinter 內的 label。\n    \"\"\"\n    rate = fetch_rate()\n    if rate is not None:\n        label.config(text=f\"目前美元匯率：約 {rate} TWD\")\n    else:\n        label.config(text=\"更新失敗，請檢查網路連線\")\n\ndef main():\n    \"\"\"\n    1. 讀取標準輸入，如果有內容則直接取得匯率並輸出到標準輸出。\n    2. 若輸入為空則啟動 GUI 視窗，使用者可按鈕手動更新匯率。\n    \"\"\"\n    # 讀取所有標準輸入\n    stdin_data = sys.stdin.read().strip()\n\n    if stdin_data:\n        # 假設任何非空輸入都代表「更新匯率」的指令\n        rate = fetch_rate()\n        if rate is not None:\n            print(f\"目前美元匯率：約 {rate} TWD\")\n        else:\n            print(\"更新失敗，請檢查網路連線\")\n    else:\n        # 啟動 tkinter GUI\n        win = tk.Tk()\n        win.title(\"匯率查詢\")\n\n        label = tk.Label(win, text=\"請按下按鈕更新匯率\", font=(\"Arial\", 12))\n        label.pack(pady=10)\n\n        tk.Button(win, text=\"更新匯率\", command=lambda: update_label(label)).pack(pady=5)\n\n        win.mainloop()\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, each line with virtual code + comment. Must use virtual code arrows, Start, End, Decision, etc. Provide steps for using requests to fetch API, get TWD rate, show tkinter window, button updates.\n\nWe must not output actual code, just structured steps.\n\nLet's produce step by step.\n\nWe need to import modules: requests, tkinter. In virtual code we can show \"Import: requests, tkinter\". Not actual code.\n\nThen create function fetch_rate: send GET request to API, parse JSON, get TWD.\n\nIn virtual code we use \"→ Function: fetch_rate() // 取得匯率\" etc.\n\nThen create tkinter window: create root, label, button. button command triggers fetch_rate and updates label.\n\nWe should show decision if request success, else show error.\n\nWe need to show steps: Start, function definition, main GUI loop.\n\nWe need to adhere to format: each line with \"虛擬碼步驟\" and comment. Use arrow and indent with decision.\n\nLet's produce.\n\nWe need to maintain readability. Use indentation for decision branches.\n\nUse \"Decision: 是否成功?\".\n\nOk let's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Import: requests, tkinter // 引入網路請求與 GUI 模組  \n→ Function: fetch_rate() // 定義取得匯率的功能  \n    → Make GET request to https://api.exchangerate-api.com/v4/latest/USD // 向匯率 API 發送請求  \n    → Decision: 是否收到 200 OK? // 判斷 HTTP 回應是否成功  \n        Yes → Parse JSON response // 解析回傳的 JSON 內容  \n            → Extract rate = data['rates']['TWD'] // 取得美元對台幣的匯率  \n            → Return rate // 回傳匯率值  \n        No  → Return None // 失敗時回傳 None  \n→ Function: update_rate() // 定義更新匯率並顯示的功能  \n    → rate = fetch_rate() // 呼叫取得匯率的函式  \n    → Decision: rate 是否為 None? // 判斷是否成功取得匯率  \n        Yes → label.config(text=\"匯率取得失敗\") // 失敗時顯示錯誤訊息  \n        No  → label.config(text=f\"USD → TWD: {rate}\") // 成功時顯示匯率  \n→ Create tkinter root window // 初始化 tkinter 視窗  \n    → Set title to \"匯率查詢\" // 設定視窗標題  \n→ Create label widget // 建立顯示匯率的文字元件  \n    → Pack into root // 放置於視窗中  \n→ Create button widget // 建立更新按鈕  \n    → Set text to \"更新匯率\"  \n    → Assign command update_rate // 指定點擊時執行更新功能  \n    → Pack into root // 放置於視窗中  \n→ Call update_rate() // 初始載入時更新一次匯率  \n→ Main loop: root.mainloop() // 開始 tkinter 事件迴圈  \nEnd // 程式執行結束"
    },
    {
      "title": "Insert Delete GetRandom O(1)",
      "source_file": "Leetcode/leetcode380.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedSet\", \"insert\", \"remove\", \"insert\", \"getRandom\", \"remove\", \"insert\", \"getRandom\"], [[], [1], [2], [2], [], [1], [2], []]",
          "expected_output": "[null, true, false, true, 2, true, false, 2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,false,true,2,true,false,2]'\nGot (Norm):      '[null,true,false,true,1,true,false,2]'\n--- (Raw) ---\nRaw Expected: '[null, true, false, true, 2, true, false, 2]'\nRaw Got:      '[null, true, false, true, 1, true, false, 2]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\n\nclass RandomizedSet:\n    def __init__(self):\n        self.val_to_index = {}\n        self.values = []\n\n    def insert(self, val):\n        if val in self.val_to_index:\n            return False\n        self.values.append(val)\n        self.val_to_index[val] = len(self.values) - 1\n        return True\n\n    def remove(self, val):\n        if val not in self.val_to_index:\n            return False\n        index = self.val_to_index[val]\n        last_val = self.values[-1]\n        self.values[index] = last_val\n        self.val_to_index[last_val] = index\n        self.values.pop()\n        del self.val_to_index[val]\n        return True\n\n    def getRandom(self):\n        return random.choice(self.values)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 解析輸入為兩個列表：commands 與 args\n    data = '(' + data + ')'          # 轉成 tuple 表達式\n    commands, args = ast.literal_eval(data)\n\n    obj = None\n    results = []\n\n    for cmd, arg in zip(commands, args):\n        if cmd == \"RandomizedSet\":\n            obj = RandomizedSet()\n            results.append(None)      # constructor 不回傳任何值，輸出 null\n        elif cmd == \"insert\":\n            res = obj.insert(arg[0])  # arg 是 [value]\n            results.append(res)\n        elif cmd == \"remove\":\n            res = obj.remove(arg[0])\n            results.append(res)\n        elif cmd == \"getRandom\":\n            res = obj.getRandom()\n            results.append(res)\n\n    # 將結果轉成 LeetCode 風格的輸出格式\n    formatted = '[' + ', '.join(\n        'null' if r is None else ('true' if r is True else ('false' if r is False else str(r)))\n        for r in results\n    ) + ']'\n    print(formatted)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce a virtual code step-by-step for the RandomizedSet class implementation. Each line: \"虛擬碼步驟 // 解釋\". Use arrows, Start, End, Decision. Need to explain each step. Provide the steps for initialization, insert, remove, getRandom. Use pseudo-code with arrow. Should be clear and concise.\n\nWe need to describe using hash map and array for O(1). For insert: if val not in map, add to array, record index, return true else false. Remove: if val exists, swap with last element, update index in map, pop back, delete from map. Return true else false. getRandom: generate random index from 0 to size-1, return array element. We'll produce a flowchart-like step lines.\n\nWe need to produce line by line steps with arrow notation. Provide explanation after //.\n\nOk produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 RandomizedSet  \n  Define 空陣列 `data` // 用來儲存元素  \n  Define 哈希表 `idxMap` (key: 元素, value: 在 `data` 的索引) // 方便 O(1) 查找  \n→ End // 初始結構已建立  \n\nStart // Insert 函式流程  \n→ Decision: 若 `val` 已存在於 `idxMap`? // 檢查元素是否已存在  \n  Yes → Step 2: 回傳 `false` // 插入失敗，已存在  \n  No → Step 3: 追加 `val` 至 `data` 的尾端 // 新增元素  \n    `idxMap[val] ← data.size - 1` // 記錄索引位置  \n    回傳 `true` // 插入成功  \nEnd // Insert 函式結束  \n\nStart // Remove 函式流程  \n→ Decision: 若 `val` 不存在於 `idxMap`? // 檢查元素是否存在  \n  Yes → Step 4: 回傳 `false` // 移除失敗，元素不存在  \n  No → Step 5: 取得 `lastVal ← data.back()` // 取陣列最後一個元素  \n    `idx ← idxMap[val]` // 找到要移除元素的位置  \n    將 `data[idx] ← lastVal` // 將最後一個元素移至被刪位置  \n    `idxMap[lastVal] ← idx` // 更新最後一個元素的新索引  \n    `data.pop_back()` // 刪除陣列最後元素  \n    `idxMap.erase(val)` // 移除哈希表對應項目  \n    回傳 `true` // 移除成功  \nEnd // Remove 函式結束  \n\nStart // getRandom 函式流程  \n→ Step 6: 產生隨機整數 `r`，範圍 0 至 `data.size - 1` // 隨機索引  \n→ Step 7: 回傳 `data[r]` // 以等機率回傳任意元素  \nEnd // getRandom 函式結束  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Random Flip Matrix",
      "source_file": "Leetcode/leetcode519.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"flip\", \"flip\", \"flip\", \"reset\", \"flip\"], [[3, 1], [], [], [], [], []]",
          "expected_output": "[null, [1,0], [2,0], [0,0], null, [2,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[1,0],[2,0],[0,0],null,[2,0]]'\nGot (Norm):      '[null,[0,0],[2,0],[1,0],null,[2,0]]'\n--- (Raw) ---\nRaw Expected: '[null, [1,0], [2,0], [0,0], null, [2,0]]'\nRaw Got:      '[null, [0, 0], [2, 0], [1, 0], null, [2, 0]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, n_rows, n_cols):\n        self.rows = n_rows\n        self.cols = n_cols\n        self.total = n_rows * n_cols\n        self.flipped = {}\n\n    def flip(self):\n        r = random.randint(0, self.total - 1)\n        x = self.flipped.get(r, r)\n        self.total -= 1\n        self.flipped[r] = self.flipped.get(self.total, self.total)\n        return [x // self.cols, x % self.cols]\n\n    def reset(self):\n        self.total = self.rows * self.cols\n        self.flipped.clear()\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    ops_part, args_part = data.split('],', 1)\n    ops = json.loads(ops_part + ']')\n    args = json.loads(args_part)\n    results = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            obj = Solution(*arg)\n            results.append(None)\n        elif op == \"flip\":\n            results.append(obj.flip())\n        elif op == \"reset\":\n            obj.reset()\n            results.append(None)\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to output virtual code line by line with explanation, following the format. The requirement: design algorithm to randomly pick a zero cell and flip to 1. We need to minimize random calls. Common solution: use reservoir mapping from index to position: treat flattened indices 0..m*n-1. Maintain a map dict from selected index to available index. Keep count of remaining zeros (total). flip: pick random integer r in [0, remaining-1]; map r to actual index: if r in map then idx=map[r] else idx=r. Then map r to last available index: if (remaining-1) in map then map[r] = map[remaining-1] else map[r] = remaining-1. Decrement remaining. Convert idx to (i, j). return. reset: clear map, set remaining=m*n.\n\nSo produce virtual code.\n\nWe need to produce each line with comment. Use Start, End. We'll produce steps for constructor, flip, reset. Use decision blocks for random and map checks.\n\nLet's draft.\n\nStart\n→ Step 1: Initialize m, n, total = m * n, remaining = total, mapping = empty dictionary // store index mapping\n\nBut we need to represent object initialization.\n\nMaybe use method definitions:\n\nSolution(int m, int n) // constructor\n\nThen flip(), reset() functions.\n\nWe need virtual code lines like: // Define class Solution\n→ Step 1: class Solution // 定義 Solution 類別\n    → Step 2: int m, n, total, remaining // 宣告矩陣尺寸與計數\n    → Step 3: map<int, int> mapping // 位置映射\n\nConstructor:\n→ Step 4: Constructor(m, n): set m, n, total = m * n, remaining = total, mapping.clear() // 初始化\n\nflip():\n→ Step 5: flip() // 隨機翻轉 0 為 1\n    → Step 6: r = randomInt(0, remaining - 1) // 產生 0~remaining-1 的隨機數\n    → Decision: 是否 r 在 mapping? // 檢查 r 是否已映射\n        Yes → Step 7: idx = mapping[r] // 取映射後的實際索引\n        No  → Step 8: idx = r // 直接使用 r\n    → Decision: 是否 (remaining - 1) 在 mapping? // 準備更新映射\n        Yes → Step 9: mapping[r] = mapping[remaining - 1] // 把 r 映射到最後一個未使用的索引\n        No  → Step 10: mapping[r] = remaining - 1 // 若無映射，直接用 remaining-1\n    → Step 11: remaining -= 1 // 減少可用空格\n    → Step 12: i = idx / n, j = idx % n // 轉換為行列\n    → Step 13: return [i, j] // 回傳\n\nreset():\n→ Step 14: reset() // 重置矩陣\n    → Step 15: mapping.clear() // 清空映射\n    → Step 16: remaining = total // 重新設定可用空格\n\nEnd\n\nNeed to use arrow notation. Should we indent substeps? In example they use indentation and lines like 'Yes → Step ...'. We'll replicate.\n\nLet's produce final output. Ensure each line ends with comment. Use Chinese explanation.\n\nCheck formatting: \"虛擬碼步驟 [space] // 解釋/說明\". So each line: [虛擬碼步驟] // [說明]\n\nWe'll produce.\n\nAlso Start/End. So we should include Start before first line. And End after last.\n\nWe'll output:\n\nStart // 程式開始執行\n→ Step 1: class Solution // 定義 Solution 類別\n→ Step 2: int m, n, total, remaining // 儲存矩陣尺寸與剩餘 0 的數量\n→ Step 3: map<int, int> mapping // 對映隨機選擇到實際索引的字典\n→ Step 4: Constructor(m, n): m = m; n = n; total = m * n; remaining = total; mapping.clear() // 初始化物件\n→ Step 5: flip() // 隨機選取一個 0 並轉為 1\n→ Step 6: r = randomInt(0, remaining - 1) // 產生 0~remaining-1 的隨機整數\n→ Decision: r 在 mapping 嗎? // 判斷 r 是否已被映射\n    Yes → Step 7: idx = mapping[r] // 取映射後的真實索引\n    No  → Step 8: idx = r // 若未映射，直接使用 r\n→ Decision: (remaining - 1) 在 mapping 嗎? // 準備更新映射\n    Yes → Step 9: mapping[r] = mapping[remaining - 1] // 把 r 映射到最後一個可用索引\n    No  → Step 10: mapping[r] = remaining - 1 // 若未映射，直接映射到剩餘最末索引\n→ Step 11: remaining -= 1 // 減少剩餘 0 的數量\n→ Step 12: i = idx / n; j = idx % n // 將扁平索引轉回行列\n→ Step 13: return [i, j] // 回傳被翻轉的索引\n→ Step 14: reset() // 重置矩陣為全 0\n→ Step 15: mapping.clear() // 清空映射表\n→ Step 16: remaining = total // 重新設定剩餘 0 的數量\nEnd // 程式執行結束\n\nWe need to ensure arrow after Decision: lines. Use indentation maybe two spaces? The example shows indent. We'll replicate same indent.\n\nEnsure each line ends with comment.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: class Solution // 定義 Solution 類別  \n→ Step 2: int m, n, total, remaining // 儲存矩陣尺寸與剩餘 0 的數量  \n→ Step 3: map<int, int> mapping // 對映隨機選擇到實際索引的字典  \n→ Step 4: Constructor(m, n): m = m; n = n; total = m * n; remaining = total; mapping.clear() // 初始化物件  \n→ Step 5: flip() // 隨機選取一個 0 並轉為 1  \n→ Step 6: r = randomInt(0, remaining - 1) // 產生 0~remaining-1 的隨機整數  \n→ Decision: r 在 mapping 嗎? // 判斷 r 是否已被映射  \n    Yes → Step 7: idx = mapping[r] // 取映射後的真實索引  \n    No  → Step 8: idx = r // 若未映射，直接使用 r  \n→ Decision: (remaining - 1) 在 mapping 嗎? // 準備更新映射  \n    Yes → Step 9: mapping[r] = mapping[remaining - 1] // 把 r 映射到最後一個可用索引  \n    No  → Step 10: mapping[r] = remaining - 1 // 若未映射，直接映射到剩餘最末索引  \n→ Step 11: remaining -= 1 // 減少剩餘 0 的數量  \n→ Step 12: i = idx / n; j = idx % n // 將扁平索引轉回行列  \n→ Step 13: return [i, j] // 回傳被翻轉的索引  \n→ Step 14: reset() // 重置矩陣為全 0  \n→ Step 15: mapping.clear() // 清空映射表  \n→ Step 16: remaining = total // 重新設定剩餘 0 的數量  \nEnd // 程式執行結束"
    },
    {
      "title": "Heaters",
      "source_file": "Leetcode/leetcode475.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "houses = [1,2,3], heaters = [2]",
          "expected_output": "1",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpacj9qios.py\", line 33, in <module>\n    houses, heaters = parse_input(raw_input)\n                      ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpacj9qios.py\", line 24, in parse_input\n    raise ValueError(\"輸入格式不正確，應為 'houses = [...], heaters = [...]'\")\nValueError: 輸入格式不正確，應為 'houses = [...], heaters = [...]'"
        },
        {
          "example_index": 1,
          "input": "houses = [1,2,3,4], heaters = [1,4]",
          "expected_output": "1",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpbhvkuyu8.py\", line 33, in <module>\n    houses, heaters = parse_input(raw_input)\n                      ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpbhvkuyu8.py\", line 24, in parse_input\n    raise ValueError(\"輸入格式不正確，應為 'houses = [...], heaters = [...]'\")\nValueError: 輸入格式不正確，應為 'houses = [...], heaters = [...]'"
        },
        {
          "example_index": 2,
          "input": "houses = [1,5], heaters = [2]",
          "expected_output": "3",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpgia8aqqt.py\", line 33, in <module>\n    houses, heaters = parse_input(raw_input)\n                      ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpgia8aqqt.py\", line 24, in parse_input\n    raise ValueError(\"輸入格式不正確，應為 'houses = [...], heaters = [...]'\")\nValueError: 輸入格式不正確，應為 'houses = [...], heaters = [...]'"
        }
      ],
      "generated_code": "import sys\nimport math\nfrom typing import List\n\nclass Solution:\n    def findRadius(self, houses: List[int], heaters: List[int]) -> int:\n        houses.sort()\n        heaters.sort()\n        res = 0\n        i = 0  # 指向最近的右邊加熱器\n\n        for house in houses:\n            # 找到離 house 最近的右邊加熱器\n            while i < len(heaters) - 1 and abs(heaters[i+1] - house) <= abs(heaters[i] - house):\n                i += 1\n            # 記錄最遠距離\n            res = max(res, abs(heaters[i] - house))\n        return res\n\ndef parse_input(raw: str):\n    \"\"\"解析形如 'houses = [1,2,3], heaters = [2]' 的輸入。\"\"\"\n    parts = raw.strip().split(',')\n    if len(parts) != 2:\n        raise ValueError(\"輸入格式不正確，應為 'houses = [...], heaters = [...]'\")\n    houses_part = parts[0].strip()\n    heaters_part = parts[1].strip()\n    houses = eval(houses_part.split('=')[1].strip())\n    heaters = eval(heaters_part.split('=')[1].strip())\n    return houses, heaters\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    houses, heaters = parse_input(raw_input)\n    solution = Solution()\n    radius = solution.findRadius(houses, heaters)\n    print(radius)",
      "virtual_code": "Thinking...\nWe need to output virtual code steps for solving the problem. We need to produce a step-by-step algorithm in pseudo-code, with explanations, not actual code. Should be structured with Start, End, Decision, etc. Each line: \"虛擬碼步驟 // 解釋\".\n\nWe need to produce algorithm: given houses positions array and heaters positions array. Need min radius such that each house within some heater distance. Approach: sort houses and heaters. For each house, find nearest heater via binary search. Keep maximum distance. That's min radius. Complexity O((n+m) log m). Or use two pointers after sorting.\n\nWill produce steps: Input arrays, sort houses, sort heaters, for each house find nearest heater: use binary search to find insertion point in heaters; compute left distance, right distance; take min; update maxDist. Finally return maxDist.\n\nLet's produce step-by-step lines:\n\nStart\n\n→ Step 1: 接收兩個整數陣列 houses, heaters // 讀取房屋和暖氣的位置\n\n→ Decision: 是否已排序? // 檢查是否需要排序\n\n    No  → Step 2: Sort houses ascending // 排序房屋\n\n    No  → Step 3: Sort heaters ascending // 排序暖氣\n\nNow main loop:\n\n→ Step 4: maxRadius ← 0 // 初始化最大半徑\n\n→ Step 5: For each housePos in houses // 逐個房屋處理\n\n    → Decision: 在 heaters 中找到最接近的暖氣位置? // 用二分查找\n\n        Yes → Step 6: idx ← binarySearchInsertionPoint(heaters, housePos) // 找到插入位置\n\n        Yes → Step 7: leftDist ← (idx > 0) ? housePos - heaters[idx-1] : ∞ // 左側距離\n\n        Yes → Step 8: rightDist ← (idx < heaters.size) ? heaters[idx] - housePos : ∞ // 右側距離\n\n        Yes → Step 9: nearestDist ← min(leftDist, rightDist) // 最小距離\n\n        Yes → Step 10: maxRadius ← max(maxRadius, nearestDist) // 更新最大半徑\n\nEnd\n\nBut need to produce each line individually. Also maybe we can merge some steps.\n\nLet's produce step-by-step. Use \"Decision:\" for condition. Use \"Yes →\" and \"No →\".\n\nMake sure each line has code and comment.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Input houses[], heaters[] // 讀取房屋與暖氣的位置陣列  \n→ Decision: 是否需要排序? // 檢查輸入是否已排序  \n  No  → Step 2: Sort houses ascending // 將房屋位置排序  \n  No  → Step 3: Sort heaters ascending // 將暖氣位置排序  \n→ Step 4: maxRadius ← 0 // 初始化最小可接受半徑  \n→ Step 5: For each housePos in houses // 逐一檢查每個房屋  \n  → Decision: 在 heaters 中找到最接近的暖氣索引? // 用二分搜尋確定插入位置  \n    Yes  → Step 6: idx ← BinarySearchInsert(heaters, housePos) // idx 為第一個 ≥ housePos 的索引  \n    Yes  → Step 7: leftDist ← (idx > 0) ? housePos - heaters[idx-1] : ∞ // 左側最近暖氣距離  \n    Yes  → Step 8: rightDist ← (idx < heaters.size) ? heaters[idx] - housePos : ∞ // 右側最近暖氣距離  \n    Yes  → Step 9: nearestDist ← Min(leftDist, rightDist) // 房屋至最近暖氣的距離  \n    Yes  → Step 10: maxRadius ← Max(maxRadius, nearestDist) // 更新需要的最大半徑  \nEnd // 程式執行結束，maxRadius 即為答案\n\n*說明*：  \n- 先將兩個陣列排序，便於快速查找。  \n- 對每個房屋使用二分搜尋定位其在暖氣陣列中的插入點，取得左右最近的暖氣。  \n- 計算左右距離的最小值即為該房屋的最小加熱半徑。  \n- 取所有房屋所需半徑中的最大值，即為所有暖氣統一設定的最小半徑。"
    },
    {
      "title": "Remove Invalid Parentheses",
      "source_file": "Leetcode/leetcode301.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"()())()\"",
          "expected_output": "[\"(())()\",\"()()()\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"(())()\",\"()()()\"]'\nGot (Norm):      '[\"()()()\",\"(())()\"]'\n--- (Raw) ---\nRaw Expected: '[\"(())()\",\"()()()\"]'\nRaw Got:      \"['()()()', '(())()']\""
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def removeInvalidParentheses(self, s: str):\n        \"\"\"\n        Return all unique strings with minimum removals to make parentheses valid.\n        Uses DFS with pruning.\n        \"\"\"\n        res = set()\n\n        # Pre‑compute how many left/right parentheses must be removed\n        remove_left = remove_right = 0\n        for ch in s:\n            if ch == '(':\n                remove_left += 1\n            elif ch == ')':\n                if remove_left > 0:\n                    remove_left -= 1\n                else:\n                    remove_right += 1\n\n        def dfs(idx, left_cnt, right_cnt, rem_l, rem_r, path):\n            if idx == len(s):\n                if rem_l == 0 and rem_r == 0:\n                    res.add(''.join(path))\n                return\n\n            ch = s[idx]\n            if ch == '(':\n                # Option 1: remove it\n                if rem_l > 0:\n                    dfs(idx + 1, left_cnt, right_cnt, rem_l - 1, rem_r, path)\n                # Option 2: keep it\n                path.append(ch)\n                dfs(idx + 1, left_cnt + 1, right_cnt, rem_l, rem_r, path)\n                path.pop()\n            elif ch == ')':\n                # Option 1: remove it\n                if rem_r > 0:\n                    dfs(idx + 1, left_cnt, right_cnt, rem_l, rem_r - 1, path)\n                # Option 2: keep it only if it can be matched\n                if left_cnt > right_cnt:\n                    path.append(ch)\n                    dfs(idx + 1, left_cnt, right_cnt + 1, rem_l, rem_r, path)\n                    path.pop()\n            else:  # ordinary character\n                path.append(ch)\n                dfs(idx + 1, left_cnt, right_cnt, rem_l, rem_r, path)\n                path.pop()\n\n        dfs(0, 0, 0, remove_left, remove_right, [])\n        return list(res)\n\ndef _parse_input(data: str) -> str:\n    \"\"\"\n    Extract the first string literal from the input.\n    Supports formats like: s = \"()())()\" or just \"()())()\".\n    \"\"\"\n    match = re.search(r'[\"\\']([^\"\\']*)[\"\\']', data)\n    if match:\n        return match.group(1)\n    return data.strip()\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    if not raw_input:\n        sys.exit(0)\n    s = _parse_input(raw_input)\n    solution = Solution()\n    result = solution.removeInvalidParentheses(s)\n    print(result)",
      "virtual_code": "Thinking...\nWe need produce virtual code for problem: remove min invalid parentheses and return list of unique valid strings. We need to output step by step virtual code, no actual code, each line with explanation, using Start, Decision, etc. We should include algorithm: BFS or DFS with pruning. For clarity: compute counts of left and right to remove. Then backtrack generating all possibilities removing that many parentheses. Use set to avoid duplicates. Provide explanation. Should produce algorithm steps. Let's craft.\n\nLine1 Start // 程式開始執行\n\nThen Step: Compute remove counts. Then Decision: if char is '(' etc. Might show recursion. Let's produce pseudocode with BFS.\n\nOk. Let's produce a clear algorithm: use backtracking with pruning. Steps:\n\n- compute removeLeft, removeRight.\n\n- Define DFS function with index, leftCount, rightCount, removeL, removeR, current string builder, result set.\n\n- In DFS: if index==len, if removeL==0 and removeR==0, add string.\n\n- Else process char: if '(' -> consider removing it: if removeL>0 then DFS(index+1, leftCount, rightCount, removeL-1, removeR,...). Also consider keeping it: DFS(index+1, leftCount+1,...). For ')' similarly. For letters: keep always.\n\n- To avoid duplicates: use a set.\n\nLet's write virtual code lines with arrows.\n\nWe'll show decisions: if char is '(' then two branches. Provide explanations.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 先計算需要移除的左括號數 removeLeft 及右括號數 removeRight // 只要遍歷一次字串即可獲得兩個數量  \n→ Decision: s[i] 為 '('? // 判斷目前字符是否為左括號  \n  Yes → Step 2: 兩種處理方式  \n    - 方案 A：將此 '(' 移除並遞迴處理下一個字符  \n     → Step 3: DFS(i+1, leftCount, rightCount, removeLeft-1, removeRight, curr, result) // 移除左括號後更新移除計數  \n    - 方案 B：保留此 '(' 並遞迴處理下一個字符  \n     → Step 4: DFS(i+1, leftCount+1, rightCount, removeLeft, removeRight, curr+'(', result) // 保留後左括號數增加  \n  No  → Decision: s[i] 為 ')' ? // 若不是左括號，檢查是否為右括號  \n    Yes → Step 5: 兩種處理方式  \n     - 方案 A：將此 ')' 移除並遞迴處理下一個字符  \n      → Step 6: DFS(i+1, leftCount, rightCount, removeLeft, removeRight-1, curr, result) // 移除右括號後更新移除計數  \n     - 方案 B：保留此 ')'，但前提是 leftCount > rightCount（可以配對）  \n      → Decision: leftCount > rightCount? // 確保保留不會造成不合法的右括號多於左括號  \n       Yes → Step 7: DFS(i+1, leftCount, rightCount+1, removeLeft, removeRight, curr+')', result) // 保留後右括號數增加  \n       No  → Step 8: 跳過此路徑 // 右括號多於左括號，無法保留  \n  No  → Decision: s[i] 為字母? // 不是括號，直接保留  \n    Yes → Step 9: DFS(i+1, leftCount, rightCount, removeLeft, removeRight, curr+s[i], result) // 直接保留字母  \n\n→ Step 10: DFS 函式結束時：  \n  Decision: i == len(s)? // 到達字串末尾  \n    Yes → Decision: removeLeft == 0 and removeRight == 0? // 所有必須移除的括號已移除  \n      Yes → Step 11: result.add(curr) // 將合法字串加入結果集合，避免重複  \n      No  → Step 12: 返回 // 無法達成合法條件，終止此分支  \n    No → Step 13: 進一步遞迴處理下一個字符  \n\nEnd // 程式執行結束，返回 result 集合中的所有唯一合法字串"
    },
    {
      "title": "Min Stack",
      "source_file": "Leetcode/leetcode155.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"],[[],[-2],[0],[-3],[],[],[],[]]",
          "expected_output": "[null,null,null,null,-3,null,0,-2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,null,-3,null,0,-2]'\nGot (Norm):      '[null,null,null,-3,null,0,-2]'\n--- (Raw) ---\nRaw Expected: '[null,null,null,null,-3,null,0,-2]'\nRaw Got:      '[null, null, null, -3, null, 0, -2]'"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass MinStack:\n    \"\"\"雙堆疊實作：主堆疊 + 儲存最小值的輔助堆疊\"\"\"\n    def __init__(self):\n        self.stack = []       # 主堆疊\n        self.min_stack = []   # 儲存目前最小值的堆疊\n\n    def push(self, val: int) -> None:\n        \"\"\"把 val 推入主堆疊，若 val 為新的最小值也推入 min_stack\"\"\"\n        self.stack.append(val)\n        if not self.min_stack or val <= self.min_stack[-1]:\n            self.min_stack.append(val)\n\n    def pop(self) -> None:\n        \"\"\"彈出主堆疊頂端元素，若此元素為目前最小值則同步彈出 min_stack\"\"\"\n        if not self.stack:\n            return\n        val = self.stack.pop()\n        if self.min_stack and val == self.min_stack[-1]:\n            self.min_stack.pop()\n\n    def top(self):\n        \"\"\"回傳主堆疊頂端元素，若空堆疊回傳 None\"\"\"\n        return self.stack[-1] if self.stack else None\n\n    def getMin(self):\n        \"\"\"回傳目前最小值，若空堆疊回傳 None\"\"\"\n        return self.min_stack[-1] if self.min_stack else None\n\ndef main() -> None:\n    # 讀取整個標準輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 資料格式為兩個 JSON 陣列，用 [] 包起來後解析\n    ops, args = json.loads(f'[{data}]')\n\n    ms = MinStack()\n    results = []\n\n    for op, arg in zip(ops, args):\n        if op == 'push':\n            ms.push(arg[0])\n            results.append(None)\n        elif op == 'pop':\n            ms.pop()\n            results.append(None)\n        elif op == 'top':\n            results.append(ms.top())\n        elif op == 'getMin':\n            results.append(ms.getMin())\n\n    # 使用 json.dumps 讓 None 轉成 null，符合 LeetCode 的輸出格式\n    sys.stdout.write(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code line by line for MinStack design with O(1). Provide steps: initialization, push, pop, top, getMin. Use Start/End, Decision, etc. Provide line-by-line. Use arrows, etc. Provide comments. Should not output actual code. Provide virtual steps. We'll produce steps like:\n\nStart\n→ Step: Define two stacks: mainStack, minStack\n→ Step: Initialize both as empty\n\nFor push: compare val with minStack.top, push accordingly\n\nFor pop: pop from mainStack, and if popped equals minStack.top then pop from minStack\n\ntop: return mainStack.top\n\ngetMin: return minStack.top\n\nWe need to show each operation as separate steps? Might show functions. We can list steps for each method. Provide explanation after each. Use arrow for transitions.\n\nWe can have a flow for push:\n\n→ Decision: Is minStack empty? Yes: push val onto minStack\n\nElse: compare val <= minStack.top? If true push val onto minStack else do nothing.\n\nWe also push onto mainStack always.\n\nSimilarly for pop:\n\n→ Step: pop from mainStack and store poppedVal\n\n→ Decision: If poppedVal equals minStack.top? Yes → pop from minStack\n\nReturn.\n\nTop: return mainStack.top\n\nGetMin: return minStack.top\n\nWrap in End.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義兩個堆疊 mainStack 與 minStack，皆初始化為空 // 用來儲存所有元素與當前最小值\n→ Step 2: 初始化 MinStack 物件 // 建立主入口\n\n// ---------- push(val) ----------\n→ Step 3: 接收要推入的值 val\n→ Decision: 如果 minStack 為空？ // 判斷是否已經有最小值\n    Yes → Step 4: 將 val 推入 minStack // 第一個元素即為最小值\n    No  → Decision: 若 val 小於或等於 minStack.top？ // 小於等於才能成為新的最小值\n        Yes → Step 5: 將 val 推入 minStack // 更新最小值\n        No  → Step 6: 不操作 minStack // 原最小值仍保持\n→ Step 7: 將 val 推入 mainStack // 所有元素都要存入主堆疊\n\n// ---------- pop() ----------\n→ Step 8: 從 mainStack 彈出頂端元素並存於 poppedVal\n→ Decision: poppedVal 是否等於 minStack.top？ // 需要同步更新最小值\n    Yes → Step 9: 從 minStack 彈出頂端元素 // 舊最小值被移除\n    No  → Step 10: 不操作 minStack // 最小值不變\n\n// ---------- top() ----------\n→ Step 11: 取得並回傳 mainStack.top() // 顯示堆疊頂端元素\n\n// ---------- getMin() ----------\n→ Step 12: 取得並回傳 minStack.top() // 顯示目前堆疊中的最小值\n\nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick Index",
      "source_file": "Leetcode/leetcode398.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\"], [[[1, 2, 3, 3, 3]], [3], [1], [3]]",
          "expected_output": "[null, 4, 0, 2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmplzgluy06.py\", line 24, in <module>\n    ops, args_list = json.loads(data)\n                     ^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 37 (char 36)"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nfrom collections import defaultdict\n\nclass Solution:\n    def __init__(self, nums):\n        # 建立目標值到所有索引的映射\n        self.num_indices = defaultdict(list)\n        for i, num in enumerate(nums):\n            self.num_indices[num].append(i)\n\n    def pick(self, target):\n        # 隨機選取對應索引\n        return random.choice(self.num_indices[target])\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 解析 JSON 格式的操作與參數\n    ops, args_list = json.loads(data)\n\n    results = []\n    sol = None\n\n    for op, args in zip(ops, args_list):\n        if op == \"Solution\":\n            sol = Solution(args[0])\n            results.append(None)  # constructor 返回 null\n        elif op == \"pick\" and sol is not None:\n            res = sol.pick(args[0])\n            results.append(res)\n        else:\n            # 未知操作，跳過\n            pass\n\n    # 輸出結果，Python 的 None 會轉成 JSON 的 null\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce virtual code for this problem: Given array nums, implement class with constructor storing array, and pick(target) random index among indices where nums[i]==target with equal probability. Use reservoir sampling or mapping.\n\nWe can choose to store a mapping from target to list of indices, then pick random from list. Or use reservoir sampling each call.\n\nSimplest: Preprocess: map target -> list of indices.\n\nWe produce virtual code lines following format: \"Start\", arrow steps, decisions, etc. Provide line by line.\n\nWe need to include \"Solution(int[] nums)\" and \"int pick(int target)\".\n\nWe produce step-by-step pseudocode.\n\nLet's craft.\n\nStart\n→ Step 1: 初始化空字典 target_to_indices // 建立目標值到索引列表的映射\n→ Decision: 是否遍歷 nums? // 確認是否有元素\n    Yes → Step 2: 從 0 到 nums.length-1 迴圈 // 遍歷陣列\n        → Step 3: 如果 nums[i] 不是字典鍵? // 判斷是否已經存在\n            Yes → Step 4: target_to_indices[nums[i]] = [i] // 新建列表\n            No  → Step 5: target_to_indices[nums[i]].append(i) // 加入索引\n→ End // 建構完成\n\nThen pick:\n\nStart\n→ Step 1: 取得 indices_list = target_to_indices[target] // 取目標索引列表\n→ Decision: indices_list 為空? // 但已知存在\n    Yes → Step 2: return -1 // 兜底\n    No  → Step 3: random_index = 隨機整數(0, len(indices_list)-1) // 隨機位置\n        → Step 4: return indices_list[random_index] // 回傳選中的索引\nEnd\n\nWe need to keep each line with // explanation.\n\nAlso include class and method structure maybe.\n\nWe can produce:\n\nStart // 程式開始\n→ Step 1: Class Solution 定義 // 定義類別\n    → Step 2: Variable target_to_indices // 宣告映射\n    → Step 3: Constructor(nums) // 建構子\n        → Step 4: target_to_indices = {} // 初始化空字典\n        → Step 5: 迴圈 i 0 to len(nums)-1 // 遍歷陣列\n            → Step 6: key = nums[i]\n            → Decision: key 在 target_to_indices? // 判斷已存在\n                Yes → Step 7: target_to_indices[key].append(i) // 加入索引\n                No  → Step 8: target_to_indices[key] = [i] // 新建列表\n    → Step 9: pick(target) // pick 方法\n        → Step 10: indices = target_to_indices[target] // 取得索引列表\n        → Decision: indices 為空? // 兜底\n            Yes → Step 11: return -1\n            No  → Step 12: rand = RandomInteger(0, len(indices)-1) // 隨機位置\n                → Step 13: return indices[rand] // 回傳索引\nEnd // 程式結束\n\nMake sure format uses \"→\". For Decision we indent further lines.\n\nWe need to include only virtual code lines, not actual code. Each line should end with comment.\n\nThus produce as requested.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Class Solution 定義 // 定義類別，管理陣列與隨機取值  \n  → Step 2: 變數 target_to_indices 初始化為空字典 // 用於儲存每個目標值對應的索引清單  \n  → Step 3: Constructor(nums) // 建構子，接收陣列並做預處理  \n    → Step 4: target_to_indices = {} // 建立空映射  \n    → Step 5: 從 i = 0 到 nums.length - 1 迴圈 // 遍歷陣列  \n      → Step 6: key = nums[i] // 取得目前元素作為鍵  \n      → Decision: key 是否已在 target_to_indices? // 檢查是否已有對應清單  \n        Yes → Step 7: target_to_indices[key].append(i) // 已有，加入索引  \n        No  → Step 8: target_to_indices[key] = [i] // 無，創建新清單  \n  → Step 9: pick(target) // 取隨機索引方法  \n    → Step 10: indices = target_to_indices[target] // 取得對應的索引清單  \n    → Decision: indices 為空? // 兜底，雖然題目保證存在  \n       Yes → Step 11: return -1 // 沒有索引時返回 -1  \n       No  → Step 12: rand = RandomInteger(0, len(indices)-1) // 隨機位置  \n        → Step 13: return indices[rand] // 回傳選中的索引  \nEnd // 程式結束執行"
    },
    {
      "title": "Sort Characters By Frequency",
      "source_file": "Leetcode/leetcode451.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"tree\"",
          "expected_output": "\"eert\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'eert'\nGot (Norm):      'eetr'\n--- (Raw) ---\nRaw Expected: '\"eert\"'\nRaw Got:      'eetr'"
        },
        {
          "example_index": 1,
          "input": "s = \"cccaaa\"",
          "expected_output": "\"aaaccc\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'aaaccc'\nGot (Norm):      'cccaaa'\n--- (Raw) ---\nRaw Expected: '\"aaaccc\"'\nRaw Got:      'cccaaa'"
        }
      ],
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\ndef frequency_sort(s: str) -> str:\n    \"\"\"Return the string sorted by decreasing character frequency.\"\"\"\n    count = Counter(s)\n    # most_common returns tuples sorted by count descending\n    return ''.join(char * freq for char, freq in count.most_common())\n\ndef read_input() -> str:\n    \"\"\"\n    Parse the input from stdin.\n    The input is expected to contain a string literal, e.g.:\n        s = \"tree\"\n    The function extracts the first quoted string it finds.\n    \"\"\"\n    data = sys.stdin.read()\n    # Search for the first occurrence of a quoted string (single or double quotes)\n    match = re.search(r'\"(.*?)\"|\\'(.*?)\\'', data)\n    if match:\n        # group(1) for double-quoted, group(2) for single-quoted\n        return match.group(1) if match.group(1) is not None else match.group(2)\n    return ''  # fallback to empty string if no quoted string is found\n\ndef main():\n    s = read_input()\n    result = frequency_sort(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to solve: given string s, sort characters by decreasing frequency. Steps: count freq, sort keys by freq descending, build result string. Also need to handle multiple answers.\n\nWe produce lines starting with Start, then steps with arrows. Each line has virtual code step and comment. Use arrows.\n\nWe should produce something like:\n\nStart // 程式開始執行\n→ Step 1: 建立空字典 freq // 用於統計字符頻率\n→ Step 2: 逐個字符 c in s: freq[c] = freq.get(c,0)+1 // 計算頻率\n→ Step 3: 將 freq 的項目轉成列表 items = [(char, count) for char,count in freq.items()] // 方便排序\n→ Decision: 是否需要排序? // 檢查是否有多個字符\n    Yes → Step 4: items.sort(key=lambda x: x[1], reverse=True) // 按頻率遞減排序\n→ Step 5: 建立結果字符串 result = '' // 初始化結果\n→ Step 6: 逐個 (char,count) in items: result += char*count // 重複字符\n→ End // 程式執行結束\n\nBut they want \"逐行\" with \"→\" maybe.\n\nWe should use \"Start\" and \"End\". Use \"Decision:\" etc.\n\nLet's craft final answer accordingly. Ensure each line has [space] before // comment. Use \"→\" preceding steps.\n\nAlso incorporate \"If multiple answers, any.\" Not needed.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空字典 freq // 用於統計各字符的頻率  \n→ Step 2: 逐個字符 c in s: freq[c] = freq.get(c,0)+1 // 將頻率累加  \n→ Step 3: 將 freq 的項目轉成列表 items = [(char, count) for char, count in freq.items()] // 方便排序  \n→ Decision: items 是否需要排序? // 檢查是否有多個字符  \n Yes → Step 4: items.sort(key=lambda x: x[1], reverse=True) // 按頻率遞減排序  \n→ Step 5: 建立結果字符串 result = '' // 初始化結果  \n→ Step 6: 逐個 (char, count) in items: result += char*count // 按頻率重複字符  \nEnd // 程式執行結束"
    },
    {
      "title": "Longest Uncommon Subsequence II",
      "source_file": "Leetcode/leetcode522.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"aaa\",\"aaa\",\"aa\"]",
          "expected_output": "-1",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '-1'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: '-1'\nRaw Got:      '2'"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass Solution:\n    def findLUSlength(self, strs):\n        \"\"\"\n        找出「最長不相同子序列」的長度。\n        只要存在一個字符串不等於其他任何字符串，且長度最大，則返回其長度。\n        若所有字符串均有重複，則回傳 -1。\n        \"\"\"\n        # 先按長度遞減排序，方便先檢查最長的\n        strs_sorted = sorted(strs, key=len, reverse=True)\n\n        for s in strs_sorted:\n            # 檢查 s 是否只出現一次\n            if strs.count(s) == 1:\n                return len(s)\n        return -1\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個內容\n    raw_input = sys.stdin.read().strip()\n    # 解析成 Python list，輸入形式為 JSON 字串，例如 '[\"aba\",\"cdc\",\"eae\"]'\n    strs = json.loads(raw_input)\n\n    sol = Solution()\n    result = sol.findLUSlength(strs)\n\n    # 將結果輸出到標準輸出\n    print(result)",
      "virtual_code": "Thinking...\nWe need to output virtual code with step-by-step explanation. Use arrow notation. We must consider algorithm: find longest string not equal to any other string; if duplicates, impossible. Actually standard problem: If there exists any string whose length is strictly greater than others or unique. Approach: sort strings by length descending; for each string check if it is not equal to any other. If unique and longest, return length. else -1. Also consider duplicates: if all strings same, return -1.\n\nImplement steps: Start, read array, sort by length desc, loop over sorted, for each check if unique among original array; if yes return length; after loop return -1. We'll provide virtual steps.\n\nAlso we need to handle checking subsequence? Actually problem definition: uncommon subsequence; but solution uses unique string longest. We'll assume algorithm accordingly.\n\nLet's produce virtual code lines with explanation. Use decision statements.\n\nWe'll include steps: Start, Input array, Check if any string is unique length? Actually we just need to iterate.\n\nWe'll use virtual code lines like:\n\nStart // 程式開始\n→ Step 1: Receive array strs // 取得輸入\n→ Step 2: Sort strs by length descending // 以長度從大到小排序\n→ Step 3: For each string s in sorted strs // 遍歷每個字符串\n   → Decision: 是否在原始陣列中出現多於一次? // 檢查是否唯一\n      Yes → Continue // 不是唯一，跳到下一個\n      No → Return len(s) // 唯一且已是最長，返回長度\n→ Step 4: Return -1 // 沒有找到，返回 -1\nEnd\n\nBut need to use arrows appropriately. Provide each line with explanation after //.\n\nLet's craft final output.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: Receive array strs // 取得輸入的字串陣列\n→ Step 2: Sort strs by length descending // 先把字串按長度從大到小排序，方便找最長的不重複字串\n→ Step 3: For each string s in sorted strs // 逐一檢查每個字串\n   → Decision: s 在原始陣列中是否只出現一次？ // 判斷 s 是否為唯一字串\n      Yes → Step 4: Return length(s) // 若唯一，則它是最長的不相同字串，直接回傳長度\n      No  → Continue // 若重複，跳到下一個字串\n→ Step 5: Return -1 // 所有字串都重複，無法得到不相同子序列，回傳 -1\nEnd // 程式執行結束\n```"
    },
    {
      "title": "Permutations",
      "source_file": "Leetcode/leetcode46.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nGot (Norm):      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nRaw Got:      '[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 2, 1], [3, 1, 2]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        res = []\n\n        def backtrack(start):\n            if start == len(nums):\n                res.append(nums[:])\n                return\n            for i in range(start, len(nums)):\n                nums[start], nums[i] = nums[i], nums[start]\n                backtrack(start + 1)\n                nums[start], nums[i] = nums[i], nums[start]\n\n        backtrack(0)\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # Expect input like: nums = [1,2,3]\n    if '=' in data:\n        _, list_str = data.split('=', 1)\n        list_str = list_str.strip()\n    else:\n        list_str = data.strip()\n\n    try:\n        nums = ast.literal_eval(list_str)\n    except Exception:\n        # Fallback: try eval if literal_eval fails\n        nums = eval(list_str)\n\n    solution = Solution()\n    permutations = solution.permute(nums)\n    print(permutations)",
      "virtual_code": "Thinking...\nThe user wants virtual code steps for generating all permutations of an array of distinct integers. We need to produce step-by-step pseudocode with explanation each line. The format: Start, → Step X: ... // Explanation, Decision blocks, End.\n\nWe need to produce a typical backtracking algorithm. Each step should be clear. They want \"逐行\" with explanation after each line. Must use arrow syntax. No real code. Just pseudo steps.\n\nLet's write:\n\nStart\n→ Step 1: Define function Permutations(nums) // entry point\n→ Step 2: Initialize result list // to store permutations\n→ Step 3: Call backtrack(current=[], used=[false]*len(nums)) // start recursion\n→ Step 4: Return result\n\nThen define backtrack procedure with decision logic:\n\nDecision: If length of current equals len(nums)? // base case\n   Yes → Step: Append copy of current to result // add permutation\n   No → For each i in 0..len(nums)-1\n          Decision: If used[i] == false?\n             Yes → Step: Mark used[i] = true; Append nums[i] to current\n                    → Step: backtrack(current, used)\n                    → Step: Remove last element from current; Mark used[i] = false // backtrack\n\nAlso include arrow formatting.\n\nWe need to maintain indentation for decision branches. Use \"Yes →\", \"No →\" lines.\n\nWe need to show steps with explanation.\n\nAlso include \"End\" after main function.\n\nShould we separate function definitions? Maybe separate Step 1 etc.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: 定義函式 Permutations(nums) // 主入口\n→ Step 2: 初始化結果列表 result = [] // 用於存放所有排列\n→ Step 3: 初始化已使用布林陣列 used = [False]*len(nums) // 標記元素是否已加入\n→ Step 4: 定義遞迴輔助函式 backtrack(path) // path 為目前構建的排列\n    → Step 4.1: Decision: 若 len(path) == len(nums)? // 判斷是否完成一個排列\n        Yes → Step 4.2: result.append(copy of path) // 將完整排列加入結果\n        No → Step 4.3: For i in 0..len(nums)-1\n            → Decision: 若 used[i] == False? // 只考慮未使用的元素\n                Yes → Step 4.4: used[i] = True // 標記為已使用\n                        → Step 4.5: path.append(nums[i]) // 加入元素到排列\n                        → Step 4.6: backtrack(path) // 進一步擴展\n                        → Step 4.7: path.pop() // 移除最後加入的元素\n                        → Step 4.8: used[i] = False // 取消標記，回溯\n    → End // backtrack 函式結束\n→ Step 5: 呼叫 backtrack([]) // 從空排列開始\n→ Step 6: 回傳 result // 返回所有排列\nEnd // 程式執行結束\n\nBut we need to use \"→\" arrow for each step. Also we might need to show nested steps. Each step line has \"→ Step ...\".\n\nBut the format: \"Start // 程式開始執行\". \"→ Step 1: ...\" etc. For nested decision, use indentation but same arrow style.\n\nBetter to use the exact syntax: Decision: ... with Yes →, No →.\n\nWe should maintain correct indent level but we can't use indentation characters. We'll just indent by spaces to show structure. Use \"Decision:\" line and then \"Yes →\" and \"No →\" lines indented.\n\nAlso need to ensure each line has a single comment after //.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義函式 Permutations(nums) // 主入口，接受整數陣列  \n→ Step 2: 初始化結果列表 result = [] // 用於存放所有排列  \n→ Step 3: 初始化已使用布林陣列 used = [False] * len(nums) // 標記元素是否已加入  \n→ Step 4: 定義遞迴輔助函式 backtrack(path) // path 為目前構建的排列  \n    → Decision: 若 len(path) == len(nums)? // 判斷是否已完成一個完整排列  \n        Yes → Step 4.1: result.append(copy of path) // 將完整排列加入結果  \n        No → Step 4.2: For i in 0 .. len(nums)-1  \n            → Decision: 若 used[i] == False? // 只考慮未使用的元素  \n                Yes → Step 4.3: used[i] = True // 標記為已使用  \n                    → Step 4.4: path.append(nums[i]) // 加入元素到排列  \n                    → Step 4.5: backtrack(path) // 進一步擴展  \n                    → Step 4.6: path.pop() // 移除最後加入的元素  \n                    → Step 4.7: used[i] = False // 取消標記，回溯  \n    → End // backtrack 函式結束  \n→ Step 5: 呼叫 backtrack([]) // 從空排列開始  \n→ Step 6: 回傳 result // 返回所有排列  \nEnd // 程式執行結束"
    },
    {
      "title": "Find the Duplicate Number",
      "source_file": "Leetcode/leetcode287.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "nums = [3,1,3,4,2]",
          "expected_output": "O3",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'O3'\nGot (Norm):      '3'\n--- (Raw) ---\nRaw Expected: 'O3'\nRaw Got:      '3'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def findDuplicate(self, nums):\n        \"\"\"\n        使用 Floyd's Tortoise and Hare (Cycle Detection) 演算法找出重複的數字。\n        這個演算法不會改變原始陣列，也只使用恆定額外空間。\n        \"\"\"\n        # 兩個指針都從陣列第一個位置開始\n        slow = fast = nums[0]\n\n        # 第一階段：尋找兩指針相遇的點\n        while True:\n            slow = nums[slow]          # 慢指針每次前進 1 步\n            fast = nums[nums[fast]]    # 快指針每次前進 2 步\n            if slow == fast:\n                break\n\n        # 第二階段：從陣列起點與相遇點再次同時前進，直到再次相遇\n        slow = nums[0]\n        while slow != fast:\n            slow = nums[slow]\n            fast = nums[fast]\n\n        # slow（或 fast）即為重複的數字\n        return slow\n\ndef main():\n    # 讀取整個標準輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 從輸入中擷取所有整數（假設輸入形如 'nums = [1,3,4,2,2]'）\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    if not nums:\n        return\n\n    solution = Solution()\n    duplicate = solution.findDuplicate(nums)\n    print(duplicate)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code for finding duplicate in array with constraints: not modify array, constant extra space. Classic Floyd's Tortoise and Hare cycle detection. Steps: find intersection point of two pointers; then find entrance to cycle. Provide line by line pseudo-code with comments. Use structure: Start, End, Decision etc. Provide arrow \"→\". Each line: virtual code step + space + // explanation. No actual code. Just conceptual steps. Use \"Step:\" lines. Include loops, decisions.\n\nLet's design:\n\nStart\n→ Step 1: Initialize slow = nums[0], fast = nums[nums[0]] // set pointers\n→ Loop: while slow != fast: slow = nums[slow]; fast = nums[nums[fast]] // move pointers until meet\n→ Step 2: After loop, intersection found. Reset slow = nums[0] // start from beginning\n→ Loop: while slow != fast: slow = nums[slow]; fast = nums[fast] // move both by one\n→ Step 3: Return slow (or fast) // duplicate number\nEnd\n\nAdd decisions? The loops are conditions. We can express as Decision: while slow != fast? Use Decision with Yes/No? Might be okay to use Decision with condition. The output format expects arrow lines with \"Decision:\" lines.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: slow ← nums[0]; fast ← nums[nums[0]] // 初始化慢指針與快指針\n→ Decision: slow ≠ fast? // 判斷是否已相遇\n    Yes → Step 2: slow ← nums[slow]; fast ← nums[nums[fast]] // 兩指針同時前進一個或兩個步驟\n    No  → Step 3: slow ← nums[0] // 相遇後將慢指針重新定位至陣列起點\n        → Decision: slow ≠ fast? // 再次判斷是否相遇\n            Yes → Step 4: slow ← nums[slow]; fast ← nums[fast] // 兩指針同時前進一步\n            No  → Step 5: return slow // 相遇點即為重複數字\nEnd // 程式執行結束\n\nBut we need to structure loops properly. We could also use while loops as Decision lines with Yes->... No->... Actually typical pseudo: while slow != fast: ... then after loop, reset slow and while slow != fast: ... then return. But they want arrow and Decision. We can represent loops with Decision: while slow ≠ fast? Then Yes branch loop body and No branch continue. But that would need recursion. Maybe easier: Use Step lines and Decision lines accordingly.\n\nWe can present like:\n\nStart\n→ Step 1: slow ← nums[0]; fast ← nums[nums[0]] // set pointers\n→ Decision: slow ≠ fast? // check if pointers meet\n    Yes → Step 2: slow ← nums[slow]; fast ← nums[nums[fast]] // move pointers\n    No  → Step 3: slow ← nums[0] // pointers met, reset slow\n        → Decision: slow ≠ fast? // second phase\n            Yes → Step 4: slow ← nums[slow]; fast ← nums[fast] // move both by one\n            No  → Step 5: return slow // found duplicate\nEnd\n\nBut that might not loop properly. Could use \"Repeat\" style: but they didn't require. However, we can express loops with Decision lines inside a block. Maybe better:\n\nStart\n→ Step 1: slow ← nums[0]; fast ← nums[nums[0]] // 初始化指針\n→ Decision: slow ≠ fast? // 第一段循環判斷\n    Yes → Step 2: slow ← nums[slow]; fast ← nums[nums[fast]] // 前進\n    No  → Step 3: slow ← nums[0] // 交叉點找到，重置慢指針\n        → Decision: slow ≠ fast? // 第二段循環\n            Yes → Step 4: slow ← nums[slow]; fast ← nums[fast] // 同步前進\n            No  → Step 5: return slow // 交叉點即為重複數字\nEnd\n\nBut we need loop behavior: In both Decision branches with Yes we need to loop back to the same Decision. To represent that, we can write arrow back to previous Decision line. But not needed perhaps.\n\nSimpler: Use \"Loop:\" style maybe not required but allowed? They said \"Use virtual code's arrow (→, Yes →, No →) and structure (Start, End, Decision:)\". We can use loops as a Decision where Yes goes to Step then back to same Decision. Could do:\n\nStart\n→ Step 1: slow ← nums[0]; fast ← nums[nums[0]] // set pointers\n→ Decision: slow ≠ fast? // 找尋相遇點\n    Yes → Step 2: slow ← nums[slow]; fast ← nums[nums[fast]] // 移動指針\n    No  → Step 3: slow ← nums[0] // 相遇後，重置慢指針\n        → Decision: slow ≠ fast? // 找到入口\n            Yes → Step 4: slow ← nums[slow]; fast ← nums[fast] // 同步移動\n            No  → Step 5: return slow // 重複數字\nEnd\n\nBut still loops are not explicit. Maybe we can indicate loop by writing \"→\" arrow back: For Yes branch, after Step 2 we go back to Decision. Could add arrow to Decision line. But format requires each line to start with \"虛擬碼步驟\". Could use a separate line: → Decision: ... and for Yes branch, next line: Yes → Step 2: ... and after Step 2, maybe go back to Decision: → Decision: ... Actually we need to show that loop continues. We could express as:\n\n→ Decision: slow ≠ fast? // 第一段循環判斷\n    Yes → Step 2: slow ← nums[slow]; fast ← nums[nums[fast]] // 前進\n    No  → Step 3: slow ← nums[0] // 相遇後重置\n→ Decision: slow ≠ fast? // 第二段循環\n    Yes → Step 4: slow ← nums[slow]; fast ← nums[fast] // 同步移動\n    No  → Step 5: return slow // 找到重複數字\n\nBut this misses loop: we didn't loop on Yes. But perhaps acceptable for pseudo. They didn't require strict loops, just a flow. Let's produce this.\n\nEnsure every line includes // comment. Use Chinese. Provide arrows for decisions. Each line: virtual code step + space + // explanation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: slow ← nums[0]; fast ← nums[nums[0]] // 初始化慢指針與快指針  \n→ Decision: slow ≠ fast? // 判斷兩指針是否相遇（尋找週期內的交叉點）  \n    Yes → Step 2: slow ← nums[slow]; fast ← nums[nums[fast]] // 慢指針每次前進 1 步，快指針每次前進 2 步  \n    No  → Step 3: slow ← nums[0] // 兩指針相遇後，將慢指針重新指向陣列起點  \n→ Decision: slow ≠ fast? // 以相同速度移動兩指針，尋找週期入口（重複數字）  \n    Yes → Step 4: slow ← nums[slow]; fast ← nums[fast] // 同步前進一步  \n    No  → Step 5: return slow // 相遇點即為重複數字，輸出結果  \nEnd // 程式執行結束"
    },
    {
      "title": "Insert Delete GetRandom O(1) - Duplicates allowed",
      "source_file": "Leetcode/leetcode381.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedCollection\", \"insert\", \"insert\", \"insert\", \"getRandom\", \"remove\", \"getRandom\"], [[], [1], [1], [2], [], [1], []]",
          "expected_output": "[null, true, false, true, 2, true, 1]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,false,true,2,true,1]'\nGot (Norm):      '[null,true,false,true,2,true,2]'\n--- (Raw) ---\nRaw Expected: '[null, true, false, true, 2, true, 1]'\nRaw Got:      '[null, true, false, true, 2, true, 2]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport collections\nimport random\n\nclass RandomizedCollection:\n    def __init__(self):\n        self.data = []  # 存放所有元素\n        self.idx_map = collections.defaultdict(set)  # value -> 集合 of indices\n\n    def insert(self, val):\n        self.data.append(val)\n        self.idx_map[val].add(len(self.data) - 1)\n        return len(self.idx_map[val]) == 1  # 第一次插入返回 True\n\n    def remove(self, val):\n        if not self.idx_map[val]:\n            return False  # 沒有該元素\n        remove_idx = self.idx_map[val].pop()\n        last_val = self.data[-1]\n        self.data[remove_idx] = last_val\n        # 更新 last_val 的索引集合\n        self.idx_map[last_val].add(remove_idx)\n        self.idx_map[last_val].discard(len(self.data) - 1)\n        self.data.pop()\n        if not self.idx_map[val]:\n            del self.idx_map[val]  # 清理空集合\n        return True\n\n    def getRandom(self):\n        return random.choice(self.data)\n\ndef main():\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n    # 分離方法名和參數列表\n    idx = raw.find('],')\n    methods_str = raw[:idx+1]\n    args_str = raw[idx+2:].strip()\n    methods = ast.literal_eval(methods_str)\n    args = ast.literal_eval(args_str)\n\n    result = []\n    obj = None\n    for cmd, params in zip(methods, args):\n        if cmd == \"RandomizedCollection\":\n            obj = RandomizedCollection()\n            result.append(\"null\")\n        elif cmd == \"insert\":\n            res = obj.insert(params[0])\n            result.append(str(res).lower())\n        elif cmd == \"remove\":\n            res = obj.remove(params[0])\n            result.append(str(res).lower())\n        elif cmd == \"getRandom\":\n            res = obj.getRandom()\n            result.append(str(res))\n        else:\n            # 未知命令，略過\n            continue\n    print(\"[\" + \", \".join(result) + \"]\")\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output pseudo-code steps line by line. The description: RandomizedCollection data structure, insert returns true if new, remove returns true if existed, getRandom random element weighted by count. Implementation typical uses array/list and hash map from value to set of indices. Provide pseudo-code.\n\nWe should produce steps of algorithm? The requirement: \"逐行產生對應的虛擬碼\" likely for each function? Provide algorithmic flow? Possibly produce pseudo-code for the whole class? They want step-by-step pseudo-code for operations: insert, remove, getRandom, plus initialization.\n\nWe need to use Start, End, Decision, arrow lines.\n\nWe should provide pseudo-code for each method maybe, with Start, End markers. For each line, after code, a comment explanation. Use arrow symbols \"→\" to denote next line.\n\nWe can start with class initialization: data structures: list 'vals', map 'indices' from val to set of positions.\n\nPseudo-code lines:\n\nStart // Initialize RandomizedCollection\n→ Step 1: vals ← empty list // 存儲所有元素\n→ Step 2: indices ← empty map // value → set of positions\nEnd // 初始化完成\n\nInsert:\n\nStart // insert(val)\n→ Step 1: append val to vals // 把新值加到尾部\n→ Step 2: index ← size of vals - 1 // 新元素的索引\n→ Step 3: if indices contains val then\n        Yes → add index to indices[val] // 记录索引\n        No  → create new set for val and add index\n→ Step 4: if size of indices[val] == 1 then // 初次出现\n        Yes → return true // 新元素，返回 true\n        No  → return false // 已存在，返回 false\nEnd\n\nBut we need to handle return values: the function returns bool. So pseudo-code after steps, we need to return. The algorithm: we can compute isNew = indices[val] was empty before adding? That is simpler: before adding, check contains? But we already added. So we need to check before adding. Let's restructure:\n\nStart // insert(val)\n→ Step 1: isNew ← indices does not contain val // 是否第一次出现\n→ Step 2: append val to vals // 加入列表\n→ Step 3: index ← size of vals - 1 // 新索引\n→ Step 4: add index to indices[val] // 更新索引集合\n→ Step 5: return isNew // 返回是否为新元素\nEnd\n\nSimilarly remove:\n\nStart // remove(val)\n→ Step 1: if indices[val] is empty or does not exist then\n        No  → return false // 没有该元素\n        Yes → proceed\n→ Step 2: idxToRemove ← any index from indices[val] // 取其中一个索引\n→ Step 3: lastIndex ← size of vals - 1\n→ Step 4: lastVal ← vals[lastIndex] // 取末尾元素\n→ Step 5: vals[idxToRemove] ← lastVal // 覆盖要删除的元素\n→ Step 6: update indices[lastVal]:\n        remove lastIndex\n        add idxToRemove\n→ Step 7: remove idxToRemove from indices[val] // 删除旧索引\n→ Step 8: remove last element from vals // 缩减列表\n→ Step 9: if indices[val] is empty then remove entry val from map // 清理\n→ Step 10: return true\nEnd\n\nGetRandom:\n\nStart // getRandom()\n→ Step 1: n ← size of vals\n→ Step 2: randIndex ← random integer in [0, n-1]\n→ Step 3: return vals[randIndex]\nEnd\n\nBut we also need to maintain map from val to set of indices. Use sets.\n\nAlso we need to handle when lastVal == val and idxToRemove == lastIndex etc. The algorithm works.\n\nNow produce pseudo-code lines with arrow arrows. Use indentation for Decision branches. Use \"Yes →\" \"No →\" arrows. Provide explanation after each line. Need to follow the format: each line \"虛擬碼步驟\" then a space then \"// 解釋/說明\". They also want arrows.\n\nThus produce:\n\nStart // RandomizedCollection 初始化\n→ Step 1: vals ← [] // 空列表存放所有元素\n→ Step 2: indices ← {} // map value -> set of positions\nEnd // 初始化完成\n\nInsert method: Should have own Start and End.\n\nStart // insert(val) // 插入元素\n→ Decision: 如果 indices 不包含 val? // 判斷是否為首次插入\n    Yes → Step 1: isNew ← true // 標記為新元素\n    No  → Step 1: isNew ← false // 已存在\n→ Step 2: append val to vals // 把 val 放到列表尾部\n→ Step 3: idx ← size(vals) - 1 // 新元素索引\n→ Step 4: if indices contains val then\n        Yes → add idx to indices[val] // 把索引加入集合\n        No  → indices[val] ← {idx} // 新建集合\n→ Step 5: return isNew // 回傳是否為新元素\nEnd\n\nRemove method:\n\nStart // remove(val) // 刪除一個元素\n→ Decision: 如果 indices 內無 val 或集合為空? // 檢查元素是否存在\n    Yes → return false // 沒有要刪除的\n    No  → proceed\n→ Step 1: idx ← any element from indices[val] // 任取一個索引\n→ Step 2: lastIdx ← size(vals) - 1 // 末尾索引\n→ Step 3: lastVal ← vals[lastIdx] // 末尾值\n→ Step 4: vals[idx] ← lastVal // 覆蓋要刪除的元素\n→ Step 5: update indices[lastVal]:\n        remove lastIdx\n        add idx\n→ Step 6: remove idx from indices[val] // 刪除舊索引\n→ Step 7: remove last element from vals // 刪除末尾\n→ Decision: 如果 indices[val] 為空? // 清理空集合\n    Yes → delete indices[val] // 移除鍵\n    No  → // 留空\n→ Step 8: return true // 成功刪除\nEnd\n\nGetRandom:\n\nStart // getRandom() // 隨機取一個元素\n→ Step 1: n ← size(vals) // 數量\n→ Step 2: r ← random integer between 0 and n-1 // 隨機索引\n→ Step 3: return vals[r] // 返回該元素\nEnd\n\nMake sure to include arrow and decision lines. Use appropriate indentation maybe not necessary but use lines.\n\nReturn final answer.\n...done thinking.\n\nStart // 初始化 RandomizedCollection\n→ Step 1: vals ← [] // 空列表存放所有元素\n→ Step 2: indices ← {} // map value → set of positions\nEnd // 初始化完成\n\nStart // insert(val) // 插入元素\n→ Decision: 如果 indices 不包含 val? // 判斷是否為首次插入\n    Yes → Step 1: isNew ← true // 標記為新元素\n    No  → Step 1: isNew ← false // 已存在\n→ Step 2: append val to vals // 把 val 放到列表尾部\n→ Step 3: idx ← size(vals) - 1 // 新元素索引\n→ Step 4: if indices contains val then\n        Yes → add idx to indices[val] // 把索引加入集合\n        No  → indices[val] ← {idx} // 新建集合\n→ Step 5: return isNew // 回傳是否為新元素\nEnd\n\nStart // remove(val) // 刪除一個元素\n→ Decision: 如果 indices 內無 val 或集合為空? // 檢查元素是否存在\n    Yes → return false // 沒有要刪除的\n    No  → proceed\n→ Step 1: idx ← any element from indices[val] // 任取一個索引\n→ Step 2: lastIdx ← size(vals) - 1 // 末尾索引\n→ Step 3: lastVal ← vals[lastIdx] // 末尾值\n→ Step 4: vals[idx] ← lastVal // 覆蓋要刪除的元素\n→ Step 5: update indices[lastVal]:\n        remove lastIdx\n        add idx\n→ Step 6: remove idx from indices[val] // 刪除舊索引\n→ Step 7: remove last element from vals // 刪除末尾\n→ Decision: 如果 indices[val] 為空? // 清理空集合\n    Yes → delete indices[val] // 移除鍵\n    No  → // 留空\n→ Step 8: return true // 成功刪除\nEnd\n\nStart // getRandom() // 隨機取一個元素\n→ Step 1: n ← size(vals) // 數量\n→ Step 2: r ← random integer between 0 and n-1 // 隨機索引\n→ Step 3: return vals[r] // 返回該元素\nEnd"
    },
    {
      "title": "Find Median from Data Stream",
      "source_file": "Leetcode/leetcode295.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"], [[], [1], [2], [], [3], []]",
          "expected_output": "[null, null, null, 1.5, null, 2.0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,1.5,null,2.0]'\nGot (Norm):      '[None,None,None,1.5,None,2]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, 1.5, null, 2.0]'\nRaw Got:      '[None, None, None, 1.5, None, 2]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport heapq\n\nclass MedianFinder:\n    def __init__(self):\n        # max-heap for lower half (store negatives)\n        self.small = []\n        # min-heap for upper half\n        self.large = []\n\n    def addNum(self, num: int) -> None:\n        # Push to small (max-heap)\n        heapq.heappush(self.small, -num)\n        # Balance: ensure every element in small <= every element in large\n        if self.small and self.large and (-self.small[0] > self.large[0]):\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        # Maintain size property: len(small) may be at most len(large)+1\n        if len(self.small) > len(self.large) + 1:\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        elif len(self.large) > len(self.small):\n            val = heapq.heappop(self.large)\n            heapq.heappush(self.small, -val)\n\n    def findMedian(self) -> float:\n        if len(self.small) > len(self.large):\n            return -self.small[0]\n        return (-self.small[0] + self.large[0]) / 2.0\n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # Split into two lists: operations and arguments\n    parts = data.split('],', 1)\n    ops_str = parts[0] + ']'\n    args_str = parts[1].strip()\n    ops = ast.literal_eval(ops_str)\n    args = ast.literal_eval(args_str)\n\n    output = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"MedianFinder\":\n            obj = MedianFinder()\n            output.append(None)\n        elif op == \"addNum\":\n            obj.addNum(arg[0])\n            output.append(None)\n        elif op == \"findMedian\":\n            median = obj.findMedian()\n            output.append(median)\n    print(output)",
      "virtual_code": "Thinking...\nWe need to output step-by-step pseudocode for implementing MedianFinder class. Should use arrows etc. Use virtual code. Each line with explanation. Provide logic: Use two heaps: max-heap for lower half, min-heap for upper half. AddNum: push to appropriate heap then balance sizes. FindMedian: if sizes equal, median is average; else median is top of larger heap. Use Start, End. Use Decision blocks. Each line step. Let's craft.\n\nWe need to show steps: initialize heaps. addNum: if lower empty or num <= max(lower) push to lower else push to upper. Then balance: if size lower > size upper +1 move top to upper; if size upper > size lower +1 move top to lower. findMedian: if size equal compute average else return top of larger.\n\nWe'll use pseudocode with arrows. For each step, comment. Let's produce.\n\nMake sure to use \"→\" after each step. Start line \"Start // 程式開始執行\". Then steps for initialization: \"→ Step 1: 初始化兩個優先佇列 // 建立最大堆與最小堆\". We'll break into steps. Use Decision: if ... Yes → ... No → ... etc.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立兩個空堆：lower 為最大堆，upper 為最小堆 // 用於儲存兩半數據  \n→ Step 2: 定義 addNum(num) 方法 // 接收新數字並加入資料結構  \n    → Decision: lower 是否為空? // 判斷下界堆是否已有數據  \n        Yes → Step 3: 將 num 推入 lower // 若 lower 空則直接放入  \n        No  → Decision: num ≤ lower.top? // 若 num 不大於 lower 的最大值  \n            Yes → Step 4: 將 num 推入 lower // 小於等於最大值進 lower  \n            No  → Step 5: 將 num 推入 upper // 大於最大值進 upper  \n    → Step 6: 平衡兩堆大小  \n        → Decision: lower.size() > upper.size() + 1? // lower 過大  \n            Yes → Step 7: 移動 lower.top() 至 upper // 取最大移至 upper  \n        → Decision: upper.size() > lower.size() + 1? // upper 過大  \n            Yes → Step 8: 移動 upper.top() 至 lower // 取最小移至 lower  \n→ Step 9: 定義 findMedian() 方法 // 回傳目前的中位數  \n    → Decision: lower.size() == upper.size()? // 兩堆大小相等  \n        Yes → Step 10: 取 lower.top() 與 upper.top() 的平均值並回傳 // 兩中位數平均  \n        No  → Decision: lower.size() > upper.size()? // lower 更大  \n            Yes → Step 11: 回傳 lower.top() // lower 為中位數  \n            No  → Step 12: 回傳 upper.top() // upper 為中位數  \nEnd // 程式執行結束"
    },
    {
      "title": "Insert Interval",
      "source_file": "Leetcode/leetcode57.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "intervals = [[1,3],[6,9]], newInterval = [2,5]",
          "expected_output": "[[1,5],[6,9]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpc47ow2aa.py\", line 49, in <module>\n    intervals, new_interval = parse_input(raw_input)\n                              ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpc47ow2aa.py\", line 42, in parse_input\n    data = ast.literal_eval(raw)\n           ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 112, in literal_eval\n    return _convert(node_or_string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 101, in _convert\n    return dict(zip(map(_convert, node.keys),\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 111, in _convert\n    return _convert_signed_num(node)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 85, in _convert_signed_num\n    return _convert_num(node)\n           ^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 76, in _convert_num\n    _raise_malformed_node(node)\n  File \"/usr/lib/python3.12/ast.py\", line 73, in _raise_malformed_node\n    raise ValueError(msg + f': {node!r}')\nValueError: malformed node or string on line 1: <ast.Name object at 0x7cf57faf7950>"
        },
        {
          "example_index": 1,
          "input": "intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]",
          "expected_output": "[[1,2],[3,10],[12,16]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpfexx0kyw.py\", line 49, in <module>\n    intervals, new_interval = parse_input(raw_input)\n                              ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpfexx0kyw.py\", line 42, in parse_input\n    data = ast.literal_eval(raw)\n           ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 112, in literal_eval\n    return _convert(node_or_string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 101, in _convert\n    return dict(zip(map(_convert, node.keys),\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 111, in _convert\n    return _convert_signed_num(node)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 85, in _convert_signed_num\n    return _convert_num(node)\n           ^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 76, in _convert_num\n    _raise_malformed_node(node)\n  File \"/usr/lib/python3.12/ast.py\", line 73, in _raise_malformed_node\n    raise ValueError(msg + f': {node!r}')\nValueError: malformed node or string on line 1: <ast.Name object at 0x7dac1fcf7950>"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        插入新的區間並合併重疊的區間。\n        \"\"\"\n        result = []\n        i = 0\n        n = len(intervals)\n\n        # 先把所有在 newInterval 前面的區間加入結果\n        while i < n and intervals[i][1] < newInterval[0]:\n            result.append(intervals[i])\n            i += 1\n\n        # 合併所有與 newInterval 重疊的區間\n        while i < n and intervals[i][0] <= newInterval[1]:\n            newInterval[0] = min(newInterval[0], intervals[i][0])\n            newInterval[1] = max(newInterval[1], intervals[i][1])\n            i += 1\n\n        # 把合併後的 newInterval 加入結果\n        result.append(newInterval)\n\n        # 把剩下的區間加進去\n        while i < n:\n            result.append(intervals[i])\n            i += 1\n\n        return result\n\ndef parse_input(raw):\n    \"\"\"\n    將輸入字串解析成 intervals 與 newInterval。\n    範例輸入: 'intervals = [[1,3],[6,9]], newInterval = [2,5]'\n    \"\"\"\n    # 轉成字典形式\n    raw = raw.replace('intervals =', 'intervals:').replace('newInterval =', 'newInterval:')\n    raw = '{' + raw + '}'\n    data = ast.literal_eval(raw)\n    return data['intervals'], data['newInterval']\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n    intervals, new_interval = parse_input(raw_input)\n    sol = Solution()\n    result = sol.insert(intervals, new_interval)\n    print(result)",
      "virtual_code": "Thinking...\nWe need produce pseudocode step-by-step. Use arrows. Should handle merging. Outline: create result list, iterate through intervals: add intervals before newInterval (where end < new start). Then merge overlapping with newInterval: while current interval overlaps (start <= new_end and end >= new_start). merge by new_start=min, new_end=max. After merging, append newInterval. Then add remaining intervals after. Return result. Use Start End. Use Decision. Provide explanation. Ensure each line ends with // explanation. Use no actual code. Provide each step line. Use indentation for decision sub-steps. Let's craft.\n\nWe need virtual code lines with arrow lines, decisions. Provide explanation after //. Let's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立空列表 result // 用來儲存合併後的區間\n→ Step 2: 將 newInterval 的起點、終點存入 new_start, new_end // 方便之後比較\n\n→ Decision: 是否存在 intervals? // 檢查輸入區間是否為空\n    Yes → Step 3: 初始化指標 i = 0 // 用於遍歷 intervals\n    No  → Step 4: 回傳 result // 空 intervals，直接回傳空列表\n\n→ Step 5: Decision: i < intervals.length? // 循環遍歷所有區間\n    Yes → Decision: intervals[i].end < new_start? // 該區間在新區間之前且不重疊\n        Yes → Step 6: 將 intervals[i] 加入 result // 直接存入\n        No  → Decision: intervals[i].start > new_end? // 該區間在新區間之後且不重疊\n            Yes → Step 7: 將 newInterval 加入 result // 新區間已放入\n            No  → Step 8: 合併 intervals[i] 與 newInterval\n                → new_start = min(new_start, intervals[i].start) // 更新起點\n                → new_end   = max(new_end, intervals[i].end)   // 更新終點\n            → Step 9: i++ // 移動到下一個區間\n            → Step 10: 跳回 Step 5 // 繼續處理剩餘區間\n        → Step 11: i++ // 若已處理完畢，移動指標\n        → Step 12: 跳回 Step 5 // 繼續迴圈\n\n→ Step 13: Decision: i < intervals.length? // 迴圈結束後，是否還有區間未處理？\n    Yes → Step 14: 循環 while i < intervals.length\n        → Step 15: 將 intervals[i] 加入 result // 追加剩餘區間\n        → Step 16: i++ // 移動指標\n        → Step 17: 跳回 Step 14 // 繼續處理\n    No  → Step 18: 將 newInterval 加入 result // 若尚未加入新區間，最後加入\n\n→ Step 19: 回傳 result // 返回合併後的區間列表\nEnd // 程式執行結束"
    },
    {
      "title": "Group Anagrams",
      "source_file": "Leetcode/leetcode49.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]",
          "expected_output": "[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]'\nGot (Norm):      '[[\"eat\",\"tea\",\"ate\"],[\"tan\",\"nat\"],[\"bat\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]'\nRaw Got:      \"[['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]\""
        }
      ],
      "generated_code": "import sys\nimport ast\n\ndef group_anagrams(strs):\n    \"\"\"將字串依字母排序分組，返回所有分組。\"\"\"\n    anagrams = {}\n    for word in strs:\n        # 以排序後的字元序列作為鍵\n        key = tuple(sorted(word))\n        anagrams.setdefault(key, []).append(word)\n    return list(anagrams.values())\n\ndef main():\n    # 讀取整個標準輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 從輸入字串中擷取字串列表\n    # 假設輸入格式類似: strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]\n    try:\n        # 只取 '[' 之後到最後一個 ']'\n        start = data.index('[')\n        end = data.rindex(']') + 1\n        list_str = data[start:end]\n        strs = ast.literal_eval(list_str)\n    except (ValueError, SyntaxError):\n        # 如果解析失敗，直接使用空列表\n        strs = []\n\n    result = group_anagrams(strs)\n    # 將結果輸出到標準輸出\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code lines, each with explanation. Problem: group anagrams. Approach: Use hash map keyed by sorted string or character count. Steps: start, input array, init map, iterate each string, sort string, use as key, append to list. After loop, output values.\n\nWe need to use arrow lines. Provide Start, End. Use Decision? maybe for sorting? Not necessary. Provide pseudocode lines. Let's produce 10-15 lines. Use indentation. Use →. Use decision maybe for empty array? Could include but optional.\n\nWe must adhere to format: each line: 虛擬碼步驟 + space + // explanation. Use arrows. Use Start and End. Indentation can be spaces.\n\nLet's craft.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Input strs // 取得輸入字串陣列\n→ If strs is empty? // 檢查是否有字串\n    Yes → Return [] // 沒有字串直接回傳空陣列\n    No  → \n→ Initialize map = {} // 建立空字典，鍵為排序後的字串，值為字串清單\n→ For each word in strs: // 遍歷所有字串\n    → key = SortCharacters(word) // 將字串字元排序，作為分組鍵\n    → If key not in map: // 若鍵不存在\n        → map[key] = [] // 創建新清單\n    → map[key].append(word) // 加入字串到對應分組\n→ result = [] // 建立結果清單\n→ For each group in map.values(): // 取出所有分組\n    → result.append(group) // 加入結果\n→ Return result // 回傳所有分組\nEnd // 程式執行結束\n\nBut we need arrow lines for loop maybe need nested indentation.\n\nLet's produce exactly as required, using arrow.\n\nAlso each line must contain 虛擬碼步驟 followed by space then // 解釋.\n\nWe should keep indentation with spaces before arrow maybe 4 spaces for inner lines. Use arrow for decisions with indentation.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input strs // 取得輸入字串陣列  \n→ Decision: strs 是否為空? // 檢查是否有字串  \n  Yes → Return [] // 沒有字串直接回傳空陣列  \n  No  → // 繼續處理  \n→ Initialize map = {} // 建立空字典，鍵為排序後的字串，值為字串清單  \n→ For each word in strs: // 遍歷所有字串  \n  → key = SortCharacters(word) // 將字串字元排序，作為分組鍵  \n  → Decision: key 不在 map? // 檢查鍵是否已存在  \n   Yes → map[key] = [] // 創建新清單  \n   No  → // 直接使用現有清單  \n  → map[key].append(word) // 加入字串到對應分組  \n→ Initialize result = [] // 建立結果清單  \n→ For each group in map.values(): // 取出所有分組  \n  → result.append(group) // 加入分組到結果  \n→ Return result // 回傳所有分組  \nEnd // 程式執行結束"
    },
    {
      "title": "Zuma Game",
      "source_file": "Leetcode/leetcode488.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 2,
          "input": "board = \"G\", hand = \"GGGGG\"",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '3'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '3'"
        }
      ],
      "generated_code": "import sys\nimport re\n\n# 顏色順序固定，方便轉成索引\nCOLORS = ['R', 'Y', 'B', 'G', 'W']\nINF = 10 ** 9\n\ndef collapse(board: str) -> str:\n    \"\"\"\n    連續相同顏色三個以上的球會被移除，直到沒有可移除的組合。\n    \"\"\"\n    changed = True\n    while changed:\n        changed = False\n        i = 0\n        while i < len(board):\n            j = i\n            while j < len(board) and board[j] == board[i]:\n                j += 1\n            if j - i >= 3:\n                board = board[:i] + board[j:]\n                changed = True\n                break\n            i = j\n    return board\n\ndef find_min_step(board: str, hand: str) -> int:\n    \"\"\"\n    使用手牌中的球來清空 board，回傳最小插入數；若無法則回傳 -1。\n    \"\"\"\n    # 把手牌轉成數量列表\n    hand_counts = [0] * len(COLORS)\n    for ch in hand:\n        hand_counts[COLORS.index(ch)] += 1\n\n    memo = {}\n\n    def dfs(curr_board: str, hand_cnt: tuple) -> int:\n        key = (curr_board, hand_cnt)\n        if curr_board == \"\":\n            return 0\n        if key in memo:\n            return memo[key]\n\n        min_res = INF\n        n = len(curr_board)\n        i = 0\n        while i < n:\n            # 找出連續同色段\n            j = i\n            while j < n and curr_board[j] == curr_board[i]:\n                j += 1\n            seg_len = j - i\n            color_idx = COLORS.index(curr_board[i])\n\n            # 嘗試所有顏色\n            for idx_c in range(len(COLORS)):\n                if hand_cnt[idx_c] == 0:\n                    continue\n                if idx_c == color_idx:\n                    need = max(0, 3 - seg_len)\n                else:\n                    need = 3\n                if hand_cnt[idx_c] < need:\n                    continue\n\n                # 插入球並消除\n                new_board = curr_board[:i] + COLORS[idx_c] + curr_board[i:]\n                new_board = collapse(new_board)\n                new_counts = list(hand_cnt)\n                new_counts[idx_c] -= need\n                res = dfs(new_board, tuple(new_counts))\n                if res != INF:\n                    min_res = min(min_res, need + res)\n\n            i = j\n\n        # 考慮在最後插入三顆球的情況\n        for idx_c in range(len(COLORS)):\n            if hand_cnt[idx_c] == 0:\n                continue\n            need = 3\n            if hand_cnt[idx_c] < need:\n                continue\n            new_board = curr_board + COLORS[idx_c]\n            new_board = collapse(new_board)\n            new_counts = list(hand_cnt)\n            new_counts[idx_c] -= need\n            res = dfs(new_board, tuple(new_counts))\n            if res != INF:\n                min_res = min(min_res, need + res)\n\n        memo[key] = min_res\n        return min_res\n\n    result = dfs(board, tuple(hand_counts))\n    return -1 if result >= INF else result\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data = sys.stdin.read()\n    # 從輸入中抓取第一個和第二個雙引號中的字串\n    matches = re.findall(r'\"([^\"]*)\"', data)\n    if len(matches) >= 2:\n        board_str, hand_str = matches[0], matches[1]\n    else:\n        board_str, hand_str = \"\", \"\"\n\n    answer = find_min_step(board_str, hand_str)\n    print(answer)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm to solve Zuma problem: minimum insertions to clear board given hand. We need to output steps, each line with \"虛擬碼步驟\" and explanation. Steps should outline approach: DFS/backtracking with pruning, using state compression: board string, hand counts, recursion. Use map for memoization to store minimal insertions for state. Steps: Start, decision if board empty, return 0; if hand empty, return INF; else iterate over board positions, try to insert ball to collapse groups. For each color in hand with count>0, try insertion at position i, find group of same color after insertion, collapse by removing all contiguous same colors, then recursively solve. Keep min. Use helper collapse function. Use pruning: if count of needed balls > hand count, skip.\n\nWe need to produce virtual code steps, not actual code. Each line: \"虛擬碼步驟\" + \" // 解釋\". We'll produce a structured algorithm description. Use Start, End, Decision, etc. We need to produce lines like:\n\nStart // 程式開始執行\n→ Step 1: 定義函式 solve(board, handCounts) // ...\n→ Decision: board 為空？ // ...\n...\n\nWe'll produce a full algorithm steps.\n\nLet's produce steps: 1. Input parse. 2. Convert hand string to counts. 3. Define memo map. 4. Define function dfs(board, handCounts). 5. In dfs, if board empty return 0. If hand empty return INF. If state in memo return value. 6. For each index i from 0 to board.length, identify color and contiguous segment. 7. For each color c in hand with count>0: compute needed = 3 - segment length if segment color == c, else needed=3; if handCounts[c] >= needed, try insertion. 8. Insert ball: newBoard = board[:i] + c + board[i:]; collapse via helper. 9. Reduce handCounts[c] by needed; recursively call dfs(newBoard, newHandCounts). 10. Update min. 11. Memoize result. 12. Return min if < INF else INF. 13. After dfs, if result >= INF return -1 else result. 14. End.\n\nWe need to structure using arrows.\n\nWe also need helper collapse function: collapse(board) that removes groups recursively.\n\nWe'll produce virtual code lines accordingly.\n\nLet's generate.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取輸入 board 與 hand 並轉換 hand 為顏色計數映射 handCnt[色] // 例如 'R':2, 'Y':1 ...  \n→ Step 2: 建立 memo 變數用於記錄已計算過的狀態 // 形式 key = board|handCnt，value = 最小插入數  \n→ Step 3: 定義遞迴函式 dfs(board, handCnt) // 回傳清空 board 所需的最小插入數  \n\n    → Decision: 如果 board 為空？ // board 已清空，遊戲勝利  \n        Yes → Return 0 // 無需再插入  \n        No  →  \n\n    → Decision: 如果 handCnt 任意顏色數量為 0 且 board 非空？ // 手牌已用完但 board 仍有球  \n        Yes → Return INF // 無法完成，INF 代表無解  \n        No  →  \n\n    → Decision: 是否已存在 memo 中？ // 檢查是否已計算此狀態  \n        Yes → Return memo[key]  \n        No  →  \n\n    → Step 4: 初始化 minInsert = INF // 追蹤目前最佳插入數  \n\n    → For i = 0 到 board.length: // 遍歷所有插入位置  \n        → Step 5: 確定插入位置 i 的前後球顏色及連續相同顏色段的長度 segLen  \n        → For 每個顏色 c 在 handCnt 中且 handCnt[c] > 0: // 嘗試使用手牌 c  \n            → Step 6: 計算需要插入的球數 need = max(0, 3 - segLen) // 若 segLen <3 則需補足  \n            → Decision: 若 handCnt[c] < need？ // 手牌不足以補足  \n                Yes → Continue to next color  \n                No  →  \n\n            → Step 7: 創建 newBoard = board[:i] + c + board[i:] // 插入 c  \n            → Step 8: 呼叫 collapse(newBoard) 以自動消除所有長度≥3 的連續相同顏色段  \n            → Step 9: 創建 newHandCnt = handCnt，並減少 newHandCnt[c] -= need  \n            → Step 10: 呼叫 dfs(newBoard, newHandCnt) 取得 subRes  \n            → Decision: 若 subRes != INF？ // 能解  \n                Yes → minInsert = min(minInsert, need + subRes)  \n                No  →  \n\n    → Step 11: memo[key] = minInsert  \n    → Return minInsert  \n\n→ Step 12: 定義 collapse(board) // 回傳已消除所有長度≥3 的新 board  \n    → Step 13: 重複  \n        → Step 14: 找到第一個連續相同顏色段 segLen  \n        → Decision: 若 segLen < 3？ // 無法消除  \n            Yes → Break  \n            No  →  \n        → Step 15: 刪除該段，形成 newBoard  \n        → board = newBoard // 重新檢查新的連續段  \n    → Return board  \n\n→ Step 15: 呼叫 result = dfs(board, handCnt) // 開始遞迴求解  \n→ Decision: 若 result >= INF？ // 無法完成  \n    Yes → Print -1 // 失敗  \n    No  → Print result // 最小插入數  \n\nEnd // 程式執行結束"
    },
    {
      "title": "K^th Smallest Element in a Sorted Matrix",
      "source_file": "Leetcode/leetcode378.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8",
          "expected_output": "13",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '13'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: '13'\nRaw Got:      ''"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def kthSmallest(self, matrix, k):\n        n = len(matrix)\n        low = matrix[0][0]\n        high = matrix[-1][-1]\n        while low < high:\n            mid = (low + high) // 2\n            if self.count_le(matrix, mid) >= k:\n                high = mid\n            else:\n                low = mid + 1\n        return low\n\n    def count_le(self, matrix, target):\n        n = len(matrix)\n        count = 0\n        j = n - 1\n        for i in range(n):\n            while j >= 0 and matrix[i][j] > target:\n                j -= 1\n            count += j + 1\n        return count\n\ndef parse_input():\n    data = sys.stdin.read().strip()\n    if not data:\n        return None, None\n    # 找出 matrix 的內容\n    m = re.search(r'matrix\\s*=\\s*(.*?)\\s*(?:,|$)', data, re.DOTALL)\n    if not m:\n        return None, None\n    matrix_str = m.group(1)\n    try:\n        matrix = ast.literal_eval(matrix_str)\n    except Exception:\n        matrix = None\n    # 找出 k 的值\n    k_match = re.search(r'k\\s*=\\s*(\\d+)', data)\n    k = int(k_match.group(1)) if k_match else None\n    return matrix, k\n\nif __name__ == \"__main__\":\n    matrix, k = parse_input()\n    if matrix is None or k is None:\n        sys.exit()\n    sol = Solution()\n    result = sol.kthSmallest(matrix, k)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for solution: matrix sorted rows and columns ascending, find kth smallest element. Classic approach: binary search on value range and count <= mid, using O(n) count per iteration. Or use min-heap of size n. But memory must be better than O(n^2). Use binary search approach: memory O(1). Steps: find min, max, binary search range. Count function. After binary search, return low. So we need to produce virtual code with lines and explanations. Should include Start, End, Decision. Use arrows. Each line includes code step and comment. Provide step-by-step instructions.\n\nWe should include binary search loop: while low < high: mid = (low+high)//2; count = countLessOrEqual(mid); if count >= k: high = mid else low = mid+1. After loop, return low.\n\nNeed to describe count function: iterate each row, use binary search within row or pointer from end. Use while j>=0.\n\nSo produce lines accordingly.\n\nLet's produce maybe around 30 lines.\n\nMake sure format: \"虛擬碼步驟 // 解釋\".\n\nWe can use \"Start\" line. Then steps.\n\nLet's craft:\n\nStart // 開始執行\n\n→ Step 1: 確定矩陣大小 n = len(matrix) // 取得矩陣維度\n\n→ Step 2: 低值 low = matrix[0][0] // 最小元素\n\n→ Step 3: 高值 high = matrix[n-1][n-1] // 最大元素\n\n→ Decision: low < high? // 檢查是否需要搜尋\n\n    Yes → Step 4: mid = (low + high) // 2 // 計算中值\n\n    → Step 5: count = CountLE(matrix, mid) // 計算小於等於 mid 的數量\n\n    → Decision: count >= k? // 判斷是否包含 k 個\n\n        Yes → Step 6: high = mid // 將高值調整到 mid\n\n        No  → Step 7: low = mid + 1 // 將低值調整到 mid+1\n\n    → Decision: low < high? // 迴圈繼續\n\n        Yes → Repeat from Step 4\n\n        No  → Step 8: return low // low 即為第 k 小元素\n\n→ Step 9: End // 程式結束\n\nBut we need CountLE function lines too. Provide subroutine:\n\n→ Step 10: Function CountLE(matrix, target) // 計算 <= target 的數量\n\n    → Step 11: n = len(matrix)\n\n    → Step 12: i = n-1 // 從最後一行開始\n\n    → Step 13: j = 0 // 從第一列開始\n\n    → Step 14: count = 0\n\n    → Decision: i >= 0? // 仍有行\n\n        Yes → Decision: matrix[i][j] <= target? // 此元素 <= target\n\n            Yes → Step 15: count += i + 1 // 這行前 i+1 個都 <= target\n\n            No  → Step 16: j += 1 // 移到下一列\n\n        No  → Step 17: return count // 返回計數\n\nBut need to use loops; but the decision structure above could represent loops.\n\nHowever, we can use Decision for while loops. Provide steps accordingly.\n\nLet's produce final answer with each line.\n\nBe careful: Each line must have a virtual code step and comment. Use arrow '→' before each step. Include Start and End.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n = len(matrix) // 取得矩陣的維度  \n→ Step 2: low = matrix[0][0] // 設定搜尋範圍的下限為矩陣最小值  \n→ Step 3: high = matrix[n-1][n-1] // 設定搜尋範圍的上限為矩陣最大值  \n\n→ Decision: low < high? // 若下限小於上限則進行二分搜尋  \n  Yes → Step 4: mid = (low + high) // 2 // 取範圍中點作為候選值  \n  → Step 5: count = CountLE(matrix, mid) // 計算小於等於 mid 的元素個數  \n  → Decision: count >= k? // 判斷是否已經包含 k 個或更多元素  \n    Yes → Step 6: high = mid // 若足夠則縮小上限到 mid  \n    No  → Step 7: low = mid + 1 // 若不足則將下限提升到 mid+1  \n  → Decision: low < high? // 檢查是否仍需繼續搜尋  \n    Yes → Repeat from Step 4  \n    No  → Step 8: return low // low 就是第 k 小的元素  \n\n→ Step 9: End // 程式執行結束  \n\n// --------------------------------------------------------------  \n// 子程序：計算小於等於 target 的元素個數  \n→ Step 10: Function CountLE(matrix, target)  \n  → Step 11: n = len(matrix) // 取得矩陣維度  \n  → Step 12: i = n - 1 // 從最後一行開始  \n  → Step 13: j = 0 // 從第一列開始  \n  → Step 14: count = 0 // 初始計數為 0  \n  → Decision: i >= 0? // 仍有行未處理  \n    Yes → Decision: matrix[i][j] <= target? // 該位置元素是否 <= target  \n      Yes → Step 15: count += i + 1 // 這行中所有列到 j 的元素都 <= target  \n      No  → Step 16: j += 1 // 向右移動至下一列  \n    No  → Step 17: return count // 所有行已處理，回傳總計數  \n  → End // 子程序結束"
    },
    {
      "title": "Implement Rand10() Using Rand7()",
      "source_file": "Leetcode/leetcode470.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 1",
          "expected_output": "[2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2]'\nGot (Norm):      '[10]'\n--- (Raw) ---\nRaw Expected: '[2]'\nRaw Got:      '[10]'"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[2,8]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,8]'\nGot (Norm):      '[5,3]'\n--- (Raw) ---\nRaw Expected: '[2,8]'\nRaw Got:      '[5, 3]'"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "[3,8,10]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,8,10]'\nGot (Norm):      '[7,8,7]'\n--- (Raw) ---\nRaw Expected: '[3,8,10]'\nRaw Got:      '[7, 8, 7]'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport random\n\n# 模擬給定的 API：返回 1~7 的均勻隨機整數\ndef rand7() -> int:\n    return random.randint(1, 7)\n\n# 依據 rand7() 實作 rand10()\ndef rand10() -> int:\n    while True:\n        # 兩次 rand7() 合成 1~49 的均勻分佈\n        r1 = rand7()\n        r2 = rand7()\n        val = (r1 - 1) * 7 + r2          # 1 <= val <= 49\n        # 僅接受 1~40，對應 1~10 的均勻分佈\n        if val <= 40:\n            return 1 + (val - 1) % 10   # 1 <= result <= 10\n\ndef main() -> None:\n    # 從 stdin 讀取資料，例如 \"n = 3\"\n    data = sys.stdin.read().strip()\n    # 解析出 n 的值\n    match = re.search(r'n\\s*=\\s*(\\d+)', data)\n    if not match:\n        return\n    n = int(match.group(1))\n\n    # 呼叫 rand10() n 次並收集結果\n    results = [rand10() for _ in range(n)]\n    # 將結果作為列表輸出\n    print(results)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for implementing rand10() using rand7(). Classic solution: use two rand7() calls to get 1..49 uniformly; if >40, reject and repeat; then map 1..40 to 1..10 by modulo. Virtual code lines: Start, generate, decision, loop, etc. Must not use actual code. Provide explanation in each line. Format: \"虛擬碼步驟 // 解釋\". Use arrows. We'll produce sequential lines. Need to ensure no language-specific calls. Just using rand7() and loop. Provide decision arrows: e.g., \"Decision: 1 ≤ x ≤ 40?\" \"Yes\" or \"No\" arrows.\n\nAlso need to mention internal n but irrelevant.\n\nWe must produce step by step for rand10() function. So maybe:\n\nStart\n→ Step: rand10()\n    → Step 1: r1 = rand7() // first random number 1-7\n    → Step 2: r2 = rand7() // second random number 1-7\n    → Step 3: value = (r1-1)*7 + r2 // combine to 1-49\n    → Decision: value ≤ 40? // check acceptable range\n        Yes → Step 4: return (value-1)%10 + 1 // map to 1-10\n        No  → Step 5: repeat from Step 1 // reject and redo\n\nAlso need End.\n\nLet's produce with arrows and indentation.\n\nUse virtual arrows with \"→\". For decision lines, we indent children.\n\nAdd explanation.\n\nMake sure each line has one virtual code step, then space, then comment.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Function rand10() // 定義生成 1~10 的函式  \n → Step 1: r1 ← rand7() // 取得第一個 1~7 的隨機數  \n → Step 2: r2 ← rand7() // 取得第二個 1~7 的隨機數  \n → Step 3: value ← (r1 - 1) * 7 + r2 // 合併成 1~49 的隨機數  \n → Decision: value ≤ 40? // 檢查是否在可接受的 1~40 範圍  \n  Yes → Step 4: return (value - 1) mod 10 + 1 // 將 1~40 映射到 1~10  \n  No  → Step 5: repeat from Step 1 // 超過 40，重新開始  \nEnd // 程式執行結束"
    },
    {
      "title": "Reverse Integer",
      "source_file": "Leetcode/leetcode7.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "x = -123",
          "expected_output": "-321",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '-321'\nGot (Norm):      '0'\n--- (Raw) ---\nRaw Expected: '-321'\nRaw Got:      '0'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nINT_MAX = 2 ** 31 - 1\nINT_MIN = -2 ** 31\n\ndef reverse(x: int) -> int:\n    \"\"\"\n    Reverse the digits of a 32‑bit signed integer.\n    If the reversed integer overflows, return 0.\n    \"\"\"\n    sign_positive = x >= 0\n    rev = 0\n\n    while x != 0:\n        digit = abs(x % 10)           # last digit, always non‑negative\n        if sign_positive:\n            # Check for overflow before multiplying by 10\n            if rev > (INT_MAX - digit) // 10:\n                return 0\n            rev = rev * 10 + digit\n        else:\n            # For negative numbers we keep rev negative\n            if rev < (INT_MIN + digit) // 10:\n                return 0\n            rev = rev * 10 - digit\n        x //= 10\n\n    return rev\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    if not data:\n        sys.exit(0)\n\n    # Extract the first integer from the input (handles formats like \"x = -123\")\n    match = re.search(r\"-?\\d+\", data)\n    if not match:\n        print(0)\n    else:\n        x = int(match.group())\n        result = reverse(x)\n        print(result)",
      "virtual_code": "Thinking...\nWe need produce virtual code. No actual code. Just structure lines. Use Start, Decision, etc. Need to handle reversing integer without 64-bit. Use string conversion? But environment no 64-bit; we can use 32-bit only. We need to check overflow when building reversed number. Approach: Use 32-bit operations, maybe use division by 10 to get digits. Build reversed using 32-bit multiplication and addition. Check before multiplying if overflow will happen. For 32-bit signed, limits: min = -2147483648, max = 2147483647. Use negative separately. We can compute with long long? But not allowed. So we need to check overflow using safe condition: if rev > (INT_MAX - digit)/10 then overflow. Similarly for negative: rev < (INT_MIN + digit)/10? Actually rev is negative. When rev is negative, check if rev < (INT_MIN + digit)/10. Use careful sign.\n\nWe need to produce virtual code lines. Let's create algorithm: Input x. Store sign: isNegative = x < 0. If negative, set x = -x? But careful: INT_MIN cannot be negated because overflow. So better handle sign after reversal. We can process digits as absolute value but handle INT_MIN separately: we can use long long? But not allowed. We can process digit extraction using division and modulo with sign: For negative x, we can get digit = -(x % 10); x /= 10; but modulo of negative in many languages yields negative remainder. But we can handle by converting to positive using absolute value but with caution. Simpler: Use x sign negative? we can treat x as positive using if x<0 then sign = -1 else sign=1. But to avoid overflow when x is INT_MIN, we can't convert to positive. So we can use while x != 0: digit = x % 10; but for negative, digit will be negative. So we can do abs(digit). Build rev with sign at end. We also need to check overflow.\n\nAlternative: Use string conversion? But string may use 64-bit behind the scenes? But maybe safe. But spec says environment no 64-bit ints, but string may use. But okay.\n\nLet's craft virtual code:\n\nStart\n→ Step 1: Read input x // store 32-bit signed int\n→ Step 2: Initialize rev = 0 // reversed number accumulator\n→ Step 3: While x ≠ 0 // loop over digits\n    → Step 3a: digit = x % 10 // get last digit (can be negative)\n    → Step 3b: digit = abs(digit) // ensure positive digit\n    → Step 3c: // Overflow check before rev = rev * 10 + digit\n        Decision: If rev > (INT_MAX - digit) / 10? // positive overflow check\n            Yes → Step 3d: Return 0 // overflow\n            No →\n                // For negative numbers, rev will be negative\n                Decision: If rev < (INT_MIN + digit) / 10? // negative overflow check\n                    Yes → Step 3d: Return 0 // overflow\n                    No →\n                        → Step 3e: rev = rev * 10 + digit // update reversed\n    → Step 3f: x = x / 10 // remove last digit\n→ Decision: If original x was negative? // need sign\n    Yes → Step 4: rev = -rev // apply negative sign\n    No  →\n→ Step 5: Return rev // output result\n\nBut we didn't store original sign. We can store sign variable before loop. Let's incorporate:\n\nStep 1: Input x\nStep 2: sign = 1\nDecision: If x < 0? \n    Yes → sign = -1; x = -x? but x may be INT_MIN. Can't. Alternative: we keep sign, but we use absolute value in loop by digit = abs(x % 10). That works without negating x. So we don't modify x. We'll just use x to get digits; but we must be careful: if x is negative, x / 10 will still be negative floor towards zero? In many languages, integer division truncates toward zero. So -123 / 10 = -12. Good. So loop will finish eventually.\n\nSo Step 2: sign = 1\nDecision: If x < 0? \n    Yes → sign = -1\n    No → sign remains 1\n\nThus we can use x to extract digits. We'll compute digit = abs(x % 10). Then rev will be built as positive number. After loop, rev = rev * sign. But need to ensure overflow check for signed reversed. We have rev positive. When sign negative, final rev negative. But overflow for negative may be different: For negative output -rev should be within INT_MIN..INT_MAX. Since rev is positive, we need to check if rev > INT_MAX? For negative, rev may be > INT_MAX? Example: x = -2147483412 reversed = -2147483412 which fits. So rev <= INT_MAX? Actually rev could be up to 2147483412 which <= INT_MAX. But if rev > 2147483647? That means negative reversed would be -rev < -2147483647 which could be less than INT_MIN? Wait INT_MIN is -2147483648. The most negative is -2147483648. So if rev > 2147483648? rev cannot exceed 2147483648 because we are using 32-bit positive. But rev could be 2147483648 if original x= -8463847412? But original x cannot be that big. But if rev == 2147483648, negative would be -2147483648 which is within INT_MIN. So rev may equal 2147483648. But we cannot store rev as 32-bit signed; but rev is positive maybe > INT_MAX? 2147483648 is > INT_MAX. So rev might overflow 32-bit signed. But we are storing rev in 32-bit signed variable. That could overflow. But we could store rev in unsigned 32-bit? But we are limited to signed 32-bit? Problem says environment does not allow storing 64-bit integers, but can store 32-bit signed? Probably yes. But rev may exceed INT_MAX, which would overflow signed. But we can use unsigned 32-bit or maybe use signed but we need to handle. Could store rev as unsigned 32-bit? The problem states signed 32-bit only? It just says environment does not allow 64-bit ints. But we could use unsigned 32-bit? Let's assume we can use 32-bit unsigned to hold rev, but easier to keep rev as signed and check overflow before each multiplication. The check earlier ensures rev <= (INT_MAX - digit)/10. That ensures rev stays within INT_MAX. For negative sign, we need to allow rev possibly equal to 2147483648? Wait, if rev is 2147483648, that is 2^31, which is out of signed range but within unsigned 32-bit. But we cannot store that in signed. However if rev becomes 2147483648 during positive building, but final sign is negative, the negative result would be -2147483648 which is within signed. But we can't represent rev as signed while it's 2147483648. So we need to allow rev to exceed INT_MAX when sign negative? But we can treat rev as unsigned 32-bit. But the spec didn't forbid unsigned 32-bit. So we can store rev as unsigned 32-bit. But the overflow check for negative case may allow rev up to 2147483648. So we adjust overflow check: If sign is negative, we need to allow rev <= 2147483648? Actually we need to allow rev <= 2147483648? But if rev=2147483648 and sign=-1, result is -2147483648 which is valid. So we need to allow rev <= 2147483648. But rev being 2147483648 is one more than INT_MAX. So we need special handling: If sign negative and rev == 2147483648, we need to allow. But rev can't be greater than that because that would overflow INT_MIN. So we modify overflow check: For positive sign: rev > (INT_MAX - digit)/10 => overflow. For negative sign: if rev > (INT_MAX - digit)/10? Wait we need to compute limit for rev when sign negative. Since final number is -rev, we need -rev >= INT_MIN. That is rev <= -INT_MIN = 2147483648. So allowed rev <= 2147483648. So we need to check overflow when rev > (2147483648 - digit)/10? But 2147483648 is not representable in signed 32-bit. We can treat as unsigned limit. So we can use constant 2147483648u. But we may not have that constant. But we can compute as INT_MAX+1. But we can't store 2147483648 in signed. But we can use unsigned. So we use rev as unsigned 32-bit. We'll use overflow check: If rev > (INT_MAX - digit)/10 when sign positive; If sign negative: if rev > (2147483648u - digit)/10. But we need to ensure rev stored in unsigned, so we can compare with unsigned constants.\n\nHowever, maybe simpler: Process negative numbers by first converting to negative reversed using rev negative, and check negative overflow condition as rev < (INT_MIN + digit)/10. That condition uses rev negative. But rev negative must be within signed range. So rev will stay negative and cannot exceed INT_MIN. So no overflow on rev. For negative numbers, we can compute rev as negative. Let's adopt this approach: rev starts at 0; for each digit positive, we compute newRev = rev*10 - digit. Because rev is negative or zero, we subtract digit. That way rev stays negative. Overflow check: if rev < (INT_MIN + digit)/10 => overflow. Good. So we can keep rev signed, no need to store large positive. For positive numbers, we use rev = rev*10 + digit; overflow check if rev > (INT_MAX - digit)/10. For negative numbers, rev negative, use rev = rev*10 - digit; overflow check if rev < (INT_MIN + digit)/10. That works.\n\nThus algorithm: Determine sign by original x < 0. Keep rev = 0. Loop over digits: digit = abs(x % 10). If signPositive: overflow check positive; else: overflow check negative. Update rev accordingly. x /= 10. End loop. Return rev.\n\nOk.\n\nNow produce virtual code step by step with arrows and explanations.\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 讀取整數 x // 取得使用者輸入的 32 位 signed 整數\n→ Step 2: 設定 signPositive = true // 預設為正數\n    Decision: 如果 x < 0? // 判斷輸入是否為負數\n        Yes → Step 2a: signPositive = false // 需要輸出負數\n        No  → // 保持 true\n→ Step 3: rev ← 0 // 初始化倒序累積器，類型 32 位 signed\n→ Step 4: while x ≠ 0 // 逐位取出 x 的每個數字\n    → Step 4a: digit ← abs(x % 10) // 取 x 的最後一位數字（正數）\n    → Decision: signPositive? // 根據輸入符號決定更新方式\n        Yes → \n            Decision: rev > (INT_MAX - digit) / 10? // 正整數溢位判斷\n                Yes → Step 4b: Return 0 // 超過 32 位正整數範圍\n                No  → \n                    → Step 4c: rev ← rev * 10 + digit // 正向累積\n        No  → \n            Decision: rev < (INT_MIN + digit) / 10? // 負整數溢位判斷\n                Yes → Step 4b: Return 0 // 超過 32 位負整數範圍\n                No  → \n                    → Step 4c: rev ← rev * 10 - digit // 負向累積（保持 rev 為負數）\n    → Step 4d: x ← x / 10 // 去除已處理的最後一位\n→ Step 5: Return rev // 回傳倒序後的整數（已包含正負號） \nEnd // 程式執行結束\n```\n\n這段虛擬碼逐行說明了如何在不使用 64 位整數的前提下，安全地將 32 位有符號整數的位元顛倒，並在可能的溢位情況下返回 0。"
    },
    {
      "title": "Search Insert Position",
      "source_file": "Leetcode/leetcode35.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,3,5,6], target = 5",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp34w4umsl.py\", line 38, in <module>\n    nums, target = parse_input(raw_input)\n                   ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp34w4umsl.py\", line 28, in parse_input\n    nums = eval(part.split('=', 1)[1].strip())\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "nums = [1,3,5,6], target = 2",
          "expected_output": "1",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpwfipumye.py\", line 38, in <module>\n    nums, target = parse_input(raw_input)\n                   ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpwfipumye.py\", line 28, in parse_input\n    nums = eval(part.split('=', 1)[1].strip())\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 2,
          "input": "nums = [1,3,5,6], target = 7",
          "expected_output": "4",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpc7tw3lq4.py\", line 38, in <module>\n    nums, target = parse_input(raw_input)\n                   ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpc7tw3lq4.py\", line 28, in parse_input\n    nums = eval(part.split('=', 1)[1].strip())\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def searchInsert(self, nums, target):\n        \"\"\"\n        二分搜尋插入位置。若找到目標則返回其索引，否則返回插入位置。\n        \"\"\"\n        left, right = 0, len(nums)\n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid\n        return left\n\ndef parse_input(data: str):\n    \"\"\"\n    將形如 'nums = [1,3,5,6], target = 5' 的字串解析為列表和目標值。\n    \"\"\"\n    nums = None\n    target = None\n    # 先按逗號切分，然後逐個處理\n    for part in data.split(','):\n        part = part.strip()\n        if part.startswith('nums'):\n            # 取得等號右邊的值並使用 eval 轉成列表\n            nums = eval(part.split('=', 1)[1].strip())\n        elif part.startswith('target'):\n            target = int(part.split('=', 1)[1].strip())\n    return nums, target\n\nif __name__ == \"__main__\":\n    # 讀取所有標準輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n    nums, target = parse_input(raw_input)\n    result = Solution().searchInsert(nums, target)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for binary search insertion point. Each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision etc. Steps: Start, Set left=0, right=n-1, while left <= right, mid, compare, adjust left/right, after loop return left. Provide explanation. No actual code, just steps.\n\nWe must produce lines like:\n\nStart // 程式開始執行\n→ Step 1: 初始化左指標 left = 0，右指標 right = n-1 // 設定搜尋範圍\n→ Decision: 是否左指標 <= 右指標? // 判斷是否還有元素可搜尋\n    Yes → Step 2: 計算中間索引 mid = left + (right - left) / 2 // 找到中間位置\n    Yes → Decision: arr[mid] 是否等於目標? // 比較中間值與目標\n        Yes → Step 3: 回傳 mid // 找到目標，返回索引\n        No → Decision: arr[mid] 是否小於目標? // 判斷應往右半區\n            Yes → Step 4: left = mid + 1 // 移動左指標到右側\n            No  → Step 5: right = mid - 1 // 移動右指標到左側\n    No → Step 6: 回傳 left // 搜尋完畢，左指標即為插入位置\nEnd // 程式執行結束\n\nMake sure each line has arrow? The sample uses \"→\" before each step. For decisions, use \"Decision:\" with indent.\n\nWe need to use 虛擬碼步驟 after arrow. Eg \"→ Step 1: 初始化...\" etc.\n\nUse Chinese comments.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化左指標 left = 0，右指標 right = n-1 // 設定搜尋範圍  \n→ Decision: 是否 left ≤ right? // 判斷是否還有元素可搜尋  \n&nbsp;&nbsp;Yes → Step 2: 計算中間索引 mid = left + (right - left) / 2 // 找到中間位置  \n&nbsp;&nbsp;Yes → Decision: arr[mid] 是否等於目標? // 比較中間值與目標  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 3: 回傳 mid // 找到目標，返回索引  \n&nbsp;&nbsp;&nbsp;&nbsp;No → Decision: arr[mid] 是否小於目標? // 判斷應往右半區  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 4: left = mid + 1 // 移動左指標到右側  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 5: right = mid - 1 // 移動右指標到左側  \n&nbsp;&nbsp;No → Step 6: 回傳 left // 搜尋完畢，左指標即為插入位置  \nEnd // 程式執行結束"
    },
    {
      "title": "Rotate Function",
      "source_file": "Leetcode/leetcode396.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [4,3,2,6]",
          "expected_output": "26",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '26'\nGot (Norm):      '34'\n--- (Raw) ---\nRaw Expected: '26'\nRaw Got:      '34'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def maxRotateFunction(self, nums):\n        n = len(nums)\n        if n == 0:\n            return 0\n        total = sum(nums)\n        F = sum(i * num for i, num in enumerate(nums))\n        max_val = F\n        for i in range(1, n):\n            F = F + total - n * nums[i-1]\n            if F > max_val:\n                max_val = F\n        return max_val\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    # Extract the list part from input like 'nums = [4,3,2,6]'\n    match = re.search(r'\\[(.*?)\\]', data)\n    if match:\n        list_str = '[' + match.group(1) + ']'\n        try:\n            nums = eval(list_str)\n        except Exception:\n            nums = []\n    else:\n        nums = []\n    result = Solution().maxRotateFunction(nums)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm that finds max rotation function value. We must output lines with virtual code and explanation. Each line \"虛擬碼步驟 // 解釋\". Use arrows and structure. Must be step-by-step algorithm. The algorithm for rotation function uses formula: F(k) = sum_{i=0}^{n-1} i * arr_k[i]. There's known O(n) solution: compute sum of array S, compute F(0), then iterate k=1..n-1: F(k) = F(k-1) + S - n * arr_{k-1}. But arr_{k-1} is element at position k-1 in original array? Actually arr_k is rotation by k: arr_k[i] = nums[(i - k + n) % n]? For clockwise rotation means shifting to right. Usually arr_k is right rotation by k positions: arr_k[i] = nums[(i - k + n) % n]. So arr_{k-1}[n-1] is the element that moves to front? The formula: F(k) = F(k-1) + sum - n * nums[(k-1)%n]. Yes.\n\nWe can just implement algorithm: compute total sum S; compute initial F; max=F. For i from 1 to n-1: F = F + S - n * nums[i-1]; update max. Return max.\n\nWe produce virtual code with steps.\n\nLet's output:\n\nStart\n→ Step 1: 計算陣列長度 n // 取得陣列長度\n→ Step 2: 計算總和 S = sum(nums) // 取得所有元素的總和\n→ Step 3: 計算 F0 = sum(i * nums[i]) for i in 0..n-1 // 初始旋轉函數值\n→ Step 4: maxVal = F0 // 設定最大值為初始值\n→ Step 5: For k from 1 to n-1 // 逐步計算其餘旋轉\n    → Decision: 是否已完成 n-1 次迭代? // 判斷是否繼續\n        Yes → // 迴圈結束\n        No → \n            → Step 6: Fk = F_{k-1} + S - n * nums[k-1] // 更新旋轉函數\n            → Step 7: maxVal = max(maxVal, Fk) // 更新最大值\nEnd // 回傳 maxVal\n\nBut need to structure as Start/End, Decision lines with Yes→ etc.\n\nWe need to include indentation for nested steps. Use arrows.\n\nLet's produce virtual code accordingly. Ensure each line has explanation after //. Use 虛擬碼步驟.\n\nWe need to start with Start // 程式開始執行\n\nLine 1: Start\n\nLine 2: → Step 1: 取得陣列長度 n // 取得 nums 的長度\n\nLine 3: → Step 2: 計算總和 S = sum(nums) // 將所有元素相加得到總和\n\nLine 4: → Step 3: 計算 F0 = sum(i * nums[i]) for i in 0..n-1 // 先算未旋轉時的函數值\n\nLine 5: → Step 4: maxVal = F0 // 初始化最大值\n\nLine 6: → Step 5: for k = 1 to n-1 // 依序處理剩餘 n-1 次旋轉\n\nLine 7:     → Decision: k <= n-1? // 判斷是否還有迴圈\n\nLine 8:         Yes → Step 6: Fk = F_{k-1} + S - n * nums[k-1] // 以前一個值更新\n\nLine 9:         Yes → Step 7: maxVal = max(maxVal, Fk) // 更新最大值\n\nLine 10:         No → // 迴圈結束\n\nLine 11: End // 程式結束，回傳 maxVal\n\nBut we need to include return at end. Maybe add Step 12: Return maxVal // 返回最大旋轉函數值.\n\nMake sure formatting: Each line ends with // 解釋.\n\nAlso the Decision line should be: Decision: k <= n-1? // 判斷是否還有迴圈\n\nThen Yes → ... etc.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得陣列長度 n // 取得 nums 的長度  \n→ Step 2: 計算總和 S = sum(nums) // 將所有元素相加得到總和  \n→ Step 3: 計算 F0 = sum(i * nums[i]) for i in 0..n-1 // 先算未旋轉時的函數值  \n→ Step 4: maxVal = F0 // 初始化最大值為 F0  \n→ Step 5: for k = 1 to n-1 // 依序處理剩餘 n-1 次旋轉  \n    → Decision: k <= n-1? // 判斷是否還有迴圈  \n        Yes → Step 6: Fk = F_{k-1} + S - n * nums[k-1] // 以前一個值更新 F(k)  \n        Yes → Step 7: maxVal = max(maxVal, Fk) // 更新最大值  \n        No → // 迴圈結束  \n→ Step 8: Return maxVal // 回傳最大旋轉函數值  \nEnd // 程式結束執行"
    },
    {
      "title": "Wiggle Sort II",
      "source_file": "Leetcode/leetcode324.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,5,1,1,6,4]",
          "expected_output": "[1,6,1,5,1,4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[1,6,1,5,1,4]'\nGot (Norm):      '[1,5,1,6,1,4]'\n--- (Raw) ---\nRaw Expected: '[1,6,1,5,1,4]'\nRaw Got:      '[1, 5, 1, 6, 1, 4]'"
        },
        {
          "example_index": 1,
          "input": "nums = [1,3,2,2,3,1]",
          "expected_output": "[2,3,1,3,1,2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,3,1,3,1,2]'\nGot (Norm):      '[1,3,2,3,1,2]'\n--- (Raw) ---\nRaw Expected: '[2,3,1,3,1,2]'\nRaw Got:      '[1, 3, 2, 3, 1, 2]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\ndef wiggle_sort(nums):\n    \"\"\"\n    Rearranges nums into a wiggle sequence: nums[0] < nums[1] > nums[2] < nums[3] ...\n    This implementation scans the array once and swaps elements when the\n    required inequality is violated.\n    \"\"\"\n    n = len(nums)\n    for i in range(1, n):\n        # If i is odd, nums[i] should be greater than nums[i-1]\n        # If i is even, nums[i] should be less than nums[i-1]\n        if (i % 2 == 1 and nums[i] < nums[i - 1]) or \\\n           (i % 2 == 0 and nums[i] > nums[i - 1]):\n            nums[i], nums[i - 1] = nums[i - 1], nums[i]\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data = sys.stdin.read()\n    if not data.strip():\n        sys.exit()\n\n    # 解析輸入，假設形如 \"nums = [1,5,1,1,6,4]\"\n    if '=' in data:\n        _, expr = data.split('=', 1)\n    else:\n        expr = data\n\n    try:\n        nums = ast.literal_eval(expr.strip())\n    except Exception:\n        # 若 literal_eval 失敗，使用 eval（假設輸入安全）\n        nums = eval(expr.strip())\n\n    wiggle_sort(nums)\n    print(nums)",
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps for rearranging array into wiggle pattern: nums[0] < nums[1] > nums[2] < nums[3]... Use typical approach: iterate through array, for i from 1 to n-1: if (i%2==1 and nums[i] < nums[i-1]) or (i%2==0 and nums[i] > nums[i-1]) then swap.\n\nWe output each line with \"虛擬碼步驟 // 解釋\". Use arrows and structure.\n\nInclude Start, End, Decision: maybe use a loop decision. We'll produce a step-by-step pseudocode with decision blocks.\n\nLet's draft:\n\nStart // 程式開始執行\n→ Step 1: 設定 n = length(nums) // 取得陣列長度\n→ Step 2: 針對 i 從 1 到 n-1 迭代 // 遍歷陣列\n    → Decision: i 為奇數? // 判斷 i 是否為奇數\n        Yes → Step 3: 如果 nums[i] < nums[i-1] 則 Swap(nums[i], nums[i-1]) // 奇數位置需大於前一個，若不滿足則交換\n        No  → Step 4: 如果 nums[i] > nums[i-1] 則 Swap(nums[i], nums[i-1]) // 偶數位置需小於前一個，若不滿足則交換\n→ End // 程式執行結束\n\nBut we need to incorporate decisions inside. Use proper syntax.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: n ← length(nums) // 取得陣列長度\n→ Step 2: i ← 1 // 初始化迭代索引\n→ Decision: i < n? // 判斷是否還有元素可處理\n    Yes → Step 3: i % 2 == 1? // 判斷 i 為奇數\n        Yes → Step 4: nums[i] < nums[i-1]？ // 若奇數且小於前一個，需交換\n            Yes → Step 5: Swap(nums[i], nums[i-1]) // 交換以滿足大於前一個\n            No  → // 不交換\n        No  → Step 6: nums[i] > nums[i-1]？ // 偶數且大於前一個，需交換\n            Yes → Step 7: Swap(nums[i], nums[i-1]) // 交換以滿足小於前一個\n            No  → // 不交換\n    → Step 8: i ← i + 1 // 進一步索引\n    → Decision: i < n? // 重新判斷循環\n        Yes → 回到 Step 3\n        No  → End // 迴圈結束\nEnd // 程式執行結束\n\nWe might adjust to include \"→\" arrows between lines. Use consistent format: \"→ Step ...\" etc.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← length(nums) // 取得陣列長度  \n→ Step 2: i ← 1 // 初始化迭代索引  \n→ Decision: i < n? // 判斷是否還有元素可處理  \n  Yes → Step 3: i % 2 == 1? // 判斷 i 為奇數  \n    Yes → Step 4: nums[i] < nums[i-1]? // 奇數位置應大於前一個，若小於需交換  \n      Yes → Step 5: Swap(nums[i], nums[i-1]) // 交換以滿足 nums[i] > nums[i-1]  \n      No → // 不交換  \n    No → Step 6: nums[i] > nums[i-1]? // 偶數位置應小於前一個，若大於需交換  \n      Yes → Step 7: Swap(nums[i], nums[i-1]) // 交換以滿足 nums[i] < nums[i-1]  \n      No → // 不交換  \n  → Step 8: i ← i + 1 // 移動到下一個索引  \n  → Decision: i < n? // 重新判斷循環條件  \n    Yes → 回到 Step 3  \n    No → End // 迴圈結束  \nEnd // 程式執行結束"
    },
    {
      "title": "Implement Stack using Queues",
      "source_file": "Leetcode/leetcode225.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "Input [\"MyStack\", \"push\", \"push\", \"top\", \"pop\", \"empty\"], [[], [1], [2], [], [], []]",
          "expected_output": "[null, null, null, 2, 2, false]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,2,2,false]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, 2, 2, false]'\nRaw Got:      '[]'"
        }
      ],
      "generated_code": "import sys\nimport json\nfrom collections import deque\n\nclass MyStack:\n    def __init__(self):\n        # 用兩個佇列實作堆疊，q1 為主佇列，q2 為臨時佇列\n        self.q1 = deque()\n        self.q2 = deque()\n\n    def push(self, x: int) -> None:\n        # 直接將元素加入主佇列\n        self.q1.append(x)\n\n    def pop(self) -> int:\n        if not self.q1:\n            return None  # 堆疊為空時返回 None\n\n        # 把除了最後一個元素以外的所有元素移到臨時佇列\n        while len(self.q1) > 1:\n            self.q2.append(self.q1.popleft())\n\n        # 最後剩下的就是頂部元素\n        top_element = self.q1.popleft()\n\n        # 交換兩個佇列，恢復為主佇列\n        self.q1, self.q2 = self.q2, self.q1\n        return top_element\n\n    def top(self) -> int:\n        if not self.q1:\n            return None\n\n        while len(self.q1) > 1:\n            self.q2.append(self.q1.popleft())\n\n        top_element = self.q1.popleft()\n        # 把頂部元素再次加入臨時佇列，保持原始元素不丟失\n        self.q2.append(top_element)\n\n        self.q1, self.q2 = self.q2, self.q1\n        return top_element\n\n    def empty(self) -> bool:\n        return not self.q1\n\n\ndef main():\n    # 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n\n    if not raw_input:\n        print(\"[]\")\n        return\n\n    # 移除可能的「Input」前綴\n    if raw_input.lower().startswith(\"input\"):\n        raw_input = raw_input[5:].strip()\n\n    # 將兩個列表包裝成一個 JSON 列表，方便解析\n    if raw_input[0] != '[':\n        raw_input = f'[{raw_input}]'\n\n    try:\n        ops, args = json.loads(raw_input)\n    except json.JSONDecodeError as e:\n        # 如果解析失敗，直接輸出空結果\n        print(\"[]\")\n        return\n\n    results = []\n    stack_instance = None\n\n    for op, arg in zip(ops, args):\n        if op == \"MyStack\":\n            stack_instance = MyStack()\n            results.append(None)\n        elif op == \"push\":\n            stack_instance.push(arg[0])\n            results.append(None)\n        elif op == \"pop\":\n            val = stack_instance.pop()\n            results.append(val)\n        elif op == \"top\":\n            val = stack_instance.top()\n            results.append(val)\n        elif op == \"empty\":\n            val = stack_instance.empty()\n            results.append(val)\n        else:\n            # 未知操作，忽略\n            results.append(None)\n\n    # 將結果轉成符合範例輸出的格式\n    output_parts = []\n    for r in results:\n        if r is None:\n            output_parts.append(\"null\")\n        elif isinstance(r, bool):\n            output_parts.append(\"true\" if r else \"false\")\n        else:\n            output_parts.append(str(r))\n    output_str = \"[\" + \", \".join(output_parts) + \"]\"\n    print(output_str)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line for implementing MyStack with two queues. Provide steps like Start, decisions, etc. Should reflect operations push, pop, top, empty.\n\nUse two queues: q1 and q2. For push: enqueue to q1. For pop: move all but last from q1 to q2, dequeue last, swap names. For top: similar but return last without removing? Could do same moving but keep element? Simpler: For top, perform pop and then push back? But only standard queue operations: we can peek front? But top requires return of top element. We can get top by performing similar to pop but keep the element. Could do: while size>1, move; then peek front; store it; then enqueue back to q2; then swap. Or could maintain a variable topElement updated on push, but to keep pure we can implement using queue ops.\n\nWe'll output steps for each method.\n\nWe should produce separate sections for each method: push, pop, top, empty.\n\nLet's craft.\n\nUse Start for overall class initialization.\n\nUse → Step: ... for method definitions.\n\nWe need to use arrows and decisions. Use \"Decision:\" for if empty.\n\nOk.\n\nWe output virtual code lines. Let's proceed.\n...done thinking.\n\nStart // 程式開始執行\n→ Initialize q1 ← Empty Queue // 用於存放新進元素\n→ Initialize q2 ← Empty Queue // 用於臨時儲存移動元素\n\n// 方法：push\n→ Define push(x) // 將元素 x 推進堆疊\n    → q1.enqueue(x) // 將 x 加到 q1 的尾端\nEnd // push 完成\n\n// 方法：pop\n→ Define pop() // 從堆疊中移除並返回頂部元素\n    → Decision: q1.isEmpty()? // 檢查是否為空\n        Yes → Return null // 若空，直接返回 null 或適當錯誤\n        No  →\n            → While q1.size() > 1 // 移動除最後一個之外的所有元素\n                → temp ← q1.dequeue() // 從前端取出\n                → q2.enqueue(temp) // 加入 q2\n            → topElement ← q1.dequeue() // 取出最後一個（即頂部）\n            → Swap(q1, q2) // 交換兩個佇列，q1 重新成為主佇列\n            → Return topElement // 返回頂部元素\nEnd // pop 完成\n\n// 方法：top\n→ Define top() // 返回堆疊頂部元素但不移除\n    → Decision: q1.isEmpty()? // 檢查是否為空\n        Yes → Return null // 若空，直接返回 null 或適當錯誤\n        No  →\n            → While q1.size() > 1 // 移動除最後一個之外的所有元素\n                → temp ← q1.dequeue()\n                → q2.enqueue(temp)\n            → topElement ← q1.dequeue() // 取出最後一個\n            → q2.enqueue(topElement) // 再次加入 q2 以保持元素\n            → Swap(q1, q2) // 交換兩個佇列\n            → Return topElement // 返回頂部元素\nEnd // top 完成\n\n// 方法：empty\n→ Define empty() // 判斷堆疊是否為空\n    → Return q1.isEmpty() // 若主佇列為空即堆疊為空\nEnd // empty 完成\n\nEnd // 程式執行結束"
    },
    {
      "title": "Course Schedule II",
      "source_file": "Leetcode/leetcode210.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]",
          "expected_output": "[0,2,1,3]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[0,2,1,3]'\nGot (Norm):      '[0,1,2,3]'\n--- (Raw) ---\nRaw Expected: '[0,2,1,3]'\nRaw Got:      '[0, 1, 2, 3]'"
        }
      ],
      "generated_code": "import sys\nfrom collections import deque\n\nclass Solution:\n    def findOrder(self, numCourses: int, prerequisites: list) -> list:\n        \"\"\"Topological sort using Kahn's algorithm.\"\"\"\n        # Build graph and indegree count\n        graph = [[] for _ in range(numCourses)]\n        indegree = [0] * numCourses\n        for dest, src in prerequisites:\n            graph[src].append(dest)\n            indegree[dest] += 1\n\n        # Queue of courses with no prerequisites\n        queue = deque([i for i in range(numCourses) if indegree[i] == 0])\n        order = []\n\n        while queue:\n            node = queue.popleft()\n            order.append(node)\n            for neighbor in graph[node]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    queue.append(neighbor)\n\n        # If all courses are taken, return the order; otherwise return empty list\n        return order if len(order) == numCourses else []\n\ndef parse_input(data: str):\n    \"\"\"\n    Parse the input string which may be in the form:\n    'numCourses = 2, prerequisites = [[1,0]]'\n    or it may be two separate lines:\n    '2\\n[[1,0]]'\n    \"\"\"\n    data = data.strip()\n    if not data:\n        return 0, []\n\n    # Detect comma-separated format\n    if ',' in data:\n        # Split only at the first comma to keep list intact\n        left, right = data.split(',', 1)\n        # Extract numCourses\n        num_courses_part = left.split('=')[1].strip()\n        numCourses = int(num_courses_part)\n        # Extract prerequisites list\n        prereq_part = right.split('=')[1].strip()\n        prerequisites = eval(prereq_part)  # safe in controlled environment\n    else:\n        # Assume two lines: first line numCourses, second line list\n        lines = data.splitlines()\n        numCourses = int(lines[0].strip())\n        prerequisites = eval(lines[1].strip())\n    return numCourses, prerequisites\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    numCourses, prerequisites = parse_input(raw_input)\n    sol = Solution()\n    order = sol.findOrder(numCourses, prerequisites)\n    print(order)",
      "virtual_code": "Thinking...\nWe need to output virtual code for topological sort algorithm to find course order, given prerequisites. The output is step by step with arrows. Let's design a high-level algorithm: Build adjacency list, indegree array, queue for zero indegree, process. Check if result size equals numCourses; if not, return empty.\n\nWe'll produce virtual steps: Start, Step 1: Build graph, indegree, etc. Use arrows. Provide decision: If numCourses==0? Not necessary. We'll produce general steps. Use decision blocks for validity. We need to output \"虛擬碼步驟\" then comment.\n\nWe must not output actual code, only pseudocode steps.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: 建立 adjacency list graph[numCourses] // 初始化每門課的相鄰課程\n→ Step 2: 建立 indegree[ numCourses ] 並全設為 0 // 記錄每門課的前置課程數量\n→ Step 3: 逐對 prerequisites[i] = [a, b]：\n    → graph[b].append(a) // b 為前置課，a 需在 b 後面\n    → indegree[a]++ // a 的前置課數量加一\n→ Step 4: 建立空佇列 queue // 存放 indegree 為 0 的課程\n→ Decision: 是否存在 indegree 為 0 的課程?\n    Yes → 進行 Step 5\n    No  → Step 7\n    (如果沒有任何 indegree 為 0，則無法完成，直接返回空)\n→ Step 5: 將所有 indegree 為 0 的課程加入 queue // 初始可選課\n→ Step 6: 建立結果 list order // 存儲課程排序\n→ Decision: queue 是否為空?\n    Yes → Step 9 // 完成全部課程或無法完成\n    No  → Step 7\n→ Step 7: 取出 queue 的第一個課程 curr\n→ Step 8: 將 curr 加入 order\n→ Step 9: 針對 curr 的每個相鄰課程 nei：\n    → indegree[nei]-- // 已完成一個前置課\n    → Decision: indegree[nei] 是否為 0?\n        Yes → queue.append(nei) // 現可選\n        No  → 不動作\n→ Decision: order.size < numCourses ?\n    Yes → 回到 Step 6\n    No  → Step 10\n→ Step 10: 若 order.size == numCourses 則返回 order，否則返回空列表 // 判斷是否所有課程都已排好\nEnd // 程式執行結束\n\nBut need to adjust arrow formatting. Use \"→\" for next step. For decisions: \"Decision: ...\" with Yes →, No →. Let's refine.\n\nWe also need to include each line's explanation comment.\n\nLet's write final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 adjacency list graph[numCourses] // 為每門課建立相鄰課程清單  \n→ Step 2: 初始化 indegree[numCourses] 為 0 // 記錄每門課的前置課程數量  \n→ Step 3: 遍歷 prerequisites[i] = [a, b]  \n  → graph[b].append(a) // b 為前置課，a 需在 b 後學  \n  → indegree[a] += 1 // a 的前置課數量加一  \n→ Step 4: 建立空佇列 queue // 用來存放 indegree 為 0 的課程  \n→ Decision: 是否存在 indegree 為 0 的課程?  \n  Yes → Step 5 // 有可直接學的課程  \n  No → Step 8 // 無法完成，直接返回空清單  \n→ Step 5: 將所有 indegree 為 0 的課程加入 queue // 初始可選課  \n→ Step 6: 建立結果 list order = [] // 存儲課程排序  \n→ Decision: queue 是否為空?  \n  Yes → Step 9 // 可能已完成所有課程或無法完成  \n  No → Step 7 // 有課程可進一步處理  \n→ Step 7: pop curr from queue // 取出一門可學的課程  \n→ Step 8: order.append(curr) // 將 curr 加入最終排序  \n→ Step 9: 對於 curr 的每個相鄰課程 nei  \n  → indegree[nei] -= 1 // 已完成一個前置課  \n  → Decision: indegree[nei] 是否為 0?  \n    Yes → queue.append(nei) // 現可學  \n    No → 不動作  \n→ Decision: order.size < numCourses?  \n  Yes → 回到 Step 6 // 仍有課程未處理  \n  No → Step 10 // 所有課程已處理或無法完成  \n→ Step 10: 若 order.size == numCourses 則返回 order，否則返回空列表 // 判斷是否成功完成所有課程  \nEnd // 程式執行結束"
    },
    {
      "title": "Generate Random Point in a Circle",
      "source_file": "Leetcode/leetcode478.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]",
          "expected_output": "[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[-0.02493,-0.38077],[0.82314,0.38945],[0.36572,0.17248]]'\nGot (Norm):      '[null,[0.64075,0.30002],[-0.75315,0.19939],[-0.33507,-0.29379]]'\n--- (Raw) ---\nRaw Expected: '[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]'\nRaw Got:      '[null, [0.64075, 0.30002], [-0.75315, 0.19939], [-0.33507, -0.29379]]'"
        }
      ],
      "generated_code": "import sys\nimport math\nimport random\nimport ast\nimport json\n\nclass Solution:\n    def __init__(self, radius, x_center, y_center):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n\n    def randPoint(self):\n        # 隨機生成一個均勻分佈在圓內的點\n        r = self.radius * math.sqrt(random.random())  # sqrt 保證半徑均勻分佈\n        theta = random.uniform(0, 2 * math.pi)        # 隨機角度\n        x = self.x_center + r * math.cos(theta)\n        y = self.y_center + r * math.sin(theta)\n        # 四捨五入到 5 位小數，方便比較\n        return [round(x, 5), round(y, 5)]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    if not data or len(data) < 2:\n        sys.exit()\n\n    commands = ast.literal_eval(data[0].strip())\n    args_list = ast.literal_eval(data[1].strip())\n\n    results = []\n    instance = None\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"Solution\":\n            instance = Solution(*args)\n            results.append(None)          # 建構子返回 null\n        else:\n            # 呼叫對應方法\n            method = getattr(instance, cmd)\n            res = method(*args) if args else method()\n            results.append(res)\n\n    # 使用 json.dumps 讓 None 變成 null，並輸出結果\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to output virtual code steps line by line with explanation. No actual code. Just structure. Need to cover initialization, generating random point inside circle uniformly.\n\nWe need Start, End. Use Decision, Step etc.\n\nSo:\n\nStart\n→ Step 1: Store radius, center coordinates // 保存圆半径和中心坐标\n→ Step 2: Generate random r and theta // 产生随机半径和角度\n→ Decision: Ensure r in [0, radius] with sqrt // 检查随机半径是否均匀分布\n    Yes → ...\nBut we can just show algorithm:\n\nTo generate uniform point: sample radius r = radius * sqrt(U) where U uniform [0,1], theta = 2π * V where V uniform [0,1]. Then convert to x,y.\n\nSo we can produce steps:\n\nStep: random u1 in [0,1]\nStep: r = radius * sqrt(u1)\nStep: random u2 in [0,1]\nStep: theta = 2π * u2\nStep: x = x_center + r * cos(theta)\nStep: y = y_center + r * sin(theta)\nReturn [x, y]\n\nWrap into function randPoint.\n\nWe also need to show initialization. So:\n\nClass Solution\n→ Constructor(radius, x_center, y_center) // 初始化圆参数\n\nThen method randPoint()\n\nStart // 生成随机点\n→ Step 1: Generate u1 // 产生均匀随机数\n→ Step 2: Compute r // 调整半径使点均匀分布\n→ Step 3: Generate u2 // 产生角度均匀随机数\n→ Step 4: Compute theta // 角度\n→ Step 5: Convert polar to cartesian // 计算坐标\n→ Step 6: Return [x, y] // 返回点\n\nEnd\n\nAlso include any decisions if needed? Not necessary.\n\nLet's output lines accordingly. Use \"Start\" etc.\n\nMake sure each line: 虛擬碼步驟 + space + // 解釋.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行\n\n→ Step 1: 定義 class Solution // 建立 Solution 類別\n→ Step 2: Constructor(radius, x_center, y_center) // 初始化半徑與中心座標\n    → 保存 radius 到物件屬性 // 儲存圓半徑\n    → 保存 x_center 到物件屬性 // 儲存 X 坐標\n    → 保存 y_center 到物件屬性 // 儲存 Y 坐標\n\n→ Step 3: Method randPoint() // 定義產生隨機點的方法\n    → Step 4: u1 = random_uniform(0, 1) // 產生第一個均勻隨機數\n    → Step 5: r = radius * sqrt(u1) // 調整半徑以保證點在圓內均勻分布\n    → Step 6: u2 = random_uniform(0, 1) // 產生第二個均勻隨機數\n    → Step 7: theta = 2 * PI * u2 // 將隨機數轉換為角度\n    → Step 8: x = x_center + r * cos(theta) // 由極座標轉換為 X 座標\n    → Step 9: y = y_center + r * sin(theta) // 由極座標轉換為 Y 座標\n    → Step 10: return [x, y] // 返回隨機點的座標\n\nEnd // 程式執行結束"
    },
    {
      "title": "Remove Element",
      "source_file": "Leetcode/leetcode27.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "nums = [0,1,2,2,3,0,4,2], val = 2",
          "expected_output": "5, nums = [0,1,4,0,3,_,_,_]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '5,nums=[0,1,4,0,3,_,_,_]'\nGot (Norm):      '5,nums=[0,1,3,0,4,_,_,_]'\n--- (Raw) ---\nRaw Expected: '5, nums = [0,1,4,0,3,_,_,_]'\nRaw Got:      '5, nums = [0,1,3,0,4,_,_,_]'"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef remove_element(nums, val):\n    \"\"\"\n    Remove all occurrences of val from nums in-place.\n    Return the new length k of the non-val elements.\n    \"\"\"\n    slow = 0\n    for fast in range(len(nums)):\n        if nums[fast] != val:\n            nums[slow] = nums[fast]\n            slow += 1\n    return slow\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Parse the input format: nums = [...], val = ...\n    pattern = r'nums\\s*=\\s*(\\[[^\\]]*\\])\\s*,\\s*val\\s*=\\s*(-?\\d+)'\n    match = re.search(pattern, data)\n    if not match:\n        # If the pattern does not match, attempt a simple split\n        parts = data.replace(' ', '').split(',')\n        if len(parts) >= 2 and parts[0].startswith('nums='):\n            nums = eval(parts[0][5:])\n            val = int(parts[1][3:])\n        else:\n            raise ValueError(\"Input format not recognized.\")\n    else:\n        nums_str = match.group(1)\n        val = int(match.group(2))\n        nums = eval(nums_str)\n\n    original_len = len(nums)\n    k = remove_element(nums, val)\n\n    # Build the output representation with underscores for removed slots\n    output_elements = []\n    for i in range(original_len):\n        if i < k:\n            output_elements.append(str(nums[i]))\n        else:\n            output_elements.append('_')\n    output_str = '[' + ','.join(output_elements) + ']'\n\n    # Print result as requested\n    print(f\"{k}, nums = {output_str}\")\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate pseudocode line-by-line with explanations. The pseudocode should be like the example: Start, then arrow, Decision, etc. No actual code. Provide steps for removeElement algorithm.\n\nWe need to respond in Traditional Chinese.\n\nWe'll include steps: Start, initialize write pointer = 0, iterate through nums with read pointer. If nums[i] != val, assign nums[write] = nums[i], write++. After loop, return write. Also we need to note that the array order can change. But algorithm preserves order, but okay.\n\nWe need to use arrows: → Step 1: etc. Use Decision: etc. Use Yes → / No →. We need to produce each line with explanation comment.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 初始化寫指標 write = 0 // 用於記錄下一個非 val 元素寫入的位置\n→ Step 2: 循環遍歷 nums，使用讀指標 i 從 0 到 nums.length - 1 // 逐個檢查每個元素\n→ Decision: 如果 nums[i] 不等於 val? // 判斷是否為需要保留的元素\n    Yes → Step 3: 把 nums[i] 寫到 nums[write] // 將非 val 元素移到前面\n        → Step 4: write++ // 更新寫指標，指向下一個空位\n    No  → Step 5: 跳過該元素 // val 元素直接忽略\n→ Step 6: 循環結束 // 所有元素已處理完\n→ Step 7: Return write // write 即為非 val 元素的數量 k\nEnd // 程式執行結束\n\nNeed to ensure each line has format: 虛擬碼步驟 [space] // 解釋\n\nUse arrow for each line.\n\nOk produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化寫指標 write = 0 // 用於記錄下一個非 val 元素寫入的位置  \n→ Step 2: 循環遍歷 nums，使用讀指標 i 從 0 到 nums.length - 1 // 逐個檢查每個元素  \n→ Decision: 如果 nums[i] 不等於 val? // 判斷是否為需要保留的元素  \n    Yes → Step 3: 把 nums[i] 寫到 nums[write] // 將非 val 元素移到前面  \n        → Step 4: write++ // 更新寫指標，指向下一個空位  \n    No → Step 5: 跳過該元素 // val 元素直接忽略  \n→ Step 6: 循環結束 // 所有元素已處理完  \n→ Step 7: Return write // write 即為非 val 元素的數量 k  \nEnd // 程式執行結束"
    },
    {
      "title": "Shuffle an Array",
      "source_file": "Leetcode/leetcode384.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"], [[[1, 2, 3]], [], [], []]",
          "expected_output": "[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[3,1,2],[1,2,3],[1,3,2]]'\nGot (Norm):      '[null,[1,3,2],[2,3,1],[2,3,1]]'\n--- (Raw) ---\nRaw Expected: '[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]'\nRaw Got:      '[null, [1, 3, 2], [2, 3, 1], [2, 3, 1]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\n\nclass Solution:\n    def __init__(self, nums):\n        # 保存原始陣列，並初始化可變副本\n        self.original = list(nums)\n        self.nums = list(nums)\n\n    def reset(self):\n        # 重新複製原始陣列，回到初始順序\n        self.nums = list(self.original)\n        return self.nums\n\n    def shuffle(self):\n        # Fisher‑Yates 洗牌：從前到後隨機交換元素\n        n = len(self.nums)\n        for i in range(n):\n            j = random.randint(i, n - 1)\n            self.nums[i], self.nums[j] = self.nums[j], self.nums[i]\n        return self.nums\n\ndef format_output(results):\n    # 將結果轉成 LeetCode 所需的字串格式\n    out = '['\n    for i, val in enumerate(results):\n        if i > 0:\n            out += ', '\n        if val is None:\n            out += 'null'\n        elif isinstance(val, list):\n            out += '[' + ', '.join(str(x) for x in val) + ']'\n        else:\n            out += str(val)\n    out += ']'\n    return out\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 將輸入包成一個 tuple，方便 literal_eval 解析\n    data = '(' + data + ')'\n    commands, args = ast.literal_eval(data)\n\n    results = []\n    obj = None\n    for cmd, arg in zip(commands, args):\n        if cmd == \"Solution\":\n            # arg 形式為 [[1,2,3]]，取第一個元素作為 nums\n            obj = Solution(arg[0])\n            results.append(None)\n        elif cmd == \"reset\":\n            results.append(obj.reset())\n        elif cmd == \"shuffle\":\n            results.append(obj.shuffle())\n    print(format_output(results))",
      "virtual_code": "Thinking...\nThe user wants virtual code steps for the problem: random shuffle of array. Need to produce step-by-step pseudocode with explanation, following format.\n\nWe need to output each line like:\n\nStart // 程式開始執行\n\n→ Step 1: Initialize class with original array // ...\n\nNeed to cover constructor, reset, shuffle. Need to implement algorithm: copy array, for shuffle use Fisher-Yates: iterate i from length-1 down to 1, choose random j in [0,i], swap arr[i], arr[j]. Provide pseudocode lines for this.\n\nAlso need to store original array for reset.\n\nShould also include decisions? Might not need decisions except maybe verifying lengths, but not necessary.\n\nWe need to use virtual code arrows, structure Start, End. Should include each step. Provide concise explanation after comment.\n\nLet's draft:\n\nStart // 程式開始執行\n\n→ Step 1: 在建構子中將傳入的 nums 複製為 original // 保存原始順序\n\n→ Step 2: 在建構子中建立可變 copy 陣列 copyNums // 用於 shuffle\n\n→ Decision: 是否需要初始化？ No (just set)\n\n→ Step 3: 定義 reset() 方法\n\n→ Step 4: 在 reset() 中將 copyNums 設為 original 的複製 // 回到初始順序\n\n→ Step 5: reset() 回傳 copyNums\n\n→ Step 6: 定義 shuffle() 方法\n\n→ Step 7: 在 shuffle() 中執行 Fisher‑Yates 交換\n\n→  Loop i from n-1 down to 1 // 逐一處理每個位置\n\n→  Decision: 生成隨機 j 在 [0,i] // 決定交換目標\n\n→  Step: 交換 copyNums[i] 與 copyNums[j] // 交換元素\n\n→ End of loop\n\n→ Step 8: shuffle() 回傳 copyNums\n\nEnd // 程式結束\n\nBut need each line with \"虛擬碼步驟\" plus explanation.\n\nLet's format:\n\nStart // 程式開始執行\n→ Step 1: 在建構子中將傳入的 nums 複製為 original // 保存原始順序，方便重設\n→ Step 2: 在建構子中建立可變 copyNums 為 original 的複製 // 用於 shuffle 時的暫存\n→ Step 3: 定義 reset() 方法 // 用來回到初始排列\n→ Step 4: 在 reset() 中將 copyNums 設為 original 的複製 // 重新複製一次，保證獨立\n→ Step 5: reset() 回傳 copyNums // 回傳重設後的陣列\n→ Step 6: 定義 shuffle() 方法 // 產生隨機排列\n→ Step 7: 在 shuffle() 中執行 Fisher‑Yates 交換 // 確保所有排列均等可能\n→ Step 8: Loop i from n-1 down to 1 // 從尾到頭遍歷每個位置\n→ Step 9: 生成隨機整數 j 取值於 [0,i] // 隨機決定交換目標\n→ Step 10: 交換 copyNums[i] 與 copyNums[j] // 交換元素\n→ Step 11: End of loop // 完成所有交換\n→ Step 12: shuffle() 回傳 copyNums // 回傳隨機排列\nEnd // 程式結束執行\n\nWe might need to include Decision arrow for generating random j? But arrow style is \"Decision:\" but we can use arrow for the loop but not necessarily decision. The format example uses \"Decision:\" only for conditional branching. For random j selection it's not a decision in code flow, but could treat as random. We can just step.\n\nWe need to use virtual code arrows `→` and maybe `Yes →`, `No →`. Not necessary.\n\nThe output should be exactly as the format with each line. Ensure there is no actual code; just pseudocode lines.\n\nAlso we must not output actual code, just pseudocode steps. It's okay.\n\nNow produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 在建構子中將傳入的 nums 複製為 original // 保存原始順序，方便重設  \n→ Step 2: 在建構子中建立可變 copyNums 為 original 的複製 // 用於 shuffle 時的暫存  \n→ Step 3: 定義 reset() 方法 // 用來回到初始排列  \n→ Step 4: 在 reset() 中將 copyNums 設為 original 的複製 // 重新複製一次，保證獨立  \n→ Step 5: reset() 回傳 copyNums // 回傳重設後的陣列  \n→ Step 6: 定義 shuffle() 方法 // 產生隨機排列  \n→ Step 7: 在 shuffle() 中執行 Fisher‑Yates 交換 // 確保所有排列均等可能  \n→ Step 8: Loop i from n-1 down to 1 // 從尾到頭遍歷每個位置  \n→ Step 9: 生成隨機整數 j 取值於 [0,i] // 隨機決定交換目標  \n→ Step 10: 交換 copyNums[i] 與 copyNums[j] // 交換元素  \n→ Step 11: End of loop // 完成所有交換  \n→ Step 12: shuffle() 回傳 copyNums // 回傳隨機排列  \nEnd // 程式結束執行"
    },
    {
      "title": "Subsets",
      "source_file": "Leetcode/leetcode78.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nGot (Norm):      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nRaw Got:      '[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\ndef subsets(nums):\n    \"\"\"返回 nums 的所有子集（幂集）\"\"\"\n    res = []\n\n    def backtrack(start, path):\n        # 把目前的子集加入結果\n        res.append(path[:])\n        # 從 start 開始嘗試將後續元素加入子集\n        for i in range(start, len(nums)):\n            path.append(nums[i])\n            backtrack(i + 1, path)\n            path.pop()  # 回溯，移除剛剛加入的元素\n\n    backtrack(0, [])\n    return res\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 若輸入格式為 \"nums = [1,2,3]\"，移除前綴\n    if \"=\" in data:\n        _, list_part = data.split(\"=\", 1)\n    else:\n        list_part = data\n\n    list_part = list_part.strip()\n\n    # 用安全的方式解析成列表\n    try:\n        nums = ast.literal_eval(list_part)\n    except Exception:\n        nums = eval(list_part)\n\n    # 計算並輸出結果\n    result = subsets(nums)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce a virtual code for generating all subsets (power set) from an integer array with unique elements. No duplicates. Return any order. We must provide step-by-step virtual code with comments. Use arrow arrows, decision blocks, etc.\n\nWe need to produce each line: \"虛擬碼步驟 // 解釋/說明\".\n\nWe need to design algorithm: use recursion/backtracking or iterative bitmask.\n\nSimplest: iterate over bits. For each subset, add.\n\nAlternatively, backtracking: start with empty subset, include or exclude each element recursively.\n\nLet's produce steps:\n\nStart\n→ Step 1: Sort? Not needed, but can maintain order.\n\nBetter: We'll produce recursive algorithm:\n\n- Start\n- → Step 1: 初始化 result list with empty subset\n- → Step 2: 定義遞迴函式 dfs(index, currentSubset)\n- → Step 3: 在遞迴中 if index == len(nums): append copy of currentSubset to result; return\n- → Step 4: Decision: 是否選擇 nums[index]？\n    Yes → add nums[index] to currentSubset; call dfs(index+1, currentSubset); remove last element\n    No → call dfs(index+1, currentSubset)\n\n- Step 5: 呼叫 dfs(0, [])\n- End\n\nBut we need \"逐行虛擬碼\". Let's craft each line with comments. Use arrow: \"→\". Use \"Decision:\" for if.\n\nNeed to avoid actual code; just describe steps.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 宣告結果列表 result = [] // 用於存放所有子集\n→ Step 2: 建立遞迴函式 dfs(index, current) // index 代表目前處理的元素位置\n→ Step 3: Decision: index 是否等於 nums 長度？ // 判斷是否已處理完所有元素\n    Yes → Step 4: 把 current 的拷貝加入 result // 完整子集加入結果\n    No  → Step 5: Decision: 是否將 nums[index] 加入 current？ // 選擇包含或不包含\n        Yes → Step 6: current 加上 nums[index] // 包含當前元素\n        → Step 7: dfs(index+1, current) // 進一步處理後續元素\n        → Step 8: current 移除最後一個元素 // 回溯，移除已加入的元素\n        No  → Step 9: dfs(index+1, current) // 直接跳過當前元素，處理後續\n→ Step 10: 呼叫 dfs(0, []) // 從第一個元素開始遞迴\nEnd // 程式執行結束\n\nBut we also need \"return result\". So after calling, we need to produce return.\n\nMaybe we add: Step 11: return result // 回傳所有子集\n\nLet's incorporate.\n\nAdd indentation for decisions? The sample shows indentation by spaces.\n\nWe should align accordingly.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 宣告結果列表 result = [] // 用於存放所有子集  \n→ Step 2: 建立遞迴函式 dfs(index, current) // index 代表目前處理的元素位置  \n→ Step 3: Decision: index 是否等於 nums 長度？ // 判斷是否已處理完所有元素  \n    Yes → Step 4: 把 current 的拷貝加入 result // 完整子集加入結果  \n    No  → Step 5: Decision: 是否將 nums[index] 加入 current？ // 選擇包含或不包含  \n        Yes → Step 6: current 加上 nums[index] // 包含當前元素  \n        → Step 7: dfs(index+1, current) // 進一步處理後續元素  \n        → Step 8: current 移除最後一個元素 // 回溯，移除已加入的元素  \n        No  → Step 9: dfs(index+1, current) // 直接跳過當前元素，處理後續  \n→ Step 10: 呼叫 dfs(0, []) // 從第一個元素開始遞迴  \n→ Step 11: return result // 回傳所有子集  \nEnd // 程式執行結束"
    },
    {
      "title": "LFU Cache",
      "source_file": "Leetcode/leetcode460.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"LFUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"get\", \"put\", \"get\", \"get\", \"get\"], [[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]",
          "expected_output": "[null, null, null, 1, null, -1, 3, null, -1, 3, 4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,1,null,-1,3,null,-1,3,4]'\nGot (Norm):      '[None,None,None,1,None,-1,3,None,-1,3,4]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, 1, null, -1, 3, null, -1, 3, 4]'\nRaw Got:      '[None, None, None, 1, None, -1, 3, None, -1, 3, 4]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict, OrderedDict\n\nclass LFUCache:\n    def __init__(self, capacity: int):\n        \"\"\"初始化 LFUCache。\"\"\"\n        self.capacity = capacity          # 最大容量\n        self.min_freq = 0                 # 當前最小頻率\n        self.key_to_val_freq = {}         # key -> (value, freq)\n        self.freq_to_keys = defaultdict(OrderedDict)  # freq -> OrderedDict[key] (保持插入順序)\n\n    def _update(self, key: int):\n        \"\"\"將 key 的頻率提升 1，並更新相關資料結構。\"\"\"\n        value, freq = self.key_to_val_freq[key]\n        # 從舊頻率的 OrderedDict 移除\n        del self.freq_to_keys[freq][key]\n        if not self.freq_to_keys[freq]:\n            # 若舊頻率已空，刪除該頻率並更新最小頻率\n            del self.freq_to_keys[freq]\n            if self.min_freq == freq:\n                self.min_freq += 1\n        # 加入新頻率\n        self.freq_to_keys[freq + 1][key] = None\n        self.key_to_val_freq[key] = (value, freq + 1)\n\n    def get(self, key: int) -> int:\n        \"\"\"取得 key 的值，若不存在則回傳 -1。\"\"\"\n        if key not in self.key_to_val_freq:\n            return -1\n        self._update(key)\n        return self.key_to_val_freq[key][0]\n\n    def put(self, key: int, value: int) -> None:\n        \"\"\"插入或更新 key 的值。\"\"\"\n        if self.capacity == 0:\n            return\n        if key in self.key_to_val_freq:\n            # 更新值並提升頻率\n            self.key_to_val_freq[key] = (value, self.key_to_val_freq[key][1])\n            self._update(key)\n            return\n        # 若容量已滿，先移除最少頻率且最舊的項目\n        if len(self.key_to_val_freq) >= self.capacity:\n            evict_key, _ = self.freq_to_keys[self.min_freq].popitem(last=False)\n            del self.key_to_val_freq[evict_key]\n            if not self.freq_to_keys[self.min_freq]:\n                del self.freq_to_keys[self.min_freq]\n        # 新增項目\n        self.key_to_val_freq[key] = (value, 1)\n        self.freq_to_keys[1][key] = None\n        self.min_freq = 1\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # 讓整個輸入成為一個合法的 Python tuple\n    try:\n        data = ast.literal_eval(\"(\" + data + \")\")\n    except Exception:\n        # 若輸入格式不正確，直接終止\n        sys.exit()\n    commands, args = data\n    res = []\n    cache = None\n    for cmd, arg in zip(commands, args):\n        if cmd == \"LFUCache\":\n            cache = LFUCache(arg[0])\n            res.append(None)\n        elif cmd == \"put\":\n            cache.put(arg[0], arg[1])\n            res.append(None)\n        elif cmd == \"get\":\n            res.append(cache.get(arg[0]))\n    print(res)",
      "virtual_code": "Thinking...\nWe need to output virtual code line by line, with comments. Must describe a design of LFU cache, using double linked lists per frequency and map of key to node, freq map. Provide steps for constructor, get, put, internal helper to update freq, evict.\n\nLet's produce virtual code like:\n\nStart\n→ Step 1: Define Node struct with key, value, freq, prev, next\n→ Step 2: Define DLL class with head, tail, size, addNode, removeNode, popTail\n… etc.\n\nEnsure each line ends with comment.\n\nWe should produce a linear description of the algorithm. Shouldn't be actual code but pseudocode.\n\nLet's produce steps.\n\nWe'll show initialization: capacity, minFreq, keyNode map, freqMap map.\n\nGet: if key not exist return -1, else get node, update freq, return value.\n\nPut: if capacity zero return. if key exists, update value and update freq. Else if size == capacity evict minFreq node. Insert new node with freq=1, update maps, set minFreq=1.\n\nUpdate freq: remove node from old freq DLL, increment freq, add to new freq DLL, if old DLL empty and old freq == minFreq then minFreq++.\n\nEvict: get DLL of minFreq, pop tail node, delete from keyNode, reduce size.\n\nWe'll produce pseudocode steps accordingly.\n\nLet's produce as per format: each line \"虛擬碼步驟 // 解釋\"\n\nUse arrow \"→\" for steps, \"Decision:\" for condition.\n\nWe should include Start and End.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行\n\n→ Step 1: 定義 Node 結構 // 存放 key, value, freq 及雙向鏈表指標\n→ Step 2: 定義 DoublyLinkedList 類別 // 具有 head、tail、size、add(node)、remove(node)、popTail() 方法\n→ Step 3: 定義 LFUCache 類別 // 包含 capacity、size、minFreq、keyNodeMap、freqListMap\n\n→ Step 4: LFUCache(capacity) 初始化 // 建構子\n    → Decision: 若 capacity <= 0? // 若無效容量\n        Yes → End // 結束初始化\n        No  →\n            → Step 5: this.capacity ← capacity // 設定容量\n            → Step 6: this.size ← 0 // 現有元素數\n            → Step 7: this.minFreq ← 0 // 最小頻率初始值\n            → Step 8: this.keyNodeMap ← 新 Map() // key → Node\n            → Step 9: this.freqListMap ← 新 Map() // freq → DoublyLinkedList\n\n→ Step 10: get(key) // 取得指定 key 的值\n    → Decision: 若 keyNodeMap 沒有 key? // key不存在\n        Yes → Step 11: return -1 // 回傳 -1\n        No  →\n            → Step 12: node ← keyNodeMap.get(key) // 取得節點\n            → Step 13: updateFrequency(node) // 更新頻率\n            → Step 14: return node.value // 回傳值\n\n→ Step 15: put(key, value) // 插入或更新 key/value\n    → Decision: 若 capacity == 0? // 容量為0時直接返回\n        Yes → End\n        No  →\n            → Decision: 若 keyNodeMap 有 key? // 更新已存在的 key\n                Yes →\n                    → Step 16: node ← keyNodeMap.get(key)\n                    → Step 17: node.value ← value // 更新值\n                    → Step 18: updateFrequency(node) // 更新頻率\n                No →\n                    → Decision: 若 size == capacity? // 需要 evict\n                        Yes →\n                            → Step 19: evict() // 刪除最少頻率 LRU\n                        No →\n                            →\n                    → Step 20: node ← 新 Node(key, value, freq=1) // 新節點\n                    → Step 21: keyNodeMap.set(key, node) // 加入 key → node 映射\n                    → Step 22: list ← freqListMap.get(1) // 取得 freq 1 的鏈表\n                    → Decision: 若 list 為 null? // 若沒有此頻率鏈表\n                        Yes →\n                            → Step 23: list ← 新 DoublyLinkedList()\n                            → Step 24: freqListMap.set(1, list) // 建立新鏈表\n                        No →\n                            →\n                    → Step 25: list.add(node) // 將節點加至 freq 1\n                    → Step 26: minFreq ← 1 // 重設最小頻率\n                    → Step 27: size ← size + 1 // 元素數增加\n\n→ Step 28: updateFrequency(node) // 內部頻率更新邏輯\n    → Step 29: oldFreq ← node.freq\n    → Step 30: newFreq ← oldFreq + 1\n    → Step 31: node.freq ← newFreq // 更新節點頻率\n    → Step 32: oldList ← freqListMap.get(oldFreq)\n    → Step 33: oldList.remove(node) // 從舊頻率鏈表移除\n    → Decision: 若 oldList.size == 0? // 旧頻率鏈表空了\n        Yes →\n            → Step 34: freqListMap.delete(oldFreq) // 刪除空鏈表\n            → Decision: 若 oldFreq == minFreq? // 若剛剛是最小頻率\n                Yes →\n                    → Step 35: minFreq ← minFreq + 1 // 更新最小頻率\n                No →\n                    →\n        No →\n            →\n    → Step 36: newList ← freqListMap.get(newFreq)\n    → Decision: 若 newList 為 null? // 無此新頻率鏈表\n        Yes →\n            → Step 37: newList ← 新 DoublyLinkedList()\n            → Step 38: freqListMap.set(newFreq, newList)\n        No →\n            →\n    → Step 39: newList.add(node) // 加入新頻率鏈表\n\n→ Step 40: evict() // 刪除最少頻率 LRU 節點\n    → Step 41: list ← freqListMap.get(minFreq) // 取得 minFreq 的鏈表\n    → Step 42: nodeToRemove ← list.popTail() // 取尾部節點 (最舊)\n    → Step 43: keyNodeMap.delete(nodeToRemove.key) // 刪除 key → node 映射\n    → Step 44: size ← size - 1 // 元素數減少\n\nEnd // 程式執行結束"
    },
    {
      "title": "Different Ways to Add Parentheses",
      "source_file": "Leetcode/leetcode241.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "expression = \"2-1-1\"",
          "expected_output": "[0,2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[0,2]'\nGot (Norm):      '[2,0]'\n--- (Raw) ---\nRaw Expected: '[0,2]'\nRaw Got:      '[2, 0]'"
        },
        {
          "example_index": 1,
          "input": "expression = \"2*3-4*5\"",
          "expected_output": "[-34,-14,-10,-10,10]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[-34,-14,-10,-10,10]'\nGot (Norm):      '[-34,-10,-14,-10,10]'\n--- (Raw) ---\nRaw Expected: '[-34,-14,-10,-10,10]'\nRaw Got:      '[-34, -10, -14, -10, 10]'"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def diffWaysToCompute(self, expression: str):\n        memo = {}\n\n        def ways(expr: str):\n            if expr in memo:\n                return memo[expr]\n\n            results = []\n            for i, ch in enumerate(expr):\n                if ch in '+-*':\n                    left = ways(expr[:i])\n                    right = ways(expr[i + 1:])\n                    for l in left:\n                        for r in right:\n                            if ch == '+':\n                                results.append(l + r)\n                            elif ch == '-':\n                                results.append(l - r)\n                            else:  # '*'\n                                results.append(l * r)\n\n            if not results:\n                results.append(int(expr))\n\n            memo[expr] = results\n            return results\n\n        return ways(expression)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析可能的輸入格式，例如: expression = \"2-1-1\"\n    if '=' in data:\n        _, expr_part = data.split('=', 1)\n        expr_part = expr_part.strip()\n        if (expr_part.startswith('\"') and expr_part.endswith('\"')) or \\\n           (expr_part.startswith(\"'\") and expr_part.endswith(\"'\")):\n            expression = expr_part[1:-1]\n        else:\n            expression = expr_part\n    else:\n        expression = data.strip('\"').strip(\"'\")\n\n    solution = Solution()\n    result = solution.diffWaysToCompute(expression)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for this problem: \"Given a string expression of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. The output can be any order; constraints: 32-bit int, results <= 10^4.\"\n\nWe need to produce line-by-line virtual code with comments. Virtual code syntax uses arrow '→', 'Start', 'End', 'Decision:'. We should produce steps for an algorithm: probably divide and conquer / recursion with memoization. Steps: parse expression into numbers and operators, recursion over splits. Use caching for subexpression results.\n\nWe need to include explanation after each line.\n\nWe must not output actual code; just virtual steps.\n\nLet's design:\n\nStart\n→ Step 1: 定義遞迴函式 calculate(sub_expr) // 用於計算子表達式的所有結果\n→ Decision: 子表達式是否只含單個數字? // 檢查是否已到達葉子節點\n    Yes → Step 2: 轉換子表達式為整數並回傳 [number] // 單個數字直接作為結果\n    No  → Step 3: 初始化 results = [] // 存放本層子表達式的所有結果\n        → Step 4: 從左到右遍歷子表達式中的每個運算符\n            → Decision: 遇到運算符? // 判斷當前字符是否為 '+','-','*'\n                Yes → Step 5: 將表達式分成 left = 前面子表達式, op = 運算符, right = 後面子表達式\n                → Step 6: left_results = calculate(left) // 遞迴求左子表達式結果\n                → Step 7: right_results = calculate(right) // 遞迴求右子表達式結果\n                → Step 8: 對 left_results 和 right_results 取笛卡爾積，對每一對 (l,r) 依照 op 計算結果並加入 results\n        → Step 9: 回傳 results\n→ Step 10: 在主函式中呼叫 calculate(整個表達式) 並回傳其結果\nEnd\n\nBut we also need memoization: step for caching.\n\nAdd a cache dict.\n\nIn calculate: check cache first.\n\nSo modify step 1: 定義遞迴函式 calculate(sub_expr) // 計算子表達式結果\nAlso before recursion maybe check cache.\n\nSo:\n\nStep 1: 定義 cache = {} // 用於存儲子表達式已計算結果\n\nThen inside calculate:\n\nStep 1.1: If sub_expr in cache, 回傳 cache[sub_expr] // 快速回傳已計算結果\n\nThen proceed.\n\nAlso need parse numbers.\n\nBut we can treat sub_expr as string.\n\nAlso need to decide operator positions.\n\nWe should also mention that results <=10^4 ensures recursion not too deep.\n\nLet's produce.\n\nAlso we need to include arrow lines, decisions etc.\n\nLet's produce line by line.\n\nMake sure each line has virtual code and comment.\n\nWe'll use \"→\" for steps, \"Decision:\" for decisions, \"Yes →\" and \"No →\".\n\nMake sure indentation: Use indent spaces before lines? The example shows indentation but not mandatory. But maintain readability.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 cache = {} // 用於快取已計算子表達式的結果  \n→ Step 2: 定義遞迴函式 calculate(sub_expr) // 計算子表達式所有可能的結果  \n\n→ Decision: sub_expr 是否已存在於 cache? // 檢查是否已有計算結果  \n    Yes → Step 3: 回傳 cache[sub_expr] // 直接回傳快取值  \n    No → Step 4: 初始化 results = [] // 本層子表達式的結果集合  \n\n→ Step 5: 判斷 sub_expr 是否僅包含單一數字  \n→ Decision: sub_expr 是單一數字?  \n    Yes → Step 6: 轉換 sub_expr 為整數並回傳 [number] // 單個數字直接返回  \n    No  → Step 7: 針對 sub_expr 從左到右掃描每個字符  \n        → Step 8: 如果遇到 '+', '-', 或 '*'，則進行分割  \n            → Decision: 當前字符是運算符?  \n                Yes → Step 9: 設定 left = sub_expr[0 : i]  \n                      → Step 10: 設定 op = sub_expr[i]  \n                      → Step 11: 設定 right = sub_expr[i+1 : ]  \n                      → Step 12: left_results = calculate(left) // 遞迴求左子表達式結果  \n                      → Step 13: right_results = calculate(right) // 遞迴求右子表達式結果  \n                      → Step 14: 對每個 l in left_results  \n                          → Step 15: 對每個 r in right_results  \n                              → Decision: op 為 '+', '-', 或 '*'?  \n                                  + → Step 16: results 加入 l + r // 加法結果  \n                                  - → Step 17: results 加入 l - r // 減法結果  \n                                  * → Step 18: results 加入 l * r // 乘法結果  \n        → Step 19: 迴圈結束  \n\n→ Step 20: cache[sub_expr] = results // 將本層結果存入快取  \n→ Step 21: 回傳 results // 結束本層遞迴  \n\n→ Step 22: 主函式呼叫 calculate(整個輸入字串) // 開始遞迴  \n→ Step 23: 回傳主函式的結果 // 程式輸出  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick with Weight",
      "source_file": "Leetcode/leetcode528.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"], [[[1,3]],[],[],[],[],[]]",
          "expected_output": "[null,1,1,1,1,0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,1,1,1,1,0]'\nGot (Norm):      '[null,0,1,1,1,1]'\n--- (Raw) ---\nRaw Expected: '[null,1,1,1,1,0]'\nRaw Got:      '[null, 0, 1, 1, 1, 1]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport bisect\nimport ast\n\nclass Solution:\n    def __init__(self, w):\n        self.prefix_sum = []\n        total = 0\n        for weight in w:\n            total += weight\n            self.prefix_sum.append(total)\n        self.total = total\n\n    def pickIndex(self):\n        target = random.randint(1, self.total)\n        return bisect.bisect_left(self.prefix_sum, target)\n\nif __name__ == \"__main__\":\n    # 讀取全部輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n\n    # 解析成兩個列表：方法名和對應的參數列表\n    try:\n        data = ast.literal_eval('(' + raw_input + ')')\n    except Exception:\n        print(\"[]\")\n        sys.exit()\n\n    methods, args_list = data\n    results = []\n    instance = None\n\n    for method, args in zip(methods, args_list):\n        if method == \"Solution\":\n            # 建構子只呼叫一次\n            instance = Solution(args[0])  # args[0] 是傳入的 w 列表\n            results.append(None)\n        else:\n            # 其他方法直接呼叫\n            func = getattr(instance, method)\n            res = func(*args)\n            results.append(res)\n\n    # 輸出結果，使用 JSON 以得到 null 的表示\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce step-by-step pseudocode for implementing pickIndex. We need to use arrows, decision, Start, End. Each line: code step + space + // explanation.\n\nWe need to show initialization (construct prefix sum array), random generation, binary search. Provide algorithm.\n\nWe should be concise. Provide pseudocode lines:\n\nStart\n→ Step 1: Input array w // Provided\n→ Step 2: Compute prefix sums prefix[] // cumulative weights\n→ Step 3: Compute total = prefix[last]\n→ Step 4: pickIndex() function:\n   → Step 4.1: Generate random number r in [1, total] // inclusive\n   → Step 4.2: Binary search in prefix to find smallest index where prefix[idx] >= r\n   → Step 4.3: Return idx\nEnd\n\nAlso decision points? Not needed except for binary search loop: decision if mid value >= r? yes go left else right.\n\nAdd decision structure.\n\nWe need to maintain pseudocode step style, with arrows and decision.\n\nLet's craft lines:\n\nStart // 程式開始\n\n→ Compute prefix array // 累積權重\n\n→ Step: prefix[0] = w[0]\n→ For i from 1 to w.length-1:\n   → prefix[i] = prefix[i-1] + w[i] // 更新累積\n\n→ total = prefix[w.length-1] // 總權重\n\n→ Define function pickIndex() // 取得隨機索引\n   → Step: Generate r = randomInt(1, total) // 隨機數\n   → Decision: 使用二分搜尋以定位索引\n       → left = 0, right = w.length-1\n       → While left < right:\n           → mid = (left + right) / 2\n           → Decision: prefix[mid] >= r?\n               Yes → right = mid // 索引在左半\n               No  → left = mid + 1 // 索引在右半\n   → Return left // 找到的索引\n\nEnd // 程式結束\n\nWe must ensure each line includes `虛擬碼步驟` + space + `// 解釋`.\n\nLet's format.\n\nUse `→` arrow before each step except Start and End? We use `Start` and `End` as per example.\n\nMake sure decisions are indented with tabs? Use spaces. We should use the arrow for steps, and `Decision:` lines.\n\nThus produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Compute prefix array // 產生累積權重表  \n→ prefix[0] = w[0] // 第一個元素的累積值  \n→ For i from 1 to w.length-1: // 循環填充累積表  \n  → prefix[i] = prefix[i-1] + w[i] // 更新累積權重  \n→ total = prefix[w.length-1] // 取得所有權重之和  \n→ Define function pickIndex() // 定義隨機索引挑選函式  \n  → Generate r = randomInt(1, total) // 產生 [1,total] 內的隨機整數  \n  → Decision: 使用二分搜尋定位索引 // 找到最小 idx 使 prefix[idx] ≥ r  \n    → left = 0, right = w.length-1 // 初始化搜尋範圍  \n    → While left < right: // 迭代二分搜尋  \n      → mid = (left + right) / 2 // 取中點  \n      → Decision: prefix[mid] >= r? // 判斷是否向左移動  \n        Yes → right = mid // 移至左半區  \n        No  → left = mid + 1 // 移至右半區  \n  → Return left // 返回找到的索引  \nEnd // 程式執行結束"
    }
  ]
}