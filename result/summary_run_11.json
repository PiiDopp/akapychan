{
  "run_index": 11,
  "total_files_found": 391,
  "total_files_processed": 323,
  "files_skipped": 68,
  "files_failed_load": 0,
  "---": "--- (以下基於 *題目* 總數) ---",
  "total_problems_attempted": 334,
  "generation_and_validation_success_count": 297,
  "generation_or_validation_failure_count": 37,
  "failed_cases_details": [
    {
      "title": "統計文字行數",
      "source_file": "900.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "（假設 data.txt 內容如下）\\nHello\\nPython\\nWorld",
          "expected_output": "檔案共有 3 行",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '檔案共有3行'\nGot (Norm):      '檔案共有1行'\n--- (Raw) ---\nRaw Expected: '檔案共有 3 行'\nRaw Got:      '檔案共有 1 行'"
        }
      ],
      "generated_code": "import sys\n\ndef main():\n    # 先讀取 stdin（如果需要）\n    stdin_data = sys.stdin.read()\n\n    try:\n        # 嘗試開啟 data.txt\n        with open('data.txt', 'r', encoding='utf-8') as f:\n            lines = f.readlines()\n    except FileNotFoundError:\n        # 若檔案不存在，改用 stdin 的內容（若有）\n        if stdin_data:\n            lines = stdin_data.splitlines()\n        else:\n            print('找不到檔案！')\n            return\n\n    # 輸出行數\n    print('檔案共有', len(lines), '行')\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output a virtual code with arrows and explanation. Use Start, End. Each line: \"虛擬碼步驟 // 解釋\". Use with, try except, read lines, count, print.\n\nLet's produce steps:\n\nStart\n→ Decision: 檔案是否存在? but we can't check directly; use try open. So Step: 尝试用 with open('data.txt','r') as file: // open file\n→ Step: 讀取所有行並計數 // count lines\n→ Step: 輸出計數 // print\n→ Decision: 是否發生 FileNotFoundError? Actually catch.\n\nSo structure: Start → Try: with open... → Inside: lines = file.readlines() → line_count = len(lines) → print line_count. End. Except FileNotFoundError: print '找不到檔案！'.\n\nIn virtual code:\n\nStart // 程式開始執行\n→ Decision: 嘗試開啟檔案? // 開始 try 區塊\n    Yes → Start of try block // 進入 try\n        → Step: with open('data.txt', 'r') as file: // 使用 with 開啟檔案\n            → Step: lines = file.readlines() // 讀取所有行\n            → Step: line_count = len(lines) // 計算行數\n            → Step: print(line_count) // 輸出行數\n    No  → Decision: 是否發生 FileNotFoundError? // except 區塊\n        Yes → Step: print('找不到檔案！') // 顯示錯誤訊息\n        No  → End // 程式結束\n\nBut the try-except is one block. Perhaps simpler: \n→ Step: try: // 嘗試開啟檔案\n→ Indented lines inside try.\n\nWe need arrows.\n\nWe can represent try as Step: try: ; but we can't indent, but we can use arrows to show hierarchy.\n\nSimpler: \n→ Step: try: // 嘗試開啟檔案\n    → Step: with open('data.txt','r') as file: // 使用 with\n        → Step: lines = file.readlines() // 讀取行\n        → Step: line_count = len(lines) // 計行數\n        → Step: print(line_count) // 輸出\n    → Step: except FileNotFoundError: // 捕獲檔案未找到\n        → Step: print('找不到檔案！') // 顯示訊息\nEnd\n\nBut need to follow arrow syntax. Use indentation via arrows.\n\nWe can use \"→\" for steps inside blocks, \"Decision:\" for if/except. But try-except is like \"try:\" and \"except:\".\n\nThus we could treat try as Decision: 是否成功開啟? No but we can use \"Decision: try\" with Yes -> try block, No -> except block? Not necessary.\n\nWe could do:\n\n→ Step: try: // 嘗試開啟檔案\n    → Step: with open('data.txt', 'r') as file: // 使用 with\n        → Step: lines = file.readlines() // 讀取所有行\n        → Step: line_count = len(lines) // 計算行數\n        → Step: print(line_count) // 輸出行數\n    → Decision: 是否拋出 FileNotFoundError? // except 區塊\n        Yes → Step: print('找不到檔案！') // 顯示錯誤訊息\n        No → End // 程式結束\n\nBut \"Decision\" maybe not required for except.\n\nBetter to just produce:\n\nStart // 程式開始執行\n→ Step: try: // 嘗試開啟檔案\n    → Step: with open('data.txt', 'r') as file: // 使用 with\n        → Step: lines = file.readlines() // 讀取所有行\n        → Step: line_count = len(lines) // 計算行數\n        → Step: print(line_count) // 輸出行數\n    → Step: except FileNotFoundError: // 捕捉檔案不存在\n        → Step: print('找不到檔案！') // 顯示錯誤訊息\nEnd // 程式結束\n\nBut we need to ensure each line has \"虛擬碼步驟 [space] // 解釋\". Each step ends with // explanation.\n\nWe need to keep arrow per step.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step: try: // 開始嘗試區塊\n    → Step: with open('data.txt', 'r') as file: // 以讀取模式開啟檔案\n        → Step: lines = file.readlines() // 讀取全部行為列表\n        → Step: line_count = len(lines) // 計算行數\n        → Step: print(line_count) // 輸出行數\n    → Step: except FileNotFoundError: // 捕捉檔案不存在的錯誤\n        → Step: print('找不到檔案！') // 顯示錯誤訊息\nEnd // 程式結束\n\nBut the arrow lines indent after try: etc. We can use \"→\" for each step. For nested blocks, use multiple arrows? The example shows only one arrow per line. But nested uses indentation by indenting the arrow? The example shows \"→ Decision: ...\", then \"Yes → Step ...\", \"No → Decision ...\". So they use indentation of arrows. So we can use \"→\" at same level for each step, but indent for nested lines with spaces before arrow? In example, they didn't indent lines but used \"Yes → Step\" with \"Yes →\". So we might need to use \"→\" for steps inside try block? Actually in example they didn't show try/except. But we can represent try as a decision: \"Decision: 嘗試開啟檔案?\" but that may not be necessary. Let's keep simple.\n\nWe'll show:\n\nStart // 程式開始執行\n→ Decision: 嘗試開啟檔案? // 開始 try 區塊\n    Yes → Step: with open('data.txt', 'r') as file: // 使用 with 開啟檔案\n        → Step: lines = file.readlines() // 讀取所有行\n        → Step: line_count = len(lines) // 計行數\n        → Step: print(line_count) // 輸出行數\n    No  → Decision: 是否拋出 FileNotFoundError? // except 區塊\n        Yes → Step: print('找不到檔案！') // 顯示錯誤訊息\n        No  → End // 程式結束\n\nBut this uses nested decisions. Might be too complex.\n\nLet's follow simple path: Use try and except as steps.\n\nWe can treat \"try:\" as a step and \"except FileNotFoundError:\" as a step. Then indent inside each block with arrows.\n\nSo:\n\nStart // 程式開始執行\n→ Step: try: // 開始嘗試區塊\n    → Step: with open('data.txt', 'r') as file: // 以讀取模式開啟檔案\n        → Step: lines = file.readlines() // 讀取全部行\n        → Step: line_count = len(lines) // 計算行數\n        → Step: print(line_count) // 輸出行數\n→ Step: except FileNotFoundError: // 捕捉檔案不存在\n    → Step: print('找不到檔案！') // 顯示錯誤訊息\nEnd // 程式結束\n\nWe need to ensure each line has arrow or step. The indentation indicates block. Use \"→\" for each step line. For nested inside try, indent with spaces before arrow? In example they don't indent but use \"→\" each line. They show \"Decision: ...\" and then \"Yes → Step\". So we can mimic that: use \"→\" for each line. For nested inside try, just use \"→\" and maybe indent with spaces for readability but not necessary. Example uses only one arrow per line; indentation is not shown.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step: try: // 嘗試執行以下程式碼\n→ Step:     with open('data.txt', 'r') as file: // 以讀取模式開啟檔案\n→ Step:         lines = file.readlines() // 讀取所有行\n→ Step:         line_count = len(lines) // 計算行數\n→ Step:         print(line_count) // 輸出行數\n→ Step: except FileNotFoundError: // 捕捉檔案不存在\n→ Step:     print('找不到檔案！') // 顯示錯誤訊息\nEnd // 程式結束\n\nBut we need to include the arrow and spaces properly. Might be easier to just keep one arrow per line without indentation. Eg:\n\nStart // 程式開始執行\n→ Step: try: // 嘗試開啟檔案\n→ Step: with open('data.txt', 'r') as file: // 以讀取模式開啟檔案\n→ Step: lines = file.readlines() // 讀取所有行\n→ Step: line_count = len(lines) // 計算行數\n→ Step: print(line_count) // 輸出行數\n→ Step: except FileNotFoundError: // 捕捉檔案不存在\n→ Step: print('找不到檔案！') // 顯示錯誤訊息\nEnd // 程式結束\n\nBut the \"except\" needs to be at same indentation as \"try\". So maybe we need to keep them at same level. But it's okay.\n\nI'll output accordingly.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: try: // 嘗試執行以下程式碼  \n→ Step: with open('data.txt', 'r') as file: // 以讀取模式開啟檔案  \n→ Step: lines = file.readlines() // 讀取所有行  \n→ Step: line_count = len(lines) // 計算行數  \n→ Step: print(line_count) // 輸出行數  \n→ Step: except FileNotFoundError: // 捕捉檔案不存在的錯誤  \n→ Step: print('找不到檔案！') // 顯示錯誤訊息  \nEnd // 程式結束"
    },
    {
      "title": "模擬擲骰子遊戲",
      "source_file": "800.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "print(roll_dice(5))",
          "expected_output": "[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,6,1,4,2]#(結果會隨機，每次可能不同)'\nGot (Norm):      '[3,5,4,2,1]'\n--- (Raw) ---\nRaw Expected: '[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)'\nRaw Got:      '[3, 5, 4, 2, 1]'"
        }
      ],
      "generated_code": "import random\nimport sys\n\ndef roll_dice(n):\n    \"\"\"\n    模擬擲 n 次六面骰，回傳所有結果的串列。\n    \"\"\"\n    results = []\n    for _ in range(n):\n        results.append(random.randint(1, 6))\n    return results\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取程式碼並執行\n    code = sys.stdin.read()\n    exec(code, globals())",
      "virtual_code": "Thinking...\nThe user wants a virtual code for a function roll_dice(n) using random module, returning a list of results of n dice rolls. We need to output step-by-step virtual code with explanations. Each line: virtual step + space + // explanation. Use arrow →, Decision, Start, End. So we need to start with Start, then Step 1: Import random, Step 2: Define function roll_dice(n), Step 3: Initialize results list, Step 4: Loop i from 1 to n, inside loop: Step 5: generate random integer 1-6, Step 6: append to results, after loop: Step 7: Return results, End. Use appropriate arrow syntax.\n\nAlso we might include decision about n > 0? Not necessary but we can. But the requirement didn't mention validation. We'll just assume n is positive integer. We'll provide code steps accordingly.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: Import random module // 載入 random\n→ Step 2: Define function roll_dice(n) // 建立函式\n→ Step 3: 初始化 results = [] // 空列表儲存結果\n→ Step 4: For i in range(n): // 迴圈 n 次\n    → Step 5: roll = random.randint(1,6) // 擲骰子\n    → Step 6: results.append(roll) // 將結果加入列表\n→ Step 7: Return results // 回傳結果列表\nEnd // 程式執行結束\n\nNeed to keep each line separated. Indentation inside loop? The example uses nested lines with indentation. We'll format as:\n\nStart // 程式開始執行\n→ Step 1: Import random module // 載入 random\n→ Step 2: Define function roll_dice(n) // 建立函式\n→ Step 3: 初始化 results = [] // 空列表儲存結果\n→ Step 4: For i in range(n): // 迴圈 n 次\n    → Step 5: roll = random.randint(1,6) // 擲骰子\n    → Step 6: results.append(roll) // 將結果加入列表\n→ Step 7: Return results // 回傳結果列表\nEnd // 程式執行結束\n\nBut each line must be separated by newline. The arrow lines that are nested need indentation but still a separate line. So we produce each line separately. Use a space before each nested line? The example shows indentation with spaces but same arrow? We can indent by 4 spaces.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Import random module // 載入 random  \n→ Step 2: Define function roll_dice(n) // 建立函式  \n→ Step 3: 初始化 results = [] // 空列表儲存結果  \n→ Step 4: For i in range(n): // 迴圈 n 次  \n    → Step 5: roll = random.randint(1,6) // 擲骰子  \n    → Step 6: results.append(roll) // 將結果加入列表  \n→ Step 7: Return results // 回傳結果列表  \nEnd // 程式執行結束"
    },
    {
      "title": "計算程式執行時間",
      "source_file": "800.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "import time\n\ndef slow_add(a, b):\n    time.sleep(2)\n    return a + b\n\nprint(measure_time(slow_add, 3, 5))",
          "expected_output": "約 2.0 秒 (依電腦執行環境略有差異)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '約2.0秒(依電腦執行環境略有差異)'\nGot (Norm):      '2.0'\n--- (Raw) ---\nRaw Expected: '約 2.0 秒 (依電腦執行環境略有差異)'\nRaw Got:      '2.0'"
        }
      ],
      "generated_code": "import sys\nimport time\n\ndef measure_time(func, *args):\n    \"\"\"\n    計算 func(*args) 執行所需秒數，並四捨五入到小數點三位。\n    \"\"\"\n    start = time.perf_counter()\n    func(*args)\n    end = time.perf_counter()\n    return round(end - start, 3)\n\ndef main():\n    \"\"\"\n    讀取標準輸入中的程式碼並執行。\n    \"\"\"\n    code = sys.stdin.read()\n    # 建立一個命名空間，讓執行的程式碼可以使用 measure_time\n    ns = {\"measure_time\": measure_time}\n    exec(code, ns)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line with explanation in Chinese, using the specified format. Need to include time module usage, define function measure_time(func, *args). Steps: import time, define function, record start time, call func(*args), record end, compute duration, round to 3 decimal places, return result. The function should return the rounded time. The steps should be in virtual code style with arrows etc. Probably start, decision? Not needed. Just sequential steps. Let's produce virtual code.\n\nThe output must be only the virtual code lines with explanations after each line. Use \"Start\", \"End\". Include arrow \"→\" before steps. Also include function definition etc.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 載入 time 模組 // 引入時間測量功能\n→ Step 2: 定義函式 measure_time(func, *args) // 建立時間測量工具\n    → Step 3: 記錄開始時間 start = time.perf_counter() // 取得高精度起始時間\n    → Step 4: 執行目標函式 result = func(*args) // 呼叫傳入的函式並取得結果\n    → Step 5: 記錄結束時間 end = time.perf_counter() // 取得高精度結束時間\n    → Step 6: 計算耗時 duration = end - start // 取得執行秒數\n    → Step 7: 四捨五入到小數點 3 位 rounded = round(duration, 3) // 將時間四捨五入\n    → Step 8: 回傳 rounded // 回傳測量結果\nEnd // 程式執行結束\n\nBut we need to follow formatting: each line must be \"虛擬碼步驟\" + space + \"// 解釋\". Indent is okay? The example uses indentation for decision branches but each line still begins with \"→\". So we can indent nested lines with spaces before \"→\". Provide them as separate lines.\n\nLet's write.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 載入 time 模組 // 引入時間測量功能  \n→ Step 2: 定義函式 measure_time(func, *args) // 建立時間測量工具  \n  → Step 3: 記錄開始時間 start = time.perf_counter() // 取得高精度起始時間  \n  → Step 4: 執行目標函式 result = func(*args) // 呼叫傳入的函式並取得結果  \n  → Step 5: 記錄結束時間 end = time.perf_counter() // 取得高精度結束時間  \n  → Step 6: 計算耗時 duration = end - start // 取得執行秒數  \n  → Step 7: 四捨五入到小數點 3 位 rounded = round(duration, 3) // 將時間四捨五入  \n  → Step 8: 回傳 rounded // 回傳測量結果  \nEnd // 程式執行結束"
    },
    {
      "title": "集合函數練習",
      "source_file": "600.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "{'apple', 'orange', 'grape', 'melon'}",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '{\"apple\",\"orange\",\"grape\",\"melon\"}'\nGot (Norm):      '{\"melon\",\"grape\",\"orange\",\"apple\"}'\n--- (Raw) ---\nRaw Expected: \"{'apple', 'orange', 'grape', 'melon'}\"\nRaw Got:      \"{'melon', 'grape', 'orange', 'apple'}\""
        }
      ],
      "generated_code": "import sys\n\ndef main():\n    # Consume any input; not used for this problem\n    _ = sys.stdin.read()\n\n    # Initialize the set\n    fruits = {'apple', 'banana'}\n\n    # Add 'orange'\n    fruits.add('orange')\n\n    # Update with 'grape' and 'melon'\n    fruits.update(['grape', 'melon'])\n\n    # Remove 'banana'\n    fruits.remove('banana')\n\n    # Discard 'pineapple' (does nothing if absent)\n    fruits.discard('pineapple')\n\n    # Output the final set\n    print(fruits)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line with comments. Use arrow notation. Start, End. Steps: create set, add, update, remove, discard, print. Use virtual code, no actual code. Provide concise explanations. Use 虛擬碼步驟, space, // explanation. Use arrow. Use Decision? Not necessary. We'll just sequential. Use \"Step 1: 初始化集合 fruits = {'apple', 'banana'}\" etc. Provide arrow. Provide End. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化集合 fruits = {'apple', 'banana'} // 建立初始集合  \n→ Step 2: 使用 add() 新增 'orange' // 將 'orange' 加入集合  \n→ Step 3: 使用 update() 一次新增 'grape' 與 'melon' // 同時加入兩個新元素  \n→ Step 4: 使用 remove() 移除 'banana' // 刪除指定元素，若不存在會錯誤  \n→ Step 5: 使用 discard() 嘗試移除 'pineapple' // 失敗時不報錯  \n→ Step 6: 輸出集合 fruits // 顯示最終集合內容  \nEnd // 程式執行結束"
    },
    {
      "title": "即時匯率查詢小工具",
      "source_file": "1200.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "按下「更新匯率」按鈕",
          "expected_output": "目前美元匯率：約 32.5 TWD",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '目前美元匯率：約32.5TWD'\nGot (Norm):      '目前美元匯率：約30.82TWD'\n--- (Raw) ---\nRaw Expected: '目前美元匯率：約 32.5 TWD'\nRaw Got:      '目前美元匯率：約 30.82 TWD'"
        }
      ],
      "generated_code": "import requests\nimport sys\n\ndef get_rate() -> float | None:\n    \"\"\"\n    取得 USD 對 TWD 的匯率，若失敗回傳 None。\n    \"\"\"\n    try:\n        url = \"https://api.exchangerate-api.com/v4/latest/USD\"\n        response = requests.get(url, timeout=5)\n        response.raise_for_status()\n        data = response.json()\n        return data[\"rates\"][\"TWD\"]\n    except Exception:\n        return None\n\ndef main() -> None:\n    \"\"\"\n    主程式，從 stdin 讀取輸入，若包含「更新匯率」則取得匯率並輸出。\n    \"\"\"\n    # 讀取整個輸入\n    command = sys.stdin.read().strip()\n\n    if \"更新匯率\" in command:\n        rate = get_rate()\n        if rate is not None:\n            # 以兩位小數輸出\n            print(f\"目前美元匯率：約 {rate:.2f} TWD\")\n        else:\n            print(\"更新失敗，請檢查網路連線\")\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step with explanation after each line. Use arrow, decisions. Use Start, End. Must not output real code. Just virtual steps.\n\nRequirements: use requests module to call exchangerate-api, get USD to TWD. Display in tkinter window. Button to refresh. Virtual code steps: import modules, create root window, create label, create button, define function to fetch rate and update label, call at start, set button command, mainloop, End.\n\nAlso need to show decision about error maybe? Could include Decision: If response ok? Yes -> update label; No -> show error. Use arrow lines.\n\nWe need each line: \"虛擬碼步驟 // 解釋\". Use Start and End. Provide arrow \"→\" before each step. Use indentation for nested decisions.\n\nLet's craft. Use \"Start\" line no arrow. Then \"→ Step 1: import requests, tkinter\". Explanation. Then \"→ Step 2: 建立 tkinter 主視窗\". Then \"→ Step 3: 建立顯示匯率的 Label\". \"→ Step 4: 建立更新匯率的 Button\". \"→ Step 5: 定義 fetch_rate 函式\". Inside fetch_rate: \"→ Step 6: 使用 requests.get 取得 API 內容\". \"→ Decision: 若回應成功?\" Then Yes and No branches. For Yes: \"→ Step 7: 解析 JSON 並取得 TWD 匯率\". \"→ Step 8: 更新 Label 文字為 'USD/TWD = xxx'\". For No: \"→ Step 9: 更新 Label 文字為 '取得匯率失敗'\". Then \"→ Step 10: 設定 Button command 為 fetch_rate\". \"→ Step 11: 初次調用 fetch_rate 以顯示匯率\". \"→ Step 12: 執行 tkinter mainloop\". \"End\". Provide explanation each line.\n\nAlso need to include arrow for Start? In example, Start line has no arrow. Then arrow for each step. For decisions, include indentation.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: import requests, tkinter, json // 匯入 HTTP 與 GUI 所需模組  \n→ Step 2: root = tkinter.Tk() // 建立主視窗物件  \n→ Step 3: rate_label = tkinter.Label(root, text=\"匯率載入中…\") // 佈局顯示匯率的文字元件  \n→ Step 4: rate_label.pack(padx=20, pady=10) // 置中顯示標籤  \n→ Step 5: refresh_button = tkinter.Button(root, text=\"更新匯率\") // 建立按鈕元件  \n→ Step 6: refresh_button.pack(pady=5) // 放置按鈕於視窗  \n→ Step 7: define fetch_rate() // 定義取得並更新匯率的函式  \n&nbsp;&nbsp;→ Step 8: response = requests.get(\"https://api.exchangerate-api.com/v4/latest/USD\") // 呼叫 API  \n&nbsp;&nbsp;→ Decision: 若 response.status_code == 200? // 檢查 HTTP 回應是否成功  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 9: data = response.json() // 解析回傳的 JSON  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 10: twd_rate = data[\"rates\"][\"TWD\"] // 取得 USD→TWD 匯率  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 11: rate_label.config(text=f\"USD/TWD = {twd_rate}\") // 更新標籤文字  \n&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 12: rate_label.config(text=\"取得匯率失敗\") // 顯示錯誤訊息  \n→ Step 13: refresh_button.config(command=fetch_rate) // 將按鈕與 fetch_rate 連結  \n→ Step 14: fetch_rate() // 初始呼叫一次以載入匯率  \n→ Step 15: root.mainloop() // 啟動 tkinter 事件迴圈  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Flip Matrix",
      "source_file": "Leetcode/leetcode519.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"flip\", \"flip\", \"flip\", \"reset\", \"flip\"], [[3, 1], [], [], [], [], []]",
          "expected_output": "[null, [1,0], [2,0], [0,0], null, [2,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[1,0],[2,0],[0,0],null,[2,0]]'\nGot (Norm):      '[null,[0,0],[2,0],[1,0],null,[0,0]]'\n--- (Raw) ---\nRaw Expected: '[null, [1,0], [2,0], [0,0], null, [2,0]]'\nRaw Got:      '[null, [0, 0], [2, 0], [1, 0], null, [0, 0]]'"
        }
      ],
      "generated_code": "import sys\nimport random\nimport json\nimport ast\n\nclass Solution:\n    def __init__(self, m, n):\n        self.m = m\n        self.n = n\n        self.total = m * n\n        self.flipped = {}\n\n    def flip(self):\n        r = random.randint(0, self.total - 1)\n        x = self.flipped.get(r, r)\n        self.total -= 1\n        self.flipped[r] = self.flipped.get(self.total, self.total)\n        return [x // self.n, x % self.n]\n\n    def reset(self):\n        self.total = self.m * self.n\n        self.flipped.clear()\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    # parse input like: [\"Solution\", \"flip\", ...], [[3, 1], [], ...]\n    ops, args_list = ast.literal_eval(data)\n    obj = None\n    outputs = []\n    for op, args in zip(ops, args_list):\n        if op == \"Solution\":\n            obj = Solution(*args)\n            outputs.append(None)          # null in JSON\n        elif op == \"flip\":\n            outputs.append(obj.flip())\n        elif op == \"reset\":\n            obj.reset()\n            outputs.append(None)          # null in JSON\n    print(json.dumps(outputs))",
      "virtual_code": "Thinking...\nWe need to output virtual code lines with explanation after each. The requirement: no real code, just virtual steps. Need to design algorithm: Use reservoir? Actually classic LeetCode 519. Approach: Map random to index via a mapping from available indices to chosen. Keep count of remaining zeros. For flip: pick random k in [0, remaining-1], map to actual index using dictionary mapping: if mapping contains k, actual = mapping[k], else actual = k. Similarly map the last index r = remaining-1 to be swapped: if mapping contains r, last = mapping[r], else last = r. Then set mapping[k] = last, decrement remaining. Convert flat index to (i,j). For reset: clear mapping, set remaining = m*n. Complexity: O(1) average per flip.\n\nNeed to output steps: Start, initialize mapping empty, set total = m*n. flip: generate random int. Map. Swap. Update. Convert to coordinates. reset: clear mapping, set total.\n\nWe'll produce virtual code lines.\n\nLet's produce:\n\nStart // start program\n→ Step 1: Initialize total = m * n // total number of cells\n→ Step 2: Initialize mapping = empty dictionary // maps available indices\n→ Decision: 是否調用 flip? // check if flip called\n    Yes → Step 3: 隨機選取 k ∈ [0, total-1] // choose random index among remaining zeros\n    → Step 4: actualIndex = mapping.get(k, k) // if mapping contains k use mapped value else k\n    → Step 5: lastIndex = total - 1 // last available index\n    → Step 6: lastMapped = mapping.get(lastIndex, lastIndex) // get mapping for last\n    → Step 7: mapping[k] = lastMapped // swap k with last\n    → Step 8: total = total - 1 // reduce remaining count\n    → Step 9: i = actualIndex // m // row number\n    → Step 10: j = actualIndex % n // column number\n    → Step 11: return [i, j] // output coordinates\n    No → End // end of flip process\n→ Decision: 是否調用 reset? // check if reset called\n    Yes → Step 12: mapping.clear() // clear mapping\n    → Step 13: total = m * n // reset total\n    → End // reset finished\nEnd // program end\n\nBut we need virtual steps for reset and flip separately. Provide separate sections.\n\nAlso include 'Start' 'End'. Each line: step comment. Use arrow '→' for sequence, 'Yes →' 'No →'.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n\n→ Step 1: total ← m * n // 初始化剩餘可翻轉的 0 的數量  \n→ Step 2: mapping ← {} // 建立空字典，用於映射已被選取的索引  \n\n// ---- flip 方法 ----\n→ Decision: 是否呼叫 flip? // 判斷是否需要進行一次翻轉\n    Yes → Step 3: k ← randomInt(0, total - 1) // 隨機選取一個在剩餘 0 之間的索引  \n    → Step 4: actual ← mapping.get(k, k) // 若 k 已映射，取得映射值，否則使用 k 本身  \n    → Step 5: last ← total - 1 // 取得最後一個剩餘索引  \n    → Step 6: lastMapped ← mapping.get(last, last) // 若 last 已映射，取得映射值，否則使用 last 本身  \n    → Step 7: mapping[k] ← lastMapped // 將 k 的位置映射到最後一個索引，完成交換  \n    → Step 8: total ← total - 1 // 更新剩餘可翻轉的 0 的數量  \n    → Step 9: i ← actual // m // 轉換成行坐標  \n    → Step 10: j ← actual % n // 轉換成列坐標  \n    → Step 11: return [i, j] // 回傳隨機選取的 (i, j) 並已將其標記為 1  \n    No → End // flip 完成\n\n// ---- reset 方法 ----\n→ Decision: 是否呼叫 reset? // 判斷是否需要重置矩陣\n    Yes → Step 12: mapping.clear() // 清空映射，恢復所有索引可用  \n    → Step 13: total ← m * n // 重設剩餘 0 的數量為完整矩陣大小  \n    → End // reset 完成\n\nEnd // 程式執行結束"
    },
    {
      "title": "Two Sum",
      "source_file": "Leetcode/leetcode1.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [2,7,11,15], target = 9",
          "expected_output": "[0,1]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp_qm4jkk4.py\", line 28, in <module>\n    target_str = target_part.split('=', 1)[1].strip()\n                 ~~~~~~~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        },
        {
          "example_index": 1,
          "input": "nums = [3,2,4], target = 6",
          "expected_output": "[1,2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp0o870ozi.py\", line 28, in <module>\n    target_str = target_part.split('=', 1)[1].strip()\n                 ~~~~~~~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        },
        {
          "example_index": 2,
          "input": "nums = [3,3], target = 6",
          "expected_output": "[0,1]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpiihn3z_c.py\", line 28, in <module>\n    target_str = target_part.split('=', 1)[1].strip()\n                 ~~~~~~~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def twoSum(self, nums, target):\n        \"\"\"\n        使用哈希表在 O(n) 時間內找到兩個數字的索引。\n        \"\"\"\n        index_map = {}               # 先前遇到的數值對應索引\n        for i, val in enumerate(nums):\n            complement = target - val\n            if complement in index_map:\n                return [index_map[complement], i]\n            index_map[val] = i\n        return []  # 在題目保證存在唯一解的情況下，這行不會被執行\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個內容\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n\n    # 解析輸入格式: \"nums = [2,7,11,15], target = 9\"\n    parts = raw_input.split(',')\n    nums_part = parts[0].strip()          # \"nums = [2,7,11,15]\"\n    target_part = parts[1].strip()        # \"target = 9\"\n\n    nums_str = nums_part.split('=', 1)[1].strip()\n    target_str = target_part.split('=', 1)[1].strip()\n\n    # 使用 eval 解析 list，轉成 int 解析目標\n    nums = eval(nums_str)\n    target = int(target_str)\n\n    sol = Solution()\n    result = sol.twoSum(nums, target)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to output virtual code lines: Start, → Step, Decision etc. Need to include explanation comment.\n\nWe must not output actual code. Just pseudo steps. Provide line-by-line. Should cover typical algorithm: hash map.\n\nWe'll produce:\n\nStart // program start\n→ Step 1: 初始化空哈希表 map // store value->index\n→ For each index i in nums:\n    → Step 2: 計算 complement = target - nums[i] // 需要的另一個數\n    → Decision: 如果 complement 已存在於 map? // 檢查是否已找到配對\n        Yes → Step 3: 回傳 [map[complement], i] // 找到答案\n        No  → Step 4: 將 nums[i] 及其索引 i 存入 map // 供後續查找\nEnd // 程式結束\n\nNeed to format lines with arrow, colon etc. Use \"Step\" numbering maybe Step 1, Step 2 etc. Use Decision indentation.\n\nNeed to include brackets properly.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空哈希表 map // 用於儲存已遍歷元素及其索引  \n→ Step 2: 對於每個索引 i 從 0 到 nums.length - 1 進行迴圈  \n  → Step 2.1: 計算 complement = target - nums[i] // 需要的另一個數  \n  → Decision: 如果 complement 已存在於 map? // 檢查是否已有配對  \n    Yes → Step 2.2: 回傳 [map[complement], i] // 找到符合條件的兩個索引  \n    No  → Step 2.3: 將 nums[i] 及其索引 i 存入 map // 供後續搜尋使用  \nEnd // 程式執行結束"
    },
    {
      "title": "Merge Sorted Array",
      "source_file": "Leetcode/leetcode88.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3",
          "expected_output": "[1,2,2,3,5,6]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp5tbrl8o3.py\", line 49, in <module>\n    main()\n  File \"/tmp/tmp5tbrl8o3.py\", line 36, in main\n    vars_dict[key] = ast.literal_eval(val)\n                     ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def merge(self, nums1, m, nums2, n):\n        i = m - 1\n        j = n - 1\n        k = m + n - 1\n        while i >= 0 and j >= 0:\n            if nums1[i] > nums2[j]:\n                nums1[k] = nums1[i]\n                i -= 1\n            else:\n                nums1[k] = nums2[j]\n                j -= 1\n            k -= 1\n        while j >= 0:\n            nums1[k] = nums2[j]\n            j -= 1\n            k -= 1\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Split the input by commas that separate assignments\n    parts = [p.strip() for p in data.split(',')]\n    vars_dict = {}\n    for part in parts:\n        if '=' not in part:\n            continue\n        key, val = part.split('=', 1)\n        key = key.strip()\n        val = val.strip()\n        if key in ('nums1', 'nums2'):\n            vars_dict[key] = ast.literal_eval(val)\n        else:\n            vars_dict[key] = int(val)\n    nums1 = vars_dict.get('nums1', [])\n    m = vars_dict.get('m', 0)\n    nums2 = vars_dict.get('nums2', [])\n    n = vars_dict.get('n', 0)\n\n    sol = Solution()\n    sol.merge(nums1, m, nums2, n)\n    print(nums1)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for merging two sorted arrays into nums1, like Leetcode 88 merge array. Use virtual code with Start, Decision, arrows, etc.\n\nWe need to output line by line with explanation comment. Each line: `虛擬碼步驟 // 解釋`.\n\nLet's craft:\n\nStart\n→ Set i = m - 1 // last index of real elements in nums1\n→ Set j = n - 1 // last index of nums2\n→ Set k = m + n - 1 // last index of nums1 array\n→ Decision: i >= 0 or j >= 0? // while any elements remain\n    Yes →\n        → Decision: j < 0? // no more in nums2\n            Yes → Step: i--? Actually if j<0, copy remaining nums1? Actually we can break. But typical algorithm: while j >=0\n        → Decision: i < 0? // no more in nums1\n            Yes → Copy nums2[j] to nums1[k]; j--; k--; Continue\n        → Decision: nums1[i] > nums2[j]? // compare\n            Yes → nums1[k] = nums1[i]; i--; k--;\n            No  → nums1[k] = nums2[j]; j--; k--;\n    No → End\n\nBut we need to express with virtual code. We should include while loop? Use Decision with Yes/No. Perhaps represent while loop via Decision: i >=0 or j >=0? Yes loop.\n\nLet's produce lines:\n\nStart // program starts\n→ Set i = m - 1 // index of last real element in nums1\n→ Set j = n - 1 // index of last element in nums2\n→ Set k = m + n - 1 // index of last position in nums1\n→ Decision: i >= 0 or j >= 0? // continue while elements remain\n    Yes →\n        → Decision: j < 0? // nums2 exhausted\n            Yes →\n                → Step: Break // end loop\n            No →\n                → Decision: i < 0? // nums1 exhausted\n                    Yes →\n                        → Step: nums1[k] = nums2[j]; // copy remaining nums2\n                        → Step: j = j - 1; // move j\n                        → Step: k = k - 1; // move k\n                        → Step: Continue // repeat loop\n                    No →\n                        → Decision: nums1[i] > nums2[j]? // compare current elements\n                            Yes →\n                                → Step: nums1[k] = nums1[i]; // place larger from nums1\n                                → Step: i = i - 1;\n                                → Step: k = k - 1;\n                                → Step: Continue\n                            No  →\n                                → Step: nums1[k] = nums2[j]; // place larger from nums2\n                                → Step: j = j - 1;\n                                → Step: k = k - 1;\n                                → Step: Continue\n    No → End // finished merging\n\nBut each line must be a single virtual code step with comment. Need to maintain the \"→\" arrow for steps within decision branches. Use indentation or not? In example, indentation used to show hierarchy. We'll mimic.\n\nWe need to include Decision: and branches Yes / No. Use same format as example.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Set i = m - 1 // 初始化指向 nums1 的最後一個有效元素\n→ Set j = n - 1 // 初始化指向 nums2 的最後一個元素\n→ Set k = m + n - 1 // 初始化指向 nums1 的最後一個位置\n→ Decision: i >= 0 或 j >= 0? // 只要還有未合併的元素就繼續\n    Yes →\n        → Decision: j < 0? // nums2 已經全部合併\n            Yes →\n                → Step: 退出循環 // 兩個陣列均已合併完畢\n            No →\n                → Decision: i < 0? // nums1 已經全部合併\n                    Yes →\n                        → Step: nums1[k] = nums2[j]; // 把剩餘的 nums2 元素搬入\n                        → Step: j = j - 1; // 移動 j\n                        → Step: k = k - 1; // 移動 k\n                        → Step: 繼續 // 回到 Decision\n                    No →\n                        → Decision: nums1[i] > nums2[j]? // 比較當前元素大小\n                            Yes →\n                                → Step: nums1[k] = nums1[i]; // 把較大的 nums1 元素放到最末\n                                → Step: i = i - 1;\n                                → Step: k = k - 1;\n                                → Step: 繼續\n                            No  →\n                                → Step: nums1[k] = nums2[j]; // 把較大的 nums2 元素放到最末\n                                → Step: j = j - 1;\n                                → Step: k = k - 1;\n                                → Step: 繼續\n    No → End // 合併完成，程式結束\n\nBut we need each line as \"虛擬碼步驟 // 解釋\". The example had no indent. But the example used indentation for branches: They had `→ Decision: ...` and then `Yes →` lines under indent. We should replicate.\n\nWe need to include arrow for each step. For nested steps, use indentation. Eg:\n\n→ Decision: i >= 0 或 j >= 0? // ...\n    Yes →\n        → Decision: j < 0? // ...\n            Yes →\n                → Step: 退出循環 // ...\n            No →\n                → Decision: i < 0? // ...\n                    Yes →\n                        → Step: ...\n                    No →\n                        → Decision: nums1[i] > nums2[j]? // ...\n                            Yes →\n                                → Step: ...\n                            No  →\n                                → Step: ...\n\nBut each line must start with \"→\" or other? In example, lines after Start had \"→ Step 1: ...\". The \"Decision:\" lines had \"→ Decision: ...\" and branches had \"Yes →\" lines. So we should use same. Use \"→\" for all lines. Let's produce accordingly.\n\nAlso include \"End\" after the loop. The \"End\" line should be not indented? Example had End // 程式執行結束. So we use End.\n\nAlso include comments.\n\nLet's write final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Set i = m - 1 // 初始化指向 nums1 的最後一個有效元素  \n→ Set j = n - 1 // 初始化指向 nums2 的最後一個元素  \n→ Set k = m + n - 1 // 初始化指向 nums1 的最後一個位置  \n→ Decision: i >= 0 或 j >= 0? // 只要還有未合併的元素就繼續  \n    Yes →  \n        → Decision: j < 0? // nums2 已經全部合併  \n            Yes →  \n                → Step: 退出循環 // 兩個陣列均已合併完畢  \n            No →  \n                → Decision: i < 0? // nums1 已經全部合併  \n                    Yes →  \n                        → Step: nums1[k] = nums2[j]; // 把剩餘的 nums2 元素搬入  \n                        → Step: j = j - 1; // 移動 j  \n                        → Step: k = k - 1; // 移動 k  \n                        → Step: 繼續 // 回到外層 Decision  \n                    No →  \n                        → Decision: nums1[i] > nums2[j]? // 比較當前元素大小  \n                            Yes →  \n                                → Step: nums1[k] = nums1[i]; // 把較大的 nums1 元素放到最末  \n                                → Step: i = i - 1;  \n                                → Step: k = k - 1;  \n                                → Step: 繼續  \n                            No →  \n                                → Step: nums1[k] = nums2[j]; // 把較大的 nums2 元素放到最末  \n                                → Step: j = j - 1;  \n                                → Step: k = k - 1;  \n                                → Step: 繼續  \n    No → End // 合併完成，程式結束"
    },
    {
      "title": "Subsets II",
      "source_file": "Leetcode/leetcode90.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,2]",
          "expected_output": "[[],[1],[1,2],[1,2,2],[2],[2,2]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[1,2],[1,2,2],[2],[2,2]]'\nGot (Norm):      '[[],[1],[2],[1,2],[2,2],[1,2,2]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[1,2],[1,2,2],[2],[2,2]]'\nRaw Got:      '[[],[1],[2],[1,2],[2,2],[1,2,2]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def subsetsWithDup(self, nums):\n        \"\"\"Return all unique subsets of a list that may contain duplicates.\"\"\"\n        nums.sort()                # 讓相同元素相鄰，方便後續處理\n        res = [[]]                 # 初始只有空集合\n        for num in nums:\n            # 為每個已存在的子集加入當前元素，產生新的子集\n            new_subsets = [subset + [num] for subset in res]\n            res += new_subsets\n\n        # 由於可能出現重複子集，使用 set 做去重\n        seen = set()\n        unique_res = []\n        for subset in res:\n            t = tuple(subset)       # 列表不可哈希，先轉成 tuple\n            if t not in seen:\n                seen.add(t)\n                unique_res.append(subset)\n        return unique_res\n\ndef format_result(result):\n    \"\"\"將結果轉換為沒有空格的字串，例如 [[1,2],[3]] → '[[1,2],[3]]'。\"\"\"\n    subsets_str = []\n    for subset in result:\n        if not subset:\n            subsets_str.append(\"[]\")\n        else:\n            subsets_str.append(\"[\" + \",\".join(str(x) for x in subset) + \"]\")\n    return \"[\" + \",\".join(subsets_str) + \"]\"\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入，支援「nums = [1,2,2]」或直接「[1,2,2]」\n    if \"=\" in data:\n        _, rhs = data.split(\"=\", 1)\n        data = rhs.strip()\n    try:\n        nums = ast.literal_eval(data)\n    except Exception as e:\n        print(f\"Error parsing input: {e}\", file=sys.stderr)\n        return\n\n    solution = Solution()\n    subsets = solution.subsetsWithDup(nums)\n    output = format_result(subsets)\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for generating power set of array with duplicates, avoiding duplicate subsets. Should use algorithm typical: sort array, backtrack with skip duplicates. Provide step-by-step.\n\nWe output line by line: Start, Step etc.\n\nWe must not output real code. So each line: \"Step: ... // explanation\".\n\nWe can show structure with indentation. Use Decision, etc.\n\nLet's produce a virtual algorithm.\n\nWe need to show steps:\n\nStart\n→ Step 1: sort nums // order duplicates adjacent\n→ Step 2: initialize result list // store subsets\n→ Step 3: call backtrack(0, empty subset) // DFS\nInside backtrack(index, current)\n   → Decision: index == len(nums)? // if reached end\n        Yes → Step: add current to result // complete subset\n        No → Decision: include current nums[index]?\n           Yes → Step: add nums[index] to current // include\n              → Step: backtrack(index+1, current) // recursive\n              → Step: remove last element from current // backtrack\n           No → Decision: if index>0 and nums[index]==nums[index-1] and not included? // skip duplicates\n              Yes → Step: skip this element and backtrack(index+1, current) // avoid duplicate subsets\n              No → Step: backtrack(index+1, current) // skip normally\nEnd\n\nWe need to format with arrows and indentation.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 將輸入陣列 nums 依升序排序 // 使重複元素相鄰，方便跳過重複\n→ Step 2: 建立空的列表 result 用於儲存所有子集 // 結果集合\n→ Step 3: 呼叫遞迴函式 backtrack(0, 空子集) // 從索引 0 開始探索\n\n// 定義遞迴函式 backtrack(index, current)\n→ Decision: index 是否等於 nums 的長度？ // 檢查是否已遍歷完所有元素\n    Yes → Step 4: 將目前的子集 current 複製並加入 result // 子集完成\n    No  → Decision: 是否考慮包含 nums[index]？ // 兩種分支：包含或不包含\n        Yes → Step 5: 將 nums[index] 加入 current // 包含此元素\n              → Step 6: 呼叫 backtrack(index + 1, current) // 進行下一層遞迴\n              → Step 7: 從 current 中移除最後一個元素 // 回溯，恢復狀態\n        No  → Decision: 是否跳過重複元素？ // 避免重複子集\n            Yes → Step 8: 呼叫 backtrack(index + 1, current) // 跳過此重複元素\n            No  → Step 9: 呼叫 backtrack(index + 1, current) // 正常跳過非重複元素\n\nEnd // 程式執行結束\n\n(Note: 在 Step 9 的判斷中，實際實作會檢查「當 index > 0 且 nums[index] == nums[index-1] 時，若上一層未包含此元素，則跳過以避免重複子集。」)"
    },
    {
      "title": "Random Pick Index",
      "source_file": "Leetcode/leetcode398.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\"], [[[1, 2, 3, 3, 3]], [3], [1], [3]]",
          "expected_output": "[null, 4, 0, 2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp71q4bd9v.py\", line 47, in <module>\n    main()\n  File \"/tmp/tmp71q4bd9v.py\", line 28, in main\n    args_list = ast.literal_eval(args_str)\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[[[1, 2, 3, 3, 3]], [3], [1], [3]]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\nimport json\nfrom collections import defaultdict\n\nclass Solution:\n    def __init__(self, nums):\n        # 建立從數字到其所有索引的映射\n        self.indices = defaultdict(list)\n        for i, num in enumerate(nums):\n            self.indices[num].append(i)\n\n    def pick(self, target):\n        # 隨機挑選符合 target 的索引\n        return random.choice(self.indices[target])\n\ndef main():\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n\n    # 將輸入拆分成兩個列表：方法名稱和對應參數\n    parts = raw_input.split('],', 1)\n    methods_str = parts[0] + ']'\n    args_str = '[' + parts[1].strip()\n    methods = ast.literal_eval(methods_str)\n    args_list = ast.literal_eval(args_str)\n\n    # 建構物件\n    obj = Solution(*args_list[0])\n    results = [None]  # constructor 的返回值為 null\n\n    # 執行後續方法\n    for i, method in enumerate(methods[1:], 1):\n        if method == 'pick':\n            result = obj.pick(*args_list[i])\n            results.append(result)\n        else:\n            # 若未預期的方法，直接 append None\n            results.append(None)\n\n    # 輸出結果，None 轉為 JSON null\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code lines, no actual code. The requirement: Given an integer array nums with duplicates, random index of target number. Implement Solution class: constructor takes array nums, init. pick(target) returns random index among indices where nums[i]==target. Each index equal probability.\n\nWe need to produce virtual code steps. Should reflect design: store map from target to list of indices. Then pick random index from list. Implementation steps: Start, read array, iterate over indices, populate map. End. Then pick: Input target, get list, random index from list length, return list[randomIndex]. Add steps.\n\nWe need each line: virtual code step + space + // explanation.\n\nUse Start, End, Decision, etc. Use arrow →.\n\nShould we use loops and conditions: For loop to populate map. For pick: Decision if target exists? But assumption target exists.\n\nOk produce steps:\n\nStart\n→ Step 1: Initialize an empty hash map M // Map target to list of indices\n→ Step 2: For each index i from 0 to length-1 in nums // Iterate through array\n    → Step 3: Let val = nums[i] // Current value\n    → Step 4: If M does not contain val\n        → Step 5: Add val -> new empty list to M // Initialize list\n    → Step 6: Append i to M[val] // Store index\nEnd\n\nPick function:\nStart\n→ Step 7: Input target // Target number\n→ Step 8: Retrieve list L = M[target] // List of indices\n→ Step 9: Generate random integer r in [0, length(L)-1] // Random index\n→ Step 10: Return L[r] // Return chosen index\nEnd\n\nMake sure each line has // explanation. Use arrow lines.\n\nLet's format as per example: \"Start // 程式開始執行\". Use Start, End. Use arrow for steps. Use indentation for nested steps.\n\nAdd explanation in Chinese.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空哈希表 M // 建立目標值到其索引列表的映射  \n→ Step 2: 對於陣列 nums 的每個索引 i 從 0 到 len(nums)-1  \n    → Step 3: 取出 val = nums[i] // 當前元素值  \n    → Step 4: 如果 M 尚未包含 val  \n        → Step 5: 在 M 中加入鍵 val 與空列表 [] // 為新值建立列表  \n    → Step 6: 將索引 i 加入 M[val] // 存儲此值的索引  \nEnd // 完成建構子初始化  \n\nStart // pick 方法開始執行  \n→ Step 7: 接收目標值 target // 需要隨機挑選的目標  \n→ Step 8: 取得對應索引列表 L = M[target] // 取得所有符合的索引  \n→ Step 9: 產生隨機整數 r，範圍為 0 到 len(L)-1 // 隨機選擇其中一個索引  \n→ Step 10: 回傳 L[r] // 回傳隨機選中的索引  \nEnd // pick 方法執行結束"
    },
    {
      "title": "Sort Characters By Frequency",
      "source_file": "Leetcode/leetcode451.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"tree\"",
          "expected_output": "\"eert\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'eert'\nGot (Norm):      'eetr'\n--- (Raw) ---\nRaw Expected: '\"eert\"'\nRaw Got:      'eetr'"
        },
        {
          "example_index": 1,
          "input": "s = \"cccaaa\"",
          "expected_output": "\"aaaccc\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'aaaccc'\nGot (Norm):      'cccaaa'\n--- (Raw) ---\nRaw Expected: '\"aaaccc\"'\nRaw Got:      'cccaaa'"
        }
      ],
      "generated_code": "import sys\nfrom collections import Counter\n\ndef frequency_sort(s: str) -> str:\n    \"\"\"\n    將字串 s 按照字元出現頻率遞減排序，若頻率相同則保持任何順序。\n    \"\"\"\n    # 統計每個字元的頻率\n    counter = Counter(s)\n    # most_common() 會自動按頻率遞減排序\n    # 生成結果字串\n    return ''.join(char * freq for char, freq in counter.most_common())\n\ndef parse_input(raw: str) -> str:\n    \"\"\"\n    解析從 stdin 讀取的原始輸入，支持兩種常見格式：\n    1. 直接給出字串，例如 tree\n    2. 帶有前綴 s = \"tree\" 的輸入\n    \"\"\"\n    raw = raw.strip()\n    # 若包含等號，嘗試提取引號中的內容\n    if '=' in raw:\n        # 找第一個雙引號\n        first_quote = raw.find('\"')\n        last_quote = raw.rfind('\"')\n        if first_quote != -1 and last_quote != -1 and last_quote > first_quote:\n            return raw[first_quote + 1:last_quote]\n        # 可能是單引號或沒有引號的情況\n        parts = raw.split('=', 1)[1].strip()\n        return parts.strip('\\'\"')\n    # 直接返回整行\n    return raw\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw_input = sys.stdin.read()\n    s = parse_input(raw_input)\n    result = frequency_sort(s)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce a step-by-step pseudo-code for sorting characters by frequency descending. Steps: count frequencies, sort characters by freq descending, build result string. Need to use arrow notation. Each line with explanation. Use Start, Decision, End. Also maybe loop. Use \"Step\" naming. Let's produce.\n\nAlso \"If multiple answers return any of them\" meaning no tie-breaking needed.\n\nImplement pseudocode:\n\nStart\n→ Step 1: 初始化字典 freq = {}\n→ Step 2: 逐個字符 ch 在 s 中:\n    → Decision: 如果 ch 在 freq 中? // 檢查是否已計數\n        Yes → Step 3: freq[ch] += 1 // 增加計數\n        No  → Step 4: freq[ch] = 1 // 初始計數\n→ Step 5: 建立列表 pairs = []\n→ Step 6: 對於每個 (ch, count) 在 freq:\n    → Step 7: 加入 pairs.append((count, ch))\n→ Step 8: 對 pairs 進行排序，鍵為 count 降序\n→ Step 9: 初始化結果 str_builder = []\n→ Step 10: 對於每個 (count, ch) 在 pairs:\n    → Step 11: str_builder.append(ch * count) // 重複字符 count 次\n→ Step 12: 返回 ''.join(str_builder) // 合併為字符串\nEnd\n\nWe can shorten by merging some steps. But should be fine.\n\nWe need each line with virtual code and explanation.\n\nLet's produce. Use indentation for decisions. Provide arrow and colon.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化字典 freq = {} // 用於統計每個字符的出現頻率  \n→ Step 2: 逐個字符 ch 在 s 中: // 遍歷輸入字串  \n  → Decision: 如果 ch 在 freq 中? // 檢查字典中是否已有此字符  \n   Yes → Step 3: freq[ch] += 1 // 已存在，頻率加 1  \n   No  → Step 4: freq[ch] = 1 // 尚未存在，初始頻率為 1  \n→ Step 5: 建立列表 pairs = [] // 用於存放 (頻率, 字符) 的元組  \n→ Step 6: 對於每個 (ch, count) 在 freq: // 轉化字典為列表  \n  → Step 7: pairs.append((count, ch)) // 將 (頻率, 字符) 加入列表  \n→ Step 8: 對 pairs 進行排序，鍵為 count 降序 // 依頻率降序排列  \n→ Step 9: 初始化結果 str_builder = [] // 用於組合最終字串  \n→ Step 10: 對於每個 (count, ch) 在 pairs: // 依排序順序重複字符  \n  → Step 11: str_builder.append(ch * count) // 把重複後的字符加入結果  \n→ Step 12: 返回 ''.join(str_builder) // 合併列表為最終字串並返回  \nEnd // 程式執行結束"
    },
    {
      "title": "Palindrome Pairs",
      "source_file": "Leetcode/leetcode336.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "words = [\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]",
          "expected_output": "[[0,1],[1,0],[3,2],[2,4]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0],[3,2],[2,4]]'\nGot (Norm):      '[[3,2]]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0],[3,2],[2,4]]'\nRaw Got:      '[[3,2]]'"
        },
        {
          "example_index": 1,
          "input": "words = [\"bat\",\"tab\",\"cat\"]",
          "expected_output": "[[0,1],[1,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0]]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0]]'\nRaw Got:      '[]'"
        },
        {
          "example_index": 2,
          "input": "words = [\"a\",\"\"]",
          "expected_output": "[[0,1],[1,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0]]'\nGot (Norm):      '[[1,0],[1,0],[0,1]]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0]]'\nRaw Got:      '[[1,0],[1,0],[0,1]]'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\nimport json\n\nclass Solution:\n    def palindromePairs(self, words):\n        # 建立字典: 逆序字串 -> 原索引\n        rev_map = {word[::-1]: i for i, word in enumerate(words)}\n        res = []\n\n        for i, word in enumerate(words):\n            n = len(word)\n            # 空字串特例：任何回文字串都能與空字串配對\n            if word == \"\":\n                for j, w in enumerate(words):\n                    if j != i and w == w[::-1]:\n                        res.append([i, j])\n                        res.append([j, i])\n                continue\n\n            for k in range(n + 1):\n                prefix, suffix = word[:k], word[k:]\n\n                # 前半部分是回文，後半部分逆序在字典中\n                if prefix == prefix[::-1]:\n                    rev_suffix = suffix[::-1]\n                    if rev_suffix in rev_map and rev_map[rev_suffix] != i:\n                        res.append([rev_map[rev_suffix], i])\n\n                # 後半部分是回文（k 不能為 0，避免重複）\n                if k != 0 and suffix == suffix[::-1]:\n                    rev_prefix = prefix[::-1]\n                    if rev_prefix in rev_map and rev_map[rev_prefix] != i:\n                        res.append([i, rev_map[rev_prefix]])\n        return res\n\n\nif __name__ == \"__main__\":\n    # 讀取整行輸入，例如：words = [\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n\n    # 提取括號內的列表字串\n    start = raw_input.find('[')\n    end = raw_input.rfind(']') + 1\n    list_str = raw_input[start:end]\n    words = ast.literal_eval(list_str)\n\n    sol = Solution()\n    pairs = sol.palindromePairs(words)\n\n    # 輸出不帶空格的 JSON 格式，符合範例要求\n    print(json.dumps(pairs, separators=(',', ':')))",
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm: given array of unique strings, find palindrome pairs (i, j) such that concatenation forms palindrome. Complexity O(sum of lengths). Classic solution: For each word, iterate all splits, check prefix/suffix palindrome, use hashmap of reversed words. Steps: Build dictionary mapping word to index. For each word with index i, for each split position k from 0 to len(word), prefix=word[:k], suffix=word[k:]; if prefix is palindrome, find reversed suffix in dict as j; if j!=i then add (j,i). Similarly if suffix palindrome, find reversed prefix. Also handle empty string. Complexity linear.\n\nWe need to output virtual code line by line with explanations. Let's produce steps:\n\nStart\n→ Step 1: 建立字典 map: word -> index // O(total length)\n→ Step 2: 建立結果 list // empty\n\n→ For each word index i, word\n\n→ Decision: if word == \"\" // handle empty\n    Yes → For each key, if key != \"\" and key is palindrome -> add pair (i, index_of_key)\n    No → Continue\n\n→ Decision: for split position k from 0 to len(word) inclusive\n\nWithin loop:\n\n    prefix = word[:k]\n    suffix = word[k:]\n\n    Decision: if prefix is palindrome\n        Yes → rev_suffix = reverse(suffix)\n        Yes if rev_suffix in map and map[rev_suffix] != i -> add (map[rev_suffix], i)\n    Decision: if k < len(word) and suffix is palindrome\n        Yes → rev_prefix = reverse(prefix)\n        Yes if rev_prefix in map and map[rev_prefix] != i -> add (i, map[rev_prefix])\n\nAfter loops end.\n\nEnd\n\nNeed to express virtual code in given format: \"Step X: ... // explanation\" etc. Use arrows. Use Decision: for conditions.\n\nWe need to reflect iteration loops etc. Provide pseudocode lines with \"→ Step\" etc. Use \"Decision:\".\n\nLet's craft step numbers.\n\nUse variable names: words, index, word, k, prefix, suffix, rev, map, result.\n\nWe'll produce lines accordingly.\n\nLet's ensure each line has explanation after //.\n\nMake sure to use virtual arrows. Use \"→\" to indicate flow, and \"Decision:\" for if conditions.\n\nWe'll produce:\n\nStart // 程式開始\n→ Step 1: 建立字典 word_to_index = {} // map each word to its index\n→ Step 2: 建立結果列表 result = [] // 存放所有 (i,j) 對\n\n→ Step 3: 對每個索引 i 及其對應字串 word 進行迴圈\n    → Decision: 若 word 為空字串 \"\"?\n        Yes → Step 4a: 對字典中每個鍵 key, 若 key 非空且 key 為回文, 則將對 (i, word_to_index[key]) 加入 result\n        No  → No → // 直接進行後續分割檢查\n\n→ Step 5: 對每個分割位置 k 從 0 到 len(word) 進行迴圈\n    → Step 5a: 計算 prefix = word[:k], suffix = word[k:]\n    → Decision: prefix 是否為回文?\n        Yes → Step 5b: 計算 rev_suffix = reverse(suffix)\n        Yes → Decision: rev_suffix 是否存在於 word_to_index 且 index ≠ i?\n            Yes → Step 5c: result.append((word_to_index[rev_suffix], i)) // (j,i)\n    → Decision: k < len(word) 且 suffix 是否為回文?\n        Yes → Step 5d: 計算 rev_prefix = reverse(prefix)\n        Yes → Decision: rev_prefix 是否存在於 word_to_index 且 index ≠ i?\n            Yes → Step 5e: result.append((i, word_to_index[rev_prefix])) // (i,j)\n\nEnd // 程式結束\n\nBut need to follow the format: \"虛擬碼步驟 [space] // 解釋\". Also need to include arrows \"→\" before each step.\n\nAlso ensure to indicate decision branches with indentation. Provide \"Yes →\" and \"No →\". For loops, use \"→\" lines with step.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始  \n→ Step 1: 建立字典 word_to_index = {} // 將每個字串對應到其索引  \n→ Step 2: 建立結果列表 result = [] // 用來存放所有 (i, j) 的對  \n\n→ Step 3: 對於每個索引 i 與對應字串 word 進行迴圈  \n    → Decision: word 是否為空字串 \"\"?  \n        Yes → Step 3a: 對字典中每個 key, 若 key 非空且 key 為回文, 則將對 (i, word_to_index[key]) 加入 result  \n        No  → // 直接進入後續分割檢查  \n\n→ Step 4: 對於每個分割位置 k 從 0 到 len(word) 進行迴圈  \n    → Step 4a: 計算 prefix = word[:k], suffix = word[k:]  \n    → Decision: prefix 是否為回文?  \n        Yes → Step 4b: 計算 rev_suffix = reverse(suffix)  \n        Yes → Decision: rev_suffix 是否存在於 word_to_index 且 index ≠ i?  \n            Yes → Step 4c: result.append((word_to_index[rev_suffix], i)) // (j, i)  \n    → Decision: k < len(word) 且 suffix 是否為回文?  \n        Yes → Step 4d: 計算 rev_prefix = reverse(prefix)  \n        Yes → Decision: rev_prefix 是否存在於 word_to_index 且 index ≠ i?  \n            Yes → Step 4e: result.append((i, word_to_index[rev_prefix])) // (i, j)  \n\nEnd // 程式結束"
    },
    {
      "title": "Repeated DNA Sequences",
      "source_file": "Leetcode/leetcode187.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = 'AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT'",
          "expected_output": "[\"AAAAACCCCC\",\"CCCCCAAAAA\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"AAAAACCCCC\",\"CCCCCAAAAA\"]'\nGot (Norm):      '[\"CCCCCAAAAA\",\"AAAAACCCCC\"]'\n--- (Raw) ---\nRaw Expected: '[\"AAAAACCCCC\",\"CCCCCAAAAA\"]'\nRaw Got:      '[\"CCCCCAAAAA\", \"AAAAACCCCC\"]'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport json\n\nclass Solution:\n    def findRepeatedDnaSequences(self, s):\n        seen = set()\n        repeated = set()\n        for i in range(len(s) - 9):\n            seq = s[i:i+10]\n            if seq in seen:\n                repeated.add(seq)\n            else:\n                seen.add(seq)\n        return list(repeated)\n\ndef main():\n    data = sys.stdin.read().strip()\n    # Extract DNA string from input like \"s = '...'\" or just \"'...'\"\n    match = re.search(r\"['\\\"]([^'\\\"]*)['\\\"]\", data)\n    if match:\n        dna = match.group(1)\n    else:\n        dna = data  # fallback if no quotes\n    sol = Solution()\n    res = sol.findRepeatedDnaSequences(dna)\n    # Output as JSON array\n    print(json.dumps(res))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code steps line by line, with explanation after each line. It's a classic problem: find all 10-letter-long substrings that occur more than once. So algorithm: sliding window of length 10, store counts in hash map; after scanning all substrings, collect keys with count >1. Return them. Steps: start, input string s, length check, if length <10 then return empty list. Initialize dictionary counts. For i from 0 to len(s)-10, substring = s[i:i+10]; increment count. After loop, result list = [sub for sub,count in counts.items() if count>1]; output result. End.\n\nAlso we can include decision: length <10? Yes → return empty. No → proceed.\n\nWe'll produce virtual code lines with arrow →. Each line ends with comment after //.\n\nLet's craft. Need to adhere to format: `虛擬碼步驟` + space + `// 解釋/說明`.\n\nWe'll include Start, End. Use arrow lines with \"→\". Decision lines.\n\nLet's produce.\n\nUse steps:\n\nStart\n→ Input s\n→ Decision: length(s) < 10?\n    Yes → Return []\n    No  → Init counts dict\n→ For i in 0 to len(s)-10:\n    sub = s[i:i+10]\n    Increment counts[sub]\n→ Collect result = [sub for sub,count in counts if count>1]\n→ Return result\nEnd\n\nNow produce as lines.\n\nMake sure each line is separate. Use arrow and indentation.\n\nLet's write.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input s // 從使用者或呼叫處取得 DNA 字串  \n→ Decision: 如果 len(s) < 10? // 判斷字串長度是否足夠為 10 個核苷酸  \n Yes → Return [] // 若不足 10，直接回傳空清單  \n No  → Init counts dict // 建立雜湊表記錄 10 字串出現次數  \n→ For i in 0 to len(s)-10: // 循環所有可能的 10 字母滑動窗口  \n sub = s[i:i+10] // 取出當前 10 個字符的子字串  \n Increment counts[sub] // 在雜湊表中增加此子字串的計數  \n→ Collect result = [sub for sub,count in counts if count > 1] // 篩選出現次數大於 1 的子字串  \n→ Return result // 將符合條件的 10 字母序列輸出  \nEnd // 程式執行結束"
    },
    {
      "title": "Permutations",
      "source_file": "Leetcode/leetcode46.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nGot (Norm):      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nRaw Got:      '[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 2, 1], [3, 1, 2]]'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def permute(self, nums):\n        \"\"\"\n        Generate all permutations of a list of distinct integers.\n        \"\"\"\n        res = []\n\n        def backtrack(start):\n            # 如果已經將所有位置填滿，則將目前的排列加入結果\n            if start == len(nums):\n                res.append(nums[:])  # 取副本避免後續修改影響結果\n                return\n            # 逐一嘗試將每個未固定的位置與起始位置交換\n            for i in range(start, len(nums)):\n                nums[start], nums[i] = nums[i], nums[start]\n                backtrack(start + 1)\n                nums[start], nums[i] = nums[i], nums[start]  # 回溯，恢復原狀\n\n        backtrack(0)\n        return res\n\n\ndef main():\n    # 讀取整個輸入\n    data = sys.stdin.read()\n    # 從輸入中提取方括號內的列表字串\n    match = re.search(r'\\[.*\\]', data, re.S)\n    if not match:\n        print(\"[]\")\n        return\n    nums_str = match.group()\n    # 將字串轉成實際的列表物件\n    nums = eval(nums_str)\n\n    sol = Solution()\n    result = sol.permute(nums)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. It's algorithm to generate permutations of distinct integers. Use backtracking. Provide steps with arrow and decision. Use \"Start\", \"End\". Provide explanation after each line. Should be line by line. Let's craft.\n\nWe'll do:\nStart\n→ Step 1: Define result list\n→ Step 2: Define visited array or use list of remaining\n→ Step 3: Define recursive function backtrack(path)\n→ Step 4: Decision: 是否已經完成一個排列? Yes → add path copy to result\nNo → Decision: 遍歷 nums for each number not visited\n→ Step 5: 取 num\n→ Step 6: Mark visited\n→ Step 7: Append to path\n→ Step 8: backtrack(path)\n→ Step 9: 回溯：移除最後一個\n→ Step 10: Unmark visited\n→ Decision: loop continues\n→ End\n\nAdd explanations. Ensure each line has \"虛擬碼步驟 // 解釋\".\n\nAlso ensure no actual code. Use pseudo style like \"→ Step 1: 初始化結果列表\" etc. Use \"Decision:\" lines with Yes → / No →.\n\nLet's craft lines.\n\nBe careful: each line must end with // 解釋/說明.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義空列表 result 用來存儲所有排列 // 建立結果容器  \n→ Step 2: 定義布林列表 visited，長度等於 nums 長度，全部 False // 標記哪些數已被選用  \n→ Step 3: 定義遞迴函式 backtrack(currentPath) // 將會產生排列的核心邏輯  \n→ Step 4: Decision: currentPath 長度是否等於 nums 長度? // 檢查是否已組成完整排列  \n  Yes → Step 5: 把 currentPath 的副本加入 result // 完整排列加入結果  \n  No  → Decision: 遍歷 nums 的每個索引 i? // 將未使用的數字逐一嘗試  \n    Yes → Step 6: Decision: visited[i] 為 False? // 確定該數字尚未被選用  \n     Yes → Step 7: 設置 visited[i] = True // 標記為已使用  \n      → Step 8: 將 nums[i] 加入 currentPath // 擴充目前排列  \n       → Step 9: backtrack(currentPath) // 進一步遞迴生成後續排列  \n       → Step 10: 從 currentPath 刪除最後一個元素 // 回溯，移除該數字  \n       → Step 11: 設置 visited[i] = False // 取消標記，為下一個候選做準備  \n       → Decision: 結束此索引 i 的遞迴分支？ // 只需返回至上一層  \n          No → Step 12: 繼續下一個索引 i 的遍歷  \n→ End // 程式執行結束，result 中已包含所有可能排列"
    },
    {
      "title": "Find the Duplicate Number",
      "source_file": "Leetcode/leetcode287.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "nums = [3,1,3,4,2]",
          "expected_output": "O3",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'O3'\nGot (Norm):      '3'\n--- (Raw) ---\nRaw Expected: 'O3'\nRaw Got:      '3'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findDuplicate(self, nums):\n        # Floyd's Tortoise and Hare (Cycle Detection) 演算法\n        slow = fast = nums[0]\n        # 第一階段：尋找相遇點\n        while True:\n            slow = nums[slow]\n            fast = nums[nums[fast]]\n            if slow == fast:\n                break\n        # 第二階段：尋找入圈點（即重複數字）\n        slow = nums[0]\n        while slow != fast:\n            slow = nums[slow]\n            fast = nums[fast]\n        return slow\n\ndef parse_input(raw):\n    \"\"\"\n    從輸入字串中擷取數列。\n    支援格式：nums = [1,2,3,2] 或僅 [1,2,3,2]。\n    \"\"\"\n    raw = raw.strip()\n    # 找到第一個 '[' 和最後一個 ']'\n    left = raw.find('[')\n    right = raw.rfind(']')\n    if left == -1 or right == -1:\n        return []\n    try:\n        # 使用 ast.literal_eval 安全地解析列表\n        return ast.literal_eval(raw[left:right+1])\n    except Exception:\n        return []\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    nums = parse_input(data)\n    if not nums:\n        print()\n    else:\n        sol = Solution()\n        print(sol.findDuplicate(nums))",
      "virtual_code": "Thinking...\nWe need to generate virtual code for Floyd's cycle detection algorithm (tortoise and hare). Must be constant space, no modification. Provide steps line by line with explanation. Use Start, End, Decision, arrows. We'll produce steps:\n\nStart\n→ Step 1: 初始化 tortoise = nums[0], hare = nums[0] // 兩個指針指向起始\n→ Step 2: 移動 tortoise = nums[tortoise], hare = nums[nums[hare]] until they meet // 找到交點\n→ Decision: tortoise == hare? // 判斷是否相遇\n    Yes → Step 3: 重新設定 tortoise = nums[0] // 設置一個指針回到起始\n    No → → Step 2 循環 // 若未相遇，繼續前進\n→ Step 4: 移動 tortoise = nums[tortoise], hare = nums[hare] // 同時移動一步\n→ Decision: tortoise == hare? // 判斷是否相遇\n    Yes → Step 5: 重複數為 tortoise // 相遇位置即為重複數\n    No  → → Step 4 循環 // 但在 Floyd 中不會再次不相遇\nEnd\n\nBut we need to ensure correct formatting with arrows and indentations. Use 'Decision:' then Yes/No branches. Use consistent indent. Use '→' arrow before each step. Use 'Start' and 'End'.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: tortoise ← nums[0]  // 初始化緩慢指針指向陣列第一個位置  \n→ Step 2: hare ← nums[0]  // 初始化快慢指針指向相同位置  \n\n→ Step 3: tortoise ← nums[tortoise]  // 緩慢指針走一步  \n→ Step 4: hare ← nums[nums[hare]]  // 快速指針走兩步  \n\n→ Decision: tortoise == hare?  // 判斷是否相遇  \n    Yes → Step 5: tortoise ← nums[0]  // 相遇，將慢指針移回陣列起點  \n    No  → → Step 3  // 未相遇，繼續第一階段尋找交點  \n\n→ Step 6: tortoise ← nums[tortoise]  // 同時將慢指針與快指針各移一步  \n→ Step 7: hare ← nums[hare]  \n\n→ Decision: tortoise == hare?  // 第二階段尋找入圈點  \n    Yes → Step 8: result ← tortoise  // 相遇點即為重複數  \n    No  → → Step 6  // 理論上不會發生，為安全循環  \n\nEnd // 程式執行結束，返回重複數結果"
    },
    {
      "title": "Insert Delete GetRandom O(1) - Duplicates allowed",
      "source_file": "Leetcode/leetcode381.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedCollection\", \"insert\", \"insert\", \"insert\", \"getRandom\", \"remove\", \"getRandom\"], [[], [1], [1], [2], [], [1], []]",
          "expected_output": "[null, true, false, true, 2, true, 1]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,false,true,2,true,1]'\nGot (Norm):      '[null,true,false,true,1,true,2]'\n--- (Raw) ---\nRaw Expected: '[null, true, false, true, 2, true, 1]'\nRaw Got:      '[null, true, false, true, 1, true, 2]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport collections\n\nclass RandomizedCollection:\n    \"\"\"\n    多重集合資料結構，支援重複元素。\n    - insert：平均 O(1)\n    - remove：平均 O(1)\n    - getRandom：平均 O(1)\n    \"\"\"\n\n    def __init__(self):\n        # 用 list 存放所有元素，方便索引存取\n        self.data = []\n        # 對每個值，維持一組它在 data 中所有索引的集合\n        self.idx_map = collections.defaultdict(set)\n\n    def insert(self, val: int) -> bool:\n        \"\"\"\n        把 val 插入集合。\n        若 val 原本不存在，回傳 True，否則回傳 False。\n        \"\"\"\n        # 把 val 放到 data 的尾端\n        self.data.append(val)\n        # 把新索引加入映射\n        self.idx_map[val].add(len(self.data) - 1)\n        # 若映射集合只有一個索引，表示這是第一次出現\n        return len(self.idx_map[val]) == 1\n\n    def remove(self, val: int) -> bool:\n        \"\"\"\n        把 val 從集合中移除一個。\n        若 val 存在，移除並回傳 True；否則回傳 False。\n        \"\"\"\n        # 如果對應集合為空，表示不存在此值\n        if not self.idx_map[val]:\n            return False\n\n        # 取出任一索引（任意一個出現位置）\n        remove_idx = self.idx_map[val].pop()\n        # 取得最後一個元素的索引和值\n        last_idx = len(self.data) - 1\n        last_val = self.data[last_idx]\n\n        # 把最後一個元素搬到 remove_idx 的位置\n        self.data[remove_idx] = last_val\n        # 更新 last_val 的索引集合：加入新位置 remove_idx\n        self.idx_map[last_val].add(remove_idx)\n        # 移除舊的最後位置索引 last_idx\n        self.idx_map[last_val].discard(last_idx)\n\n        # 移除 data 的最後一個位置\n        self.data.pop()\n\n        return True\n\n    def getRandom(self) -> int:\n        \"\"\"\n        隨機回傳集合中的一個元素。\n        \"\"\"\n        return random.choice(self.data)\n\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入，輸入格式類似：\n    # [\"RandomizedCollection\", \"insert\", \"insert\", ...], [[], [1], [1], ...]\n    raw_input = sys.stdin.read().strip()\n    # 把輸入包成一個 JSON 陣列，方便解析為兩個子陣列\n    try:\n        ops, args = json.loads(f'[{raw_input}]')\n    except json.JSONDecodeError as e:\n        # 若解析失敗，直接終止程式\n        sys.exit(0)\n\n    # 建立 RandomizedCollection 物件\n    rc = RandomizedCollection()\n    results = []\n\n    for op, arg in zip(ops, args):\n        if op == \"RandomizedCollection\":\n            # 建構子呼叫，結果為 None\n            results.append(None)\n        else:\n            method = getattr(rc, op)\n            res = method(*arg)\n            results.append(res)\n\n    # 將結果轉成符合題目輸出的格式\n    out_list = []\n    for r in results:\n        if r is None:\n            out_list.append(\"null\")\n        elif isinstance(r, bool):\n            out_list.append(\"true\" if r else \"false\")\n        else:\n            out_list.append(str(r))\n    print(\"[\" + \", \".join(out_list) + \"]\")",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for implementing RandomizedCollection class with operations insert, remove, getRandom. Must be average O(1). Use data structures: vector for values, unordered_map<int, unordered_set<int>> val to indices. We'll produce steps.\n\nNeed to output lines like \"Start // 程式開始執行\", etc. Provide virtual steps in order: initialization, insert, remove, getRandom.\n\nAlso we need to explain each line. Use arrow for steps, decisions.\n\nLet's draft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 宣告 Vector<int> values // 儲存所有元素，允許重複  \n→ Step 2: 宣告 Map<int, Set<int>> idxMap // 對每個值維持其在 values 的索引集合  \n→ Step 3: 宣告 RandomEngine rand // 隨機數產生器  \n\n// ---------- 插入 ----------\n→ Step 4: Function insert(val)  \n    → Step 5: Append val 到 values 的尾端 // O(1)  \n    → Step 6: idx ← values.size() - 1 // 新元素的索引  \n    → Step 7: idxMap[val].insert(idx) // 在對應集合加入索引  \n    → Step 8: Return (idxMap[val].size() == 1) // 若之前不存在則回傳 true  \n\n// ---------- 刪除 ----------\n→ Step 9: Function remove(val)  \n    → Decision: 若 idxMap[val] 為空? // 目標值不存在  \n        No  → Step 10: Return false // 無法刪除  \n        Yes → Step 11: idxToRemove ← 任一元素從 idxMap[val] 取出 // O(1)  \n            → Step 12: lastIdx ← values.size() - 1  \n            → Step 13: lastVal ← values[lastIdx]  \n            → Step 14: Swap values[idxToRemove] 與 values[lastIdx] // O(1)  \n            → Step 15: values.pop_back() // 刪除最後元素  \n            → Step 16: idxMap[val].erase(idxToRemove) // 移除被刪除元素的索引  \n            → Decision: 若 idxToRemove ≠ lastIdx? // 只有在交換時需要更新另一個索引  \n                Yes → Step 17: idxMap[lastVal].erase(lastIdx) // 移除舊的最後索引  \n                Yes → Step 18: idxMap[lastVal].insert(idxToRemove) // 插入新的索引位置  \n            → Decision: 若 idxMap[val] 變空? // 清除空集合以節省空間  \n                Yes → Step 19: idxMap.erase(val)  \n            → Step 20: Return true  \n\n// ---------- 取得隨機 ----------\n→ Step 21: Function getRandom()  \n    → Step 22: idx ← rand() mod values.size() // 隨機選取索引  \n    → Step 23: Return values[idx] // 返回對應的值  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Longest Uncommon Subsequence I",
      "source_file": "Leetcode/leetcode521.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "\"aba\", \"cdc\"",
          "expected_output": "3",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '3'\nGot (Norm):      '5'\n--- (Raw) ---\nRaw Expected: '3'\nRaw Got:      '5'"
        },
        {
          "example_index": 1,
          "input": "\"aaa\", \"bbb\"",
          "expected_output": "3",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '3'\nGot (Norm):      '5'\n--- (Raw) ---\nRaw Expected: '3'\nRaw Got:      '5'"
        }
      ],
      "generated_code": "import sys\n\ndef find_lus(a: str, b: str) -> int:\n    \"\"\"\n    Return the length of the longest uncommon subsequence between a and b.\n    If a and b are identical, there is no uncommon subsequence, return -1.\n    \"\"\"\n    return -1 if a == b else max(len(a), len(b))\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 嘗試先按逗號分割（例如: \"aba\", \"cdc\"）\n    parts = [p.strip() for p in data.split(',') if p.strip() != '']\n    if len(parts) >= 2:\n        a, b = parts[0], parts[1]\n    else:\n        # 若沒有逗號，則以空白分割\n        tokens = data.split()\n        if len(tokens) >= 2:\n            a, b = tokens[0], tokens[1]\n        else:\n            # 只能讀到一個字串時，視為空字串\n            a = tokens[0]\n            b = ''\n\n    # 計算結果並輸出\n    print(find_lus(a, b))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line with explanation. The task: Given two strings a and b, return the length of longest uncommon subsequence between a and b. If none, return -1. So typical known Leetcode problem: Longest Uncommon Subsequence I. Answer: If a == b: return -1 else return max(len(a), len(b)). So algorithm: if a == b return -1 else return max(len(a), len(b)). We'll produce steps.\n\nWe should include Start, End, Decision etc. Each line: \"虛擬碼步驟 // 解釋\".\n\nWe need to include arrow arrow? The sample uses \"→ Step 1: ...\". So each step should start with \"→\". For decisions, \"Decision:\" with arrows Yes → No →.\n\nLet's craft steps:\n\nStart // 開始\n→ Step 1: 讀取字串 a 和 b // 從輸入取得兩個字串\n→ Decision: a 等於 b? // 檢查兩個字串是否相同\n    Yes → Step 2: 回傳 -1 // 若相同，無不相同子序列，回傳 -1\n    No  → Step 3: 計算長度_a = 長度(a) // 取得字串 a 的長度\n    No  → Step 4: 計算長度_b = 長度(b) // 取得字串 b 的長度\n    No  → Step 5: 回傳 max(長度_a, 長度_b) // 回傳兩者中較長的長度\nEnd // 結束\n\nBut to keep linear structure, we might combine steps after No branch. Might need to indent. Use the same indentation. Provide explanation. Should we use \"→ Step 3: 取得長度 a\" etc. Provide concise explanation.\n\nLet's produce. Ensure each line ends with comment. Provide step names. Let's deliver.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 讀取字串 a 與 b // 從輸入取得兩個字串\n→ Decision: a 等於 b? // 檢查兩個字串是否相同\n    Yes → Step 2: 回傳 -1 // 若兩字串相同，無不相同子序列，直接回傳 -1\n    No  → Step 3: 計算長度_a = 長度(a) // 取得字串 a 的長度\n    No  → Step 4: 計算長度_b = 長度(b) // 取得字串 b 的長度\n    No  → Step 5: 回傳 max(長度_a, 長度_b) // 回傳兩者中較長的長度，為長度最長的不相同子序列\nEnd // 程式執行結束"
    },
    {
      "title": "Group Anagrams",
      "source_file": "Leetcode/leetcode49.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]",
          "expected_output": "[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]'\nGot (Norm):      '[[\"eat\",\"tea\",\"ate\"],[\"tan\",\"nat\"],[\"bat\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]'\nRaw Got:      '[[\"eat\",\"tea\",\"ate\"],[\"tan\",\"nat\"],[\"bat\"]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nfrom collections import defaultdict\n\ndef parse_input(raw: str):\n    \"\"\"\n    從原始輸入字串中提取字串列表。\n    支援「strs = [ ... ]」以及單純的 [ ... ] 兩種格式。\n    \"\"\"\n    raw = raw.strip()\n    if '=' in raw:\n        # 取等號右側的內容\n        _, rhs = raw.split('=', 1)\n        rhs = rhs.strip()\n    else:\n        rhs = raw\n    # 使用 literal_eval 以避免 eval 的安全風險\n    return ast.literal_eval(rhs)\n\ndef group_anagrams(strs):\n    \"\"\"\n    以排序後的字母組為 key，將同屬一組的字串放在同一 list。\n    \"\"\"\n    anagrams = defaultdict(list)\n    for s in strs:\n        # 將字串排序後轉成 tuple 作為 key\n        key = tuple(sorted(s))\n        anagrams[key].append(s)\n    return list(anagrams.values())\n\ndef main():\n    # 讀取全部輸入\n    raw_input = sys.stdin.read()\n    if not raw_input.strip():\n        # 空輸入時輸出空列表\n        print('[]')\n        return\n\n    strs = parse_input(raw_input)\n    # 確保輸入為 list\n    if not isinstance(strs, list):\n        raise ValueError('輸入必須是字串列表')\n\n    grouped = group_anagrams(strs)\n    # 以 JSON 格式輸出，去除空白以符合範例輸出格式\n    print(json.dumps(grouped, separators=(',', ':')))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to solve grouping anagrams. Use Start, End, Decision, steps. Provide each line with explanation. Avoid actual code. Provide step by step pseudo-code. Must be in Traditional Chinese. Each line: \"虛擬碼步驟 // 解釋\". Use arrow. Should be clear. Let's craft.\n\nPossible algorithm: use hash map where key is sorted string. For each word, sort chars, use sorted string as key, push into list. After loop, output values.\n\nWe need stepwise: Start, Input array, Initialize map, Iterate each string, Sort, Use key, Append, End.\n\nAlso maybe decision: if key exists? then append else create.\n\nLet's produce.\n\nEnsure each line has arrow or indent with decision block.\n\nUse Start, End.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 接收輸入陣列 strs // 取得所有待分組的字串  \n→ Step 2: 建立空 HashMap map<string, list<string>> // 用於存放以排序後字串為鍵的字串群  \n→ Step 3: For each string s in strs // 逐一處理每個字串  \n  → Decision: s 是否為空字串? // 檢查字串是否為空，避免排序失效  \n   Yes → Step 4: 跳過此 s // 空字串不需要處理，直接進下一個  \n   No  → Step 5: 建立字元陣列 arr = s 的所有字元 // 將字串拆分為字元方便排序  \n    → Step 6: 對 arr 進行字母排序 // 使同一字母組合的字串排序後相同  \n    → Step 7: 將 arr 重新拼接成字串 key // 這個 key 作為 HashMap 的鍵  \n    → Decision: map 是否已存在 key? // 判斷是否已有同類型字串群  \n     Yes → Step 8: map[key].append(s) // 若存在，將 s 加入該群  \n     No  → Step 9: map[key] = [s] // 若不存在，建立新群並放入 s  \n→ Step 10: 收集所有 map 的 values 為結果 list // 取得所有已分組的字串群  \nEnd // 程式執行結束，輸出結果 list 其中每個子清單為一組同字母排列的字串"
    },
    {
      "title": "Roman to Integer",
      "source_file": "Leetcode/leetcode13.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 2,
          "input": "Input: s = \"MCMXCIV\"",
          "expected_output": "Output: 1994",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'Output:1994'\nGot (Norm):      '1993'\n--- (Raw) ---\nRaw Expected: 'Output: 1994'\nRaw Got:      '1993'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    \"\"\"將羅馬數字字串轉換為整數。\"\"\"\n    def romanToInt(self, s: str) -> int:\n        roman_map = {\n            'I': 1, 'V': 5, 'X': 10, 'L': 50,\n            'C': 100, 'D': 500, 'M': 1000\n        }\n        total = 0\n        prev_value = 0\n        # 逆序遍歷字串，依照前面小於前一數值時的減法規則\n        for char in reversed(s):\n            value = roman_map[char]\n            if value < prev_value:\n                total -= value\n            else:\n                total += value\n            prev_value = value\n        return total\n\ndef main():\n    # 從標準輸入讀取完整資料\n    data = sys.stdin.read()\n    # 只取出 I, V, X, L, C, D, M 這些羅馬字元，拼成真正的數字字串\n    roman_str = ''.join(re.findall(r'[IVXLCDM]', data))\n    if not roman_str:\n        return  # 若無有效羅馬數字，直接結束\n    sol = Solution()\n    result = sol.romanToInt(roman_str)\n    # 將結果輸出到標準輸出\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode for converting Roman numeral string to integer. Must be line-by-line with comments after a space. Use arrows and Decision structure. Let's craft a clear algorithm.\n\nStandard approach: iterate over string from left to right, add value of each symbol, but if a smaller value precedes a larger, subtract double of smaller? Alternatively process from right to left, adding value, subtract if current < previous. We'll present algorithm maybe scanning string and using a map.\n\nWe'll produce pseudocode:\n\nStart\n→ Step 1: 定義符號對應表 // map roman chars to integer\n→ Step 2: 初始化 total = 0, prev_value = 0 // 用於記錄前一符號的數值\n→ Step 3: 逆序遍歷輸入字串中的每個字符 // 從右到左處理\n    → Decision: 當前符號對應值 > prev_value? // 判斷是否需要加或減\n        Yes → Step 4: total = total + current_value // 加\n        No  → Step 5: total = total - current_value // 減\n    → Step 6: prev_value = current_value // 更新前一值\n→ Step 7: 返回 total // 完成\nEnd\n\nAdd comments each line.\n\nWe need to use \"→\" arrow for steps, \"Decision:\" for decision. For nested decision, indent.\n\nWe also need to include \"Yes →\" and \"No →\" lines.\n\nLet's craft.\n\nUse line numbers? Not necessary. Just each line.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義符號對應表：{'I':1,'V':5,'X':10,'L':50,'C':100,'D':500,'M':1000} // 建立羅馬字元到整數的映射  \n→ Step 2: 初始化 total = 0，prev_value = 0 // 用於累計結果及追蹤前一個符號的數值  \n→ Step 3: 逆序遍歷輸入字串中的每個字符 // 從右至左處理，方便判斷加減法  \n  → Decision: 當前字符對應值 > prev_value? // 判斷是否為加法情形  \n   Yes → Step 4: total = total + current_value // 前一個數值較小，需加  \n   No  → Step 5: total = total - current_value // 前一個數值較大，需減  \n  → Step 6: prev_value = current_value // 更新 prev_value 為本次數值  \n→ Step 7: 返回 total // 回傳最終整數結果  \nEnd // 程式執行結束"
    },
    {
      "title": "K^th Smallest Element in a Sorted Matrix",
      "source_file": "Leetcode/leetcode378.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8",
          "expected_output": "13",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpvlqy2avl.py\", line 52, in <module>\n    main()\n  File \"/tmp/tmpvlqy2avl.py\", line 43, in main\n    exec(data_str, {}, env)\n  File \"<string>\", line 1\n    matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "matrix = [[-5]], k = 1",
          "expected_output": "-5",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpb0vfsi21.py\", line 52, in <module>\n    main()\n  File \"/tmp/tmpb0vfsi21.py\", line 43, in main\n    exec(data_str, {}, env)\n  File \"<string>\", line 1\n    matrix = [[-5]], k = 1\n    ^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "import sys\n\ndef kthSmallest(matrix, k):\n    \"\"\"\n    Find the k-th smallest element in a sorted n x n matrix\n    using binary search on the value range.\n    Time Complexity: O(n * log(max_value - min_value))\n    Space Complexity: O(1) (excluding input matrix)\n    \"\"\"\n    n = len(matrix)\n    low = matrix[0][0]               # minimum possible value\n    high = matrix[n - 1][n - 1]       # maximum possible value\n\n    while low < high:\n        mid = (low + high) // 2\n        count = 0\n        i = n - 1        # start from bottom-left corner\n        j = 0\n\n        # Count how many numbers are <= mid\n        while i >= 0 and j < n:\n            if matrix[i][j] <= mid:\n                count += i + 1   # all elements in column j up to row i are <= mid\n                j += 1           # move right\n            else:\n                i -= 1           # move up\n\n        if count < k:\n            low = mid + 1        # need larger numbers\n        else:\n            high = mid           # mid could be the answer\n\n    return low\n\ndef main():\n    # Read entire input as a string\n    data_str = sys.stdin.read().strip()\n    if not data_str:\n        return\n\n    # Evaluate the input to extract matrix and k\n    env = {}\n    exec(data_str, {}, env)\n    matrix = env['matrix']\n    k = env['k']\n\n    # Compute and print the k-th smallest element\n    result = kthSmallest(matrix, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce a virtual code flow for solving the problem: find k-th smallest element in an n x n sorted matrix. Use binary search on value range and count <= mid.\n\nAlso mention memory complexity O(log(max-min))? Actually algorithm uses O(1) extra memory.\n\nWe need to output line by line with arrow and explanation. Should start with Start, End, etc. Use Decision etc. Provide steps: Input matrix, k, find min, max, binary search while low<high. Count numbers <= mid by row iteration moving from bottom-left.\n\nWe need to produce virtual code, no real code. Let's craft steps:\n\nStart // start\n\n→ Step 1: 取得矩陣行列數 n // read n\n\n→ Step 2: 取得 min = matrix[0][0], max = matrix[n-1][n-1] // initial bounds\n\n→ Decision: min == max? // if all equal\n\n    Yes → Step 3: Return min // done\n\n    No → Step 4: binary search while low < high // start binary search\n\n→ Step 4.1: low = min, high = max // initialize bounds\n\n→ Step 4.2: while low < high // loop\n\n    → Step 4.2.1: mid = (low + high) / 2 // mid value\n\n    → Step 4.2.2: count = 0 // counter\n\n    → Step 4.2.3: i = n-1, j = 0 // start from bottom-left\n\n    → Decision: i >= 0 and j < n? // while loop\n\n        Yes → Step 4.2.3.1: if matrix[i][j] <= mid // check value\n\n            → Decision: matrix[i][j] <= mid?\n\n                Yes → Step 4.2.3.1.1: count += i+1 // all in column <= mid\n\n                No  → Step 4.2.3.1.2: i -= 1 // move up\n\n        No  → Step 4.2.3.2: // exit inner loop\n\n    → Decision: count < k? // adjust bounds\n\n        Yes → Step 4.2.4: low = mid + 1 // need larger values\n\n        No  → Step 4.2.5: high = mid // mid could be answer\n\n→ Step 5: Return low // low is kth smallest\n\nEnd\n\nBut we need to output arrow for each step and explanation. Use \"→\" for step, \"Decision:\" for decision, indent for nested decisions? Use indentation with spaces. The example uses indentation like:\n\nDecision: 如果數字大於 0? \n    Yes → Step 2: 輸出 '正數' \n    No  → Decision: 如果數字等於 0? \n        Yes → Step 3: 輸出 '零' \n\nSo we can mimic that.\n\nWe need to include \"Start\" \"End\".\n\nAlso mention memory complexity: O(1). But not necessary.\n\nLet's craft.\n\nAlso mention that we don't use actual code.\n\nLet's write each line.\n\nRemember: \"虛擬碼步驟\" + \" \" + \"// 解釋/說明\".\n\nThus each line ends with \"// ...\".\n\nLet's create.\n\nWe will use \"Step\" with numbers.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取矩陣大小 n 與 k // 取得矩陣維度與欲搜尋的第 k 個數字  \n→ Step 2: min ← matrix[0][0] // 初始最小值  \n→ Step 3: max ← matrix[n-1][n-1] // 初始最大值  \n→ Decision: min == max? // 若矩陣所有元素相同  \n  Yes → Step 4: 回傳 min // 結束，k^th 最小即為唯一值  \n  No  → Step 5: low ← min, high ← max // 設定二分搜尋的下界與上界  \n→ Step 6: while low < high do // 二分搜尋主迴圈  \n  → Step 6.1: mid ← (low + high) / 2 // 取中間值  \n  → Step 6.2: count ← 0 // 初始化小於等於 mid 的元素個數  \n  → Step 6.3: i ← n-1, j ← 0 // 從左下角開始搜尋  \n  → Decision: i ≥ 0 且 j < n? // 判斷是否還有格子可掃描  \n    Yes → Step 6.3.1: if matrix[i][j] ≤ mid then  \n      → Decision: matrix[i][j] ≤ mid? // 判斷此格子是否小於等於 mid  \n        Yes → Step 6.3.1.1: count ← count + (i + 1) // 這列中前 i+1 個元素皆 ≤ mid  \n        No  → Step 6.3.1.2: i ← i - 1 // 向上移動  \n    No  → Step 6.3.2: // inner loop 結束  \n  → Decision: count < k? // 根據 count 調整搜尋範圍  \n    Yes → Step 6.4: low ← mid + 1 // 需要更大的數值  \n    No  → Step 6.5: high ← mid // mid 可能是答案  \n→ Step 7: 回傳 low // low 即為第 k 個最小的元素  \nEnd // 程式執行結束"
    },
    {
      "title": "Implement Rand10() Using Rand7()",
      "source_file": "Leetcode/leetcode470.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 1",
          "expected_output": "[2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2]'\nGot (Norm):      '[4]'\n--- (Raw) ---\nRaw Expected: '[2]'\nRaw Got:      '[4]'"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[2,8]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,8]'\nGot (Norm):      '[5,1]'\n--- (Raw) ---\nRaw Expected: '[2,8]'\nRaw Got:      '[5, 1]'"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "[3,8,10]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,8,10]'\nGot (Norm):      '[6,10,9]'\n--- (Raw) ---\nRaw Expected: '[3,8,10]'\nRaw Got:      '[6, 10, 9]'"
        }
      ],
      "generated_code": "import sys\nimport random\n\n# 生成 [1, 7] 的隨機整數 API\ndef rand7() -> int:\n    return random.randint(1, 7)\n\nclass Solution:\n    def rand10(self) -> int:\n        \"\"\"產生 [1, 10] 的均勻隨機整數，使用 rand7() 作為基礎\"\"\"\n        while True:\n            # 兩次 rand7() 產生 1~49 的均勻分布\n            num = (rand7() - 1) * 7 + rand7()  # 1~49\n            if num <= 40:                     # 只接受 1~40\n                return 1 + (num - 1) % 10     # 對 1~10 做映射\n\ndef main() -> None:\n    # 從 stdin 讀取輸入，預期形如 \"n = 1\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 取得等號右側的整數\n    try:\n        n = int(data.split('=')[-1].strip())\n    except ValueError:\n        # 若輸入格式不符，直接退出\n        return\n\n    sol = Solution()\n    results = [sol.rand10() for _ in range(n)]\n    print(results)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps with explanation. Approach: use rejection sampling: generate 2 rand7() to produce 1-49 (like 7* (a-1)+b). Accept 1-40, map to 1-10 via modulo 10. Rejection loop. Or could use more efficient algorithm generating 1-21 from two rand7() (3* (a-1)+b) and accept 1-20. But simplest is 1-49. Use loop. Provide virtual code steps. Ensure each line has arrow and comment. Start, End, Decision, Yes, No.\n\nLet's produce:\n\nStart\n→ Step 1: 重複執行直到得到有效數值 // 準備產生隨機數\n    → Decision: 產生兩個 rand7() 的組合? // 先產生 1-49\n        Yes → Step 2: rand7() 呼叫 1 // 取得第一個隨機數\n        → Step 3: rand7() 呼叫 2 // 取得第二個隨機數\n        → Step 4: 計算 randVal = (a - 1) * 7 + b // 產生 1-49\n        → Decision: randVal <= 40? // 檢查是否在可接受範圍\n            Yes → Step 5: 產生 rand10() = ((randVal - 1) mod 10) + 1 // 對 1-10 做映射\n            No  → Step 6: 回到 Step 1 重新嘗試 // 拒絕 41-49\n→ End // 完成\n\nNeed to follow format. Use \"→\" before each step. For decisions, use \"Decision:\" then indent Yes → etc.\n\nMake sure each line ends with // explanation.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 重複執行直到得到有效數值 // 準備產生隨機數  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: 產生兩個 rand7() 的組合? // 先產生 1-49  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 2: rand7() 呼叫 1 // 取得第一個隨機數  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 3: rand7() 呼叫 2 // 取得第二個隨機數  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 4: 計算 randVal = (a - 1) * 7 + b // 產生 1-49  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: randVal <= 40? // 檢查是否在可接受範圍  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 5: 產生 rand10() = ((randVal - 1) mod 10) + 1 // 對 1-10 做映射  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 6: 回到 Step 1 重新嘗試 // 拒絕 41-49  \n→ End // 程式執行結束"
    },
    {
      "title": "Reverse Integer",
      "source_file": "Leetcode/leetcode7.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "x = -123",
          "expected_output": "-321",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '-321'\nGot (Norm):      '0'\n--- (Raw) ---\nRaw Expected: '-321'\nRaw Got:      '0'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nINT_MAX = 2**31 - 1\nINT_MIN = -2**31\n\ndef reverse_int(x: int) -> int:\n    rev = 0\n    while x != 0:\n        pop = x % 10          # 取得最右邊的位數（可能為負）\n        x //= 10              # 去除已處理的位數\n\n        # 檢查正向溢出\n        if rev > INT_MAX // 10 or (rev == INT_MAX // 10 and pop > 7):\n            return 0\n        # 檢查負向溢出\n        if rev < INT_MIN // 10 or (rev == INT_MIN // 10 and pop < -8):\n            return 0\n\n        rev = rev * 10 + pop  # 把 pop 加入 rev\n\n    return rev\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 取第一個整數（可從 \"x = 123\" 等格式提取）\n    nums = re.findall(r'-?\\d+', data)\n    if not nums:\n        return\n    x = int(nums[0])\n    result = reverse_int(x)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce a pseudo-code step by step, with explanations, for reversing digits of a 32-bit signed integer without using 64-bit ints. Must handle overflow by returning 0. We need to produce step-by-step with arrows and decisions. We should use pseudo-code constructs: Start, Decision:, Yes →, No →, Step. We need to ensure each line has virtual code step + space + // explanation.\n\nWe cannot use 64-bit ints; we can use 32-bit operations. For overflow detection we can compare to threshold. Standard solution: store rev as int, loop while x != 0: pop digit: pop = x % 10; x /= 10; before pushing: if rev > INT_MAX/10 or (rev == INT_MAX/10 and pop > 7) return 0; similar for negative.\n\nBut we cannot use 64-bit; we use 32-bit ints. For checking overflow, we need to avoid overflow when multiplying rev by 10. So we check before multiply.\n\nWe'll produce pseudo-code accordingly.\n\nNeed to use \"Decision: ... ?\" lines.\n\nWe must not output real code; only pseudo-code.\n\nOk produce lines:\n\nStart\n→ Step 1: Initialize rev = 0 and sign = 1 // store reversed number and sign\n→ Step 2: If x < 0: sign = -1; x = -x // make x positive for processing\n→ Decision: While x != 0? // process each digit\n    Yes → Step 3: pop = x % 10 // get last digit\n    → Step 4: x = x / 10 // remove last digit\n    → Decision: rev > INT_MAX/10 or (rev == INT_MAX/10 and pop > 7)? // check overflow for positive\n        Yes → Step 5: Return 0 // overflow, exit\n        No → Decision: rev < INT_MIN/10 or (rev == INT_MIN/10 and pop < -8)? // check overflow for negative\n            Yes → Step 6: Return 0\n            No → Step 7: rev = rev * 10 + pop // append digit\n→ Step 8: rev = rev * sign // apply original sign\n→ Decision: rev > INT_MAX or rev < INT_MIN? // final overflow check\n    Yes → Step 9: Return 0\n    No  → Step 10: Return rev // valid result\nEnd\n\nBut we need to include comments after each line. Use // explanation.\n\nAlso include arrow after Start? In example they wrote: Start // 程式開始執行. So we need \"Start //\". Then \"→ Step 1: ...\" etc. For Decision lines we need \"Decision: ... ?\" and then indent Yes →, No → lines.\n\nMake sure each line ends with // explanation.\n\nWe need to incorporate INT_MAX = 2147483647, INT_MIN = -2147483648.\n\nWe must also mention that rev is int.\n\nBe careful: when we do rev = rev * 10 + pop, rev remains int, but rev * 10 may overflow before assignment if rev > INT_MAX/10. That's why we checked.\n\nBut we used pop positive only since x positive. For negative, we apply sign later, so no need to check negative pop.\n\nBut in the overflow condition for negative we used rev < INT_MIN/10 etc, but rev is non-negative during loop. Actually rev is always non-negative. For negative input, we will multiply by -1 at the end, but rev is non-negative. But we can check overflow at the end.\n\nSimpler: we can handle overflow only for positive rev, but after we apply sign, we can check final value.\n\nBut typical algorithm uses overflow check with rev > INT_MAX/10 or rev == INT_MAX/10 && pop > 7 for positive. Since rev is always non-negative, that covers all. For negative input, we just multiply by sign at the end; but we need to check if rev * sign < INT_MIN. But that only occurs if rev > 2147483648? Actually negative INT_MIN is -2147483648, which magnitude is 1 more than INT_MAX. The rev can be up to 2147483648? But rev is positive. So when rev > 2147483648, we would overflow. But we can't hold 2147483648 in int? It fits within 32-bit signed? 2147483648 is 0x80000000, which overflows signed int (max 2147483647). So rev can never be > 2147483647. So if we restrict rev <= INT_MAX, rev * -1 will be >= -INT_MAX. So it cannot reach INT_MIN. But the reversed number of -2147483648 is -8463847412? Actually reversed digits of -2147483648 is -8463847412 which is out of range. That rev would be 8463847412 > INT_MAX. So during building rev we would overflow at some point. Actually rev will reach 8463847412 > INT_MAX during process; but we will detect overflow earlier? Let's think: For -2147483648, digits: 8 4 6 3 8 4 7 4 1 2? Wait reverse of -2147483648 is -8463847412, which has 10 digits. Our algorithm: start x=2147483648 (positive after sign extraction). But x is too big for 32-bit signed int: 2147483648 > INT_MAX. But the input is signed 32-bit; x can't be 2147483648. Actually the input is -2147483648, which in 32-bit signed is representable. When we negate it, we cannot store 2147483648 in signed 32-bit int (since overflow). So we can't do x = -x. So we must avoid negating INT_MIN. The standard algorithm avoids that by using sign variable but not negating x; instead use abs? Actually typical solution uses negative handling differently: Use long for intermediate? But we can't use 64-bit. Alternative: Use unsigned int for x? But environment forbids 64-bit. We can use negative loop: while x != 0: pop = x % 10; x = x / 10; rev = rev*10 + pop. But if x negative, pop will be negative too? In C, -1 % 10 = -1? So pop negative. But rev will accumulate negative. But we still check overflow with rev? It's tricky. Simpler: Use sign variable but not negate x. Instead, we can treat x as int and use pop = x % 10; rev = rev * 10 - pop; x = x / 10. This handles negative numbers properly. Let's design algorithm: Set rev=0. While x != 0: pop = x % 10; x = x / 10; // pop could be negative if x negative. Then before rev = rev * 10 + pop, we check overflow. For negative rev, rev may be negative or positive? If x negative, pop negative, rev will become negative eventually. For positive x, rev stays positive. For negative x, rev becomes negative. For overflow detection, we can use condition: if rev > INT_MAX/10 or (rev == INT_MAX/10 and pop > 7) return 0; if rev < INT_MIN/10 or (rev == INT_MIN/10 and pop < -8) return 0; Because rev can be negative. That covers both signs.\n\nSo we avoid negating INT_MIN.\n\nThus algorithm steps: rev = 0; while x != 0: pop = x % 10; x = x / 10; check overflow with rev and pop; rev = rev * 10 + pop; end; return rev.\n\nNow produce pseudo-code accordingly.\n\nNow produce lines with explanation.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: Set rev = 0 // 逆轉後的數字暫存\n→ Decision: While x ≠ 0? // 處理每一位數\n    Yes → Step 2: pop = x % 10 // 取得目前最右邊的數字（可能為負）\n    → Step 3: x = x / 10 // 去除已處理的數字\n    → Decision: rev > INT_MAX / 10 or (rev == INT_MAX / 10 and pop > 7)? // 檢查正向溢出\n        Yes → Step 4: Return 0 // 溢出，直接返回 0\n        No  → Decision: rev < INT_MIN / 10 or (rev == INT_MIN / 10 and pop < -8)? // 檢查負向溢出\n            Yes → Step 5: Return 0 // 溢出，直接返回 0\n            No  → Step 6: rev = rev * 10 + pop // 把 pop 加入 rev\n→ Step 7: Return rev // 逆轉成功，回傳結果\nEnd // 程式執行結束\n\nEnsure each line has explanation comment.\n\nMake sure to include the \"Decision:\" lines with indent and Yes →, No →. Provide explanation after each.\n\nAlso include INT_MAX and INT_MIN constants.\n\nNow produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Set rev = 0 // 初始化逆轉後的數字  \n→ Decision: While x ≠ 0? // 逐位處理輸入數字  \n&nbsp;&nbsp;Yes → Step 2: pop = x % 10 // 取得目前最右邊的數字（若 x 為負則為負數）  \n&nbsp;&nbsp;→ Step 3: x = x / 10 // 移除已處理的數字  \n&nbsp;&nbsp;→ Decision: rev > INT_MAX / 10 or (rev == INT_MAX / 10 and pop > 7)? // 檢查正向溢出條件  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 4: Return 0 // 溢出，直接回傳 0  \n&nbsp;&nbsp;&nbsp;&nbsp;No  → Decision: rev < INT_MIN / 10 or (rev == INT_MIN / 10 and pop < -8)? // 檢查負向溢出條件  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 5: Return 0 // 溢出，直接回傳 0  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 6: rev = rev * 10 + pop // 把 pop 加入 rev  \n→ Step 7: Return rev // 逆轉完成，回傳結果  \nEnd // 程式執行結束"
    },
    {
      "title": "Expression Add Operators",
      "source_file": "Leetcode/leetcode282.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "num = \"123\", target = 6",
          "expected_output": "[\"1*2*3\",\"1+2+3\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"1*2*3\",\"1+2+3\"]'\nGot (Norm):      '[\"1+2+3\",\"1*2*3\"]'\n--- (Raw) ---\nRaw Expected: '[\"1*2*3\",\"1+2+3\"]'\nRaw Got:      \"['1+2+3', '1*2*3']\""
        },
        {
          "example_index": 1,
          "input": "num = \"232\", target = 8",
          "expected_output": "[\"2*3+2\",\"2+3*2\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"2*3+2\",\"2+3*2\"]'\nGot (Norm):      '[\"2+3*2\",\"2*3+2\"]'\n--- (Raw) ---\nRaw Expected: '[\"2*3+2\",\"2+3*2\"]'\nRaw Got:      \"['2+3*2', '2*3+2']\""
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def addOperators(self, num, target):\n        res = []\n\n        def backtrack(index, path, value, last):\n            if index == len(num):\n                if value == target:\n                    res.append(path)\n                return\n\n            for i in range(index + 1, len(num) + 1):\n                temp = num[index:i]\n                if len(temp) > 1 and temp[0] == '0':\n                    continue\n                curr = int(temp)\n                if index == 0:\n                    backtrack(i, temp, curr, curr)\n                else:\n                    backtrack(i, path + '+' + temp, value + curr, curr)\n                    backtrack(i, path + '-' + temp, value - curr, -curr)\n                    backtrack(i, path + '*' + temp, value - last + last * curr, last * curr)\n\n        backtrack(0, '', 0, 0)\n        return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    num_match = re.search(r'num\\s*=\\s*\"([^\"]*)\"', data)\n    target_match = re.search(r'target\\s*=\\s*(-?\\d+)', data)\n    num = num_match.group(1) if num_match else ''\n    target = int(target_match.group(1)) if target_match else 0\n    solution = Solution()\n    result = solution.addOperators(num, target)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line, each line with \"虛擬碼步驟 // 解釋\". Use arrows and Start, End, Decision etc. So we need to explain algorithm: backtracking recursion to build expressions, evaluating with precedence (multiplication). Avoid leading zeros. Steps: start, call backtrack(index, path, value, last), etc.\n\nWe must not output actual code, just virtual steps. Must use arrow '→', 'Yes →', 'No →'.\n\nLet's produce steps:\n\nStart // begin\n\n→ Step 1: Initialize result list // 存儲符合目標的表達式\n\n→ Decision: 是否已達到 num 長度? // 检查是否已遍历完所有数字\n\nThen recursion steps: we need to explain building current number substrings, recursion.\n\nWe'll produce something like:\n\n→ Step 2: 從 idx 開始遍歷所有可能的子字符串 num[idx...i] // 每一步取一個連續子串作為數字\n\n→ Step 3: 檢查子串是否有前導零且長度>1? // 若是則跳過\n\n→ Decision: idx==0? // 第一個數字不需要操作符\n\n- Yes → Step 4: 呼叫 backtrack(i+1, 子串, 數值, 數值) // 第一個數字直接設定值\n\n- No → For每種操作符: '+', '-', '*'\n\n   → Step 5: 計算 new_value, last_val 根據操作符\n\n   → Decision: 選擇 '+'\n\n     Yes → Step 6: backtrack(i+1, path+'+'+子串, value+數值, 數值)\n\n   → Decision: 選擇 '-'\n\n     Yes → Step 7: backtrack(i+1, path+'-'+子串, value-數值, -數值)\n\n   → Decision: 選擇 '*'\n\n     Yes → Step 8: backtrack(i+1, path+'*'+子串, value - last + last*數值, last*數值)\n\nAt recursion end when idx==len(num):\n\n→ Decision: value==target? // 判斷是否符合目標\n\n- Yes → Step 9: 把 path 加入結果列表\n\n- No → Step 10: 什麼都不做\n\nFinally after recursion finish:\n\n→ End // 完成\n\nBut we need to structure with arrows. Provide all lines.\n\nLet's produce output accordingly.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 初始化結果列表 result = [] // 用於儲存所有符合目標的表達式\n→ Step 2: 定義遞迴函式 backtrack(idx, path, cur_val, last_val) // idx: 當前索引, path: 目前的表達式字串, cur_val: 目前表達式計算結果, last_val: 最近一次操作的數值（用於乘法計算）\n→ Decision: idx 是否等於 num 的長度? // 檢查是否已經處理完所有數字\n    Yes → Decision: cur_val 是否等於 target? // 判斷完整表達式是否符合目標值\n        Yes → Step 3: 把 path 加入 result 列表 // 找到一個有效表達式\n        No  → Step 4: 回到上一層遞迴 // 不符合目標，回溯\n    No  → Step 5: 從 idx 開始遍歷所有可能的子字串 num[idx…i] // 每一步取一個連續子串作為新數字\n        → Decision: 子字串是否為前導零且長度>1? // 防止前導零的多位數\n            Yes → Step 6: 跳過此子字串 // 無效的數字，繼續下一個子字串\n            No  → Step 7: 把子字串轉為整數 cur_num // 取得當前數字的值\n                → Decision: idx 是否為 0? // 第一個數字不需要操作符\n                    Yes → Step 8: 呼叫 backtrack(i+1, cur_num, cur_num, cur_num) // 第一個數字直接設定值\n                    No  → Step 9: 對於每個操作符 '+', '-', '*' 做以下處理\n                        → Decision: 操作符是 '+'\n                            Yes → Step 10: 呼叫 backtrack(i+1, path+'+'+子字串, cur_val+cur_num, cur_num) // 加法\n                        → Decision: 操作符是 '-'\n                            Yes → Step 11: 呼叫 backtrack(i+1, path+'-'+子字串, cur_val-cur_num, -cur_num) // 減法\n                        → Decision: 操作符是 '*'\n                            Yes → Step 12: 呼叫 backtrack(i+1, path+'*'+子字串, cur_val-last_val+last_val*cur_num, last_val*cur_num) // 乘法（先取消上一步最後一次運算，再加乘法結果）\n→ End // 程式執行結束，result 列表即為所有符合條件的表達式\n```"
    },
    {
      "title": "Concatenated Words",
      "source_file": "Leetcode/leetcode472.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "words = [\"cat\",\"cats\",\"catsdogcats\",\"dog\",\"dogcatsdog\",\"hippopotamuses\",\"rat\",\"ratcatdogcat\"]",
          "expected_output": "[\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]'\nGot (Norm):      '[\"dogcatsdog\",\"catsdogcats\",\"ratcatdogcat\"]'\n--- (Raw) ---\nRaw Expected: '[\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]'\nRaw Got:      \"['dogcatsdog', 'catsdogcats', 'ratcatdogcat']\""
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findAllConcatenatedWordsInADict(self, words):\n        # 先按長度升序排序，方便只用較短的單詞來組合\n        words.sort(key=len)\n        word_set = set()\n        res = []\n\n        for word in words:\n            if not word:          # 空字串不可能是合法連接單詞\n                continue\n            if self._can_form(word, word_set):\n                res.append(word)\n            word_set.add(word)   # 把目前單詞加入集合，供後面更長單詞使用\n        return res\n\n    def _can_form(self, word, word_set):\n        if not word_set:\n            return False\n        dp = [False] * (len(word) + 1)\n        dp[0] = True  # 空前綴總是可組合\n\n        for i in range(1, len(word) + 1):\n            for j in range(i):\n                if dp[j] and word[j:i] in word_set:\n                    dp[i] = True\n                    break\n        return dp[len(word)]\n\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    data = sys.stdin.read()\n    if not data.strip():\n        sys.exit()\n\n    # 從輸入中抽取字串列表\n    idx = data.find('[')\n    if idx != -1:\n        list_str = data[idx:]\n    else:\n        list_str = data\n\n    try:\n        words = ast.literal_eval(list_str)\n    except Exception:\n        words = eval(list_str)\n\n    solution = Solution()\n    result = solution.findAllConcatenatedWordsInADict(words)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for algorithm: Given array of strings words, find all concatenated words (at least two shorter words) comprised entirely of words from array. Typical approach: sort by length ascending; use set; for each word, DP to check if can be formed by others; add to result and add to set. Provide virtual code lines.\n\nWe must use virtual code format: lines like \"Start // 程式開始執行\", \"→ Step 1: Sort words by length // ...\". Use Decision lines with Yes → No → etc. Provide explanations after each line.\n\nNeed to ensure step-by-step, each line with // explanation.\n\nWe must not output actual code, only pseudocode lines.\n\nLet's craft steps:\n\n1. Start\n2. Sort words by length ascending\n3. Initialize set foundWords empty\n4. Initialize result list empty\n5. For each word in sorted words:\n   - If word empty skip\n   - Call canForm(word, foundWords)\n   - If true: add to result, add to foundWords\n   - else: add to foundWords? Actually to check future longer words we need to add all words to set, regardless. Typically add to set after processing. So add to set anyway. But if we don't add, cannot use same word as part of itself; but we should add all words to set for future words. So after processing, add to set.\n6. canForm function: DP array dp[0..len] boolean, dp[0]=true\n   For i from 1 to len:\n     For j from 0 to i-1:\n        if dp[j] && substring j..i in foundWords:\n           dp[i] = true; break\n   Return dp[len] && at least one cut? But ensures at least two words: if dp[len] true, but we need to ensure at least two words. We can enforce by ensuring dp[len] true and either length > 0? Actually we can enforce that at least one split happened. In DP, if dp[len] true and we found at least one j where dp[j] true and substring in foundWords, that's a split. But if word itself is in foundWords (like we added earlier), dp[len] true due to j=0? But substring[0..len] might be in foundWords. But we added foundWords after processing? Actually we only add after checking, so foundWords doesn't contain current word. So dp[len] true requires at least one split. So we can return dp[len].\n7. After loop, End\n8. Return result\n\nWe need to produce virtual code lines accordingly.\n\nLet's craft with arrows and decisions.\n\nAlso need to include decisions: if word empty? If canForm? If word already in set? But no duplicates.\n\nLet's produce final.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort words by length ascending // 先把單詞按長度從短到長排序，方便後續只用已處理過的短單詞來拼接  \n→ Step 2: 初始化 foundWords 為空集合 // 存放已確認可作為「子單詞」的單字  \n→ Step 3: 初始化 result 為空列表 // 存放所有找到的連接單詞  \n→ Step 4: 循環遍歷每個 word in words // 逐一檢查每個單字是否能由更短單詞拼成  \n    → Decision: 如果 word 為空字串?  \n        Yes → Continue // 空字串不可能是合法連接單詞，直接跳過  \n        No  → Step 5: 呼叫 canForm(word, foundWords)  \n    → Decision: canForm 回傳 true?  \n        Yes → Step 6: 將 word 加入 result // 找到合法連接單詞  \n        No  → Step 7: 跳過結果收集 // 不是合法連接單詞  \n    → Step 8: 將 word 加入 foundWords // 之後的較長單字可使用它作為子單詞  \n→ Step 9: 迴圈結束  \n→ Step 10: 返回 result // 完成所有單字的檢查，得到所有連接單詞  \nEnd // 程式執行結束  \n\nStart // canForm 子程序開始  \n→ Step 1: 建立 dp 陣列長度為 word.length + 1，dp[0] = true // dp[i] 表示前 i 個字可否被拼接  \n→ Step 2: 循環 i 從 1 到 word.length  \n    → Step 3: 循環 j 從 0 到 i-1  \n        → Decision: 如果 dp[j] 為 true 且 substring(j, i) 在 foundWords?  \n            Yes → dp[i] = true ; 跳出內層循環 // 找到一個合法分段  \n            No  → 繼續 j  \n    → Step 4: 循環結束 i  \n→ Step 5: 返回 dp[word.length] // 若為 true，說明整個單字能由已知子單詞拼成，且至少有一次分段  \nEnd // canForm 子程序結束"
    },
    {
      "title": "Implement Stack using Queues",
      "source_file": "Leetcode/leetcode225.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "Input [\"MyStack\", \"push\", \"push\", \"top\", \"pop\", \"empty\"], [[], [1], [2], [], [], []]",
          "expected_output": "[null, null, null, 2, 2, false]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp42udu41k.py\", line 75, in <module>\n    main()\n  File \"/tmp/tmp42udu41k.py\", line 52, in main\n    ops, args = ast.literal_eval(f'({data})')\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 112, in literal_eval\n    return _convert(node_or_string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 90, in _convert\n    return tuple(map(_convert, node.elts))\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 111, in _convert\n    return _convert_signed_num(node)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 85, in _convert_signed_num\n    return _convert_num(node)\n           ^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 76, in _convert_num\n    _raise_malformed_node(node)\n  File \"/usr/lib/python3.12/ast.py\", line 73, in _raise_malformed_node\n    raise ValueError(msg + f': {node!r}')\nValueError: malformed node or string on line 1: <ast.Subscript object at 0x7b9e5ac21810>"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nfrom collections import deque\n\nclass MyStack:\n    \"\"\"\n    LIFO stack implemented using two queues (deque).\n    \"\"\"\n    def __init__(self):\n        self.q1 = deque()  # 主隊列，存放所有元素\n        self.q2 = deque()  # 輔助隊列，用於搬移元素\n\n    def push(self, x):\n        \"\"\"Push element onto the stack.\"\"\"\n        self.q1.append(x)  # 直接加入主隊列尾部\n\n    def pop(self):\n        \"\"\"Remove and return the top element of the stack.\"\"\"\n        if not self.q1:\n            return None\n        # 把除了最後一個之外的元素全部移到輔助隊列\n        while len(self.q1) > 1:\n            self.q2.append(self.q1.popleft())\n        popped = self.q1.popleft()  # 最後一個元素即為堆疊頂部\n        # 交換兩隊列，使 q1 再次成為主隊列\n        self.q1, self.q2 = self.q2, self.q1\n        return popped\n\n    def top(self):\n        \"\"\"Return the top element without removing it.\"\"\"\n        if not self.q1:\n            return None\n        while len(self.q1) > 1:\n            self.q2.append(self.q1.popleft())\n        top_val = self.q1.popleft()\n        # 把頂部元素放回輔助隊列\n        self.q2.append(top_val)\n        self.q1, self.q2 = self.q2, self.q1\n        return top_val\n\n    def empty(self):\n        \"\"\"Check if the stack is empty.\"\"\"\n        return not self.q1\n\ndef main():\n    # 讀取整個輸入，格式為: [operations], [arguments]\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 將輸入轉成 tuple (ops, args)\n    ops, args = ast.literal_eval(f'({data})')\n    stack = MyStack()\n    results = []\n\n    for op, arg in zip(ops, args):\n        if op == 'push':\n            # push 需要一個參數，arg 是 [x]\n            stack.push(arg[0] if arg else None)\n            results.append(None)          # push 沒有返回值\n        elif op == 'pop':\n            results.append(stack.pop())\n        elif op == 'top':\n            results.append(stack.top())\n        elif op == 'empty':\n            results.append(stack.empty())\n        else:\n            # 未知操作，略過\n            results.append(None)\n\n    # 使用 json.dumps 以符合期望輸出格式 (null, false)\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps that implement a stack using two queues. We need to output lines like \"Start // 程式開始執行\" and each step. We need to include virtual code with arrow etc.\n\nWe need to produce a sequence of steps to implement push, pop, top, empty. Possibly use two queues q1, q2. Standard method: for push, enqueue into q1. For pop, move all except last from q1 to q2, dequeue last, then swap q1 and q2. For top, similar but return last element without removal. For empty, check q1 empty.\n\nWe need to produce steps as a high-level algorithm. Let's produce steps for each function: push, pop, top, empty. Could structure like Start, then maybe functions defined. But need to produce line by line.\n\nWe can structure like:\n\nStart\n→ Initialize Queue1 // q1\n→ Initialize Queue2 // q2\n→ Define Function push(x) // push operation\n    → Enqueue x into q1 // add to back\n→ Define Function pop() // pop operation\n    → Decision: if q1 empty? // check empty\n        Yes → Return null // or handle error\n        No  → Decision: if size(q1) == 1? // only one element\n            Yes → Dequeue from q1 // pop and return\n            No  → While size(q1) > 1: // move all but last\n                → Dequeue front from q1 and enqueue into q2 // transfer\n            → Dequeue last from q1 // pop\n            → Swap q1 and q2 // restore queues\n→ Define Function top() // top operation\n    → Similar to pop but keep last element\n        ... etc\n→ Define Function empty() // empty\n    → Return isEmpty(q1)\nEnd\n\nBut need to use arrow \"→\" and Decision lines.\n\nWe must ensure each line has comment. Provide brief explanation after //.\n\nLet's craft accordingly.\n\nAlso note we need to maintain stack top in q1. We may want to keep q1 as main. We'll use q2 as temp.\n\nWe can produce lines for each function separately. For clarity, we might put \"Function push\" and then steps.\n\nWe need each line with virtual code step + comment.\n\nLet's produce something like:\n\nStart // 程式開始執行\n→ Initialize Queue q1 // 初始化主隊列\n→ Initialize Queue q2 // 初始化輔助隊列\n\n→ Function push(x) // 推入元素\n    → Enqueue x into q1 // 把 x 放入隊列尾部\n\n→ Function pop() // 彈出頂部元素\n    → Decision: q1 is empty? // 檢查是否為空\n        Yes → Return null // 空時返回 null\n        No  → Decision: size(q1) == 1? // 只剩一個元素\n            Yes → Dequeue from q1 → Return value // 直接彈出\n            No  → While size(q1) > 1:\n                → Dequeue front from q1 → Enqueue into q2 // 移除前面元素\n            → Dequeue last from q1 → Store as popped // 把最後一個元素彈出\n            → Swap q1 and q2 // 重新整理隊列\n            → Return popped // 返回彈出的值\n\n→ Function top() // 查看頂部元素\n    → Decision: q1 is empty? // 檢查是否為空\n        Yes → Return null // 空時返回 null\n        No  → Decision: size(q1) == 1? // 只剩一個元素\n            Yes → Peek front of q1 → Return value // 直接返回\n            No  → While size(q1) > 1:\n                → Dequeue front from q1 → Enqueue into q2 // 移除前面元素\n            → Peek front of q1 → Store as topVal // 獲取最後一個元素\n            → Dequeue from q1 → Enqueue into q2 // 將最後一個元素移到 q2\n            → Swap q1 and q2 // 重新整理隊列\n            → Return topVal // 返回頂部值\n\n→ Function empty() // 判斷是否為空\n    → Return isEmpty(q1) // 只檢查主隊列即可\n\nEnd // 程式結束\n\nBut each line must have comment after //. Also we must keep indentation? Not specified, but we can indent to show nested.\n\nWe must not output actual code but virtual code. So we can write \"→ Function push(x)\". That is a line. But we need to indent steps inside function. Use indentation spaces.\n\nWe need to be careful with arrow: we use \"→\" for steps, and for decision we use \"Decision:\" and then indentation. In sample they used \"Decision:\" and then \"Yes →\" etc. So we need to follow that.\n\nAlso we need to ensure each line ends with comment after //.\n\nLet's craft final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Initialize Queue q1 // 初始化主隊列，儲存所有元素  \n→ Initialize Queue q2 // 初始化輔助隊列，協助搬移元素  \n\n→ Function push(x) // 將元素 x 推入堆疊  \n    → Enqueue x into q1 // 把 x 放入 q1 的尾端  \n\n→ Function pop() // 從堆疊頂部移除並返回元素  \n    → Decision: q1 is empty? // 檢查是否為空  \n        Yes → Return null // 空時返回 null  \n        No  → Decision: size(q1) == 1? // 只剩一個元素  \n            Yes → Dequeue from q1 → Return value // 直接彈出並返回  \n            No  → While size(q1) > 1: // 只留下最後一個元素  \n                → Dequeue front from q1 → Enqueue into q2 // 移除前面元素至 q2  \n            → Dequeue last from q1 → Store as popped // 把最後一個元素彈出  \n            → Swap q1 and q2 // 重新將 q2 變為主隊列  \n            → Return popped // 返回彈出的值  \n\n→ Function top() // 查看堆疊頂部元素但不移除  \n    → Decision: q1 is empty? // 檢查是否為空  \n        Yes → Return null // 空時返回 null  \n        No  → Decision: size(q1) == 1? // 只剩一個元素  \n            Yes → Peek front of q1 → Return value // 直接返回  \n            No  → While size(q1) > 1: // 只留下最後一個元素  \n                → Dequeue front from q1 → Enqueue into q2 // 移除前面元素至 q2  \n            → Peek front of q1 → Store as topVal // 獲取最後一個元素  \n            → Dequeue from q1 → Enqueue into q2 // 將最後一個元素移至 q2  \n            → Swap q1 and q2 // 重新將 q2 變為主隊列  \n            → Return topVal // 返回頂部值  \n\n→ Function empty() // 判斷堆疊是否為空  \n    → Return isEmpty(q1) // 只檢查主隊列即可  \n\nEnd // 程式結束執行"
    },
    {
      "title": "Course Schedule II",
      "source_file": "Leetcode/leetcode210.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]",
          "expected_output": "[0,2,1,3]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[0,2,1,3]'\nGot (Norm):      '[0,1,2,3]'\n--- (Raw) ---\nRaw Expected: '[0,2,1,3]'\nRaw Got:      '[0, 1, 2, 3]'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import deque\n\nclass Solution:\n    def findOrder(self, numCourses, prerequisites):\n        # 建立鄰接表與入度表\n        graph = [[] for _ in range(numCourses)]\n        indegree = [0] * numCourses\n\n        for dest, src in prerequisites:\n            graph[src].append(dest)\n            indegree[dest] += 1\n\n        # 先修課程的佇列\n        queue = deque([i for i in range(numCourses) if indegree[i] == 0])\n        order = []\n\n        # Kahn 演算法\n        while queue:\n            node = queue.popleft()\n            order.append(node)\n            for neighbor in graph[node]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    queue.append(neighbor)\n\n        # 判斷是否完成所有課程\n        return order if len(order) == numCourses else []\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 從字串中擷取 numCourses 與 prerequisites\n    num_match = re.search(r'numCourses\\s*=\\s*(\\d+)', data)\n    pre_match = re.search(r'prerequisites\\s*=\\s*(\\[.*\\])', data)\n\n    if not num_match or not pre_match:\n        print([])\n        sys.exit()\n\n    numCourses = int(num_match.group(1))\n    prerequisites = ast.literal_eval(pre_match.group(1))\n\n    # 取得排序結果並輸出\n    result = Solution().findOrder(numCourses, prerequisites)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to generate a step-by-step virtual code for topological sort algorithm using Kahn's algorithm or DFS. Provide virtual code lines with explanation. Should be in Traditional Chinese. Use arrows. Provide each step. Use decision branches.\n\nWe need to output start, steps: read input, build graph, indegree array, queue, etc. Provide comments in // after each line. Should be step-by-step lines.\n\nLet's craft. Use arrow formatting: \"→ Step X: ...\" Use Decision: with Yes/No. Use End.\n\nLet's write.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取 numCourses 與 prerequisites 陣列 // 取得課程總數與先修關係  \n→ Step 2: 建立空的鄰接表 graph，長度為 numCourses // 用於儲存每門課的後續課程  \n→ Step 3: 建立 indegree 陣列，長度為 numCourses，全部初始為 0 // 儲存每門課的入度數  \n→ Decision: prerequisites 是否為空? // 檢查是否有先修條件  \n  Yes → Step 4: 回傳空陣列 [] // 無先修條件，任何順序皆可，直接回傳空結果  \n  No  → Step 5: 針對每對 [a, b] in prerequisites 做以下操作  \n   → Step 5a: 將 a 加入 graph[b] 的後續清單 // b 必須先修於 a  \n   → Step 5b: indegree[a] += 1 // a 的入度加 1  \n→ Step 6: 建立空佇列 queue，並將所有 indegree 為 0 的課程加入 queue // 這些課程可立即修  \n→ Step 7: 建立空的結果陣列 order = [] // 儲存課程順序  \n→ Decision: queue 是否為空? // 檢查是否還有可修課程  \n  Yes → Step 8: 迴圈 while queue 非空  \n    → Step 8a: 取出 queue 前端課程 u  \n    → Step 8b: order.append(u) // 加入順序  \n    → Step 8c: 針對 graph[u] 中每個後續課程 v 做以下操作  \n      → Step 8c1: indegree[v] -= 1 // v 的入度減 1  \n      → Decision: indegree[v] == 0? // 判斷 v 是否現在可修  \n        Yes → Step 8c2: queue.append(v) // 加入佇列  \n        No → Step 8c3: do nothing  \n    → Step 8d: 重複 Step 8a  \n  No → Step 9: // queue 為空且仍有未處理課程  \n    → Decision: len(order) == numCourses? // 檢查是否已排完所有課程  \n      Yes → Step 9a: // 所有課程已排完  \n        → Step 9a1: 回傳 order // 有效的修課順序  \n      No → Step 9b: // 存在循環，無法完成所有課程  \n       → Step 9b1: 回傳 [] // 返回空陣列表示不可能完成  \nEnd // 程式執行結束"
    },
    {
      "title": "Search in Rotated Sorted Array II",
      "source_file": "Leetcode/leetcode81.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [2,5,6,0,0,1,2], target = 0",
          "expected_output": "true",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpepfl6vbp.py\", line 44, in <module>\n    main()\n  File \"/tmp/tmpepfl6vbp.py\", line 34, in main\n    exec(data, {}, local_vars)\n  File \"<string>\", line 1\n    nums = [2,5,6,0,0,1,2], target = 0\n    ^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "nums = [2,5,6,0,0,1,2], target = 3",
          "expected_output": "false",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp1sxi0ev6.py\", line 44, in <module>\n    main()\n  File \"/tmp/tmp1sxi0ev6.py\", line 34, in main\n    exec(data, {}, local_vars)\n  File \"<string>\", line 1\n    nums = [2,5,6,0,0,1,2], target = 3\n    ^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "class Solution:\n    def search(self, nums, target):\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return True\n\n            if nums[left] == nums[mid] == nums[right]:\n                left += 1\n                right -= 1\n            elif nums[left] <= nums[mid]:\n                if nums[left] <= target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            else:\n                if nums[mid] < target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n        return False\n\n\ndef main():\n    import sys\n\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 執行輸入的文字，期望得到 nums 與 target 兩個變數\n    local_vars = {}\n    exec(data, {}, local_vars)\n    nums = local_vars.get(\"nums\")\n    target = local_vars.get(\"target\")\n\n    sol = Solution()\n    result = sol.search(nums, target)\n    print(\"true\" if result else \"false\")\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code (pseudo) line by line with explanation. We need to answer in Traditional Chinese. The user describes a rotated sorted array with possible duplicates, search target. We need to find algorithm: Typically use modified binary search that handles duplicates. But requirement: minimize operations. Approach: find pivot? But duplicates cause ambiguity. Standard approach: use binary search with check for duplicates by skipping duplicates.\n\nWe need to produce pseudocode lines like:\n\nStart // start\n\n→ Step 1: n = length(nums)\n\n→ Step 2: left = 0; right = n-1\n\n→ Decision: left <= right? // loop while\n\nInside loop:\n\n→ Step: mid = (left+right)//2\n\n→ Decision: nums[mid] == target? -> return true\n\n→ Decision: nums[left] == nums[mid] == nums[right]? -> left++, right-- (skip duplicates)\n\n→ Decision: nums[left] <= nums[mid]? // left part sorted\n\n-> Decision: target in [nums[left], nums[mid])? -> right = mid-1 else left = mid+1\n\nElse (right part sorted)\n\n-> Decision: target in (nums[mid], nums[right]]? -> left = mid+1 else right = mid-1\n\nLoop.\n\nAfter loop, return false.\n\nWe'll produce each step with explanation. Use arrow style as required.\n\nAlso need to include Start and End markers.\n\nLet's craft the virtual code lines accordingly.\n\nWe need to use \"→\" and indent for decisions. Use \"Yes →\" and \"No →\". Provide explanation after each line. All in Traditional Chinese.\n\nLet's output:\n\nStart // 程式開始執行\n→ Step 1: n = length(nums) // 取得陣列長度\n→ Step 2: left = 0; right = n - 1 // 初始化左右指標\n→ Decision: left <= right? // 當左指標不超過右指標時持續搜尋\n    Yes → Step 3: mid = (left + right) // 2 // 計算中間索引\n    → Decision: nums[mid] == target? // 中間元素是否為目標\n        Yes → Step 4: return true // 找到目標，直接返回真\n        No  → Decision: nums[left] == nums[mid] && nums[mid] == nums[right]? // 左、中、右相等，無法判斷排序區域\n            Yes → Step 5: left = left + 1; right = right - 1 // 兩端元素相同，移除重複\n            No  → Decision: nums[left] <= nums[mid]? // 左半邊是否有序\n                Yes → Decision: nums[left] <= target < nums[mid]? // 目標在左半邊\n                    Yes → Step 6: right = mid - 1 // 搜尋左半邊\n                    No  → Step 7: left = mid + 1 // 搜尋右半邊\n                No  → Decision: nums[mid] < target <= nums[right]? // 目標在右半邊\n                    Yes → Step 8: left = mid + 1 // 搜尋右半邊\n                    No  → Step 9: right = mid - 1 // 搜尋左半邊\nEnd // 程式執行結束，未找到目標，返回偽\nBut we need to include return false at the end.\n\nLet's adjust: After loop exit, return false.\n\nSo after the Decision block, we should close loop and then at End we return false.\n\nLet's format accordingly.\n\nRemember each line must have \"虛擬碼步驟\" followed by space then \"// 解釋\".\n\nWe can use indentation to show nested decisions.\n\nWe need to ensure each line is separate. Use \"→\" at beginning for steps within start. For decisions use \"Decision:\" with indent.\n\nUse \"Yes →\" and \"No →\" for branches.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n = length(nums) // 取得陣列長度  \n→ Step 2: left = 0; right = n - 1 // 初始化左右指標  \n→ Decision: left <= right? // 當左指標不超過右指標時持續搜尋  \n Yes → Step 3: mid = (left + right) // 2 // 計算中間索引  \n → Decision: nums[mid] == target? // 中間元素是否為目標  \n  Yes → Step 4: return true // 找到目標，直接返回真  \n  No → Decision: nums[left] == nums[mid] && nums[mid] == nums[right]? // 左、中、右相等，無法判斷排序區域  \n   Yes → Step 5: left = left + 1; right = right - 1 // 兩端元素相同，移除重複  \n   No → Decision: nums[left] <= nums[mid]? // 左半邊是否有序  \n    Yes → Decision: nums[left] <= target < nums[mid]? // 目標在左半邊  \n     Yes → Step 6: right = mid - 1 // 搜尋左半邊  \n     No → Step 7: left = mid + 1 // 搜尋右半邊  \n    No → Decision: nums[mid] < target <= nums[right]? // 目標在右半邊  \n     Yes → Step 8: left = mid + 1 // 搜尋右半邊  \n     No → Step 9: right = mid - 1 // 搜尋左半邊  \nEnd // 程式執行結束，未找到目標，返回偽（程式將返回 false）"
    },
    {
      "title": "Generate Random Point in a Circle",
      "source_file": "Leetcode/leetcode478.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]",
          "expected_output": "[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[-0.02493,-0.38077],[0.82314,0.38945],[0.36572,0.17248]]'\nGot (Norm):      '[null,[0.4485151189334944,-0.3070240679337768],[0.5159732726736688,-0.6452936591407364],[-0.45658082435057284,0.09115330269137539]]'\n--- (Raw) ---\nRaw Expected: '[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]'\nRaw Got:      '[null, [0.4485151189334944, -0.3070240679337768], [0.5159732726736688, -0.6452936591407364], [-0.45658082435057284, 0.09115330269137539]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport math\n\nclass Solution:\n    def __init__(self, radius, x_center, y_center):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n\n    def randPoint(self):\n        r = self.radius * math.sqrt(random.random())\n        theta = random.uniform(0, 2 * math.pi)\n        x = self.x_center + r * math.cos(theta)\n        y = self.y_center + r * math.sin(theta)\n        return [x, y]\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    commands = json.loads(data[0])\n    args_list = json.loads(data[1]) if len(data) > 1 else []\n\n    results = []\n    obj = None\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"Solution\":\n            obj = Solution(*args)\n            results.append(None)\n        elif cmd == \"randPoint\":\n            results.append(obj.randPoint())\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode for this functionality. Must be line by line with arrow and explanation. Use structure: Start, Decision etc. We need to cover class initialization, random point generation. Need to incorporate generating uniform random point inside circle: use method: choose random radius sqrt(rnd) * R, random angle uniform 0 to 2π. Then x = center_x + radius * cos(angle). y = center_y + radius * sin(angle). Or choose random point in square and reject outside circle (but less efficient). We'll choose polar method.\n\nWe need to produce lines: Start // Program start. Then Step 1: Class constructor. Step 2: random generation. Use Random() instance.\n\nUse arrow: →.\n\nWe need to include lines for initializing random number generator.\n\nWe also need a Step for computing angle, radius.\n\nWe need explanation after each line.\n\nWe should use decision? maybe not needed.\n\nBut we can show decisions? maybe not.\n\nLet's produce:\n\nStart // 程式開始執行\n\n→ Step 1: 定義類別 Solution // 宣告 Solution 類別\n\n→ Step 2: 在類別內部，建立建構子 Solution(radius, x_center, y_center) // 初始化圓半徑與中心座標\n\n→ Step 3: 內部存儲 radius, x_center, y_center 作為物件屬性 // 方便後續使用\n\n→ Step 4: 建立隨機數產生器 rng = Random() // 用於產生亂數\n\n→ Step 5: 定義方法 randPoint() // 將產生隨機點的功能包裝為方法\n\n→ Step 6: 內部產生均勻角度 θ = rng.nextDouble() * 2π // 0 ~ 2π 之間的隨機角度\n\n→ Step 7: 產生半徑 r = rng.nextDouble() 的平方根 * radius // 確保點在圓內均勻分佈\n\n→ Step 8: 計算座標 x = x_center + r * cos(θ) // 轉換極座標為直角座標\n\n→ Step 9: 計算座標 y = y_center + r * sin(θ) // 同上\n\n→ Step 10: 回傳 [x, y] // 以陣列形式輸出結果\n\nEnd // 程式執行結束\n\nBut we need to output each line with virtual code and comment. Use arrow \"→\".\n\nAlso, we may include Start, End lines with no arrow? According to format example, Start and End are lines with just 'Start' and 'End'.\n\nYes.\n\nSo we produce:\n\nStart // 程式開始執行\n\n→ Step 1: class Solution // 宣告 Solution 類別\n\n→ Step 2: constructor Solution(radius, x_center, y_center) // 初始化半徑與中心\n\n→ Step 3: this.radius ← radius // 儲存半徑\n\n→ Step 4: this.x_center ← x_center // 儲存中心 x 座標\n\n→ Step 5: this.y_center ← y_center // 儲存中心 y 座標\n\n→ Step 6: this.rng ← Random() // 建立隨機數產生器\n\n→ Step 7: method randPoint() // 定義隨機點生成方法\n\n→ Step 8:   θ ← rng.nextDouble() * 2π // 產生隨機角度\n\n→ Step 9:   u ← rng.nextDouble() // 產生 0~1 的隨機數\n\n→ Step 10:   r ← sqrt(u) * this.radius // 產生均勻半徑\n\n→ Step 11:   x ← this.x_center + r * cos(θ) // 計算 x 座標\n\n→ Step 12:   y ← this.y_center + r * sin(θ) // 計算 y 座標\n\n→ Step 13:   return [x, y] // 回傳點\n\nEnd // 程式執行結束\n\nWe should ensure no actual code; just pseudocode with arrows and comments. Good.\n\nLet's provide that.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: class Solution // 宣告 Solution 類別\n→ Step 2: constructor Solution(radius, x_center, y_center) // 初始化半徑與中心座標\n→ Step 3:     this.radius ← radius // 儲存圓半徑\n→ Step 4:     this.x_center ← x_center // 儲存中心 x 座標\n→ Step 5:     this.y_center ← y_center // 儲存中心 y 座標\n→ Step 6:     this.rng ← Random() // 建立隨機數產生器\n→ Step 7: method randPoint() // 定義產生隨機點的方法\n→ Step 8:         θ ← rng.nextDouble() * 2π // 產生 0~2π 的隨機角度\n→ Step 9:         u ← rng.nextDouble() // 產生 0~1 的隨機數\n→ Step 10:        r ← sqrt(u) * this.radius // 轉換為均勻分布的半徑\n→ Step 11:        x ← this.x_center + r * cos(θ) // 計算 x 座標\n→ Step 12:        y ← this.y_center + r * sin(θ) // 計算 y 座標\n→ Step 13:        return [x, y] // 回傳隨機點\nEnd // 程式執行結束"
    },
    {
      "title": "Remove Element",
      "source_file": "Leetcode/leetcode27.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "nums = [0,1,2,2,3,0,4,2], val = 2",
          "expected_output": "5, nums = [0,1,4,0,3,_,_,_]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '5,nums=[0,1,4,0,3,_,_,_]'\nGot (Norm):      '5,nums=[0,1,3,0,4,_,_,_]'\n--- (Raw) ---\nRaw Expected: '5, nums = [0,1,4,0,3,_,_,_]'\nRaw Got:      '5, nums = [0, 1, 3, 0, 4, _, _, _]'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def removeElement(self, nums, val):\n        \"\"\"移除 nums 中所有等於 val 的元素，並返回剩餘元素的個數 k。\"\"\"\n        slow = 0\n        for fast in range(len(nums)):\n            if nums[fast] != val:\n                nums[slow] = nums[fast]\n                slow += 1\n        return slow\n\ndef main():\n    # 讀取整行輸入，例如: \"nums = [3,2,2,3], val = 3\"\n    data = sys.stdin.read().strip()\n\n    # 解析 nums 列表\n    nums_match = re.search(r'nums\\s*=\\s*\\[([^\\]]*)\\]', data)\n    val_match  = re.search(r'val\\s*=\\s*(-?\\d+)', data)\n\n    if not nums_match or not val_match:\n        return\n\n    nums_str = nums_match.group(1).strip()\n    nums = [int(x.strip()) for x in nums_str.split(',')] if nums_str else []\n\n    val = int(val_match.group(1))\n\n    # 呼叫解法\n    sol = Solution()\n    k = sol.removeElement(nums, val)\n\n    # 準備輸出：前 k 個元素保留，後面以 '_' 標示\n    parts = [str(num) for num in nums[:k]] + ['_' for _ in range(len(nums) - k)]\n    print(f\"{k}, nums = [{', '.join(parts)}]\")\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm: remove element from array in-place, return k. We must produce line-by-line steps with explanations. Use Start, End, Decision, arrow. Provide each line like \"Start // 程式開始執行\" etc.\n\nWe need to produce algorithm: iterate over array, use two pointers: i index scanning, p index for position of next keep. For each element nums[i], if nums[i] != val then assign nums[p] = nums[i]; p++. After loop, k = p; return k.\n\nWe need to produce virtual code lines accordingly.\n\nUse arrow lines: \"→ Step 1: ...\" etc. Indent decisions.\n\nLet's produce: Start, Step 1: Initialize p=0, n = length of nums, i=0. Step 2: Decision: i < n? Yes -> Step 3: If nums[i] != val? Yes -> Step 4: nums[p] = nums[i]; p++. Step 5: i++ . Then loop back to Step 2. After loop, Step 6: k = p. Step 7: Return k. End.\n\nAlso maybe we need to handle if val appears multiple times.\n\nWe'll produce. Use virtual code arrow '→' for each step. Use 'Decision:' lines. Use 'Yes →', 'No →'.\n\nLet's craft.\n\nLine formatting:\n\nStart // 程式開始執行\n→ Step 1: n ← length(nums); p ← 0; i ← 0 // 初始化變數\n→ Decision: i < n? // 檢查是否還有元素要處理\n    Yes → Step 2: If nums[i] ≠ val? // 判斷當前元素是否需要保留\n        Yes → Step 3: nums[p] ← nums[i]; p ← p + 1 // 把非 val 元素移到前面\n        No  → // 若是 val，直接跳過\n    No  → // 沒有更多元素\n    // 無論結果，繼續\n→ Step 4: i ← i + 1 // 移動到下一個元素\n→ Decision: i < n? // 再次檢查是否結束迴圈\n    Yes → 回到 Step 2\n    No  → // 迴圈結束\n→ Step 5: k ← p // 最終保留元素個數\n→ Step 6: Return k // 將結果返回給調用者\nEnd // 程式結束\n\nBut we need to ensure formatting: each line separated. For decision blocks we use indentation or separate lines with Yes →. Example format: \"Decision: ... // comment\". Then indent \"Yes → Step ...\" etc.\n\nBetter to format as:\n\nDecision: i < n? // comment\n    Yes → Step 2: ...\n    No  → // comment\n\nAlso step after decision to increment i. For readability.\n\nWe need to produce only virtual code lines, each line with step and comment. No real code.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← length(nums); p ← 0; i ← 0 // 初始化長度、前置指標 p 與掃描指標 i  \n→ Decision: i < n? // 檢查是否還有元素要處理  \n Yes → Step 2: If nums[i] ≠ val? // 判斷目前元素是否應保留  \n  Yes → Step 3: nums[p] ← nums[i]; p ← p + 1 // 把非 val 元素移至前面，更新 p  \n  No  → // 當前元素為 val，直接跳過  \n No  → // 沒有更多元素可掃描  \n→ Step 4: i ← i + 1 // 移動到下一個元素  \n→ Decision: i < n? // 再次檢查是否結束迴圈  \n Yes → 回到 Step 2  \n No  → // 迴圈結束  \n→ Step 5: k ← p // k 為保留元素的個數  \n→ Step 6: Return k // 回傳 k 給調用者  \nEnd // 程式執行結束"
    },
    {
      "title": "Target Sum",
      "source_file": "Leetcode/leetcode494.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,1,1,1,1], target = 3",
          "expected_output": "5",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpie159o4d.py\", line 36, in <module>\n    nums, target = parse_input(raw_input)\n                   ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpie159o4d.py\", line 29, in parse_input\n    target_part = parts[1].split('=')[1].strip()\n                  ~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def findTargetSumWays(self, nums, target):\n        \"\"\"\n        DP: dp[s] 表示使用已處理數字時，能得到總和 s 的方案數。\n        每個數字可以加 (+) 或減 (-)，故對每個 s 產生兩個新的總和。\n        \"\"\"\n        dp = defaultdict(int)\n        dp[0] = 1  # 初始時總和為 0 的方案只有一種（未選任何數字）\n\n        for num in nums:\n            next_dp = defaultdict(int)\n            for s in dp:\n                next_dp[s + num] += dp[s]  # 加上正號\n                next_dp[s - num] += dp[s]  # 加上負號\n            dp = next_dp\n\n        return dp[target]\n\ndef parse_input(input_str: str):\n    \"\"\"\n    解析形如 'nums = [1,1,1,1,1], target = 3' 的輸入字串。\n    \"\"\"\n    parts = input_str.split(',')\n    nums_part = parts[0].split('=')[1].strip()\n    target_part = parts[1].split('=')[1].strip()\n    nums = ast.literal_eval(nums_part)   # 安全地解析列表\n    target = int(target_part)\n    return nums, target\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    nums, target = parse_input(raw_input)\n    solution = Solution()\n    result = solution.findTargetSumWays(nums, target)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for solving this problem: count number of ways to assign + or - to each number in array nums such that sum equals target. Classic DP or recursion with memo. Use recursion: f(index, current_sum). Complexity 2^n. But we can use DP with sum offset. We'll produce pseudocode.\n\nWe need to output step-by-step virtual code lines, each line with `虛擬碼步驟 // 解釋`. Use Start, End, Decision, etc. We need to produce lines, each line one step.\n\nLet's design:\n\nStart\n→ Step: 定義函式 countWays(nums, target)\n→ Step: 建立 memo dict\n→ Step: 定義遞迴函式 dfs(index, current_sum)\n→ Decision: 若 index == len(nums) ?\n    Yes → Decision: 若 current_sum == target ?\n        Yes → Return 1\n        No  → Return 0\n    No  → 兩個選擇:\n        Yes → left = dfs(index+1, current_sum + nums[index])\n        No  → right = dfs(index+1, current_sum - nums[index])\n        Return left + right\n→ Step: 將 dfs(0, 0) 存入 memo if needed.\n→ Step: Return result\nEnd\n\nWe also need to include memoization logic: check memo[(index,current_sum)] first. Add Decision: 若 memo contains key?\n\nSo lines accordingly.\n\nLet's craft lines with arrows. Use \"→\" arrow after each step.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step: 定義函式 CountWays(nums, target) // 主入口\n→ Step: 建立 memo = {} // 用於記錄已計算的子問題\n→ Step: 定義遞迴函式 dfs(idx, curr) // idx 為目前處理到的索引，curr 為目前累積總和\n    → Decision: 若 memo 中存在 (idx, curr) ?\n        Yes → Return memo[(idx, curr)] // 直接回傳已算結果\n        No  →\n    → Decision: 若 idx == len(nums) ?\n        Yes → Decision: 若 curr == target ?\n            Yes → Return 1 // 找到一種合法表達式\n            No  → Return 0 // 不符合目標\n        No  →\n    → Step: left = dfs(idx + 1, curr + nums[idx]) // 加上正號\n    → Step: right = dfs(idx + 1, curr - nums[idx]) // 加上負號\n    → Step: memo[(idx, curr)] = left + right // 記錄結果\n    → Step: Return memo[(idx, curr)] // 回傳累計結果\n→ Step: result = dfs(0, 0) // 從第一個數字開始，總和初始為 0\n→ Step: Return result // 回傳總計數\nEnd // 程式執行結束"
    },
    {
      "title": "Shuffle an Array",
      "source_file": "Leetcode/leetcode384.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"], [[[1, 2, 3]], [], [], []]",
          "expected_output": "[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[3,1,2],[1,2,3],[1,3,2]]'\nGot (Norm):      '[None,[1,3,2],[1,2,3],[3,2,1]]'\n--- (Raw) ---\nRaw Expected: '[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]'\nRaw Got:      '[None, [1, 3, 2], [1, 2, 3], [3, 2, 1]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\n\nclass Solution:\n    def __init__(self, nums):\n        self.original = list(nums)   # 儲存原始陣列\n\n    def reset(self):\n        # 回復原始陣列\n        return list(self.original)\n\n    def shuffle(self):\n        # Fisher‑Yates 洗牌\n        arr = list(self.original)\n        n = len(arr)\n        for i in range(n):\n            j = random.randint(i, n - 1)\n            arr[i], arr[j] = arr[j], arr[i]\n        return arr\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 解析輸入，例如 '[\"Solution\", \"shuffle\", ...], [[[1, 2, 3]], [], [], []]'\n    ops, args_list = ast.literal_eval(data)\n    result = []\n    sol = None\n    for op, args in zip(ops, args_list):\n        if op == \"Solution\":\n            sol = Solution(args[0])\n            result.append(None)          # LeetCode 期望返回 null\n        elif op == \"reset\":\n            result.append(sol.reset())\n        elif op == \"shuffle\":\n            result.append(sol.shuffle())\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nThe user wants virtual code steps, not actual code. We need to output line by line with \"虛擬碼步驟 // 解釋\". The algorithm: we have a Solution class with constructor storing original array and a copy for shuffling. Reset returns original. Shuffle uses Fisher-Yates. We need to produce steps in a flowchart style, with Start, End, Decision, etc. Each line: \"虛擬碼步驟\" could be like \"Start\", \"→ Step: 初始化物件\", etc. Provide explanation after //.\n\nWe need to adhere to the format: each line: 虛擬碼步驟 [space] // 解釋.\n\nUse arrow \"→\" and \"Yes →\" \"No →\".\n\nWe can produce high-level steps for class design, constructor, reset, shuffle methods.\n\nWe need to include method definitions and steps inside them. But \"虛擬碼步驟\" should be something like \"Solution(int[] nums) { ... }\" but we cannot write actual code. Instead we can write \"Solution: 初始化物件\" etc.\n\nWe might represent code blocks as steps. Eg:\n\nStart // 程式開始執行\n→ Step 1: 定義類別 Solution // 宣告類別\n→ Step 2: 宣告成員變數 original, current // 存儲原始與現有陣列\n\nThen maybe separate blocks for constructor, reset, shuffle.\n\nBut we need to maintain clarity. We'll produce a flow of the class and its methods.\n\nProbably better: Show pseudo-code inside methods.\n\nLet's design:\n\nStart\n→ Step: 定義類別 Solution // 開始定義類別\n→ Step: 成員: original[], current[] // 儲存原始與拷貝\n→ Step: Constructor Solution(nums) // 初始化\n    → Step: original ← copy of nums // 儲存原始\n    → Step: current ← copy of nums // 初始化當前陣列\n→ Step: 方法 reset() // 重置\n    → Step: current ← copy of original // 重置\n    → Step: 返回 current // 返回重置後陣列\n→ Step: 方法 shuffle() // 洗牌\n    → Step: length ← current 的長度 // 取得長度\n    → Decision: length > 1? // 若陣列長度>1\n        Yes →\n            → For i從0到 length-1\n                → 隨機生成 j ∈ [i, length-1] // 隨機索引\n                → 交換 current[i] 與 current[j] // 交換\n            → End For\n        No → // 如果長度<=1, 不需要交換\n    → Step: 返回 current // 返回洗牌後陣列\nEnd\n\nWe need each line as \"虛擬碼步驟 // 解釋\". Use arrow at start.\n\nUse \"→\" for normal steps.\n\nUse \"Decision:\" with \"Yes →\" \"No →\".\n\nMake sure each line has no actual code but description. Use Chinese.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類別 Solution // 宣告 Solution 類別  \n→ Step 2: 宣告成員變數 original[], current[] // 儲存原始陣列與當前陣列  \n→ Step 3: 定義 Constructor Solution(nums) // 初始化物件  \n  → Step 3.1: original ← 複製 nums // 先保存原始順序  \n  → Step 3.2: current ← 複製 nums // 初始時 current 與 original 相同  \n→ Step 4: 定義方法 reset() // 重置陣列  \n  → Step 4.1: current ← 複製 original // 回復為原始順序  \n  → Step 4.2: 返回 current // 給使用者回傳重置後陣列  \n→ Step 5: 定義方法 shuffle() // 隨機洗牌  \n  → Step 5.1: length ← current 的長度 // 取得陣列長度  \n  → Decision: length > 1? // 若陣列長度大於 1  \n   Yes → Step 5.2: 從 i=0 到 length-1 逐步執行  \n    → Step 5.2.1: 隨機生成 j ∈ [i, length-1] // 隨機索引  \n    → Step 5.2.2: 交換 current[i] 與 current[j] // 交換兩個元素  \n    → Step 5.2.3: 結束迴圈  \n   No → Step 5.3: // 長度 ≤ 1 時不需交換  \n  → Step 5.4: 返回 current // 給使用者回傳洗牌後陣列  \nEnd // 程式執行結束"
    },
    {
      "title": "Subsets",
      "source_file": "Leetcode/leetcode78.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nGot (Norm):      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nRaw Got:      '[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def subsets(self, nums):\n        \"\"\"Generate all subsets of a list of unique integers.\"\"\"\n        res = []\n\n        def backtrack(start, path):\n            # Record a copy of the current subset\n            res.append(path[:])\n\n            # Explore further elements to add to the subset\n            for i in range(start, len(nums)):\n                path.append(nums[i])\n                backtrack(i + 1, path)\n                path.pop()  # backtrack\n\n        backtrack(0, [])\n        return res\n\ndef main():\n    # Read the entire input from stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Expect format: \"nums = [1,2,3]\" (possibly with spaces/newlines)\n    # Extract the part after '=' and safely evaluate it\n    try:\n        _, nums_part = data.split('=', 1)\n        nums = ast.literal_eval(nums_part.strip())\n    except Exception:\n        # If parsing fails, treat the whole input as a literal list\n        nums = ast.literal_eval(data)\n\n    # Compute all subsets\n    solution = Solution()\n    result = solution.subsets(nums)\n\n    # Print the result in Python list format\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for generating power set of unique integers. Each line with \"→\" etc. Should produce algorithm like recursive backtracking or iterative bitmask. Provide steps.\n\nLet's produce algorithm: Start, read nums, sort? Not necessary. Use backtracking: function backtrack(index, current_subset). At each index, choose include or exclude. Record subset. At end, return result.\n\nSteps: Start. Initialize result list. Define function. Call function with index 0 and empty subset. End.\n\nWe'll produce lines like:\n\nStart // program start\n→ Step 1: Input array nums // get array\n→ Step 2: Initialize result = [] // storage\n→ Step 3: Define function backtrack(idx, subset) // recursive helper\n    → Decision: idx == len(nums)? // if reached end\n        Yes → Append copy of subset to result // record subset\n        No → \n            → Step 4: Include nums[idx] into subset\n            → Step 5: backtrack(idx+1, subset) // include path\n            → Step 6: Remove last element from subset // backtrack\n            → Step 7: Exclude nums[idx] from subset (no change)\n            → Step 8: backtrack(idx+1, subset) // exclude path\n→ Step 9: Call backtrack(0, []) // start recursion\n→ Step 10: Return result // output subsets\nEnd // program end\n\nNeed to keep format: each line with arrow or Step number. Use \"→\" for step lines, \"Decision:\" for decisions, indent for nested. Provide explanation after //.\n\nMake sure each line has one virtual code step and explanation. Provide \"Yes →\" and \"No →\" within decision.\n\nLet's construct final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Input array nums // 取得唯一元素的整數陣列  \n→ Step 2: Initialize result = [] // 用於存放所有子集  \n→ Step 3: Define function backtrack(idx, subset) // 建立遞迴回溯輔助函式  \n    → Decision: idx == len(nums)? // 判斷是否已遍歷完所有元素  \n        Yes → Append copy of subset to result // 若已到尾，將目前子集加入結果  \n        No  →  \n            → Step 4: Append nums[idx] to subset // 將當前元素納入子集  \n            → Step 5: backtrack(idx + 1, subset) // 進一步遞迴，處理下一個元素  \n            → Step 6: Remove last element from subset // 回溯，移除剛加入的元素  \n            → Step 7: // 不納入 nums[idx] 的情況  \n            → Step 8: backtrack(idx + 1, subset) // 直接遞迴到下一個元素  \n→ Step 9: Call backtrack(0, []) // 從索引 0 開始，初始子集為空  \n→ Step 10: Return result // 回傳所有子集（冪集）  \nEnd // 程式執行結束"
    },
    {
      "title": "Design Twitter",
      "source_file": "Leetcode/leetcode355.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Twitter\", \"postTweet\", \"getNewsFeed\", \"follow\", \"postTweet\", \"getNewsFeed\", \"unfollow\", \"getNewsFeed\"], [[], [1, 5], [1], [1, 2], [2, 6], [1], [1, 2], [1]]",
          "expected_output": "[null, null, [5], null, null, [6, 5], null, [5]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp_cxz_w_l.py\", line 56, in <module>\n    ops = ast.literal_eval(ops_str.strip())\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [\"Twitter\"\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport json\nimport ast\nimport heapq\nfrom collections import defaultdict\n\nclass Twitter:\n    def __init__(self):\n        self.time = 0\n        self.tweets = defaultdict(list)          # userId -> list of (time, tweetId)\n        self.following = defaultdict(set)       # userId -> set of followees\n\n    def postTweet(self, userId: int, tweetId: int) -> None:\n        self.time += 1\n        self.tweets[userId].append((self.time, tweetId))\n        # ensure user follows himself\n        self.following[userId].add(userId)\n\n    def getNewsFeed(self, userId: int):\n        res = []\n        if userId not in self.following:\n            return res\n        heap = []\n        # push the most recent tweet of each followee onto the heap\n        for fid in self.following[userId]:\n            tws = self.tweets.get(fid)\n            if tws:\n                idx = len(tws) - 1\n                ttime, tid = tws[idx]\n                heapq.heappush(heap, (-ttime, tid, fid, idx))\n        # pop up to 10 most recent tweets\n        while heap and len(res) < 10:\n            negtime, tid, fid, idx = heapq.heappop(heap)\n            res.append(tid)\n            if idx - 1 >= 0:\n                ttime, tid_prev = self.tweets[fid][idx - 1]\n                heapq.heappush(heap, (-ttime, tid_prev, fid, idx - 1))\n        return res\n\n    def follow(self, followerId: int, followeeId: int) -> None:\n        self.following[followerId].add(followeeId)\n        # user always follows himself\n        self.following[followerId].add(followerId)\n\n    def unfollow(self, followerId: int, followeeId: int) -> None:\n        if followerId == followeeId:\n            return\n        self.following[followerId].discard(followeeId)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    # The input is two lists: operations and arguments\n    ops_str, args_str = data.split(',', 1)\n    ops = ast.literal_eval(ops_str.strip())\n    args_list = ast.literal_eval(args_str.strip())\n\n    twitter = None\n    outputs = []\n\n    for op, args in zip(ops, args_list):\n        if op == \"Twitter\":\n            twitter = Twitter()\n            outputs.append(None)\n        elif op == \"postTweet\":\n            twitter.postTweet(*args)\n            outputs.append(None)\n        elif op == \"getNewsFeed\":\n            outputs.append(twitter.getNewsFeed(*args))\n        elif op == \"follow\":\n            twitter.follow(*args)\n            outputs.append(None)\n        elif op == \"unfollow\":\n            twitter.unfollow(*args)\n            outputs.append(None)\n        else:\n            # ignore unknown operations\n            outputs.append(None)\n\n    # Convert Python None to JSON null for output\n    print(json.dumps(outputs))",
      "virtual_code": "Thinking...\nWe need to produce a virtual code step by step. The system says not to output actual code but pseudo-code steps. Provide each line with virtual code step + explanation. Use Start, End, Decision: etc. Provide structure. The code will implement Twitter class with the operations. We need to design a simplified version: maintain tweet list with timestamp, follow relationships. For getNewsFeed, we need to gather recent tweets from self and follows, then pick top 10.\n\nWe will produce steps: Start class, initialize data structures. Methods: postTweet, getNewsFeed, follow, unfollow. Provide steps for each method.\n\nWe need to show decision structures: for follow/unfollow check if already following? etc.\n\nUse arrow -> to indicate steps.\n\nLet's outline:\n\nStart // 初始化\n→ Initialize data structures: tweet list mapping userId to list of tweet IDs with timestamps, followees map, global timestamp counter.\n\nImplement postTweet: record tweet with timestamp.\n\nImplement getNewsFeed: gather tweets from self and followees, merge sorted by timestamp, take top 10.\n\nImplement follow: add followee to follower's set.\n\nImplement unfollow: remove followee.\n\nEnd\n\nLet's produce lines. Each line should be a step or a decision or comment. For getNewsFeed, we can pseudo-code merging.\n\nWe need to produce in Chinese: Provide short explanation in Chinese after //.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n\n→ Initialise `timestamp ← 0` // 追蹤全局時間戳，確保每條推文唯一且可排序  \n→ Initialise `tweets ← Map<userId, List<(tweetId, timestamp)>>` // 儲存每個使用者的推文及時間戳  \n→ Initialise `followees ← Map<userId, Set<userId>>` // 儲存每個使用者關注的對象集合  \n\n// ---------- Twitter() ------------\n→ Constructor Twitter()  \n    → // 以上三個資料結構已於 Start 初始化，無需額外處理  \n→ End // Twitter 物件建立完畢  \n\n// ---------- postTweet(userId, tweetId) ------------\n→ Method postTweet(userId, tweetId)  \n    → Increment `timestamp ← timestamp + 1` // 取得新時間戳  \n    → If `userId` not in `tweets`  \n        → `tweets[userId] ← Empty List`  \n    → Append `(tweetId, timestamp)` to `tweets[userId]` // 將新推文加入該使用者的推文列表  \n→ End // 推文已發布  \n\n// ---------- getNewsFeed(userId) ------------\n→ Method getNewsFeed(userId)  \n    → Initialise `candidateList ← Empty List` // 儲存所有候選推文  \n    → // 先將使用者自己的推文加入候選  \n    → If `userId` in `tweets`  \n        → Append all `tweets[userId]` to `candidateList`  \n    → // 將所有關注者的推文加入候選  \n    → If `userId` in `followees`  \n        → For each `followeeId` in `followees[userId]`  \n            → If `followeeId` in `tweets`  \n                → Append all `tweets[followeeId]` to `candidateList`  \n    → // 依時間戳降序排序候選推文  \n    → Sort `candidateList` by `timestamp` descending  \n    → // 取前 10 個推文 ID  \n    → Initialise `feed ← Empty List`  \n    → For i from 0 to min(9, length(candidateList)-1)  \n        → Append `candidateList[i].tweetId` to `feed`  \n    → Return `feed` // 回傳最新 10 條推文 ID  \n→ End // 取得新聞提要  \n\n// ---------- follow(followerId, followeeId) ------------\n→ Method follow(followerId, followeeId)  \n    → If `followerId` not in `followees`  \n        → `followees[followerId] ← Empty Set`  \n    → Add `followeeId` to `followees[followerId]` // 建立關注關係  \n→ End // 追蹤成功  \n\n// ---------- unfollow(followerId, followeeId) ------------\n→ Method unfollow(followerId, followeeId)  \n    → If `followerId` in `followees`  \n        → Remove `followeeId` from `followees[followerId]` // 解除關注關係  \n    → // 若不存在則不執行任何動作  \n→ End // 取消追蹤  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Range Sum Query - Immutable",
      "source_file": "Leetcode/leetcode303.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"NumArray\", \"sumRange\", \"sumRange\", \"sumRange\"], [[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]",
          "expected_output": "[null, 1, -1, -3]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpuy76v3ah.py\", line 50, in <module>\n    main()\n  File \"/tmp/tmpuy76v3ah.py\", line 32, in main\n    args = ast.literal_eval(args_part)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\n\nclass NumArray:\n    \"\"\"\n    使用前綴和 (prefix sum) 來快速回答區間和查詢。\n    \"\"\"\n    def __init__(self, nums):\n        # 建立長度為 len(nums)+1 的前綴和陣列\n        self.prefix_sums = [0]\n        for num in nums:\n            self.prefix_sums.append(self.prefix_sums[-1] + num)\n\n    def sumRange(self, left, right):\n        # 区间和 = 前綴和[right+1] - 前綴和[left]\n        return self.prefix_sums[right + 1] - self.prefix_sums[left]\n\ndef main():\n    # 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n\n    # 依照第一個']'把操作序列與參數序列分開\n    split_idx = raw_input.find('],')\n    ops_part = raw_input[:split_idx + 1]\n    args_part = '[' + raw_input[split_idx + 2:].lstrip()\n\n    # 解析為 Python 物件\n    ops = ast.literal_eval(ops_part)\n    args = ast.literal_eval(args_part)\n\n    results = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"NumArray\":\n            # 初始化物件，arg 是 [nums]\n            obj = NumArray(arg[0])\n            results.append(None)          # 代表 null\n        elif op == \"sumRange\":\n            # 執行查詢\n            res = obj.sumRange(arg[0], arg[1])\n            results.append(res)\n\n    # 輸出結果，使用 json.dumps 以得到正確的 null 表示\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for the NumArray class with sumRange queries, likely using prefix sums. Provide steps. Use virtual code syntax: Start, → Step, Decision: etc. No actual code, just steps. Must handle initialization and sumRange. Probably algorithm: Build prefix sum array during init. sumRange uses prefix sum difference. Provide steps. Let's craft.\n\nWe need multiple queries: each sumRange call. Virtual code could show initialization procedure and query procedure. Could use while loop for queries? But the class design: methods. Provide steps for constructor and method. Provide explanation. Also include condition for queries: left <= right? Not needed in code. Provide Steps.\n\nLet's produce virtual code:\n\nStart\n→ Step 1: 接收 nums 陣列 // 初始化\n→ Step 2: 建立 prefixSum 陣列長度 n+1，prefixSum[0]=0 // 前綴和基底\n→ Decision: 遍歷 nums\n    Yes → Step 3: 計算 prefixSum[i+1] = prefixSum[i] + nums[i] // 填寫前綴和\n    No  → End // 完成前綴和建構\n→ End // 結束初始化\n\nThen sumRange:\n\nStart\n→ Step 1: 取得 left, right 參數 // sumRange 輸入\n→ Decision: 是否 left <= right?\n    Yes → Step 2: 回傳 prefixSum[right+1] - prefixSum[left] // 直接求和\n    No  → Step 3: 回傳 0 或 error // 處理非法輸入\n→ End // sumRange 執行結束\n\nBut maybe they don't require error handling. Provide simple steps.\n\nLet's format accordingly. Use \"→\" and \"Decision:\" lines. Provide each step with explanation after //.\n\nWe must output each line. Provide all steps. Ensure correct order.\n\nLet's craft final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 接收輸入陣列 nums // 初始化物件時取得使用者提供的整數陣列  \n→ Step 2: 建立長度為 nums.length+1 的 prefixSum 陣列並將 prefixSum[0] 設為 0 // 前綴和基底  \n→ Decision: 是否需要遍歷 nums? // 檢查是否還有元素未處理  \n Yes → Step 3: 以 i 從 0 開始遍歷 nums  \n  → Step 4: 計算 prefixSum[i+1] = prefixSum[i] + nums[i] // 填寫前綴和  \n  → Decision: 是否已遍歷完所有元素?  \n   Yes → End // 前綴和建構完成  \n   No  → Step 3 (回到迴圈)  \n No  → End // 沒有元素，直接結束初始化  \nEnd // 初始化結束  \n\nStart // sumRange 方法開始執行  \n→ Step 1: 取得 left 與 right 參數 // sumRange 輸入  \n→ Decision: left 是否小於等於 right? // 驗證參數合法性  \n Yes → Step 2: 回傳 prefixSum[right+1] - prefixSum[left] // 直接以前綴和求區間和  \n No  → Step 3: 回傳 0 或拋出錯誤 // 處理非法輸入（可選）  \nEnd // sumRange 方法結束執行"
    },
    {
      "title": "LFU Cache",
      "source_file": "Leetcode/leetcode460.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"LFUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"get\", \"put\", \"get\", \"get\", \"get\"], [[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]",
          "expected_output": "[null, null, null, 1, null, -1, 3, null, -1, 3, 4]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp6z8xpcy1.py\", line 62, in <module>\n    args = ast.literal_eval(args_part)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [ [[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport json\nimport ast\nfrom collections import defaultdict, OrderedDict\n\nclass LFUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.min_freq = 0\n        self.key_to_val_freq = {}                     # key -> (value, freq)\n        self.freq_to_keys = defaultdict(OrderedDict)   # freq -> OrderedDict of keys\n\n    def _update(self, key: int) -> None:\n        \"\"\"Increase frequency of a key and move it to the appropriate bucket.\"\"\"\n        value, freq = self.key_to_val_freq[key]\n        # Remove key from old frequency bucket\n        del self.freq_to_keys[freq][key]\n        if not self.freq_to_keys[freq]:\n            del self.freq_to_keys[freq]\n            if self.min_freq == freq:\n                self.min_freq += 1\n        # Insert key into new frequency bucket\n        self.freq_to_keys[freq + 1][key] = None\n        self.key_to_val_freq[key] = (value, freq + 1)\n\n    def get(self, key: int) -> int:\n        \"\"\"Return value of key if present, else -1. Update frequency.\"\"\"\n        if key not in self.key_to_val_freq:\n            return -1\n        self._update(key)\n        return self.key_to_val_freq[key][0]\n\n    def put(self, key: int, value: int) -> None:\n        \"\"\"Insert or update key with value. Evict if necessary.\"\"\"\n        if self.capacity == 0:\n            return\n        if key in self.key_to_val_freq:\n            # Update value and frequency\n            self.key_to_val_freq[key] = (value, self.key_to_val_freq[key][1])\n            self._update(key)\n            return\n        # Evict least frequently used key if at capacity\n        if len(self.key_to_val_freq) >= self.capacity:\n            evict_key, _ = self.freq_to_keys[self.min_freq].popitem(last=False)\n            del self.key_to_val_freq[evict_key]\n            if not self.freq_to_keys[self.min_freq]:\n                del self.freq_to_keys[self.min_freq]\n        # Insert new key with frequency 1\n        self.key_to_val_freq[key] = (value, 1)\n        self.freq_to_keys[1][key] = None\n        self.min_freq = 1\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    # Separate the two lists: operations and arguments\n    parts = data.split('],', 1)\n    ops_part = parts[0] + ']'\n    args_part = '[' + parts[1]\n    ops = ast.literal_eval(ops_part)\n    args = ast.literal_eval(args_part)\n\n    results = []\n    cache = None\n    for op, arg in zip(ops, args):\n        if op == \"LFUCache\":\n            cache = LFUCache(arg[0])\n            results.append(None)\n        elif op == \"get\":\n            results.append(cache.get(arg[0]))\n        elif op == \"put\":\n            cache.put(arg[0], arg[1])\n            results.append(None)\n    # Output results in JSON format (None -> null)\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to output step-by-step pseudocode with explanations. The code should design data structure with O(1). Use doubly linked lists for frequencies, map from key to node, map freq to linked list. Need to keep minFreq.\n\nWe need to provide step-by-step process for get and put.\n\nWe'll produce lines like:\n\nStart\n→ Step 1: Initialize maps and minFreq // etc\n\nBut we need to include algorithm for initialization, get, put. Provide each line with explanation. The pseudocode lines should represent algorithm logic.\n\nProbably we need to show high-level structure: class LFUCache with constructor, get, put. Provide each step inside methods. Use arrows to show flow.\n\nOk produce pseudocode lines accordingly. Ensure each line ends with // explanation.\n\nLet's craft.\n\nWe'll show:\n\nStart\n→ Step 1: Define class LFUCache // class definition\n→ Step 2: Define constructor with capacity // etc\n→ Step 3: Initialize capacity, minFreq, keyNode map, freqList map // etc\n\nThen for get:\n\n→ Step 4: If key not in keyNode map → return -1 // etc\n\n→ Step 5: node := keyNode[key] // retrieve node\n→ Step 6: Increment node.freq\n→ Step 7: Remove node from old freq list\n→ Step 8: If old freq list empty and minFreq == old freq → minFreq++\n→ Step 9: Add node to freqList[new freq]\n→ Step 10: Return node.value\n\nFor put:\n\n→ Step 11: If capacity == 0 → return\n→ Step 12: If key exists → update value, then perform get-like freq update\n→ Step 13: Else if cache size == capacity → evict least freq LRU\n→ Step 14: Create new node with freq 1\n→ Step 15: Insert into keyNode, freqList[1], set minFreq=1\n\nAlso need evict:\n\n→ Step 16: list := freqList[minFreq]\n→ Step 17: nodeToRemove := list.tail.prev (LRU)\n→ Step 18: Remove nodeToRemove from list and keyNode map\n\nOk.\n\nWe should use virtual arrows to indicate decisions.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 LFUCache 類別 // 建立類別框架  \n→ Step 2: 在類別中宣告成員變數：  \n  capacity // 緩存容量  \n  minFreq // 最小頻率  \n  keyNode // Map<key, Node> 存儲鍵對應的節點  \n  freqList // Map<freq, DoubleLinkedList> 存儲同一頻率的節點列表  \n→ Step 3: 建構子 LFUCache(int capacity)  \n  設定 this.capacity = capacity  \n  初始化 this.minFreq = 0  \n  初始化 this.keyNode 為空 HashMap  \n  初始化 this.freqList 為空 HashMap  \nEnd // 初始化完成  \n\nStart // get 方法開始  \n→ Step 4: get(int key)  \n  Decision: 若 key 不在 keyNode? // 檢查鍵是否存在  \n   Yes → Return -1 // 缓存未命中，返回 -1  \n   No →  \n    Node node = keyNode.get(key) // 取得節點  \n    int oldFreq = node.freq  \n    node.freq += 1 // 頻率遞增  \n    Remove node 從 freqList[oldFreq] // 移除舊頻率列表  \n    Decision: 若 freqList[oldFreq] 為空且 oldFreq == minFreq? // 最小頻率列表被清空  \n     Yes → minFreq += 1 // 更新最小頻率  \n     No →  \n    Add node 到 freqList[node.freq] // 加入新頻率列表  \n    Return node.value // 返回對應值  \nEnd // get 方法結束  \n\nStart // put 方法開始  \n→ Step 5: put(int key, int value)  \n  Decision: 若 capacity == 0? // 緩存無容量  \n   Yes → Return // 不做任何操作  \n   No →  \n   Decision: 若 key 已存在於 keyNode? // 更新操作  \n    Yes → Node node = keyNode.get(key)  \n     node.value = value // 更新值  \n     // 重新計算頻率（同 get）  \n     int oldFreq = node.freq  \n     node.freq += 1  \n     Remove node 從 freqList[oldFreq]  \n     Decision: 若 freqList[oldFreq] 為空且 oldFreq == minFreq?  \n      Yes → minFreq += 1  \n      No →  \n     Add node 到 freqList[node.freq]  \n     Return  \n    No → // 插入新鍵  \n     Decision: 若 keyNode.size() == capacity? // 是否需要淘汰  \n      Yes → // 淘汰最少頻率最舊的節點  \n       List list = freqList.get(minFreq) // 取得最小頻率列表  \n       Node nodeToRemove = list.tail.prev // LRU 節點  \n       Remove nodeToRemove 從 list  \n       keyNode.remove(nodeToRemove.key) // 從 keyNode 刪除  \n       如果 list 變為空 → delete freqList[minFreq]  \n      No →  \n     // 插入新節點  \n     Node newNode = new Node(key, value, freq=1)  \n     keyNode.put(key, newNode)  \n     if freqList.containsKey(1) → freqList[1].add(newNode)  \n     else → freqList[1] = new DoubleLinkedList(); freqList[1].add(newNode)  \n     minFreq = 1 // 新鍵頻率為 1，重置 minFreq  \nEnd // put 方法結束\n\nEnd // 程式執行結束"
    },
    {
      "title": "Different Ways to Add Parentheses",
      "source_file": "Leetcode/leetcode241.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "expression = \"2-1-1\"",
          "expected_output": "[0,2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[0,2]'\nGot (Norm):      '[2,0]'\n--- (Raw) ---\nRaw Expected: '[0,2]'\nRaw Got:      '[2, 0]'"
        },
        {
          "example_index": 1,
          "input": "expression = \"2*3-4*5\"",
          "expected_output": "[-34,-14,-10,-10,10]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[-34,-14,-10,-10,10]'\nGot (Norm):      '[-34,-10,-14,-10,10]'\n--- (Raw) ---\nRaw Expected: '[-34,-14,-10,-10,10]'\nRaw Got:      '[-34, -10, -14, -10, 10]'"
        }
      ],
      "generated_code": "import sys\n\ndef diffWaysToCompute(expression: str):\n    memo = {}\n    def ways(expr: str):\n        if expr in memo:\n            return memo[expr]\n        res = []\n        for i, ch in enumerate(expr):\n            if ch in '+-*':\n                left = ways(expr[:i])\n                right = ways(expr[i+1:])\n                for l in left:\n                    for r in right:\n                        if ch == '+':\n                            res.append(l + r)\n                        elif ch == '-':\n                            res.append(l - r)\n                        else:\n                            res.append(l * r)\n        if not res:\n            res.append(int(expr))\n        memo[expr] = res\n        return res\n    return ways(expression)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    # Extract expression between quotes, if present\n    start = data.find('\"')\n    end = data.rfind('\"')\n    if start != -1 and end != -1 and end > start:\n        expr = data[start + 1:end]\n    else:\n        expr = data  # fallback if no quotes\n    result = diffWaysToCompute(expr)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for solving \"Different Ways to Add Parentheses\" problem. We output step-by-step pseudocode lines with explanation.\n\nWe must follow format: each line: \"虛擬碼步驟 // 解釋/說明\". Use arrow etc. Let's produce. Ensure Start, End, Decision, Step etc.\n\nWe need to produce logic: parse string, recursion with memoization.\n\nLet's outline lines:\n\nStart // start\n→ Step 1: Define function diffWays(expression) // main function\n→ Step 2: If expression contains no operator return [int(expression)] // base case\n→ Decision: If result cached? // memoization\n    Yes → Step 3: Return cached result // reuse\n    No  → Step 4: Initialize results list\n→ Step 5: For each index i in expression\n→ Decision: If expression[i] is operator? // process splits\n    Yes → Step 6: left = diffWays(substring before i)\n    → Step 7: right = diffWays(substring after i)\n    → Step 8: For each l in left\n        → Step 9: For each r in right\n            → Step 10: Compute l op r\n            → Step 11: Append to results\n    No  → continue\n→ Step 12: Cache results for expression\n→ Step 13: Return results\nEnd\n\nBut we need \"逐行\" output with each line. Also include arrow lines for decision.\n\nWe need to use \"Yes →\", \"No →\".\n\nAlso include indentation maybe not required but we can show sub lines with indentation or just sequential lines.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: Define function diffWays(expression) // 定義遞迴求不同結果的函式\n→ Decision: expression 是否為純數字? // 檢查是否已無運算子\n    Yes → Step 2: Return [int(expression)] // 若為純數字，直接回傳其整數值\n    No  → Step 3: Check cache for expression // 查看是否已計算過\n        Yes → Step 4: Return cached result // 若有，直接回傳快取結果\n        No  → Step 5: Initialize results = [] // 初始化結果清單\n→ Step 6: For i from 0 to len(expression)-1\n→ Decision: expression[i] 是否為運算子 (+,-,*)? // 判斷是否是分割點\n    Yes → Step 7: left_expr = expression[0:i] // 左子表達式\n    → Step 8: right_expr = expression[i+1:] // 右子表達式\n    → Step 9: left_results = diffWays(left_expr) // 取得左側所有結果\n    → Step 10: right_results = diffWays(right_expr) // 取得右側所有結果\n    → Decision: 有多少左結果? // 進一步迴圈\n        Yes → Step 11: For each l in left_results\n            → Decision: 有多少右結果? // 迴圈右結果\n                Yes → Step 12: For each r in right_results\n                    → Step 13: op = expression[i] // 取得運算子\n                    → Step 14: value = compute(l, op, r) // 計算 l op r\n                    → Step 15: Append value to results // 加入結果\n                No  → Step 16: // 無右結果，跳過\n        No  → Step 17: // 無左結果，跳過\n    No  → Step 18: // expression[i] 不是運算子，繼續下一個索引\n→ Step 19: Cache[expression] = results // 存入快取\n→ Step 20: Return results // 回傳所有可能結果\nEnd // 程式執行結束\n\nBut we need \"Yes →\" \"No →\" lines. Should we use arrow lines for decisions? We can do indentation but we can just put them line by line. Maybe it's acceptable.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義函式 diffWays(expression) // 建立遞迴計算不同結果的主函式  \n→ Decision: expression 是否為純數字? // 判斷是否已無運算子  \n Yes → Step 2: Return [int(expression)] // 若為純數字，直接回傳其整數值  \n No → Step 3: 若結果已存在於快取表中? // 檢查是否已計算過此子表達式  \n  Yes → Step 4: Return cache[expression] // 若已快取，直接回傳結果  \n  No → Step 5: results ← [] // 初始化結果清單  \n→ Step 6: 逐個索引 i 迭代 expression  \n→ Decision: expression[i] 是否為運算子 (+, -, *)? // 判斷是否為分割點  \n Yes → Step 7: left_expr ← expression[0:i] // 取左子表達式  \n  → Step 8: right_expr ← expression[i+1:] // 取右子表達式  \n  → Step 9: left_results ← diffWays(left_expr) // 取得左側所有可能結果  \n  → Step 10: right_results ← diffWays(right_expr) // 取得右側所有可能結果  \n  → Decision: left_results 是否為空? // 進一步迴圈左結果  \n   Yes → Step 11: // 若左結果為空，跳過此分割點  \n   No → Step 12: 逐個 l 在 left_results  \n    → Decision: right_results 是否為空? // 迴圈右結果  \n     Yes → Step 13: // 若右結果為空，跳過此分割點  \n     No → Step 14: 逐個 r 在 right_results  \n      → Step 15: op ← expression[i] // 取得運算子  \n      → Step 16: value ← compute(l, op, r) // 計算 l op r  \n      → Step 17: Append value 到 results // 加入此組合結果  \n  No → Step 18: // expression[i] 不是運算子，繼續下一個索引  \n→ Step 19: cache[expression] ← results // 將計算結果存入快取  \n→ Step 20: Return results // 回傳所有可能的計算結果  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick with Weight",
      "source_file": "Leetcode/leetcode528.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"], [[[1,3]],[],[],[],[],[]]",
          "expected_output": "[null,1,1,1,1,0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,1,1,1,1,0]'\nGot (Norm):      '[null,1,1,1,1,1]'\n--- (Raw) ---\nRaw Expected: '[null,1,1,1,1,0]'\nRaw Got:      '[null, 1, 1, 1, 1, 1]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport bisect\n\nclass Solution:\n    def __init__(self, w):\n        \"\"\"初始化前綴和與總重\"\"\"\n        self.prefix_sum = []\n        total = 0\n        for weight in w:\n            total += weight\n            self.prefix_sum.append(total)\n        self.total = total\n\n    def pickIndex(self):\n        \"\"\"隨機選擇一個索引，概率與權重成正比\"\"\"\n        target = random.randint(1, self.total)\n        return bisect.bisect_left(self.prefix_sum, target)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 將輸入包裝成外層列表，方便 json 解析\n    json_str = \"[\" + data + \"]\"\n    try:\n        methods, args_list = json.loads(json_str)\n    except json.JSONDecodeError as e:\n        print(\"Invalid input format\", file=sys.stderr)\n        sys.exit(1)\n\n    results = []\n    solution = None\n\n    for method, args in zip(methods, args_list):\n        if method == \"Solution\":\n            # 建構子只接受一個參數：權重列表\n            solution = Solution(args[0])\n            results.append(None)  # LeetCode 風格的 null\n        elif method == \"pickIndex\":\n            if solution is None:\n                results.append(None)\n            else:\n                results.append(solution.pickIndex())\n        else:\n            # 如有其他方法，直接記錄 None\n            results.append(None)\n\n    # 輸出結果，以 JSON 格式表示\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce virtual code for implementing weighted random index selection. Steps: Precompute prefix sums, generate random number between 1 and total sum, binary search to find first prefix sum >= random. Provide each line as described. Use arrows, decisions.\n\nWe need no actual code, just steps. Format: \"虛擬碼步驟 // 解釋\".\n\nWe'll include Start, End, Steps, Decision etc.\n\nLet's design:\n\nStart\n→ Step 1: 接收 w // array of weights\n→ Step 2: 計算總和 total = sum(w) // sum of weights\n→ Step 3: 建立前綴和 prefix[0] = w[0]; for i from 1 to n-1: prefix[i] = prefix[i-1] + w[i] // prefix sums\n→ Step 4: 函數 pickIndex() // define function\n   → Step 4.1: 產生隨機整數 r 在 [1, total] // inclusive\n   → Step 4.2: 二分搜尋 prefix，找到最小 i 使 prefix[i] >= r // binary search\n   → Step 4.3: 回傳 i // 返回索引\n→ End\n\nNeed decision? We could add decision if r <= prefix[i]? but binary search covers. Use decision: while low<high etc.\n\nLet's produce each line with explanation.\n\nEnsure each line has arrow or prefix and comment.\n\nLet's output.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 接收 w // 取得權重陣列  \n→ Step 2: 計算總和 total ← sum(w) // 計算所有權重之和  \n→ Step 3: 建立前綴和 prefix[0] ← w[0] // 初始化前綴和  \n→ Step 3.1: 對於 i 從 1 到 w.length-1 做 // 迭代填充前綴和  \n    → Step 3.1.1: prefix[i] ← prefix[i-1] + w[i] // 累加得到前綴和  \n→ Step 4: 定義函式 pickIndex() // 建立隨機挑選函式  \n    → Step 4.1: 產生隨機整數 r ∈ [1, total] // 產生隨機數  \n    → Step 4.2: 設定 low ← 0, high ← prefix.length-1 // 初始化二分搜尋範圍  \n    → Step 4.3: Decision: low < high? // 是否需要繼續搜尋  \n        Yes → Step 4.3.1: mid ← floor((low+high)/2) // 計算中點  \n            → Decision: prefix[mid] < r? // 中點前綴和是否小於 r  \n                Yes → Step 4.3.1.1: low ← mid + 1 // r 在右半邊  \n                No  → Step 4.3.1.2: high ← mid // r 在左半邊或等於 mid  \n        No  → Step 4.4: idx ← low // 找到最小符合條件的索引  \n    → Step 4.5: 回傳 idx // 返回選中的索引  \nEnd // 程式執行結束"
    }
  ]
}