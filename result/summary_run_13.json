{
  "run_index": 13,
  "total_files_found": 391,
  "total_files_processed": 323,
  "files_skipped": 68,
  "files_failed_load": 0,
  "---": "--- (以下基於 *題目* 總數) ---",
  "total_problems_attempted": 334,
  "generation_and_validation_success_count": 297,
  "generation_or_validation_failure_count": 37,
  "failed_cases_details": [
    {
      "title": "統計文字行數",
      "source_file": "900.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "（假設 data.txt 內容如下）\\nHello\\nPython\\nWorld",
          "expected_output": "檔案共有 3 行",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '檔案共有3行'\nGot (Norm):      '檔案共有1行'\n--- (Raw) ---\nRaw Expected: '檔案共有 3 行'\nRaw Got:      '檔案共有 1 行'"
        }
      ],
      "generated_code": "import sys\n\ndef main() -> None:\n    # 讀取所有標準輸入（雖然對此題不影響，但依照需求必須讀取）\n    sys.stdin.read()\n\n    # 讀取 data.txt 的行數\n    try:\n        with open('data.txt', 'r', encoding='utf-8') as f:\n            lines = f.readlines()\n        print(f'檔案共有 {len(lines)} 行')\n    except FileNotFoundError:\n        print('找不到檔案！')\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output step-by-step virtual code with explanation per line. Must use Start, End, Decision, with arrow. Use with, try/except. For file reading. Use line count. The code must be structured. Each line: 虛擬碼步驟 + space + // explanation. Must not output actual code. So we need to use pseudo steps. Eg:\n\nStart // 程式開始執行\n→ Step 1: 初始化行計數器為 0 // 計算行數\n→ Decision: 試圖以 with 開啟 data.txt 進行讀取 // 嘗試打開檔案\n   Yes → Step 2: 以 for 迴圈逐行讀取文件 // 逐行遍歷\n       → Step 3: 行計數器加 1 // 計數\n   No → Step 4: 輸出 '找不到檔案！' // 當檔案不存在時顯示錯誤\n→ Step 5: 輸出 '總行數: X' // 顯示計算結果\nEnd // 程式結束\n\nBut need to show try/except. So Decision: try? Actually we can express try/except as Decision: 如果成功? or using Decision: 是否成功開啟? That might reflect try/except. Let's design:\n\nStart // ...\n→ Step 1: 設置行計數器為 0 // 初始化\n→ Decision: 進入 try 區塊開啟檔案 // 嘗試\n    Yes → Step 2: 使用 with 語法開啟 'data.txt' 為 file // 打開檔案\n        → Step 3: 以 for 迴圈逐行讀取 file\n            → Step 4: 行計數器 += 1 // 計數\n        → Step 5: 輸出 '總行數: 行計數器' // 顯示結果\n    No → Step 6: 輸出 '找不到檔案！' // 當發生異常時\n\nEnd\n\nBut we need to show exception handling. Use Decision: 如果 try 成功? No -> except.\n\nBetter:\n\nStart // 程式開始執行\n→ Step 1: 設置行計數器為 0 // 初始化行數\n→ Decision: 進入 try 區塊 // 嘗試打開檔案\n    Yes → Step 2: with open('data.txt', 'r') as file // 使用 with 開啟\n        → Step 3: for each line in file\n            → Step 4: 行計數器 += 1 // 計算行數\n        → Step 5: 輸出 '總行數: 行計數器' // 顯示結果\n    No  → Step 6: 輸出 '找不到檔案！' // 在 except 中處理\nEnd\n\nBut the Decision: \"進入 try 區塊\" is not clear. We can treat try/except as:\n\nDecision: 嘗試打開檔案是否成功? // 檢查是否發生例外\n\nYes → Step 2: with open(... ) as file // 打開\n    ... \nNo → Step 6: 輸出 '找不到檔案！'\n\nWe need to mention try/except explicitly: Step 2 could include \"try:\" and Step 6 \"except FileNotFoundError:\". But we can describe in explanation.\n\nLet's produce lines accordingly:\n\nStart // 程式開始執行\n→ Step 1: 初始化行計數器為 0 // 設定計數變數\n→ Decision: 嘗試打開檔案是否成功? // 檢查是否發生 FileNotFoundError\n    Yes → Step 2: with open('data.txt', 'r') as file // 使用 with 開啟檔案\n        → Step 3: for 每行 in file\n            → Step 4: 行計數器 += 1 // 逐行計數\n        → Step 5: 輸出 '總行數: 行計數器' // 顯示總行數\n    No  → Step 6: 輸出 '找不到檔案！' // 顯示錯誤訊息\nEnd // 程式結束\n\nWe also should show \"try:\" and \"except\" conceptually. Maybe add \"Step 2a: try:\" preceding? We can represent with nested decision:\n\nStart\n→ Step 1: 行計數器 = 0\n→ Decision: 嘗試打開檔案? // 進入 try\n    Yes → Step 2: with open('data.txt', 'r') as file\n        → Step 3: for line in file\n            → Step 4: 行計數器 += 1\n        → Step 5: 輸出 行計數器\n    No  → Step 6: 輸出 '找不到檔案！'\n\nBut we need to use try/except structure: maybe include a step indicating \"try:\" and \"except:\".\n\nLet's design:\n\nStart // 程式開始\n→ Step 1: 設置行計數器 = 0 // 初始化計數\n→ Decision: 進入 try 區塊? // 嘗試打開檔案\n    Yes → Step 2: try: // 開始嘗試\n        → Step 3: with open('data.txt', 'r') as file // 打開\n            → Step 4: for line in file\n                → Step 5: 行計數器 += 1 // 計數\n        → Step 6: 輸出 '總行數: 行計數器' // 成功結束\n    No  → Step 7: except FileNotFoundError: // 檔案不存在\n        → Step 8: 輸出 '找不到檔案！' // 顯示錯誤\nEnd\n\nBut each line must be one step; we can use indentation.\n\nWe need to ensure arrow direction: \"→\" after each step. Decision: uses Yes →, No →. Use arrow for steps after decisions.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設置行計數器為 0 // 初始化行數變數  \n→ Decision: 進入 try 區塊? // 嘗試打開檔案  \n  Yes → Step 2: try: // 開始嘗試  \n   → Step 3: with open('data.txt', 'r') as file // 使用 with 開啟檔案  \n    → Step 4: for 每行 in file  \n     → Step 5: 行計數器 += 1 // 逐行計數  \n    → Step 6: 輸出 '總行數: 行計數器' // 成功結束後顯示結果  \n  No → Step 7: except FileNotFoundError: // 檔案不存在時執行  \n   → Step 8: 輸出 '找不到檔案！' // 顯示錯誤訊息  \nEnd // 程式執行結束"
    },
    {
      "title": "模擬擲骰子遊戲",
      "source_file": "800.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "print(roll_dice(5))",
          "expected_output": "[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,6,1,4,2]#(結果會隨機，每次可能不同)'\nGot (Norm):      '[6,4,4,2,2]'\n--- (Raw) ---\nRaw Expected: '[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)'\nRaw Got:      '[6, 4, 4, 2, 2]'"
        }
      ],
      "generated_code": "import random\nimport sys\n\ndef roll_dice(n):\n    \"\"\"模擬擲 n 次六面骰，回傳所有結果的串列。\"\"\"\n    results = []\n    for _ in range(n):\n        results.append(random.randint(1, 6))\n    return results\n\ndef main():\n    \"\"\"從 stdin 讀取程式碼並執行，允許使用 roll_dice 函式。\"\"\"\n    # 讀取全部輸入\n    code = sys.stdin.read()\n    if not code.strip():\n        return\n    # 在全域命名空間中執行輸入的程式碼\n    exec(code, globals())\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps with explanations. Each line must contain the step followed by comment. Use Start, End, Decision: etc. We need to include random module, define function roll_dice(n). Simulate n rolls, store results in list, return list. Also maybe check n>0? Not necessary but could include decision. Use decision if n <= 0? Maybe not. Just simple loop.\n\nSo output format: each line \"虛擬碼步驟 // 解釋/說明\"\n\nLet's craft:\n\nStart // 程式開始\n→ Import random module // 載入 random\n→ Function: roll_dice(n) // 定義函式\n    → Step 1: results = [] // 建立空串列存放結果\n    → Step 2: For i in range(n): // 重複 n 次\n        → Step 3: roll = random.randint(1, 6) // 擲骰子得到 1-6\n        → Step 4: results.append(roll) // 加入結果\n    → Step 5: Return results // 回傳結果串列\nEnd // 程式結束\n\nAdd explanation after each.\n\nMake sure to use arrow syntax and indent decision? No decision needed.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Import random // 引入 random 模組以使用隨機數產生\n→ Function: roll_dice(n) // 定義函式 roll_dice，參數為擲骰次數 n\n    → Step 1: results = [] // 初始化空串列，用於儲存每一次擲骰的結果\n    → Step 2: For i in range(n): // 迴圈，從 0 到 n-1，執行 n 次\n        → Step 3: roll = random.randint(1, 6) // 產生 1 到 6 的隨機整數，模擬一次六面骰擲點\n        → Step 4: results.append(roll) // 將本次擲骰結果加入 results 串列\n    → Step 5: Return results // 回傳整個結果串列給呼叫者\nEnd // 程式執行結束"
    },
    {
      "title": "計算程式執行時間",
      "source_file": "800.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "import time\n\ndef slow_add(a, b):\n    time.sleep(2)\n    return a + b\n\nprint(measure_time(slow_add, 3, 5))",
          "expected_output": "約 2.0 秒 (依電腦執行環境略有差異)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '約2.0秒(依電腦執行環境略有差異)'\nGot (Norm):      '2.0'\n--- (Raw) ---\nRaw Expected: '約 2.0 秒 (依電腦執行環境略有差異)'\nRaw Got:      '2.0'"
        }
      ],
      "generated_code": "import sys\nimport time\n\ndef measure_time(func, *args):\n    \"\"\"\n    測量 func(*args) 的執行時間（秒），並四捨五入到小數點 3 位。\n    \"\"\"\n    start = time.time()\n    func(*args)\n    end = time.time()\n    return round(end - start, 3)\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取完整的程式碼（包含測試範例）\n    script = sys.stdin.read()\n    # 只提供 measure_time 這個全域，其他全域使用預設（含 builtins）\n    exec(script, {\"measure_time\": measure_time})",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines following the specified format. Steps: Start, then import time, define function, start timer, call function, end timer, compute duration, round to 3 decimals, return result. Use Decision? No decision needed. Provide comments. Use virtual arrow and indent. Ensure each line has format: \"虛擬碼步驟 // 解釋/說明\". Use arrow \"→\". We'll include \"Start\" and \"End\". Use maybe \"Step 1:\" etc. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 導入 time 模組 // 引入計時功能  \n→ Step 2: 定義函式 measure_time(func, *args) // 建立測時主函式  \n→ Step 3: 設定 start_time = time.time() // 記錄執行前時間  \n→ Step 4: 執行 func(*args) 並存儲結果為 result // 呼叫目標函式並取得返回值  \n→ Step 5: 設定 end_time = time.time() // 記錄執行後時間  \n→ Step 6: 計算 duration = end_time - start_time // 取得執行所用秒數  \n→ Step 7: 取四捨五入後的 duration_round = round(duration, 3) // 四捨五入到小數點三位  \n→ Step 8: 回傳 duration_round // 傳回經四捨五入的秒數  \nEnd // 程式執行結束"
    },
    {
      "title": "集合函數練習",
      "source_file": "600.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "{'apple', 'orange', 'grape', 'melon'}",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '{\"apple\",\"orange\",\"grape\",\"melon\"}'\nGot (Norm):      '{\"grape\",\"melon\",\"apple\",\"orange\"}'\n--- (Raw) ---\nRaw Expected: \"{'apple', 'orange', 'grape', 'melon'}\"\nRaw Got:      \"{'grape', 'melon', 'apple', 'orange'}\""
        }
      ],
      "generated_code": "import sys\n\ndef main():\n    # 讀取所有輸入（如果無輸入則為空字串，這裡不做進一步處理）\n    _ = sys.stdin.read()\n\n    # 初始化集合並執行要求的操作\n    fruits = {'apple', 'banana'}\n    fruits.add('orange')\n    fruits.update(['grape', 'melon'])\n    fruits.remove('banana')\n    fruits.discard('pineapple')\n\n    # 輸出最終集合\n    print(fruits)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce step-by-step virtual code. Each line: \"虛擬碼步驟 // 解釋\". Use arrows, Start, End, Decision. For this scenario, we just create set, add, update, remove, discard, print. No decision needed except maybe for discard? but we can just show attempt.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: fruits ← {'apple', 'banana'} // 初始化集合\n→ Step 2: fruits.add('orange') // 新增 'orange'\n→ Step 3: fruits.update({'grape', 'melon'}) // 一次新增 'grape' 與 'melon'\n→ Step 4: fruits.remove('banana') // 移除 'banana'\n→ Step 5: fruits.discard('pineapple') // 嘗試移除不存在的 'pineapple'\n→ Step 6: Output fruits // 顯示最終集合\nEnd // 程式執行結束\n\nBut we should use arrow \"→\" and maybe indentation not needed. Provide each line.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: fruits ← {'apple', 'banana'} // 初始化集合  \n→ Step 2: fruits.add('orange') // 新增 'orange'  \n→ Step 3: fruits.update({'grape', 'melon'}) // 一次新增 'grape' 與 'melon'  \n→ Step 4: fruits.remove('banana') // 移除 'banana'  \n→ Step 5: fruits.discard('pineapple') // 嘗試移除不存在的 'pineapple'  \n→ Step 6: Output fruits // 顯示最終集合  \nEnd // 程式執行結束"
    },
    {
      "title": "即時匯率查詢小工具",
      "source_file": "1200.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "按下「更新匯率」按鈕",
          "expected_output": "目前美元匯率：約 32.5 TWD",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '目前美元匯率：約32.5TWD'\nGot (Norm):      '目前美元匯率：約30.82TWD'\n--- (Raw) ---\nRaw Expected: '目前美元匯率：約 32.5 TWD'\nRaw Got:      '目前美元匯率：約 30.82 TWD'"
        }
      ],
      "generated_code": "import requests\nimport sys\n\ndef get_rate() -> float | None:\n    \"\"\"\n    取得美元兌台幣的匯率\n    若成功則回傳浮點數，失敗時回傳 None\n    \"\"\"\n    url = \"https://api.exchangerate-api.com/v4/latest/USD\"\n    try:\n        resp = requests.get(url, timeout=5)\n        resp.raise_for_status()\n        data = resp.json()\n        return float(data[\"rates\"][\"TWD\"])\n    except Exception:\n        return None\n\n\ndef run_gui() -> None:\n    \"\"\"\n    啟動 tkinter GUI\n    \"\"\"\n    import tkinter as tk\n\n    win = tk.Tk()\n    win.title(\"匯率查詢\")\n\n    label = tk.Label(win, text=\"請按下按鈕更新匯率\", font=(\"Arial\", 12))\n    label.pack(pady=10)\n\n    def update() -> None:\n        rate = get_rate()\n        if rate is None:\n            label.config(text=\"更新失敗，請檢查網路連線\")\n        else:\n            label.config(text=f\"目前美元匯率：約 {rate} TWD\")\n\n    tk.Button(win, text=\"更新匯率\", command=update).pack(pady=5)\n    win.mainloop()\n\n\ndef main() -> None:\n    \"\"\"\n    主流程：讀取標準輸入，無論內容為何，皆取得匯率並輸出\n    \"\"\"\n    # 讀取整個 stdin（內容不影響結果，只是為符合需求）\n    sys.stdin.read()\n\n    rate = get_rate()\n    if rate is None:\n        print(\"取得匯率失敗，請檢查網路連線\")\n    else:\n        print(f\"目前美元匯率：約 {rate} TWD\")\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines in Taiwanese Traditional Chinese. Each line: virtual code step + space + // explanation. Use arrow markers. We'll need steps: import, create window, fetch function, button, label, event loop.\n\nLet's craft: \nStart \n→ Step 1: import requests, tkinter\n→ Step 2: define fetch_rate() // call API\n→ Step 3: parse JSON, get TWD rate\n→ Step 4: update label text\n→ Step 5: create root window\n→ Step 6: create label placeholder\n→ Step 7: create button bound to fetch_rate\n→ Step 8: call fetch_rate initially\n→ Step 9: root.mainloop\nEnd.\n\nAdd decision? maybe not.\n\nWe also need to show arrow notation. Use \"→\" before each step. For label updates, maybe decision not needed.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: import requests, tkinter // 載入網路請求與 GUI 模組  \n→ Step 2: define fetch_rate() // 定義取得匯率的函式  \n→ Decision: 在 fetch_rate() 中是否成功取得資料?  \n    Yes → Step 3: data = requests.get('https://api.exchangerate-api.com/v4/latest/USD') // 送出 GET 請求  \n    Yes → Step 4: json_data = data.json() // 解析 JSON  \n    Yes → Step 5: rate_twd = json_data['rates']['TWD'] // 取得台幣匯率  \n    Yes → Step 6: label.config(text=f'USD → TWD: {rate_twd}') // 更新標籤文字  \n    No → Step 7: label.config(text='取得匯率失敗') // 顯示錯誤訊息  \n→ Step 8: root = tkinter.Tk() // 建立主視窗  \n→ Step 9: root.title('美元兌台幣匯率') // 設定視窗標題  \n→ Step 10: label = tkinter.Label(root, text='點擊按鈕取得匯率', font=('Arial', 14)) // 建立顯示匯率的標籤  \n→ Step 11: label.pack(pady=20) // 放置標籤並留白  \n→ Step 12: button = tkinter.Button(root, text='更新匯率', command=fetch_rate) // 建立更新按鈕並連結函式  \n→ Step 13: button.pack(pady=10) // 放置按鈕並留白  \n→ Step 14: fetch_rate() // 程式啟動即先取得一次匯率  \n→ Step 15: root.mainloop() // 啟動 GUI 事件迴圈  \nEnd // 程式執行結束"
    },
    {
      "title": "Insert Delete GetRandom O(1)",
      "source_file": "Leetcode/leetcode380.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedSet\", \"insert\", \"remove\", \"insert\", \"getRandom\", \"remove\", \"insert\", \"getRandom\"], [[], [1], [2], [2], [], [1], [2], []]",
          "expected_output": "[null, true, false, true, 2, true, false, 2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp70flq5j6.py\", line 52, in <module>\n    args = ast.literal_eval(lines[1])\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\nimport json\n\nclass RandomizedSet:\n    def __init__(self):\n        self.val_to_index = {}\n        self.values = []\n\n    def insert(self, val):\n        if val in self.val_to_index:\n            return False\n        self.values.append(val)\n        self.val_to_index[val] = len(self.values) - 1\n        return True\n\n    def remove(self, val):\n        if val not in self.val_to_index:\n            return False\n        idx = self.val_to_index[val]\n        last_val = self.values[-1]\n        self.values[idx] = last_val\n        self.val_to_index[last_val] = idx\n        self.values.pop()\n        del self.val_to_index[val]\n        return True\n\n    def getRandom(self):\n        return random.choice(self.values)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 將兩個列表之間插入換行，方便後續分割\n    if '], [' in data:\n        data = data.replace('], [', ']\\n[')\n    lines = [line.strip() for line in data.splitlines() if line.strip()]\n\n    # 若仍只有一行，嘗試用逗號分割\n    if len(lines) < 2:\n        parts = data.split('], [', 1)\n        if len(parts) == 2:\n            lines = [f\"[{parts[0]}]\", f\"[{parts[1]}]\"]\n        else:\n            parts = data.split(',', 1)\n            lines = [parts[0], parts[1] if len(parts) > 1 else '[]']\n\n    ops = ast.literal_eval(lines[0])\n    args = ast.literal_eval(lines[1])\n\n    rs = RandomizedSet()\n    results = []\n\n    for op, arg in zip(ops, args):\n        if op == 'RandomizedSet':\n            results.append(None)\n        elif op == 'insert':\n            results.append(rs.insert(arg[0]))\n        elif op == 'remove':\n            results.append(rs.remove(arg[0]))\n        elif op == 'getRandom':\n            results.append(rs.getRandom())\n        else:\n            results.append(None)\n\n    # 使用 json.dumps 以得到符合題目輸出格式的字串\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce virtual code, line by line, with explanations, for the RandomizedSet class implementation with O(1) average for insert, remove, getRandom. Use virtual code with arrows and decisions. Should outline structure: use hash map val->index and array list. Insert: if exists return false else push to list, record index, return true. Remove: if not exist false else swap with last, update map, pop last, delete from map, return true. getRandom: random index from list, return element.\n\nWe must not output actual code. Use pseudo steps.\n\nWe need to include Start and End.\n\nUse virtual steps like: Start, → Step: initialize data structures, etc. Decision: if val in map? etc.\n\nInclude explanation in Chinese.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空的 hash map `indexMap` 用於儲存元素與其在陣列中的索引 // 方便 O(1) 位置查找  \n→ Step 2: 建立空的動態陣列 `elements` 用於儲存所有元素 // 方便 O(1) 隨機存取  \n→ Step 3: 定義 `insert(val)` 方法 // 進入插入流程  \n    → Decision: 如果 `val` 在 `indexMap` 中? // 檢查是否已存在  \n        Yes → Step 4a: 回傳 false // 已存在，插入失敗  \n        No  → Step 4b: 將 `val` 加入 `elements` 的末尾 // 添加元素  \n              → Step 4c: 在 `indexMap` 中紀錄 `val` 的索引為 `elements` 長度 - 1 // 更新映射  \n              → Step 4d: 回傳 true // 插入成功  \n→ Step 5: 定義 `remove(val)` 方法 // 進入刪除流程  \n    → Decision: 如果 `val` 不在 `indexMap` 中? // 檢查是否存在  \n        Yes → Step 6a: 回傳 false // 沒有此元素，刪除失敗  \n        No  → Step 6b: 取得 `val` 在 `elements` 的索引 `idx` // 紀錄位置  \n              → Step 6c: 取得陣列最後一個元素 `lastVal` // 準備交換  \n              → Step 6d: 把 `lastVal` 放到 `idx` 位置 // 覆蓋要刪除的位置  \n              → Step 6e: 更新 `indexMap[lastVal] = idx` // 更新映射  \n              → Step 6f: 從 `elements` 刪除最後一個元素 // 真正移除  \n              → Step 6g: 從 `indexMap` 刪除 `val` 的鍵值對 // 清除映射  \n              → Step 6h: 回傳 true // 刪除成功  \n→ Step 7: 定義 `getRandom()` 方法 // 取得隨機元素  \n    → Step 8: 生成一個隨機索引 `randIdx` 在 [0, elements.length - 1] 之間 // 隨機位置  \n    → Step 9: 回傳 `elements[randIdx]` // 同機率返回元素  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Flip Matrix",
      "source_file": "Leetcode/leetcode519.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"flip\", \"flip\", \"flip\", \"reset\", \"flip\"], [[3, 1], [], [], [], [], []]",
          "expected_output": "[null, [1,0], [2,0], [0,0], null, [2,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[1,0],[2,0],[0,0],null,[2,0]]'\nGot (Norm):      '[null,[0,0],[1,0],[2,0],null,[1,0]]'\n--- (Raw) ---\nRaw Expected: '[null, [1,0], [2,0], [0,0], null, [2,0]]'\nRaw Got:      '[null, [0, 0], [1, 0], [2, 0], null, [1, 0]]'"
        }
      ],
      "generated_code": "import sys\nimport random\nimport ast\nimport json\n\nclass Solution:\n    \"\"\"\n    以一維映射表（hash map）維持剩餘可翻轉的位置。\n    - self.total：目前還未被翻轉的位置數量。\n    - self.mapping：映射表用來「懶惰」交換隨機索引與最後可用索引。\n    \"\"\"\n    def __init__(self, m: int, n: int):\n        self.m = m\n        self.n = n\n        self.total = m * n\n        self.mapping = {}\n\n    def flip(self):\n        # 隨機挑選一個仍為 0 的位置\n        r = random.randint(0, self.total - 1)\n        # 若此位置已經被映射，取映射後的實際索引；否則直接使用 r\n        x = self.mapping.get(r, r)\n        # 將選中的索引從可用集合中移除\n        self.total -= 1\n        # 把最後一個未翻轉的位置映射到 r，確保後續 r 的值不會再次被選中\n        self.mapping[r] = self.mapping.get(self.total, self.total)\n        # 將扁平化索引轉回 (i, j)\n        return [x // self.n, x % self.n]\n\n    def reset(self):\n        # 重新將所有位置設回 0\n        self.total = self.m * self.n\n        self.mapping.clear()\n\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入，並移除前後空白與換行\n    data = sys.stdin.read().strip()\n\n    # 若輸入為空則直接結束\n    if not data:\n        sys.exit(0)\n\n    # 將輸入分成兩部分：操作序列與對應參數\n    # 假設格式為：<ops_list>, <args_list>\n    idx = data.find('],')\n    if idx == -1:\n        raise ValueError(\"Input format error\")\n    ops_str = data[:idx + 1]          # 取到第 1 個 ']' 為止\n    args_str = data[idx + 2:].strip()  # 跳過 '],'\n\n    # 解析為 Python 物件\n    ops = ast.literal_eval(ops_str)\n    args = ast.literal_eval(args_str)\n\n    result = []\n    obj = None\n\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            obj = Solution(arg[0], arg[1])\n            result.append(None)\n        elif op == \"flip\":\n            result.append(obj.flip())\n        elif op == \"reset\":\n            obj.reset()\n            result.append(None)\n        else:\n            raise ValueError(f\"Unknown operation: {op}\")\n\n    # 使用 json.dumps 讓 None 轉成 null，符合題目輸出格式\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to output virtual code lines with explanations. Provide algorithm: maintain list of available positions (flattened indices). Initially list = [0,1,...,m*n-1]. For flip: pick random index r from 0 to len-1, return mapping to 2D. Swap chosen index with last available and pop. For reset: refill list. Complexity: O(1) avg.\n\nWe must use virtual code with arrows and decision. Provide steps for initialization, flip, reset. Provide pseudocode.\n\nLet's write lines:\n\nStart\n\n→ Step 1: Initialize m, n, total = m*n // store dimensions\n\n→ Step 2: Create array available of size total, fill with indices 0..total-1 // list of available spots\n\n→ Step 3: Set count = total // number of unflipped positions\n\n→ Decision: flip() called? // when flip method invoked\n\n   Yes → Step 4: Generate random int r between 0 and count-1 // choose random available\n\n   → Step 5: pos = available[r] // pick index\n\n   → Step 6: Swap available[r] with available[count-1] // move chosen to end\n\n   → Step 7: count = count-1 // reduce available\n\n   → Step 8: Convert pos to (i, j): i = pos / n, j = pos % n // mapping\n\n   → Step 9: Return [i, j] // output\n\n   No → Decision: reset() called? // when reset invoked\n\n      Yes → Step 10: Reinitialize available with 0..total-1 // refill list\n\n      → Step 11: count = total // reset count\n\n      No → End\n\nAlso handle edge: if count==0, maybe raise error.\n\nInclude explanation comments.\n\nNeed to ensure format: each line as `虛擬碼步驟 // 解釋`. Use `→` arrow lines.\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: Initialize m, n, total ← m × n // 取得矩陣尺寸與總格數\n→ Step 2: Create array available[0 … total-1] // 儲存所有尚未翻轉的格子索引\n→ Step 3: Set count ← total // 未翻轉格子數量\n→ Decision: flip() called? // 檢查是否執行 flip\n    Yes → Step 4: r ← randomInt(0, count-1) // 產生 0 ~ count-1 的隨機整數\n    → Step 5: pos ← available[r] // 取得對應的扁平化索引\n    → Step 6: Swap available[r] with available[count-1] // 將選中索引移到末尾\n    → Step 7: count ← count-1 // 減少未翻轉格子數\n    → Step 8: i ← pos / n // 轉換為行號\n    → Step 9: j ← pos % n // 轉換為列號\n    → Step 10: Return [i, j] // 回傳隨機位置並已將其標記為 1\n    No → Decision: reset() called? // 檢查是否執行 reset\n        Yes → Step 11: Reinitialize available with 0 … total-1 // 重新填滿所有格子\n        → Step 12: count ← total // 重置未翻轉格子數\n        No → End // 程式執行結束\n```"
    },
    {
      "title": "Create Maximum Number",
      "source_file": "Leetcode/leetcode321.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums1 = [3,4,6,5], nums2 = [9,1,2,5,8,3], k = 5",
          "expected_output": "[9,8,6,5,3]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpgt8n_v02.py\", line 53, in <module>\n    exec(exec_code, {}, local_vars)\n  File \"<string>\", line 1\n    nums1 = [3\n             ^\nSyntaxError: invalid syntax. Perhaps you forgot a comma?"
        },
        {
          "example_index": 1,
          "input": "nums1 = [6,7], nums2 = [6,0,4], k = 5",
          "expected_output": "[6,7,6,0,4]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpq1_l3jmv.py\", line 53, in <module>\n    exec(exec_code, {}, local_vars)\n  File \"<string>\", line 1\n    nums1 = [6\n             ^\nSyntaxError: invalid syntax. Perhaps you forgot a comma?"
        },
        {
          "example_index": 2,
          "input": "nums1 = [3,9], nums2 = [8,9], k = 3",
          "expected_output": "[9,8,9]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpb_4yjnkj.py\", line 53, in <module>\n    exec(exec_code, {}, local_vars)\n  File \"<string>\", line 1\n    nums1 = [3\n             ^\nSyntaxError: invalid syntax. Perhaps you forgot a comma?"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def maxNumber(self, nums1, nums2, k):\n        # 取得長度 t 的最大子序列\n        def pick_max(nums, t):\n            drop = len(nums) - t  # 可以刪除的數量\n            stack = []\n            for num in nums:\n                # 若前一個數字較小且還有刪除餘量，則刪除\n                while drop and stack and stack[-1] < num:\n                    stack.pop()\n                    drop -= 1\n                stack.append(num)\n            # 只取前 t 個\n            return stack[:t]\n\n        # 合併兩個子序列，得到字典序最大的序列\n        def merge(a, b):\n            res = []\n            i = j = 0\n            while i < len(a) or j < len(b):\n                # 如果 a 後面剩下的序列大於 b 則從 a 選取\n                if i < len(a) and (j == len(b) or a[i:] > b[j:]):\n                    res.append(a[i])\n                    i += 1\n                else:\n                    res.append(b[j])\n                    j += 1\n            return res\n\n        best = []\n        # nums1 至多取 i 個，取值範圍為 max(0, k - len(nums2)) 到 min(k, len(nums1))\n        min_i = max(0, k - len(nums2))\n        max_i = min(k, len(nums1))\n        for i in range(min_i, max_i + 1):\n            a = pick_max(nums1, i)\n            b = pick_max(nums2, k - i)\n            candidate = merge(a[:], b[:])  # 需要複製，避免被修改\n            if candidate > best:\n                best = candidate\n        return best\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入並轉成可執行的程式碼\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 將逗號換成換行，使之成為合法的 python 指令\n    exec_code = data.replace(',', '\\n')\n    local_vars = {}\n    exec(exec_code, {}, local_vars)\n\n    nums1 = local_vars.get('nums1', [])\n    nums2 = local_vars.get('nums2', [])\n    k = local_vars.get('k', 0)\n\n    sol = Solution()\n    result = sol.maxNumber(nums1, nums2, k)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to generate pseudocode steps for algorithm to create maximum number of length k from two arrays preserving relative order. This is classic Leetcode 321: Create Maximum Number. Approach: For each split i from max(0,k-n) to min(k,m), take i digits from nums1 and k-i from nums2. For each, select maximum subsequence of given length from each array (using stack). Then merge two subsequences to form maximum number (lexicographically compare). Keep max. So pseudocode steps.\n\nWe need to output line by line with comments. Use arrows and decisions. Must not output actual code, only structure.\n\nWe can create high-level steps: Start, define helper functions: MaxSubsequence(array, length), Merge(seq1, seq2). Then loop over split range. Compute sub1, sub2. Merge. Compare with best. At end, return best. Provide explanation after each line. Use arrow symbol.\n\nWe need to be careful to use the specified format: each line \"虛擬碼步驟 // 解釋\". Use arrow \"→\". For decisions use \"Decision:\". Indentation.\n\nLet's produce pseudocode:\n\nStart // 開始執行\n→ Step 1: 定義函式 MaxSubsequence(nums, t) // 選取長度 t 的最大子序列\n→ Decision: 若 t <= 0? // 檢查 t 是否有效\n    Yes → Return 空序列 // t 為 0 時返回空\n    No → 進入函式內部\n→ Step 2: 初始化空堆疊 stack // 用於構造最大子序列\n→ Step 3: 計算刪除數 drop = len(nums) - t // 可刪除的元素數\n→ Step 4: 逐個遍歷 nums 中的數字 val\n    → Decision: 若 stack 不空 且 top < val 且 drop > 0? // 可以刪除較小前項\n        Yes → pop top; drop-- // 刪除\n        No → continue\n    → Step 5: push val 到 stack\n→ Step 6: 若 stack 長度 > t, 截斷為 t // 只取前 t 個\n→ Step 7: Return stack // 返回最大子序列\nEnd // MaxSubsequence 定義結束\n\nSimilar for Merge:\n\nStart // Merge 函式開始\n→ Step 1: 初始化空結果 merged\n→ Step 2: 當 seq1 或 seq2 非空\n    → Decision: seq1 先於 seq2? // 判斷哪個子序列更大\n        Yes → pop seq1 首位並加入 merged\n        No  → pop seq2 首位並加入 merged\n→ Step 3: 返回 merged // 合併結果\nEnd // Merge 函式結束\n\nMain algorithm:\n\nStart // 主程式開始\n→ Step 1: 設定 best = 空陣列 // 儲存最佳答案\n→ Step 2: 計算 min1 = max(0, k - len(nums2)) // nums1 最少取的數量\n→ Step 3: 計算 max1 = min(k, len(nums1)) // nums1 最多取的數量\n→ Step 4: 循環 i 從 min1 到 max1\n    → Step 5: sub1 = MaxSubsequence(nums1, i) // 從 nums1 取 i 個\n    → Step 6: sub2 = MaxSubsequence(nums2, k - i) // 從 nums2 取 k-i 個\n    → Step 7: candidate = Merge(sub1, sub2) // 合併兩個子序列\n    → Decision: candidate > best? // 以字典序比較\n        Yes → best = candidate // 更新最佳\n        No  → 不更新\n→ Step 8: Return best // 結果\nEnd // 主程式結束\n\nNeed to incorporate arrow \"→\" lines with indentations.\n\nMake sure each line ends with // explanation. Also decisions lines with \"Decision:\" maybe use \"Decision:\".\n\nWe need to use \"Yes →\" \"No →\" within decisions. Indentation is indicated by tabs or spaces. Provide consistent formatting.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義函式 MaxSubsequence(nums, t) // 用來選取長度 t 的最大子序列  \n→ Decision: 若 t <= 0? // 檢查 t 是否有效  \n  Yes → Return 空序列 // t 為 0 時直接返回空陣列  \n  No → 進入函式內部  \n→ Step 2: 初始化空堆疊 stack // 用於構造子序列  \n→ Step 3: 計算可刪除數 drop = len(nums) - t // 這麼多元素可以被刪除  \n→ Step 4: 逐個遍歷 nums 中的數字 val  \n  → Decision: 若 stack 不空 且 stack.top < val 且 drop > 0? // 是否能刪除較小前項  \n   Yes → pop stack.top; drop-- // 刪除並減少可刪除數  \n   No  → 直接執行下一步  \n  → Step 5: push val 到 stack // 將當前數字加入堆疊  \n→ Step 6: 若 stack 長度 > t, 截斷為前 t 個元素 // 保留最大子序列  \n→ Step 7: Return stack // 返回最大子序列  \nEnd // MaxSubsequence 函式結束  \n\nStart // Merge 函式開始  \n→ Step 1: 初始化空結果 merged // 用於存放合併後的序列  \n→ Step 2: 當 seq1 或 seq2 非空  \n  → Decision: seq1 > seq2? // 判斷哪個子序列更大（字典序比較）  \n   Yes → pop seq1 首位並加入 merged // 選取 seq1 的頭  \n   No  → pop seq2 首位並加入 merged // 選取 seq2 的頭  \n→ Step 3: Return merged // 合併完成後返回結果  \nEnd // Merge 函式結束  \n\nStart // 主程式開始  \n→ Step 1: 設定 best = 空陣列 // 儲存目前最佳答案  \n→ Step 2: 計算 min1 = max(0, k - len(nums2)) // nums1 最少取的數量  \n→ Step 3: 計算 max1 = min(k, len(nums1)) // nums1 最多取的數量  \n→ Step 4: 循環 i 從 min1 到 max1  \n  → Step 5: sub1 = MaxSubsequence(nums1, i) // 從 nums1 取 i 個數字  \n  → Step 6: sub2 = MaxSubsequence(nums2, k - i) // 從 nums2 取 k-i 個數字  \n  → Step 7: candidate = Merge(sub1, sub2) // 合併兩個子序列  \n  → Decision: candidate > best? // 以字典序比較兩個序列  \n   Yes → best = candidate // 如果更大則更新最佳答案  \n   No  → 不更新 // 保持現有最佳答案  \n→ Step 8: Return best // 最終返回最大長度為 k 的數字序列  \nEnd // 主程式結束"
    },
    {
      "title": "Random Pick Index",
      "source_file": "Leetcode/leetcode398.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\"], [[[1, 2, 3, 3, 3]], [3], [1], [3]]",
          "expected_output": "[null, 4, 0, 2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,4,0,2]'\nGot (Norm):      '[null,3,0,3]'\n--- (Raw) ---\nRaw Expected: '[null, 4, 0, 2]'\nRaw Got:      '[null, 3, 0, 3]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nfrom collections import defaultdict\n\nclass Solution:\n    \"\"\"\n    Solution class for picking random indices of a target value.\n    \"\"\"\n    def __init__(self, nums):\n        # 建立目標值到所有索引的映射\n        self.num_indices = defaultdict(list)\n        for i, num in enumerate(nums):\n            self.num_indices[num].append(i)\n\n    def pick(self, target):\n        \"\"\"\n        隨機返回 nums 中等於 target 的索引。\n        \"\"\"\n        return random.choice(self.num_indices[target])\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n\n    # 將輸入包成 JSON array 方便解析\n    # 原始格式如 '[\"Solution\", \"pick\", ...], [[[1,2,3]], [3], ...]'\n    # 轉成 '[[\"Solution\", \"pick\", ...], [[[1,2,3]], [3], ...]]'\n    data = json.loads('[' + raw_input + ']')\n    commands, arguments = data[0], data[1]\n\n    outputs = []\n    obj = None\n\n    for cmd, args in zip(commands, arguments):\n        if cmd == \"Solution\":\n            # 參數 args 是一個列表，例如 [[1,2,3,3,3]]\n            obj = Solution(*args)\n            outputs.append(None)  # constructor 沒有返回值，使用 null\n        elif cmd == \"pick\":\n            result = obj.pick(*args)  # args 也是列表，例如 [3]\n            outputs.append(result)\n\n    # 輸出結果列表，使用 JSON 格式可自動將 None 轉為 null\n    print(json.dumps(outputs))",
      "virtual_code": "Thinking...\nWe need to produce pseudo code steps, line by line, with explanations. It's essentially random sampling with reservoir or maintain list of indices? Problem: pick should be random among indices with given target. Approach: in constructor, build map target->list of indices. Or better, store indices. Then pick: return random from list. Let's produce pseudo code. Use Start, End, Decision. Provide lines.\n\nLet's craft:\n\nStart\n→ Step 1: 初始化空字典 map // 建立映射\n→ Step 2: 循環遍歷 nums 的每個元素及其索引 // 收集索引\n    → Step 2.1: 若 map 沒有 key nums[i] 則新增空列表\n    → Step 2.2: 將索引 i 加入 map[nums[i]]\n→ End // 建構完成\n\npick(target)\n→ Step 1: 取得 indicesList = map[target] // 目標對應索引\n→ Step 2: 生成隨機整數 r 在 0 到 len(indicesList)-1 之間\n→ Step 3: 回傳 indicesList[r] // 隨機選取\n\nNeed to present as pseudo code lines. Each line with explanation. Use arrow etc. Should show method boundaries. We'll produce separate blocks for constructor and pick. Also indicate Start/End. Let's produce.\n\n...done thinking.\n\nStart // 程式執行開始\n→ Step 1: 建立空字典 map // 用於儲存每個目標數值對應的索引清單\n→ Step 2: For 每個元素 nums[i] 以及其索引 i // 遍歷整個陣列\n    → Decision: 如果 map 沒有 key nums[i]?\n        Yes → Step 3: map[nums[i]] ← 空清單 // 新增此數值的索引清單\n        No  → Step 3: 直接跳過 // 索引清單已存在\n    → Step 4: map[nums[i]] ← map[nums[i]] ∪ {i} // 將索引加入對應清單\n→ End // 建構完畢，資料結構已準備好\n\nFunction pick(target) // 隨機挑選目標的索引\n→ Step 1: indicesList ← map[target] // 取得所有等於 target 的索引\n→ Step 2: n ← length(indicesList) // 取得索引數量\n→ Step 3: r ← 隨機整數 0 到 n-1 // 隨機產生位置\n→ Step 4: return indicesList[r] // 隨機返回一個索引\nEnd // 程式結束"
    },
    {
      "title": "Sort Characters By Frequency",
      "source_file": "Leetcode/leetcode451.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"tree\"",
          "expected_output": "\"eert\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'eert'\nGot (Norm):      'eetr'\n--- (Raw) ---\nRaw Expected: '\"eert\"'\nRaw Got:      'eetr'"
        },
        {
          "example_index": 1,
          "input": "s = \"cccaaa\"",
          "expected_output": "\"aaaccc\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'aaaccc'\nGot (Norm):      'cccaaa'\n--- (Raw) ---\nRaw Expected: '\"aaaccc\"'\nRaw Got:      'cccaaa'"
        }
      ],
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\ndef frequency_sort(s: str) -> str:\n    \"\"\"\n    Sort the characters of `s` in decreasing order of their frequency.\n    \"\"\"\n    if not s:\n        return \"\"\n    # Count occurrences of each character\n    freq = Counter(s)\n    # Sort by frequency descending (ties can be in any order)\n    sorted_items = sorted(freq.items(), key=lambda x: -x[1])\n    # Build result string\n    return \"\".join(char * cnt for char, cnt in sorted_items)\n\ndef read_input() -> str:\n    \"\"\"\n    Read the entire stdin and extract the string value.\n    Handles inputs like:\n        s = \"tree\"\n    or just:\n        tree\n    \"\"\"\n    raw = sys.stdin.read()\n    if not raw:\n        return \"\"\n    # Try to find a quoted substring\n    match = re.search(r'[\"\\']([^\"\\']*)[\"\\']', raw)\n    if match:\n        return match.group(1)\n    # If no quotes, strip any 's = ' prefix and whitespace\n    cleaned = raw.strip()\n    if cleaned.lower().startswith(\"s =\"):\n        cleaned = cleaned[3:].strip()\n    # Remove surrounding quotes if any\n    if (cleaned.startswith('\"') and cleaned.endswith('\"')) or \\\n       (cleaned.startswith(\"'\") and cleaned.endswith(\"'\")):\n        cleaned = cleaned[1:-1]\n    return cleaned\n\nif __name__ == \"__main__\":\n    input_str = read_input()\n    result = frequency_sort(input_str)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. Use Start, Decision, etc. Steps: Count frequency, sort characters by freq descending, build output string. Use loops, data structures. Provide explanation. Let's produce each line. Use arrow '→'. Let's start.\n\nWe'll produce lines:\n\nStart\n→ Step 1: Initialize frequency map\n→ Step 2: For each character in s, increment count\n→ Step 3: Convert frequency map entries to list of (char, freq)\n→ Decision: If list empty? no\n→ Step 4: Sort list by freq descending\n→ Step 5: Initialize result string builder\n→ For each (char, freq) in sorted list:\n    → Append char repeated freq times to result\n→ End\n\nWe need to add comments after space.\n\nLet's produce each line with explanation. Provide arrow, step name. Ensure each line includes explanation comment. Also ensure indentation for Decision branches. In our case, no branches. But we can keep Decision but optional. Maybe we skip Decision. But guidelines say use Decision if needed. We can include a Decision to check if s is empty. Provide branch: if empty -> return empty.\n\nLet's do:\n\nStart\n→ Step 1: Initialize an empty map `freqMap` // 建立頻率表\n→ Step 2: 遍歷字串 `s`，對每個字元 `c`，若在 `freqMap` 中則頻率+1，否則新增為1 // 計算每個字元出現次數\n→ Decision: s 為空? // 若輸入字串為空\n    Yes → Step 3: Return 空字串 // 直接回傳\n    No  → Step 4: 將 `freqMap` 轉成列表 `entries`，格式為 (字元, 頻率) // 準備排序\n→ Step 5: 對 `entries` 按頻率降序排序 // 依照頻率從大到小排列\n→ Step 6: 初始化空字串 `result` // 用於組合結果\n→ Step 7: 對於每個 `(c, f)` 在 `entries`:\n    → Step 8: 將 `c` 重複 `f` 次後連接到 `result` // 把字元按照頻率添加\n→ End\n\nNeed to format each line properly with '→'. Indent for nested. Provide explanation. Ensure each line ends with comment.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Initialize an empty map `freqMap` // 建立字元頻率表  \n→ Step 2: For each character `c` in string `s`, increment `freqMap[c]` by 1 or set to 1 if absent // 逐一計算每個字元的出現次數  \n→ Decision: s 為空? // 判斷輸入字串是否為空  \n Yes → Step 3: Return empty string // 若為空，直接回傳空字串  \n No  → Step 4: Convert `freqMap` into list `entries` of (char, freq) pairs // 準備進行排序  \n→ Step 5: Sort `entries` by frequency in descending order // 依頻率從高到低排列  \n→ Step 6: Initialize empty string `result` // 用於組合最終結果  \n→ Step 7: For each (c, f) in sorted `entries`  \n  → Step 8: Append `c` repeated `f` times to `result` // 按頻率將字元加入結果  \nEnd // 程式執行結束"
    },
    {
      "title": "Permutations",
      "source_file": "Leetcode/leetcode46.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nGot (Norm):      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nRaw Got:      '[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 2, 1], [3, 1, 2]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def permute(self, nums):\n        \"\"\"\n        生成 nums 的所有排列\n        \"\"\"\n        res = []\n\n        def backtrack(start):\n            if start == len(nums):\n                res.append(nums[:])  # 加入當前排列的拷貝\n                return\n            for i in range(start, len(nums)):\n                nums[start], nums[i] = nums[i], nums[start]  # 交換\n                backtrack(start + 1)\n                nums[start], nums[i] = nums[i], nums[start]  # 回溯\n\n        backtrack(0)\n        return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 從輸入中提取 list\n    idx = data.find('[')\n    if idx == -1:\n        nums = []\n    else:\n        nums_str = data[idx:]\n        nums = ast.literal_eval(nums_str)  # 安全解析\n    solution = Solution()\n    result = solution.permute(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode for generating all permutations of an array of distinct integers, returning them in any order. Use the format: line per step with arrow, comment explanation. Include Start, End, Decision etc. Provide virtual code steps. Should be step-by-step algorithm, perhaps backtracking. Must not output actual code. Just structured steps. Each line: \"虛擬碼步驟 // 解釋\".\n\nWe need to include steps like:\n\nStart\n→ Step 1: Initialize result list // ...\n→ Step 2: Define recursive function permute(current, remaining)\n    → Decision: If remaining empty? // base case\n        Yes → Step 3: Append copy of current to result // ...\n        No → Step 4: For each index i in remaining\n            → Step 5: Swap current[i] with current[last]? Actually typical: iterate over remaining, pick element, push onto current, recurse with remaining minus element, then backtrack.\nBut we need pseudocode with simple constructs.\n\nSimplify: Use list of numbers. Represent current permutation as a list.\n\nMaybe use backtracking: function backtrack(path, unused). path is current permutation. unused is list of remaining numbers.\n\nPseudo:\n\nStart\n→ Step 1: Create empty list result\n→ Step 2: Call backtrack(empty path, nums)\n→ End\n\nInside backtrack:\n→ Decision: if path length equals nums length?\n    Yes → Step: Append copy of path to result\n    No → Step: For each number in unused\n        → Step: Add number to path\n        → Step: Remove number from unused\n        → Step: Call backtrack(path, unused)\n        → Step: Add number back to unused (backtrack)\n        → Step: Remove number from path\n\nBut we need line-by-line steps. Use arrows and indentation? The example uses arrows and indenting with indentation. Use arrow for decision branches: Yes →, No →.\n\nWe must write each line. Use \"→\" at start of each step. For decisions, use \"Decision:\" and indent branches.\n\nLet's construct:\n\nStart // 程式開始執行\n→ Step 1: 初始化 result 為空列表 // 用於存放所有排列\n→ Step 2: 定義遞迴函式 backtrack(path, remaining) // path: 當前排列, remaining: 尚未使用的數字\n    → Decision: 如果 remaining 為空? // 判斷是否已排列完畢\n        Yes → Step 3: 將 path 的拷貝加入 result // 存入一個完整排列\n        No  → Step 4: 循環遍歷 remaining 中的每個數字 i\n            → Step 5: 將 i 加入 path // 將數字放入當前排列\n            → Step 6: 從 remaining 移除 i // 標記為已使用\n            → Step 7: 調用 backtrack(path, remaining) // 繼續構造排列\n            → Step 8: 將 i 從 path 移除 // 回溯，撤回選擇\n            → Step 9: 將 i 加回 remaining // 恢復未使用列表\n→ Step 10: 呼叫 backtrack(empty, nums) // 開始遞迴\n→ Step 11: 返回 result // 所有排列完成\n\nBut need each line as separate. Use indentation to show nested steps. The example uses indentation by spaces. We can indent with four spaces or tabs.\n\nAlso we should not include actual code syntax like brackets. But we can use pseudo language.\n\nWe need each line like \"→ Step X: ...\" after each comment. Indentation for inner steps maybe use spaces. Use \"→\" for each step.\n\nMake sure to use Chinese explanation.\n\nLet's write the lines:\n\nStart // 程式開始執行\n→ Step 1: 初始化 result 為空列表 // 用來存儲所有排列結果\n→ Step 2: 定義遞迴函式 backtrack(path, remaining) // path: 目前排列, remaining: 未使用的數字\n    → Decision: 若 remaining 為空? // 檢查是否已完成排列\n        Yes → Step 3: 把 path 的複製加入 result // 完成一個排列，存入結果\n        No  → Step 4: 遍歷 remaining 中的每個元素 num\n            → Step 5: 把 num 加入 path // 選擇 num 作為下一個位置\n            → Step 6: 從 remaining 刪除 num // 標記 num 為已使用\n            → Step 7: 呼叫 backtrack(path, remaining) // 繼續遞迴\n            → Step 8: 把 num 從 path 移除 // 回溯，撤銷選擇\n            → Step 9: 把 num 加回 remaining // 恢復未使用列表\n→ Step 10: 呼叫 backtrack([], nums) // 以空排列和所有數字開始遞迴\n→ Step 11: 回傳 result // 所有排列已完成\n\nCheck: Each line has \"→\" or \"Decision:\" with branches. Indentation. Provide explanation after //.\n\nMake sure no code, only pseudocode.\n\nLet's output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 result 為空列表 // 用來存儲所有排列結果  \n→ Step 2: 定義遞迴函式 backtrack(path, remaining) // path: 目前排列, remaining: 未使用的數字  \n  → Decision: 若 remaining 為空? // 檢查是否已完成排列  \n   Yes → Step 3: 把 path 的複製加入 result // 完成一個排列，存入結果  \n   No  → Step 4: 遍歷 remaining 中的每個元素 num  \n    → Step 5: 把 num 加入 path // 選擇 num 作為下一個位置  \n    → Step 6: 從 remaining 刪除 num // 標記 num 為已使用  \n    → Step 7: 呼叫 backtrack(path, remaining) // 繼續遞迴  \n    → Step 8: 把 num 從 path 移除 // 回溯，撤銷選擇  \n    → Step 9: 把 num 加回 remaining // 恢復未使用列表  \n→ Step 10: 呼叫 backtrack([], nums) // 以空排列和所有數字開始遞迴  \n→ Step 11: 回傳 result // 所有排列已完成"
    },
    {
      "title": "Find the Duplicate Number",
      "source_file": "Leetcode/leetcode287.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "nums = [3,1,3,4,2]",
          "expected_output": "O3",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'O3'\nGot (Norm):      '3'\n--- (Raw) ---\nRaw Expected: 'O3'\nRaw Got:      '3'"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def findDuplicate(self, nums):\n        \"\"\"\n        Use Floyd's Tortoise and Hare algorithm to find the duplicate number.\n        Time Complexity: O(n)\n        Space Complexity: O(1) (constant extra space)\n        \"\"\"\n        # Phase 1: Find intersection point in the cycle\n        slow = fast = nums[0]\n        while True:\n            slow = nums[slow]\n            fast = nums[nums[fast]]\n            if slow == fast:\n                break\n\n        # Phase 2: Find the entrance to the cycle (duplicate number)\n        slow = nums[0]\n        while slow != fast:\n            slow = nums[slow]\n            fast = nums[fast]\n\n        return slow\n\n\ndef parse_input(data: str):\n    \"\"\"\n    Extract the list of integers from the input string.\n    Expected format: something like 'nums = [1,2,3,3]' (spaces are optional).\n    \"\"\"\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1 or start >= end:\n        raise ValueError(\"Invalid input format: list not found.\")\n    list_str = data[start:end + 1]\n    try:\n        nums = eval(list_str, {}, {})\n    except Exception as e:\n        raise ValueError(f\"Unable to parse list: {e}\")\n    if not isinstance(nums, list):\n        raise ValueError(\"Parsed value is not a list.\")\n    return nums\n\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n    try:\n        nums = parse_input(raw_input)\n    except ValueError as e:\n        print(f\"Error: {e}\")\n        sys.exit(1)\n\n    solution = Solution()\n    duplicate = solution.findDuplicate(nums)\n    print(duplicate)",
      "virtual_code": "Thinking...\nWe need to produce pseudocode for solving this classic problem: find duplicate in array without modifying array, constant extra space, but can use Floyd's Tortoise and Hare (cycle detection). So produce step-by-step pseudocode. Use Start, End, Decision. Provide explanation after each line.\n\nWe need to follow output format. Each line: \"虛擬碼步驟 [space] // 解釋\". Use arrow →.\n\nWe should cover initialization of slow, fast, etc. Decision to detect cycle.\n\nPseudo:\n\nStart // begin\n→ Step 1: 初始化 slow = nums[0], fast = nums[nums[0]] // start pointers\n→ Decision: while slow != fast? // find meeting point\n    Yes → Step 2: slow = nums[slow] // move slow one step\n           → Step 3: fast = nums[nums[fast]] // move fast two steps\n        No  → // pointers met, exit loop\n→ Step 4: 重置 slow = nums[0] // find entry of cycle\n→ Decision: while slow != fast? // move both one step\n    Yes → Step 5: slow = nums[slow]\n           → Step 6: fast = nums[fast]\n        No  → // found duplicate\n→ Step 7: 返回 slow // duplicate number\nEnd // finish\n\nNeed to ensure formatting: lines starting with \"→\". For decisions with nested steps, indentation maybe? The example shows indentation inside decision blocks. We can use spaces indentation. Let's produce. Use \"Decision:\" lines with question. Indent steps inside decision. Provide explanation comments.\n\nAlso use [空格] meaning a single space between virtual code and comment. Ensure no actual code output but pseudocode. Let's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: slow ← nums[0] , fast ← nums[nums[0]] // 初始化慢指標與快指標  \n→ Decision: slow ≠ fast? // 檢查兩指標是否相遇  \n  Yes → Step 2: slow ← nums[slow] // 慢指標前進一步  \n    → Step 3: fast ← nums[nums[fast]] // 快指標前進兩步  \n  No → // slow 與 fast 相遇，結束搜尋迴圈  \n→ Step 4: slow ← nums[0] // 重新將慢指標定位於起點，尋找週期入口  \n→ Decision: slow ≠ fast? // 檢查慢快指標是否再次相遇  \n  Yes → Step 5: slow ← nums[slow] // 慢指標前進一步  \n    → Step 6: fast ← nums[fast] // 快指標前進一步  \n  No → // slow 與 fast 再次相遇，該位置即為重複數值  \n→ Step 7: return slow // 回傳重複的數字  \nEnd // 程式執行結束"
    },
    {
      "title": "Insert Delete GetRandom O(1) - Duplicates allowed",
      "source_file": "Leetcode/leetcode381.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedCollection\", \"insert\", \"insert\", \"insert\", \"getRandom\", \"remove\", \"getRandom\"], [[], [1], [1], [2], [], [1], []]",
          "expected_output": "[null, true, false, true, 2, true, 1]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,false,true,2,true,1]'\nGot (Norm):      '[null,true,false,true,1,true,2]'\n--- (Raw) ---\nRaw Expected: '[null, true, false, true, 2, true, 1]'\nRaw Got:      '[null, true, false, true, 1, true, 2]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport collections\n\nclass RandomizedCollection:\n    def __init__(self):\n        self.data = []\n        self.idx_map = collections.defaultdict(set)\n\n    def insert(self, val):\n        self.data.append(val)\n        self.idx_map[val].add(len(self.data) - 1)\n        return len(self.idx_map[val]) == 1\n\n    def remove(self, val):\n        if not self.idx_map[val]:\n            return False\n        remove_idx = self.idx_map[val].pop()\n        last_val = self.data[-1]\n        self.data[remove_idx] = last_val\n        self.idx_map[last_val].add(remove_idx)\n        self.idx_map[last_val].discard(len(self.data) - 1)\n        self.data.pop()\n        return True\n\n    def getRandom(self):\n        return random.choice(self.data)\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n    # 轉成合法 JSON\n    raw_input = raw_input.replace(\"'\", '\"')\n    raw_input = '[' + raw_input + ']'\n    try:\n        commands, args = json.loads(raw_input)\n    except json.JSONDecodeError:\n        # 若輸入格式不符，直接結束\n        sys.exit()\n    outputs = []\n    rc = None\n    for cmd, arg in zip(commands, args):\n        if cmd == \"RandomizedCollection\":\n            rc = RandomizedCollection()\n            outputs.append(None)\n        else:\n            method = getattr(rc, cmd)\n            result = method(*arg)\n            outputs.append(result)\n    # 以 JSON 格式輸出\n    print(json.dumps(outputs))",
      "virtual_code": "Thinking...\nWe need to output virtual code line by line, with arrow etc. Should produce algorithm description: maintain vector of values and hashmap from value to set of indices. Provide pseudocode. Must follow format: each line: virtual step + space + // explanation. Use Start, End, Decision. Provide indentation? In example, they use indents. We can produce similar.\n\nLet's design pseudocode:\n\nStart\n→ Initialize list values\n→ Initialize map valToIndices: value -> set of indices\n→ Function insert(val)\n    → Check if val not in map? -> but we just do insert anyway\n    → Append val to values list at index len(values)\n    → Add index to valToIndices[val]\n    → If val not existed before? then return true else false\n\n→ Function remove(val)\n    → If val not in map or empty set -> return false\n    → Get any index idx from valToIndices[val] (e.g., first)\n    → Remove idx from valToIndices[val]\n    → Get lastIndex = len(values)-1\n    → If idx != lastIndex:\n        → Move lastVal = values[lastIndex]\n        → Overwrite values[idx] = lastVal\n        → Update valToIndices[lastVal]: remove lastIndex, add idx\n    → Pop last element from values\n    → If valToIndices[val] becomes empty: delete key\n    → Return true\n\n→ Function getRandom()\n    → Generate random integer r in [0, len(values)-1]\n    → Return values[r]\n\nEnd\n\nAlso need to indicate average O(1). Use Decision: maybe for checking existence. Provide explanation comments.\n\nEnsure each line has arrow or Start/End etc.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行\n\n→ Step 1: 初始化 list< int > values // 用來儲存所有元素，便於隨機存取  \n→ Step 2: 初始化 map< int, set< int > > valToIndices // 將每個值映射到其在 values 中所有索引的位置  \n\n// ---------- Insert ----------\n→ Function insert( int val ) // 定義插入方法  \n    → Decision: 若 val 尚未在 valToIndices 中? // 判斷是否為新值  \n        Yes → Step 3a: valToIndices[ val ] ← 空集合 // 建立新集合  \n        No  → // 若已存在，直接跳至後續步驟  \n    → Step 3b: index ← values.size() // 新元素將插入的索引  \n    → Step 3c: values.append( val ) // 把值加入尾端  \n    → Step 3d: valToIndices[ val ].add( index ) // 將索引記錄到對應集合  \n    → Decision: 若此時 valToIndices[ val ].size() == 1? // 是否第一次插入此值  \n        Yes → Step 3e: return true // 新值，回傳 true  \n        No  → Step 3f: return false // 不是新值，回傳 false  \n\n// ---------- Remove ----------\n→ Function remove( int val ) // 定義刪除方法  \n    → Decision: 若 val 不在 valToIndices 或集合為空? // 檢查值是否存在  \n        Yes → Step 4a: return false // 無此值，直接回傳 false  \n        No  → // 繼續刪除一個實例  \n    → Step 4b: idx ← valToIndices[ val ].any() // 任取一個索引  \n    → Step 4c: valToIndices[ val ].remove( idx ) // 刪除該索引  \n    → Step 4d: lastIndex ← values.size() - 1 // 最後一個元素的索引  \n    → Decision: 若 idx != lastIndex? // 若刪除的不是尾端  \n        Yes → Step 4e: lastVal ← values[ lastIndex ] // 取得尾端值  \n        → Step 4f: values[ idx ] ← lastVal // 覆寫待刪除位置  \n        → Step 4g: valToIndices[ lastVal ].remove( lastIndex ) // 移除舊索引  \n        → Step 4h: valToIndices[ lastVal ].add( idx ) // 加入新索引  \n        No  → // 若刪除的是尾端，無需調整  \n    → Step 4i: values.pop_back() // 刪除尾端（已被移動或原本位置）  \n    → Decision: 若 valToIndices[ val ] 為空? // 是否剩下無元素  \n        Yes → Step 4j: valToIndices.erase( val ) // 清除鍵  \n        No  → // 留下集合  \n    → Step 4k: return true // 成功刪除，回傳 true  \n\n// ---------- GetRandom ----------\n→ Function getRandom() // 定義隨機取得方法  \n    → Step 5a: r ← randomInt( 0, values.size() - 1 ) // 產生合法索引  \n    → Step 5b: return values[ r ] // 回傳隨機元素  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Coin Change",
      "source_file": "Leetcode/leetcode322.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "coins = [1,2,5], amount = 11",
          "expected_output": "3",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp_amvpzdd.py\", line 35, in <module>\n    main()\n  File \"/tmp/tmp_amvpzdd.py\", line 24, in main\n    amount_part = parts[1].split('=')[1].strip()\n                  ~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def coinChange(self, coins, amount):\n        # 初始化 dp 陣列，dp[i] 表示湊成金額 i 所需最少硬幣數\n        dp = [float('inf')] * (amount + 1)\n        dp[0] = 0\n\n        for coin in coins:\n            for x in range(coin, amount + 1):\n                dp[x] = min(dp[x], dp[x - coin] + 1)\n\n        return dp[amount] if dp[amount] != float('inf') else -1\n\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 假設輸入格式為: coins = [1,2,5], amount = 11\n    parts = data.split(',')\n    coins_part = parts[0].split('=')[1].strip()\n    amount_part = parts[1].split('=')[1].strip()\n\n    coins = eval(coins_part)          # 取得硬幣面額列表\n    amount = int(amount_part)         # 取得總金額\n\n    sol = Solution()\n    result = sol.coinChange(coins, amount)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for coin change DP algorithm. Steps: Start, input coins and amount, initialize dp array size amount+1 with large INF, dp[0]=0. Iterate amount from 1 to amount: for each coin: if coin <= i: dp[i] = min(dp[i], dp[i-coin]+1). After loops, if dp[amount] > amount: return -1 else return dp[amount]. End. Also include explanation. Use arrows and decision structure.\n\nWe must produce step-by-step virtual code lines with explanations. Must not output actual code, only pseudocode steps. Each line: \"虛擬碼步驟 // 解釋\". Use arrows.\n\nOk. We'll produce like:\n\nStart // 程式開始執行\n→ Step 1: 讀取 coins 陣列與 amount 數值 // 取得輸入資料\n→ Step 2: 建立 dp 陣列長度 amount+1，並初始化為 INF，dp[0]=0 // dp[i] 代表組成金額 i 所需最少硬幣數\n→ Decision: amount 是否為 0? // 若 amount 為 0，已無需任何硬幣\n    Yes → Step 3: 回傳 0 // 金額為 0，硬幣數為 0\n    No  → Step 4: 進行 DP 計算 // 否則執行動態規劃\n→ Step 5: 從 i=1 到 amount 逐個計算 // 外層迴圈遍歷所有金額\n    → Step 6: 對於每顆 coin in coins\n        → Decision: coin <= i? // 僅考慮能夠扣除的硬幣\n            Yes → Step 7: 更新 dp[i] = min(dp[i], dp[i-coin]+1) // 嘗試使用此硬幣\n            No  → // 無需更新\n→ Step 8: 計算完畢後，決定是否可組成 amount\n    → Decision: dp[amount] > amount? // 若仍為 INF 或大於 amount，表示無法組成\n        Yes → Step 9: 回傳 -1 // 無法達成金額\n        No  → Step 10: 回傳 dp[amount] // 返回最少硬幣數\nEnd // 程式執行結束\n\nWe must ensure each line has virtual code and comment. Let's format exactly. Use \"Start\", \"End\", \"Decision:\" etc. For lines with arrows, use \"→\". For decisions with Yes/No we need indentation.\n\nOk produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取 coins 陣列與 amount 數值 // 取得輸入資料  \n→ Step 2: 建立 dp 陣列長度 amount+1，並初始化為 INF，dp[0]=0 // dp[i] 代表組成金額 i 所需最少硬幣數  \n→ Decision: amount 是否為 0? // 若 amount 為 0，已無需任何硬幣  \n  Yes → Step 3: 回傳 0 // 金額為 0，硬幣數為 0  \n  No  → Step 4: 進行 DP 計算 // 否則執行動態規劃  \n→ Step 5: 從 i=1 到 amount 逐個計算 // 外層迴圈遍歷所有金額  \n  → Step 6: 對於每顆 coin in coins  \n    → Decision: coin <= i? // 僅考慮能夠扣除的硬幣  \n      Yes → Step 7: 更新 dp[i] = min(dp[i], dp[i-coin]+1) // 嘗試使用此硬幣  \n      No  → // 無需更新  \n→ Step 8: 計算完畢後，決定是否可組成 amount  \n  → Decision: dp[amount] > amount? // 若仍為 INF 或大於 amount，表示無法組成  \n    Yes → Step 9: 回傳 -1 // 無法達成金額  \n    No  → Step 10: 回傳 dp[amount] // 返回最少硬幣數  \nEnd // 程式執行結束"
    },
    {
      "title": "Find Median from Data Stream",
      "source_file": "Leetcode/leetcode295.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"], [[], [1], [2], [], [3], []]",
          "expected_output": "[null, null, null, 1.5, null, 2.0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,1.5,null,2.0]'\nGot (Norm):      '[null,null,null,1.5,null,2]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, 1.5, null, 2.0]'\nRaw Got:      '[null, null, null, 1.5, null, 2]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nimport heapq\n\nclass MedianFinder:\n    \"\"\"\n    用兩個堆疊保持資料分為兩半，左半部使用最大堆（small）\n    右半部使用最小堆（large）。兩堆大小保持相差不超過 1，\n    這樣就能在 O(log n) 時間內得到中位數。\n    \"\"\"\n    def __init__(self):\n        # small 儲存較小的一半，作為最大堆 (使用負值來模擬最大堆)\n        self.small = []\n        # large 儲存較大的一半，作為最小堆\n        self.large = []\n\n    def addNum(self, num: int) -> None:\n        # 把新數字先放進 small（最大堆）\n        heapq.heappush(self.small, -num)\n\n        # 若 small 的最大值大於 large 的最小值，兩堆交換一個元素\n        if self.small and self.large and (-self.small[0] > self.large[0]):\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n\n        # 調整大小，確保小堆不比大堆多太多\n        if len(self.small) > len(self.large) + 1:\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        elif len(self.large) > len(self.small):\n            val = heapq.heappop(self.large)\n            heapq.heappush(self.small, -val)\n\n    def findMedian(self) -> float:\n        # 如果小堆較大，取小堆頂；若兩堆相等，取兩個頂的平均\n        if len(self.small) > len(self.large):\n            return -self.small[0]\n        else:\n            return (-self.small[0] + self.large[0]) / 2.0\n\n\ndef parse_input(data: str):\n    \"\"\"\n    將輸入字串解析成兩個列表：commands 與 arguments。\n    假設輸入格式為:\n        [\"MedianFinder\", \"addNum\", ...], [[], [1], ...]\n    \"\"\"\n    import re\n    # 找到第一個完整列表的結束位置\n    bracket = 0\n    end_index = 0\n    for i, ch in enumerate(data):\n        if ch == '[':\n            bracket += 1\n        elif ch == ']':\n            bracket -= 1\n            if bracket == 0:\n                end_index = i\n                break\n    first_part = data[:end_index + 1]\n    second_part = data[end_index + 2:].lstrip()\n    # 使用 ast.literal_eval 解析為 Python 物件\n    commands = ast.literal_eval(first_part)\n    args = ast.literal_eval(second_part)\n    return commands, args\n\n\ndef main():\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n    commands, args = parse_input(raw)\n\n    result = []\n    obj = None\n    for cmd, arg in zip(commands, args):\n        if cmd == \"MedianFinder\":\n            obj = MedianFinder()\n            result.append(None)\n        elif cmd == \"addNum\":\n            obj.addNum(arg[0])\n            result.append(None)\n        elif cmd == \"findMedian\":\n            result.append(obj.findMedian())\n        else:\n            # 若出現未知指令，視作錯誤\n            raise ValueError(f\"Unknown command: {cmd}\")\n\n    # 輸出結果，使用 json.dumps 以得到 null 而非 None\n    print(json.dumps(result))\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with arrows and explanations. Provide algorithm: using two heaps: max-heap for lower half, min-heap for upper half. Keep sizes balanced (difference <=1). addNum pushes appropriately. findMedian returns average if equal sizes else top of larger heap.\n\nWe must output step-by-step pseudocode. Probably break into class initialization, addNum, findMedian, plus helper functions.\n\nWe'll produce:\n\nStart\n→ Class MedianFinder\n  → Init:\n     ← maxHeap ← empty // max-heap for lower half\n     ← minHeap ← empty // min-heap for upper half\n  → End of Init\n\n→ Method addNum(num):\n    Decision: If maxHeap empty or num <= top of maxHeap? // decide placement\n        Yes → Insert num into maxHeap // add to lower half\n        No  → Insert num into minHeap // add to upper half\n    Decision: If size(maxHeap) > size(minHeap) + 1? // rebalance\n        Yes → Move top of maxHeap to minHeap\n    Decision: If size(minHeap) > size(maxHeap)? // rebalance\n        Yes → Move top of minHeap to maxHeap\n\n→ Method findMedian():\n    Decision: size(maxHeap) == size(minHeap)? // even number of elements\n        Yes → Return (top(maxHeap)+top(minHeap))/2.0\n        No  → Return top(maxHeap) // since maxHeap always larger or equal\n\nEnd\n\nWe need to ensure each line with comment.\n\nLet's produce as per format. Use arrows. Each line as virtual code with explanation. Should start with Start and End. Provide structure lines.\n\nWe'll output exactly following format.\n...done thinking.\n\nStart // 程式開始執行\n→ Class MedianFinder // 宣告 MedianFinder 類別\n  → Init // 初始化建構子\n    → maxHeap ← empty // 建立用於左半部的最大堆\n    → minHeap ← empty // 建立用於右半部的最小堆\n  → End Init // 結束初始化\n  → Method addNum(num) // 定義加入新數字的函式\n    → Decision: 如果 maxHeap 為空 或 num <= maxHeap.top()? // 判斷將新數字放入左半部還是右半部\n      Yes → Insert num into maxHeap // 新數字放入左半部\n      No  → Insert num into minHeap // 新數字放入右半部\n    → Decision: 如果 size(maxHeap) > size(minHeap) + 1? // 檢查左半部是否過大\n      Yes → Move maxHeap.top() 到 minHeap // 重新平衡：把左半部最大的數移到右半部\n    → Decision: 如果 size(minHeap) > size(maxHeap)? // 檢查右半部是否過大\n      Yes → Move minHeap.top() 到 maxHeap // 重新平衡：把右半部最小的數移到左半部\n  → End Method addNum // 結束 addNum 方法\n  → Method findMedian() // 定義查找中位數的函式\n    → Decision: 如果 size(maxHeap) == size(minHeap)? // 判斷元素數量是否為偶數\n      Yes → Return (maxHeap.top() + minHeap.top()) / 2.0 // 兩個中位數的平均\n      No  → Return maxHeap.top() // 若奇數，左半部堆頂即為中位數\n  → End Method findMedian // 結束 findMedian 方法\nEnd // 程式執行結束"
    },
    {
      "title": "Insert Interval",
      "source_file": "Leetcode/leetcode57.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "intervals = [[1,3],[6,9]], newInterval = [2,5]",
          "expected_output": "[[1,5],[6,9]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp37ncnic_.py\", line 61, in <module>\n    merged = solution.insert(intervals, new_interval)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp37ncnic_.py\", line 19, in insert\n    while i < n and intervals[i][1] < newInterval[0]:\n                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nTypeError: '<' not supported between instances of 'list' and 'int'"
        },
        {
          "example_index": 1,
          "input": "intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]",
          "expected_output": "[[1,2],[3,10],[12,16]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpob3oryvr.py\", line 61, in <module>\n    merged = solution.insert(intervals, new_interval)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpob3oryvr.py\", line 19, in insert\n    while i < n and intervals[i][1] < newInterval[0]:\n                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nTypeError: '<' not supported between instances of 'list' and 'int'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        Insert a new interval into a list of sorted non-overlapping intervals,\n        merging if necessary.\n\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        result = []\n        i = 0\n        n = len(intervals)\n\n        # Add all intervals that end before the new interval starts\n        while i < n and intervals[i][1] < newInterval[0]:\n            result.append(intervals[i])\n            i += 1\n\n        # Merge all overlapping intervals with the new interval\n        while i < n and intervals[i][0] <= newInterval[1]:\n            newInterval[0] = min(newInterval[0], intervals[i][0])\n            newInterval[1] = max(newInterval[1], intervals[i][1])\n            i += 1\n\n        # Insert the merged new interval\n        result.append(newInterval)\n\n        # Add the remaining intervals\n        while i < n:\n            result.append(intervals[i])\n            i += 1\n\n        return result\n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # Find positions of the two assignments\n    idx_interval = data.find(\"intervals =\")\n    idx_new = data.find(\"newInterval =\")\n    if idx_interval == -1 or idx_new == -1:\n        raise ValueError(\"Input format is incorrect.\")\n\n    # Extract the string representations of the lists\n    intervals_str = data[idx_interval + len(\"intervals =\") : idx_new].strip()\n    new_interval_str = data[idx_new + len(\"newInterval =\") :].strip()\n\n    # Safely evaluate the list literals\n    intervals = ast.literal_eval(intervals_str)\n    new_interval = ast.literal_eval(new_interval_str)\n\n    # Compute the result\n    solution = Solution()\n    merged = solution.insert(intervals, new_interval)\n\n    # Print the result\n    print(merged)",
      "virtual_code": "Thinking...\nWe need to output virtual code line by line with comments. The problem: insert interval into sorted non-overlapping intervals, merging if overlap. Should produce steps: iterate, add non-overlapping before, merge overlapping, add rest. Provide virtual steps. Ensure using Start, End, Decision. Use → arrow. Provide each line with comment.\n\nWe must produce virtual code. For each line: \"Start // 程式開始執行\" etc.\n\nLet's craft.\n\nStep 1: initialize result array. Step 2: iterate intervals with index i. For each interval, if its end < new start, add to result. else if its start > new end, then if not added new interval yet, add new interval, then add remaining intervals and break. else merge: update new start = min(new start, interval start), new end = max(new end, interval end). After loop, if new interval not added, add it. End.\n\nLet's produce virtual code:\n\nStart // 程式開始執行\n→ Step 1: result ← empty list // 用來儲存合併後的 intervals\n→ Step 2: newStart ← newInterval[0]; newEnd ← newInterval[1]; // 取出新 interval 的起點與終點\n→ Step 3: i ← 0; // 設定迴圈索引\n→ Decision: i < intervals.length? // 是否還有 interval 可處理\n    Yes → Decision: intervals[i][1] < newStart? // 目前 interval 完在新 interval 之前\n        Yes → Step 4: result.append(intervals[i]); // 將其加入結果\n                i ← i + 1;\n                → Decision: i < intervals.length? // 重新判斷\n                    Yes → (back to Decision)\n                    No  → Step 7: result.append([newStart, newEnd]); // 新 interval 未加入，加入後結束\n                         → End // 完成\n        No  → Decision: intervals[i][0] > newEnd? // 目前 interval 完在新 interval 之後\n            Yes → Decision: result does not contain new interval? // 檢查是否已經加入\n                Yes → Step 5: result.append([newStart, newEnd]); // 加入新 interval\n                        → Step 6: while i < intervals.length: result.append(intervals[i]); i ← i + 1; // 加入剩餘 intervals\n                        → End // 結束\n                No  → Step 6: while i < intervals.length: result.append(intervals[i]); i ← i + 1; // 已加入，直接追加\n                        → End\n            No  → Step 7: newStart ← min(newStart, intervals[i][0]); // 合併起點\n                     newEnd ← max(newEnd, intervals[i][1]); // 合併終點\n                     i ← i + 1; // 移動至下一個 interval\n                     → Decision: i < intervals.length? // 重新判斷\n                        Yes → (back to Decision)\n                        No  → Step 8: result.append([newStart, newEnd]); // 合併完成後加入結果\n                              → End\nEnd // 程式執行結束\n\nBut we might need more concise representation.\n\nWe need to ensure each line includes arrow and comment. Provide steps with proper indentation maybe. Use decision lines with Yes →, No →.\n\nBetter to write simplified pseudo flow.\n\nLet's craft final answer accordingly.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: result ← [] // 建立空的結果列表\n→ Step 2: newStart ← newInterval[0]; newEnd ← newInterval[1]; // 取新 interval 的起點與終點\n→ Step 3: i ← 0; // 初始化索引\n→ Decision: i < intervals.length? // 是否還有 interval 未處理？\n    Yes → Decision: intervals[i][1] < newStart? // 目前 interval 完全在新 interval 前面？\n        Yes → Step 4: result.append(intervals[i]); // 加入此 interval\n                i ← i + 1;\n                → Decision: i < intervals.length? // 重新判斷\n                    Yes → (回到 Decision)\n                    No  → Step 8: result.append([newStart, newEnd]); // 新 interval 尚未加入，直接加入\n                         → End // 程式結束\n        No  → Decision: intervals[i][0] > newEnd? // 目前 interval 完全在新 interval 後面？\n            Yes → Decision: result does not contain new interval? // 檢查是否已經加入新 interval\n                Yes → Step 5: result.append([newStart, newEnd]); // 加入新 interval\n                        → Step 6: while i < intervals.length: result.append(intervals[i]); i ← i + 1; // 加入剩餘的 intervals\n                        → End\n                No  → Step 6: while i < intervals.length: result.append(intervals[i]); i ← i + 1; // 已加入新 interval，直接追加剩餘\n                        → End\n            No  → Step 7: newStart ← min(newStart, intervals[i][0]); // 合併起點\n                     newEnd ← max(newEnd, intervals[i][1]); // 合併終點\n                     i ← i + 1; // 前往下一個 interval\n                     → Decision: i < intervals.length? // 重新判斷\n                        Yes → (回到 Decision)\n                        No  → Step 8: result.append([newStart, newEnd]); // 合併完成後加入結果\n                              → End\nEnd // 程式執行結束\n```"
    },
    {
      "title": "Substring with Concatenation of All Words",
      "source_file": "Leetcode/leetcode30.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]",
          "expected_output": "[0,9]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp73hsg1sv.py\", line 76, in <module>\n    data = parse_input(raw)\n           ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp73hsg1sv.py\", line 71, in parse_input\n    return ast.literal_eval(raw_input)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    {\"s\": \"barfoothefoobarman\", word\"s\": [\"foo\",\"bar\"]}\n                                   ^\nSyntaxError: ':' expected after dictionary key"
        },
        {
          "example_index": 1,
          "input": "s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]",
          "expected_output": "[]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmppbmew0e_.py\", line 76, in <module>\n    data = parse_input(raw)\n           ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmppbmew0e_.py\", line 71, in parse_input\n    return ast.literal_eval(raw_input)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    {\"s\": \"wordgoodgoodgoodbestword\", word\"s\": [\"word\",\"good\",\"best\",\"word\"]}\n                                         ^\nSyntaxError: ':' expected after dictionary key"
        },
        {
          "example_index": 2,
          "input": "s = \"barfoofoobarthefoobarman\", words = [\"bar\",\"foo\",\"the\"]",
          "expected_output": "[6,9,12]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpgzygh1kf.py\", line 76, in <module>\n    data = parse_input(raw)\n           ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpgzygh1kf.py\", line 71, in parse_input\n    return ast.literal_eval(raw_input)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    {\"s\": \"barfoofoobarthefoobarman\", word\"s\": [\"bar\",\"foo\",\"the\"]}\n                                         ^\nSyntaxError: ':' expected after dictionary key"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import Counter, defaultdict\n\nclass Solution:\n    def findSubstring(self, s, words):\n        # 若 words 為空，無法構成任何串\n        if not words:\n            return []\n        word_len = len(words[0])\n        word_count = len(words)\n        total_len = word_len * word_count\n        n = len(s)\n        # s 的長度若不足以容納所有單字，直接返回空列表\n        if n < total_len:\n            return []\n\n        # 建立每個單字的頻率表\n        need = Counter(words)\n        result = []\n\n        # 依照 word_len 的 offset 進行滑動窗口\n        for offset in range(word_len):\n            left = offset\n            right = offset\n            seen = defaultdict(int)\n            matched = 0\n\n            while right + word_len <= n:\n                # 取右側單字\n                word = s[right:right + word_len]\n                right += word_len\n\n                if word in need:\n                    seen[word] += 1\n                    if seen[word] <= need[word]:\n                        matched += 1\n                    else:\n                        # 右側單字頻率超過需要，縮小窗口直到頻率合法\n                        while seen[word] > need[word]:\n                            left_word = s[left:left + word_len]\n                            seen[left_word] -= 1\n                            if seen[left_word] < need[left_word]:\n                                matched -= 1\n                            left += word_len\n                else:\n                    # 單字不在需求表中，重置窗口\n                    seen.clear()\n                    matched = 0\n                    left = right\n\n                # 若窗口長度正好為總長度，檢查是否匹配\n                if right - left == total_len and matched == word_count:\n                    result.append(left)\n\n        return result\n\n\ndef parse_input(raw_input: str):\n    \"\"\"\n    將輸入字串轉換為字典，格式類似：\n        s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]\n    \"\"\"\n    # 移除換行，轉成單行\n    raw_input = raw_input.strip()\n    # 替換成 Python dict 風格\n    raw_input = raw_input.replace('s =', '\"s\":').replace('words =', '\"words\":')\n    # 包裝進大括號\n    raw_input = '{' + raw_input + '}'\n    # 使用安全的 literal_eval\n    return ast.literal_eval(raw_input)\n\n\nif __name__ == \"__main__\":\n    raw = sys.stdin.read()\n    data = parse_input(raw)\n    s = data['s']\n    words = data['words']\n    sol = Solution()\n    res = sol.findSubstring(s, words)\n    print(res)",
      "virtual_code": "Thinking...\nWe need to produce a virtual code algorithm for the problem: find starting indices of substrings in s that are concatenations of each word in words exactly once, words same length. Classic sliding window. We'll output virtual code step-by-step with explanations. Let's craft steps:\n\nStart\n→ Step 1: Determine word length l and total words count n.\n→ Step 2: Compute total concat length = l*n.\n→ Decision: If total length > s length? Yes → End // no possible.\n→ Step 3: Build hash map wordCount from words.\n→ Step 4: For i from 0 to l-1 (offsets)\n    → Step 5: Initialize left = i, right = i, windowCount empty, matched = 0.\n    → While right + l <= s length\n        → Step 6: Extract currentWord = s.substr(right, l)\n        → Decision: currentWord in wordCount? Yes → Increment windowCount[currentWord]; If windowCount[currentWord] <= wordCount[currentWord] then matched++.\n            No → Reset windowCount empty; matched=0; left = right + l; right = left; continue.\n        → Decision: right - left + l > totalConcat? Yes → While (leftWord = s.substr(left, l)) remove: decrement windowCount[leftWord]; if windowCount[leftWord] < wordCount[leftWord] then matched--; left += l.\n        → Decision: matched == n? Yes → Record left as answer; // add left to result.\n        → right += l.\n    → End of while.\n→ End of for.\n→ Step 7: Return result list.\n\nMake sure to include comments after each line. Use arrow syntax. Provide each line with `→` or `Decision:` etc.\n\nEdge cases: words empty? Usually at least one. We can assume. Provide explanation.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算單個單字長度 `wordLen = words[0].length()` // 所有單字長度相同  \n→ Step 2: 計算單字總數 `wordCount = words.length` // 需要用到的單字數  \n→ Step 3: 計算所有單字連接後的總長度 `totalLen = wordLen * wordCount` // 目標子字串長度  \n→ Decision: 如果 `totalLen > s.length()`?  \n Yes → End // 字串長度不足，無法找到符合條件的子字串  \n No →  \n  Step 4: 建立單字頻率表 `freqMap`，key 為單字，value 為出現次數  \n  Step 5: 建立結果陣列 `result = []` // 儲存符合條件的起始索引  \n\n→ Decision: 對於 offset `i` 從 0 到 `wordLen - 1`  \n → Step 6: 初始化滑動窗口變數  \n  `left = i` // 窗口左邊界  \n  `right = i` // 窗口右邊界  \n  `currentMap = {}` // 當前窗口內單字頻率表  \n  `matched = 0` // 符合頻率的單字數量  \n\n  → While `right + wordLen <= s.length()` // 右邊界可擴展  \n   → Step 7: 取出右側單字 `word = s.substr(right, wordLen)`  \n   → Decision: `word` 是否在 `freqMap`?  \n    Yes →  \n     `currentMap[word] = (currentMap[word] || 0) + 1`  \n     Decision: `currentMap[word] <= freqMap[word]`?  \n      Yes → `matched++` // 這個單字的出現次數未超過目標頻率  \n      No → // 超過頻率，必須縮小窗口直到頻率合適  \n       → While `currentMap[word] > freqMap[word]`  \n        `leftWord = s.substr(left, wordLen)`  \n        `currentMap[leftWord]--`  \n        if `currentMap[leftWord] < freqMap[leftWord]` `matched--`  \n        `left += wordLen`  \n       End While  \n      End Decision  \n     End Decision  \n     → `right += wordLen` // 右邊界移動到下一個單字  \n\n    → Decision: `right - left == totalLen`?  \n     Yes → // 窗口長度已正好為所有單字連接長度  \n      Decision: `matched == wordCount`?  \n       Yes → `result.push(left)` // 取得起始索引  \n       No → // 不符合，繼續擴展或縮小  \n      End Decision  \n     End Decision  \n    End While  \n  End Decision  \nEnd // 程式執行結束（返回 `result`）"
    },
    {
      "title": "Group Anagrams",
      "source_file": "Leetcode/leetcode49.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]",
          "expected_output": "[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]'\nGot (Norm):      '[[\"eat\",\"tea\",\"ate\"],[\"tan\",\"nat\"],[\"bat\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]'\nRaw Got:      \"[['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]\""
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\ndef group_anagrams(strs):\n    \"\"\"Group strings that are anagrams of each other.\"\"\"\n    anagrams = defaultdict(list)\n    for s in strs:\n        key = tuple(sorted(s))          # 以字母排序後的元組作為鍵\n        anagrams[key].append(s)         # 把原字串加入對應的清單\n    return list(anagrams.values())\n\ndef main():\n    # 從標準輸入讀取整個內容\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 只保留等號右側的列表表示\n    if '=' in data:\n        _, rhs = data.split('=', 1)\n        rhs = rhs.strip()\n    else:\n        rhs = data\n\n    try:\n        # 用 literal_eval 解析 Python 列表字面量\n        strs = ast.literal_eval(rhs)\n    except Exception as e:\n        # 若解析失敗，直接嘗試 eval 作為備援\n        strs = eval(rhs, {\"__builtins__\": None}, {})\n\n    # 確保得到的是列表\n    if not isinstance(strs, list):\n        strs = [strs]\n\n    result = group_anagrams(strs)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines, each with // explanation. Use Start, End, Decision. Should not output actual code. Provide steps: Start, iterate through array, compute sorted key, use dictionary mapping key to list, add string to list, then after loop gather lists, return result.\n\nWe must produce each line with virtual code and comment. Use arrow →.\n\nWe need to consider \"逐行\" each line as a step. Use indentation for nested decisions.\n\nMake sure to include steps like: Start, → Step 1: 初始化空字典 // Create dictionary mapping sorted string to list. etc.\n\nWe also might include Decision: if key exists? But could just add to list automatically. Provide logic. Provide \"End\".\n\nLet's craft. Ensure each line ends with // 解釋/說明.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空字典 hashMap // 用來把排序後的字串映射到同類字串清單  \n→ Step 2: 對於每個字串 word 於 strs 中執行 // 逐一處理輸入陣列  \n    → Step 2.1: 取得 word 的字母排序 key // 以字母排序後的字串作為鍵  \n    → Decision: 若 hashMap 已含有 key? // 判斷鍵是否已存在  \n        Yes → Step 2.2: 將 word 加入 hashMap[key] 清單 // 已有鍵則把字串加入對應清單  \n        No → Step 2.3: 建立 hashMap[key] 為新清單並加入 word // 新鍵則先建立清單再加入  \n→ Step 3: 建立結果列表 result = 空清單 // 用來收集所有同類字串清單  \n→ Step 4: 對於每個 key, value 在 hashMap 之中執行 // 逐一取出字典值  \n    → Step 4.1: 將 value (字串清單) 加入 result // 加入最終結果中  \n→ End // 程式執行結束，返回 result 為分組後的字串清單"
    },
    {
      "title": "Roman to Integer",
      "source_file": "Leetcode/leetcode13.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 2,
          "input": "Input: s = \"MCMXCIV\"",
          "expected_output": "Output: 1994",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'Output:1994'\nGot (Norm):      '1994'\n--- (Raw) ---\nRaw Expected: 'Output: 1994'\nRaw Got:      '1994'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def romanToInt(self, s: str) -> int:\n        roman_map = {\n            'I': 1, 'V': 5, 'X': 10, 'L': 50,\n            'C': 100, 'D': 500, 'M': 1000\n        }\n        total = 0\n        prev_value = 0\n        for char in reversed(s):\n            value = roman_map[char]\n            if value < prev_value:\n                total -= value\n            else:\n                total += value\n            prev_value = value\n        return total\n\ndef main():\n    data = sys.stdin.read().strip()\n    # Try to extract the roman numeral from a quoted string\n    match = re.search(r'\"([A-Z]+)\"', data)\n    if match:\n        s = match.group(1)\n    else:\n        # Fallback: remove known prefixes and quotes if present\n        s = data.replace('Input:', '').replace('Output:', '').replace('s =', '').strip().strip('\"')\n    result = Solution().romanToInt(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for converting Roman numeral string to integer. Provide step by step. The virtual code should use Start, End, Decision, arrow etc. Each line with comment.\n\nWe'll write pseudocode: Start, input string, initialize total=0, previous_value=0. For each char from end to start (or start to end with previous). Simpler: iterate from left to right, look ahead to next char to decide if subtract. Implementation: for i from 0 to len-1: value=map[char]; if i+1 < len and value < map[next]: total -= value else total += value. Or use reverse.\n\nLet's produce virtual code lines:\n\nStart\n→ Step 1: 輸入羅馬數字字串 // 取得輸入字串\n→ Step 2: 初始化總和為 0 // 存放結果\n→ Step 3: 建立符號到數值的映射表 // I->1, V->5 等\n→ Decision: 是否存在字串？ // 確認輸入非空\n    Yes → Step 4: 從左到右遍歷每個字符 // 逐個處理\n        → Step 5: 取得當前字符對應數值 // map lookup\n        → Decision: 是否為最後一個字符？ // 判斷是否有下一個字符\n            Yes → Step 6: 加總到總和 // 最後一個直接加\n            No  → Step 7: 取得下一個字符對應數值 // 看看是否需要減法\n                → Decision: 當前值 < 下一個值？ // 判斷是否使用減法規則\n                    Yes → Step 8: 減去當前值 (total = total - value) // 符號前置\n                    No  → Step 9: 加上當前值 (total = total + value) // 正常加\n→ Step 10: 輸出總和 // 最終結果\nEnd\n\nBut need to ensure each line uses \"→\" arrow and \"Decision:\" lines indent? Use same pattern as example: For decisions, we indent the Yes/No branches. Provide simple arrow lines for steps.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入羅馬數字字串 // 從使用者或函式取得輸入字串  \n→ Step 2: 初始化總和為 0 // 用於累加計算結果  \n→ Step 3: 建立符號到數值的映射表 // I:1, V:5, X:10, L:50, C:100, D:500, M:1000  \n→ Decision: 是否存在字串？ // 檢查輸入是否為空  \n    Yes → Step 4: 從左到右遍歷每個字符 // 逐個處理字串中的符號  \n        → Step 5: 取得當前字符對應數值 // map lookup  \n        → Decision: 是否為最後一個字符？ // 判斷是否有下一個字符  \n            Yes → Step 6: 加總到總和 (total = total + value) // 最後一個符號直接加  \n            No  → Step 7: 取得下一個字符對應數值 // 用於判斷減法規則  \n                → Decision: 當前值 < 下一個值？ // 判斷是否需要減法  \n                    Yes → Step 8: 減去當前值 (total = total - value) // 前置符號表示減法  \n                    No  → Step 9: 加上當前值 (total = total + value) // 正常加法  \n→ Step 10: 輸出總和 // 顯示或返回最終的整數值  \nEnd // 程式執行結束"
    },
    {
      "title": "Find the Difference",
      "source_file": "Leetcode/leetcode389.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"abcd\", t = \"abcde\"",
          "expected_output": "\"e\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'e'\nGot (Norm):      'N'\n--- (Raw) ---\nRaw Expected: '\"e\"'\nRaw Got:      'N'"
        },
        {
          "example_index": 1,
          "input": "s = \"\", t = \"y\"",
          "expected_output": "\"y\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'y'\nGot (Norm):      'N'\n--- (Raw) ---\nRaw Expected: '\"y\"'\nRaw Got:      'N'"
        }
      ],
      "generated_code": "import sys\n\ndef find_difference(s: str, t: str) -> str:\n    \"\"\"\n    找出 t 中多出來的那個字元。\n    方式：利用 XOR 逐個對應字元消除，最後剩下的即為多出的字元。\n    \"\"\"\n    xor_val = 0\n    for ch in s:\n        xor_val ^= ord(ch)          # 把 s 的字元對 XOR\n    for ch in t:\n        xor_val ^= ord(ch)          # 再把 t 的字元對 XOR\n    return chr(xor_val)             # xor_val 轉回字元\n\ndef main() -> None:\n    \"\"\"\n    主程式入口：從標準輸入讀取 s 與 t，計算並輸出多出的字元。\n    讀取方式：假設每行一個字串，或兩個字串用空白分隔。\n    \"\"\"\n    data = [line.strip() for line in sys.stdin.read().splitlines() if line.strip()]\n    if len(data) >= 2:\n        s, t = data[0], data[1]\n    elif len(data) == 1:\n        parts = data[0].split()\n        if len(parts) >= 2:\n            s, t = parts[0], parts[1]\n        else:\n            # 只有一行且無空白分隔，直接結束\n            return\n    else:\n        return\n\n    result = find_difference(s, t)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. Problem: find extra letter added after shuffling. Approach: count frequencies or XOR each char. Virtual code: Start, Input s t, compute frequency difference. Use array 26 or map. Or XOR each char of s and t and return result. We'll produce step-by-step virtual code using Decision structure etc.\n\nWe need to output in specified format: each line \"虛擬碼步驟 // 解釋\". Use arrows →, Yes →, No →. Provide steps: Start, Input s t, initialize char difference variable (maybe XOR), iterate over s, XOR with char; iterate over t, XOR; result is added letter. Then output. End.\n\nWe need to produce each line of virtual code. Use bullet like \"→ Step 1: Initialize xor to 0\". Use arrows.\n\nWe need to incorporate decision? Not much decision, but maybe we can show if we want to use frequency array: Decision: if char in array etc. But simpler.\n\nLet's produce:\n\nStart\n→ Input s, t\n→ Step 1: Initialize xor_val = 0 // 初始 XOR 值\n→ Step 2: For each char c in s: xor_val = xor_val XOR c // 排除 s 的字元\n→ Step 3: For each char c in t: xor_val = xor_val XOR c // 加入 t 的字元\n→ Step 4: Output xor_val // xor_val 即為多出的字元\nEnd\n\nNeed to include comments in Chinese. Use 虛擬碼步驟: maybe \"Step 1:\" etc. Provide explanation after //.\n\nAlso need to include arrow indicator: \"→\" before each step.\n\nDecision not needed. But could include a Decision: \"Decision: 是否需要字元頻率?\" but not necessary.\n\nLet's produce. Use \"Start // 程式開始\" etc. Use \"End // 程式結束\".\n\nMake sure each line contains arrow. For steps after Start, use \"→\". For End, maybe \"End //\".\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input s, t // 取得兩個字串  \n→ Step 1: xor_val = 0 // 初始化 XOR 值為 0  \n→ Step 2: For each character c in s: xor_val = xor_val XOR c // 依序將 s 的字元 XOR 掉  \n→ Step 3: For each character c in t: xor_val = xor_val XOR c // 再把 t 的字元 XOR 入去  \n→ Step 4: Output xor_val // xor_val 即為多出來的那個字元  \nEnd // 程式執行結束"
    },
    {
      "title": "Distinct Subsequences",
      "source_file": "Leetcode/leetcode115.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"rabbbit\", t = \"rabbit\"",
          "expected_output": "3",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '3'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: '3'\nRaw Got:      '1'"
        },
        {
          "example_index": 1,
          "input": "s = \"babgbag\", t = \"bag\"",
          "expected_output": "5",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '5'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: '5'\nRaw Got:      '1'"
        }
      ],
      "generated_code": "import sys\n\ndef num_distinct(s, t):\n    m, n = len(s), len(t)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(m + 1):\n        dp[i][0] = 1\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s[i - 1] == t[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j]\n    return dp[m][n]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().splitlines()\n    if not data:\n        sys.exit(0)\n    s = data[0].rstrip('\\n')\n    t = data[1].rstrip('\\n') if len(data) > 1 else ''\n    result = num_distinct(s, t)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to output virtual code lines with explanations, for counting distinct subsequences of s that equal t. Standard DP: dp[i][j] = number of ways to match first j chars of t in first i chars of s. 1-indexed, base dp[0][0] = 1, dp[i][0] = 1, dp[0][j>0] = 0. Recurrence: if s[i-1]==t[j-1], dp[i][j] = dp[i-1][j-1] + dp[i-1][j]; else dp[i][j] = dp[i-1][j]. Return dp[m][n].\n\nWe need to produce virtual code step-by-step with explanation each line. Use Start, End, Decision. Must use arrow etc. Each line: \"虛擬碼步驟 // 解釋\". Use Start. We'll structure: Input strings, compute lengths, initialize dp array, loop i from 1..m, loop j from 1..n, decision on char match. After loops, output dp[m][n].\n\nLet's produce.\n\nWe'll need to note that dp is 2D array maybe use 0..m rows, 0..n columns. For brevity: initialize dp[0][0]=1, dp[i][0]=1. Use decisions.\n\nWe'll output step by step.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: Read input string s and string t // 取得兩個字串\n→ Step 2: Set m ← length of s, n ← length of t // 取得長度\n→ Step 3: Create 2D array dp of size (m+1) x (n+1) // 用來儲存子問題答案\n→ Decision: If n == 0? // t 為空字串\n    Yes → Step 4: Return 1 // 空字串是每個 s 的唯一子序列\n    No  → Step 5: Initialize dp[0][0] ← 1 // 空字串作為子序列的唯一方式\n        → For i from 1 to m: dp[i][0] ← 1 // 任意前綴都能匹配空字串\n        → For j from 1 to n: dp[0][j] ← 0 // 空 s 不能匹配非空 t\n        → For i from 1 to m: // 逐行處理 s\n            → For j from 1 to n: // 逐列處理 t\n                → Decision: s[i-1] == t[j-1]? // 比對當前字元\n                    Yes → dp[i][j] ← dp[i-1][j-1] + dp[i-1][j] // 匹配或跳過\n                    No  → dp[i][j] ← dp[i-1][j] // 只能跳過\n        → Step 6: Return dp[m][n] // 最終答案\nEnd // 程式執行結束\n\nBut must keep each line separate. Need to avoid multi-step lines inside same line? It's fine but each line must be \"虛擬碼步驟 // 解釋\". We have decision blocks. For loops we can combine. For for loops, we can show step then inner loop as separate lines with indentation? The sample uses indentation but we should keep same style.\n\nProbably each line includes arrow \"→\" or \"Yes →\" etc. Indentation with spaces.\n\nLet's produce accordingly. Ensure each line separate.\n\nCheck: We have decision: If n == 0? ; Yes branch simple. But in that case, we would return 1; but then End. The No branch contains initialization and loops, and final return.\n\nWe need to maintain Start and End. Ok.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取字串 s 與 t // 取得兩個輸入字串  \n→ Step 2: 設定 m ← s 的長度, n ← t 的長度 // 確定字串長度  \n→ Step 3: 建立 2D 陣列 dp (m+1) x (n+1) // 用來存放子問題結果  \n→ Decision: n == 0? // t 是否為空字串  \n Yes → Step 4: 回傳 1 // 空字串在任何 s 中只有一種子序列  \n No → Step 5: dp[0][0] ← 1 // 空子序列在空前綴的唯一方式  \n  → For i ← 1 to m: dp[i][0] ← 1 // 任意前綴都能匹配空字串  \n  → For j ← 1 to n: dp[0][j] ← 0 // 空 s 不能匹配非空 t  \n  → For i ← 1 to m: // 逐行處理 s  \n   → For j ← 1 to n: // 逐列處理 t  \n    → Decision: s[i-1] == t[j-1]? // 比對當前字元  \n     Yes → dp[i][j] ← dp[i-1][j-1] + dp[i-1][j] // 匹配或跳過  \n     No  → dp[i][j] ← dp[i-1][j] // 只能跳過  \n  → Step 6: 回傳 dp[m][n] // 取得最終答案  \nEnd // 程式執行結束"
    },
    {
      "title": "Complex Number Multiplication",
      "source_file": "Leetcode/leetcode537.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "\"1+-1i\", \"1+-1i\"",
          "expected_output": "\"0+-2i\"",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpk1hsyedu.py\", line 55, in <module>\n    main()\n  File \"/tmp/tmpk1hsyedu.py\", line 51, in main\n    result = multiply_complex(num1, num2)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpk1hsyedu.py\", line 26, in multiply_complex\n    real1, imag1 = parse_complex(num1)\n                   ^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpk1hsyedu.py\", line 20, in parse_complex\n    return int(real_str), int(imag_str)\n                          ^^^^^^^^^^^^^\nValueError: invalid literal for int() with base 10: '+-1'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\ndef parse_complex(s: str) -> tuple[int, int]:\n    \"\"\"\n    把「實部+虛部i」字串解析成兩個整數 (real, imag)\n    \"\"\"\n    s = s.strip()                     # 去除前後空白\n    if s.endswith('i'):               # 移除尾部的 i\n        s = s[:-1]\n    # 找出虛部符號的位置（從索引 1 開始尋找 '+' 或 '-'）\n    sign_pos = None\n    for i in range(1, len(s)):\n        if s[i] == '+' or s[i] == '-':\n            sign_pos = i\n            break\n    # 取得實部與虛部字串，轉成整數\n    real_str = s[:sign_pos]\n    imag_str = s[sign_pos:]\n    return int(real_str), int(imag_str)\n\ndef multiply_complex(num1: str, num2: str) -> str:\n    \"\"\"\n    計算兩個複數字串的乘積，回傳「實部+虛部i」的字串\n    \"\"\"\n    real1, imag1 = parse_complex(num1)\n    real2, imag2 = parse_complex(num2)\n    # (a+bi)(c+di) = (ac-bd) + (ad+bc)i\n    real_part = real1 * real2 - imag1 * imag2\n    imag_part = real1 * imag2 + imag1 * real2\n    return f\"{real_part}+{imag_part}i\"\n\ndef main() -> None:\n    \"\"\"\n    主程式：從 stdin 讀取兩個複數字串，輸出乘積\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 期望輸入格式為 \"1+1i\",\"1+1i\" 之類的字串\n    try:\n        # 先試著用 ast.literal_eval 解析成元組\n        num1, num2 = ast.literal_eval(data)\n    except Exception:\n        # 失敗時手動切割並去除引號\n        parts = data.split(',')\n        num1 = parts[0].strip().strip('\"').strip(\"'\")\n        num2 = parts[1].strip().strip('\"').strip(\"'\")\n\n    result = multiply_complex(num1, num2)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step with explanations. The problem: multiply two complex numbers given as strings \"a+bi\". Need to parse, multiply: (a+bi)*(c+di) = (ac - bd) + (ad + bc)i. Then format back to string.\n\nWe need to produce step-by-step virtual code: Start, parse num1 into real1, imag1; parse num2; compute; format; return.\n\nUse Decision steps maybe for parsing: find '+', remove 'i', convert to int. Also need to handle negative imaginary part maybe \"a-bi\". So find last 'i', parse before i. The sign is before imag.\n\nImplementation: find index of '+' or '-' between real and imag. For num1: find position of 'i', but easier: find the position of the last '+' or '-' before 'i', ignoring sign of real part. Could find first occurrence of '+' after position 0. Or use split on 'i', remove 'i', then split on '+' or '-'.\n\nSimplify: For each string num:\n- Remove trailing 'i'\n- Replace '-' with '+-' (except leading). Then split on '+', gives two parts: real, imag. Convert to int.\n\nProceed.\n\nLet's write virtual code accordingly.\n\nWe need to use Start, End, Decision, steps, with arrows. Use '→'.\n\nLet's produce lines like:\n\nStart // 程式開始執行\n→ Step 1: Define function multiplyComplex(num1, num2) // 主函式\n→ Decision: 解析 num1? // 解析第一個複數\n    Yes → Step 2: Remove trailing 'i' from num1 // 去除尾部的 i\n    Yes → Step 3: Replace '-' with '+-' except first char // 轉成可分割格式\n    Yes → Step 4: Split on '+' to get [realStr, imagStr] // 取得實部與虛部字串\n    Yes → Step 5: Convert realStr to int real1, imagStr to int imag1 // 轉為整數\n...\nSimilar for num2.\n\nCompute products.\n\nFormat output: combine to string.\n\nReturn.\n\nWe need to provide each line with explanation after //. Provide arrow and indentation for decisions. Ensure each line ends with explanation.\n\nLet's produce about maybe 20 lines.\n\nLet's include decision to handle negative sign? But our method handles.\n\nSimplify: For parsing, we can implement a sub-step parseComplex function. So we can call parseComplex on each string. That would reduce lines.\n\nWe can do:\n\nStep 1: Define parseComplex(str)\n    Inside parseComplex: Remove 'i'; Replace first '-'? But we need to handle minus sign at start: keep leading '-'. Replace all '-' with '+-' except first char. Then split on '+', convert.\n\nThen compute.\n\nLet's produce.\n\nAlso include error check: but not needed.\n\nLet's produce virtual code.\n\nMake sure to keep indent for nested decisions.\n\nOk. Let's write.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Define function multiplyComplex(num1, num2) // 主函式，接收兩個複數字串  \n→ Decision: 需要解析複數字串? // 準備將字串轉成整數部份  \n    Yes → Step 2: Define function parseComplex(s) // 解析單一複數的子函式  \n        → Step 3: Remove trailing 'i' from s // 去掉字串尾端的 i  \n        → Step 4: If s starts with '-' then set sign = -1 else sign = 1 // 處理負號  \n        → Step 5: Remove leading sign from s to get body // 只保留數值部分  \n        → Step 6: Replace all '-' in body with '+-' // 讓負號變成可分割符號  \n        → Step 7: Split body on '+' into parts[0] (realStr) and parts[1] (imagStr) // 取得實部和虛部字串  \n        → Step 8: Convert realStr to integer realVal  \n        → Step 9: Convert imagStr to integer imagVal  \n        → Step 10: Return [realVal, imagVal] // 解析完成  \n    End // parseComplex 函式結束  \n\n→ Step 11: Call parseComplex(num1) → [real1, imag1] // 解析第一個複數  \n→ Step 12: Call parseComplex(num2) → [real2, imag2] // 解析第二個複數  \n\n→ Step 13: Compute productReal = real1 * real2 - imag1 * imag2 // 實部乘法公式  \n→ Step 14: Compute productImag = real1 * imag2 + imag1 * real2 // 虛部乘法公式  \n\n→ Step 15: Convert productReal to string realStr  \n→ Step 16: Convert productImag to string imagStr  \n\n→ Step 17: Format resultStr = realStr + \"+\" + imagStr + \"i\" // 將結果組成字串  \n→ Step 18: Return resultStr // 回傳乘積字串  \nEnd // 程式執行結束"
    },
    {
      "title": "Implement Rand10() Using Rand7()",
      "source_file": "Leetcode/leetcode470.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 1",
          "expected_output": "[2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmphev32fuq.py\", line 28, in <module>\n    results = [solver.rand10() for _ in range(n)]\n               ^^^^^^^^^^^^^^^\n  File \"/tmp/tmphev32fuq.py\", line 13, in rand10\n    a = rand7()\n        ^^^^^\nNameError: name 'rand7' is not defined. Did you mean: 'range'?"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[2,8]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmps07_q3xt.py\", line 28, in <module>\n    results = [solver.rand10() for _ in range(n)]\n               ^^^^^^^^^^^^^^^\n  File \"/tmp/tmps07_q3xt.py\", line 13, in rand10\n    a = rand7()\n        ^^^^^\nNameError: name 'rand7' is not defined. Did you mean: 'range'?"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "[3,8,10]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp6_ia21l8.py\", line 28, in <module>\n    results = [solver.rand10() for _ in range(n)]\n               ^^^^^^^^^^^^^^^\n  File \"/tmp/tmp6_ia21l8.py\", line 13, in rand10\n    a = rand7()\n        ^^^^^\nNameError: name 'rand7' is not defined. Did you mean: 'range'?"
        }
      ],
      "generated_code": "import sys\nimport re\n\n# 假設環境已提供 rand7() API\n# def rand7():\n#     return ...\n\nclass Solution:\n    def rand10(self):\n        \"\"\"產生 1~10 的均勻隨機數，僅使用 rand7()\"\"\"\n        while True:\n            # 兩次 rand7() 產生 1~49 的均勻分布\n            a = rand7()\n            b = rand7()\n            num = (a - 1) * 7 + b          # 1~49\n            if num <= 40:                  # 只接受 1~40，足以映射為 1~10\n                return 1 + (num - 1) % 10  # 映射至 1~10\n\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取 n 的值，例如 \"n = 3\"\n    data = sys.stdin.read()\n    m = re.search(r'\\d+', data)\n    n = int(m.group()) if m else 0\n\n    # 呼叫 rand10() n 次，收集結果\n    solver = Solution()\n    results = [solver.rand10() for _ in range(n)]\n\n    # 輸出結果列表\n    print(results)",
      "virtual_code": "Thinking...\nWe need to produce virtual code with line by line steps. Use Start, Decision, etc. The logic: use rand7 twice to generate 1-49 uniformly: combine two numbers. Then if result <= 40, map to 1-10 by modulo 10. Else repeat. Standard solution.\n\nWe need to produce virtual code. Each line: \"虛擬碼步驟 // 解釋\". Use arrow \"→\". Decision lines. Provide steps: Start, Step 1: repeat loop. Inside: call rand7 twice: a,b. Compute result = (a-1)*7 + b. Decision if result <= 40. Yes -> output (result-1)%10 +1. No -> repeat.\n\nWe'll include End. Provide clear explanation.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: 需要產生 1~10 的隨機數? // 循環直到得到合法值  \n Yes → Step 1: rand7() → a // 產生第一個 1~7 的隨機數  \n  → Step 2: rand7() → b // 產生第二個 1~7 的隨機數  \n  → Step 3: 組合: value = (a - 1) * 7 + b // 產生 1~49 的均勻隨機數  \n  → Decision: value <= 40? // 只接受 1~40 的值，足以映射為 1~10  \n   Yes → Step 4: rand10_value = ((value - 1) % 10) + 1 // 映射為 1~10  \n    → Step 5: return rand10_value // 給出結果  \n   No  → Step 6: 重複整個循環 // 超出 1~40，重新嘗試  \nEnd // 程式執行結束"
    },
    {
      "title": "Expression Add Operators",
      "source_file": "Leetcode/leetcode282.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "num = \"123\", target = 6",
          "expected_output": "[\"1*2*3\",\"1+2+3\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"1*2*3\",\"1+2+3\"]'\nGot (Norm):      '[\"1+2+3\",\"1*2*3\"]'\n--- (Raw) ---\nRaw Expected: '[\"1*2*3\",\"1+2+3\"]'\nRaw Got:      \"['1+2+3', '1*2*3']\""
        },
        {
          "example_index": 1,
          "input": "num = \"232\", target = 8",
          "expected_output": "[\"2*3+2\",\"2+3*2\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"2*3+2\",\"2+3*2\"]'\nGot (Norm):      '[\"2+3*2\",\"2*3+2\"]'\n--- (Raw) ---\nRaw Expected: '[\"2*3+2\",\"2+3*2\"]'\nRaw Got:      \"['2+3*2', '2*3+2']\""
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def addOperators(self, num: str, target: int) -> list[str]:\n        res = []\n\n        def backtrack(index: int, path: str, value: int, last: int):\n            if index == len(num):\n                if value == target:\n                    res.append(path)\n                return\n\n            for i in range(index + 1, len(num) + 1):\n                temp = num[index:i]\n                if len(temp) > 1 and temp[0] == '0':   # avoid leading zeros\n                    continue\n                curr = int(temp)\n                if index == 0:\n                    backtrack(i, temp, curr, curr)\n                else:\n                    backtrack(i, path + '+' + temp, value + curr, curr)\n                    backtrack(i, path + '-' + temp, value - curr, -curr)\n                    backtrack(i, path + '*' + temp,\n                              value - last + last * curr, last * curr)\n\n        backtrack(0, \"\", 0, 0)\n        return res\n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    # 尋找 num 和 target 的定義\n    num_match = re.search(r'num\\s*=\\s*\"([^\"]+)\"', data)\n    target_match = re.search(r'target\\s*=\\s*(-?\\d+)', data)\n\n    if num_match and target_match:\n        num = num_match.group(1)\n        target = int(target_match.group(1))\n    else:\n        # 如果輸入格式不同，直接讀兩行\n        lines = [line.strip() for line in data.strip().splitlines() if line.strip()]\n        if len(lines) >= 2:\n            num = lines[0]\n            target = int(lines[1])\n        else:\n            raise ValueError(\"輸入格式不符合要求\")\n\n    solution = Solution()\n    result = solution.addOperators(num, target)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce pseudocode lines with explanations. Need to design algorithm: backtracking generating expressions, evaluating with precedence. Typical solution: recursively choose next number substring, handle current value, previous operand to handle multiplication. We'll produce steps.\n\nWe must output \"虛擬碼步驟 // 解釋\". Use arrows.\n\nWe'll include Start, End, Decision, Step, etc.\n\nWe need to avoid real code. Provide structured steps.\n\nLet's craft pseudocode:\n\nStart\n→ Step 1: 定義結果列表 results // 用於存放符合目標的表達式\n→ Step 2: 定義遞迴函數 DFS(position, expression, evaluated, previous) // 位置、表達式、已評估值、上一操作數\n→ Decision: 如果 position == length(num) // 到達字串末尾\n    Yes → Decision: if evaluated == target\n        Yes → Step 3: 添加 expression 至 results // 找到合法表達式\n        No → Step 3: // 不滿足目標，返回\n    No → Step 4: 循環 i from position to length(num)-1 // 選取子串\n        → Step 5: currentStr = substring(num, position, i) // 當前數字字串\n        → Decision: if currentStr has leading zero and length>1\n            Yes → Step 6: 跳過此子串 // 不能有前導零\n            No → Step 7: currentNum = integer of currentStr // 轉成數字\n        → Decision: if position == 0 // 第一個數字\n            Yes → Step 8: DFS(i+1, currentStr, currentNum, currentNum) // 直接使用\n            No → Decision: if previous operation was '+'\n                Yes → Step 9: DFS(i+1, expression + '+' + currentStr, evaluated + currentNum, currentNum) // 加\n                No  → Decision: if previous operation was '-'\n                    Yes → Step 10: DFS(i+1, expression + '-' + currentStr, evaluated - currentNum, -currentNum) // 減\n                    No  → Decision: if previous operation was '*'\n                        Yes → Step 11: DFS(i+1, expression + '*' + currentStr, evaluated - previous + previous * currentNum, previous * currentNum) // 乘\n        // Actually we handle '+' '-' '*', but we need to maintain previous for multiplication.\nEnd\n\nBut need to incorporate the standard algorithm: for each operator, call DFS with updated eval and prev.\n\nLet's structure more clearly:\n\nWe'll have DFS(pos, expr, curVal, prev) where prev is the last operand value used in curVal calculation, for handling multiplication.\n\nFor each next num segment (from pos to i):\n\n- nextNum = int(substring)\n- If pos==0: newExpr=nextStr; newVal=nextNum; newPrev=nextNum; DFS(i+1,...)\n- Else:\n    - Add: DFS(i+1, expr+'+'+nextStr, curVal+nextNum, nextNum)\n    - Sub: DFS(i+1, expr+'-'+nextStr, curVal-nextNum, -nextNum)\n    - Mul: DFS(i+1, expr+'*'+nextStr, curVal - prev + prev*nextNum, prev*nextNum)\n\nAlso skip numbers with leading zeros.\n\nWe need to output pseudocode with arrows and comments. Use Decision and Yes →, No →.\n\nLet's craft.\n\nNeed to ensure step lines are incremental, not too many lines. But requirement: each line must contain virtual code and comment.\n\nWe will include nested decisions.\n\nWe'll produce a structured flow.\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 定義結果列表 results = [] // 用於存放符合 target 的表達式\n→ Step 2: 定義遞迴函數 DFS(position, expr, curVal, prev) // position: 下一個待處理位址，expr: 已組成的表達式，curVal: 表達式目前值，prev: 上一個被加乘的操作數\n    → Decision: 如果 position == len(num) // 已遍歷完整字串\n        Yes → Decision: if curVal == target // 評估結果是否符合目標\n            Yes → Step 3: results.append(expr) // 將符合的表達式加入結果\n            No  → Step 3: // 不符合，直接返回\n        No → Step 4: 循環 i 從 position 到 len(num)-1 // 逐個選取可能的數字子串\n            → Step 5: currentStr = num[position : i+1] // 取得子串\n            → Decision: if len(currentStr) > 1 且 currentStr[0] == '0' // 判斷是否為前導零\n                Yes → Step 6: // 跳過此子串，因為不能有前導零\n                    → Continue // 進入下一個 i\n                No  → Step 7: currentNum = int(currentStr) // 轉成整數\n            → Decision: if position == 0 // 第一個數字，無需加運算子\n                Yes → Step 8: DFS(i+1, currentStr, currentNum, currentNum) // 直接進入遞迴\n                No  → Step 9: // 後續位置，需要考慮三種運算子\n                    → Step 10: // 加法\n                        → DFS(i+1, expr + '+' + currentStr, curVal + currentNum, currentNum)\n                    → Step 11: // 減法\n                        → DFS(i+1, expr + '-' + currentStr, curVal - currentNum, -currentNum)\n                    → Step 12: // 乘法（需修正之前的 prev）\n                        → newVal = curVal - prev + (prev * currentNum)\n                        → newPrev = prev * currentNum\n                        → DFS(i+1, expr + '*' + currentStr, newVal, newPrev)\n→ Step 13: 呼叫 DFS(0, '', 0, 0) // 從字串開頭開始遞迴\n→ Step 14: 回傳 results // 傳回所有符合 target 的表達式\nEnd // 程式執行結束\n```"
    },
    {
      "title": "Wiggle Sort II",
      "source_file": "Leetcode/leetcode324.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,5,1,1,6,4]",
          "expected_output": "[1,6,1,5,1,4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[1,6,1,5,1,4]'\nGot (Norm):      '[1,5,1,6,1,4]'\n--- (Raw) ---\nRaw Expected: '[1,6,1,5,1,4]'\nRaw Got:      '[1, 5, 1, 6, 1, 4]'"
        },
        {
          "example_index": 1,
          "input": "nums = [1,3,2,2,3,1]",
          "expected_output": "[2,3,1,3,1,2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,3,1,3,1,2]'\nGot (Norm):      '[1,3,2,3,1,2]'\n--- (Raw) ---\nRaw Expected: '[2,3,1,3,1,2]'\nRaw Got:      '[1, 3, 2, 3, 1, 2]'"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def wiggleSort(self, nums):\n        \"\"\"\n        Rearranges nums into a wiggle sequence:\n        nums[0] < nums[1] > nums[2] < nums[3] ...\n        \"\"\"\n        n = len(nums)\n        for i in range(n - 1):\n            if i % 2 == 0:  # even index: need nums[i] < nums[i+1]\n                if nums[i] > nums[i + 1]:\n                    nums[i], nums[i + 1] = nums[i + 1], nums[i]\n            else:          # odd index: need nums[i] > nums[i+1]\n                if nums[i] < nums[i + 1]:\n                    nums[i], nums[i + 1] = nums[i + 1], nums[i]\n\nif __name__ == \"__main__\":\n    # Read all input from stdin\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n\n    # Expect format like: nums = [1,5,1,1,6,4]\n    # Extract the part after '=' and evaluate it safely\n    try:\n        _, nums_str = raw_input.split('=', 1)\n        nums = eval(nums_str.strip(), {\"__builtins__\": None}, {})\n    except Exception as e:\n        print(f\"Error parsing input: {e}\")\n        sys.exit(1)\n\n    Solution().wiggleSort(nums)\n    print(nums)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. The problem: given integer array nums, reorder to wiggle: nums[0] < nums[1] > nums[2] < nums[3] ... It's known solution: for i from 0 to n-2, if i%2==0, ensure nums[i] < nums[i+1]; else ensure nums[i] > nums[i+1]; if not, swap. Virtual code: Start, Step 1: input array; Step 2: iterate i; Decision: if i%2==0? Yes -> if nums[i] > nums[i+1] -> swap; No -> nothing. For odd: if nums[i] < nums[i+1] -> swap. End. Also mention complexity.\n\nNeed to use virtual code arrow notation. Provide explanation after each line. Ensure each line is separate, no actual code, only steps. Use '→' arrows.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入整數陣列 nums // 從使用者處取得待處理的數字序列  \n→ Step 2: 設定變數 n ← 長度(nums) // 取得陣列長度，方便迴圈控制  \n→ Step 3: 從 i = 0 到 n-2 逐個遞增迴圈 // 檢查每對相鄰元素的關係  \n  Decision: i 為偶數? // 判斷索引屬於「<」位置還是「>」位置  \n   Yes → Decision: nums[i] > nums[i+1]? // 若偶數位，需確保左小於右  \n    Yes → Step 4: 交換 nums[i] 與 nums[i+1] // 若不符合，交換使關係成立  \n    No  → // 已符合 nums[i] < nums[i+1]，不做任何事  \n   No  → Decision: nums[i] < nums[i+1]? // 若奇數位，需確保左大於右  \n    Yes → Step 5: 交換 nums[i] 與 nums[i+1] // 若不符合，交換使關係成立  \n    No  → // 已符合 nums[i] > nums[i+1]，不做任何事  \n→ End // 程式執行結束，nums 已完成 wiggle 排列"
    },
    {
      "title": "Evaluate Division",
      "source_file": "Leetcode/leetcode399.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]",
          "expected_output": "[6.00000,0.50000,-1.00000,1.00000,-1.00000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmppoyu8wc4.py\", line 61, in <module>\n    equations, values, queries = parse_input(data)\n                                 ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmppoyu8wc4.py\", line 52, in parse_input\n    equations = eval(eq_str)\n                ^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2\n                                  ^\nSyntaxError: invalid syntax"
        },
        {
          "example_index": 1,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1.5,2.5,5.0], queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]",
          "expected_output": "[3.75000,0.40000,5.00000,0.20000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpbtie0i42.py\", line 61, in <module>\n    equations, values, queries = parse_input(data)\n                                 ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpbtie0i42.py\", line 52, in parse_input\n    equations = eval(eq_str)\n                ^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1\n                                              ^\nSyntaxError: invalid syntax"
        },
        {
          "example_index": 2,
          "input": "equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]",
          "expected_output": "[0.50000,2.00000,-1.00000,-1.00000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpn_hddgzi.py\", line 61, in <module>\n    equations, values, queries = parse_input(data)\n                                 ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpn_hddgzi.py\", line 52, in parse_input\n    equations = eval(eq_str)\n                ^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [[\"a\",\"b\"]], values = [0\n                        ^\nSyntaxError: invalid syntax"
        }
      ],
      "generated_code": "import sys\nfrom collections import defaultdict\nfrom typing import List\n\nclass Solution:\n    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\n        graph = defaultdict(dict)\n        for (a, b), val in zip(equations, values):\n            graph[a][b] = val\n            graph[b][a] = 1 / val\n\n        def dfs(src: str, dst: str, visited: set) -> float:\n            if src not in graph or dst not in graph:\n                return -1.0\n            if src == dst:\n                return 1.0\n            visited.add(src)\n            for neighbor, weight in graph[src].items():\n                if neighbor not in visited:\n                    res = dfs(neighbor, dst, visited)\n                    if res != -1.0:\n                        return weight * res\n            return -1.0\n\n        result = []\n        for u, v in queries:\n            result.append(dfs(u, v, set()))\n        return result\n\ndef parse_input(line: str):\n    # Find positions of the three keys\n    eq_key = 'equations'\n    val_key = 'values'\n    qry_key = 'queries'\n    eq_start = line.find(eq_key)\n    val_start = line.find(val_key)\n    qry_start = line.find(qry_key)\n\n    def extract(start: int, end: int) -> str:\n        s = line[start:].strip()\n        if s.startswith('='):\n            s = s[1:].strip()\n        return s[:end].strip()\n\n    eq_end = val_start - 1 if val_start > 0 else len(line)\n    val_end = qry_start - 1 if qry_start > 0 else len(line)\n\n    eq_str = extract(eq_start + len(eq_key), eq_end)\n    val_str = extract(val_start + len(val_key), val_end)\n    qry_str = extract(qry_start + len(qry_key), len(line))\n\n    equations = eval(eq_str)\n    values = eval(val_str)\n    queries = eval(qry_str)\n    return equations, values, queries\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    equations, values, queries = parse_input(data)\n    sol = Solution()\n    results = sol.calcEquation(equations, values, queries)\n    formatted = [f\"{r:.5f}\" for r in results]\n    print(f\"[{','.join(formatted)}]\")",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps that solve division equations using graph approach. Provide line by line pseudocode with explanations. Ensure use of arrows. Format: each line \"虛擬碼步驟 // 解釋\". Use Start, End, Decision. Let's design steps: Build graph mapping variable to neighbors with weight ratio. For each query, perform DFS/BFS to find path from C to D, multiply weights. If either variable not in graph or no path, return -1.0.\n\nWe will provide pseudo code in lines.\n\nWe'll include Start, Step building graph, for each query, if variable not exist -> return -1.0. Else DFS. We'll also have decision for path found or not.\n\nLet's write.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空的鄰接表 graph // 用字典保存每個變量的相鄰變量與比值  \n→ Step 2: For each equation [Ai, Bi] with value v  \n    → graph[Ai][Bi] ← v // Ai / Bi = v  \n    → graph[Bi][Ai] ← 1 / v // Bi / Ai = 1/v  \n→ Step 3: 建立答案陣列 results // 用於儲存每個查詢的答案  \n→ Step 4: For each query [Cj, Dj]  \n    → Decision: 是否 Cj 與 Dj 同時存在於 graph?  \n        Yes → Step 5: 執行 DFS 或 BFS 尋找從 Cj 到 Dj 的路徑  \n            → Step 6: 初始 stack/queue ← (Cj, 1.0) // 目前節點與累積乘積  \n            → Step 7: While stack/queue 不是空的  \n                → Step 8: 取出 (current, prod)  \n                → Decision: current 是否等於 Dj?  \n                    Yes → Step 9: results.append(prod) // 找到路徑，記錄答案  \n                    No  → Step 10: For each neighbor, weight in graph[current]  \n                            → Decision: 是否已訪問 neighbor?  \n                                No → stack/queue.add((neighbor, prod * weight))  \n                                Yes → // 跳過已訪問的節點  \n            → Step 11: Decision: 是否未找到 Dj?  \n                Yes → results.append(-1.0) // 沒有路徑  \n                No  → // 已在 Step 9 處理  \n        No  → Step 12: results.append(-1.0) // 其中一個變量不存在  \n→ Step 13: Return results // 所有查詢的答案  \nEnd // 程式執行結束"
    },
    {
      "title": "Concatenated Words",
      "source_file": "Leetcode/leetcode472.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "words = [\"cat\",\"cats\",\"catsdogcats\",\"dog\",\"dogcatsdog\",\"hippopotamuses\",\"rat\",\"ratcatdogcat\"]",
          "expected_output": "[\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]'\nGot (Norm):      '[\"dogcatsdog\",\"catsdogcats\",\"ratcatdogcat\"]'\n--- (Raw) ---\nRaw Expected: '[\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]'\nRaw Got:      '[\"dogcatsdog\", \"catsdogcats\", \"ratcatdogcat\"]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport re\n\ndef can_form(word: str, word_set: set) -> bool:\n    \"\"\"判斷 word 是否能由 word_set 中的單字連結而成.\"\"\"\n    if not word_set:\n        return False\n    dp = [False] * (len(word) + 1)\n    dp[0] = True\n    for i in range(1, len(word) + 1):\n        for j in range(i):\n            if not dp[j]:\n                continue\n            if word[j:i] in word_set:\n                dp[i] = True\n                break\n    return dp[len(word)]\n\ndef find_all_concatenated_words(words):\n    \"\"\"找出所有可由其他單字連接而成的字串.\"\"\"\n    words.sort(key=len)          # 先處理短字，後面可作為組合基礎\n    word_set = set()             # 儲存已確認可被使用的單字\n    result = []\n\n    for word in words:\n        if not word:              # 跳過空字串\n            continue\n        if can_form(word, word_set):\n            result.append(word)\n        word_set.add(word)        # 不管是否為連接詞，都加入字典供後續使用\n    return result\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 取得等號後的字串，並以 JSON 方式解析得到單字列表\n    match = re.search(r'\\[(.*)\\]', data, re.S)\n    if not match:\n        words = []\n    else:\n        # 以 JSON 解析，因為範例使用雙引號\n        words = json.loads(match.group(0))\n    concatenated_words = find_all_concatenated_words(words)\n    # 以 JSON 格式輸出結果\n    print(json.dumps(concatenated_words))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce a virtual code flow for the described algorithm. The requirement: \"Given an array of strings words (without duplicates), return all the concatenated words in the given list of words.\" So we need steps: sort words by length, use a hash set of words seen, check each word if it can be formed by other words using DP or recursion. Then collect concatenated words.\n\nThe output must be virtual code lines, each with explanation. Use arrows and Decision, etc. No real code. Just the steps. Let's produce a structured algorithm:\n\nStart\n→ Step 1: Sort words ascending by length // easier to build dictionary\n→ Step 2: Initialize empty set dictionary // store words processed\n→ Step 3: Initialize empty list result // store concatenated words\n→ Decision: For each word in sorted list\n    Yes → Step 4: If word can be segmented by dictionary // DP check\n        Yes → Step 5: Add word to result\n        No  → Step 6: Add word to dictionary // new word for future segmentation\n→ End // return result\n\nBut we need to provide the DP check as steps: we can embed sub-steps for segmentation.\n\nWe also need to incorporate \"not necessarily distinct\" meaning can reuse same word multiple times.\n\nThe DP: create boolean array dp[0..len] where dp[0]=true. For i from 1 to len, for j from 0 to i-1, if dp[j] and word[j:i] in dictionary then dp[i]=true break. After loop, if dp[len] true and word not empty? But we need at least two words: but since we process sorted ascending, we only add to dictionary after checking. So if a word can be segmented using earlier words, it must be at least two words. So no need separate check.\n\nBut we might want to handle empty string? Not necessary.\n\nAlso we should mention that we skip empty word.\n\nSo let's produce final virtual code accordingly.\n\nWe need to include \"Decision:\" lines for loops.\n\nWe need arrow lines with \"→\".\n\nWe need to include explanatory comments after each line, with //.\n\nAlso must include indentation for nested decisions maybe.\n\nLet's produce:\n\nStart // 程式開始\n→ Step 1: Sort words by length ascending // 方便先處理短字，後面可作為組合基礎\n→ Step 2: Initialize dictionary = empty set // 儲存已確認可被使用的單字\n→ Step 3: Initialize result = empty list // 儲存找到的連接詞\n→ Decision: For each word in sorted words\n    Yes → Step 4: If word is empty string, skip // 跳過空字串\n        No  → Step 5: Perform DP segmentation check using dictionary\n            → Step 5.1: Initialize dp array of size len(word)+1, dp[0] = true // dp[i] 表示前 i 個字可以被分割\n            → Step 5.2: For i from 1 to len(word)\n                → Step 5.2.1: For j from 0 to i-1\n                    → Decision: If dp[j] is true and substring word[j:i] in dictionary\n                        Yes → Step 5.2.1.1: Set dp[i] = true; break inner loop // 找到合法切分\n            → Step 5.3: Decision: If dp[len(word)] is true\n                Yes → Step 5.4: Append word to result // 找到連接詞\n                No  → Step 5.5: Add word to dictionary // 不是連接詞，加入字典供後續使用\n→ End // 程式結束，返回 result\n\nBut we need to use \"Yes →\" and \"No →\" arrows. Use \"Decision:\" before each branch.\n\nAlso we need to ensure each line ends with // explanation.\n\nBut \"Step 5.2.1: For j from 0 to i-1\" is a loop, we might express as Decision? Actually it's loop.\n\nWe might structure loops as \"→ Loop: for i in 1..len(word)\" but arrow lines can show loops.\n\nSimplify: Use \"→ Step 5.2: For i from 1 to len(word)\" comment accordingly.\n\nWe should include the nested loops as sub-steps.\n\nWe need to keep consistent arrow usage.\n\nLet's craft final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort words by length ascending // 先處理短字，方便後續組合  \n→ Step 2: Initialize dictionary = empty set // 儲存已確認可被使用的單字  \n→ Step 3: Initialize result = empty list // 儲存找到的連接詞  \n\n→ Decision: 遍歷 sorted words  \n    Yes → Step 4: If word is empty string, skip // 跳過空字串  \n    No  → Step 5: Perform DP segmentation check using dictionary  \n\n        → Step 5.1: Initialize dp array of size len(word)+1, set dp[0] = true // dp[i] 表示前 i 個字可被分割  \n        → Step 5.2: For i from 1 to len(word)  \n            → Step 5.2.1: For j from 0 to i-1  \n                → Decision: 若 dp[j] 為 true 且 word[j:i] 在 dictionary 中  \n                    Yes → Step 5.2.1.1: 設 dp[i] = true; break inner loop // 找到合法切分  \n        → Step 5.3: Decision: 若 dp[len(word)] 為 true  \n            Yes → Step 5.4: Append word to result // 找到連接詞  \n            No  → Step 5.5: Add word to dictionary // 不是連接詞，加入字典供後續使用  \n\nEnd // 程式執行結束，返回 result"
    },
    {
      "title": "Course Schedule II",
      "source_file": "Leetcode/leetcode210.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]",
          "expected_output": "[0,2,1,3]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[0,2,1,3]'\nGot (Norm):      '[0,1,2,3]'\n--- (Raw) ---\nRaw Expected: '[0,2,1,3]'\nRaw Got:      '[0, 1, 2, 3]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import deque\nfrom typing import List\n\nclass Solution:\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\n        # 建立鄰接清單與入度表\n        graph = [[] for _ in range(numCourses)]\n        indegree = [0] * numCourses\n\n        # 讀取前置課程，建立圖與入度\n        for dest, src in prerequisites:\n            graph[src].append(dest)\n            indegree[dest] += 1\n\n        # 找出入度為 0 的課程，放入佇列\n        queue = deque([i for i in range(numCourses) if indegree[i] == 0])\n        order = []\n\n        # Kahn 演算法進行拓樸排序\n        while queue:\n            node = queue.popleft()\n            order.append(node)\n            for neighbor in graph[node]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    queue.append(neighbor)\n\n        # 若完整排序成功，回傳；否則回傳空列表\n        return order if len(order) == numCourses else []\n\n\ndef parse_input(data: str) -> (int, List[List[int]]):\n    \"\"\"\n    從輸入字串中解析出 numCourses 與 prerequisites。\n    允許輸入形如：\n    'numCourses = 2, prerequisites = [[1,0]]'\n    \"\"\"\n    parts = data.strip().split(',', 1)\n    # 解析 numCourses\n    num_part = parts[0].strip()\n    num = int(num_part.split('=')[1].strip())\n\n    # 解析 prerequisites\n    if len(parts) > 1:\n        pre_part = parts[1].strip()\n        pre = ast.literal_eval(pre_part.split('=')[1].strip())\n    else:\n        pre = []\n\n    return num, pre\n\n\ndef main() -> None:\n    raw_input = sys.stdin.read()\n    if not raw_input:\n        return\n\n    numCourses, prerequisites = parse_input(raw_input)\n    solution = Solution()\n    order = solution.findOrder(numCourses, prerequisites)\n    print(order)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code algorithm for topological sorting Kahn's algorithm. Provide step-by-step pseudocode lines with explanations. Use the required format: each line: virtual code step + space + // explanation. Use arrows and decisions. Start and End. Provide each line sequentially. No actual code, just pseudo steps.\n\nWe should include steps: Start, Build graph adjacency list, compute indegree, initialize queue with zero indegree, while queue not empty, pop, add to result, reduce indegree of neighbors, if neighbor indegree zero push, after loop if result length equals numCourses, return result else empty array. End. Use decisions where needed. Use arrow syntax. Also handle prerequisites array input.\n\nLet's craft.\n\nUse \"→\" arrow for sequence. Indentation for decisions. Use \"Decision:\" lines.\n\nWe must not output actual code. Just steps.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化圖的鄰接清單與入度表 // 為每門課建立空的相鄰清單與入度計數  \n→ Step 2: 遍歷 prerequisites  \n  → Step 2.1: 取得 pair (a, b) // a 需要先修 b  \n   → Step 2.2: 在圖中將 b 加到 a 的鄰接清單 // 表示邊 b → a  \n   → Step 2.3: 入度表 a 的計數 +1 // a 的前置課程數增加  \n→ Step 3: 建立空隊列 queue // 用於存放入度為 0 的課程  \n→ Step 4: 遍歷所有課程 i  \n  → Decision: 若入度表[i] == 0? // 找到沒有前置課程的課程  \n   Yes → Step 4.1: 將 i 放入 queue // 可以立即修習  \n   No  → Step 4.2: 不處理 // 有前置課程，稍後處理  \n→ Step 5: 初始化結果清單 order // 存放最終修課順序  \n→ Decision: 若 queue 為空? // 沒有可開始的課程  \n  Yes → Step 5.1: Return 空清單 // 無法完成所有課程  \n  No  → Step 5.2: 跳至 Step 6  \n→ Step 6: 循環直到 queue 為空  \n  → Step 6.1: 從 queue 取出一門課程 cur  \n   → Step 6.1.1: 將 cur 加入 order // 已修習的課程  \n   → Step 6.1.2: 遍歷 cur 的鄰接課程 next  \n    → Step 6.1.2.1: 入度表[next] -1 // 移除對 cur 的依賴  \n     → Decision: 若入度表[next] == 0? // 依賴已全部解除  \n      Yes → Step 6.1.2.2: 將 next 放入 queue // 現可修習  \n      No  → Step 6.1.2.3: 不處理  \n→ Step 7: Decision: 若 order 的長度 == numCourses? // 所有課程皆已排定  \n  Yes → Step 7.1: Return order // 成功完成課程順序  \n  No  → Step 7.2: Return 空清單 // 存在環路，無法完成  \nEnd // 程式執行結束"
    },
    {
      "title": "Generate Random Point in a Circle",
      "source_file": "Leetcode/leetcode478.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]",
          "expected_output": "[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[-0.02493,-0.38077],[0.82314,0.38945],[0.36572,0.17248]]'\nGot (Norm):      '[null,[-0.20985880215391123,0.824923591491016],[-0.4557524826307494,0.49138110995126755],[0.2599353770744566,0.08217661739486891]]'\n--- (Raw) ---\nRaw Expected: '[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]'\nRaw Got:      '[null, [-0.20985880215391123, 0.824923591491016], [-0.4557524826307494, 0.49138110995126755], [0.2599353770744566, 0.08217661739486891]]'"
        }
      ],
      "generated_code": "import sys\nimport math\nimport random\nimport ast\nimport json\n\nclass Solution:\n    def __init__(self, radius, x_center, y_center):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n\n    def randPoint(self):\n        r = self.radius * math.sqrt(random.random())  # sqrt 保證均勻分布\n        theta = random.uniform(0, 2 * math.pi)\n        x = self.x_center + r * math.cos(theta)\n        y = self.y_center + r * math.sin(theta)\n        return [x, y]\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    # 第一行是命令列表，第二行是參數列表\n    commands = ast.literal_eval(data[0].strip())\n    params = ast.literal_eval(data[1].strip())\n\n    obj = None\n    results = []\n\n    for cmd, arg in zip(commands, params):\n        if cmd == \"Solution\":\n            obj = Solution(*arg)\n            results.append(None)\n        else:\n            method = getattr(obj, cmd)\n            results.append(method(*arg))\n\n    # 使用 json.dumps 讓 None 轉成 null，並保持原始資料格式\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code with explanation line by line. It's a problem: random point in circle. We can use polar coordinates: pick random radius sqrt(r^2 * random) to ensure uniform area; pick random angle [0, 2π). Then compute x = center_x + radius*sqrt(rand)*cos(angle); y = center_y + radius*sqrt(rand)*sin(angle). We need to structure pseudo-code.\n\nWe must follow format: Start, Step, Decision etc. But here we don't need decisions except maybe generating random numbers. But we can include steps like:\n\nStart // Program start\n→ Step 1: Define class Solution with constructor storing radius, center coordinates // initialization\n→ Step 2: Define method randPoint() // returns random point\n    → Step 3: Generate random number u in [0,1) // for radius\n    → Step 4: Compute r = sqrt(u) * radius // scale radius\n    → Step 5: Generate random number theta in [0, 2π) // for angle\n    → Step 6: Compute x = x_center + r * cos(theta) // final x\n    → Step 7: Compute y = y_center + r * sin(theta) // final y\n    → Step 8: Return [x, y] // output\nEnd // Program end\n\nWe might include an explanation for each. Provide as lines of pseudo-code.\n\nMake sure each line ends with comment. Use arrow → for steps. Use Start, End. Ensure each line includes \"虛擬碼步驟\" and comment. \"虛擬碼步驟\" presumably the code like \"Start\", \"→ Step 1:\" etc. Provide explanation after space.\n\nMake sure it's in Traditional Chinese.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Define class Solution(radius, x_center, y_center) // 建立類別並儲存半徑與圓心座標  \n→ Step 2: Store radius → this.radius = radius // 這樣之後可以直接使用  \n→ Step 3: Store x_center → this.xc = x_center // 記錄圓心 X 座標  \n→ Step 4: Store y_center → this.yc = y_center // 記錄圓心 Y 座標  \n→ Step 5: Define method randPoint() // 開始隨機產生點的邏輯  \n    → Step 6: Generate random u in [0,1) // u 用來計算半徑，確保面積均勻  \n    → Step 7: Compute r = sqrt(u) * this.radius // r 為隨機半徑，sqrt 保持均勻分佈  \n    → Step 8: Generate random theta in [0, 2π) // theta 為角度，確保圓周均勻  \n    → Step 9: Compute x = this.xc + r * cos(theta) // 轉換回直角座標 X  \n    → Step 10: Compute y = this.yc + r * sin(theta) // 轉換回直角座標 Y  \n    → Step 11: Return [x, y] // 回傳隨機點  \nEnd // 程式執行結束"
    },
    {
      "title": "Pow(x, n)",
      "source_file": "Leetcode/leetcode50.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 2,
          "input": "x = 2.00000, n = -2",
          "expected_output": "0.25000",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '0.25000'\nGot (Norm):      '4.00000'\n--- (Raw) ---\nRaw Expected: '0.25000'\nRaw Got:      '4.00000'"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef my_pow(x: float, n: int) -> float:\n    \"\"\"快速指數（exponentiation by squaring）\"\"\"\n    if n == 0:\n        return 1.0\n    if n < 0:\n        x = 1.0 / x\n        n = -n\n\n    # 迭代版本避免遞迴深度限制\n    result = 1.0\n    base = x\n    while n > 0:\n        if n & 1:          # n 為奇數\n            result *= base\n        base *= base\n        n >>= 1            # n //= 2\n    return result\n\ndef main() -> None:\n    data = sys.stdin.read()\n    # 從輸入中抽取浮點數與整數\n    numbers = re.findall(r'[-+]?\\d*\\.\\d+|\\d+', data)\n    if len(numbers) < 2:\n        return\n    x = float(numbers[0])\n    n = int(float(numbers[1]))   # 兼容「10.0」形式\n    ans = my_pow(x, n)\n    print(f\"{ans:.5f}\")\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nThe user wants virtual code for pow(x, n) calculation. We need step-by-step pseudo-code with explanations. Should handle negative n? Usually pow(x, n) where n is integer, maybe handle negative? We can include if n < 0. We'll include fast exponentiation (exponentiation by squaring). Steps: Start, Input x, n. Decision: if n==0 return 1. Else if n<0, set result=1/x, n=-n. Then loop while n>0: if n odd, result*=x; x*=x; n//=2. Return result. End. Use virtual arrows. Include decisions. Provide one line per step with // explanation. Use Start, End. Use arrow \"→\". Indent decision branches with \"Yes →\" \"No →\" like example. We'll produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取輸入變數 x, n // 取得底數與指數  \n→ Decision: n 是否等於 0? // 檢查特殊情況  \n    Yes → Step 2: 回傳 1 // x^0 為 1，直接返回  \n    No → Decision: n 是否小於 0? // 處理負指數  \n        Yes → Step 3: 設定 result ← 1 / x // 先取倒數作為結果基礎  \n                         → Step 4: 將 n ← -n // 轉成正整數便於後續計算  \n                         → Decision: 跳至 Step 5 // 直接進行正整數指數計算  \n        No → Step 5: 設定 result ← 1 // 初始累積乘積  \n→ Step 5: 設定 base ← x // 用於平方遞迴的底數  \n→ Step 6: while n > 0 do // 主要計算迴圈  \n    → Decision: n 是否為奇數? // 判斷是否需要乘上 base  \n        Yes → Step 7: result ← result * base // 乘以目前底數  \n        No → Step 8: 跳過乘法 // 不需要直接乘  \n    → Step 9: base ← base * base // 底數平方  \n    → Step 10: n ← n // 2 // 指數右移一位（除以2）  \n→ Step 11: 回傳 result // 完成計算，返回 x^n  \nEnd // 程式執行結束"
    },
    {
      "title": "Remove Element",
      "source_file": "Leetcode/leetcode27.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "nums = [0,1,2,2,3,0,4,2], val = 2",
          "expected_output": "5, nums = [0,1,4,0,3,_,_,_]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '5,nums=[0,1,4,0,3,_,_,_]'\nGot (Norm):      '5,nums=[0,1,3,0,4,_,_,_]'\n--- (Raw) ---\nRaw Expected: '5, nums = [0,1,4,0,3,_,_,_]'\nRaw Got:      '5, nums = [0, 1, 3, 0, 4, _, _, _]'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def removeElement(self, nums, val):\n        \"\"\"Remove all occurrences of val from nums in-place and return new length.\"\"\"\n        write_idx = 0\n        for i in range(len(nums)):\n            if nums[i] != val:\n                nums[write_idx] = nums[i]\n                write_idx += 1\n        return write_idx\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    nums_match = re.search(r'nums\\s*=\\s*(\\[[^\\]]*\\])', data)\n    val_match = re.search(r'val\\s*=\\s*(\\S+)', data)\n\n    if not nums_match or not val_match:\n        return\n\n    nums = ast.literal_eval(nums_match.group(1))\n    val = int(val_match.group(1))\n\n    sol = Solution()\n    k = sol.removeElement(nums, val)\n\n    # Format output: length and list with placeholders for remaining slots\n    out_list = [str(nums[i]) if i < k else '_' for i in range(len(nums))]\n    print(f\"{k}, nums = [{', '.join(out_list)}]\")\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code, step by step, describing algorithm: removing val from array in-place and return new length k. Use two-pointer approach: write pointer i for current index, write pointer j for place to write non-val. Implementation: iterate i, if nums[i] != val then set nums[j] = nums[i]; j++. After loop, return j.\n\nNeed to produce virtual code lines with arrow and comments. Use Start, End, Decision etc. Provide each line.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 定義寫入指標 writeIdx = 0 // 目標位置\n→ Step 2: 循環遍歷 nums (i = 0 to nums.length-1) // 檢查每個元素\n    → Decision: 如果 nums[i] != val? // 判斷是否需要保留\n        Yes → Step 3: nums[writeIdx] = nums[i] // 把非 val 的元素寫入\n             → Step 4: writeIdx = writeIdx + 1 // 移動寫入指標\n        No → Step 5: 省略 // val 元素不處理\nEnd // 返回結果\n→ Step 6: Return writeIdx // k，保留元素個數\n\nBut we need to include arrows: → etc. Use \"Decision:\" with Yes →, No →. We should produce each line separately. For loops we might break into multiple lines? Use indentation like in example.\n\nLet's follow format exactly. For loops, we can use \"Loop:\"? Not in example but we can use Step with loop. We'll just describe loop.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Step 1: writeIdx = 0 // 初始化寫入指標\n→ Step 2: for i from 0 to nums.length-1 // 遍歷所有元素\n    → Decision: nums[i] != val? // 判斷是否保留\n        Yes → Step 3: nums[writeIdx] = nums[i] // 將非 val 元素寫入\n             → Step 4: writeIdx = writeIdx + 1 // 更新寫入指標\n        No  → Step 5: 跳過 // 跳過 val 元素\nEnd // 完成遍歷\n→ Step 6: Return writeIdx // k，返回保留元素個數\n\nLet's ensure each line ends with // 解釋. And each line must be in \"虛擬碼步驟 [空格] // 解釋\". Use arrows and indentation. Use \"→\" before each step inside loop. Indentation may not matter. We need to separate lines. For loop we could treat \"Step 2:\" as loop header, but the decision inside.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: writeIdx = 0 // 初始化寫入指標，準備寫入非 val 的元素  \n→ Step 2: for i from 0 to nums.length-1 // 遍歷整個陣列  \n  Decision: nums[i] != val? // 判斷當前元素是否需要保留  \n   Yes → Step 3: nums[writeIdx] = nums[i] // 把非 val 元素寫入寫入指標位置  \n    → Step 4: writeIdx = writeIdx + 1 // 移動寫入指標到下一個位置  \n   No  → Step 5: 跳過 // 當元素為 val 時不進行任何操作  \nEnd // 完成所有元素的遍歷  \n→ Step 6: Return writeIdx // writeIdx 即為 k，返回保留元素的數量"
    },
    {
      "title": "Shuffle an Array",
      "source_file": "Leetcode/leetcode384.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"], [[[1, 2, 3]], [], [], []]",
          "expected_output": "[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[3,1,2],[1,2,3],[1,3,2]]'\nGot (Norm):      '[null,[2,3,1],[1,2,3],[1,3,2]]'\n--- (Raw) ---\nRaw Expected: '[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]'\nRaw Got:      '[null, [2, 3, 1], [1, 2, 3], [1, 3, 2]]'"
        }
      ],
      "generated_code": "import sys\nimport random\nimport ast\nimport json\n\nclass Solution:\n    def __init__(self, nums):\n        # 原始陣列的深拷貝，避免被外部修改\n        self.original = list(nums)\n\n    def reset(self):\n        # 直接回傳原始陣列\n        return list(self.original)\n\n    def shuffle(self):\n        # 先複製一次，再進行 Fisher-Yates 洗牌\n        arr = list(self.original)\n        n = len(arr)\n        for i in range(n - 1, 0, -1):\n            j = random.randint(0, i)\n            arr[i], arr[j] = arr[j], arr[i]\n        return arr\n\ndef main():\n    # 讀取整個 stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 解析成 (operations, arguments) 的元組\n    ops, args = ast.literal_eval('(' + data + ')')\n\n    res = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            # 建構子，arg 為 list 的 list\n            obj = Solution(arg[0] if arg else [])\n            res.append(None)\n        else:\n            # 取得方法並執行\n            method = getattr(obj, op)\n            ret = method(*arg)\n            res.append(ret)\n    # 將 None 轉成 JSON 的 null\n    print(json.dumps(res))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm that shuffles array with equal probability, using Fisher-Yates. Provide constructor storing original array copy, reset returns original copy, shuffle performs copy of array and shuffles.\n\nWe must output step by step with virtual code and explanation, no real code. Use Start, End, Decision: etc. Also use arrow '→'.\n\nWe'll produce lines:\n\nStart\n→ Step: 初始化 Solution(nums) // store nums and original copy\n→ Step: 定義 original 為 nums 的深拷貝\n→ Step: 定義 current 為 nums 的深拷貝\n→ Step: reset() // return original copy\n→ Step: shuffle() // create copy, shuffle via Fisher-Yates\n\nWe need to include Decision maybe not necessary. But we can illustrate shuffle loop: For i from n-1 down to 1: j = random[0,i], swap.\n\nWe produce virtual code lines:\n\nStart\n→ Step 1: 初始化 Solution(nums) // 保存原始陣列與工作陣列\n→ Step 2: original ← 複製 nums // 原始配置\n→ Step 3: current ← 複製 nums // 用於重置與隨機化\n→ Step 4: Function reset() // 恢復原始順序\n→ Step 5: return original // 回傳原始陣列\n→ Step 6: Function shuffle() // 隨機洗牌\n→ Step 7: array ← 複製 current // 先複製以保持原始不變\n→ Step 8: n ← array.length // 取得長度\n→ Step 9: For i ← n-1 downto 1 // Fisher–Yates 迴圈\n    → Step 10: j ← random integer in [0, i] // 隨機選擇\n    → Step 11: swap array[i] 與 array[j] // 交換元素\n→ Step 12: return array // 回傳洗牌結果\nEnd\n\nNeed to maintain format with arrow and explanation.\n\nAlso might need to show \"Decision\" not necessary.\n\nWe'll output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 Solution(nums) // 傳入原始整數陣列  \n→ Step 2: original ← 複製 nums // 儲存原始排列以供重置使用  \n→ Step 3: current ← 複製 nums // 建立一個工作副本  \n→ Step 4: Function reset() // 定義重置方法  \n→ Step 5: return original // 回傳原始陣列，並保持不變  \n→ Step 6: Function shuffle() // 定義洗牌方法  \n→ Step 7: array ← 複製 current // 先複製工作陣列以免改變原始資料  \n→ Step 8: n ← array.length // 取得陣列長度  \n→ Step 9: For i ← n-1 downto 1 // Fisher–Yates 迴圈從尾端開始  \n    → Step 10: j ← 隨機整數 [0, i] // 隨機選擇 0~i 的索引  \n    → Step 11: swap array[i] 與 array[j] // 交換兩個位置的元素  \n→ Step 12: return array // 回傳隨機排列後的陣列  \nEnd // 程式執行結束"
    },
    {
      "title": "Subsets",
      "source_file": "Leetcode/leetcode78.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nGot (Norm):      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nRaw Got:      '[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\ndef subsets(nums):\n    \"\"\"Return all subsets (power set) of a list of unique integers.\"\"\"\n    res = []\n\n    def backtrack(start, path):\n        # 目前的 path 是一個合法子集，先加入結果\n        res.append(path[:])\n        # 從 start 開始嘗試加入後續元素\n        for i in range(start, len(nums)):\n            path.append(nums[i])          # 選擇 nums[i]\n            backtrack(i + 1, path)        # 再往後搜尋\n            path.pop()                    # 回溯，移除最後加入的元素\n\n    backtrack(0, [])\n    return res\n\ndef main():\n    \"\"\"讀取輸入、計算子集並輸出結果。\"\"\"\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n\n    # 允許輸入形式為 'nums = [1,2,3]' 或直接 '[1,2,3]'\n    raw_input = raw_input.strip()\n    if raw_input.lower().startswith('nums'):\n        idx = raw_input.find('[')\n        if idx != -1:\n            raw_input = raw_input[idx:]\n\n    try:\n        nums = ast.literal_eval(raw_input)\n    except Exception:\n        # 如果 literal_eval 失敗，退而使用 eval（僅限安全輸入）\n        nums = eval(raw_input, {})\n\n    result = subsets(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce a step-by-step virtual code for generating all subsets of an integer array with unique elements, return all subsets (power set). The virtual code should use arrows and structure like Start, Decision, End. Each line must have virtual code step + space + // explanation.\n\nWe must not output real code, only virtual steps. It's a typical backtracking or iterative solution. We'll outline steps: start, initialize result list, call backtrack function with index 0 and current subset empty, in backtrack: add current subset to result, iterate from index to len(nums), include nums[i] in subset and recurse. Also remove after recursion.\n\nWe'll produce virtual steps. Use indentation for decisions. Need to follow the formatting: each line \"虛擬碼步驟 [space] // 解釋/說明\". Use arrow \"→\". Use \"Decision:\" for condition. Provide Start and End.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 result 為空集合 // 用於存放所有子集  \n→ Step 2: 定義遞迴函式 backtrack(index, current) // index 指定目前考慮的位置，current 儲存正在構造的子集  \n→ Step 3: backtrack(0, []) // 開始從索引 0 並且子集為空  \n\n→ Decision: 是否已完成所有元素? // 判斷 index 是否已超過陣列長度  \n    Yes → Step 4: 將 current 加入 result // 目前子集完成，加入結果  \n    No  → Step 5: 將 current 加入 result // 在每一步都把目前子集加入結果  \n→ Decision: 是否還有元素可加入? // 確認是否還有元素待考慮  \n    Yes → Loop for i from index to len(nums)-1  \n        → Step 6: 將 nums[i] 加入 current // 把當前元素納入子集中  \n        → Step 7: backtrack(i+1, current) // 以下一個索引繼續遞迴  \n        → Step 8: 從 current 移除最後一個元素 // 回溯，移除已加入的元素  \n    No  → // 迴圈結束，回溯到上一層  \n\nEnd // 程式執行結束，返回 result，包含所有子集"
    },
    {
      "title": "Different Ways to Add Parentheses",
      "source_file": "Leetcode/leetcode241.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "expression = \"2-1-1\"",
          "expected_output": "[0,2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[0,2]'\nGot (Norm):      '[2,0]'\n--- (Raw) ---\nRaw Expected: '[0,2]'\nRaw Got:      '[2,0]'"
        },
        {
          "example_index": 1,
          "input": "expression = \"2*3-4*5\"",
          "expected_output": "[-34,-14,-10,-10,10]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[-34,-14,-10,-10,10]'\nGot (Norm):      '[-34,-10,-14,-10,10]'\n--- (Raw) ---\nRaw Expected: '[-34,-14,-10,-10,10]'\nRaw Got:      '[-34,-10,-14,-10,10]'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def diffWaysToCompute(self, expression: str):\n        memo = {}\n\n        def ways(expr: str):\n            if expr in memo:\n                return memo[expr]\n\n            res = []\n            for i, ch in enumerate(expr):\n                if ch in '+-*':\n                    left = ways(expr[:i])\n                    right = ways(expr[i+1:])\n                    for l in left:\n                        for r in right:\n                            if ch == '+':\n                                res.append(l + r)\n                            elif ch == '-':\n                                res.append(l - r)\n                            else:\n                                res.append(l * r)\n\n            if not res:\n                res.append(int(expr))\n            memo[expr] = res\n            return res\n\n        return ways(expression)\n\n\ndef main():\n    data = sys.stdin.read().strip()\n    # 尋找引號內的表達式\n    match = re.search(r'\"([^\"]*)\"', data)\n    if match:\n        expr = match.group(1)\n    else:\n        # 若沒有引號，直接使用整行內容\n        expr = data\n\n    solution = Solution()\n    results = solution.diffWaysToCompute(expr)\n    # 以無空格的方式輸出列表\n    output = '[' + ','.join(map(str, results)) + ']'\n    print(output)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for computing all possible results from expression string. The algorithm is typical divide and conquer with memoization. Provide step-by-step. Use virtual steps: Start, Decision, etc. Need to handle parsing and recursion. Also maybe dynamic programming. Use memo dict.\n\nWe need to produce lines: e.g., Start // 程式開始執行. Then Step: Parse input string into list maybe tokens. But algorithm uses recursion on substring: for each operator, compute left results and right results recursively.\n\nWe need to ensure to include memoization: map from substring to list of results.\n\nWe need to handle base case when substring contains no operator, parse integer.\n\nWe produce explanation lines.\n\nLet's structure:\n\nStart // 程式開始執行\n→ Step 1: 定義遞迴函式 diffWaysToCompute(substring) // 以子字串計算所有結果\n\nBut need to show Decision etc.\n\nAlso we may show memoization: Decision: 若 substring 已在 Memo? Yes -> return cached // avoid recomputation\n\nDecision: 若 substring 為純數字? Yes -> return [int(substring)] // base case\n\nElse:\n→ Step: 建立 results = [] // 初始化結果列表\n→ Step: for i in range(len(substring)):\n    Decision: 若 substring[i] 是運算子? Yes -> // 進行分割\n        left_sub = substring[:i]\n        right_sub = substring[i+1:]\n        left_results = diffWaysToCompute(left_sub)\n        right_results = diffWaysToCompute(right_sub)\n        for each l in left_results:\n            for each r in right_results:\n                compute l op r\n                append to results\n    End for\n→ Step: Memoize results\n→ Step: return results\n\nThen final call: all_results = diffWaysToCompute(expression)\n→ Step: 輸出 all_results // 返回結果\n\nEnd // 程式結束\n\nNeed to use arrow formatting. Each line: '虛擬碼步驟 // 解釋'. Use arrow '→' for steps. Decision lines 'Decision: ...? // 解釋'.\n\nAlso we need to incorporate loops, recursion.\n\nMake sure each line is separate.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義遞迴函式 diffWaysToCompute(substring) // 以子字串計算所有結果  \n→ Decision: 如果 substring 已在 Memo? // 檢查是否已計算過  \n    Yes → Step 2: Return Memo[substring] // 回傳快取結果  \n    No → Decision: 如果 substring 為純數字? // 檢查是否為基礎情形  \n        Yes → Step 3: Return [int(substring)] // 直接回傳數字本身  \n        No → Step 4: 初始化 results = [] // 用於儲存所有可能結果  \n→ Step 5: for i in 0 .. len(substring)-1: // 遍歷子字串索引  \n    Decision: 如果 substring[i] 是運算子 (+, -, *)? // 判斷是否為分割點  \n        Yes → Step 6: left_sub = substring[:i] // 取得左側子字串  \n            → Step 7: right_sub = substring[i+1:] // 取得右側子字串  \n            → Step 8: left_results = diffWaysToCompute(left_sub) // 重新遞迴左側  \n            → Step 9: right_results = diffWaysToCompute(right_sub) // 重新遞迴右側  \n            → Step 10: for each l in left_results:  \n                    for each r in right_results:  \n                        Decision: 根據 operator 計算 l op r?  \n                            Yes → Step 11: result = l op r // 執行相應運算  \n                            → Step 12: Append result to results // 加入結果列表  \n→ Step 13: Memo[substring] = results // 將結果快取起來  \n→ Step 14: Return results // 回傳所有可能結果  \n→ Step 15: all_results = diffWaysToCompute(expression) // 主程式呼叫遞迴  \n→ Step 16: 輸出 all_results // 將結果傳回  \nEnd // 程式執行結束"
    },
    {
      "title": "Contains Duplicate III",
      "source_file": "Leetcode/leetcode220.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,1], indexDiff = 3, valueDiff = 0",
          "expected_output": "true",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpuxn9x_pu.py\", line 48, in <module>\n    nums, index_diff, value_diff = parse_input(raw_input)\n                                   ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpuxn9x_pu.py\", line 36, in parse_input\n    nums = ast.literal_eval(value)\n           ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "nums = [1,5,9,1,5,9], indexDiff = 2, valueDiff = 3",
          "expected_output": "false",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpzhu0sa_m.py\", line 48, in <module>\n    nums, index_diff, value_diff = parse_input(raw_input)\n                                   ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpzhu0sa_m.py\", line 36, in parse_input\n    nums = ast.literal_eval(value)\n           ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\n\ndef contains_nearby_almost_duplicate(nums, index_diff, value_diff):\n    \"\"\"\n    檢查是否存在兩個索引 (i, j) 滿足：\n    1. i != j\n    2. abs(i - j) <= index_diff\n    3. abs(nums[i] - nums[j]) <= value_diff\n    若存在返回 True，否則 False。\n    \"\"\"\n    n = len(nums)\n    for i in range(n):\n        # j 必須比 i 大，並且距離不超過 index_diff\n        upper = min(n - 1, i + index_diff)\n        for j in range(i + 1, upper + 1):\n            if abs(nums[i] - nums[j]) <= value_diff:\n                return True\n    return False\n\ndef parse_input(data: str):\n    \"\"\"\n    解析輸入字串，格式示例：\n    'nums = [1,2,3,1], indexDiff = 3, valueDiff = 0'\n    返回 nums, indexDiff, valueDiff。\n    \"\"\"\n    parts = [p.strip() for p in data.split(',')]\n    nums = None\n    index_diff = None\n    value_diff = None\n    for part in parts:\n        key, _, value = part.partition('=')\n        key = key.strip()\n        value = value.strip()\n        if key.lower() == 'nums':\n            nums = ast.literal_eval(value)\n        elif key.lower() == 'indexdiff':\n            index_diff = int(value)\n        elif key.lower() == 'valuediff':\n            value_diff = int(value)\n    return nums, index_diff, value_diff\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取所有資料\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n    nums, index_diff, value_diff = parse_input(raw_input)\n    result = contains_nearby_almost_duplicate(nums, index_diff, value_diff)\n    print('true' if result else 'false')",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. The algorithm: iterate pairs with sliding window? We need to check conditions. Use nested loops but with constraints: index difference <= indexDiff, so j ranges from i+1 to i+indexDiff. Also check absolute difference of values <= valueDiff. Return true if found. Otherwise false. Complexity O(n * indexDiff). We'll produce virtual code accordingly. Include start, end. Provide explanation after each line. Use arrow notation.\n\nWe must not output real code, just virtual steps. So use steps like \"Step 1: Initialize result as false\" etc. Use Decision blocks. Provide brief explanation. Ensure each line ends with // ... comment. Use Start, End. Provide \"→\" arrow to indicate flow. Provide indentation for nested steps? Use 4 spaces? Use sample formatting. Provide arrow for decision lines. Provide indent using spaces.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 取得輸入陣列 nums, 整數 indexDiff, valueDiff // 初始化輸入\n→ Step 2: 設定變數 result 為 false // 結果預設為 false\n→ Step 3: 對每個索引 i 從 0 到 nums.Length-1 迴圈 // 外層迴圈遍歷所有元素\n    → Step 3.1: 對每個索引 j 從 i+1 到 min(i+indexDiff, nums.Length-1) 迴圈 // 內層迴圈只檢查距離不超過 indexDiff 的元素\n        → Decision: abs(nums[i] - nums[j]) <= valueDiff? // 檢查值差是否符合條件\n            Yes → Step 3.1.1: 將 result 設為 true // 找到符合條件的對\n            Yes → Step 3.1.1: 返回 result // 直接返回 true\n            No  → // 無需做任何事，繼續下一個 j\n    → Decision: result 為 true? // 若已找到對，提前終止外層迴圈\n        Yes → Step 3.2: 跳出外層迴圈 // 已找到，避免不必要計算\n        No  → // 繼續下一個 i\n→ Step 4: 返回 result // 若未找到，返回 false\nEnd // 程式執行結束\n\nBut we need to show arrow lines and indent correctly. Use \"→\" arrow for steps. For decision lines: \"Decision: ...\". For Yes/No branches use indent and arrow.\n\nMake sure each line has \" // \" comment.\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 取得輸入陣列 nums、整數 indexDiff、valueDiff // 初始化輸入\n→ Step 2: 設定變數 result 為 false // 結果預設為 false\n→ Step 3: 對每個索引 i 從 0 到 nums.Length-1 迴圈 // 外層迴圈遍歷所有元素\n    → Step 3.1: 對每個索引 j 從 i+1 到 min(i+indexDiff, nums.Length-1) 迴圈 // 內層迴圈只檢查距離不超過 indexDiff 的元素\n        → Decision: abs(nums[i] - nums[j]) <= valueDiff? // 檢查值差是否符合條件\n            Yes → Step 3.1.1: 設定 result 為 true // 找到符合條件的對\n            Yes → Step 3.1.1: 返回 result // 直接返回 true\n            No  → // 無需做任何事，繼續下一個 j\n    → Decision: result 為 true? // 若已找到對，提前終止外層迴圈\n        Yes → Step 3.2: 跳出外層迴圈 // 已找到，避免不必要計算\n        No  → // 繼續下一個 i\n→ Step 4: 返回 result // 若未找到，返回 false\nEnd // 程式執行結束\n```"
    },
    {
      "title": "Random Pick with Weight",
      "source_file": "Leetcode/leetcode528.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\",\"pickIndex\"], [[[1]],[]]",
          "expected_output": "[null,0]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpk7_5qwui.py\", line 45, in <module>\n    main()\n  File \"/tmp/tmpk7_5qwui.py\", line 28, in main\n    ops = ast.literal_eval(ops_part.strip())\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [\"Solution\"\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"], [[[1,3]],[],[],[],[],[]]",
          "expected_output": "[null,1,1,1,1,0]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpu01mo50x.py\", line 45, in <module>\n    main()\n  File \"/tmp/tmpu01mo50x.py\", line 28, in main\n    ops = ast.literal_eval(ops_part.strip())\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [\"Solution\"\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nimport random\nimport bisect\n\nclass Solution:\n    def __init__(self, w):\n        \"\"\"建立前綴總和陣列並記錄總權重。\"\"\"\n        self.prefix_sum = []\n        total = 0\n        for weight in w:\n            total += weight\n            self.prefix_sum.append(total)\n        self.total = total\n\n    def pickIndex(self):\n        \"\"\"隨機挑選一個索引，機率與權重成正比。\"\"\"\n        target = random.randint(1, self.total)          # 產生 1 ~ total 的隨機整數\n        return bisect.bisect_left(self.prefix_sum, target)  # 找到第一個不小於 target 的索引\n\ndef main():\n    # 讀取整個輸入，並拆分成兩個部分：操作列表與對應的參數\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n    ops_part, args_part = raw.split(',', 1)\n    ops = ast.literal_eval(ops_part.strip())\n    args = ast.literal_eval(args_part.strip())\n\n    results = []\n    instance = None\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            instance = Solution(*arg)\n            results.append(None)          # 建構子回傳 null\n        else:\n            # 取得方法並執行，將回傳值加入結果\n            method = getattr(instance, op)\n            results.append(method(*arg))\n    # 輸出 JSON 格式，None 會轉成 null\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce step-by-step virtual code for implementing pickIndex. It includes preprocessing: build prefix sums. Then pick random number between 1 and total weight. Binary search to find index. We'll produce virtual code lines. Use Start, End, Decision. Include comments after space. Use arrow for each step. Also mention initialization inside constructor? We'll assume class with constructor that receives w. So steps: Start, compute prefix sums, store total weight. Then Step: pick random number. Then decision: binary search loop. Provide explanation. Use arrows accordingly. Provide each line separately. Let's craft.\n\nWe need to output only virtual code lines. Each line includes explanation after a space. Ensure arrow and decision syntax. We'll include indentation maybe but not necessary. Provide steps: Start, Step 1: Initialize prefix sum array, etc.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: 建立 prefixSum 陣列，長度為 w.length // 用於儲存前綴總和\n→ Step 2: prefixSum[0] = w[0] // 第一個前綴總和即為第一個權重\n→ Decision: 從 i = 1 到 w.length-1? // 迭代填充後續前綴總和\n    Yes → Step 3: prefixSum[i] = prefixSum[i-1] + w[i] // 每個前綴總和為前一個加上當前權重\n    No  → End // 前綴總和計算完成\n→ Step 4: totalWeight = prefixSum[w.length-1] // 總權重等於最後一個前綴總和\n→ Step 5: 產生隨機整數 r 在 [1, totalWeight] 之間 // 隨機選擇一個權重值\n→ Decision: index = 0 // 初始索引\n→ Decision: index < w.length? // 進行二分搜尋\n    Yes → Decision: r <= prefixSum[index]? // r 是否小於等於當前前綴總和\n        Yes → Step 6: return index // 找到對應索引，返回結果\n        No  → Step 7: index = index + 1 // 繼續搜尋下一個索引\n    No  → Step 8: return index // 搜尋結束，返回最終索引\nEnd // 程式執行結束\n\nBut binary search should use while low <= high. We can outline decision loops. Maybe simpler: Use while loop. We'll include Decision: low <= high? but we need to maintain low/high. Let's rewrite more formally:\n\nStart\n→ Step 1: prefixSum = []\n→ Step 2: prefixSum[0] = w[0]\n→ Decision: i = 1 to w.length-1?\n    Yes → Step 3: prefixSum[i] = prefixSum[i-1] + w[i]\n    No  → End\n\nBut we can't use for loop with decision; might use Decision inside.\n\nAlternatively we can summarise algorithm in steps. But requirement is to be \"逐行\" and use Decision, arrows.\n\nWe can present steps more abstractly: Build prefix, pick random, binary search.\n\nWe can use a Decision with binary search logic:\n\n→ Decision: low = 0, high = w.length - 1\n    While low <= high:\n        mid = (low + high) // 2\n        Decision: r <= prefixSum[mid]?\n            Yes → high = mid - 1\n            No  → low = mid + 1\n→ Step 6: return low // low will be the smallest index where r <= prefixSum[index]\n\nBut need to represent loops with Decision. Could use recursion style.\n\nGiven the requirement, we can just provide high-level steps.\n\nLet's produce final virtual code accordingly.\n\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: prefixSum ← 空陣列 // 用於儲存每個索引的前綴總和\n→ Step 2: prefixSum[0] ← w[0] // 第一個前綴總和即為第一個權重\n→ Decision: i = 1 到 w.length-1? // 逐個填寫剩餘的前綴總和\n    Yes → Step 3: prefixSum[i] ← prefixSum[i-1] + w[i] // 前綴總和等於前一個加上當前權重\n    No  → End // 前綴總和計算完成\n→ Step 4: totalWeight ← prefixSum[w.length-1] // 總權重等於最後一個前綴總和\n→ Step 5: r ← 隨機整數(1, totalWeight) // 產生一個在 [1, totalWeight] 之間的隨機整數\n→ Step 6: low ← 0 // 二分搜尋的左邊界\n→ Step 7: high ← w.length - 1 // 二分搜尋的右邊界\n→ Decision: low ≤ high? // 進行二分搜尋\n    Yes → Step 8: mid ← (low + high) // 2 // 計算中間索引\n        → Decision: r ≤ prefixSum[mid]? // 判斷 r 是否落在前綴總和區間內\n            Yes → Step 9: high ← mid - 1 // r 在左半區，縮小右邊界\n            No  → Step 10: low ← mid + 1 // r 在右半區，縮小左邊界\n        → Decision: low ≤ high? // 仍需要繼續搜尋嗎？\n            Yes → 回到 Decision: low ≤ high?\n            No  → Step 11: return low // low 為最小索引，使得 r ≤ prefixSum[low]\n    No  → Step 12: return low // 若未進入迴圈，直接返回 low\nEnd // 程式執行結束"
    },
    {
      "title": "H-Index II",
      "source_file": "Leetcode/leetcode275.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "citations = [0,1,3,5,6]",
          "expected_output": "3",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '3'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: '3'\nRaw Got:      '1'"
        },
        {
          "example_index": 1,
          "input": "citations = [1,2,100]",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '1'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\ndef h_index(citations):\n    n = len(citations)\n    left, right = 0, n - 1\n    ans = 0\n    while left <= right:\n        mid = (left + right) // 2\n        if citations[mid] >= n - mid:\n            ans = n - mid\n            left = mid + 1\n        else:\n            right = mid - 1\n    return ans\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        print(0)\n        sys.exit()\n    # Expect format like: citations = [0,1,3,5,6]\n    if '=' in data:\n        _, expr = data.split('=', 1)\n    else:\n        expr = data\n    citations = ast.literal_eval(expr.strip())\n    print(h_index(citations))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps with explanation. The problem: given sorted array, find h-index via binary search. Steps: start, low=0, high=n-1, while low<=high: mid=(low+high)//2; citations[mid] >= n-mid? because number of papers with >= citations[mid] is n-mid. If condition true: low=mid+1, else high=mid-1. After loop, return low? Actually h-index = n - high? Let's derive: After loop, high is last index where condition false? We want maximum h such that condition holds. Standard solution: answer = n - high. If high is last index where condition true, answer n - (high+1)??? Let's test: citations=[0,1,3,5,6], n=5. Binary search finds high=3? Let's simulate. mid 2 (3) citations[2]=3 >= n-2=3? yes so low=3. mid=3 citations[3]=5>=2? yes low=4. mid=4 citations[4]=6>=1? yes low=5. loop ends low=5 high=4. So answer n - high -1? high=4. n - (high+1)=5-5=0 wrong. But we need h=3? Wait correct h-index for [0,1,3,5,6] is 3. Let's compute answer as low? low=5? not correct. Let's compute n - high? 5-4=1 wrong. Another approach: answer = n - low? low=5 =>0 wrong. Let's examine known algorithm: while low <= high: mid = (low+high)//2; if citations[mid] >= n - mid: answer = n - mid; low = mid + 1 else high = mid -1. After loop return answer. This yields correct. So use variable answer. Implementation steps.\n\nWe produce virtual code line by line, with explanation. Use Start, End, Decision.\n\nLet's generate.\n\nWe'll produce: Start // 程式開始\n\n→ Step 1: 設定 n ← citations.length // 取得文章總數\n\n→ Step 2: low ← 0 // 初始化搜尋下限\n\n→ Step 3: high ← n - 1 // 初始化搜尋上限\n\n→ Step 4: answer ← 0 // 預設 h-index\n\n→ Step 5: Decision: low ≤ high? // 判斷是否還有未搜尋區間\n\n    Yes → Step 6: mid ← (low + high) // 2 // 取中間索引\n\n    → Decision: citations[mid] ≥ n - mid? // 檢查是否有至少 n-mid 篇被至少 citations[mid] 次引用\n\n        Yes → Step 7: answer ← n - mid // 更新 h-index 為 n-mid\n\n            → Step 8: low ← mid + 1 // 搜尋右半邊尋找更大 h\n\n        No  → Step 9: high ← mid - 1 // 搜尋左半邊尋找符合條件的索引\n\n    No → End // 搜尋完成\n\n→ Step 10: Output answer // 回傳最終 h-index\n\nEnd // 程式結束\n\nMake sure each line ends with // 解釋. Use virtual code syntax: \"Start //...\" \"→ Step ...\" etc.\n\nAlso we need arrow formatting: Use \"→\" before steps. For decisions, use \"Decision: ...\". Indent inside? The sample shows indentation via spaces. Use two spaces indent. We'll follow that.\n\nLet's produce final.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: n ← citations.length // 取得論文總數\n→ Step 2: low ← 0 // 設定搜尋下限為陣列首指標\n→ Step 3: high ← n - 1 // 設定搜尋上限為陣列尾指標\n→ Step 4: answer ← 0 // 初始化 h-index 結果為 0\n→ Step 5: Decision: low ≤ high? // 判斷是否還有未搜尋的區間\n    Yes → Step 6: mid ← (low + high) // 2 // 取得中間索引\n        → Decision: citations[mid] ≥ n - mid? // 檢查該索引所對應的引用數是否能滿足 h-index 條件\n            Yes → Step 7: answer ← n - mid // 更新 h-index 為可行的最大值\n                → Step 8: low ← mid + 1 // 在右半邊尋找可能更大的 h\n            No  → Step 9: high ← mid - 1 // 在左半邊尋找符合條件的索引\n    No → End // 搜尋結束\n→ Step 10: Output answer // 回傳最終計算出的 h-index\nEnd // 程式執行結束\n```"
    }
  ]
}