{
  "run_index": 31,
  "total_files_found": 391,
  "total_files_processed": 323,
  "files_skipped": 68,
  "files_failed_load": 0,
  "---": "--- (以下基於 *題目* 總數) ---",
  "total_problems_attempted": 334,
  "generation_and_validation_success_count": 296,
  "generation_or_validation_failure_count": 38,
  "failed_cases_details": [
    {
      "title": "統計文字行數",
      "source_file": "900.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "（假設 data.txt 內容如下）\\nHello\\nPython\\nWorld",
          "expected_output": "檔案共有 3 行",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '檔案共有3行'\nGot (Norm):      '檔案共有1行'\n--- (Raw) ---\nRaw Expected: '檔案共有 3 行'\nRaw Got:      '檔案共有 1 行'"
        }
      ],
      "generated_code": "def main():\n    import sys\n    content = sys.stdin.read()\n    if content:\n        with open('data.txt', 'w', encoding='utf-8') as f:\n            f.write(content)\n    try:\n        with open('data.txt', 'r', encoding='utf-8') as f:\n            lines = f.readlines()\n            print('檔案共有', len(lines), '行')\n    except FileNotFoundError:\n        print('找不到檔案！')\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output line by line virtual code, each line with \"虛擬碼步驟 // 解釋\". Use Start, End, Decision. Should include with and try/except logic. We'll produce the steps accordingly.\n\nWe need to consider reading file, counting lines. If file not found, catch FileNotFoundError, print message. We'll use with open('data.txt', 'r') as f: lines = f.readlines(); count = len(lines). Then output.\n\nBut virtual code, not actual code. So we produce steps like:\n\nStart\n→ Step 1: 設定檔案路徑 // 指定要開啟的檔案\n→ Step 2: 嘗試開啟檔案並讀取內容 // 使用 try 進行錯誤捕捉\n→ Decision: 檔案是否成功開啟? // 判斷是否進入 try 成功\n    Yes → Step 3: 讀取所有行並計算行數 // 用 with 語法\n    No → Step 4: 捕捉 FileNotFoundError // 將錯誤訊息印出\n\nBut we need to incorporate try/except within virtual code. The structure can be: Step 2: try block begins; Step 2a: with open...; Step 3: count lines; Step 4: print count; Step 5: except FileNotFoundError: print error. Finally End.\n\nWe must maintain the pattern: Each line with arrow if necessary, or Decision: etc.\n\nLet's craft a step-by-step:\n\nStart // 程式開始執行\n→ Step 1: 設定檔案路徑為 'data.txt' // 定義要開啟的檔案名稱\n→ Step 2: 進入 try 區塊 // 開始錯誤捕捉流程\n    → Step 2a: 使用 with open('data.txt', 'r') as file // 打開檔案並確保關閉\n        → Step 2b: 讀取所有行並存入 lines // 取得檔案內容\n        → Step 2c: 計算 lines 的長度並存入 line_count // 行數統計\n        → Step 2d: 輸出 line_count // 顯示行數\n→ Decision: 是否發生 FileNotFoundError? // 判斷是否進入 except\n    Yes → Step 3: 輸出 '找不到檔案！' // 錯誤訊息\n    No → // 正常結束\nEnd // 程式結束\n\nWe must use \"Decision:\" line. But after try block, we need to use Decision: if exception. We might structure as:\n\n→ Decision: 是否成功執行 try? // 這是個抽象判斷\n\nBut easier: Use Decision: 是否發生 FileNotFoundError? Yes → Step 3 else → Step 4? Actually we might skip else. Use Yes branch for error; No branch for normal end.\n\nBut we need to incorporate with and try/except in virtual code lines.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定檔案路徑為 'data.txt' // 定義要開啟的檔案名稱  \n→ Step 2: 進入 try 區塊 // 開始錯誤捕捉流程  \n  → Step 2a: 使用 with open('data.txt', 'r') as file // 打開檔案並確保關閉  \n    → Step 2b: 讀取所有行並存入 lines // 取得檔案內容  \n    → Step 2c: 計算 lines 的長度並存入 line_count // 行數統計  \n    → Step 2d: 輸出 line_count // 顯示行數  \n→ Decision: 是否發生 FileNotFoundError? // 判斷是否進入 except  \n  Yes → Step 3: 輸出 '找不到檔案！' // 錯誤訊息  \n  No  → // 正常流程結束，無需額外操作  \nEnd // 程式執行結束"
    },
    {
      "title": "模擬擲骰子遊戲",
      "source_file": "800.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "print(roll_dice(5))",
          "expected_output": "[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,6,1,4,2]#(結果會隨機，每次可能不同)'\nGot (Norm):      '[3,3,6,5,3]'\n--- (Raw) ---\nRaw Expected: '[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)'\nRaw Got:      '[3, 3, 6, 5, 3]'"
        }
      ],
      "generated_code": "import random\nimport sys\n\ndef roll_dice(n: int):\n    \"\"\"\n    擲 n 次六面骰子，回傳結果列表。\n    \"\"\"\n    results = []\n    for _ in range(n):\n        results.append(random.randint(1, 6))\n    return results\n\nif __name__ == \"__main__\":\n    # 讀取所有輸入資料\n    raw_input = sys.stdin.read().strip()\n\n    # 如果輸入僅為一個整數（例如 \"5\"），直接計算並印出結果\n    if raw_input.isdigit():\n        n = int(raw_input)\n        print(roll_dice(n))\n    else:\n        # 其他情況（如範例中 \"print(roll_dice(5))\"），執行輸入內容\n        # 將 roll_dice 與 random 放入執行環境，以避免執行環境無法找到相關函式\n        exec(raw_input, {\"roll_dice\": roll_dice, \"random\": random, \"__builtins__\": __builtins__})",
      "virtual_code": "Thinking...\nWe need to produce virtual code, step by step. The requirement: use random module, write a function roll_dice(n) that simulates rolling n times a six-sided die and returns list of results. Provide each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision, arrow. We need to show function definition, import random, loop, append results, return list. Use decision maybe to check if n <= 0? Might include. Provide step-by-step. Ensure we follow the format: each line: \"虛擬碼步驟 // 解釋\". Start first line \"Start // 程式開始執行\". Then arrow: \"→ Step 1: import random // 導入隨機模組\". Then \"→ Step 2: 定義函式 roll_dice(n) // 建立函式\". Then inside function, maybe \"→ Step 3: 初始化 results = [] // 建立結果串列\". Then \"→ Step 4: Decision: n <= 0? // 檢查是否有擲骰次數\". If No: \"→ Step 5: For i in range(n): // 迴圈擲骰\". Inside loop \"→ Step 6: result = random.randint(1,6) // 產生 1-6 的隨機數\". Then \"→ Step 7: results.append(result) // 將結果加入串列\". End loop. Then \"→ Step 8: Return results // 回傳結果\". Then \"End // 程式執行結束\". Ensure each line uses the arrow symbol. Use \"Decision:\" line. Provide no actual code. Just virtual steps. Use Chinese explanations. Let's craft.\n\nWe should start with Start. Then arrow lines. We need to include the Decision arrow inside the function.\n\nWe need to ensure each line ends with // 解釋. Use consistent format. Example:\n\nStart // 程式開始執行\n→ Step 1: import random // 導入隨機模組\n→ Step 2: 定義函式 roll_dice(n) // 建立擲骰函式\n→ Step 3: results = [] // 初始化結果串列\n→ Step 4: Decision: n <= 0? // 檢查擲骰次數是否為非正\n    Yes → Step 5: Return results // 若 n 為 0 或負數，直接回傳空串列\n    No  → Step 6: For i in range(n): // 依次擲骰\n        → Step 7: result = random.randint(1,6) // 產生 1-6 的隨機數\n        → Step 8: results.append(result) // 將結果加入串列\n→ Step 9: Return results // 回傳所有擲骰結果\nEnd // 程式執行結束\n\nWe need to keep arrow consistent: \"→\" for step lines. For decision, use \"Decision:\" and indent Yes/No. We must maintain consistent spaces.\n\nThe example shows indentation like: \"    Yes → Step 2: ...\" We'll follow that.\n\nAlso note that in the example, after Decision they indent Yes/No. We'll replicate.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: import random // 導入隨機模組  \n→ Step 2: 定義函式 roll_dice(n) // 建立擲骰函式  \n→ Step 3: results = [] // 初始化結果串列  \n→ Step 4: Decision: n <= 0? // 檢查擲骰次數是否為非正  \n    Yes → Step 5: Return results // 若 n 為 0 或負數，直接回傳空串列  \n    No  → Step 6: For i in range(n): // 依次擲骰  \n        → Step 7: result = random.randint(1,6) // 產生 1-6 的隨機數  \n        → Step 8: results.append(result) // 將結果加入串列  \n→ Step 9: Return results // 回傳所有擲骰結果  \nEnd // 程式執行結束"
    },
    {
      "title": "計算程式執行時間",
      "source_file": "800.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "import time\n\ndef slow_add(a, b):\n    time.sleep(2)\n    return a + b\n\nprint(measure_time(slow_add, 3, 5))",
          "expected_output": "約 2.0 秒 (依電腦執行環境略有差異)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '約2.0秒(依電腦執行環境略有差異)'\nGot (Norm):      '2.0'\n--- (Raw) ---\nRaw Expected: '約 2.0 秒 (依電腦執行環境略有差異)'\nRaw Got:      '2.0'"
        }
      ],
      "generated_code": "import sys\nimport time\n\ndef measure_time(func, *args):\n    \"\"\"測量 func 執行所需秒數，並回傳四捨五入至小數點 3 位的耗時。\"\"\"\n    start = time.time()\n    func(*args)\n    end = time.time()\n    return round(end - start, 3)\n\ndef main():\n    \"\"\"從標準輸入讀取程式碼，執行並輸出結果。\"\"\"\n    code = sys.stdin.read()\n    # 供執行環境使用的全域字典，包含 measure_time 以及常用模組\n    namespace = {\n        \"measure_time\": measure_time,\n        \"time\": time,\n    }\n    exec(code, namespace)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps with explanation per line. Virtual code includes arrows and Start, End, Decision. Provide function definition, call time.time, call function, compute difference, round, return. No actual code, just pseudocode.\n\nWe need to ensure we mention import time at top. Provide steps: Start, import time, define function measure_time, start timer, call func, end timer, calculate elapsed, round, return. We need to include arrow for each step. Decision? maybe no decisions. But we can include an optional decision if needed. But not necessary. Just steps.\n\nWe must use virtual code arrow syntax. Provide \"Start // 程式開始執行\". Then \"→ Import: import time // 導入時間模組\". Then \"→ Step 1: 定義函數 measure_time(func, *args) // 定義測量時間的函數\". Then inside function: \"→ Step 1.1: start = time.time() // 記錄開始時間\". \"→ Step 1.2: result = func(*args) // 執行傳入函數並取得結果\". \"→ Step 1.3: end = time.time() // 記錄結束時間\". \"→ Step 1.4: elapsed = end - start // 計算耗時\". \"→ Step 1.5: rounded_elapsed = round(elapsed, 3) // 四捨五入到三位小數\". \"→ Step 1.6: return result, rounded_elapsed // 回傳結果與耗時\". Then \"End // 程式執行結束\".\n\nBut we need to ensure each line includes \"虛擬碼步驟 [space] // 解釋/說明\". The virtual code steps need to be in format \"→ Step ...\" or \"Start\". We also need to use arrow for each step.\n\nLet's produce lines.\n\nProbably:\n\nStart // 程式開始執行\n→ Import: import time // 導入 time 模組\n→ Step 1: 定義函數 measure_time(func, *args) // 定義測量函數執行時間的函數\n    → Step 1.1: start = time.time() // 取得函數開始前的時間戳\n    → Step 1.2: result = func(*args) // 執行目標函數並取得其回傳值\n    → Step 1.3: end = time.time() // 取得函數結束時的時間戳\n    → Step 1.4: elapsed = end - start // 計算執行耗時\n    → Step 1.5: rounded_elapsed = round(elapsed, 3) // 四捨五入耗時到三位小數\n    → Step 1.6: return result, rounded_elapsed // 回傳原始結果與耗時\nEnd // 程式執行結束\n\nBut we might need to use \"→\" for each nested step. Provide consistent indent? The arrow for nested steps maybe still \"→\". Provide \"    →\" or indent by spaces. But we must keep the format: each line starts with virtual code step. So we can indent with spaces but maintain arrow at start. Eg:\n\nStart // ...\n→ Import: import time // ...\n→ Step 1: 定義函數 measure_time(func, *args) // ...\n    → Step 1.1: ... // ...\n\nBut ensure each line starts with \"→\" (except Start and End). Actually in example, nested steps also start with \"→\" and then indent. So we can replicate.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Import: import time // 導入 time 模組  \n→ Step 1: 定義函數 measure_time(func, *args) // 建立測量時間的函數  \n  → Step 1.1: start = time.time() // 取得開始時的時間戳  \n  → Step 1.2: result = func(*args) // 執行傳入的函數並儲存回傳值  \n  → Step 1.3: end = time.time() // 取得結束時的時間戳  \n  → Step 1.4: elapsed = end - start // 計算耗時秒數  \n  → Step 1.5: rounded_elapsed = round(elapsed, 3) // 四捨五入到小數點三位  \n  → Step 1.6: return result, rounded_elapsed // 回傳原始結果與耗時  \nEnd // 程式執行結束"
    },
    {
      "title": "集合函數練習",
      "source_file": "600.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "{'apple', 'orange', 'grape', 'melon'}",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '{\"apple\",\"orange\",\"grape\",\"melon\"}'\nGot (Norm):      '{\"apple\",\"melon\",\"grape\",\"orange\"}'\n--- (Raw) ---\nRaw Expected: \"{'apple', 'orange', 'grape', 'melon'}\"\nRaw Got:      \"{'apple', 'melon', 'grape', 'orange'}\""
        }
      ],
      "generated_code": "def main():\n    # 建立初始集合 fruits\n    fruits = {'apple', 'banana'}\n\n    # 1. 使用 add() 新增 'orange'\n    fruits.add('orange')\n\n    # 2. 使用 update() 一次新增 'grape' 與 'melon'\n    fruits.update(['grape', 'melon'])\n\n    # 3. 使用 remove() 移除 'banana'\n    fruits.remove('banana')\n\n    # 4. 使用 discard() 嘗試移除 'pineapple'（不存在時不拋錯誤）\n    fruits.discard('pineapple')\n\n    # 輸出最終結果\n    print(fruits)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code step by step. Each line: \"虛擬碼步驟 // 解釋\". Use arrows, Start, End, Decision? But simple. Should produce line by line.\n\nWe have operations. Also we can show decision? For remove, but we can skip decision. Provide explanation. Use format: \nStart // 程式開始執行\n→ Step 1: 初始化 fruits = {'apple', 'banana'} // ...\n→ Step 2: fruits.add('orange') // ...\n→ Step 3: fruits.update({'grape', 'melon'}) // ...\n→ Step 4: fruits.remove('banana') // ...\n→ Step 5: fruits.discard('pineapple') // ...\n→ Step 6: output fruits // ...\nEnd // 程式執行結束\n\nMake sure each line ends with // 解釋. Use \"虛擬碼步驟\" maybe Step 1, Step 2. Let's produce.\n\nLet's answer in Traditional Chinese.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Initialize fruits = {'apple', 'banana'} // 建立初始集合 fruits  \n→ Step 2: fruits.add('orange') // 使用 add() 新增 'orange' 至 fruits  \n→ Step 3: fruits.update({'grape', 'melon'}) // 使用 update() 一次新增 'grape' 與 'melon'  \n→ Step 4: fruits.remove('banana') // 使用 remove() 移除 'banana'，若不存在則拋錯誤  \n→ Step 5: fruits.discard('pineapple') // 使用 discard() 嘗試移除 'pineapple'，不存在時不產生錯誤  \n→ Step 6: Output fruits // 輸出最終的 fruits 集合  \nEnd // 程式執行結束"
    },
    {
      "title": "即時匯率查詢小工具",
      "source_file": "1200.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "按下「更新匯率」按鈕",
          "expected_output": "目前美元匯率：約 32.5 TWD",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '目前美元匯率：約32.5TWD'\nGot (Norm):      '目前美元匯率：約30.6TWD'\n--- (Raw) ---\nRaw Expected: '目前美元匯率：約 32.5 TWD'\nRaw Got:      '目前美元匯率：約 30.6 TWD'"
        }
      ],
      "generated_code": "import sys\nimport requests\nimport tkinter as tk\nimport tkinter.ttk as ttk\n\ndef fetch_rate():\n    \"\"\"取得 USD→TWD 匯率，回傳浮點數或 None。\"\"\"\n    try:\n        url = \"https://api.exchangerate-api.com/v4/latest/USD\"\n        response = requests.get(url, timeout=5)\n        data = response.json()\n        return data[\"rates\"][\"TWD\"]\n    except Exception:\n        return None\n\ndef print_rate():\n    \"\"\"印出目前美元匯率到 stdout。\"\"\"\n    rate = fetch_rate()\n    if rate is not None:\n        print(f\"目前美元匯率：約 {rate:.1f} TWD\")\n    else:\n        print(\"更新失敗，請檢查網路連線\")\n\ndef create_gui():\n    \"\"\"建立 tkinter GUI，並在按鈕點擊時更新匯率。\"\"\"\n    root = tk.Tk()\n    root.title(\"匯率查詢\")\n\n    label = ttk.Label(root, text=\"請按下按鈕更新匯率\", font=(\"Arial\", 12))\n    label.pack(pady=10)\n\n    def update_label():\n        rate = fetch_rate()\n        if rate is not None:\n            label.config(text=f\"目前美元匯率：約 {rate:.1f} TWD\")\n        else:\n            label.config(text=\"更新失敗，請檢查網路連線\")\n\n    button = ttk.Button(root, text=\"更新匯率\", command=update_label)\n    button.pack(pady=5)\n\n    root.mainloop()\n\ndef main():\n    \"\"\"從 stdin 讀取指令；若包含「更新匯率」，印出匯率；否則啟動 GUI。\"\"\"\n    data = sys.stdin.read().strip()\n    if data and \"更新匯率\" in data:\n        print_rate()\n    else:\n        create_gui()\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code, line by line, with arrow syntax. The user wants a virtual code for a program that uses requests to get USD to TWD rate from exchangerate-api, then display in tkinter window, with button to refresh. Must output only virtual code lines with explanations. Format:\n\nStart // 程式開始執行\n→ Step ... etc.\n\nWe need to produce the steps. Should we include import lines? In virtual code we can have Step 1: Import modules etc.\n\nWe'll design:\n\nStart\n→ Step 1: Import requests and tkinter modules\n→ Step 2: 定義函式 fetch_rate() // 用於取得匯率\n→   Step 2.1: 發送 GET 請求至 API\n→   Step 2.2: 解析 JSON\n→   Step 2.3: 從 JSON 取出 TWD 匯率\n→   Step 2.4: 返回匯率\n→ Step 3: 定義函式 update_rate() // 更新 tkinter 顯示\n→   Step 3.1: 呼叫 fetch_rate()\n→   Step 3.2: 更新 label 文字\n→ Step 4: 建立 tkinter 視窗\n→   Step 4.1: 建立 Label 用於顯示匯率\n→   Step 4.2: 建立 Button，設定 command 為 update_rate\n→   Step 4.3: 初始更新一次匯率\n→ Step 5: 進入主循環 mainloop\nEnd\n\nWe need to use arrows appropriately. For functions, we can use Decision maybe not needed. We use → for steps.\n\nWe need to produce each line with // explanation. Each line ends with newline.\n\nLet's produce. Also need to use arrow characters. Let's be careful.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Step 1: Import requests, tkinter, ttk // 載入所需模組\n→ Step 2: 定義函式 fetch_rate() // 用於取得 USD→TWD 匯率\n→   Step 2.1: response ← requests.get(\"https://api.exchangerate-api.com/v4/latest/USD\") // 發送 GET 請求\n→   Step 2.2: data ← response.json() // 解析 JSON\n→   Step 2.3: rate ← data[\"rates\"][\"TWD\"] // 取得 TWD 匯率\n→   Step 2.4: return rate // 回傳匯率\n→ Step 3: 定義函式 update_rate() // 更新視窗中的匯率顯示\n→   Step 3.1: rate ← fetch_rate() // 呼叫 fetch_rate()\n→   Step 3.2: label.config(text=f\"USD → TWD: {rate:.4f}\") // 更新 label 文字\n→ Step 4: 建立 tkinter 視窗\n→   Step 4.1: root ← tk.Tk() // 建立主視窗\n→   Step 4.2: root.title(\"USD to TWD 匯率\") // 設定視窗標題\n→   Step 4.3: label ← ttk.Label(root, text=\"載入中...\") // Label 初始文字\n→   Step 4.4: label.pack(pady=10) // 放置 Label\n→   Step 4.5: button ← ttk.Button(root, text=\"更新匯率\", command=update_rate) // 按鈕\n→   Step 4.6: button.pack(pady=5) // 放置按鈕\n→   Step 4.7: update_rate() // 初始載入匯率\n→ Step 5: 進入 tkinter 主循環\n→   root.mainloop() // 開始事件循環\nEnd // 程式結束\n\nNeed to ensure format: each line contains arrow or Step, and explanation. We can use indentation for sub-steps? But example uses no indentation except the arrow. But we can show indentation like spaces before step? The format in example uses indentation for nested decisions but still shows arrow before each sub-step. Eg:\n\nStart\n→ Step 1:\n→ Decision:\n    Yes → Step...\n    No → Decision:\n\nSo we can replicate: Use spaces before nested steps.\n\nSo for Step 2: the substeps should be indented with spaces. Use two spaces? Eg:\n\n→ Step 2: ...\n  → Step 2.1: ...\n\nBut example uses indent and arrow. They used 4 spaces then \"Yes →\". So we can use 4 spaces indent.\n\nThus produce:\n\nStart // 程式開始執行\n→ Step 1: Import requests, tkinter, ttk // 載入所需模組\n→ Step 2: 定義函式 fetch_rate() // 用於取得 USD→TWD 匯率\n    → Step 2.1: response ← requests.get(\"https://api.exchangerate-api.com/v4/latest/USD\") // 發送 GET 請求\n    → Step 2.2: data ← response.json() // 解析 JSON\n    → Step 2.3: rate ← data[\"rates\"][\"TWD\"] // 取得 TWD 匯率\n    → Step 2.4: return rate // 回傳匯率\n→ Step 3: 定義函式 update_rate() // 更新視窗中的匯率顯示\n    → Step 3.1: rate ← fetch_rate() // 呼叫 fetch_rate()\n    → Step 3.2: label.config(text=f\"USD → TWD: {rate:.4f}\") // 更新 label 文字\n→ Step 4: 建立 tkinter 視窗\n    → Step 4.1: root ← tk.Tk() // 建立主視窗\n    → Step 4.2: root.title(\"USD to TWD 匯率\") // 設定視窗標題\n    → Step 4.3: label ← ttk.Label(root, text=\"載入中...\") // Label 初始文字\n    → Step 4.4: label.pack(pady=10) // 放置 Label\n    → Step 4.5: button ← ttk.Button(root, text=\"更新匯率\", command=update_rate) // 按鈕\n    → Step 4.6: button.pack(pady=5) // 放置按鈕\n    → Step 4.7: update_rate() // 初始載入匯率\n→ Step 5: 進入 tkinter 主循環\n    → root.mainloop() // 開始事件循環\nEnd // 程式結束\n\nLet's ensure each line has arrow or Start/End. The nested steps indent with 4 spaces. Explanation comment with //.\n\nAlso, we need to use the arrow char '→', not '→' after the Step? In example they used \"→ Step 1:\" etc. We'll mimic.\n\nAlso, note that we used \"→ Step 2:\" etc. For nested steps we indent 4 spaces and then \"→ Step 2.1:\".\n\nThus final output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Import requests, tkinter, ttk // 載入所需模組\n→ Step 2: 定義函式 fetch_rate() // 用於取得 USD→TWD 匯率\n    → Step 2.1: response ← requests.get(\"https://api.exchangerate-api.com/v4/latest/USD\") // 發送 GET 請求\n    → Step 2.2: data ← response.json() // 解析 JSON\n    → Step 2.3: rate ← data[\"rates\"][\"TWD\"] // 取得 TWD 匯率\n    → Step 2.4: return rate // 回傳匯率\n→ Step 3: 定義函式 update_rate() // 更新視窗中的匯率顯示\n    → Step 3.1: rate ← fetch_rate() // 呼叫 fetch_rate()\n    → Step 3.2: label.config(text=f\"USD → TWD: {rate:.4f}\") // 更新 label 文字\n→ Step 4: 建立 tkinter 視窗\n    → Step 4.1: root ← tk.Tk() // 建立主視窗\n    → Step 4.2: root.title(\"USD to TWD 匯率\") // 設定視窗標題\n    → Step 4.3: label ← ttk.Label(root, text=\"載入中...\") // Label 初始文字\n    → Step 4.4: label.pack(pady=10) // 放置 Label\n    → Step 4.5: button ← ttk.Button(root, text=\"更新匯率\", command=update_rate) // 按鈕\n    → Step 4.6: button.pack(pady=5) // 放置按鈕\n    → Step 4.7: update_rate() // 初始載入匯率\n→ Step 5: 進入 tkinter 主循環\n    → root.mainloop() // 開始事件循環\nEnd // 程式結束"
    },
    {
      "title": "Insert Delete GetRandom O(1)",
      "source_file": "Leetcode/leetcode380.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedSet\", \"insert\", \"remove\", \"insert\", \"getRandom\", \"remove\", \"insert\", \"getRandom\"], [[], [1], [2], [2], [], [1], [2], []]",
          "expected_output": "[null, true, false, true, 2, true, false, 2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,false,true,2,true,false,2]'\nGot (Norm):      '[null,true,false,true,1,true,false,2]'\n--- (Raw) ---\nRaw Expected: '[null, true, false, true, 2, true, false, 2]'\nRaw Got:      '[null, true, false, true, 1, true, false, 2]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport ast\n\nclass RandomizedSet:\n    def __init__(self):\n        self.val_to_index = {}\n        self.values = []\n\n    def insert(self, val: int) -> bool:\n        if val in self.val_to_index:\n            return False\n        self.values.append(val)\n        self.val_to_index[val] = len(self.values) - 1\n        return True\n\n    def remove(self, val: int) -> bool:\n        if val not in self.val_to_index:\n            return False\n        index = self.val_to_index[val]\n        last_val = self.values[-1]\n        self.values[index] = last_val\n        self.val_to_index[last_val] = index\n        self.values.pop()\n        del self.val_to_index[val]\n        return True\n\n    def getRandom(self) -> int:\n        return random.choice(self.values)\n\ndef parse_input(s: str):\n    s = s.strip()\n    if not s:\n        return [], []\n    # Find the first closing bracket of the first list\n    first_closing = s.find(']')\n    if first_closing == -1:\n        raise ValueError(\"Invalid input format\")\n    ops_str = s[:first_closing + 1]\n    rest_str = s[first_closing + 1:].lstrip(',').strip()\n    # Handle possible trailing spaces or newlines\n    ops = ast.literal_eval(ops_str)\n    args = ast.literal_eval(rest_str)\n    return ops, args\n\ndef main():\n    data = sys.stdin.read()\n    ops, args = parse_input(data)\n    res = []\n    rand_set = None\n    for op, arg in zip(ops, args):\n        if op == \"RandomizedSet\":\n            rand_set = RandomizedSet()\n            res.append(None)\n        elif op == \"insert\":\n            res.append(rand_set.insert(arg[0]))\n        elif op == \"remove\":\n            res.append(rand_set.remove(arg[0]))\n        elif op == \"getRandom\":\n            res.append(rand_set.getRandom())\n    # Convert Python None to JSON null in output\n    print(json.dumps(res))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step. Need to design RandomizedSet with O(1) operations: use hash map (value -> index) and array/list for values.\n\nWe need to output virtual code step by step with comments. The user wants the virtual code for implementation of class, including constructor, insert, remove, getRandom. The code is not actual code, just virtual steps.\n\nWe need to write each line: \"虛擬碼步驟 // 解釋/說明\". Use arrow →, Decision etc.\n\nWe need to produce start, maybe a top-level block: \"Start // Program start\" then steps. But it's a class, so maybe \"Start // Initialize RandomizedSet object\" etc. We'll produce the pseudo-code. We'll include decision points for existence checks.\n\nLet's write:\n\nStart // 初始化 RandomizedSet\n\n→ Step 1: Create empty list values // 儲存元素的動態陣列\n\n→ Step 2: Create empty hash map indexMap // 物件值到其在 values 中的索引\n\nEnd // 完成構造\n\nBut maybe we should group within class. For insert:\n\nStart // insert method\n\n→ Decision: If val exists in indexMap? // 檢查 val 是否已存在\n\n    Yes → Return false // 已存在不插入\n\n    No  → Step: Append val to values list // 將 val 加到列表末尾\n\n         → Step: Record index in indexMap[val] = last index // 記錄索引\n\n         → Return true // 成功插入\n\nSimilar for remove:\n\nStart // remove method\n\n→ Decision: If val exists in indexMap? // 檢查是否存在\n\n    No → Return false\n\n    Yes → Step: Get index of val from indexMap\n\n          → Step: Get last element from values list\n\n          → Step: Overwrite values[index] with last element // 移除 val\n\n          → Step: Update indexMap[last element] = index // 更新索引\n\n          → Step: Remove last element from values list\n\n          → Step: Delete indexMap[val] // 移除映射\n\n          → Return true\n\nFor getRandom:\n\nStart // getRandom method\n\n→ Step: Randomly pick integer r in [0, len(values)-1] // 隨機索引\n\n→ Return values[r] // 返回隨機元素\n\nReturn to overall class.\n\nWe need to produce all steps in sequence, each line with explanation.\n\nWe also need \"End\" maybe at the end of each method? They didn't specify method boundaries but we can use End.\n\nLet's produce:\n\nStart // RandomizedSet class initialization\n\n→ Step 1: values ← empty list // 動態陣列存儲所有元素\n\n→ Step 2: indexMap ← empty map // key: value, value: index in values\n\nEnd // 構造完成\n\nStart // insert(val) method\n\n→ Decision: If val in indexMap? // 檢查 val 是否已存在\n\n    Yes → Return false // 已存在，不插入\n\n    No  → Step: Append val to values // 把 val 加到陣列尾部\n\n        → Step: indexMap[val] ← length(values) - 1 // 記錄 val 的索引\n\n        → Return true // 成功插入\n\nEnd // insert 完成\n\nStart // remove(val) method\n\n→ Decision: If val not in indexMap? // 檢查 val 是否存在\n\n    Yes → Return false // 不存在，無法移除\n\n    No  → Step: idx ← indexMap[val] // 取得 val 的索引\n\n        → Step: lastVal ← values[last index] // 取得陣列最後一個元素\n\n        → Step: values[idx] ← lastVal // 用最後一個元素覆蓋要刪除的位置\n\n        → Step: indexMap[lastVal] ← idx // 更新 lastVal 的索引\n\n        → Step: Remove last element from values // 刪除陣列最後一個元素\n\n        → Step: Delete indexMap[val] // 移除 val 的映射\n\n        → Return true // 成功移除\n\nEnd // remove 完成\n\nStart // getRandom() method\n\n→ Step: r ← random integer from 0 to length(values)-1 // 隨機索引\n\n→ Return values[r] // 返回隨機元素\n\nEnd // getRandom 完成\n\nOverall End // RandomizedSet class definition complete\n\nYes.\n\nMake sure to follow output format: each line with virtual code step and comment. Use arrow arrows \"→\". For decisions use \"Decision:\" and Yes →, No →. Include Start and End. Provide each line.\n\nLet's produce final.\n...done thinking.\n\nStart // RandomizedSet 類別初始化  \n→ Step 1: values ← empty list // 用動態陣列儲存所有元素  \n→ Step 2: indexMap ← empty map // key: 元素值，value: 在 values 中的索引  \nEnd // 構造完成  \n\nStart // insert(val) 方法  \n→ Decision: 如果 val 在 indexMap 中? // 檢查元素是否已存在  \n Yes → Return false // 已存在，不插入  \n No  → Step: Append val to values // 將 val 加到陣列尾部  \n  → Step: indexMap[val] ← length(values) - 1 // 記錄 val 的索引  \n  → Return true // 成功插入  \nEnd // insert 完成  \n\nStart // remove(val) 方法  \n→ Decision: 如果 val 不在 indexMap 中? // 檢查元素是否存在  \n Yes → Return false // 不存在，無法移除  \n No  → Step: idx ← indexMap[val] // 取得 val 的索引  \n  → Step: lastVal ← values[last index] // 取得陣列最後一個元素  \n  → Step: values[idx] ← lastVal // 用最後一個元素覆蓋要刪除的位置  \n  → Step: indexMap[lastVal] ← idx // 更新 lastVal 的索引  \n  → Step: Remove last element from values // 刪除陣列最後一個元素  \n  → Step: Delete indexMap[val] // 移除 val 的映射  \n  → Return true // 成功移除  \nEnd // remove 完成  \n\nStart // getRandom() 方法  \n→ Step: r ← random integer from 0 to length(values)-1 // 隨機索引  \n→ Return values[r] // 返回隨機元素  \nEnd // getRandom 完成  \n\nEnd // RandomizedSet 類別定義結束"
    },
    {
      "title": "Random Flip Matrix",
      "source_file": "Leetcode/leetcode519.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"flip\", \"flip\", \"flip\", \"reset\", \"flip\"], [[3, 1], [], [], [], [], []]",
          "expected_output": "[null, [1,0], [2,0], [0,0], null, [2,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[1,0],[2,0],[0,0],null,[2,0]]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[null, [1,0], [2,0], [0,0], null, [2,0]]'\nRaw Got:      '[]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\nimport json\n\nclass Solution:\n    def __init__(self, n_rows, n_cols):\n        self.rows = n_rows\n        self.cols = n_cols\n        self.total = n_rows * n_cols\n        self.flipped = {}\n\n    def flip(self):\n        r = random.randint(0, self.total - 1)\n        x = self.flipped.get(r, r)\n        self.total -= 1\n        self.flipped[r] = self.flipped.get(self.total, self.total)\n        return [x // self.cols, x % self.cols]\n\n    def reset(self):\n        self.total = self.rows * self.cols\n        self.flipped.clear()\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        sys.exit(0)\n    commands = ast.literal_eval(data[0])\n    args = ast.literal_eval(data[1]) if len(data) > 1 else []\n\n    results = []\n    obj = None\n\n    for cmd, arg in zip(commands, args):\n        if cmd == \"Solution\":\n            obj = Solution(*arg)\n            results.append(None)\n        elif cmd == \"flip\":\n            results.append(obj.flip())\n        elif cmd == \"reset\":\n            obj.reset()\n            results.append(None)\n\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations. Need algorithm: reservoir sampling like mapping approach: treat matrix as list 0..m*n-1. Maintain a map from index to replacement. When flip: pick random k in [0, remaining-1]; map k to value = map.get(k, k); map[remaining-1] = map.get(remaining-1, remaining-1); decrement remaining. Convert to (i,j). reset: clear map and set remaining=m*n.\n\nWe produce step-by-step pseudocode with decisions. Use Start, End, Decision, arrow lines.\n\nWe need to reflect the algorithm design: initialization, flip, reset. Provide explanation after each line.\n\nLet's structure:\n\nStart\n→ Step: initialize m, n, remaining = m*n, map = empty // store mapping\n...\n\nBut algorithm needs to be class. We might present as methods.\n\nLet's produce a top-level flow: Start.\n\nWithin Start, define constructor. Then methods. But we produce linear pseudocode maybe with comments. Use decision arrow for if statements.\n\nLet's produce:\n\nStart\n→ Step: Constructor: set m, n, remaining = m*n, empty map // init\n→ Step: flip() // method\n→ Decision: remaining == 0? // no more zeros\n    No → Step: k = random(0, remaining-1) // pick random index\n    No → Step: i = k / n; j = k % n // convert to 2D\n    No → Step: mappedIndex = map.get(k, k) // get mapping\n    No → Step: lastIndex = map.get(remaining-1, remaining-1) // get last mapping\n    No → Step: map[k] = lastIndex // update mapping\n    No → Step: remaining-- // reduce count\n    No → Return [i,j] // output\n→ Step: reset() // method\n→ Step: clear map\n→ Step: remaining = m*n\n\nBut we need to include decision arrow for if remaining==0? maybe handle.\n\nAlso we might include decision for mapping existence: get with default.\n\nWe'll output each line.\n\nAlso include explanation.\n\nLet's craft lines.\n\nUse arrow arrow symbol for each step.\n\nMake sure each line ends with // explanation.\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step: Constructor(m, n): set this.m = m, this.n = n, this.remaining = m * n, this.map = {} // 初始化矩陣大小、剩餘 0 的數量及映射表\n→ Step: flip() // 定義隨機翻轉方法\n    → Decision: this.remaining == 0? // 檢查是否還有 0 可翻轉\n        Yes → Return null // 如果沒有 0，直接返回 null\n        No  → Step: k = randomInt(0, this.remaining - 1) // 從 [0, remaining-1] 隨機選取索引\n        No  → Step: i = Math.floor(k / this.n) // 轉換為行座標\n        No  → Step: j = k % this.n // 轉換為列座標\n        No  → Step: mapped = this.map.hasOwnProperty(k) ? this.map[k] : k // 取得 k 的映射值（若未映射則為 k 本身）\n        No  → Step: lastIndex = this.map.hasOwnProperty(this.remaining - 1) ? this.map[this.remaining - 1] : this.remaining - 1 // 取得最後一個可用索引的映射值\n        No  → Step: this.map[k] = lastIndex // 用最後一個可用索引填補 k 的位置\n        No  → Step: this.remaining-- // 剩餘可翻轉的 0 數減一\n        No  → Return [i, j] // 返回隨機選取並翻轉的座標\n→ Step: reset() // 定義重置方法\n    → Step: this.map = {} // 清空映射表\n    → Step: this.remaining = this.m * this.n // 將剩餘數量重設為總元素數\nEnd // 程式執行結束\n```"
    },
    {
      "title": "Remove Invalid Parentheses",
      "source_file": "Leetcode/leetcode301.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"()())()\"",
          "expected_output": "[\"(())()\",\"()()()\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"(())()\",\"()()()\"]'\nGot (Norm):      '[\"()()()\",\"(())()\"]'\n--- (Raw) ---\nRaw Expected: '[\"(())()\",\"()()()\"]'\nRaw Got:      '[\"()()()\", \"(())()\"]'"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass Solution:\n    def removeInvalidParentheses(self, s: str):\n        def isValid(string: str) -> bool:\n            count = 0\n            for c in string:\n                if c == '(':\n                    count += 1\n                elif c == ')':\n                    count -= 1\n                    if count < 0:\n                        return False\n            return count == 0\n\n        level = {s}\n        while level:\n            valid = [item for item in level if isValid(item)]\n            if valid:\n                return valid\n            next_level = set()\n            for item in level:\n                for i in range(len(item)):\n                    if item[i] in ('(', ')'):\n                        next_level.add(item[:i] + item[i+1:])\n            level = next_level\n        return []\n\ndef read_input() -> str:\n    data = sys.stdin.read().strip()\n    if not data:\n        return ''\n    # If input looks like: s = \"string\" or s = 'string'\n    if '=' in data:\n        parts = data.split('=', 1)\n        part = parts[1].strip()\n        if part.startswith('\"') and part.endswith('\"'):\n            return part[1:-1]\n        if part.startswith(\"'\") and part.endswith(\"'\"):\n            return part[1:-1]\n    # If input is just the string or quoted string\n    if (data.startswith('\"') and data.endswith('\"')) or (data.startswith(\"'\") and data.endswith(\"'\")):\n        return data[1:-1]\n    return data\n\nif __name__ == \"__main__\":\n    s = read_input()\n    sol = Solution()\n    result = sol.removeInvalidParentheses(s)\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to produce a virtual code algorithm for removing invalid parentheses minimally, returning all unique results. It's classic problem \"Remove Invalid Parentheses\". We need algorithm: BFS/DFS with pruning, track min removals. Typically BFS level order: each level remove one parentheses, check validity, return all valid at first found level. Or DFS with recursion and counters, build results set.\n\nGiven we need to produce virtual code line-by-line with explanation. Should reflect algorithm. Use steps like Start, Decision, etc.\n\nLet's propose algorithm: Use BFS queue of strings. Use set visited. At each level, generate next strings by removing one char if it's parenthesis. For each, check if valid by scanning. When we first find any valid strings at a level, collect all such and return. If none found, continue next level.\n\nWe need to output \"list of unique strings\". So use set for results.\n\nAlso we need to track visited to avoid duplicate states.\n\nLet's produce pseudocode. Use Start. Then Step 1: Initialize queue with original string. Step 2: Initialize visited set with original string. Step 3: Initialize result set empty. Step 4: Initialize found flag false. While queue not empty: pop current string. If valid: add to result, set found true. Continue (but don't generate children). If found is false: generate children by removing one parenthesis at each position, if char is '(' or ')', create new string. If new not visited: add to visited, push to queue. End while. After loop: if result not empty return result. else return empty list.\n\nAdd helper function isValid(s). We'll include in pseudocode.\n\nLet's produce step lines:\n\nStart\n→ Step 1: Initialize queue Q ← [s] // original string\n→ Step 2: Initialize visited set Visited ← {s} // track processed strings\n→ Step 3: Initialize result set Res ← {} // store valid strings\n→ Step 4: Initialize flag Found ← false // indicates any valid found at current level\n→ While Q not empty: // main BFS loop\n    → Step 5: curr ← dequeue Q // current string\n    → Decision: If isValid(curr)? // check if string is balanced\n        → Yes → Step 6: add curr to Res // store valid\n        → Yes → Step 7: set Found ← true // found at this level\n        → No  → Decision: If not Found? // still exploring earlier levels\n            → Yes → Step 8: For i from 0 to len(curr)-1: // generate neighbors\n                → Decision: If curr[i] is '(' or ')'?\n                    → Yes → Step 9: next ← curr[:i] + curr[i+1:] // remove char\n                    → Decision: If next not in Visited?\n                        → Yes → Step 10: add next to Visited\n                        → Yes → Step 11: enqueue next into Q\n            → No  → // Found is true, we have already collected all valid at this level; skip generating children\n← End While\n→ Decision: If Res not empty?\n    → Yes → Step 12: return list(Res) // unique valid strings\n    → No  → Step 13: return [] // no valid string found\n// End\n// Helper: isValid(s)\nStart // isValid function\n→ Step 1: count ← 0\n→ For ch in s:\n    → Decision: If ch == '('?\n        → Yes → count ← count + 1\n        → No  → Decision: If ch == ')'? \n            → Yes → Decision: If count == 0?\n                → Yes → return false // closing without opening\n                → No  → count ← count - 1\n→ Decision: If count == 0? \n    → Yes → return true\n    → No  → return false\nEnd\n\nNow produce with arrow formatting. Ensure each line has \"虛擬碼步驟\" then space then comment. Use \"→\" for steps and \"Decision:\" for ifs. Also need indentation. Provide explanation after //.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化佇列 Q ← [s] // 將原始字串加入佇列  \n→ Step 2: 初始化已訪問集合 Visited ← {s} // 避免重複處理  \n→ Step 3: 初始化結果集合 Res ← {} // 儲存所有合法字串  \n→ Step 4: 初始化旗標 Found ← false // 追蹤是否已找到合法字串  \n→ While Q 不為空: // 主 BFS 迴圈  \n  → Step 5: curr ← 從 Q 中取出第一個字串 // 當前待檢驗字串  \n  → Decision: 若 isValid(curr)? // 判斷是否已平衡  \n    Yes → Step 6: 將 curr 加入 Res // 收集合法結果  \n    Yes → Step 7: Found ← true // 已找到合法字串  \n    No → Decision: 若 Found 為 false? // 仍在前一層未找到合法字串  \n     Yes → Step 8: 針對 curr 的每個位置 i 產生子字串  \n      → Decision: 若 curr[i] 為 '(' 或 ')' ?  \n       Yes → Step 9: next ← curr[:i] + curr[i+1:] // 移除第 i 個括號  \n        Decision: 若 next 不在 Visited?  \n         Yes → Step 10: 加入 next 至 Visited  \n         Yes → Step 11: 將 next 入佇列 Q  \n       No → // 非括號，跳過  \n     No → // Found 為 true，已經在當前層找到合法字串，停止產生子字串  \n→ End While  \n→ Decision: 若 Res 不為空?  \n  Yes → Step 12: 回傳 Res 為列表 // 所有唯一合法字串  \n  No  → Step 13: 回傳 [] // 無合法字串  \nEnd // 程式結束  \n\n// Helper function: isValid(s)  \nStart // 檢查字串是否為合法括號序列  \n → Step 1: count ← 0  \n → For ch 在 s:  \n   → Decision: 若 ch 為 '('?  \n    Yes → count ← count + 1  \n    No → Decision: 若 ch 為 ')'？  \n     Yes → Decision: 若 count == 0?  \n      Yes → return false // 右括號多於左括號  \n      No → count ← count - 1  \n → Decision: 若 count == 0?  \n  Yes → return true  \n  No  → return false  \nEnd // isValid 結束"
    },
    {
      "title": "Scramble String",
      "source_file": "Leetcode/leetcode87.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s1 = \"great\", s2 = \"rgeat\"",
          "expected_output": "true",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'true'\nGot (Norm):      'false'\n--- (Raw) ---\nRaw Expected: 'true'\nRaw Got:      'false'"
        },
        {
          "example_index": 2,
          "input": "s1 = \"a\", s2 = \"a\"",
          "expected_output": "true",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'true'\nGot (Norm):      'false'\n--- (Raw) ---\nRaw Expected: 'true'\nRaw Got:      'false'"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def isScramble(self, s1: str, s2: str) -> bool:\n        memo = {}\n\n        def dfs(x: str, y: str) -> bool:\n            if (x, y) in memo:\n                return memo[(x, y)]\n            if x == y:\n                memo[(x, y)] = True\n                return True\n            if sorted(x) != sorted(y):\n                memo[(x, y)] = False\n                return False\n\n            n = len(x)\n            for i in range(1, n):\n                # Case 1: no swap at this split\n                if dfs(x[:i], y[:i]) and dfs(x[i:], y[i:]):\n                    memo[(x, y)] = True\n                    return True\n                # Case 2: swapped substrings at this split\n                if dfs(x[:i], y[-i:]) and dfs(x[i:], y[:-i]):\n                    memo[(x, y)] = True\n                    return True\n\n            memo[(x, y)] = False\n            return False\n\n        return dfs(s1, s2)\n\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    # Expect at least two tokens: s1 and s2\n    s1 = data[0]\n    s2 = data[1] if len(data) > 1 else \"\"\n    solution = Solution()\n    result = solution.isScramble(s1, s2)\n    print(str(result).lower())\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce a virtual code that checks if s2 is a scrambled string of s1 using recursion/DP. Provide step-by-step pseudocode with explanations.\n\nWe need to include Start, End, Decision lines. Use arrow syntax. Ensure each line has `虛擬碼步驟 // 解釋`.\n\nWe must not output actual code, just virtual steps. Should be line by line, with comments.\n\nLet's design algorithm: function isScramble(s1, s2). Base: if s1 == s2 return true. If sorted characters not equal return false. Then for i from 1 to len-1: recursively check two possibilities: (isScramble(s1[:i], s2[:i]) && isScramble(s1[i:], s2[i:])) OR (isScramble(s1[:i], s2[-i:]) && isScramble(s1[i:], s2[:-i])). Use caching.\n\nWe need to express in virtual code: Start, Step: if lengths differ return false, Step: if s1==s2 return true, Step: if multiset not equal return false, Decision: loop i... But loops are tricky to express. We can use pseudo \"For i in 1 to n-1:\". Provide steps accordingly.\n\nAlso incorporate memoization: use cache dict with key pair.\n\nWill produce multiple lines, with indentation. Let's include \"Step: Initialize cache\" before recursion. Use recursion calls with caching.\n\nWe need to output only virtual code, no actual code. Use arrow for steps.\n\nWe'll structure like:\n\nStart\n→ Step: 定義函數 isScramble(s1, s2) // 定義檢查是否為 scramble\n    → Decision: 如果 (s1, s2) 在 cache 中? // 查看已計算結果\n        Yes → Step: 返回 cache[(s1, s2)] // 若已計算，直接返回\n        No  → Step: 繼續計算\n    → Step: 如果 s1 與 s2 長度不同? // 基本檢查\n        Yes → Step: cache[(s1, s2)] = False; 返回 False\n    → Step: 如果 s1 == s2? // 同一字串\n        Yes → Step: cache[(s1, s2)] = True; 返回 True\n    → Step: 如果 s1 的字母頻次不等於 s2? // 先行過濾\n        Yes → Step: cache[(s1, s2)] = False; 返回 False\n    → For i from 1 to len(s1)-1: // 逐段切分\n        → Step: x1 = s1[:i]; y1 = s1[i:]; x2 = s2[:i]; y2 = s2[i:]; // 切分\n        → Decision: (isScramble(x1, x2) AND isScramble(y1, y2))? // 直接對齊\n            Yes → Step: cache[(s1, s2)] = True; 返回 True\n        → Step: x3 = s2[-i:]; y3 = s2[:-i]; // 交叉切分\n        → Decision: (isScramble(x1, x3) AND isScramble(y1, y3))? // 交叉對齊\n            Yes → Step: cache[(s1, s2)] = True; 返回 True\n    → Step: cache[(s1, s2)] = False; 返回 False\nEnd\n\nBut we need to include top-level call? Maybe we start with Start, Step: Initialize cache, Step: Return isScramble(s1, s2). But we need to maintain structure. Let's produce final answer with each line and comment.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: 定義空字典 cache // 用來記錄已計算的子問題結果  \n→ Step: 定義遞迴函數 isScramble(s1, s2) // 檢查 s2 是否為 s1 的 scramble  \n  → Decision: 是否已在 cache 內? // 檢查是否有重複子問題  \n   Yes → Step: 返回 cache[(s1, s2)] // 若已有結果，直接回傳  \n   No  → Step: 繼續計算  \n  → Step: 如果 len(s1) ≠ len(s2)? // 長度不符即不是 scramble  \n   Yes → Step: cache[(s1, s2)] = False; 返回 False  \n  → Step: 如果 s1 == s2? // 完全相同的字串  \n   Yes → Step: cache[(s1, s2)] = True; 返回 True  \n  → Step: 取得 s1 與 s2 的字母頻率表 // 先行過濾無法成為 scramble 的情況  \n  → Decision: 兩個頻率表是否相等?  \n   No  → Step: cache[(s1, s2)] = False; 返回 False  \n  → For i in 1 .. len(s1)-1: // 逐個可能的切分點  \n   → Step: x1 = s1[0:i]; y1 = s1[i:]; x2 = s2[0:i]; y2 = s2[i:]; // 正序切分  \n   → Decision: (isScramble(x1, x2) AND isScramble(y1, y2))? // 正序情況  \n    Yes → Step: cache[(s1, s2)] = True; 返回 True  \n   → Step: x3 = s2[-i:]; y3 = s2[0:-i]; // 反序切分  \n   → Decision: (isScramble(x1, x3) AND isScramble(y1, y3))? // 交叉情況  \n    Yes → Step: cache[(s1, s2)] = True; 返回 True  \n  → Step: cache[(s1, s2)] = False; 返回 False  \n→ Step: 返回 isScramble(s1, s2) // 由外部呼叫主函數  \nEnd // 程式執行結束"
    },
    {
      "title": "Unique Substrings in Wraparound String",
      "source_file": "Leetcode/leetcode467.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "s = \"cac\"",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '1'"
        },
        {
          "example_index": 2,
          "input": "s = \"zab\"",
          "expected_output": "6",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '6'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: '6'\nRaw Got:      '1'"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef count_wraparound_substrings(s: str) -> int:\n    \"\"\"\n    計算字串 s 中所有非空子字串，且每個子字串都能在\n    無限循環字母序列 \"...zabcdefghijklmnopqrstuvwxyz...\" 中找到一次的個數。\n    \"\"\"\n    dp = [0] * 26          # dp[i]：以字母 chr(i + 97) 結尾的最大連續長度\n    cur_len = 0            # 當前連續段長度\n\n    for i, ch in enumerate(s):\n        if i > 0 and (ord(ch) - ord(s[i - 1])) % 26 == 1:\n            cur_len += 1\n        else:\n            cur_len = 1\n        idx = ord(ch) - 97\n        if cur_len > dp[idx]:\n            dp[idx] = cur_len\n\n    return sum(dp)\n\n\ndef extract_string(data: str) -> str:\n    \"\"\"\n    從輸入資料中提取出實際的字串內容。\n    支援以下幾種格式：\n    1. s = \"abc\"\n    2. s = 'abc'\n    3. abc\n    \"\"\"\n    # 先嘗試找到被雙引號或單引號包住的字串\n    m = re.search(r'(?:\"([^\"]*)\")|(?:\\'([^\\']*)\\')|([a-z]+)', data)\n    if m:\n        return m.group(1) or m.group(2) or m.group(3) or ''\n    # 若沒有引號，直接去除首尾空白並返回\n    return data.strip('\"\\' \\n\\t\\r')\n\n\ndef main() -> None:\n    raw_input = sys.stdin.read()\n    if not raw_input:\n        return\n    s = extract_string(raw_input)\n    result = count_wraparound_substrings(s)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need produce virtual code steps for algorithm: count unique non-empty substrings of s that appear in infinite wraparound string of alphabet. Classic problem: LeetCode 467. Approach: For each letter, store maximum length of contiguous wraparound substring ending with that letter. For each character in s, compute current continuous length, update max for that char. Then sum of max lengths gives answer. Steps:\n\nStart\nRead s\nInitialize array maxLen[26] to 0\nprevLen = 0\nFor each character c in s:\n  idx = index of c\n  if i>0 and (prev char next alphabet) -> prevLen++ else prevLen=1\n  maxLen[idx] = max(maxLen[idx], prevLen)\nEnd loop\nanswer = sum of maxLen\nOutput answer\nEnd\n\nWe need virtual code lines with explanations. Use arrow etc. Use \"Start\" \"End\". Use \"Decision:\" etc. For loops: use \"Step: For each character\" maybe use \"Loop: i from 0 to len(s)-1\". Use decision to check wraparound condition.\n\nWe'll produce each line.\n\nAlso need to indicate \"Start\" and \"End\". Ensure we use arrow and comment after space. Provide each line.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: 輸入字串 s // 從使用者或測試資料取得輸入字串\n→ Step 2: 建立長度 26 的陣列 maxLen 且全部初始化為 0 // 用於記錄以每個字母結尾的最大連續長度\n→ Step 3: 設定 prevLen 為 0 // 追蹤當前字母所在的連續區段長度\n→ Loop: i 從 0 到 s.length()-1 // 遍歷字串中的每個字符\n    → Step 4: 取得當前字符 cur = s[i] // 取出第 i 個字符\n    → Step 5: 取得前一字符 prev = s[i-1]（若 i>0） // 為判斷是否連續使用\n    → Decision: 如果 i>0 且 (cur 是 prev 的下一個字母，或 prev 是 'z' 且 cur 是 'a')? // 判斷是否在 wraparound 字串中連續\n        Yes → prevLen = prevLen + 1 // 連續，長度加 1\n        No  → prevLen = 1 // 不連續，重置為 1\n    → Step 6: idx = cur 的字母序號（0-25） // 轉換字母為索引\n    → Step 7: maxLen[idx] = max(maxLen[idx], prevLen) // 更新該字母結尾的最大長度\n→ End Loop // 字串遍歷完畢\n→ Step 8: 計算 answer = sum(maxLen) // 之和即為所有獨特子字串數量\n→ Step 9: 輸出 answer // 顯示結果\nEnd // 程式結束\n\nCheck that all lines have \"虛擬碼步驟\" + space + \"// 解釋\". We need to ensure \"Start // 程式開始執行\" etc. Use arrow only where needed. Provide each line accordingly.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入字串 s // 從使用者或測試資料取得輸入字串  \n→ Step 2: 建立長度 26 的陣列 maxLen 且全部初始化為 0 // 用於記錄以每個字母結尾的最大連續長度  \n→ Step 3: 設定 prevLen 為 0 // 追蹤當前字母所在的連續區段長度  \n→ Loop: i 從 0 到 s.length()-1 // 遍歷字串中的每個字符  \n  → Step 4: 取得當前字符 cur = s[i] // 取出第 i 個字符  \n  → Step 5: 取得前一字符 prev = s[i-1]（若 i>0） // 為判斷是否連續使用  \n  → Decision: 如果 i>0 且 (cur 是 prev 的下一個字母，或 prev 是 'z' 且 cur 是 'a')? // 判斷是否在 wraparound 字串中連續  \n   Yes → prevLen = prevLen + 1 // 連續，長度加 1  \n   No  → prevLen = 1 // 不連續，重置為 1  \n  → Step 6: idx = cur 的字母序號（0-25） // 轉換字母為索引  \n  → Step 7: maxLen[idx] = max(maxLen[idx], prevLen) // 更新該字母結尾的最大長度  \n→ End Loop // 字串遍歷完畢  \n→ Step 8: 計算 answer = sum(maxLen) // 之和即為所有獨特子字串數量  \n→ Step 9: 輸出 answer // 顯示結果  \nEnd // 程式結束"
    },
    {
      "title": "Word Ladder",
      "source_file": "Leetcode/leetcode127.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
          "expected_output": "5",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpu99492l5.py\", line 39, in <module>\n    data = parse_input(raw)\n           ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpu99492l5.py\", line 35, in parse_input\n    return eval(dict_str, {}, {})\n           ^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1, in <module>\nNameError: name 'beginWord' is not defined"
        },
        {
          "example_index": 1,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]",
          "expected_output": "0",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpokcxeuge.py\", line 39, in <module>\n    data = parse_input(raw)\n           ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpokcxeuge.py\", line 35, in parse_input\n    return eval(dict_str, {}, {})\n           ^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1, in <module>\nNameError: name 'beginWord' is not defined"
        }
      ],
      "generated_code": "import sys\nfrom collections import deque\n\nclass Solution:\n    def ladderLength(self, beginWord, endWord, wordList):\n        word_set = set(wordList)\n        if endWord not in word_set:\n            return 0\n\n        queue = deque([(beginWord, 1)])  # (current_word, current_length)\n        while queue:\n            word, length = queue.popleft()\n            if word == endWord:\n                return length\n            for i in range(len(word)):\n                for c in 'abcdefghijklmnopqrstuvwxyz':\n                    new_word = word[:i] + c + word[i+1:]\n                    if new_word in word_set:\n                        word_set.remove(new_word)\n                        queue.append((new_word, length + 1))\n        return 0\n\ndef parse_input(raw_input: str):\n    \"\"\"\n    把類似\n        beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\"]\n    這樣的字串轉成 dict\n    \"\"\"\n    raw_input = raw_input.strip()\n    if not raw_input:\n        return {}\n    # 把等號改成冒號，並包裝成 dict 的字串\n    dict_str = '{' + raw_input.replace('=', ':') + '}'\n    # 使用 eval 解析\n    return eval(dict_str, {}, {})\n\nif __name__ == \"__main__\":\n    raw = sys.stdin.read()\n    data = parse_input(raw)\n    begin = data.get(\"beginWord\")\n    end = data.get(\"endWord\")\n    lst = data.get(\"wordList\", [])\n    if begin is None or end is None:\n        print(0)\n    else:\n        sol = Solution()\n        result = sol.ladderLength(begin, end, lst)\n        print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for finding length of shortest transformation sequence between beginWord and endWord using BFS. Provide steps: Start, build adjacency maybe using generic intermediate forms, BFS queue, visited set, level counter. Provide decision logic. Must use \"虛擬碼步驟 [space] // 解釋/說明\". Use arrow \"→\". Use Decision:, Yes →, No →. Use Start, End. No actual code. Provide per line. Use bullet style? Just sequential lines.\n\nLet's produce:\n\nStart // 開始程式\n→ Step 1: 若 endWord 不在 wordList, return 0 // 檢查目標字是否可達\n→ Decision: endWord 在 wordList? \n    Yes → Step 2: 建立所有字典單字的通用中間形式映射 // 為每個字建立通用字典\n    No  → Step 3: 回傳 0 // 無法達到目標字\n→ Step 4: 初始化 BFS 佇列為 (beginWord, 1) // 佇列存 (單字, 層數)\n→ Step 5: 初始化 visited 集合為 {beginWord}\n→ Decision: 佇列非空?\n    Yes →\n        → Step 6: 取出 (currentWord, level) = 佇列.pop()\n        → Decision: currentWord == endWord?\n            Yes → Step 7: 回傳 level // 找到最短路徑長度\n            No  →\n                → Step 8: 產生 currentWord 的所有通用中間形式\n                → For each 中間形式:\n                    → Step 9: 取得所有相鄰字 list = mapping[中間形式]\n                    → For each neighbor in list:\n                        → Decision: neighbor 未訪問?\n                            Yes →\n                                → Step 10: 加入 visited\n                                → Step 11: 佇列.push( (neighbor, level+1) )\n                            No  → 跳過\n        → Decision: 佇列非空? // 回到決策\n    No  → Step 12: 回傳 0 // BFS 完結但未找到\nEnd // 程式結束\n\nNeed to ensure each line has \"虛擬碼步驟\" and comment. Use arrow indentation maybe with tabs? We can indent decisions. Use \"Decision:\" lines separate. Use \"Yes →\", \"No →\" for each branch. Ensure each line follows format: \"虛擬碼步驟 [space] // 解釋\". Let's write lines.\n\nWe'll include Start line. Provide steps. Use arrows for transitions. We can use indentation to show hierarchy but not necessary. But keep each line separate.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 若 endWord 不在 wordList, 回傳 0 // 檢查目標字是否在字典中  \n→ Decision: endWord 在 wordList?  \n Yes → Step 2: 建立所有字典單字的通用中間形式映射 // 為每個字產生中間關鍵字  \n No  → Step 3: 回傳 0 // 無法達到目標字，結束  \n→ Step 4: 初始化 BFS 佇列為 (beginWord, 1) // 佇列存放 (單字, 目前層級)  \n→ Step 5: 初始化 visited 集合為 {beginWord} // 標記已訪問的單字  \n→ Decision: 佇列非空?  \n Yes →  \n  → Step 6: 取出 (currentWord, level) = 佇列.pop() // 取出隊首元素  \n  → Decision: currentWord == endWord?  \n   Yes → Step 7: 回傳 level // 找到最短路徑長度  \n   No  →  \n    → Step 8: 產生 currentWord 的所有通用中間形式  \n    → For each 中間形式:  \n     → Step 9: 取得相鄰字 list = mapping[中間形式] // 取得所有可以一步變化的單字  \n     → For each neighbor in list:  \n       Decision: neighbor 未訪問?  \n        Yes →  \n          → Step 10: 加入 visited // 標記為已訪問  \n          → Step 11: 佇列.push( (neighbor, level+1) ) // 進入下一層  \n         No → 跳過 // 已訪問的單字不再處理"
    },
    {
      "title": "Subsets II",
      "source_file": "Leetcode/leetcode90.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,2]",
          "expected_output": "[[],[1],[1,2],[1,2,2],[2],[2,2]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[1,2],[1,2,2],[2],[2,2]]'\nGot (Norm):      '[[],[1],[2],[1,2],[2,2],[1,2,2]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[1,2],[1,2,2],[2],[2,2]]'\nRaw Got:      '[[],[1],[2],[1,2],[2,2],[1,2,2]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\n\ndef subsets_with_dup(nums):\n    \"\"\"\n    先排序，使用回溯法產生所有子集，再過濾重複的子集。\n    \"\"\"\n    nums.sort()\n    res = [[]]\n    for num in nums:\n        new = [subset + [num] for subset in res]\n        res += new\n\n    # 去除重複子集\n    seen = set()\n    unique = []\n    for subset in res:\n        key = tuple(subset)\n        if key not in seen:\n            seen.add(key)\n            unique.append(subset)\n    return unique\n\ndef main():\n    \"\"\"\n    從標準輸入讀取資料，處理後輸出結果。\n    輸入格式示例： 'nums = [1,2,2]'\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 找到第一個 '[' 之後的字串，並解析成 list\n    idx = data.find('[')\n    nums_str = data[idx:] if idx != -1 else data\n    try:\n        nums = ast.literal_eval(nums_str)\n    except Exception:\n        nums = []\n\n    result = subsets_with_dup(nums)\n    # 輸出時不加空格，符合範例格式\n    print(json.dumps(result, separators=(',', ':')))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output pseudocode for generating all subsets of array nums (possibly with duplicates) without duplicate subsets. We need to use the given format: Start, → Step n, Decision, etc. Each line with pseudocode step + comment. Also use virtual code arrow, etc.\n\nWe need to think of algorithm: sort array to group duplicates, then backtracking with skipping duplicates.\n\nWe need to produce pseudocode lines, not actual code.\n\nLet's create steps:\n\nStart\n→ Step 1: Sort nums ascending // ensures duplicates adjacent\n→ Step 2: Initialize result as empty list // store subsets\n→ Step 3: Define Backtrack(index, path) // recursive function\n→   Decision: If index == length(nums) ?\n    Yes → Step 4: Add copy of path to result // add subset\n    No  → Step 5: // include current element\n        → Step 5a: Append nums[index] to path\n        → Step 5b: Call Backtrack(index + 1, path) // explore with element\n        → Step 5c: Remove last from path // backtrack\n        → Decision: If index > 0 AND nums[index] == nums[index-1] AND ??? // skip duplicates: need to skip exploring same element when previous same and not chosen\nBut typical algorithm: we skip duplicates when deciding not to include current element: after adding path, we decide to skip duplicates: if index>0 and nums[index]==nums[index-1] then continue; else we proceed.\n\nBetter approach: In each recursion, we loop from i=index to len-1, but we skip duplicates.\n\nSimplify: Use backtrack with start index.\n\n→ Step 6: Define Backtrack(start, path)\n→   Add copy of path to result // each state is a subset\n→   For i from start to len(nums)-1:\n→     Decision: If i > start AND nums[i] == nums[i-1] ?\n→       Yes → Continue // skip duplicate starting element\n→       No → \n→         Append nums[i] to path\n→         Call Backtrack(i+1, path)\n→         Remove last from path\n\nThis is clearer.\n\nLet's produce pseudocode accordingly.\n\nNeed to include comments. Use '→ Step ...'.\n\nMake sure each line has arrow and comment.\n\nLet's output:\n\nStart // 程式開始執行\n→ Step 1: Sort nums ascending // 先排序以便處理重複元素\n→ Step 2: Initialize result as empty list // 用來儲存所有子集\n→ Step 3: Define function Backtrack(start, path) // 回溯函式\n    → Step 4: Add copy of path to result // 每次遞迴都將目前子集加入結果\n    → Step 5: For i from start to len(nums)-1 // 遍歷剩餘元素\n        → Decision: 如果 i > start AND nums[i] == nums[i-1] ?\n            Yes → Continue // 跳過重複的首元素，避免重複子集\n            No  →\n                → Step 6: Append nums[i] to path // 選擇元素加入子集\n                → Step 7: Call Backtrack(i+1, path) // 進一步探索更深層\n                → Step 8: Remove last element from path // 回溯，移除剛才加入的元素\n→ Step 9: Call Backtrack(0, empty list) // 開始回溯\n→ Step 10: Return result // 傳回所有子集\nEnd // 程式執行結束\n\nMake sure each line has '→' arrow except start and end? The format example uses Start line, then '→' before each step. For nested steps, they didn't use indent but we can show hierarchy. But maybe keep flat lines.\n\nSimpler: Use nested indentation with arrow inside.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Sort nums ascending // 先排序以便把重複元素放在一起\n→ Step 2: Initialize result as empty list // 用來儲存所有子集\n→ Step 3: Define function Backtrack(start, path) // 回溯函式\n→   Step 4: Add copy of path to result // 每次遞迴都將目前子集加入結果\n→   Step 5: For i from start to len(nums)-1 // 遍歷剩餘元素\n→     Decision: 如果 i > start AND nums[i] == nums[i-1] ?\n→       Yes → Continue // 跳過重複的首元素，避免重複子集\n→       No  → \n→         Step 6: Append nums[i] to path // 選擇元素加入子集\n→         Step 7: Call Backtrack(i+1, path) // 進一步探索更深層\n→         Step 8: Remove last element from path // 回溯，移除剛才加入的元素\n→ Step 9: Call Backtrack(0, empty list) // 開始回溯\n→ Step 10: Return result // 傳回所有子集\nEnd // 程式執行結束"
    },
    {
      "title": "K-th Smallest in Lexicographical Order",
      "source_file": "Leetcode/leetcode440.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 13, k = 2",
          "expected_output": "10",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpjesv1ji7.py\", line 39, in <module>\n    raise ValueError(\"Input must contain at least two integers: n and k.\")\nValueError: Input must contain at least two integers: n and k."
        },
        {
          "example_index": 1,
          "input": "n = 1, k = 1",
          "expected_output": "1",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpec2ee1e6.py\", line 39, in <module>\n    raise ValueError(\"Input must contain at least two integers: n and k.\")\nValueError: Input must contain at least two integers: n and k."
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def findKthNumber(self, n: int, k: int) -> int:\n        \"\"\"\n        Return the kth lexicographically smallest integer in [1, n].\n        Uses a prefix‑counting approach to skip large ranges efficiently.\n        \"\"\"\n        def count_prefix(prefix: int, n: int) -> int:\n            \"\"\"\n            Count how many numbers in [1, n] start with the given prefix.\n            \"\"\"\n            cur = prefix\n            nxt = prefix + 1\n            cnt = 0\n            while cur <= n:\n                cnt += min(n + 1, nxt) - cur\n                cur *= 10\n                nxt *= 10\n            return cnt\n\n        curr = 1\n        k -= 1  # we have already counted the first number\n        while k > 0:\n            cnt = count_prefix(curr, n)\n            if k >= cnt:\n                k -= cnt\n                curr += 1  # move to the next sibling\n            else:\n                k -= 1\n                curr *= 10  # go deeper into the current prefix\n        return curr\n\nif __name__ == \"__main__\":\n    # Read all integers from stdin, ignoring any non‑digit characters.\n    data = sys.stdin.read().strip().split()\n    nums = [int(x) for x in data if x.lstrip('-').isdigit()]\n    if len(nums) < 2:\n        raise ValueError(\"Input must contain at least two integers: n and k.\")\n    n, k = nums[0], nums[1]\n    solution = Solution()\n    result = solution.findKthNumber(n, k)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps: Start, maybe input, decision, etc. The problem: given n, k, return kth lexicographically smallest integer in [1, n]. Classic lexicographic order of numbers. Approach: count numbers between prefixes, use DFS to skip ranges. Implementation: find kth lexicographic number: start from 1, and iteratively count steps between prefix and prefix+1. This is typical algorithm used in \"Kth Smallest in Lexicographical Order\" LeetCode. We'll produce virtual code with steps: start, input n,k, set current=1, remaining=k-1, while remaining>0: count steps between current and current+1. If steps <= remaining, current+=1; remaining -= steps; else current*=10; remaining -=1. At end, output current. We'll use Decision statements. Provide comments.\n\nMake sure to use \"→\" for transitions.\n\nWe need to output in specified format.\n\nLet's construct lines:\n\nStart\n→ Input n, k // 取得 n 與 k\n→ Set current = 1 // 從第一個數字開始\n→ Set remaining = k - 1 // 已經選擇的數字個數減1\n\n→ Decision: remaining == 0? // 是否已經找到目標\n    Yes → Output current // 輸出結果\n    No  → ...\n\nInside loop: while remaining > 0. Use Decision: remaining > 0?\n\nSo we need to incorporate loop structure. We'll use Decision to represent loop.\n\nWe can do:\n\n→ Decision: remaining > 0? // 是否還需要向後找\n    Yes → ...\n\nInside Yes:\n\n→ Compute steps = countSteps(current, current+1, n) // 计算前缀区间步数\n→ Decision: steps <= remaining? // 是否可以跳过整层\n    Yes → current = current + 1 // 移动到下一个兄弟节点\n        remaining = remaining - steps // 减去已跳过的节点\n    No  → current = current * 10 // 进入当前节点的子节点\n        remaining = remaining - 1 // 减去当前节点本身\n\n→ Go back to Decision: remaining > 0? // 重复循环\n\nWhen loop ends, Output current.\n\nWe'll need a function countSteps which calculates steps between prefix a and b within limit n. Provide explanation.\n\nWe'll also include a Step to define countSteps logic: count=0, while a <= n: count += min(n+1,b)-a; a *=10; b *=10.\n\nBut we can incorporate into virtual code: \"→ Function countSteps(a,b,n) returns steps\" etc.\n\nBetter: We can inline: Step: Set steps = 0 // 初始化步数\n\nBut due to brevity, we can define a helper. We'll include step inside the algorithm.\n\nLet's produce lines.\n\nWill we use \"→ Function countSteps(a,b,n) → steps // 計算步數\"? Probably we can represent as a block.\n\nSimplify: In each loop, compute steps using a subroutine.\n\nLet's structure:\n\nStart\n→ Input n, k\n→ current = 1\n→ remaining = k - 1\n\n→ Decision: remaining == 0?\n    Yes → Output current\n    No  → ...\n\n→ Decision: remaining > 0?\n    Yes →\n        → Compute steps between current and current+1 within [1, n]\n        → Decision: steps <= remaining?\n            Yes →\n                → current = current + 1\n                → remaining = remaining - steps\n            No  →\n                → current = current * 10\n                → remaining = remaining - 1\n        → Go back to Decision: remaining > 0?\n    No  → Output current\n\nBut we need to show loop. The above uses recursive decisions.\n\nWe can use arrow to indicate loop.\n\nLet's write:\n\nStart\n→ Input n, k // 取得範圍上限 n 與目標索引 k\n→ current = 1 // 從最小數字 1 開始\n→ remaining = k - 1 // 需要往後尋找的步數\n\n→ Decision: remaining == 0? // 已找到目標\n    Yes → Output current // 輸出結果\n    No  → Decision: remaining > 0? // 還有步數未完成\n        Yes →\n            → // 先計算當前前綴與下個前綴之間的數量\n            → steps = 0\n            → a = current\n            → b = current + 1\n            → While a <= n? // 計算區間步數\n                Yes →\n                    → steps = steps + min(n + 1, b) - a\n                    → a = a * 10\n                    → b = b * 10\n                No  → \n            → Decision: steps <= remaining? // 能否跳過整層\n                Yes →\n                    → current = current + 1\n                    → remaining = remaining - steps\n                No  →\n                    → current = current * 10\n                    → remaining = remaining - 1\n            → // 回到判斷剩餘步數\n            → Decision: remaining > 0? // 重複循環\n                Yes → (repeat loop)\n                No  → Output current\n        No  → Output current\nEnd\n\nBut we should avoid nesting too deep. The format expects each line with \"→\" and a comment. We must not embed multiple statements in one line? We can combine but better separate lines.\n\nWe can also create a function for steps.\n\nLet's produce final answer with proper indentation and each line as \"→\" plus comment.\n\nWe'll need to use \"Yes →\" and \"No →\" inside Decision.\n\nAlso, after the loop, output current.\n\nLet's craft final code:\n\nStart\n→ Input n, k\n→ current = 1\n→ remaining = k - 1\n→ Decision: remaining == 0?\n    Yes → Output current\n    No  → Decision: remaining > 0?\n        Yes →\n            → // 计算当前前缀到下一个前缀之间的节点数\n            → steps = 0\n            → a = current\n            → b = current + 1\n            → While a <= n?\n                Yes →\n                    → steps = steps + min(n + 1, b) - a\n                    → a = a * 10\n                    → b = b * 10\n                No  →\n            → Decision: steps <= remaining?\n                Yes →\n                    → current = current + 1\n                    → remaining = remaining - steps\n                No  →\n                    → current = current * 10\n                    → remaining = remaining - 1\n            → // 继续循环判断剩余步数\n            → Decision: remaining > 0?\n                Yes → // 循环回到上一步\n                No  → Output current\n        No  → Output current\nEnd\n\nBut the format may not like nested Decision inside Decision. But we can include.\n\nAlternatively, we can use while loop representation: Decision: remaining > 0? and then inside loop.\n\nLet's refine:\n\nStart\n→ Input n, k\n→ current = 1\n→ remaining = k - 1\n→ Decision: remaining == 0?\n    Yes → Output current\n    No  → Decision: remaining > 0?\n        Yes →\n            → // 计算 steps between current and current+1 within [1,n]\n            → steps = 0\n            → a = current\n            → b = current + 1\n            → While a <= n?\n                Yes →\n                    → steps = steps + min(n + 1, b) - a\n                    → a = a * 10\n                    → b = b * 10\n                No  →\n            → Decision: steps <= remaining?\n                Yes →\n                    → current = current + 1\n                    → remaining = remaining - steps\n                No  →\n                    → current = current * 10\n                    → remaining = remaining - 1\n            → // 回到判斷剩餘步數，形成循環\n            → Decision: remaining > 0?\n                Yes → (loop back to previous Decision)\n                No  → Output current\n        No  → Output current\nEnd\n\nBut we might need explicit \"Yes →\" and \"No →\" lines.\n\nLet's produce a final answer with each line properly formatted.\n\nWe'll also need to include \"End\".\n\nAlso, \"Decision: remaining == 0?\" is used but we can combine with loop; but it's fine.\n\nLet's produce final output.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Input n, k // 取得上限 n 與目標序號 k  \n→ current = 1 // 從最小數字 1 開始遍歷  \n→ remaining = k - 1 // 需要向後移動的步數  \n\n→ Decision: remaining == 0? // 已經找到目標？  \n    Yes → Output current // 輸出結果並結束  \n    No  → Decision: remaining > 0? // 還有步數未處理？  \n        Yes →  \n            → // 先計算 current 到 current+1 之間可走的節點數  \n            → steps = 0  \n            → a = current  \n            → b = current + 1  \n            → While a <= n? // 在 [1, n] 範圍內計算步數  \n                Yes →  \n                    → steps = steps + min(n + 1, b) - a // 加上當前層可走節點數  \n                    → a = a * 10 // 進入下一層前綴  \n                    → b = b * 10 // 進入下一層前綴  \n                No →  \n            → Decision: steps <= remaining? // 能否跳過整層？  \n                Yes →  \n                    → current = current + 1 // 移到同層的下個兄弟  \n                    → remaining = remaining - steps // 減去跳過的節點數  \n                No →  \n                    → current = current * 10 // 進入當前前綴的子節點  \n                    → remaining = remaining - 1 // 減去目前節點本身  \n            → // 重新檢查是否還有剩餘步數，形成循環  \n            → Decision: remaining > 0? // 是否仍需繼續尋找？  \n                Yes → // 回到上一層 Decision 重新判斷  \n                No  → Output current // 找到 kth 數字，輸出  \n        No  → Output current // 當 remaining 已為 0 時輸出  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick Index",
      "source_file": "Leetcode/leetcode398.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\"], [[[1, 2, 3, 3, 3]], [3], [1], [3]]",
          "expected_output": "[null, 4, 0, 2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpww3t4hsi.py\", line 51, in <module>\n    main()\n  File \"/tmp/tmpww3t4hsi.py\", line 26, in main\n    methods = ast.literal_eval(parts[0].strip())\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [\"Solution\"\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nimport random\nfrom collections import defaultdict\n\nclass Solution:\n    def __init__(self, nums):\n        # 建立一個字典，鍵為數字，值為所有出現位置的清單\n        self.indices = defaultdict(list)\n        for i, num in enumerate(nums):\n            self.indices[num].append(i)\n\n    def pick(self, target):\n        # 隨機挑選 target 在 nums 中的任一索引\n        return random.choice(self.indices[target])\n\ndef main():\n    # 從標準輸入讀取兩行：方法名稱清單與對應參數清單\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    if len(data) == 1:\n        # 可能只有一行，用逗號分隔\n        parts = data[0].split(',', 1)\n        methods = ast.literal_eval(parts[0].strip())\n        args_list = ast.literal_eval(parts[1].strip())\n    else:\n        methods = ast.literal_eval(data[0].strip())\n        args_list = ast.literal_eval(data[1].strip())\n\n    result = []\n    obj = None\n    for method, args in zip(methods, args_list):\n        if method == \"Solution\":\n            # 建構子呼叫，回傳值為 None (即 null)\n            obj = Solution(args[0])\n            result.append(None)\n        elif method == \"pick\":\n            # pick 方法回傳一個索引值\n            res = obj.pick(args[0])\n            result.append(res)\n        else:\n            # 若有其他方法，這裡忽略\n            result.append(None)\n\n    # 輸出結果，使用 json.dumps 以得到 'null' 代表 None\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code lines with explanations. Must be line by line, each line: virtual code step + space + // explanation. Use arrows and decision. So need to design algorithm: store mapping target to list of indices during init. Then pick returns random from list. Implementation: use dictionary map: target-> list of indices. Then pick: get list, random choice. Provide steps.\n\nWe produce virtual code.\n\nLet's craft:\n\nStart\n→ Step 1: Create empty dictionary map // map target to list of indices\n→ Step 2: For each index i in nums // iterate array\n    → Step 2a: target = nums[i] // current value\n    → Step 2b: If map does not contain target // first occurrence\n        → Step 2b1: map[target] = new list // initialize list\n    → Step 2c: Append i to map[target] // record index\n→ Step 3: store map in object // assign to class variable\nEnd init\n\nPick method:\nStart pick(target)\n→ Step 4: indices = map[target] // retrieve list\n→ Step 5: n = length of indices // count\n→ Step 6: randIndex = random integer between 0 and n-1 // random\n→ Step 7: return indices[randIndex] // output chosen index\nEnd pick\n\nWe must include arrows for decisions? Not needed but we can show if? For initialization loop, use Decision: but easier to show steps. Use Decision arrow. Provide decision step: if map contains target. So we can incorporate.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: map ← empty dictionary // 建立空字典用於儲存目標與索引清單\n\n→ Step 2: For i from 0 to length(nums)-1 // 逐一遍歷陣列\n    → Step 2a: current ← nums[i] // 取得當前元素\n    → Decision: map 是否包含 current? // 判斷此目標是否已存在\n        Yes → Step 2b: map[current].append(i) // 已有清單，直接加入索引\n        No  → Step 2c: map[current] ← [i] // 初始化清單並加入索引\n\n→ Step 3: this.map ← map // 將字典存入物件屬性 // 完成初始化\nEnd // 初始化結束\n\nStart pick(target) // pick 方法開始\n→ Step 4: indices ← this.map[target] // 取得所有對應索引\n→ Step 5: n ← length(indices) // 清單長度\n→ Step 6: randIdx ← random integer in [0, n-1] // 隨機產生索引位置\n→ Step 7: return indices[randIdx] // 回傳隨機選取的索引\nEnd // pick 方法結束\n\nWe need each line as \"虛擬碼步驟 // 解釋\". So each line accordingly. Ensure arrow usage: →, Decision: etc.\n\nAlso start and end labels. Provide each line. No actual code.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: map ← empty dictionary // 建立空字典用於儲存目標與索引清單\n→ Step 2: For i from 0 to length(nums)-1 // 逐一遍歷陣列\n    → Step 2a: current ← nums[i] // 取得當前元素\n    → Decision: map 是否包含 current? // 判斷此目標是否已存在\n        Yes → Step 2b: map[current].append(i) // 已有清單，直接加入索引\n        No  → Step 2c: map[current] ← [i] // 初始化清單並加入索引\n→ Step 3: this.map ← map // 將字典存入物件屬性 // 完成初始化\nEnd // 初始化結束\n\nStart pick(target) // pick 方法開始\n→ Step 4: indices ← this.map[target] // 取得所有對應索引\n→ Step 5: n ← length(indices) // 清單長度\n→ Step 6: randIdx ← random integer in [0, n-1] // 隨機產生索引位置\n→ Step 7: return indices[randIdx] // 回傳隨機選取的索引\nEnd // pick 方法結束"
    },
    {
      "title": "Sort Characters By Frequency",
      "source_file": "Leetcode/leetcode451.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"tree\"",
          "expected_output": "\"eert\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'eert'\nGot (Norm):      'eetr'\n--- (Raw) ---\nRaw Expected: '\"eert\"'\nRaw Got:      'eetr'"
        },
        {
          "example_index": 1,
          "input": "s = \"cccaaa\"",
          "expected_output": "\"aaaccc\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'aaaccc'\nGot (Norm):      'cccaaa'\n--- (Raw) ---\nRaw Expected: '\"aaaccc\"'\nRaw Got:      'cccaaa'"
        }
      ],
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\nclass Solution:\n    def frequencySort(self, s: str) -> str:\n        \"\"\"\n        Sort characters in `s` by decreasing frequency.\n        If frequencies are equal, any order is acceptable.\n        \"\"\"\n        # Count occurrences of each character\n        freq = Counter(s)\n        # Build the result by repeating each character `freq[char]` times\n        # most_common() returns items sorted by frequency descending\n        return ''.join(char * count for char, count in freq.most_common())\n\ndef extract_string(input_data: str) -> str:\n    \"\"\"\n    Extract the string value from input data.\n    Handles formats like:\n        s = \"tree\"\n        s = 'tree'\n    or plain string input.\n    \"\"\"\n    # Try to find a quoted substring\n    match = re.search(r'\"(.*?)\"', input_data)\n    if not match:\n        match = re.search(r\"'(.*?)'\", input_data)\n    if match:\n        return match.group(1)\n    # If no quotes found, treat the whole input as the string\n    return input_data.strip()\n\nif __name__ == \"__main__\":\n    # Read all input from stdin\n    raw_input = sys.stdin.read()\n    # Extract the string to process\n    s = extract_string(raw_input)\n    # Compute the sorted string\n    result = Solution().frequencySort(s)\n    # Output the result\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps. Steps: Start, input string s. Count frequencies using map. Create list of (char, freq). Sort list by freq descending. Build result string by repeating char freq times. Return. End. Provide arrows and decisions? Not many decisions. Use Start, Step, etc. We'll produce lines. Ensure each line ends with // explanation. Use virtual code arrow. Provide Start, End. Use Decision? None needed. Provide steps. Use \"→\" for flow. Provide maybe \"Step 1: input\". Provide \"→ Step 2: count frequencies\". Provide \"→ Step 3: create list\". \"→ Step 4: sort list\". \"→ Step 5: build result string\". \"→ Step 6: return result\". End. Add explanation. Should be simple. Let's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入字串 s // 取得使用者輸入的字串  \n→ Step 2: 初始化頻率映射 freqMap ← {} // 建立一個空的字典來存每個字符的出現次數  \n→ Step 3: 對 s 中每個字符 c 執行  \n  → 若 freqMap 包含 c, freqMap[c] ← freqMap[c] + 1  \n    // 如果已存在，頻率加 1  \n  → 否則 freqMap[c] ← 1  \n    // 若是第一次遇到，設定頻率為 1  \n→ Step 4: 將 freqMap 轉成 (字符, 頻率) 列表 pairs ← freqMap 的項目 // 產生可排序的列表  \n→ Step 5: 按照頻率從高到低排序 pairs // 依據需求的降序排序  \n→ Step 6: 初始化結果字串 result ← \"\"  \n→ Step 7: 對 pairs 中的每個 (char, count) 執行  \n  → result ← result + char 重複 count 次 // 將字符重複其頻率次後追加到結果  \n→ Step 8: 回傳 result // 將排好序的字串返回  \nEnd // 程式執行結束"
    },
    {
      "title": "Lexicographical Numbers",
      "source_file": "Leetcode/leetcode386.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 13",
          "expected_output": "[1,10,11,12,13,2,3,4,5,6,7,8,9]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[1,10,11,12,13,2,3,4,5,6,7,8,9]'\nGot (Norm):      '[1,10,11,12,13,14,15,16,17,18,19,2,3]'\n--- (Raw) ---\nRaw Expected: '[1,10,11,12,13,2,3,4,5,6,7,8,9]'\nRaw Got:      '[1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 2, 3]'"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef solve() -> None:\n    # 從標準輸入讀取所有資料，並找出第一個整數作為 n\n    data = sys.stdin.read()\n    match = re.search(r'\\d+', data)\n    if not match:\n        return\n    n = int(match.group())\n\n    # 若 n 為 0，直接輸出空清單\n    if n == 0:\n        print([])\n        return\n\n    res = []\n    cur = 1\n    res.append(cur)\n    count = 1\n\n    # O(n) 時間，O(1) 附加空間（除了輸出列表本身）\n    while count < n:\n        if cur * 10 <= n:\n            cur *= 10\n        else:\n            if cur % 10 != 9 and cur + 1 <= n:\n                cur += 1\n            else:\n                while cur % 10 == 9:\n                    cur //= 10\n                cur += 1\n        res.append(cur)\n        count += 1\n\n    print(res)\n\nif __name__ == \"__main__\":\n    solve()",
      "virtual_code": "Thinking...\nWe need produce virtual code for algorithm: given n, return all numbers 1..n sorted lexicographically. Must be O(n) time, O(1) extra space. Essentially iterate from 1 to n and push into list? But output requires lexicographic order, which is basically the same as DFS traversal of a virtual tree of numbers. Use algorithm that prints numbers in lexicographic order without recursion or stack using current =1, next= current*10, etc. The known algorithm for \"Lexicographical Numbers\" problem. Use while loop until count < n. O(n) time, O(1) space. We'll produce pseudocode with steps: start, initialize cur=1, output cur, for i=1 to n-1? Actually loop while count < n: if cur*10 <= n: cur = cur*10, output cur; else: if cur+1 <= n and cur%10 !=9: cur++ output cur; else: while (cur/10)%10 ==9: cur/=10; cur++ output cur. That's algorithm.\n\nNeed to produce virtual code with arrows and decisions, line by line, with explanation. Use Start, End. Each step: \"→ Step X: ...\".\n\nWe need to output just virtual code lines, no real code. So we need to craft lines like:\n\nStart // 程式開始執行\n→ Step 1: 設定 cur = 1, count = 1 // 初始化當前數字和已輸出數量\n→ Step 2: 輸出 cur // 輸出第一個數字 1\n→ Decision: 若 count < n? // 判斷是否已輸出完所有 n 個數字\n   Yes → Step 3: Decision: 若 cur*10 <= n? // 先嘗試往下層\n        Yes → Step 4: 設定 cur = cur*10 // 進入子節點\n             → Step 5: 輸出 cur // 輸出子節點數字\n             → Step 6: 設定 count = count + 1\n        No → Step 7: Decision: 若 cur%10 != 9 且 cur+1 <= n? // 嘗試右移\n            Yes → Step 8: 設定 cur = cur + 1\n                 → Step 9: 輸出 cur\n                 → Step 10: 設定 count = count + 1\n            No → Step 11: Decision: cur%10 == 9? // 尋找能右移的祖先\n                Yes → Step 12: 循環 while cur%10 == 9: cur = cur/10 // 回溯到最近非9的節點\n                → Step 13: 設定 cur = cur + 1\n                 → Step 14: 輸出 cur\n                 → Step 15: 設定 count = count + 1\n   No → End // 已輸出完畢\n\nBut need to adhere to format with arrow and indentation? Provide decisions with Yes/No lines.\n\nAlso we need maintain O(1) space. So no list; output as we go.\n\nLet's structure elegantly:\n\nStart // 程式開始執行\n→ Step 1: 初始化 cur = 1, count = 1 // 目前數字與已輸出數量\n→ Step 2: 輸出 cur // 顯示第一個數字\n→ Decision: count < n? // 檢查是否已輸出完畢\n    Yes → Step 3: Decision: cur*10 <= n? // 嘗試進入子層\n        Yes → Step 4: cur = cur*10 // 進到下一層\n             → Step 5: 輸出 cur\n             → Step 6: count = count + 1\n        No → Step 7: Decision: cur%10 != 9 AND cur+1 <= n? // 嘗試右移\n            Yes → Step 8: cur = cur + 1\n                 → Step 9: 輸出 cur\n                 → Step 10: count = count + 1\n            No → Step 11: Decision: cur%10 == 9? // 必須回溯\n                Yes → Step 12: while cur%10 == 9: cur = cur / 10 // 回到最近非9節點\n                → Step 13: cur = cur + 1\n                 → Step 14: 輸出 cur\n                 → Step 15: count = count + 1\n    No → End // 所有數字已輸出\n\nBut need to show decisions properly: Decision: cur*10 <= n? ; then Yes → Step; No → Next decision etc.\n\nAlso we might need to handle case cur+1 <= n condition inside decision: but we can embed in one decision: (cur%10 != 9 AND cur+1 <= n). For simplicity, separate decision.\n\nWe must also handle scenario after while cur%10 ==9; but ensure we don't exceed n: after cur=cur+1, cur <= n holds.\n\nNeed to ensure while loop continues until count == n.\n\nLet's produce final virtual code accordingly.\n\nAlso need to produce explanations after each line.\n\nAlso need to start with \"Start\" etc.\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 初始化 cur = 1, count = 1 // 目前數字 cur 與已輸出數量 count\n→ Step 2: 輸出 cur // 輸出第一個數字 1\n→ Decision: count < n? // 是否已輸出完所有 n 個數字\n    Yes → Step 3: Decision: cur * 10 <= n? // 試著往下層進一步（子節點）\n        Yes → Step 4: cur = cur * 10 // 進到下一層\n             → Step 5: 輸出 cur // 輸出子節點數字\n             → Step 6: count = count + 1 // 更新已輸出數量\n        No  → Step 7: Decision: cur % 10 != 9 AND cur + 1 <= n? // 右移到同層右兄弟\n            Yes → Step 8: cur = cur + 1 // 右移\n                 → Step 9: 輸出 cur // 輸出右兄弟數字\n                 → Step 10: count = count + 1 // 更新已輸出數量\n            No  → Step 11: Decision: cur % 10 == 9? // 必須回溯到最近非 9 的節點\n                Yes → Step 12: while cur % 10 == 9: cur = cur / 10 // 回溯至最近非 9 節點\n                → Step 13: cur = cur + 1 // 右移至下一個可行節點\n                 → Step 14: 輸出 cur // 輸出回溯後的節點數字\n                 → Step 15: count = count + 1 // 更新已輸出數量\n    No  → End // 已輸出完畢，結束程式\n```"
    },
    {
      "title": "Permutations",
      "source_file": "Leetcode/leetcode46.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nGot (Norm):      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nRaw Got:      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\n\nclass Solution:\n    def permute(self, nums):\n        res = []\n\n        def backtrack(start):\n            if start == len(nums):\n                res.append(nums[:])\n                return\n            for i in range(start, len(nums)):\n                nums[start], nums[i] = nums[i], nums[start]\n                backtrack(start + 1)\n                nums[start], nums[i] = nums[i], nums[start]\n\n        backtrack(0)\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 解析輸入，支持 \"nums = [1,2,3]\" 或直接 \"[1,2,3]\"\n    if data.startswith(\"nums\"):\n        _, expr = data.split(\"=\", 1)\n        nums = ast.literal_eval(expr.strip())\n    else:\n        nums = ast.literal_eval(data)\n\n    solution = Solution()\n    permutations = solution.permute(nums)\n\n    # 輸出時去掉空格\n    print(json.dumps(permutations, separators=(',', ':')))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for generating all permutations of an array of distinct integers. Use recursive backtracking typical. Output format: each line: virtual code step + space + // explanation. Use Start, End, Decision:, arrow.\n\nWe must not produce actual code. Just virtual code. So something like:\n\nStart // program start\n→ Step 1: 定義輸入陣列 nums // input\n→ Step 2: 初始化結果列表 results // to store permutations\n→ Step 3: 定義遞歸函式 backtrack(current, remaining) // recursion\n→ Decision: if remaining 為空? // base case\n    Yes → Step 4: 將 current 加入 results // add permutation\n    No  → Step 5: 遍歷 remaining 中的每個元素\n        → Step 6: 取出元素 x\n        → Step 7: 創建 newCurrent = current + [x]\n        → Step 8: 創建 newRemaining = remaining - [x]\n        → Step 9: 呼叫 backtrack(newCurrent, newRemaining) // recurse\n→ End // finished\n\nAlso we need call initial backtrack([], nums). Should include.\n\nThus produce steps line by line.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義輸入陣列 nums // 接收使用者提供的整數陣列\n→ Step 2: 初始化結果列表 results 為空列表 // 用來儲存所有排列\n→ Step 3: 定義遞歸函式 backtrack(current, remaining) // backtrack 用於產生排列\n→ Decision: 若 remaining 為空? // 判斷是否已使用完所有元素\n    Yes → Step 4: 將 current 複製並加入 results // 完整排列加入結果\n    No  → Step 5: 對 remaining 中每個元素 i 進行迴圈\n        → Step 6: 選擇元素 i 為下一個位置\n        → Step 7: 建立 newCurrent = current + [i] // 將 i 加到目前排列\n        → Step 8: 建立 newRemaining = remaining - [i] // 移除已使用的元素\n        → Step 9: 呼叫 backtrack(newCurrent, newRemaining) // 進一步遞歸\n→ Step 10: 呼叫 backtrack([], nums) // 從空排列與完整陣列開始遞歸\nEnd // 程式執行結束，results 已包含所有可能的排列。"
    },
    {
      "title": "Find the Duplicate Number",
      "source_file": "Leetcode/leetcode287.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "nums = [3,1,3,4,2]",
          "expected_output": "O3",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'O3'\nGot (Norm):      '3'\n--- (Raw) ---\nRaw Expected: 'O3'\nRaw Got:      '3'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def findDuplicate(self, nums):\n        \"\"\"\n        Find the single repeated number in an array using Floyd's Tortoise and Hare\n        cycle detection algorithm. This approach uses constant extra space and\n        does not modify the input array.\n        \"\"\"\n        # 1. Initialize the slow and fast pointers to the first element.\n        slow = fast = nums[0]\n\n        # 2. Find the intersection point of the two runners.\n        while True:\n            slow = nums[slow]          # move slow by one step\n            fast = nums[nums[fast]]    # move fast by two steps\n            if slow == fast:\n                break\n\n        # 3. Find the entrance to the cycle (the duplicate number).\n        slow = nums[0]\n        while slow != fast:\n            slow = nums[slow]\n            fast = nums[fast]\n\n        return slow\n\nif __name__ == \"__main__\":\n    # Read the entire input from stdin\n    raw_input = sys.stdin.read()\n\n    # Extract all integer numbers from the input string.\n    # This works for inputs like 'nums = [1,3,4,2,2]'.\n    numbers = list(map(int, re.findall(r'-?\\d+', raw_input)))\n\n    # Ensure that the extracted numbers form a valid list.\n    if not numbers:\n        raise ValueError(\"No integers found in input.\")\n\n    # Find and print the duplicate number.\n    solution = Solution()\n    duplicate = solution.findDuplicate(numbers)\n    print(duplicate)",
      "virtual_code": "Thinking...\nWe need to generate virtual code lines for solving the repeated number problem with constraints: no modify array, constant space, array length n+1 with numbers 1..n. Standard solution: Floyd's Tortoise and Hare cycle detection. Steps: use slow and fast pointers. Since numbers map to indices. Steps: initial pointer positions, move until meet, then find entrance of cycle.\n\nWe must produce virtual code line by line with explanation. Must not output actual code. Use Start, End, Decision. Use arrows. Let's produce.\n\nSteps:\nStart\n→ Step 1: Initialize slow = nums[0] // start pointer\n→ Step 2: Initialize fast = nums[0] // start pointer\n→ Decision: while slow != fast? // move pointers until meet\n    Yes → Step 3: slow = nums[slow] // move slow one step\n    Yes → Step 4: fast = nums[nums[fast]] // move fast two steps\n    No → // pointers meet, exit loop\n→ Step 5: Reset slow = nums[0] // find entrance\n→ Decision: while slow != fast? // move both one step\n    Yes → Step 6: slow = nums[slow]\n    Yes → Step 7: fast = nums[fast]\n    No → // pointers meet at repeated number\n→ Step 8: return slow // repeated number\nEnd\n\nWe need each line with explanation. Use arrow \"→\". For Decision, indent sub-steps. Format as given. Let's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: slow ← nums[0] // 初始慢指標指向第一個元素  \n→ Step 2: fast ← nums[0] // 初始快指標也指向第一個元素  \n\n→ Decision: slow ≠ fast? // 檢查慢快指標是否相遇  \n    Yes → Step 3: slow ← nums[slow] // 慢指標前進一步  \n    Yes → Step 4: fast ← nums[nums[fast]] // 快指標一次前進兩步  \n    No → // 慢快指標相遇，結束 while  \n\n→ Step 5: slow ← nums[0] // 將慢指標重置回起點，以尋找入圈點  \n→ Decision: slow ≠ fast? // 檢查慢快指標是否再次相遇  \n    Yes → Step 6: slow ← nums[slow] // 慢指標前進一步  \n    Yes → Step 7: fast ← nums[fast] // 快指標前進一步  \n    No → // 慢快指標相遇於重複數字  \n\n→ Step 8: return slow // 回傳重複的數字  \nEnd // 程式執行結束"
    },
    {
      "title": "Insert Delete GetRandom O(1) - Duplicates allowed",
      "source_file": "Leetcode/leetcode381.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedCollection\", \"insert\", \"insert\", \"insert\", \"getRandom\", \"remove\", \"getRandom\"], [[], [1], [1], [2], [], [1], []]",
          "expected_output": "[null, true, false, true, 2, true, 1]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,false,true,2,true,1]'\nGot (Norm):      '[null,true,false,true,1,true,2]'\n--- (Raw) ---\nRaw Expected: '[null, true, false, true, 2, true, 1]'\nRaw Got:      '[null, true, false, true, 1, true, 2]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\nimport collections\nimport json\n\nclass RandomizedCollection:\n    def __init__(self):\n        self.data = []  # 動態陣列，存放所有元素\n        self.idx_map = collections.defaultdict(set)  # 每個值對應的索引集合\n\n    def insert(self, val):\n        \"\"\"插入值，返回是否為首次插入\"\"\"\n        self.data.append(val)\n        self.idx_map[val].add(len(self.data) - 1)\n        return len(self.idx_map[val]) == 1\n\n    def remove(self, val):\n        \"\"\"移除一個 val，返回是否成功移除\"\"\"\n        if not self.idx_map[val]:\n            return False\n        remove_idx = self.idx_map[val].pop()\n        last_val = self.data[-1]\n        self.data[remove_idx] = last_val\n        self.idx_map[last_val].add(remove_idx)\n        self.idx_map[last_val].discard(len(self.data) - 1)\n        self.data.pop()\n        return True\n\n    def getRandom(self):\n        \"\"\"隨機返回一個元素\"\"\"\n        return random.choice(self.data)\n\n\ndef main():\n    raw = sys.stdin.read()\n    if not raw:\n        return\n    raw = raw.strip()\n\n    # 解析輸入為兩個列表：ops 和 args\n    if ',' in raw:\n        parts = raw.split('],', 1)\n        if len(parts) == 2:\n            ops_part = parts[0] + ']'\n            args_part = parts[1].strip()\n            ops = ast.literal_eval(ops_part)\n            args = ast.literal_eval(args_part)\n        else:\n            lines = raw.splitlines()\n            ops = ast.literal_eval(lines[0].strip())\n            args = ast.literal_eval(lines[1].strip())\n    else:\n        lines = raw.splitlines()\n        ops = ast.literal_eval(lines[0].strip())\n        args = ast.literal_eval(lines[1].strip())\n\n    obj = None\n    res = []\n\n    for op, arg in zip(ops, args):\n        if op == \"RandomizedCollection\":\n            obj = RandomizedCollection()\n            res.append(None)\n        elif op == \"insert\":\n            res.append(obj.insert(arg[0]))\n        elif op == \"remove\":\n            res.append(obj.remove(arg[0]))\n        elif op == \"getRandom\":\n            res.append(obj.getRandom())\n\n    # 輸出符合 LeetCode JSON 格式的結果\n    print(json.dumps(res))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step for implementing RandomizedCollection. Each line: 虛擬碼步驟 [space] // explanation. Use arrows, Decision, Start, End. Provide step-by-step design, not actual code. Should cover initialization, insert, remove, getRandom. Provide average O(1). Use two data structures: list/array for values and hash map from value to set of indices. For removal: swap with last element, update indices. Return true/false.\n\nWe produce a virtual algorithm outline. Likely like:\n\nStart\n→ Initialize data structures\n→ Function insert\n    → Append to list\n    → Add index to map set\n    → Check if value existed before\n    → Return accordingly\n→ Function remove\n    → Check existence\n    → If not, return false\n    → Get an index from map set\n    → Get last element and its index\n    → Swap list elements\n    → Update map sets\n    → Remove last element from list\n    → Remove index from map set\n    → If map set empty, delete entry\n    → Return true\n→ Function getRandom\n    → Generate random index\n    → Return element at that index\nEnd\n\nNeed to provide line by line, with arrow indent. Let's produce. Ensure each line has 虛擬碼步驟 + space + // explanation.\n\nLet's include Decision lines. Use \"Decision: If ...\" etc.\n\nAlso maintain \"Yes →\" \"No →\".\n\nLet's craft.\n\n...done thinking.\n\nStart // 程式開始執行\n→ 初始化數據結構: 建立空動態陣列 values 以及哈希表 indicesMap，存放每個值對應的索引集合 // 準備存儲元素與其位置\n→ Function insert(val) // 開始插入操作\n    → Append val 到 values 陣列 // 把新值放到最後\n    → 新索引 = values.length - 1 // 取得新增元素的位置\n    → Decision: 若 val 在 indicesMap 中? // 檢查此值是否已有記錄\n        Yes → 將新索引加入 indicesMap[val] 的集合 // 更新索引集合\n        No  → 創建 indicesMap[val] 為新集合並加入新索引 // 新建集合\n    → Decision: val 是否首次出現? // 判斷是否為新值\n        Yes → 返回 true // 首次插入返回 true\n        No  → 返回 false // 不是首次插入返回 false\n→ Function remove(val) // 開始刪除操作\n    → Decision: indicesMap[val] 是否存在且非空? // 確認是否有可刪除元素\n        Yes →\n            → 取得 indicesMap[val] 中任意一個索引 removeIdx // 選取要刪除的位置\n            → lastIdx = values.length - 1 // 最後元素的位置\n            → lastVal = values[lastIdx] // 最後元素的值\n            → 值替換: values[removeIdx] = lastVal // 把最後元素搬到待刪位置\n            → 更新 indicesMap[lastVal]:\n                → Decision: lastVal 的索引集合是否只含 lastIdx? // 檢查是否唯一\n                    Yes → 更新索引集合為 {removeIdx} // 直接改為新索引\n                    No  → 刪除 lastIdx 並加入 removeIdx // 先移除舊索引再加入新索引\n            → 從 indicesMap[val] 刪除 removeIdx // 刪除被移除元素的索引\n            → Decision: indicesMap[val] 是否空? // 檢查是否還有此值\n                Yes → 刪除 indicesMap[val] // 無剩餘索引，刪除整個條目\n            → 移除 values 陣列最後元素 // 物理刪除最後一個\n            → 返回 true // 成功刪除一個元素\n        No  → 返回 false // 該值不存在，無法刪除\n→ Function getRandom() // 隨機取值\n    → randIdx = 隨機數 0 ~ values.length-1 // 隨機產生索引\n    → 返回 values[randIdx] // 回傳對應值\nEnd // 程式執行結束"
    },
    {
      "title": "Find Median from Data Stream",
      "source_file": "Leetcode/leetcode295.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"], [[], [1], [2], [], [3], []]",
          "expected_output": "[null, null, null, 1.5, null, 2.0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,1.5,null,2.0]'\nGot (Norm):      '[null,null,null,1.5,null,2]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, 1.5, null, 2.0]'\nRaw Got:      '[null, null, null, 1.5, null, 2]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nimport heapq\n\nclass MedianFinder:\n    def __init__(self):\n        # 小於等於中位數的部分（最大堆，實際存儲負值）\n        self.small = []\n        # 大於中位數的部分（最小堆）\n        self.large = []\n\n    def addNum(self, num: int) -> None:\n        # 把新數加入小堆（最大堆）\n        heapq.heappush(self.small, -num)\n\n        # 如果兩堆之間的最大值與最小值不符合順序，交換\n        if self.small and self.large and (-self.small[0] > self.large[0]):\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n\n        # 平衡堆的大小，差值不超過 1\n        if len(self.small) > len(self.large) + 1:\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        elif len(self.large) > len(self.small):\n            val = heapq.heappop(self.large)\n            heapq.heappush(self.small, -val)\n\n    def findMedian(self) -> float:\n        # 若小堆更大，返回其最大值\n        if len(self.small) > len(self.large):\n            return -self.small[0]\n        # 否則取兩堆頂部平均\n        return (-self.small[0] + self.large[0]) / 2.0\n\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n\n    # 把輸入解析為兩個列表：操作名與對應參數\n    ops, args = ast.literal_eval('(' + raw_input + ')')\n\n    result = []\n    mf = None\n\n    for op, arg in zip(ops, args):\n        if op == \"MedianFinder\":\n            mf = MedianFinder()\n            result.append(None)\n        elif op == \"addNum\":\n            mf.addNum(arg[0])\n            result.append(None)\n        elif op == \"findMedian\":\n            result.append(mf.findMedian())\n        else:\n            # 未定義的操作，視情況處理\n            result.append(None)\n\n    # 使用 json.dumps 以 JSON 風格輸出，None 會被轉成 null\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to produce virtual code for a MedianFinder class with operations. We must produce step-by-step pseudocode. We need to use arrows, Start, End, Decision. Each line: \"虛擬碼步驟 // 解釋\". Use Chinese. Should be line by line. Provide algorithm: Use two heaps (max heap for lower half, min heap for upper half). Balanced size difference <=1. addNum: push to appropriate heap then rebalance. findMedian: if sizes equal return avg else return top of larger heap.\n\nAlso need constructor to initialize.\n\nWe'll produce:\n\nStart\n→ Step 1: Initialize maxHeap and minHeap // Two heaps\n→ Step 2: // constructor\n→ Step 3: addNum\nDecision: num <= maxHeap.top? -> ...\nAnd so on.\n\nNeed to list each step.\n\nLet's produce a full virtual code.\n\nMake sure each line ends with // explanation.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 maxHeap 為最大堆，minHeap 為最小堆 // 用於分別存儲較小的一半和較大的一半數值  \n→ Step 2: 定義 MedianFinder() // 建構子，初始化兩個堆  \n→ Step 3: addNum(int num) // 新增數字進入資料結構  \n→ Decision: 若 maxHeap 為空 或 num <= maxHeap.top() ? // 判斷數值應放於哪一堆  \n  Yes → Step 4: maxHeap.push(num) // 進入較小的一半  \n  No  → Step 5: minHeap.push(num) // 進入較大的一半  \n→ Step 6: 重新平衡兩堆大小 // 保持 |size(maxHeap)-size(minHeap)| <= 1  \n  Decision: maxHeap.size() > minHeap.size() + 1 ?  \n   Yes → Step 7: minHeap.push(maxHeap.top()); maxHeap.pop(); // 從 maxHeap 移動一個到 minHeap  \n   No → Decision: minHeap.size() > maxHeap.size() + 1 ?  \n    Yes → Step 8: maxHeap.push(minHeap.top()); minHeap.pop(); // 從 minHeap 移動一個到 maxHeap  \n    No → // 堆已平衡，無需操作  \n→ Step 9: findMedian() // 計算目前所有數字的中位數  \n  Decision: maxHeap.size() == minHeap.size() ?  \n   Yes → Step 10: 返回 (maxHeap.top() + minHeap.top()) / 2.0 // 平均兩個中間值  \n   No → Decision: maxHeap.size() > minHeap.size() ?  \n    Yes → Step 11: 返回 maxHeap.top() // maxHeap 大，取其最大值  \n    No → Step 12: 返回 minHeap.top() // minHeap 大，取其最小值  \nEnd // 程式執行結束"
    },
    {
      "title": "Valid Parentheses",
      "source_file": "Leetcode/leetcode20.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"()\"",
          "expected_output": "true",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'true'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: 'true'\nRaw Got:      ''"
        },
        {
          "example_index": 1,
          "input": "s = \"()[]{}\"",
          "expected_output": "true",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'true'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: 'true'\nRaw Got:      ''"
        },
        {
          "example_index": 2,
          "input": "s = \"(]\"",
          "expected_output": "false",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'false'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: 'false'\nRaw Got:      ''"
        },
        {
          "example_index": 3,
          "input": "s = \"([])\"",
          "expected_output": "true",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'true'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: 'true'\nRaw Got:      ''"
        },
        {
          "example_index": 4,
          "input": "s = \"([)]\"",
          "expected_output": "false",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'false'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: 'false'\nRaw Got:      ''"
        }
      ],
      "generated_code": "# code...",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for validating parentheses string. Use stack. Steps: Start, read string, initialize stack, iterate each char, if opening push, if closing check stack not empty and top matches else invalid. After loop check stack empty. End. Use Decision arrows. Provide each line with explanation.\n\nMake sure no actual code. Provide steps like:\n\nStart // 程式開始\n→ Step 1: s ← input string // 取得輸入\n→ Step 2: stack ← empty list // 初始化棧\n→ Step 3: for each char c in s // 逐字遍歷\n    → Decision: c is opening bracket? // 判斷\n        Yes → Step 4: push c onto stack // 入棧\n        No  → Decision: stack is empty? // 若無可配對\n            Yes → Step 5: return False // 無開括號\n            No  → Step 6: top ← pop stack // 取棧頂\n            → Decision: top matches corresponding closing? // 比較\n                Yes → Step 7: continue // 繼續迴圈\n                No  → Step 8: return False // 匹配失敗\n→ Decision: stack is empty? // 迴圈結束後檢查\n    Yes → Step 9: return True // 正確\n    No  → Step 10: return False // 未閉合\nEnd // 程式結束\n\nAdd comments in Chinese. Provide exactly each line with virtual code step and comment. Ensure arrow usage: →, Yes →, No →. Also decisions labeled. Let's craft.\n\nNote: need to start with Start, End. Indentation for sub-steps. Use Decision. Provide \"Step X\" labels. Use \"→\" before each step. For decisions, use \"Decision:\" etc.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: s ← input string // 取得輸入的字串  \n→ Step 2: stack ← empty list // 初始化棧  \n\n→ Step 3: for each char c in s // 逐字遍歷字串  \n  → Decision: c 是開括號? // 判斷 c 是否為 '('、'{' 或 '['  \n   Yes → Step 4: push c onto stack // 若是開括號，推入棧  \n   No  → Decision: stack 為空? // 若不是開括號，先檢查棧是否有可配對的開括號  \n    Yes → Step 5: return False // 棧空且遇到閉括號，輸入無效  \n    No  → Step 6: top ← pop stack // 從棧取出最近的開括號  \n     → Decision: top 與 c 是否匹配? // 判斷開閉括號是否相同  \n      Yes → Step 7: continue // 匹配成功，繼續遍歷  \n      No  → Step 8: return False // 匹配失敗，輸入無效  \n\n→ Decision: stack 為空? // 完成遍歷後檢查是否所有開括號都有閉括號  \n  Yes → Step 9: return True // 所有括號正確配對  \n  No  → Step 10: return False // 有未閉合的開括號  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Group Anagrams",
      "source_file": "Leetcode/leetcode49.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]",
          "expected_output": "[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]'\nGot (Norm):      '[[\"eat\",\"tea\",\"ate\"],[\"tan\",\"nat\"],[\"bat\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]'\nRaw Got:      '[[\"eat\",\"tea\",\"ate\"],[\"tan\",\"nat\"],[\"bat\"]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nfrom collections import defaultdict\n\nclass Solution:\n    def groupAnagrams(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        anagrams = defaultdict(list)\n        for s in strs:\n            key = tuple(sorted(s))  # 將字串排序後作為 key\n            anagrams[key].append(s)\n        return list(anagrams.values())\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入字串，預期形如 'strs = [\"eat\",\"tea\"]' 或直接 '[...]'\n    if '=' in data:\n        _, arr_str = data.split('=', 1)\n        arr_str = arr_str.strip()\n    else:\n        arr_str = data\n\n    try:\n        strs = ast.literal_eval(arr_str)\n    except Exception:\n        # 若解析失敗，則設為空列表\n        strs = []\n\n    solution = Solution()\n    result = solution.groupAnagrams(strs)\n\n    # 輸出為 JSON 格式，符合範例要求\n    print(json.dumps(result, separators=(',', ':')))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate pseudocode, line by line, with explanation. The requirement: virtual code with arrows and structure. Provide steps for grouping anagrams. Use data structures: hash map key: sorted string or char count. For each string, compute sorted version, use as key, push to list.\n\nWe must follow format: each line \"虛擬碼步驟 // 解釋\". Use arrows. Eg:\n\nStart // 程式開始執行\n→ Step 1: 建立空的雜湊表 anagramMap // 用來存放各組 anagram\n\nThen iterate each str in strs: → Step 2: 對 str 進行排序得到 key // 將字串轉成可比對的 key\n\n→ Step 3: 如果 key 不在 anagramMap → Step 3a: anagramMap[key] = 空列表 // 初始化列表\n\n→ Step 4: anagramMap[key].append(str) // 將原字串加入對應組\n\nAfter loop:\n\n→ Step 5: 建立結果列表 result\n\n→ Decision: 是否需要將每組的順序排序? // 依需求可保留原順序\n\n→ Step 6: 遍歷 anagramMap.values() → Step 6a: result.append(value) // 將每組加入結果\n\n→ End // 程式結束\n\nAlso include return result.\n\nLet's produce full pseudocode lines. Ensure each line ends with comment after //. Use \"Start\", \"End\". Use \"Decision:\" lines with Yes/No arrows. Provide minimal but clear. Use Chinese. Use arrow \"→\".\n\nLet's produce.\n\nWe need to maintain structure. For loops: \"Step: 迴圈\" but we can represent as \"Step: for str in strs\".\n\nWe'll use \"Step 2: 迴圈: for each str in strs\". Then inside loop: Step 3, etc. Use indentation maybe but we can't indent; we use nested arrows with spaces? We can use indentation by adding spaces? Example from format: They used:\n\n```\n→ Decision: ...\n    Yes → ...\n    No  → ...\n```\n\nThus we can indent inside Decision by spaces. For loops we might also indent.\n\nLet's create:\n\nStart // 程式開始執行\n→ Step 1: 建立空的雜湊表 anagramMap // 用來存放各組 anagram\n\n→ Step 2: 迴圈 for each str in strs // 遍歷輸入字串\n    → Step 3: 將 str 的字元排序得到 key // 排序作為鍵\n    → Decision: key 是否已存在於 anagramMap？\n        Yes → Step 4: anagramMap[key].append(str) // 已存在則加入\n        No  → Step 4a: 建立 new list [str] 並指派給 anagramMap[key] // 初始化並加入\n    // Loop continues\n\n→ Step 5: 建立結果列表 result // 用來儲存最終分組\n→ Decision: 是否需要對每組內的字串進行排序？\n    Yes → Step 6: 迴圈 for each group in anagramMap.values()\n        → Step 6a: group.sort() // 內部排序\n    No  → Step 6b: 直接跳過 // 保留原順序\n\n→ Step 7: 迴圈 for each group in anagramMap.values()\n    → Step 7a: result.append(group) // 加入結果\n\n→ Step 8: 回傳 result // 結束\n\nEnd // 程式執行結束\n\nBut we must keep each line individually, not combine multiple actions. Need separate lines for each arrow.\n\nAlso \"Step 6\" used for sorting. Might be separate. Let's produce each line separately.\n\nImportant: Each line must include \"虛擬碼步驟\" plus comment. So we need to separate them.\n\nLet's rewrite:\n\nStart // 程式開始執行\n→ Step 1: 建立空的雜湊表 anagramMap // 用來存放各組 anagram\n→ Step 2: 迴圈 for each str in strs // 遍歷輸入字串\n    → Step 3: 將 str 的字元排序得到 key // 排序作為鍵\n    → Decision: key 是否已存在於 anagramMap？\n        Yes → Step 4: anagramMap[key].append(str) // 已存在則加入\n        No  → Step 4: 建立 new list [str] 並指派給 anagramMap[key] // 初始化並加入\n→ Step 5: 建立結果列表 result // 用來儲存最終分組\n→ Decision: 是否需要對每組內的字串進行排序？\n    Yes → Step 6: 迴圈 for each group in anagramMap.values()\n        → Step 7: group.sort() // 內部排序\n    No  → Step 6: 直接跳過 // 保留原順序\n→ Step 8: 迴圈 for each group in anagramMap.values()\n    → Step 9: result.append(group) // 加入結果\n→ Step 10: 回傳 result // 結束\nEnd // 程式執行結束\n\nBut we used duplicate Step numbers for different branches. We can keep same step number for \"Yes\" and \"No\" branches? But better to give unique numbers for clarity. The spec didn't forbid duplicate numbers, but we can keep them unique.\n\nLet's restructure:\n\nStart // 程式開始執行\n→ Step 1: 建立空的雜湊表 anagramMap // 用來存放各組 anagram\n→ Step 2: 迴圈 for each str in strs // 遍歷輸入字串\n    → Step 3: 將 str 的字元排序得到 key // 排序作為鍵\n    → Decision: key 是否已存在於 anagramMap？\n        Yes → Step 4: anagramMap[key].append(str) // 已存在則加入\n        No  → Step 5: 建立 new list [str] 並指派給 anagramMap[key] // 初始化並加入\n→ Step 6: 建立結果列表 result // 用來儲存最終分組\n→ Decision: 是否需要對每組內的字串進行排序？\n    Yes → Step 7: 迴圈 for each group in anagramMap.values()\n        → Step 8: group.sort() // 內部排序\n    No  → Step 7a: 直接跳過 // 保留原順序\n→ Step 9: 迴圈 for each group in anagramMap.values()\n    → Step 10: result.append(group) // 加入結果\n→ Step 11: 回傳 result // 結束\nEnd // 程式執行結束\n\nBut we need to maintain arrow formatting. Each line after indentation should start with arrow? For lines inside Decision, they have \"Yes →\" etc. For line 4 etc. We'll do:\n\nStart // 程式開始執行\n→ Step 1: 建立空的雜湊表 anagramMap // 用來存放各組 anagram\n→ Step 2: 迴圈 for each str in strs // 遍歷輸入字串\n    → Step 3: 將 str 的字元排序得到 key // 排序作為鍵\n    → Decision: key 是否已存在於 anagramMap？\n        Yes → Step 4: anagramMap[key].append(str) // 已存在則加入\n        No  → Step 5: 建立 new list [str] 並指派給 anagramMap[key] // 初始化並加入\n→ Step 6: 建立結果列表 result // 用來儲存最終分組\n→ Decision: 是否需要對每組內的字串進行排序？\n    Yes → Step 7: 迴圈 for each group in anagramMap.values()\n        → Step 8: group.sort() // 內部排序\n    No  → Step 7a: 直接跳過 // 保留原順序\n→ Step 9: 迴圈 for each group in anagramMap.values()\n    → Step 10: result.append(group) // 加入結果\n→ Step 11: 回傳 result // 結束\nEnd // 程式執行結束\n\nMake sure each line has \"虛擬碼步驟\" + \" // 解釋\". Good.\n\nWe need to ensure each line includes the arrow. For lines inside indentation, they still have arrow at start: \"Yes →\" etc. Good.\n\nThus produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空的雜湊表 anagramMap // 用來存放各組 anagram  \n→ Step 2: 迴圈 for each str in strs // 遍歷輸入字串  \n    → Step 3: 將 str 的字元排序得到 key // 排序作為鍵  \n    → Decision: key 是否已存在於 anagramMap？  \n        Yes → Step 4: anagramMap[key].append(str) // 已存在則加入  \n        No  → Step 5: 建立 new list [str] 並指派給 anagramMap[key] // 初始化並加入  \n→ Step 6: 建立結果列表 result // 用來儲存最終分組  \n→ Decision: 是否需要對每組內的字串進行排序？  \n    Yes → Step 7: 迴圈 for each group in anagramMap.values() // 逐組處理  \n        → Step 8: group.sort() // 內部字串排序  \n    No  → Step 7a: 直接跳過 // 保留原順序  \n→ Step 9: 迴圈 for each group in anagramMap.values() // 將所有組加入結果  \n    → Step 10: result.append(group) // 加入結果  \n→ Step 11: 回傳 result // 結束  \nEnd // 程式執行結束"
    },
    {
      "title": "Implement Rand10() Using Rand7()",
      "source_file": "Leetcode/leetcode470.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 1",
          "expected_output": "[2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2]'\nGot (Norm):      '[1]'\n--- (Raw) ---\nRaw Expected: '[2]'\nRaw Got:      '[1]'"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[2,8]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,8]'\nGot (Norm):      '[2,2]'\n--- (Raw) ---\nRaw Expected: '[2,8]'\nRaw Got:      '[2, 2]'"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "[3,8,10]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,8,10]'\nGot (Norm):      '[6,1,9]'\n--- (Raw) ---\nRaw Expected: '[3,8,10]'\nRaw Got:      '[6, 1, 9]'"
        }
      ],
      "generated_code": "import sys\nimport random\n\n# 隨機產生 1~7 的數字\ndef rand7() -> int:\n    return random.randint(1, 7)\n\nclass Solution:\n    def rand10(self) -> int:\n        \"\"\"\n        使用兩次 rand7() 產生 1~49 的均勻分布。\n        只保留前 40 個數值，將其映射到 1~10。\n        \"\"\"\n        while True:\n            # (rand7() - 1) * 7 + rand7() 的結果範圍是 1~49\n            num = (rand7() - 1) * 7 + rand7()\n            if num <= 40:               # 只保留 1~40 的結果\n                return 1 + (num - 1) % 10\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取格式為 'n = X' 的字串\n    raw_input = sys.stdin.read().strip()\n    if raw_input:\n        try:\n            # 取 '=' 右邊的數字作為 n\n            n = int(raw_input.split('=')[1].strip())\n        except (IndexError, ValueError):\n            print(\"Invalid input format.\")\n            sys.exit(1)\n\n        solution = Solution()\n        results = [solution.rand10() for _ in range(n)]\n        # 將結果以列表形式輸出到標準輸出\n        print(results)\n    else:\n        print(\"No input provided.\")",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines step by step. The problem: given rand7, produce rand10. Standard solution: use two calls to rand7 to get 49 outcomes (1-49). Use rejection sampling for 1-40 to get 10 possibilities, etc. Implementation steps: generate rand7() twice to get value in 1-49. If value <=40, return (value-1)%10 + 1 else loop again.\n\nWe must produce virtual code with arrows and decisions. Each line: \"Start\" \"→\" etc.\n\nWe need to avoid any real code. Just pseudo steps. Provide explanation after comment.\n\nWe'll produce something like:\n\nStart\n→ Step 1: 重複直到獲得合法值 // 進入循環\n    → Step 2: 取 rand7() → r1 // 第一個隨機數\n    → Step 3: 取 rand7() → r2 // 第二個隨機數\n    → Step 4: 計算 combined = (r1-1)*7 + r2 // 轉換為 1~49\n    → Decision: 如果 combined <= 40? // 只保留前 40 的結果\n        Yes → Step 5: 產生 rand10 = ((combined-1) mod 10) + 1 // 映射到 1~10\n        No  → Step 6: 跳回 Step 1 // 丟棄不合格值，重試\n→ End\n\nBut we need each line with virtual code and explanation.\n\nAlso use arrow syntax: \"→\" for steps. We might indent decisions. For decision lines: \"Decision: 如果 combined <= 40?\".\n\nThen Yes and No branches.\n\nLet's create detailed steps.\n\nAlso mention that we might loop until we get a value <= 40. Provide explanation.\n\nMake sure to follow format exactly: each line \"虛擬碼步驟 [空格] // 解釋/說明\". Use Start, End, Decision. Use arrow for steps.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Step 1: 開始 while 迴圈 // 進入重試循環，直到產生合法 rand10\n    → Step 2: 呼叫 rand7() 並儲存為 a // 取得第一個隨機數\n    → Step 3: 呼叫 rand7() 並儲存為 b // 取得第二個隨機數\n    → Step 4: 計算 combined = (a-1)*7 + b // 把兩個 1~7 的值組合成 1~49\n    → Decision: 如果 combined <= 40? // 僅保留前 40 個結果\n        Yes → Step 5: 計算 result = ((combined-1) % 10) + 1 // 將 1~40 映射到 1~10\n        No  → Step 6: 直接跳回 Step 1 // 超過 40 的結果丟棄，重新嘗試\n→ End // rand10 函式結束\n\nBut we need \"Yes →\" and \"No →\" branches inside the decision. Should we indent them? Use spaces or line break? The example shows:\n\n    Yes → Step 2: 輸出 '正數' // ...\n    No  → Decision: ...\n\nSo we should indent the Yes and No branches by spaces. The \"Decision:\" line is inside the loop. So indent accordingly.\n\nAlso after \"Yes →\" we may need to \"Return result\". Add \"→ Return result\" but the example didn't have a Return step. We might add Step 5: Return result. And then \"→ End\". But we must ensure \"End\" after loop? Actually the function returns after computing result, but the loop ends by returning.\n\nSo we can add Step 5: 返回 result // 輸出 rand10\nThen we can exit loop automatically.\n\nBut the loop might require to break after return. But we can just say \"Return result\" and then the function ends.\n\nSo produce:\n\n    Yes → Step 5: 返回 result // 產生 rand10 後結束\n    No  → Step 6: 跳回 Step 1 // 重試\n\nAfter the loop, we would have End.\n\nThus final lines:\n\nStart // 程式開始執行\n→ Step 1: 進入重試循環 // 循環直到成功產生 rand10\n    → Step 2: a ← rand7() // 取得第一個 1~7 的隨機數\n    → Step 3: b ← rand7() // 取得第二個 1~7 的隨機數\n    → Step 4: combined ← (a-1)*7 + b // 合併成 1~49 的值\n    → Decision: combined <= 40? // 只保留 1~40 的範圍\n        Yes → Step 5: result ← ((combined-1) mod 10) + 1 // 將 1~40 映射到 1~10\n        No  → Step 6: 跳回 Step 1 // 超過 40 的結果丟棄，重新嘗試\n→ End // rand10 函式結束\n\nBut we need the \"Return result\" step. Maybe add Step 5: 返回 result. But we can't have two Step 5? So we can incorporate returning inside Step 5. Or add Step 5a? Let's do:\n\n    Yes → Step 5: result ← ((combined-1) mod 10) + 1 // 將 1~40 映射到 1~10\n    Yes → Step 6: 返回 result // 成功產生 rand10，結束函式\n    No  → Step 7: 跳回 Step 1 // 重新嘗試\n\nThen End.\n\nLet's incorporate. Ensure correct numbering.\n\nWe need to keep indent and arrow. The example uses \"Yes →\" and \"No  →\". The spaces after arrow are used.\n\nWe can use similar formatting.\n\nThus final answer.\n\nAlso include explanation for each step.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 進入重試循環 // 迴圈直到成功產生 rand10  \n&nbsp;&nbsp;→ Step 2: a ← rand7() // 取得第一個 1~7 的隨機數  \n&nbsp;&nbsp;→ Step 3: b ← rand7() // 取得第二個 1~7 的隨機數  \n&nbsp;&nbsp;→ Step 4: combined ← (a-1)*7 + b // 合併成 1~49 的值  \n&nbsp;&nbsp;→ Decision: combined ≤ 40? // 僅保留 1~40 的範圍  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 5: result ← ((combined-1) mod 10) + 1 // 將 1~40 映射到 1~10  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 6: 返回 result // 成功產生 rand10，結束函式  \n&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 7: 跳回 Step 1 // 超過 40 的結果丟棄，重新嘗試  \n→ End // rand10 函式結束"
    },
    {
      "title": "Time Based Key-Value Store",
      "source_file": "Leetcode/leetcode981.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"TimeMap\", \"set\", \"get\", \"get\", \"set\", \"get\", \"get\"], [[], [\"foo\", \"bar\", 1], [\"foo\", 1], [\"foo\", 3], [\"foo\", \"bar2\", 4], [\"foo\", 4], [\"foo\", 5]]",
          "expected_output": "[null, null, \"bar\", \"bar\", null, \"bar2\", \"bar2\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,\"bar\",\"bar\",null,\"bar2\",\"bar2\"]'\nGot (Norm):      '[\"null\",\"null\",\"bar\",\"bar\",\"null\",\"bar2\",\"bar2\"]'\n--- (Raw) ---\nRaw Expected: '[null, null, \"bar\", \"bar\", null, \"bar2\", \"bar2\"]'\nRaw Got:      '[\"null\", \"null\", \"bar\", \"bar\", \"null\", \"bar2\", \"bar2\"]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport ast\nfrom collections import defaultdict\nimport bisect\n\nclass TimeMap:\n    \"\"\"時間鍵值資料結構，支援同一 key 在不同 timestamp 的多值存取。\"\"\"\n    def __init__(self):\n        # key -> list of (timestamp, value)，列表保持插入順序\n        self.store = defaultdict(list)\n\n    def set(self, key: str, value: str, timestamp: int) -> None:\n        \"\"\"在指定 timestamp 記錄 key 的 value。\"\"\"\n        self.store[key].append((timestamp, value))\n\n    def get(self, key: str, timestamp: int) -> str:\n        \"\"\"\n        取得在 timestamp 之前（含 timestamp）的最新 value。\n        若不存在則回傳空字串。\n        \"\"\"\n        if key not in self.store:\n            return \"\"\n        arr = self.store[key]\n        # bisect_right 找出第一个大于 timestamp 的位置\n        i = bisect.bisect_right(arr, (timestamp, chr(127)))\n        if i == 0:\n            return \"\"\n        return arr[i - 1][1]\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 解析輸入，輸入形式為 two lists separated by comma\n    ops, args = ast.literal_eval('(' + data + ')')\n    # 初始化 TimeMap\n    obj = TimeMap()\n    outputs = []\n    for op, arg in zip(ops, args):\n        if op == \"TimeMap\":\n            # 已在上面初始化，直接跳過\n            outputs.append(\"null\")\n            continue\n        if op == \"set\":\n            obj.set(*arg)\n            outputs.append(\"null\")\n        elif op == \"get\":\n            res = obj.get(*arg)\n            outputs.append(res if res != \"\" else \"\")\n        else:\n            # 如有其他操作，可自行處理\n            outputs.append(\"null\")\n    # 將結果轉為 JSON 格式輸出，符合範例輸出樣式\n    print(json.dumps(outputs))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step for this design. It's like algorithm design. We'll produce a start, initialization, set method, get method, with decisions. We must not output actual code, only structure. Provide each line with explanation. Use arrow → for steps, Decision for branches. Use Start and End. Provide step numbers? Not necessary. Just ensure each line includes virtual code and comment. The code should be high-level. Use pseudocode. We'll design:\n\nStart\n\n→ Declare TimeMap class // Define class\n\n→ Constructor: Initialize map // map<string, list of (timestamp, value)>\n\n→ set method: append (timestamp, value) to list for key // store\n\n→ get method: binary search in list for key to find largest timestamp <= given timestamp\n\n→ if found, return value else return \"\"\n\nDecision for key existence, binary search result.\n\nWe must show step-by-step, including Decision branches.\n\nLet's produce.\n\nWe'll need lines for binary search logic:\n\nDecision: If key exists? Yes → list exists else return \"\"\n\nDecision: If list empty? but not needed.\n\nThen binary search:\n\n→ Step: low=0, high= len-1 // bounds\n\n→ Decision: while low <= high? Yes → mid = (low+high)/2 // mid index\n\n→ Decision: if timestamp_at_mid <= target? Yes → answer=mid, low=mid+1 // search right\n\nNo → high=mid-1 // search left\n\nAt end, if answer found, return value at answer else \"\"\n\nLet's format each line accordingly. Ensure arrow lines. Provide explanations in comments after //.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ 虛擬碼: 定義 TimeMap 類別 // 建立一個存放時間戳記與值的資料結構  \n→ 虛擬碼: 建構子 TimeMap()  \n  → 虛擬碼: 初始化字典 map  // key -> list of (timestamp, value)  \n→ 虛擬碼: 方法 set(key, value, timestamp)  \n  → 虛擬碼: 若 key 不在 map 中，則 map[key] ← 空列表 // 新增鍵  \n  → 虛擬碼: 將 (timestamp, value) 附加到 map[key] // 保持插入順序  \n→ 虛擬碼: 方法 get(key, timestamp)  \n  → 虛擬碼: Decision: 若 key 不在 map 中?  \n     Yes → 虛擬碼: 返回 \"\" // 無此鍵  \n  → 虛擬碼: Decision: 若 map[key] 為空?  \n     Yes → 虛擬碼: 返回 \"\" // 無任何時間戳記  \n  → 虛擬碼: 初始化 low ← 0, high ← len(map[key]) - 1, ans ← -1 // 二分搜尋參數  \n  → 虛擬碼: Decision: low <= high?  \n     Yes → 虛擬碼: mid ← (low + high) // 取中間索引 // 計算中位數  \n     → 虛擬碼: Decision: map[key][mid].timestamp <= timestamp?  \n       Yes → 虛擬碼: ans ← mid // 記錄可能答案  \n       Yes → 虛擬碼: low ← mid + 1 // 尋找更大的時間戳記  \n       No  → 虛擬碼: high ← mid - 1 // 向左搜尋  \n     → 虛擬碼: Decision: low <= high?（迴圈結束判斷）  \n  → 虛擬碼: Decision: ans != -1?  \n     Yes → 虛擬碼: 返回 map[key][ans].value // 找到最接近但不超過的值  \n     No  → 虛擬碼: 返回 \"\" // 沒有符合條件的時間戳記  \nEnd // 程式執行結束"
    },
    {
      "title": "Wiggle Sort II",
      "source_file": "Leetcode/leetcode324.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,5,1,1,6,4]",
          "expected_output": "[1,6,1,5,1,4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[1,6,1,5,1,4]'\nGot (Norm):      '[1,5,1,6,1,4]'\n--- (Raw) ---\nRaw Expected: '[1,6,1,5,1,4]'\nRaw Got:      '[1, 5, 1, 6, 1, 4]'"
        },
        {
          "example_index": 1,
          "input": "nums = [1,3,2,2,3,1]",
          "expected_output": "[2,3,1,3,1,2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,3,1,3,1,2]'\nGot (Norm):      '[1,3,2,3,1,2]'\n--- (Raw) ---\nRaw Expected: '[2,3,1,3,1,2]'\nRaw Got:      '[1, 3, 2, 3, 1, 2]'"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def wiggleSort(self, nums):\n        \"\"\"\n        Reorder nums into a wiggle sequence: nums[0] < nums[1] > nums[2] < nums[3] ...\n        This implementation scans the array once and swaps adjacent elements\n        whenever the required ordering condition is violated.  The array is\n        modified in place.\n        \"\"\"\n        n = len(nums)\n        for i in range(n - 1):\n            if i % 2 == 0:\n                # Even index: should be less than the next element\n                if nums[i] >= nums[i + 1]:\n                    nums[i], nums[i + 1] = nums[i + 1], nums[i]\n            else:\n                # Odd index: should be greater than the next element\n                if nums[i] <= nums[i + 1]:\n                    nums[i], nums[i + 1] = nums[i + 1], nums[i]\n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # The input format is expected to be something like:\n    #   nums = [1,5,1,1,6,4]\n    # Extract the list expression after the '=' sign and evaluate it.\n    try:\n        nums_expr = data.split('=', 1)[1].strip()\n        nums = eval(nums_expr, {\"__builtins__\": None}, {})\n    except Exception:\n        # If the split fails, try to evaluate the whole input directly.\n        nums = eval(data, {\"__builtins__\": None}, {})\n\n    solution = Solution()\n    solution.wiggleSort(nums)\n    print(nums)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to reorder array into wiggle sequence: nums[0] < nums[1] > nums[2] < nums[3] ... . We can use algorithm: iterate i from 0 to len-1 step 1, compare nums[i] and nums[i+1] based on parity: if i even, ensure nums[i] < nums[i+1]; else ensure nums[i] > nums[i+1]. If condition fails, swap. That's simple O(n). The array always has valid answer; this algorithm works.\n\nWe must output each line: \"虛擬碼步驟 // 解釋\". Use arrows →. Start and End.\n\nLet's craft steps:\n\nStart\n→ Step 1: 定義 len = nums.length // 取得陣列長度\n→ Step 2: 從 i = 0 到 len - 2 做:\n    → Decision: i is even? // 判斷索引是偶數\n        Yes → Step 3: 如果 nums[i] >= nums[i+1] 則交換 // 若偶數位置不符合 <，交換\n        No → Step 4: 如果 nums[i] <= nums[i+1] 則交換 // 若奇數位置不符合 >，交換\nEnd\n\nBut we need to include loops. Virtual code should reflect the algorithm.\n\nWe must use arrow for each step.\n\nWe also should include \"for i from 0 to len-2:\" but the format might be \"→ Step 2: 循環 i = 0 到 len-2\" or \"→ Loop: i from 0 to len-2\" etc.\n\nLet's produce.\n\nWe need to include \"Decision:\" lines with Yes → and No →. For the if condition inside each parity.\n\nLet's produce step lines.\n\nStart // 程式開始執行\n→ Step 1: 設定 len = nums.length // 取得陣列長度\n→ Step 2: 循環 i = 0 到 len - 2 // 遍歷所有相鄰對\n    → Decision: i % 2 == 0? // 判斷索引為偶數\n        Yes → Step 3: Decision: nums[i] >= nums[i+1]? // 檢查偶數位置是否滿足 <，若不滿足\n            Yes → Step 4: 交換 nums[i] 與 nums[i+1] // 交換以確保 nums[i] < nums[i+1]\n            No  → // 不需要交換，條件已滿足\n        No  → Step 5: Decision: nums[i] <= nums[i+1]? // 判斷奇數位置是否滿足 >，若不滿足\n            Yes → Step 6: 交換 nums[i] 與 nums[i+1] // 交換以確保 nums[i] > nums[i+1]\n            No  → // 不需要交換，條件已滿足\nEnd // 程式執行結束\n\nWe need to keep each line separate. Indentation for inner steps might be new lines with arrow. But the format requires each line contain \"虛擬碼步驟 // 解釋\". The example shows indentation with arrow lines but still each line separate.\n\nLet's produce with proper indentation lines.\n\nUse \"→\" at each new line; but inside nested decision, we indent with more arrow? The example shows indentation with tabs? The example shows \"    Yes →\" and \"    No  →\". So we can produce same.\n\nThus lines:\n\nStart // 程式開始執行\n→ Step 1: len = nums.length // 取得陣列長度\n→ Step 2: for i = 0 to len - 2 do // 遍歷所有相鄰對\n    → Decision: i % 2 == 0? // 判斷索引為偶數\n        Yes → Step 3: if nums[i] >= nums[i+1] then // 偶數位置不符合 <\n            Yes → Step 4: swap(nums[i], nums[i+1]) // 交換以確保 < \n            No  → // 條件已滿足，無需操作\n        No  → Step 5: if nums[i] <= nums[i+1] then // 奇數位置不符合 >\n            Yes → Step 6: swap(nums[i], nums[i+1]) // 交換以確保 >\n            No  → // 條件已滿足，無需操作\nEnd // 程式執行結束\n\nWe need to maintain one line per step. But inside nested if we might have lines with \"Yes → Step 4: ...\" But the indent shows each line. Ok.\n\nMake sure each line has exactly one \"虛擬碼步驟\". For example \"Yes → Step 4: ...\" qualifies. But the example uses \"Yes → Step 2: 輸出 '正數'\" etc. So that's fine.\n\nWe might need to include the \"No →\" lines too.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: len = nums.length // 取得陣列長度  \n→ Step 2: for i = 0 to len - 2 do // 遍歷所有相鄰對  \n    → Decision: i % 2 == 0? // 判斷索引為偶數  \n        Yes → Step 3: if nums[i] >= nums[i+1] then // 偶數位置不符合 <，需要交換  \n            Yes → Step 4: swap(nums[i], nums[i+1]) // 交換以確保 nums[i] < nums[i+1]  \n            No  → // 條件已滿足，無需操作  \n        No  → Step 5: if nums[i] <= nums[i+1] then // 奇數位置不符合 >，需要交換  \n            Yes → Step 6: swap(nums[i], nums[i+1]) // 交換以確保 nums[i] > nums[i+1]  \n            No  → // 條件已滿足，無需操作  \nEnd // 程式執行結束"
    },
    {
      "title": "Course Schedule II",
      "source_file": "Leetcode/leetcode210.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "numCourses = 2, prerequisites = [[1,0]]",
          "expected_output": "[0,1]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpyg69w5oc.py\", line 46, in <module>\n    numCourses, prerequisites = parse_input(raw)\n                                ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpyg69w5oc.py\", line 37, in parse_input\n    kv[key] = ast.literal_eval(value)\n              ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[1\n     ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]",
          "expected_output": "[0,2,1,3]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp1u6752oi.py\", line 46, in <module>\n    numCourses, prerequisites = parse_input(raw)\n                                ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp1u6752oi.py\", line 37, in parse_input\n    kv[key] = ast.literal_eval(value)\n              ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[1\n     ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import deque\n\nclass Solution:\n    def findOrder(self, numCourses, prerequisites):\n        graph = [[] for _ in range(numCourses)]\n        indegree = [0] * numCourses\n\n        for dest, src in prerequisites:\n            graph[src].append(dest)\n            indegree[dest] += 1\n\n        queue = deque([i for i in range(numCourses) if indegree[i] == 0])\n        order = []\n\n        while queue:\n            node = queue.popleft()\n            order.append(node)\n            for neighbor in graph[node]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    queue.append(neighbor)\n\n        return order if len(order) == numCourses else []\n\ndef parse_input(data: str):\n    \"\"\"將輸入字串解析為 numCourses 與 prerequisites。\"\"\"\n    parts = data.split(',')\n    kv = {}\n    for part in parts:\n        if '=' not in part:\n            continue\n        key, value = part.split('=', 1)\n        key = key.strip()\n        value = value.strip()\n        kv[key] = ast.literal_eval(value)\n    numCourses = kv.get('numCourses', 0)\n    prerequisites = kv.get('prerequisites', [])\n    return numCourses, prerequisites\n\nif __name__ == \"__main__\":\n    raw = sys.stdin.read().strip()\n    if not raw:\n        sys.exit()\n    numCourses, prerequisites = parse_input(raw)\n    sol = Solution()\n    result = sol.findOrder(numCourses, prerequisites)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for topological sort, maybe Kahn's algorithm or DFS. We'll output line-by-line with explanation. Use Start, Decision, etc. Use arrow. Need to include step for building adjacency list, indegree array, queue, result list, process loop, detect cycle.\n\nMake sure each line ends with // explanation.\n\nLet's write:\n\nStart\n→ Step 1: Build adjacency list and indegree from prerequisites // create graph representation\n→ Step 2: Initialize queue with courses having indegree 0 // courses ready to take\n→ Decision: 是否有課程在佇列? // check if queue not empty\n    Yes → Step 3: Pop course from queue and add to result // take course\n    → Step 4: For each neighbor, reduce indegree by 1 // update prerequisites\n    → Decision: 邊緣節點 indegree 是否變為 0? // if becomes ready\n        Yes → Step 5: 將 neighbor 加入佇列 // ready to take\n    → Step 6: 回到 Decision: 是否有課程在佇列? // repeat\n    No → End loop\n→ Decision: result長度等於numCourses? // check if all courses scheduled\n    Yes → Return result // success\n    No  → Return empty array // cycle detected\n\nLet's format exactly.\n\nWe need arrow symbol \"→\" after Start? The example shows \"Start // 程式開始執行\" no arrow. Then \"→ Step 1: ...\". So we follow.\n\nAlso Decision lines need \"Decision: ...\" and nested Yes/No with indentation.\n\nLet's produce. Ensure each line ends with // explanation in Chinese.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立鄰接表與入度陣列，從 prerequisites 讀取每一對 [a, b] // 用來表示課程與前置關係\n→ Step 2: 初始化佇列 Queue，將所有入度為 0 的課程加入 // 這些課程可以直接修習\n→ Decision: Queue 是否非空? // 檢查是否還有可修習的課程\n    Yes → Step 3: 從 Queue 取出一門課程 cur 並加入結果陣列 result // 修習此課程\n    → Step 4: 對於每個 cur 的鄰接課程 next，執行 indegree[next] ← indegree[next] - 1 // 更新其前置課程數\n    → Decision: indegree[next] 是否等於 0? // 若此課程已無未完成前置課程\n        Yes → Step 5: 將 next 放入 Queue // 現已可修習\n    → Step 6: 回到 Decision: Queue 是否非空? // 重新檢查是否還有課程可修習\n    No → // Queue 為空，所有可修習課程已處理完\n→ Decision: result 的長度是否等於 numCourses? // 判斷是否所有課程都已排程\n    Yes → Step 7: 回傳 result // 成功完成所有課程\n    No  → Step 8: 回傳空陣列 [] // 週期存在，無法完成所有課程\nEnd // 程式執行結束"
    },
    {
      "title": "Longest Palindromic Subsequence",
      "source_file": "Leetcode/leetcode516.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "\"bbbab\"",
          "expected_output": "4",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '4'\nGot (Norm):      '6'\n--- (Raw) ---\nRaw Expected: '4'\nRaw Got:      '6'"
        },
        {
          "example_index": 1,
          "input": "\"cbbd\"",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '4'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '4'"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def longestPalindromeSubseq(self, s: str) -> int:\n        n = len(s)\n        if n == 0:\n            return 0\n        dp = [[0] * n for _ in range(n)]\n        # 初始化對角線，單字符回文長度為 1\n        for i in range(n):\n            dp[i][i] = 1\n        # 從後往前填表，保證 dp[i+1][j-1] 已計算\n        for i in range(n - 1, -1, -1):\n            for j in range(i + 1, n):\n                if s[i] == s[j]:\n                    dp[i][j] = dp[i + 1][j - 1] + 2\n                else:\n                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n        return dp[0][n - 1]\n\nif __name__ == \"__main__\":\n    # 讀取輸入字串，去除首尾空白符\n    input_str = sys.stdin.read().strip()\n    # 若輸入包含換行，僅取第一行\n    if '\\n' in input_str:\n        input_str = input_str.splitlines()[0]\n    sol = Solution()\n    result = sol.longestPalindromeSubseq(input_str)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for finding longest palindromic subsequence length. Must use Start, End, Decision, etc. Provide each line virtual code with explanation. Should be in Chinese Traditional. Each line: \"虛擬碼步驟 [space] // 解釋/說明\".\n\nWe should describe algorithm: DP with 2D array dp[i][j] length of LPS in s[i..j]. Use nested loops. Provide steps.\n\nAlso need input, processing, output.\n\nWe need to use arrows \"→\" and \"Yes →\", \"No →\".\n\nLet's produce a sequence:\n\nStart\n\n→ Step 1: 輸入字串 s // 取得輸入字串\n\nDefine n = length of s // 字串長度\n\n→ Step 2: 初始化二维表 dp[n][n] // dp[i][j] 记录 s[i..j] 的最长回文子序列长度\n\n→ Decision: 是否需要考虑长度为1的子串? // 初始化\n\nYes → Step 3: 对于每个 i 从 0 到 n-1, dp[i][i] = 1 // 单字符本身是回文\n\nNo → (no action)\n\n→ Decision: 处理子串长度从 2 开始到 n // 逐步扩展子串长度\n\nYes → for len from 2 to n:\n\n    → Step 4: 对于每个 i 从 0 到 n-len:\n\n        j = i + len - 1\n\n        → Decision: s[i] == s[j]?\n\n        Yes → dp[i][j] = dp[i+1][j-1] + 2 // 两端相同，包含两端\n\n        No  → dp[i][j] = max(dp[i+1][j], dp[i][j-1]) // 两端不同，取较大子问题\n\n    End for\n\nNo → (no action)\n\n→ Step 5: 结果 = dp[0][n-1] // 整串的最长回文子序列长度\n\n→ Step 6: 输出结果 // 打印答案\n\nEnd\n\nNeed to use arrows. Also use indentation for nested. Use \"→\" and \"Yes →\", \"No →\".\n\nMake sure each line has \" // 解釋\".\n\nAlso include \"End // 程式執行結束\".\n\nLet's craft.\n\nRemember to include Step labels. Use \"Step\". For loops maybe use \"Loop\". For Decision use \"Decision:\". Provide arrows accordingly.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: 輸入字串 s // 從使用者取得輸入字串\n→ Step 2: 定義變數 n ← s.length // 字串長度\n→ Step 3: 初始化二维表 dp[n][n] 為 0 // dp[i][j] 记录 s[i..j] 的最长回文子序列长度\n→ Decision: 是否需要初始化单字符回文？ // 每个字符本身就是回文\n    Yes → Step 4: 对于 i 由 0 到 n-1, dp[i][i] ← 1 // 单字符长度为 1\n    No  → // 無需額外操作\n→ Decision: 处理子串长度从 2 开始到 n？ // 逐步扩展子串长度\n    Yes →\n        → Loop len 由 2 到 n:\n            → Loop i 由 0 到 n-len:\n                j ← i + len - 1 // 右端索引\n                → Decision: s[i] == s[j] ?\n                    Yes → dp[i][j] ← dp[i+1][j-1] + 2 // 两端相同，长度加 2\n                    No  → dp[i][j] ← max(dp[i+1][j], dp[i][j-1]) // 取较大子问题\n            → End Loop\n        → End Loop\n    No  → // 無需進一步處理\n→ Step 5: 結果 ← dp[0][n-1] // 整串的最长回文子序列长度\n→ Step 6: 輸出結果 // 打印答案\nEnd // 程式執行結束\n\nWe must ensure each line has arrow before step, decision etc. But in example they used \"→ Step 1:\" lines. For decisions, they used indentation with \"Yes →\" \"No →\". Let's mimic.\n\nAlso need \"Start\" and \"End\" lines without arrow.\n\nLet's rewrite ensuring each line has \" // 解釋\" comment.\n\nMake sure indentation uses spaces or tabs? Just use spaces.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 輸入字串 s // 從使用者取得輸入字串\n→ Step 2: 定義變數 n ← s.length // 字串長度\n→ Step 3: 初始化二维表 dp[n][n] 為 0 // dp[i][j] 记录 s[i..j] 的最长回文子序列长度\n→ Decision: 是否需要初始化单字符回文？ // 每个字符本身就是回文\n    Yes → Step 4: 对于 i 由 0 到 n-1, dp[i][i] ← 1 // 单字符长度为 1\n    No  → // 無需額外操作\n→ Decision: 处理子串长度从 2 开始到 n？ // 逐步扩展子串长度\n    Yes →\n        → Loop len 由 2 到 n:\n            → Loop i 由 0 到 n-len:\n                j ← i + len - 1 // 右端索引\n                → Decision: s[i] == s[j] ?\n                    Yes → dp[i][j] ← dp[i+1][j-1] + 2 // 两端相同，长度加 2\n                    No  → dp[i][j] ← max(dp[i+1][j], dp[i][j-1]) // 取较大子问题\n            → End Loop\n        → End Loop\n    No  → // 無需進一步處理\n→ Step 5: 結果 ← dp[0][n-1] // 整串的最长回文子序列长度\n→ Step 6: 輸出結果 // 打印答案\nEnd // 程式執行結束"
    },
    {
      "title": "First Bad Version",
      "source_file": "Leetcode/leetcode278.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 5, bad = 4",
          "expected_output": "4",
          "actual_output_or_error": "File \"/tmp/tmpegt22ajk.py\", line 37\n    global BAD_VERSION\n    ^^^^^^^^^^^^^^^^^^\nSyntaxError: name 'BAD_VERSION' is assigned to before global declaration"
        },
        {
          "example_index": 1,
          "input": "n = 1, bad = 1",
          "expected_output": "1",
          "actual_output_or_error": "File \"/tmp/tmpkr1cxa5l.py\", line 37\n    global BAD_VERSION\n    ^^^^^^^^^^^^^^^^^^\nSyntaxError: name 'BAD_VERSION' is assigned to before global declaration"
        }
      ],
      "generated_code": "import sys\nimport re\n\n# Global variable to store the first bad version\nBAD_VERSION = None\n\ndef isBadVersion(version: int) -> bool:\n    \"\"\"\n    API to check if a given version is bad.\n    It uses the global BAD_VERSION set in main.\n    \"\"\"\n    return version >= BAD_VERSION\n\nclass Solution:\n    def firstBadVersion(self, n: int) -> int:\n        \"\"\"\n        Binary search to find the first bad version among 1..n.\n        \"\"\"\n        left, right = 1, n\n        while left < right:\n            mid = left + (right - left) // 2\n            if isBadVersion(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left\n\nif __name__ == \"__main__\":\n    # Read entire stdin and extract integers (n and bad)\n    data = sys.stdin.read()\n    numbers = list(map(int, re.findall(r'\\d+', data)))\n    if len(numbers) < 2:\n        raise ValueError(\"Input must contain two integers: n and bad.\")\n    n, bad = numbers[0], numbers[1]\n\n    # Set the global BAD_VERSION for isBadVersion to use\n    global BAD_VERSION\n    BAD_VERSION = bad\n\n    # Solve and print the result\n    solution = Solution()\n    print(solution.firstBadVersion(n))",
      "virtual_code": "Thinking...\nWe need to output virtual code line by line with explanations. It's basically binary search to find first bad version. We'll produce steps: Start, define function findFirstBad(n), set low=1 high=n, while low<high, mid=(low+high)/2, if isBadVersion(mid) then high=mid else low=mid+1. End. Return low. And at the end maybe return low. Provide comments. Use virtual arrows. Ok.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義函式 findFirstBad(n) // 接收總版本數  \n→ Step 2: low ← 1 // 初始化搜尋範圍左端  \n→ Step 3: high ← n // 初始化搜尋範圍右端  \n→ Decision: low < high? // 只要範圍還有多個版本  \n    Yes → Step 4: mid ← (low + high) / 2 // 計算中間版本  \n    Yes → Decision: isBadVersion(mid)? // 判斷中間版本是否為壞版本  \n        Yes → Step 5: high ← mid // 壞版本在左半邊，包括 mid  \n        No  → Step 6: low ← mid + 1 // 壞版本在右半邊，排除 mid  \n    Yes → 回到 Decision: low < high? // 繼續迴圈  \n    No  → Step 7: return low // low 為第一個壞版本  \nEnd // 程式執行結束"
    },
    {
      "title": "Generate Random Point in a Circle",
      "source_file": "Leetcode/leetcode478.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]",
          "expected_output": "[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[-0.02493,-0.38077],[0.82314,0.38945],[0.36572,0.17248]]'\nGot (Norm):      '[None,[0.70436,0.19548],[0.55062,-0.37347],[-0.25232,0.13353]]'\n--- (Raw) ---\nRaw Expected: '[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]'\nRaw Got:      '[None, [0.70436, 0.19548], [0.55062, -0.37347], [-0.25232, 0.13353]]'"
        }
      ],
      "generated_code": "import sys\nimport math\nimport random\nimport ast\n\nclass Solution:\n    def __init__(self, radius, x_center, y_center):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n\n    def randPoint(self):\n        # 隨機半徑，sqrt 保證均勻分布\n        r = self.radius * math.sqrt(random.random())\n        theta = random.uniform(0, 2 * math.pi)\n        x = self.x_center + r * math.cos(theta)\n        y = self.y_center + r * math.sin(theta)\n        return [x, y]\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    ops = ast.literal_eval(data[0])\n    args = ast.literal_eval(data[1])\n\n    obj = None\n    results = []\n\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            obj = Solution(*arg)\n            results.append(None)\n        elif op == \"randPoint\":\n            point = obj.randPoint()\n            results.append([round(point[0], 5), round(point[1], 5)])\n        else:\n            # 若有其他方法，簡單忽略\n            results.append(None)\n\n    print(results)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. The user wants steps for function randPoint generating uniform random point inside circle. The solution class with constructor and randPoint method. We need to describe algorithm: generate random radius sqrt(r)*rand, random angle uniform [0,2π), then convert to cartesian offset from center. So we produce virtual code lines.\n\nWe need to use arrow notation: Start, → Step X: etc, Decision. Should include Step 1: initialize parameters. Step 2: generate random number for radius: r' = sqrt(rand())*radius. Step 3: generate angle: θ = 2π * rand(). Step 4: compute x = x_center + r' * cos(θ). Step 5: compute y = y_center + r' * sin(θ). Step 6: return [x, y]. The constructor simply sets attributes.\n\nAlso we might need Decision nodes? Not really. Might include a Decision: if radius <=0? but not necessary.\n\nWe'll produce a flow that starts at Start, then maybe Decision: Check if radius positive? but not needed. But we can include for clarity.\n\nWe'll output line by line.\n\nLet's draft:\n\nStart // 程式開始執行\n→ Step 1: 定義 Solution 類別 // 建立類別\n→ Step 2: Solution(radius, x_center, y_center): 初始化屬性 // 存儲半徑與中心座標\n    → Step 2.1: this.radius ← radius\n    → Step 2.2: this.x_center ← x_center\n    → Step 2.3: this.y_center ← y_center\n→ Step 3: randPoint(): 產生隨機點 // 主功能\n    → Step 3.1: r_rand ← random() // 0~1\n    → Step 3.2: radius_sample ← sqrt(r_rand) * this.radius // 調整半徑以確保均勻分佈\n    → Step 3.3: theta ← random() * 2π // 隨機角度\n    → Step 3.4: x ← this.x_center + radius_sample * cos(theta) // 轉換為 x 坐標\n    → Step 3.5: y ← this.y_center + radius_sample * sin(theta) // 轉換為 y 坐標\n    → Step 3.6: return [x, y] // 返回隨機點\nEnd // 程式執行結束\n\nWe may use Decision if we want to check if random <=1 but not necessary. We'll keep simple.\n\nWe need to follow format exactly: each line \"虛擬碼步驟 [space] // 解釋\". Use arrow \"→\" or \"Yes →\" etc. In code above we used indentation for steps 2.1 etc. Use arrow \"→\". Use colon in Decision: but not necessary. We'll keep it simple.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 Solution 類別 // 建立類別結構  \n→ Step 2: Solution(radius, x_center, y_center) // 初始化物件  \n → Step 2.1: this.radius ← radius // 儲存半徑  \n → Step 2.2: this.x_center ← x_center // 儲存中心 X 座標  \n → Step 2.3: this.y_center ← y_center // 儲存中心 Y 座標  \n→ Step 3: randPoint() // 產生隨機點  \n → Step 3.1: r_rand ← random() // 產生 0~1 的隨機數  \n → Step 3.2: radius_sample ← sqrt(r_rand) * this.radius // 調整半徑以確保均勻分佈  \n → Step 3.3: theta ← random() * 2π // 隨機角度，範圍 0~2π  \n → Step 3.4: x ← this.x_center + radius_sample * cos(theta) // 計算 X 坐標  \n → Step 3.5: y ← this.y_center + radius_sample * sin(theta) // 計算 Y 坐標  \n → Step 3.6: return [x, y] // 回傳隨機點座標  \nEnd // 程式執行結束"
    },
    {
      "title": "Remove Element",
      "source_file": "Leetcode/leetcode27.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "nums = [0,1,2,2,3,0,4,2], val = 2",
          "expected_output": "5, nums = [0,1,4,0,3,_,_,_]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '5,nums=[0,1,4,0,3,_,_,_]'\nGot (Norm):      '5,nums=[0,1,3,0,4,_,_,_]'\n--- (Raw) ---\nRaw Expected: '5, nums = [0,1,4,0,3,_,_,_]'\nRaw Got:      '5, nums = [0,1,3,0,4,_,_,_]'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\n\ndef removeElement(nums, val):\n    \"\"\"\n    In-place removal of all occurrences of `val` from `nums`.\n    Returns the count of elements that are not equal to `val`.\n    \"\"\"\n    write_index = 0\n    for i in range(len(nums)):\n        if nums[i] != val:\n            nums[write_index] = nums[i]\n            write_index += 1\n    return write_index\n\ndef main():\n    \"\"\"\n    讀取標準輸入，格式類似：\n        nums = [3,2,2,3], val = 3\n    解析後執行移除操作，並輸出\n        <k>, nums = [<modified_list>]\n    其中未被保留的元素用 \"_\" 取代。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 取得 nums 列表\n    nums_match = re.search(r'nums\\s*=\\s*(\\[[^\\]]*\\])', data)\n    # 取得 val 整數\n    val_match = re.search(r'val\\s*=\\s*(-?\\d+)', data)\n\n    if not nums_match or not val_match:\n        return\n\n    nums_list = ast.literal_eval(nums_match.group(1))\n    val = int(val_match.group(1))\n\n    k = removeElement(nums_list, val)\n\n    # 產生輸出格式\n    out_elements = []\n    for i in range(len(nums_list)):\n        if i < k:\n            out_elements.append(str(nums_list[i]))\n        else:\n            out_elements.append('_')\n    out_str = '[' + ','.join(out_elements) + ']'\n    print(f\"{k}, nums = {out_str}\")\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code step-by-step for removing elements from array in-place. Provide explanation after each line. Use Start, Decision, arrows. Provide each line of virtual code, with explanation. Let's craft.\n\nWe can use two-pointer approach: maintain write pointer. For each element, if not equal val, assign to write pointer, increment write. After loop, return write.\n\nWe need to explain steps: Start, initialize write index 0. Iterate index from 0 to length-1. For each element, decision: if nums[i] != val? yes: assign, increment. After loop: End, return write. Provide explanations.\n\nMake sure each line has \"虛擬碼步驟 // 解釋\". Use arrow \"→\". Use \"Decision:\" and Yes/No arrows. Provide the final return step. Ensure format exactly as requested. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: writeIndex ← 0 // 初始化寫入指標，指向第一個可寫位置  \n→ Step 2: for i ← 0 to nums.length - 1 // 從頭到尾遍歷整個陣列  \n  → Decision: nums[i] ≠ val? // 判斷目前元素是否為要移除的值  \n   Yes → Step 3: nums[writeIndex] ← nums[i] // 把非目標值寫入寫入指標位置  \n    → Step 4: writeIndex ← writeIndex + 1 // 移動寫入指標到下一個位置  \n   No → // 若為目標值，直接跳過，不進行寫入  \n→ Step 5: return writeIndex // 回傳非目標值的個數 k，亦即寫入指標的位置  \nEnd // 程式執行結束"
    },
    {
      "title": "Shuffle an Array",
      "source_file": "Leetcode/leetcode384.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"], [[[1, 2, 3]], [], [], []]",
          "expected_output": "[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[3,1,2],[1,2,3],[1,3,2]]'\nGot (Norm):      '[null,[1,3,2],[1,2,3],[1,2,3]]'\n--- (Raw) ---\nRaw Expected: '[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]'\nRaw Got:      '[null, [1, 3, 2], [1, 2, 3], [1, 2, 3]]'"
        }
      ],
      "generated_code": "import sys\nimport random\nimport json\nimport ast\n\nclass Solution:\n    def __init__(self, nums):\n        # 保留原始陣列\n        self.original = list(nums)\n\n    def reset(self):\n        # 回傳原始陣列\n        return list(self.original)\n\n    def shuffle(self):\n        # Fisher‑Yates 洗牌\n        arr = list(self.original)\n        n = len(arr)\n        for i in range(n):\n            j = random.randint(i, n - 1)\n            arr[i], arr[j] = arr[j], arr[i]\n        return arr\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 分離方法名稱與參數\n    # 這裡假設輸入格式為：[\"method1\",\"method2\",...], [[args1],[args2],...]\n    # 先將第一個列表截取出來\n    idx = data.find('],')\n    if idx == -1:\n        return\n    method_str = data[:idx + 1]          # 包含閉合的 ]\n    args_str = data[idx + 2:].strip()    # 後面的參數列表\n    methods = ast.literal_eval(method_str)\n    args_list = ast.literal_eval(args_str)\n\n    result = []\n    obj = None\n    for method, args in zip(methods, args_list):\n        if method == \"Solution\":\n            obj = Solution(*args)\n            result.append(None)\n        elif method == \"reset\":\n            res = obj.reset()\n            result.append(res)\n        elif method == \"shuffle\":\n            res = obj.shuffle()\n            result.append(res)\n        else:\n            # 若遇到未知方法，直接跳過\n            result.append(None)\n    # 使用 json.dumps 以符合 LeetCode 的輸出格式 (None -> null)\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code steps. Should not output actual code. Just steps. Use Start, Decision, etc. The algorithm: constructor stores original array copy. reset returns original copy. shuffle uses Fisher-Yates algorithm. Virtual code step: store original, copy for shuffle, for each index from n-1 to 1 swap with random j. So produce steps line by line with explanation.\n\nMake sure each line has \"虛擬碼步驟\" + \" // 解釋\". Use arrow notation.\n\nLet's craft.\n\nStart\n→ Step 1: Store nums into originalArray // Preserve original configuration\n→ Step 2: Create currentArray as a copy of originalArray // Working copy for shuffling\n→ Step 3: Return currentArray // reset returns original state\n\nFor shuffle:\n→ Step 1: Create a copy of originalArray into shuffled // Start with original\n→ Step 2: For i from shuffled.length-1 down to 1: // Fisher-Yates loop\n   → Step 2.1: Generate random integer j between 0 and i inclusive // Random index\n   → Step 2.2: Swap shuffled[i] with shuffled[j] // Swap elements\n→ Step 3: Return shuffled // Output random permutation\n\nWrap with Start/End. Use Decision? Not necessary. But we can show Decision for loop? Use Decision: i >= 1? Not needed. Use standard loop arrow.\n\nWe should output in one continuous block.\n\nMake sure to use `→` arrow for steps.\n\nLet's craft final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 儲存傳入的 nums 為 originalArray // 保留原始配置  \n→ Step 2: 建立 currentArray 為 originalArray 的副本 // 用於重置與隨機排列  \n→ Step 3: 回傳 currentArray // reset 方法回傳原始陣列  \n\n→ Step 4: 為 shuffle 建立 shuffled 為 originalArray 的副本 // 開始 Fisher‑Yates 隨機化  \n→ Decision: i = shuffled.length - 1 以上 1? // 從最後一個索引往前迴圈  \n    Yes → Step 5: 隨機產生 j 在 0 到 i 之間 // 選擇待交換的索引  \n    Yes → Step 6: 交換 shuffled[i] 與 shuffled[j] // 執行一次交換  \n    Yes → Step 7: i ← i - 1 // 移至上一個索引  \n    No  → Step 8: 回傳 shuffled // 完成所有交換，回傳隨機排列  \nEnd // 程式執行結束"
    },
    {
      "title": "Subsets",
      "source_file": "Leetcode/leetcode78.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nGot (Norm):      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nRaw Got:      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\ndef subsets(nums):\n    res = []\n    def backtrack(start, path):\n        res.append(path[:])\n        for i in range(start, len(nums)):\n            path.append(nums[i])\n            backtrack(i + 1, path)\n            path.pop()\n    backtrack(0, [])\n    return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    if '=' in data:\n        _, expr = data.split('=', 1)\n    else:\n        expr = data\n    expr = expr.strip()\n    try:\n        nums = ast.literal_eval(expr)\n    except Exception:\n        nums = eval(expr)\n    res = subsets(nums)\n    subset_strs = []\n    for subset in res:\n        if subset:\n            inner = ','.join(map(str, subset))\n            subset_strs.append(f'[{inner}]')\n        else:\n            subset_strs.append('[]')\n    output = '[' + ','.join(subset_strs) + ']'\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for generating power set of unique integer array. Provide each line with virtual code and explanation. Should not output actual code. Use Start, End, Decision, etc. Should produce steps for recursion or iterative. Provide simple approach: backtracking.\n\nWe should produce a list of steps with arrow, maybe like:\n\nStart\n→ Step 1: 初始化結果列表 res 為空列表\n→ Step 2: 定義回溯函式 backtrack(start, current)\n→ Decision: start 是否等於 nums長度?\n    Yes → Step 3: 將 current 的拷貝加入 res\n    No  → Step 4: Step 5...\n    etc.\n\nNeed to include steps for adding element and recursion.\n\nWe should output each line as described: \"虛擬碼步驟 // 解釋\". Use arrow arrow.\n\nLet's produce like:\n\nStart // 程式開始執行\n→ Step 1: 建立空列表 subsets 用來儲存所有子集 // 初始化結果容器\n→ Step 2: 定義回溯函式 backtrack(index, current) // 設定遞迴\n→ Decision: index 是否等於 nums長度? // 判斷是否到達陣列尾端\n    Yes → Step 3: 把 current 的複本加入 subsets // 將目前子集加入結果\n    No  → Step 4: 將 current 複本加入 subsets // 先不選取 nums[index]\n    No  → Step 5: 將 nums[index] 加入 current // 選取 nums[index]\n    No  → Step 6: 呼叫 backtrack(index+1, current) // 進行遞迴\n    No  → Step 7: 從 current 移除最後加入的元素 // 回溯\nEnd // 程式結束\n\nBut we need to ensure each line separated. We need to show arrow indentation maybe not needed but we can keep.\n\nWe should use \"→\" after each step line, but not nested decisions indentation. We can indent by spaces? The example uses indent and sub-lines. We'll replicate:\n\nStart // 程式開始執行\n→ Step 1: 建立空列表 subsets 用來儲存所有子集 // 初始化結果容器\n→ Step 2: 定義回溯函式 backtrack(index, current) // 設定遞迴\n→ Decision: index 是否等於 nums長度? // 判斷是否到達陣列尾端\n    Yes → Step 3: 把 current 的複本加入 subsets // 將目前子集加入結果\n    No  → Step 4: 將 current 複本加入 subsets // 先不選取 nums[index]\n    No  → Step 5: 將 nums[index] 加入 current // 選取 nums[index]\n    No  → Step 6: 呼叫 backtrack(index+1, current) // 進行遞迴\n    No  → Step 7: 從 current 移除最後加入的元素 // 回溯\n→ Step 8: 呼叫 backtrack(0, []) // 開始遞迴\n→ Step 9: 回傳 subsets // 返回結果\nEnd // 程式結束執行\n\nBut we need to ensure the decision line covers all sub-steps. Usually we might need to separate decision for each branch. But we can show the decisions as separate lines: For No branch we might have steps inside.\n\nWe should make sure each line is separate; maybe no nested lines? But example uses indentation. We'll follow.\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 建立空列表 subsets 用來儲存所有子集 // 初始化結果容器\n→ Step 2: 定義回溯函式 backtrack(index, current) // 設定遞迴\n→ Decision: index 是否等於 nums長度? // 判斷是否已經走到陣列尾端\n    Yes → Step 3: 把 current 的複本加入 subsets // 將目前子集加入結果\n    No  → Step 4: 將 current 複本加入 subsets // 先不選取 nums[index]\n    No  → Step 5: 將 nums[index] 加入 current // 選取 nums[index]\n    No  → Step 6: 呼叫 backtrack(index+1, current) // 進行遞迴\n    No  → Step 7: 從 current 移除最後加入的元素 // 回溯\n→ Step 8: 呼叫 backtrack(0, []) // 開始遞迴\n→ Step 9: 回傳 subsets // 返回結果\nEnd // 程式執行結束\n```"
    },
    {
      "title": "Task Scheduler",
      "source_file": "Leetcode/leetcode621.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 2",
          "expected_output": "8",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpk4smntej.py\", line 58, in <module>\n    tasks, n = parse_input(raw_input)\n               ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpk4smntej.py\", line 53, in parse_input\n    raise ValueError(\"tasks 必須是列表\")\nValueError: tasks 必須是列表"
        },
        {
          "example_index": 1,
          "input": "tasks = [\"A\",\"C\",\"A\",\"B\",\"D\",\"B\"], n = 1",
          "expected_output": "6",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpuv79b7vv.py\", line 58, in <module>\n    tasks, n = parse_input(raw_input)\n               ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpuv79b7vv.py\", line 53, in parse_input\n    raise ValueError(\"tasks 必須是列表\")\nValueError: tasks 必須是列表"
        },
        {
          "example_index": 2,
          "input": "tasks = [\"A\",\"A\",\"A\", \"B\",\"B\",\"B\"], n = 3",
          "expected_output": "10",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmppvklhciv.py\", line 58, in <module>\n    tasks, n = parse_input(raw_input)\n               ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmppvklhciv.py\", line 53, in parse_input\n    raise ValueError(\"tasks 必須是列表\")\nValueError: tasks 必須是列表"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import Counter\n\ndef least_interval(tasks, n):\n    \"\"\"\n    計算完成所有任務所需的最少 CPU 週期數。\n    依據冷卻時間 n，先統計各任務的頻率，\n    再利用「最大頻率任務」的數量與空閒區域計算最少閒置時間。\n    \"\"\"\n    if not tasks:\n        return 0\n\n    task_counts = Counter(tasks)\n    max_freq = max(task_counts.values())\n    # 有多少個任務擁有最大頻率\n    max_count = sum(1 for cnt in task_counts.values() if cnt == max_freq)\n\n    # 計算空閒區域（idle slots）\n    # 每個最大頻率任務之間至少需要 n 個空間\n    empty_slots = (max_freq - 1) * (n + 1)\n    # 已經佔用了空閒區域的部分\n    occupied = len(tasks) - max_count\n    idle = max(empty_slots - occupied, 0)\n\n    return len(tasks) + idle\n\ndef parse_input(raw: str):\n    \"\"\"\n    從輸入字串中解析 tasks 與 n。\n    支援類似 \"tasks = [\\\"A\\\",\\\"B\\\"], n = 2\" 的格式，亦可在多行輸入。\n    \"\"\"\n    raw = raw.replace('\\n', '').strip()\n    # 找出 n 的位置\n    parts = raw.split('n =')\n    if len(parts) != 2:\n        raise ValueError(\"輸入格式錯誤，缺少 n = ...\")\n    n_str = parts[1].strip()\n    try:\n        n = int(n_str)\n    except ValueError:\n        raise ValueError(\"n 必須為整數\")\n\n    # 解析 tasks 列表\n    tasks_part = parts[0].split('tasks =')[1].strip()\n    # 使用 ast.literal_eval 解析安全\n    try:\n        tasks = ast.literal_eval(tasks_part)\n    except Exception as e:\n        raise ValueError(\"tasks 必須為列表格式\") from e\n\n    if not isinstance(tasks, list):\n        raise ValueError(\"tasks 必須是列表\")\n    return tasks, n\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    tasks, n = parse_input(raw_input)\n    result = least_interval(tasks, n)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for scheduling tasks with cooling period. Essentially typical problem: find max freq, compute idle slots. Approach: count frequencies, find max freq, count how many tasks have that max freq. Compute empty slots = (max_freq -1)*(n+1) - (total tasks - count_max). If empty slots <0 then answer = total tasks else answer = empty slots + total tasks. We'll produce step-by-step pseudo. Let's produce lines: Start, input, count frequencies, find max_freq, count_max, compute empty slots, compute idle, compute result, output result, End. Use arrows. Provide explanation. No actual code. Use \"Step\" names. Provide Decision maybe. Could use Decision: if empty_slots<0? Yes-> result=total else result=... But just compute. We'll include decisions.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取任務陣列 `tasks` 與冷卻時間 `n` // 從輸入取得資料  \n→ Step 2: 建立頻率表 `freq[26]`，並統計每個字母出現的次數 // 計算各任務重複次數  \n→ Decision: 是否有任何任務?  \n    No → Step 3: 輸出 0 // 空陣列直接結束  \n    Yes → Step 4: 找出最大頻率 `maxFreq` 以及擁有此頻率的任務數量 `maxCount` // 取頻率最高的任務  \n→ Step 5: 計算可空出區域數 `emptySlots = (maxFreq - 1) * (n + 1)` // 每個高頻任務間需要的最小空位  \n→ Step 6: 減去已安排的非高頻任務數 `occupied = len(tasks) - maxCount`  \n→ Step 7: 計算實際需要的空閒間隔 `idle = emptySlots - occupied` // 余下空位減去已佔用空位  \n→ Decision: idle 是否小於 0?  \n    Yes → Step 8: 設定 `idle = 0` // 若空閒間隔負數，表示不需要額外閒置  \n    No → Keep idle as computed  \n→ Step 9: 計算總需間隔 `totalIntervals = len(tasks) + idle` // 任務數加上必要閒置  \n→ Step 10: 輸出 `totalIntervals` // 回傳最小 CPU 週期數  \nEnd // 程式執行結束"
    },
    {
      "title": "Different Ways to Add Parentheses",
      "source_file": "Leetcode/leetcode241.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "expression = \"2-1-1\"",
          "expected_output": "[0,2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[0,2]'\nGot (Norm):      '[2,0]'\n--- (Raw) ---\nRaw Expected: '[0,2]'\nRaw Got:      '[2, 0]'"
        },
        {
          "example_index": 1,
          "input": "expression = \"2*3-4*5\"",
          "expected_output": "[-34,-14,-10,-10,10]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[-34,-14,-10,-10,10]'\nGot (Norm):      '[-34,-10,-14,-10,10]'\n--- (Raw) ---\nRaw Expected: '[-34,-14,-10,-10,10]'\nRaw Got:      '[-34, -10, -14, -10, 10]'"
        }
      ],
      "generated_code": "class Solution:\n    def diffWaysToCompute(self, expression):\n        memo = {}\n\n        def ways(expr):\n            if expr in memo:\n                return memo[expr]\n            res = []\n            for i, ch in enumerate(expr):\n                if ch in '+-*':\n                    left = ways(expr[:i])\n                    right = ways(expr[i + 1:])\n                    for l in left:\n                        for r in right:\n                            if ch == '+':\n                                res.append(l + r)\n                            elif ch == '-':\n                                res.append(l - r)\n                            else:\n                                res.append(l * r)\n            if not res:\n                res.append(int(expr))\n            memo[expr] = res\n            return res\n\n        return ways(expression)\n\n\ndef main():\n    import sys\n    import re\n\n    data = sys.stdin.read().strip()\n    # 尋找雙引號中的表達式字串\n    match = re.search(r'\"([^\"]*)\"', data)\n    if match:\n        expression = match.group(1)\n    else:\n        expression = data  # 直接使用整個輸入\n\n    solution = Solution()\n    results = solution.diffWaysToCompute(expression)\n    print(results)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for a solution: given a string expression of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. This is the \"Different Ways to Add Parentheses\" problem (LeetCode 241). We need to produce pseudo code, line by line, each line with a step and explanation comment. Use arrows, Start, End, Decision. We must not output real code. Provide virtual code structure: parse expression, recursion/memoization, etc. We need to handle all possible splits, compute left and right recursively. Use memoization dictionary keyed by substring.\n\nWe must produce each step as \"虛擬碼步驟 // 解釋\". Use arrow \"→\" and indent Decision: etc.\n\nLet's produce:\n\nStart\n→ Step 1: 初始化 memo 为空 // 用於存儲已計算子表達式的結果\n→ Step 2: 定義遞歸函數 Compute(sub_expr) // 計算子表達式的所有結果\n   → Decision: 子表達式是否只含數字? // 判斷是否已是基礎情況\n        Yes → Return [整数值] // 直接返回數字作為唯一結果\n        No  → Decision: memo 是否包含子表達式? // 檢查是否已計算\n            Yes → Return memo[sub_expr] // 直接取出緩存\n            No  → Step 3: 初始化 result_list = [] // 用於收集本次子表達式所有結果\n                  → Step 4: 遍歷子表達式中每個字符，若字符是運算符 -> // 分割表達式\n                       → Step 5: left = sub_expr[0:idx] // 左子表達式\n                       → Step 6: right = sub_expr[idx+1:] // 右子表達式\n                       → Step 7: left_results = Compute(left) // 递归计算左侧\n                       → Step 8: right_results = Compute(right) // 递归计算右侧\n                       → Step 9: 遍歷 left_results\n                           → Step 10: 遍歷 right_results\n                               → Step 11: 計算 left_val op right_val // 根據運算符計算\n                               → Step 12: result_list.append(計算結果) // 加入結果\n                  → Step 13: memo[sub_expr] = result_list // 缓存結果\n                  → Step 14: Return result_list // 返回本次子表達式所有結果\n→ Step 15: 呼叫 Compute(expression) // 計算整個表達式\n→ End // 程式結束\n\nBut each line must be a \"虛擬碼步驟\" with arrow or step. We need to ensure each line includes arrow \"→\" except start? The example uses \"Start\" without arrow. Then \"→ Step 1: ...\". For Decision, we indent and provide Yes / No arrow lines.\n\nWe need to be careful about indentation. Use spaces.\n\nAlso include the line numbers? Not required. Just each line.\n\nWe must not output actual code, only pseudo.\n\nLet's format.\n\nAlso include \"Start // 程式開始執行\".\n\nOk. Provide lines accordingly.\n\nAlso maybe we include \"End // 程式執行結束\".\n\nMake sure each line has \" // 解釋/說明\" after.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 memo 為空字典 // 用於緩存已計算子表達式的結果  \n→ Step 2: 定義遞歸函數 Compute(sub_expr) // 計算子表達式的所有可能結果  \n　→ Decision: 子表達式只含數字? // 判斷是否為基礎情況  \n　　　Yes → Return [將子表達式轉為整數] // 直接返回數字作為唯一結果  \n　　　No → Decision: memo 是否包含子表達式? // 檢查是否已計算過  \n　　　　　Yes → Return memo[sub_expr] // 直接從緩存取值  \n　　　　　No → Step 3: result_list ← [] // 用於收集本次子表達式所有結果  \n　　　　　　 → Step 4: 對子表達式中的每個字符 i 進行遍歷  \n　　　　　　　　　→ Decision: 字符是否為運算符?  \n　　　　　　　　　　　　Yes → Step 5: left ← sub_expr[0:i] // 左子表達式  \n　　　　　　　　　　　　　　Step 6: right ← sub_expr[i+1:] // 右子表達式  \n　　　　　　　　　　　　　　Step 7: left_results ← Compute(left) // 递归计算左侧结果  \n　　　　　　　　　　　　　　Step 8: right_results ← Compute(right) // 递归计算右侧结果  \n　　　　　　　　　　　　　　Step 9: 對 left_results 中的每個 left_val 進行遍歷  \n　　　　　　　　　　　　　　　　→ Step 10: 對 right_results 中的每個 right_val 進行遍歷  \n　　　　　　　　　　　　　　　　　→ Step 11: result ← Evaluate(left_val, sub_expr[i], right_val) // 根據運算符計算  \n　　　　　　　　　　　　　　　　　→ Step 12: result_list.append(result) // 加入本次計算結果  \n　　　　　　 → Step 13: memo[sub_expr] ← result_list // 缓存本次子表達式所有結果  \n　　　　　　 → Step 14: Return result_list // 返回本次子表達式的所有可能結果  \n→ Step 15: final_results ← Compute(expression) // 計算整個表達式的所有結果  \nEnd // 程式執行結束"
    },
    {
      "title": "Basic Calculator",
      "source_file": "Leetcode/leetcode224.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "s = \" 2-1 + 2 \"",
          "expected_output": "3",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '3'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: '3'\nRaw Got:      '1'"
        }
      ],
      "generated_code": "import sys\n\ndef evaluate(s: str, idx: int = 0):\n    \"\"\"遞迴解析子表達式，返回結果與當前索引\"\"\"\n    stack = []          # 用來儲存已處理的數值，處理 * / 的優先級\n    num = 0             # 正在組裝的數字\n    sign = '+'          # 上一個讀到的運算符，預設為 +\n    i = idx\n\n    while i < len(s):\n        ch = s[i]\n\n        # 跳過空白字元\n        if ch == ' ':\n            i += 1\n            continue\n\n        # 數字，累積成完整整數\n        if ch.isdigit():\n            num = num * 10 + int(ch)\n\n        # 遇到左括號，遞迴計算括號內的表達式\n        elif ch == '(':\n            sub_val, new_idx = evaluate(s, i + 1)\n            num = sub_val\n            i = new_idx  # i 會在後面再次加 1，跳到右括號後的位置\n\n        # 如果遇到運算符、右括號或到達字串結尾，處理上一個運算符\n        if ch in '+-*/)' or i == len(s) - 1:\n            if sign == '+':\n                stack.append(num)\n            elif sign == '-':\n                stack.append(-num)\n            elif sign == '*':\n                stack.append(stack.pop() * num)\n            elif sign == '/':\n                stack.append(int(stack.pop() / num))  # 向 0 截斷的整數除法\n            num = 0\n            if ch in '+-*/':\n                sign = ch\n            if ch == ')':\n                break  # 右括號結束此層遞迴\n\n        i += 1\n\n    return sum(stack), i\n\ndef main():\n    data = sys.stdin.read().strip()\n    # 取得被雙引號包裹的字串，若無則直接使用整個輸入\n    start = data.find('\"')\n    end = data.rfind('\"')\n    if start != -1 and end != -1 and start < end:\n        expr = data[start + 1:end]\n    else:\n        expr = data\n\n    result, _ = evaluate(expr)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for evaluating expression string with + - * /. It's a basic calculator that supports parentheses? The problem statement: \"Given a string s representing a valid expression, implement a basic calculator to evaluate it, and return the result of the evaluation.\" Usually this refers to LeetCode 227 or 224. Since note says not allowed to use eval. Probably we need to parse with stack, handle +, -, *, /, parentheses. Provide pseudocode lines with explanation. Must use virtual code with arrows and decision. Each line: \"虛擬碼步驟 // 解釋\". Use Start, End. Include loops. We need to output each line separately. Provide step-by-step algorithm: traverse string, use stack for numbers and operators, handle precedence. Let's design.\n\nAlgorithm idea:\n1. Initialize stack, current number = 0, sign = '+', i = 0.\n2. While i < len(s):\n   - char = s[i]\n   - If digit: build current number.\n   - If '(': push current sign and current number onto stack? Another approach: recursive evaluation.\n   - Actually easier: use stack for numbers and operators, or compute on the fly using last sign.\n   - Classic solution: when see operator or end, apply last sign: if sign is '+', push current number; if '-', push -current; if '*', pop last number, push last * current; if '/', pop last number, push last / current (integer division). Then set sign to current operator and reset current number.\n   - For parentheses: when '(', recursively evaluate until ')', returning value and index.\n\nBut we need pseudocode: Use recursion function Evaluate(start index). Inside loop until end or ')'.\n\nLet's produce pseudocode:\n\nStart\n→ Function Evaluate(start): // returns [value, index]\n    → Initialize stack = []\n    → Initialize num = 0\n    → Initialize sign = '+'\n    → Initialize i = start\n    → While i < len(s):\n        → ch = s[i]\n        → If ch is digit:\n            → num = num * 10 + int(ch)\n        → If ch == '(':\n            → result, newIndex = Evaluate(i + 1)\n            → num = result\n            → i = newIndex\n        → Decision: If ch in '+-*/)' or i == len(s) - 1? // operator or end\n            → Yes → Apply last sign to stack with num\n                → Decision: sign == '+':\n                    → Yes → stack.push(num)\n                → No → Decision: sign == '-':\n                    → Yes → stack.push(-num)\n                → No → Decision: sign == '*':\n                    → Yes → last = stack.pop(); stack.push(last * num)\n                → No → Decision: sign == '/':\n                    → Yes → last = stack.pop(); stack.push(int(last / num))\n            → Reset num = 0\n            → If ch in '+-*/':\n                → sign = ch\n            → If ch == ')':\n                → Break\n        → Increment i\n    → result = sum(stack)\n    → Return [result, i]\nEnd\n\nBut we need each line with explanation. Use arrow after Start, and indentation for decisions.\n\nLet's format as required: \"虛擬碼步驟 // 解釋\".\n\nEnsure each line includes a space between code and comment.\n\nLet's generate lines:\n\nStart // 程式開始執行\n→ Function Evaluate(start): // 開始遞迴評估子表達式，參數為起始索引\n    → stack = [] // 用於暫存數值以處理優先級\n    → num = 0 // 當前正在組裝的數字\n    → sign = '+' // 上一個讀到的運算符，預設為加號\n    → i = start // 從給定起始位置開始掃描\n    → While i < len(s): // 逐字掃描字串\n        → ch = s[i] // 取得目前字元\n        → Decision: 如果 ch 是數字? // 判斷是否為數字\n            → Yes → num = num * 10 + int(ch) // 組裝多位數\n        → No  → Decision: ch == '('? // 判斷是否為左括號\n            → Yes → subVal, newIdx = Evaluate(i + 1) // 進入子表達式評估\n            → num = subVal // 取得子表達式結果\n            → i = newIdx // 更新索引到右括號後\n        → No  → Decision: ch in '+-*/)' or i == len(s)-1? // 遇到運算符、右括號或字串結尾\n            → Yes → Decision: sign == '+'\n                → Yes → stack.append(num) // 加號，直接加入堆疊\n            → No  → Decision: sign == '-'\n                → Yes → stack.append(-num) // 減號，加入負數\n            → No  → Decision: sign == '*'\n                → Yes → last = stack.pop(); stack.append(last * num) // 乘法，與前一數值合併\n            → No  → Decision: sign == '/'\n                → Yes → last = stack.pop(); stack.append(int(last / num)) // 除法，保留整數結果\n            → Reset num = 0 // 重置數字\n            → Decision: ch in '+-*/'?\n                → Yes → sign = ch // 記錄新的運算符\n            → Decision: ch == ')'?\n                → Yes → Break // 右括號結束子表達式\n        → i = i + 1 // 移動到下一個字元\n    → result = sum(stack) // 將堆疊內所有數字相加得到子表達式值\n    → Return [result, i] // 回傳結果及當前索引\nEnd // 程式結束\n\nBut indentation might be tricky: we need each line as separate output, not nested. The example uses indentation via spaces for decisions? They used indentation with arrow after Decision: but they didn't indent decisions themselves; just line by line. Let's follow example.\n\nIn example:\n\n→ Decision: 如果數字大於 0? // ...\n    Yes → Step 2...\n    No  → Decision: ...\n\nThey used indentation for Yes/No lines. We need to mimic.\n\nThus we must output each line exactly. We'll use spaces before lines that are under decisions. But we need to preserve structure. We'll produce lines accordingly.\n\nLet's format properly.\n\nLine 1: Start // 程式開始執行\nLine 2: → Function Evaluate(start): // 開始遞迴評估子表達式，參數為起始索引\nLine 3: → stack = [] // 用於暫存數值以處理優先級\nLine 4: → num = 0 // 當前正在組裝的數字\nLine 5: → sign = '+' // 上一個讀到的運算符，預設為加號\nLine 6: → i = start // 從給定起始位置開始掃描\nLine 7: → While i < len(s): // 逐字掃描字串\nLine 8: → ch = s[i] // 取得目前字元\nLine 9: → Decision: ch 是數字? // 判斷是否為數字\nLine 10:     Yes → num = num * 10 + int(ch) // 組裝多位數\nLine 11:     No  → Decision: ch == '('? // 判斷是否為左括號\nLine 12:         Yes → subVal, newIdx = Evaluate(i + 1) // 進入子表達式評估\nLine 13:         → num = subVal // 取得子表達式結果\nLine 14:         → i = newIdx // 更新索引到右括號後\nLine 15:         No  → Decision: ch in '+-*/)' or i == len(s)-1? // 遇到運算符、右括號或字串結尾\nLine 16:             Yes → Decision: sign == '+'\nLine 17:                 Yes → stack.append(num) // 加號，直接加入堆疊\nLine 18:             No  → Decision: sign == '-'\nLine 19:                 Yes → stack.append(-num) // 減號，加入負數\nLine 20:             No  → Decision: sign == '*'\nLine 21:                 Yes → last = stack.pop(); stack.append(last * num) // 乘法，與前一數值合併\nLine 22:             No  → Decision: sign == '/'\nLine 23:                 Yes → last = stack.pop(); stack.append(int(last / num)) // 除法，保留整數結果\nLine 24:             → Reset num = 0 // 重置數字\nLine 25:             Decision: ch in '+-*/'?\nLine 26:                 Yes → sign = ch // 記錄新的運算符\nLine 27:             Decision: ch == ')'?\nLine 28:                 Yes → Break // 右括號結束子表達式\nLine 29: → i = i + 1 // 移動到下一個字元\nLine 30: → result = sum(stack) // 將堆疊內所有數字相加得到子表達式值\nLine 31: → Return [result, i] // 回傳結果及當前索引\nLine 32: End // 程式結束\n\nBut we need to maintain proper indentation for nested decisions. Use spaces before \"Yes\" or \"No\" lines. Also \"→\" inside nested may need no arrow? Example uses \"Yes →\" same level. For nested decisions, the indentation is with spaces.\n\nLet's adjust to be consistent with example: after a Decision, the Yes and No lines are indented (two spaces maybe). Example shows:\n\n    Yes → Step 2: ...\n    No  → Decision: ...\n\nSo 4 spaces before Yes? They use 4 spaces. We'll use 4 spaces before Yes and No. For nested within nested decisions, we add 4 more spaces each level.\n\nLet's craft carefully.\n\nLine 9: Decision: ch 是數字? // 判斷是否為數字\nLine 10:     Yes → num = num * 10 + int(ch) // 組裝多位數\nLine 11:     No  → Decision: ch == '('? // 判斷是否為左括號\nLine 12:         Yes → subVal, newIdx = Evaluate(i + 1) // 進入子表達式評估\nLine 13:         → num = subVal // 取得子表達式結果\nLine 14:         → i = newIdx // 更新索引到右括號後\nLine 15:         No  → Decision: ch in '+-*/)' or i == len(s)-1? // 遇到運算符、右括號或字串結尾\nLine 16:             Yes → Decision: sign == '+'\nLine 17:                 Yes → stack.append(num) // 加號，直接加入堆疊\nLine 18:             No  → Decision: sign == '-'\nLine 19:                 Yes → stack.append(-num) // 減號，加入負數\nLine 20:             No  → Decision: sign == '*'\nLine 21:                 Yes → last = stack.pop(); stack.append(last * num) // 乘法，與前一數值合併\nLine 22:             No  → Decision: sign == '/'\nLine 23:                 Yes → last = stack.pop(); stack.append(int(last / num)) // 除法，保留整數結果\nLine 24:             → Reset num = 0 // 重置數字\nLine 25:             Decision: ch in '+-*/'?\nLine 26:                 Yes → sign = ch // 記錄新的運算符\nLine 27:             Decision: ch == ')'?\nLine 28:                 Yes → Break // 右括號結束子表達式\n\nNeed to maintain indentation: line 24 has 12 spaces before \"→\" maybe? In example, after nested decisions, the action lines not preceded by Yes/No but still same indentation as inside.\n\nSimplify: we can keep same indentation for \"→\" lines as for preceding decisions.\n\nOk.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行\n→ Function Evaluate(start): // 開始遞迴評估子表達式，參數為起始索引\n→ stack = [] // 用於暫存數值以處理優先級\n→ num = 0 // 當前正在組裝的數字\n→ sign = '+' // 上一個讀到的運算符，預設為加號\n→ i = start // 從給定起始位置開始掃描\n→ While i < len(s): // 逐字掃描字串\n→ ch = s[i] // 取得目前字元\n→ Decision: ch 是數字? // 判斷是否為數字\n    Yes → num = num * 10 + int(ch) // 組裝多位數\n    No  → Decision: ch == '('? // 判斷是否為左括號\n        Yes → subVal, newIdx = Evaluate(i + 1) // 進入子表達式評估\n        → num = subVal // 取得子表達式結果\n        → i = newIdx // 更新索引到右括號後\n        No  → Decision: ch in '+-*/)' or i == len(s)-1? // 遇到運算符、右括號或字串結尾\n            Yes → Decision: sign == '+'\n                Yes → stack.append(num) // 加號，直接加入堆疊\n            No  → Decision: sign == '-'\n                Yes → stack.append(-num) // 減號，加入負數\n            No  → Decision: sign == '*'\n                Yes → last = stack.pop(); stack.append(last * num) // 乘法，與前一數值合併\n            No  → Decision: sign == '/'\n                Yes → last = stack.pop(); stack.append(int(last / num)) // 除法，保留整數結果\n            → Reset num = 0 // 重置數字\n            Decision: ch in '+-*/'?\n                Yes → sign = ch // 記錄新的運算符\n            Decision: ch == ')'?\n                Yes → Break // 右括號結束子表達式\n→ i = i + 1 // 移動到下一個字元\n→ result = sum(stack) // 將堆疊內所有數字相加得到子表達式值\n→ Return [result, i] // 回傳結果及當前索引\nEnd // 程式結束"
    },
    {
      "title": "Excel Sheet Column Number",
      "source_file": "Leetcode/leetcode171.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "columnTitle = 'A'",
          "expected_output": "1",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '1'\nGot (Norm):      '1608111596752735779042573'\n--- (Raw) ---\nRaw Expected: '1'\nRaw Got:      '1608111596752735779042573'"
        },
        {
          "example_index": 1,
          "input": "columnTitle = 'AB'",
          "expected_output": "28",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '28'\nGot (Norm):      '41810901515571130255107575'\n--- (Raw) ---\nRaw Expected: '28'\nRaw Got:      '41810901515571130255107575'"
        },
        {
          "example_index": 2,
          "input": "columnTitle = 'ZY'",
          "expected_output": "701",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '701'\nGot (Norm):      '41810901515571130255125073'\n--- (Raw) ---\nRaw Expected: '701'\nRaw Got:      '41810901515571130255125073'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def titleToNumber(self, columnTitle: str) -> int:\n        \"\"\"\n        Convert an Excel column title to its corresponding number.\n        \"\"\"\n        result = 0\n        for ch in columnTitle:\n            # 每個字母相對於 'A' 的偏移加 1，並累加至結果\n            result = result * 26 + (ord(ch) - ord('A') + 1)\n        return result\n\ndef main():\n    # 讀取所有輸入（例如：\"columnTitle = 'AB'\"）\n    data = sys.stdin.read()\n\n    # 從輸入中擷取字串值（位於單引號之間）\n    match = re.search(r\"='([^']*)'\", data)\n    if match:\n        title = match.group(1)\n    else:\n        # 若無匹配，直接使用整個輸入（去除空白）\n        title = data.strip()\n\n    # 轉換並輸出結果\n    solution = Solution()\n    print(solution.titleToNumber(title))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step. Use the format: each line with \"虛擬碼步驟 // 解釋\". Use arrows, Decision, etc.\n\nWe need algorithm: convert Excel column title to number. Approach: iterate over characters, compute result = result*26 + (char - 'A' + 1).\n\nWe need to present as steps. Provide starting, input, decision etc. Provide variable initialization, loop, etc.\n\nLet's produce lines:\n\nStart // 程式開始\n→ Step 1: Set result = 0 // 初始化結果為0\n→ Step 2: For each character ch in columnTitle // 遍歷每個字母\n→ Decision: 是否已處理完所有字母? // 檢查是否還有字母未處理\n    No → Step 3: result = result * 26 + (ch - 'A' + 1) // 更新結果\n    Yes → Step 4: 返回 result // 輸出最終列號\nEnd // 程式結束\n\nWe might need to include the loop structure. Use for loop. Use decision for loop condition.\n\nLet's produce more precise steps. Use \"Start\", \"→\", \"Decision\". Provide explanation each line.\n\nWe can also include initialization of variable to store length or index. Might use index i=0.\n\nBetter to represent:\n\nStart\n→ Step 1: Set result = 0 // 初始化累加器\n→ Step 2: Set i = 0 // 索引指向第一個字符\n→ Decision: i < length(columnTitle)? // 檢查是否還有未處理的字符\n    Yes → Step 3: ch = columnTitle[i] // 取得當前字符\n    Yes → Step 4: result = result * 26 + (ch - 'A' + 1) // 更新結果\n    Yes → Step 5: i = i + 1 // 移動到下一個字符\n    No → Step 6: Return result // 回傳最終列號\nEnd\n\nWe must include \"→\" for each step. Ensure the Decision line indent with Yes/No branches.\n\nWe can also combine steps: Step 3 and 4 under Yes branch. Provide separate lines.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 設定 result = 0 // 初始化列號累加器\n→ Step 2: 設定 i = 0 // 初始化索引，指向第一個字母\n→ Decision: i < length(columnTitle) ? // 檢查是否還有未處理的字母\n    Yes → Step 3: ch = columnTitle[i] // 取得目前字母\n    Yes → Step 4: result = result * 26 + (ch - 'A' + 1) // 把字母轉成數值並累加\n    Yes → Step 5: i = i + 1 // 移動索引到下一個字母\n    No  → Step 6: Return result // 所有字母已處理，回傳最終列號\nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick with Weight",
      "source_file": "Leetcode/leetcode528.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\",\"pickIndex\"], [[[1]],[]]",
          "expected_output": "[null,0]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpyutrgu5e.py\", line 24, in <module>\n    ops, args = json.loads(data)\n                ^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 25 (char 24)"
        },
        {
          "example_index": 1,
          "input": "[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"], [[[1,3]],[],[],[],[],[]]",
          "expected_output": "[null,1,1,1,1,0]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpzo2bs6de.py\", line 24, in <module>\n    ops, args = json.loads(data)\n                ^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 73 (char 72)"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport bisect\n\nclass Solution:\n    def __init__(self, w):\n        self.prefix_sum = []\n        total = 0\n        for weight in w:\n            total += weight\n            self.prefix_sum.append(total)\n        self.total = total\n\n    def pickIndex(self):\n        target = random.randint(1, self.total)\n        return bisect.bisect_left(self.prefix_sum, target)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    ops, args = json.loads(data)\n    result = []\n    sol = None\n\n    for i, op in enumerate(ops):\n        if op == \"Solution\":\n            # args[i] is a list containing one element: the weights list\n            sol = Solution(args[i][0])\n            result.append(None)  # constructor returns null\n        else:\n            # call the method on the solution instance\n            res = getattr(sol, op)()\n            result.append(res)\n\n    # output the result list as JSON\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, not actual code, step-by-step for implementing pickIndex() that randomly selects an index based on weights. We should show building prefix sums, random number generation, binary search, etc. Provide steps line by line with explanation. Use arrow syntax. Ensure each line ends with // explanation. Must not output actual code. Just virtual steps. Let's produce Start, Step to compute prefix sums in constructor, Step to generate random number between 1 and total, Decision binary search to find index. End. Use Yes/No arrows. Provide explanation. Use proper Chinese. Let's craft.\n\nMake sure each line has \"虛擬碼步驟\" and space then // 解釋. Use arrow and decision. Provide Start and End. Let's write.\n\nNote: We need to implement function pickIndex. In the constructor we precompute prefix sums. Then pickIndex uses random. We'll show binary search logic.\n\nWe'll include steps for:\n\n- Start\n- Step 1: Initialize prefix array\n- Step 2: Compute total weight\n- Step 3: Generate random target\n- Step 4: Binary search for target in prefix\n- End\n\nUse Decision: for binary search.\n\nWe'll use \"Decision: If target <= mid_prefix\"? or \"If target <= prefix[mid]\". Use Yes → and No → accordingly.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空的前綴和陣列 prefix // 用於儲存各索引的累計權重  \n→ Decision: w 是否為空? // 檢查輸入是否有效  \n    Yes → End // 若空，直接結束（無法選擇）  \n    No  → Step 2: 計算 total = Σ w[i] // 總權重，作為隨機數上限  \n→ Step 3: 為 i 從 0 到 w.length-1  \n    → Step 3a: prefix[i] = (i==0?0:prefix[i-1]) + w[i] // 累加權重  \n→ Step 4: 產生一個隨機整數 target 在 1 與 total 之間（包含兩端） // 隨機選擇權重區間  \n→ Step 5: 將 low ← 0, high ← w.length-1 // 設定二分搜尋範圍  \n→ Decision: low ≤ high? // 開始二分搜尋  \n    Yes → Step 6: mid ← ⌊(low+high)/2⌋ // 取中間索引  \n    → Decision: target ≤ prefix[mid]? // 判斷目標是否落在左半部  \n        Yes → Step 7: high ← mid-1 // 將搜尋範圍縮小到左半部  \n        No  → Step 8: low ← mid+1 // 右半部搜尋  \n    → Decision: low ≤ high? // 繼續二分搜尋  \n        Yes → (回到 Step 6)  \n        No  → Step 9: return low // low 即為符合條件的索引  \nEnd // 程式執行結束"
    },
    {
      "title": "Multiply Strings",
      "source_file": "Leetcode/leetcode43.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "num1 = '2', num2 = '3'",
          "expected_output": "'6'",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '6'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: \"'6'\"\nRaw Got:      '2'"
        },
        {
          "example_index": 1,
          "input": "num1 = '123', num2 = '456'",
          "expected_output": "'56088'",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '56088'\nGot (Norm):      '123'\n--- (Raw) ---\nRaw Expected: \"'56088'\"\nRaw Got:      '123'"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef multiply(num1: str, num2: str) -> str:\n    \"\"\"Multiply two non‑negative integer strings without using big integer libraries.\"\"\"\n    if num1 == \"0\" or num2 == \"0\":\n        return \"0\"\n\n    m, n = len(num1), len(num2)\n    pos = [0] * (m + n)           # result digits\n\n    # grade‑school multiplication, processing from the least significant digit\n    for i in range(m - 1, -1, -1):\n        for j in range(n - 1, -1, -1):\n            mul = int(num1[i]) * int(num2[j])\n            p1, p2 = i + j, i + j + 1\n\n            sum_ = mul + pos[p2]  # current value at lower position\n            pos[p1] += sum_ // 10\n            pos[p2] = sum_ % 10\n\n    # Convert digit array to string, removing leading zeros\n    result = ''.join(map(str, pos)).lstrip('0')\n    return result if result else \"0\"\n\ndef main():\n    data = sys.stdin.read()\n\n    # Extract numbers: works for formats like \"num1 = '2', num2 = '3'\"\n    # and for plain \"2 3\" or \"2\\n3\"\n    matches = re.findall(r\"'(\\d+)'|(\\d+)\", data)\n    nums = [m[0] or m[1] for m in matches]\n\n    if len(nums) < 2:\n        # Fallback: split on whitespace\n        parts = data.strip().split()\n        nums = parts[:2]\n\n    num1, num2 = nums[0], nums[1]\n    print(multiply(num1, num2))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce step-by-step pseudocode to multiply two large numbers as strings without BigInteger. Standard algorithm: grade school multiplication, storing result in array of digits. Steps: handle zero case. Initialize result array length m+n. Loop from end of num1, num2 multiply digits, accumulate in result[i+j+1] etc. Then convert array to string skipping leading zeros. Provide each line with explanation. Format: Each line \"虛擬碼步驟 // 解釋\". Use arrows. Must be start and end. Need to adhere to format: Start, → Step 1: ... // explanation. Use Decision blocks for conditions like zero case, leading zeros.\n\nLet's produce lines:\n\nStart // 程式開始\n\n→ Step 1: 確定長度 m = len(num1), n = len(num2) // 取得兩個字串長度\n\n→ Decision: 如果 m == 0 或 n == 0? // 檢查是否為空字串\n\n    Yes → Step 2: 回傳 \"0\" // 任一為零時結果為 0\n\n    No  → // 繼續執行\n\n→ Step 3: 建立整數陣列 result of size m+n, 初始化為 0 // 用於存放每個位置的和\n\n→ Step 4: 反向遍歷 num1 及 num2 (i從 m-1 到 0, j從 n-1 到 0) // 進行乘法累加\n\n    ← 內部決策: 將 num1[i] 與 num2[j] 轉成數字 a, b\n\n    ← 內部決策: 計算 product = a * b\n\n    ← 內部決策: 累加到位置 pos1 = i+j, pos2 = i+j+1 // result[pos1] 進位, result[pos2] 存放\n\n    ← 內部決策: 更新 result[pos2] += product % 10\n\n    ← 內部決策: result[pos1] += product // 10\n\n    // 注意: 需要處理多次加法導致進位\n\n→ Step 5: 將 result 陣列轉為字串，跳過前導 0 // 把數字拼接起來\n\n→ Decision: 如果首個非零索引不存在? // 全為零\n\n    Yes → Step 6: 回傳 \"0\" // 全零結果\n\n    No  → // 找到首個非零索引 idx\n\n→ Step 7: 建立空字串 output\n\n→ Step 8: 從 idx 到 m+n-1 逐位將 result 數字轉成字符並追加到 output // 生成最終字串\n\n→ End // 程式結束\n\nBut we need to be careful to reflect the pseudocode structure. Use arrows and decision indentation. Each line must include \"虛擬碼步驟\" and comment after //.\n\nWe should produce each line with the step number maybe not necessary, but we can include. The format uses \"Start\" and \"End\". Use \"Decision:\" lines and indent. Use arrow \"→\" before each step. Use \"Yes →\" and \"No →\" for decisions.\n\nWe need to ensure each line has explanation. For loops we need to specify: \"For i from m-1 down to 0: // loop over num1 digits\". Then inside loops we need nested decisions? Might be too many lines. But we can condense loops as a single step with explanation.\n\nLet's structure:\n\nStart\n→ Step 1: m ← len(num1); n ← len(num2) // 取得兩數字字串長度\n→ Decision: 如果 m == 0 或 n == 0? // 若任何字串為空\n    Yes → Step 2: Return \"0\" // 其中一個為 0 時結果為 0\n    No  → // 繼續\n→ Step 3: result ← 整數陣列大小 m+n，全部 0 // 用來儲存計算結果\n→ Step 4: For i從 m-1 到 0  // 反向遍歷 num1\n    → For j從 n-1 到 0  // 反向遍歷 num2\n        → a ← int(num1[i]) // 取第 i 位數字\n        → b ← int(num2[j]) // 取第 j 位數字\n        → prod ← a * b   // 兩位數字相乘\n        → p1 ← i + j     // 進位位置\n        → p2 ← i + j + 1 // 結果位置\n        → result[p2] ← result[p2] + prod % 10 // 加上個位數\n        → result[p1] ← result[p1] + prod // 10 進位\n        → Decision: 若 result[p2] >= 10? // 處理進位\n            Yes → result[p2] ← result[p2] % 10\n                → result[p1] ← result[p1] + 1\n            No  → // 無需進位\n→ Step 5: idx ← 0\n→ Decision: 若 result[idx] == 0? // 跳過前導零\n    While result[idx] == 0 且 idx < m+n-1\n        → idx ← idx + 1\n→ Step 6: output ← 空字串\n→ For k從 idx 到 m+n-1\n    → output ← output + str(result[k]) // 追加每位數字\n→ End\n\nBut need to maintain format with arrows and comments. Let's refine.\n\nMake sure each line is single line. Use indentation for nested blocks but each line still one line.\n\nWe need to use arrow \"→\" before each step. For nested decisions, we use indentation? The example shows indentation for nested decisions. So we can indent lines inside Decision. Let's follow that.\n\nThe steps can be:\n\nStart // 程式開始執行\n→ Step 1: m ← len(num1); n ← len(num2) // 取得兩個字串長度\n→ Decision: m == 0 或 n == 0? // 檢查任何字串是否為空\n    Yes → Step 2: Return \"0\" // 若有空字串，結果為 0\n    No  → // 繼續執行\n→ Step 3: result ← 整數陣列長度 m+n，全部 0 // 用於儲存乘法結果\n→ For i從 m-1 到 0 // 反向遍歷 num1\n    → For j從 n-1 到 0 // 反向遍歷 num2\n        → a ← int(num1[i]) // 取 num1 第 i 位\n        → b ← int(num2[j]) // 取 num2 第 j 位\n        → prod ← a * b // 兩位數字相乘\n        → p1 ← i + j // 進位位置\n        → p2 ← i + j + 1 // 結果位置\n        → result[p2] ← result[p2] + prod % 10 // 加上個位\n        → result[p1] ← result[p1] + prod // 加上十位\n        → Decision: result[p2] >= 10? // 處理進位\n            Yes → result[p2] ← result[p2] % 10\n                → result[p1] ← result[p1] + 1\n            No  → // 無進位\n→ Step 4: idx ← 0 // 找到第一個非零位\n→ While result[idx] == 0 且 idx < m+n-1 // 跳過前導零\n    → idx ← idx + 1\n→ Step 5: output ← \"\" // 初始化結果字串\n→ For k從 idx 到 m+n-1\n    → output ← output + str(result[k]) // 追加每位數字\n→ End // 程式執行結束\n\nMake sure each line ends with // explanation. For loops we can use \"For i從 ...\" as a step. And inside loops we indent further. For while loop we indent. Should be fine.\n\nWe must use \"虛擬碼步驟\" before //? The requirement: each line must contain \"虛擬碼步驟\" then space then // explanation. The example didn't show \"虛擬碼步驟\" literal word but rather the step content. So we just put the step content as is, with // explanation. Eg \"Start // 程式開始執行\".\n\nThus we will produce exactly that.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: m ← len(num1); n ← len(num2) // 取得兩個字串長度\n→ Decision: m == 0 或 n == 0? // 檢查任何字串是否為空\n    Yes → Step 2: Return \"0\" // 若有空字串，結果為 0\n    No  → // 繼續執行\n→ Step 3: result ← 整數陣列長度 m+n，全部 0 // 用於儲存乘法結果\n→ For i從 m-1 到 0 // 反向遍歷 num1\n    → For j從 n-1 到 0 // 反向遍歷 num2\n        → a ← int(num1[i]) // 取 num1 第 i 位\n        → b ← int(num2[j]) // 取 num2 第 j 位\n        → prod ← a * b // 兩位數字相乘\n        → p1 ← i + j // 進位位置\n        → p2 ← i + j + 1 // 結果位置\n        → result[p2] ← result[p2] + prod % 10 // 加上個位\n        → result[p1] ← result[p1] + prod // 加上十位\n        → Decision: result[p2] >= 10? // 處理進位\n            Yes → result[p2] ← result[p2] % 10\n                → result[p1] ← result[p1] + 1\n            No  → // 無進位\n→ Step 4: idx ← 0 // 找到第一個非零位\n→ While result[idx] == 0 且 idx < m+n-1 // 跳過前導零\n    → idx ← idx + 1\n→ Step 5: output ← \"\" // 初始化結果字串\n→ For k從 idx 到 m+n-1\n    → output ← output + str(result[k]) // 追加每位數字\nEnd // 程式執行結束"
    }
  ]
}