{
  "run_index": 6,
  "total_files_found": 391,
  "total_files_processed": 323,
  "files_skipped": 68,
  "files_failed_load": 0,
  "---": "--- (以下基於 *題目* 總數) ---",
  "total_problems_attempted": 334,
  "generation_and_validation_success_count": 294,
  "generation_or_validation_failure_count": 40,
  "failed_cases_details": [
    {
      "title": "統計文字行數",
      "source_file": "900.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "（假設 data.txt 內容如下）\\nHello\\nPython\\nWorld",
          "expected_output": "檔案共有 3 行",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '檔案共有3行'\nGot (Norm):      '找不到檔案！'\n--- (Raw) ---\nRaw Expected: '檔案共有 3 行'\nRaw Got:      '找不到檔案！'"
        }
      ],
      "generated_code": "import sys\n\ndef main():\n    # 讀取標準輸入，若無輸入則返回空字串，不會阻塞\n    sys.stdin.read()\n\n    try:\n        # 以 read 模式開啟 data.txt，若檔案不存在會拋出 FileNotFoundError\n        with open('data.txt', 'r', encoding='utf-8') as f:\n            lines = f.readlines()\n        # 列印檔案總行數\n        print(f'檔案共有 {len(lines)} 行')\n    except FileNotFoundError:\n        # 檔案不存在時顯示錯誤訊息\n        print('找不到檔案！')\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code with explanation per line. Follow format. Lines like \"Start\" etc. Use with syntax, try/except. Include Decision: checking if file exists? We can try open file, catch FileNotFoundError. Steps: Start, try block: open file, count lines, print count. except FileNotFoundError: print message. End. Provide explanation. Use arrows \"→\". Use decision only if needed. For file existence, we can have Decision: If FileNotFound? but we can handle via try/except. Maybe show Decision: File found? Yes -> open file. No -> print. But spec says use try/except. So we can have Decision: Try opening file? But we can't \"Decision\" before try. Could do Decision: If file exists? But spec not require but we can show Decision. Let's produce straightforward: Start. → Step 1: 進入 try block. → Step 2: 使用 with 開啟 data.txt 以讀取模式 // open file. → Step 3: 讀取所有行並計算總數 // count lines. → Step 4: 輸出總行數 // print. → Decision: 例外發生? // catch exception. → Yes → Step 5: 輸出『找不到檔案！』 // error message. End.\n\nUse proper formatting. Let's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 進入 try block // 開始嘗試執行可能會失敗的程式碼  \n→ Step 2: 使用 with 開啟 data.txt 以讀取模式 // 以安全方式打開檔案  \n→ Step 3: 讀取所有行並計算總數 // 將檔案內容存入列表並取得長度  \n→ Step 4: 輸出總行數 // 顯示計算得到的行數  \n→ Decision: 例外發生? // 若在 try 內有錯誤則進入 except  \n    Yes → Step 5: 輸出『找不到檔案！』 // 檔案不存在時顯示錯誤訊息  \nEnd // 程式執行結束"
    },
    {
      "title": "模擬擲骰子遊戲",
      "source_file": "800.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "print(roll_dice(5))",
          "expected_output": "[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,6,1,4,2]#(結果會隨機，每次可能不同)'\nGot (Norm):      '[2,1,5,3,2]'\n--- (Raw) ---\nRaw Expected: '[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)'\nRaw Got:      '[2, 1, 5, 3, 2]'"
        }
      ],
      "generated_code": "import random\nimport sys\n\ndef roll_dice(n):\n    results = []\n    for _ in range(n):\n        results.append(random.randint(1, 6))\n    return results\n\nif __name__ == \"__main__\":\n    code = sys.stdin.read()\n    # Execute the code in a namespace where roll_dice is available\n    exec(code, globals())",
      "virtual_code": "Thinking...\nWe need to produce virtual code, line by line, with comments. The user wants a function roll_dice(n) that uses random module, simulates rolling an n-sided? Wait it's \"擲 n 次六面骰\" means roll n times a 6-sided die. Return list of results. So pseudo-code. We need to follow format: each line: \"虛擬碼步驟 [space] // 解釋\". Use arrow etc.\n\nLet's produce:\n\nStart\n→ Import random // import random module\n→ Define Function roll_dice(n) // start function definition\n→ Step: results = empty list // initialize list\n→ Decision: if n <= 0? // validate input\n    Yes → Step: raise ValueError // error for invalid n\n    No  →\n        → Loop i from 1 to n // iterate n times\n            → Step: roll = random.randint(1,6) // random number 1-6\n            → Step: Append roll to results // add to list\n→ Step: Return results // return list\nEnd\n\nWe need to be careful to include Start and End lines. Each line with arrow or Step, Decision, etc.\n\nLet's output exactly as specified: each line: Virtual step + space + // explanation.\n\nInclude \"Start // 程式開始執行\" and \"End // 程式執行結束\".\n\nUse \"→\" arrow for actions, \"Decision:\" for decisions. For \"Start\" and \"End\" we might not need arrow.\n\nFollow example: \"Start // 程式開始執行\" etc.\n\nNow produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Import random // 匯入 random 模組以產生隨機數  \n→ Define Function roll_dice(n) // 定義 roll_dice 函式，參數 n 為擲骰次數  \n→ Step: results = [] // 初始化空列表以儲存每次擲骰結果  \n→ Decision: n <= 0? // 檢查擲骰次數是否有效  \n Yes → Step: Raise ValueError // 若次數非正，拋出錯誤訊息  \n No  →  \n  → Loop i from 1 to n // 依序擲 n 次骰子  \n   → Step: roll = random.randint(1,6) // 產生 1 至 6 之間的隨機整數  \n   → Step: Append roll to results // 將擲骰結果加入列表  \n→ Step: Return results // 回傳所有擲骰結果的列表  \nEnd // 程式執行結束"
    },
    {
      "title": "計算程式執行時間",
      "source_file": "800.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "import time\n\ndef slow_add(a, b):\n    time.sleep(2)\n    return a + b\n\nprint(measure_time(slow_add, 3, 5))",
          "expected_output": "約 2.0 秒 (依電腦執行環境略有差異)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '約2.0秒(依電腦執行環境略有差異)'\nGot (Norm):      '2.0'\n--- (Raw) ---\nRaw Expected: '約 2.0 秒 (依電腦執行環境略有差異)'\nRaw Got:      '2.0'"
        }
      ],
      "generated_code": "import sys\nimport time\n\ndef measure_time(func, *args):\n    start = time.perf_counter()\n    func(*args)\n    end = time.perf_counter()\n    return round(end - start, 3)\n\ndef main():\n    source = sys.stdin.read()\n    # Execute the user script in a namespace that already contains measure_time\n    exec(source, {\"measure_time\": measure_time, \"time\": time})\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps, line by line, with explanation. It's a function measure_time(func, *args) that measures execution time, returns rounded result to 3 decimal places. Use time module. Steps: import time, define function, start timer, call func(*args), end timer, compute elapsed, round to 3 decimal, return. Also maybe return result of function? It says return result (rounded to 3 decimal) — likely return elapsed time. So output steps: Start, import time, define function, etc. We'll produce stepwise virtual code with arrow notation. Use Start and End. Let's produce something like:\n\nStart // 開始執行流程\n→ Step 1: Import time module // 載入 time 模組\n→ Step 2: Define function measure_time(func, *args) // 定義測量時間的函數\n    → Step 2.1: Record start_time = time.perf_counter() // 紀錄起始時間\n    → Step 2.2: Execute result = func(*args) // 執行目標函數並取得回傳值\n    → Step 2.3: Record end_time = time.perf_counter() // 紀錄結束時間\n    → Step 2.4: Calculate elapsed = end_time - start_time // 計算耗時\n    → Step 2.5: Round elapsed to 3 decimal places → rounded = round(elapsed, 3) // 四捨五入到三位小數\n    → Step 2.6: Return rounded // 回傳四捨五入後的耗時\nEnd // 程式執行結束\n\nBut we need arrow arrow format: Start, → Step ... etc. Provide comments. Use Decision? No decision needed. Use arrow formatting: Use indentation maybe with spaces. Provide each line separate. Ensure format: \"虛擬碼步驟\" + space + \"// 解釋\". Use \"→\" arrow for steps, \"Decision:\" if needed. So we will produce lines accordingly.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: Import time module // 載入 time 模組，提供高精度計時\n→ Step 2: Define function measure_time(func, *args) // 定義測量函數的封裝器\n    → Step 2.1: start_time = time.perf_counter() // 記錄執行前的高精度時間\n    → Step 2.2: result = func(*args) // 執行傳入的函式並收集其回傳值\n    → Step 2.3: end_time = time.perf_counter() // 記錄執行後的高精度時間\n    → Step 2.4: elapsed = end_time - start_time // 取得總耗時\n    → Step 2.5: rounded = round(elapsed, 3) // 將耗時四捨五入到三位小數\n    → Step 2.6: Return rounded // 回傳計算後的耗時\nEnd // 程式執行結束\n\nBut we might need to mention that we ignore result variable? The function returns elapsed, not result. The spec: \"用來測量函數 func 執行所需的秒數，並回傳結果 (四捨五入到小數點 3 位)。\" So return elapsed. So step 2.6: Return rounded // 回傳測量時間\n\nWe can include \"Return rounded\" but we might also want to note that the function result variable is unused. Ok.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Import time module // 載入 time 模組，提供高精度計時功能  \n→ Step 2: Define function measure_time(func, *args) // 定義測量函數的封裝器  \n    → Step 2.1: start_time = time.perf_counter() // 記錄執行前的高精度時間  \n    → Step 2.2: result = func(*args) // 執行傳入的函式並收集其回傳值  \n    → Step 2.3: end_time = time.perf_counter() // 記錄執行後的高精度時間  \n    → Step 2.4: elapsed = end_time - start_time // 取得總耗時（秒）  \n    → Step 2.5: rounded = round(elapsed, 3) // 將耗時四捨五入到三位小數  \n    → Step 2.6: Return rounded // 回傳四捨五入後的耗時  \nEnd // 程式執行結束"
    },
    {
      "title": "學生資料類別設計",
      "source_file": "1100.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "Alice 的分數是 90\nBob 的分數是 80",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'Alice的分數是90\\nBob的分數是80'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: 'Alice 的分數是 90\\nBob 的分數是 80'\nRaw Got:      ''"
        }
      ],
      "generated_code": "class Student:\n    def __init__(self, name, score):\n        self.name = name\n        self.score = score\n\n    def show_info(self):\n        print(f'{self.name} 的分數是 {self.score}')\n\n\ndef main():\n    import sys\n\n    # 讀取所有非空行\n    lines = [line.strip() for line in sys.stdin if line.strip()]\n    students = []\n\n    if lines:\n        # 若有輸入，解析每行為「姓名 分數」\n        for line in lines:\n            parts = line.split()\n            if len(parts) < 2:\n                continue\n            name = parts[0]\n            try:\n                score = int(parts[1])\n            except ValueError:\n                continue\n            students.append(Student(name, score))\n    else:\n        # 無輸入時使用預設學生\n        students.append(Student('Alice', 90))\n        students.append(Student('Bob', 80))\n\n    # 輸出每位學生資訊\n    for s in students:\n        s.show_info()\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step with arrows. The user request: define a Student class with name and score attributes, init, show_info method prints \"XXX 的分數是 YYY\". Then create two objects and call show_info. Provide virtual code line by line, each line: \"虛擬碼步驟 // 解釋\".\n\nWe should include Start and End. Use arrows for steps. Use Decision? Not needed here. We'll just structure sequentially.\n\nProbably:\n\nStart\n→ Define class Student\n    → Step 1: Define __init__(self, name, score) // constructor initializing name, score\n    → Step 2: Define show_info(self) // method to output info\n        → Step 2a: Output \"name 的分數是 score\" // printing\n→ End class definition\n→ Step 3: Create student1 = Student('Alice', 90) // create first object\n→ Step 4: Create student2 = Student('Bob', 75) // second object\n→ Step 5: student1.show_info() // call method on first\n→ Step 6: student2.show_info() // call method on second\nEnd\n\nBut need proper virtual code syntax: maybe use \"→\" arrows.\n\nLet's produce each line: \nStart // 程式開始\n→ Step 1: Define class Student // 定義 Student 類別\n→ Step 2:    Define __init__(self, name, score) // 建構子初始化屬性\n→ Step 3:        self.name = name // 儲存姓名\n→ Step 4:        self.score = score // 儲存分數\n→ Step 5:    Define show_info(self) // 定義顯示資訊方法\n→ Step 6:        Output self.name + \" 的分數是 \" + self.score // 輸出分數\n→ Step 7: Create student1 = Student('Alice', 90) // 建立第一個物件\n→ Step 8: Create student2 = Student('Bob', 75) // 建立第二個物件\n→ Step 9: student1.show_info() // 呼叫第一個物件方法\n→ Step 10: student2.show_info() // 呼叫第二個物件方法\nEnd // 程式結束\n\nBut the format expects each line: \"虛擬碼步驟 // 解釋\". Should include arrow \"→\" only where appropriate. Also include Start and End. Might include indentation? The example shows arrow then Step. We can keep simple.\n\nWe also might use \"Step 1:\" but not necessary. Provide line numbers? Not required. Provide each step.\n\nMake sure each line uses arrow where necessary.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Define class Student // 定義 Student 類別\n→ Step 2:    Define __init__(self, name, score) // 建構子初始化屬性\n→ Step 3:        self.name = name // 儲存姓名\n→ Step 4:        self.score = score // 儲存分數\n→ Step 5:    Define show_info(self) // 定義顯示資訊方法\n→ Step 6:        Output self.name + \" 的分數是 \" + self.score // 輸出分數\n→ Step 7: Create student1 = Student('Alice', 90) // 建立第一個 Student 物件\n→ Step 8: Create student2 = Student('Bob', 75) // 建立第二個 Student 物件\n→ Step 9: student1.show_info() // 呼叫第一個物件的 show_info 方法\n→ Step 10: student2.show_info() // 呼叫第二個物件的 show_info 方法\nEnd // 程式執行結束"
    },
    {
      "title": "集合函數練習",
      "source_file": "600.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "{'apple', 'orange', 'grape', 'melon'}",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '{\"apple\",\"orange\",\"grape\",\"melon\"}'\nGot (Norm):      '{\"grape\",\"apple\",\"melon\",\"orange\"}'\n--- (Raw) ---\nRaw Expected: \"{'apple', 'orange', 'grape', 'melon'}\"\nRaw Got:      \"{'grape', 'apple', 'melon', 'orange'}\""
        }
      ],
      "generated_code": "import sys\n\ndef main():\n    # 讀取並忽略任何輸入\n    sys.stdin.read()\n    \n    # 建立初始集合\n    fruits = {'apple', 'banana'}\n    \n    # 新增單一元素\n    fruits.add('orange')\n    \n    # 一次新增多個元素\n    fruits.update(['grape', 'melon'])\n    \n    # 移除已存在的元素\n    fruits.remove('banana')\n    \n    # 嘗試移除不存在的元素，discard 不會拋出錯誤\n    fruits.discard('pineapple')\n    \n    # 輸出最終集合\n    print(fruits)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output step-by-step virtual code lines, each with // explanation, following format with Start, End, Decision: etc. No actual code. Just virtual steps. Each line \"虛擬碼步驟\" like \"→ Step 1: ...\" but not actual code. Use virtual pseudocode. We should include add, update, remove, discard operations. The steps are straightforward.\n\nWe should start with \"Start\". Then \"→ Step 1: Initialize fruits = {'apple', 'banana'}\". Then \"→ Step 2: fruits.add('orange')\". Then \"→ Step 3: fruits.update({'grape', 'melon'})\". Then \"→ Step 4: fruits.remove('banana')\". Then \"→ Step 5: fruits.discard('pineapple')\" (note element not in set). Then \"→ Step 6: Output fruits\". Then \"End\". Possibly decision not needed, but we could show if remove/ discard success? But requirement is just operations.\n\nLet's output each line.\n\nWe should be careful: the requirement says \"虛擬碼步驟\" + space + // explanation. So we need something like \"→ Step 1: Initialize fruits = {'apple', 'banana'} // 初始化集合\".\n\nWe must use virtual code arrow like \"→\". For start \"Start\". End \"End\".\n\nWe might include a decision around discard? Could say \"Decision: If 'pineapple' exists?\" but not necessary.\n\nBut to show more thorough, we can add decision. But requirement says to use Decision if needed.\n\nWe can add Decision before discard: \"Decision: Does 'pineapple' exist in fruits?\" -> Yes? No? Actually we can just show the discard operation which does nothing if not exist. But maybe include Decision.\n\nBetter to keep simple: no decision, just discard. The output will be fine.\n\nThus produce:\n\nStart // 程式開始執行\n→ Step 1: Initialize fruits = {'apple', 'banana'} // 創建初始集合\n→ Step 2: fruits.add('orange') // 新增元素 'orange'\n→ Step 3: fruits.update({'grape', 'melon'}) // 一次新增多個元素\n→ Step 4: fruits.remove('banana') // 移除元素 'banana'\n→ Step 5: fruits.discard('pineapple') // 嘗試移除不存在的 'pineapple'\n→ Step 6: Output fruits // 顯示最終集合\nEnd // 程式結束\n\nCheck format: Each line ends with // explanation. No code.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Initialize fruits = {'apple', 'banana'} // 創建初始集合\n→ Step 2: fruits.add('orange') // 新增元素 'orange'\n→ Step 3: fruits.update({'grape', 'melon'}) // 一次新增多個元素\n→ Step 4: fruits.remove('banana') // 移除元素 'banana'\n→ Step 5: fruits.discard('pineapple') // 嘗試移除不存在的 'pineapple'\n→ Step 6: Output fruits // 顯示最終集合\nEnd // 程式結束"
    },
    {
      "title": "即時匯率查詢小工具",
      "source_file": "1200.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "按下「更新匯率」按鈕",
          "expected_output": "目前美元匯率：約 32.5 TWD",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '目前美元匯率：約32.5TWD'\nGot (Norm):      '目前美元匯率：約30.8200TWD'\n--- (Raw) ---\nRaw Expected: '目前美元匯率：約 32.5 TWD'\nRaw Got:      '目前美元匯率：約 30.8200 TWD'"
        }
      ],
      "generated_code": "import requests\nimport tkinter as tk\nimport sys\n\n# ----------------- 匯率取得功能 -----------------\ndef get_rate() -> float | None:\n    \"\"\"\n    連結匯率 API，回傳 USD 對 TWD 的匯率\n    若失敗則回傳 None\n    \"\"\"\n    try:\n        url = \"https://api.exchangerate-api.com/v4/latest/USD\"\n        r = requests.get(url, timeout=5)\n        r.raise_for_status()                 # 若 HTTP 狀態碼不是 200，拋出例外\n        data = r.json()\n        rate = data[\"rates\"][\"TWD\"]\n        return float(rate)\n    except Exception:\n        return None\n\n# ----------------- Tkinter GUI -----------------\ndef start_gui() -> None:\n    \"\"\"\n    建立簡易 Tkinter 視窗，按下「更新匯率」按鈕即重新抓取匯率並更新顯示\n    \"\"\"\n    root = tk.Tk()\n    root.title(\"美元匯率查詢\")\n\n    # 標籤用於顯示匯率文字\n    label = tk.Label(root, text=\"請按下按鈕更新匯率\", font=(\"Arial\", 12))\n    label.pack(pady=10)\n\n    def update_label() -> None:\n        rate = get_rate()\n        if rate is not None:\n            label.config(text=f\"1 USD = {rate:.4f} TWD\")\n        else:\n            label.config(text=\"無法取得匯率，請檢查網路\")\n\n    # 按鈕設定，點擊時呼叫 update_label\n    btn = tk.Button(root, text=\"更新匯率\", command=update_label)\n    btn.pack(pady=5)\n\n    # 啟動 GUI 事件迴圈\n    root.mainloop()\n\n# ----------------- 主程式入口 -----------------\ndef main() -> None:\n    \"\"\"\n    從標準輸入讀取指令，若包含「更新匯率」字串即抓取匯率並列印結果。\n    \"\"\"\n    # 讀取全部標準輸入並移除首尾空白\n    command = sys.stdin.read().strip()\n\n    if \"更新匯率\" in command:\n        rate = get_rate()\n        if rate is not None:\n            # 將結果列印至標準輸出，符合測試範例格式\n            print(f\"目前美元匯率：約 {rate:.4f} TWD\")\n        else:\n            print(\"無法取得匯率\")\n    else:\n        # 若輸入不符合條件，保持不輸出任何訊息\n        pass\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines following format: each line \"虛擬碼步驟 // 解釋\". Use Start, End, Decision: etc. Need to produce virtual code for a program that uses requests to fetch https://api.exchangerate-api.com/v4/latest/USD, get TWD rate, display in tkinter window, button to update.\n\nWe must produce step-by-step virtual code, each line with arrow if necessary, like \"Start //\". For tkinter, we might need to define functions, GUI components, event binding. Use decisions for checking response status, error handling. Provide comments.\n\nWe should avoid actual code. Provide structure: Import modules, define function to fetch rate, define function to update label, create window, create label, button, pack, mainloop.\n\nNeed to keep format: each line \"Step: ...\" with arrow. Use arrow for transitions.\n\nLet's craft:\n\nStart // 程式開始\n→ Step 1: Import requests, tkinter // 導入需要的模組\n→ Step 2: Define function fetch_rate() // 定義抓取匯率的函式\n→     Step 2.1: 發送 GET 請求至 https://api.exchangerate-api.com/v4/latest/USD // 取得最新匯率資料\n→     Step 2.2: 判斷回應是否成功 (status 200) // 檢查請求是否成功\n→         Yes → Step 2.3: 解析 JSON 並取出 'rates' -> 'TWD' // 取得台幣匯率\n→             → Step 2.4: 返回匯率值 // 返回匯率\n→         No  → Step 2.5: 返回 None // 失敗時返回 None\n→ Step 3: 定義 function update_label() // 定義更新顯示的函式\n→     Step 3.1: 呼叫 fetch_rate() // 取得最新匯率\n→     Step 3.2: 判斷匯率是否為 None // 判斷是否取得成功\n→         Yes → Step 3.3: 設定 label 文字為 \"無法取得匯率\" // 顯示錯誤訊息\n→         No  → Step 3.4: 設定 label 文字為 f\"1 USD = {rate} TWD\" // 顯示匯率\n→ Step 4: 建立 tkinter 視窗 root // 建立主視窗\n→     Step 4.1: 建立 label 顯示匯率文字 // 顯示匯率\n→     Step 4.2: 建立按鈕 \"更新匯率\" 並綁定 update_label // 建立按鈕\n→     Step 4.3: 設定 layout (pack 或 grid) // 排版\n→ Step 5: 呼叫 update_label() // 初始顯示一次匯率\n→ Step 6: 執行 root.mainloop() // 啟動 GUI 事件迴圈\nEnd // 程式結束\n\nMake sure each line is in format: \"虛擬碼步驟 // 解釋\". Use arrow for transitions. Provide decision lines. Let's produce.\n\nAlso maintain \"Start // 程式開始執行\". Use arrows with \"→\". For decisions use \"Decision: ...\". Provide indentation maybe with spaces.\n\nWe need to keep each line separate. Let's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Import requests, tkinter // 導入請求與 GUI 所需模組  \n→ Step 2: Define function fetch_rate() // 定義抓取匯率的函式  \n  Step 2.1: 發送 GET 請求至 https://api.exchangerate-api.com/v4/latest/USD // 取得最新匯率資料  \n  Step 2.2: Decision: 如果回應狀態碼 200? // 判斷請求是否成功  \n   Yes → Step 2.3: 解析 JSON 並取出 'rates' → 'TWD' // 取得台幣匯率  \n    → Step 2.4: Return rate // 返回匯率值  \n   No  → Step 2.5: Return None // 失敗時返回空值  \n→ Step 3: Define function update_label() // 定義更新顯示文字的函式  \n  Step 3.1: Call fetch_rate() // 取得最新匯率  \n  Step 3.2: Decision: 如果 rate 為 None? // 判斷是否成功取得  \n   Yes → Step 3.3: Set label text to \"無法取得匯率\" // 顯示錯誤訊息  \n   No  → Step 3.4: Set label text to f\"1 USD = {rate} TWD\" // 顯示匯率  \n→ Step 4: 建立 tkinter 視窗 root // 創建主視窗  \n  Step 4.1: 建立 label，初始文字為空或 \"載入中…\" // 用於顯示匯率  \n  Step 4.2: 建立按鈕 \"更新匯率\"，並將 update_label 綁定為 click 事件 // 允許手動更新  \n  Step 4.3: 設定 layout (pack/grid) // 排版視窗元件  \n→ Step 5: 呼叫 update_label() // 初始顯示一次匯率  \n→ Step 6: 執行 root.mainloop() // 啟動 GUI 事件迴圈  \nEnd // 程式結束執行"
    },
    {
      "title": "Random Flip Matrix",
      "source_file": "Leetcode/leetcode519.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"flip\", \"flip\", \"flip\", \"reset\", \"flip\"], [[3, 1], [], [], [], [], []]",
          "expected_output": "[null, [1,0], [2,0], [0,0], null, [2,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[1,0],[2,0],[0,0],null,[2,0]]'\nGot (Norm):      '[null,[1,0],[2,0],[0,0],null,[1,0]]'\n--- (Raw) ---\nRaw Expected: '[null, [1,0], [2,0], [0,0], null, [2,0]]'\nRaw Got:      '[null, [1, 0], [2, 0], [0, 0], null, [1, 0]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, m: int, n: int):\n        self.m = m\n        self.n = n\n        self.total = m * n\n        self.pool = list(range(self.total))  # 可用索引池\n        self.remaining = self.total          # 尚未翻轉的元素數\n\n    def flip(self):\n        if self.remaining == 0:\n            return None\n        # 隨機選取一個剩餘位置\n        r = random.randint(0, self.remaining - 1)\n        idx = self.pool[r]                    # 扁平化索引\n        # 把已選取的索引移到池子末尾\n        self.pool[r], self.pool[self.remaining - 1] = (\n            self.pool[self.remaining - 1],\n            self.pool[r],\n        )\n        self.remaining -= 1                   # 更新剩餘數量\n        # 轉回行列座標\n        return [idx // self.n, idx % self.n]\n\n    def reset(self):\n        self.pool = list(range(self.total))\n        self.remaining = self.total\n\ndef main():\n    data = sys.stdin.read()\n    if not data.strip():\n        return\n    # 解析輸入，得到操作列表與對應參數\n    ops, args = ast.literal_eval(data.strip())\n    res = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            obj = Solution(arg[0], arg[1])\n            res.append(None)\n        elif op == \"flip\":\n            res.append(obj.flip())\n        elif op == \"reset\":\n            obj.reset()\n            res.append(None)\n    # 輸出結果，使用 json 以符合示例格式\n    print(json.dumps(res))\n\nif __name__ == \"__main__\":\n    random.seed(0)  # 為了測試可重現性，可選擇性設置種子\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code, not actual code, explaining steps. Should cover algorithm: we can flatten matrix indices into array 0..m*n-1. Maintain available pool list of indices. At init, pool = [0..m*n-1]. Each flip: pick random index k in [0, pool.size-1], pick value idx = pool[k], swap pool[k] with pool[pool.size-1] and pop last, convert idx to i,j: i=idx/n, j=idx%n. Return [i,j]. Reset: rebuild pool.\n\nNeed to mention minimize random calls: one per flip.\n\nExplain space: O(m*n) for pool; time O(1) per flip. For reset O(m*n). Provide steps in virtual code.\n\nFollow format: Each line: \"虛擬碼步驟 // 解釋\".\n\nUse arrow symbols.\n\nWe'll output a step-by-step algorithm for initialization, flip, reset.\n\nWe'll use structure: Start, Decision, etc.\n\nOk produce final.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Set total = m × n // 計算矩陣的總元素數\n→ Step 2: Create list pool = [0, 1, 2, …, total‑1] // 初始化所有可用索引\n→ Step 3: Set remaining = total // 紀錄尚未被翻轉的元素數\n\n// -------------- flip() 方法 ----------------\nStart // 進入 flip() 函式\n→ Decision: 如果 remaining == 0? // 檢查是否已無可翻轉元素\n    Yes → Return null // 或拋出例外，表示已翻轉完畢\n    No  →\n        → Step 4: r = random_integer(0, remaining‑1) // 取得一個隨機位置\n        → Step 5: idx = pool[r] // 取得對應的扁平化索引\n        → Step 6: Swap pool[r] ↔ pool[remaining‑1] // 將已選取的元素移到末尾\n        → Step 7: Remove last element from pool // 讓 pool 只剩未翻轉索引\n        → Step 8: remaining = remaining - 1 // 更新剩餘數量\n        → Step 9: i = idx ÷ n // 轉回行號\n        → Step 10: j = idx mod n // 轉回列號\n        → Step 11: Return [i, j] // 回傳隨機且均勻的索引\n\nEnd // flip() 函式結束\n\n// -------------- reset() 方法 ----------------\nStart // 進入 reset() 函式\n→ Step 12: Rebuild pool = [0, 1, 2, …, total‑1] // 重置所有索引\n→ Step 13: remaining = total // 重置剩餘元素數\nEnd // reset() 函式結束\n\nEnd // 程式執行結束"
    },
    {
      "title": "Remove Invalid Parentheses",
      "source_file": "Leetcode/leetcode301.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"()())()\"",
          "expected_output": "[\"(())()\",\"()()()\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"(())()\",\"()()()\"]'\nGot (Norm):      '[\"(())()\"]'\n--- (Raw) ---\nRaw Expected: '[\"(())()\",\"()()()\"]'\nRaw Got:      \"['(())()']\""
        },
        {
          "example_index": 1,
          "input": "s = \"(a)())()\"",
          "expected_output": "[\"(a())()\",\"(a)()()\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"(a())()\",\"(a)()()\"]'\nGot (Norm):      '[\"(a())()\"]'\n--- (Raw) ---\nRaw Expected: '[\"(a())()\",\"(a)()()\"]'\nRaw Got:      \"['(a())()']\""
        }
      ],
      "generated_code": "import sys\nimport re\nfrom typing import List, Set\n\nclass Solution:\n    def removeInvalidParentheses(self, s: str) -> List[str]:\n        # 計算需要移除的左右括號數量\n        leftRem, rightRem = 0, 0\n        for ch in s:\n            if ch == '(':\n                leftRem += 1\n            elif ch == ')':\n                if leftRem > 0:\n                    leftRem -= 1\n                else:\n                    rightRem += 1\n\n        result: Set[str] = set()\n        visited: Set[tuple] = set()\n\n        def dfs(idx: int, left: int, right: int,\n                leftRem: int, rightRem: int, path: str) -> None:\n            key = (idx, left, right, leftRem, rightRem)\n            if key in visited:\n                return\n            visited.add(key)\n\n            if idx == len(s):\n                if leftRem == 0 and rightRem == 0:\n                    result.add(path)\n                return\n\n            ch = s[idx]\n            if ch == '(':\n                # 方案 1：刪除此左括號\n                if leftRem > 0:\n                    dfs(idx + 1, left, right, leftRem - 1, rightRem, path)\n                # 方案 2：保留此左括號\n                dfs(idx + 1, left + 1, right, leftRem, rightRem, path + ch)\n            elif ch == ')':\n                # 方案 1：刪除此右括號\n                if rightRem > 0:\n                    dfs(idx + 1, left, right, leftRem, rightRem - 1, path)\n                # 方案 2：保留此右括號（前提是已有左括號可配對）\n                if left > right:\n                    dfs(idx + 1, left, right + 1, leftRem, rightRem, path + ch)\n            else:\n                # 字母，直接加入\n                dfs(idx + 1, left, right, leftRem, rightRem, path + ch)\n\n        dfs(0, 0, 0, leftRem, rightRem, \"\")\n        return list(result)\n\ndef main() -> None:\n    raw_input = sys.stdin.read()\n    if not raw_input:\n        return\n    raw_input = raw_input.strip()\n\n    # 取得等號後面的內容（如果有的話）\n    if '=' in raw_input:\n        _, after_eq = raw_input.split('=', 1)\n        s_part = after_eq.strip()\n    else:\n        s_part = raw_input\n\n    # 移除可能存在的引號\n    if (s_part.startswith('\"') and s_part.endswith('\"')) or \\\n       (s_part.startswith(\"'\") and s_part.endswith(\"'\")):\n        s_part = s_part[1:-1]\n\n    s = s_part\n    sol = Solution()\n    ans = sol.removeInvalidParentheses(s)\n    print(str(ans))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm to remove minimal invalid parentheses, produce all valid strings. Classic solution: BFS or DFS with pruning; BFS to find minimal removals, then collect all. Provide virtual code with steps. Use Decision etc.\n\nWe should outline start, compute counts of extra left and right, DFS recursion to try removals, skip duplicates by using set. Use recursion with index, leftCount, rightCount, leftRemove, rightRemove. Provide explanation each line.\n\nWill produce each line. Use arrows. Use decision branches. Should produce clear algorithm.\n\nLet's craft.\n\nStart\n→ Step 1: 定義遞迴函數 dfs(s, index, left, right, leftRem, rightRem, path, result) // 將每個字符決策並構建合法字串\n→ Decision: index == length of s? // 已處理完所有字符\n    Yes → Decision: leftRem == 0 AND rightRem == 0? // 是否已移除到最小\n        Yes → Step 2: result.add(path) // 加入合法字串\n        No  → Step 3: return // 當移除數不為 0 時，遞迴終止\n    No  → Step 4: char = s.charAt(index) // 取得當前字符\n→ Decision: char == '('? // 左括號\n    Yes →\n        → Decision: leftRem > 0? // 是否可以刪除此左括號\n            Yes → Step 5: dfs(s, index+1, left, right, leftRem-1, rightRem, path, result) // 刪除\n            No  → // 不刪除\n        → Step 6: dfs(s, index+1, left+1, right, leftRem, rightRem, path + '(', result) // 保留\n    No →\n        → Decision: char == ')'? // 右括號\n            Yes →\n                → Decision: rightRem > 0? // 是否可以刪除此右括號\n                    Yes → Step 7: dfs(s, index+1, left, right, leftRem, rightRem-1, path, result) // 刪除\n                    No  → // 不刪除\n                → Decision: right > left? // 有左括號可匹配\n                    Yes → Step 8: dfs(s, index+1, left, right+1, leftRem, rightRem, path + ')', result) // 保留\n                    No  → // 不保留\n            No → // 字母\n                → Step 9: dfs(s, index+1, left, right, leftRem, rightRem, path + char, result) // 直接加入\nEnd // 程式結束\n\nNeed also initial calculation of leftRem, rightRem. Add Step before calling dfs. Also collect results and return.\n\nLet's add at start:\n\n→ Step 0: Compute leftRem and rightRem by iterating string to count unmatched parentheses // 計算需要移除的左右括號數量\n\n→ Step 1: result = new Set() // 儲存唯一合法字串\n\n→ Step 2: Call dfs(s, 0, 0, 0, leftRem, rightRem, \"\", result) // 開始遞迴\n\n→ Step 3: Return result as list // 回傳所有合法字串\n\nThus adjust numbering. Use \"Start\". Then Step0 etc.\n\nMake sure lines are separated. Provide arrow formatting. Let's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 0: leftRem, rightRem ← 0 // 初始化需要移除的左括號與右括號數量  \n→ Decision: for each char in s? // 遍歷字串計算不配對括號  \n    Yes → Decision: char == '('? // 遇到左括號  \n        Yes → leftRem ← leftRem + 1 // 需要可能移除的左括號 +1  \n        No  → Decision: char == ')' ? // 遇到右括號  \n            Yes → Decision: leftRem > 0? // 是否已有左括號可匹配  \n                Yes → leftRem ← leftRem - 1 // 匹配成功，左括號數量減 1  \n                No  → rightRem ← rightRem + 1 // 無左括號可匹配，右括號需要移除  \n            No  → // 字母，忽略  \n→ Step 1: result ← {} // 建立集合以避免重複結果  \n→ Step 2: Call dfs(s, 0, 0, 0, leftRem, rightRem, \"\", result) // 開始深度優先搜尋  \n→ Step 3: Return list(result) // 回傳所有合法字串  \n\nStart // 進入遞迴函式  \n→ Step 4: dfs(s, index, left, right, leftRem, rightRem, path, result) // 參數說明：index-目前索引, left/right-已保留的左/右括號數量, leftRem/rightRem-還需移除的數量, path-已構造的字串, result-結果集合  \n→ Decision: index == len(s)? // 是否已處理完所有字符  \n    Yes → Decision: leftRem == 0 AND rightRem == 0? // 是否已移除到最小  \n        Yes → Step 5: result.add(path) // 加入合法字串到結果集合  \n        No  → Step 6: return // 移除數量不符，結束此遞迴路徑  \n    No  → Step 7: ch ← s.charAt(index) // 取得當前字符  \n→ Decision: ch == '('? // 左括號  \n    Yes →  \n        → Decision: leftRem > 0? // 是否允許刪除此左括號  \n            Yes → Step 8: dfs(s, index+1, left, right, leftRem-1, rightRem, path, result) // 刪除此左括號  \n            No  → // 不刪除  \n        → Step 9: dfs(s, index+1, left+1, right, leftRem, rightRem, path + '(', result) // 保留此左括號並遞增左括號計數  \n    No →  \n        → Decision: ch == ')' ? // 右括號  \n            Yes →  \n                → Decision: rightRem > 0? // 是否允許刪除此右括號  \n                    Yes → Step 10: dfs(s, index+1, left, right, leftRem, rightRem-1, path, result) // 刪除此右括號  \n                    No  → // 不刪除  \n                → Decision: right < left? // 是否有左括號可匹配  \n                    Yes → Step 11: dfs(s, index+1, left, right+1, leftRem, rightRem, path + ')', result) // 保留此右括號並遞增右括號計數  \n                    No  → // 右括號不合法，跳過  \n            No → // 字母  \n                → Step 12: dfs(s, index+1, left, right, leftRem, rightRem, path + ch, result) // 直接加入字母  \nEnd // 程式結束執行"
    },
    {
      "title": "Find First and Last Position of Element in Sorted Array",
      "source_file": "Leetcode/leetcode34.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [5,7,7,8,8,10], target = 8",
          "expected_output": "[3,4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,4]'\nGot (Norm):      '[-1,4]'\n--- (Raw) ---\nRaw Expected: '[3,4]'\nRaw Got:      '[-1, 4]'"
        },
        {
          "example_index": 2,
          "input": "nums = [], target = 0",
          "expected_output": "[-1,-1]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpmuey1258.py\", line 52, in <module>\n    main()\n  File \"/tmp/tmpmuey1258.py\", line 48, in main\n    result = solution.searchRange(nums, target)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpmuey1258.py\", line 30, in searchRange\n    if left - 1 < n and nums[left - 1] == target:\n                        ~~~~^^^^^^^^^^\nIndexError: list index out of range"
        }
      ],
      "generated_code": "import sys\nimport re\nfrom typing import List\n\nclass Solution:\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\n        \"\"\"Find the starting and ending position of target in a sorted array.\"\"\"\n        n = len(nums)\n        # Find leftmost index\n        left, right = 0, n - 1\n        left_idx = -1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        if right >= 0 and nums[right] == target:\n            left_idx = right\n\n        # Find rightmost index\n        left, right = 0, n - 1\n        right_idx = -1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] > target:\n                right = mid - 1\n            else:\n                left = mid + 1\n        if left - 1 < n and nums[left - 1] == target:\n            right_idx = left - 1\n\n        return [left_idx, right_idx]\n\ndef main() -> None:\n    data = sys.stdin.read()\n    if not data:\n        return\n\n    # Extract the list of numbers and the target value from the input\n    nums_match = re.search(r'nums\\s*=\\s*(\\[[^\\]]*\\])', data)\n    target_match = re.search(r'target\\s*=\\s*(-?\\d+)', data)\n\n    nums = eval(nums_match.group(1)) if nums_match else []\n    target = int(target_match.group(1)) if target_match else None\n\n    solution = Solution()\n    result = solution.searchRange(nums, target)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need produce virtual code with O(log n). We need binary search for leftmost and rightmost. Provide line-by-line virtual code.\n\nInclude Start, End. Use Decision: and arrow.\n\nWe'll produce code steps: initialize left,right, ans=[-1,-1]. Find left boundary: while left <= right. mid. if nums[mid] >= target left = mid+1? Wait left boundary: if nums[mid] < target then left=mid+1 else right=mid-1. After loop if right >=0 and nums[right]==target set ans[0]=right. Similarly right boundary: left=0,right=n-1; while left<=right; mid; if nums[mid] <= target then left=mid+1 else right=mid-1. After loop if left-1 < n and nums[left-1]==target set ans[1]=left-1. Return ans.\n\nLet's produce virtual code lines accordingly. Include comments. Use arrows. Use Yes→/No→ for decisions. Probably we can have two loops with decision inside.\n\nWe'll produce:\n\nStart // 開始\n→ Step 1: left ← 0 // 初始化左指標\n→ Step 2: right ← n - 1 // 初始化右指標\n→ Step 3: ans ← [-1, -1] // 預設答案\n→ Decision: 找左邊界? // 開始尋找左邊界\n    Yes → Step 4: while left ≤ right: // 二分搜尋\n        → Step 5: mid ← (left + right) / 2 // 計算中點\n        → Decision: nums[mid] < target? // 判斷\n            Yes → left ← mid + 1 // 目標在右半部\n            No  → right ← mid - 1 // 目標可能在左半部或等於 mid\n    → Step 6: if right ≥ 0 and nums[right] = target then ans[0] ← right // 左邊界確定\n→ Decision: 找右邊界? // 開始尋找右邊界\n    Yes → Step 7: left ← 0; right ← n - 1 // 重設指標\n    → Step 8: while left ≤ right: // 二分搜尋\n        → Step 9: mid ← (left + right) / 2 // 計算中點\n        → Decision: nums[mid] > target? // 判斷\n            Yes → right ← mid - 1 // 目標在左半部\n            No  → left ← mid + 1 // 目標可能在右半部或等於 mid\n    → Step 10: if left - 1 < n and nums[left - 1] = target then ans[1] ← left - 1 // 右邊界確定\n→ Step 11: return ans // 回傳結果\nEnd // 程式結束\n\nMake sure each line has // comment. Use arrow symbol for decisions. For decision we use \"Decision:\" lines.\n\nAlso use \"Yes →\" and \"No →\" under decisions.\n\nMake sure to indent decisions. Use consistent format. Provide step numbers.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: left ← 0 // 初始化左指標  \n→ Step 2: right ← n - 1 // 初始化右指標  \n→ Step 3: ans ← [-1, -1] // 預設答案  \n\n→ Decision: 找左邊界? // 開始尋找左邊界  \n    Yes → Step 4: while left ≤ right: // 二分搜尋  \n        → Step 5: mid ← (left + right) / 2 // 計算中點  \n        → Decision: nums[mid] < target? // 判斷是否需要往右移  \n            Yes → left ← mid + 1 // 目標在右半部  \n            No  → right ← mid - 1 // 目標可能在左半部或等於 mid  \n    → Step 6: if right ≥ 0 and nums[right] = target then ans[0] ← right // 確定左邊界  \n\n→ Decision: 找右邊界? // 開始尋找右邊界  \n    Yes → Step 7: left ← 0; right ← n - 1 // 重設指標  \n    → Step 8: while left ≤ right: // 二分搜尋  \n        → Step 9: mid ← (left + right) / 2 // 計算中點  \n        → Decision: nums[mid] > target? // 判斷是否需要往左移  \n            Yes → right ← mid - 1 // 目標在左半部  \n            No  → left ← mid + 1 // 目標可能在右半部或等於 mid  \n    → Step 10: if left - 1 < n and nums[left - 1] = target then ans[1] ← left - 1 // 確定右邊界  \n\n→ Step 11: return ans // 回傳結果  \nEnd // 程式執行結束"
    },
    {
      "title": "leetcode846_problem_1",
      "source_file": "Leetcode/leetcode846.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "hand = [1,2,3,6,2,3,4,7,8], groupSize = 3",
          "expected_output": "True",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp5v90fsqr.py\", line 59, in <module>\n    main()\n  File \"/tmp/tmp5v90fsqr.py\", line 45, in main\n    hand = eval(hand_str, {\"__builtins__\": None}, {})\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "hand = [1,2,3,4,5], groupSize = 4",
          "expected_output": "False",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp7qzakv8c.py\", line 59, in <module>\n    main()\n  File \"/tmp/tmp7qzakv8c.py\", line 45, in main\n    hand = eval(hand_str, {\"__builtins__\": None}, {})\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nfrom collections import Counter\n\nclass Solution:\n    def isNStraightHand(self, hand, groupSize):\n        \"\"\"判斷能否把手牌分成每組 groupSize 張連續牌\"\"\"\n        # 先檢查牌數是否能被 groupSize 整除\n        if len(hand) % groupSize != 0:\n            return False\n\n        # 計算每張牌的頻率\n        count = Counter(hand)\n\n        # 依照牌值遞增的順序處理\n        for card in sorted(count):\n            freq = count[card]\n            if freq == 0:\n                continue  # 已經全部被使用過\n\n            # 嘗試從 current card 開始構成一組\n            for i in range(card, card + groupSize):\n                if count[i] < freq:\n                    return False  # 連續牌不足，無法完成分組\n                count[i] -= freq  # 把這些牌從計數中扣掉\n\n        return True\n\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入，支持兩種格式\n    # 1. 單行：hand = [1,2,3], groupSize = 3\n    # 2. 多行：第一行手牌列表，第二行 groupSize 整數\n    lines = [line.strip() for line in data.splitlines() if line.strip()]\n\n    if len(lines) == 1:\n        # 單行輸入，使用逗號分隔\n        parts = lines[0].split(',')\n        hand_part = parts[0].strip()\n        group_part = parts[1].strip() if len(parts) > 1 else ''\n        hand_str = hand_part.split('=', 1)[1].strip()\n        hand = eval(hand_str, {\"__builtins__\": None}, {})\n        group_size_str = group_part.split('=', 1)[1].strip()\n        groupSize = int(group_size_str)\n    else:\n        # 多行輸入，第一行手牌列表，第二行 groupSize 整數\n        hand = eval(lines[0], {\"__builtins__\": None}, {})\n        groupSize = int(lines[1])\n\n    solution = Solution()\n    result = solution.isNStraightHand(hand, groupSize)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the described problem: given hand array of integers, groupSize, can rearrange into groups of size groupSize where each group is consecutive numbers. Essentially \"Hand of Straights\" Leetcode 846. Solution: count frequency, sort keys, for each card, try to form group by subtracting counts for next groupSize consecutive numbers.\n\nWe'll output step-by-step in required format, using arrows and decisions.\n\nWe should produce step lines: Start, Step 1: sort hand, Step 2: build frequency map, etc. Use Decision nodes.\n\nWe need each line: \"虛擬碼步驟 // 解釋\".\n\nLet's craft.\n\nStart\n\n→ Step 1: sort hand ascending // so that we can process lowest cards first\n\n→ Step 2: create empty map count // map card value -> frequency\n\n→ Step 3: for each card in hand: increment count[card] // populate frequency\n\n→ Step 4: for each card in sorted hand: if count[card] == 0 → continue // already used\n\n→ Decision: If count[card] > 0? // need to form group starting from this card\n\n    Yes → Step 5: for i from 0 to groupSize-1: next = card + i // next card in group\n\n        → Decision: If count[next] < count[card]? // insufficient cards for this group\n\n            Yes → End // return false\n\n            No  → Step 6: decrement count[next] by count[card] // remove cards used\n\n    No → Step 7: // no remaining cards, proceed\n\n→ Step 8: return true // all cards grouped\n\nEnd\n\nBut need to align lines: Use arrows, Decision etc.\n\nLet's produce lines accordingly.\n\nWe need to include arrows as shown: \"→\" and \"Decision:\" etc.\n\nAlso include indentation for decisions? In example they indent under Decision.\n\nWe can format similarly: indentation with spaces.\n\nLet's produce.\n\nMake sure each line has \" // \".\n\nLet's write.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: sort hand ascending // 將牌按數值升序排列，以便從最小值開始分組  \n→ Step 2: create empty map count // 建立一個映射，記錄每個牌值出現的次數  \n→ Step 3: for each card in hand: increment count[card] // 對 hand 中每張牌進行頻率統計  \n→ Step 4: for each card in sorted hand:  \n  Decision: If count[card] == 0? // 牌已被用完，直接跳過  \n   Yes → continue // 跳到下一張牌  \n   No  → Step 5: // 需要從這張牌開始組成一組  \n    Decision: If count[card] > 0? // 確保還有牌可用  \n     Yes → Step 6: for i from 0 to groupSize-1: next = card + i // 逐個檢查連續牌  \n      Decision: If count[next] < count[card]? // 是否缺少足夠的牌來完成一組  \n       Yes → End // 資料不足，回傳 false，程式結束  \n       No  → Step 7: decrement count[next] by count[card] // 依次減少使用的牌數  \n       No  → Step 8: // 連續牌檢查完成  \n      No  → Step 9: // 這張牌已無剩餘可用，跳過  \n→ Step 10: return true // 所有牌均已成功分組，回傳 true  \nEnd // 程式執行結束"
    },
    {
      "title": "Subsets II",
      "source_file": "Leetcode/leetcode90.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,2]",
          "expected_output": "[[],[1],[1,2],[1,2,2],[2],[2,2]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[1,2],[1,2,2],[2],[2,2]]'\nGot (Norm):      '[[],[1],[2],[1,2],[2,2],[1,2,2]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[1,2],[1,2,2],[2],[2,2]]'\nRaw Got:      '[[],[1],[2],[1,2],[2,2],[1,2,2]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nimport re\n\ndef subsets_with_dup(nums):\n    \"\"\"回溯法生成不重複的子集集合。\"\"\"\n    nums.sort()\n    res = [[]]\n    for num in nums:\n        new_subsets = [subset + [num] for subset in res]\n        res += new_subsets\n    # 去除重複子集\n    unique_res = []\n    seen = set()\n    for subset in res:\n        key = tuple(subset)\n        if key not in seen:\n            seen.add(key)\n            unique_res.append(subset)\n    return unique_res\n\ndef main():\n    \"\"\"主程式：讀取輸入、計算子集並輸出結果。\"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 解析形如 \"nums = [1,2,2]\" 的輸入\n    match = re.search(r'\\[.*\\]', data)\n    nums = ast.literal_eval(match.group(0)) if match else []\n    result = subsets_with_dup(nums)\n    # 以 JSON 形式輸出，避免空格\n    print(json.dumps(result, separators=(',', ':')))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code (step-by-step pseudocode) for generating power set without duplicates, given array may contain duplicates. We need to output in the required format: each line: \"虛擬碼步驟 // 解釋\". Use arrows → and structure Start, End, Decision:.\n\nWe need to handle duplicates: typical solution: sort array, use backtracking skip duplicates. So pseudocode: Start, sort nums, initialize result = [ [] ], call backtrack(idx, currentSet). In backtrack: for i from idx to n-1: if i>idx and nums[i]==nums[i-1] then continue. currentSet add nums[i], add currentSet copy to result, backtrack(i+1,...). remove last. End.\n\nWe need to produce line-by-line. Each line with step and explanation. Let's produce. Ensure each line is one step. Use arrows for nested? The sample shows indentation with nested decisions. We can replicate. We'll include \"→\" for next step, \"Decision:\" for if. We need to show backtracking recursion maybe.\n\nLet's produce.\n\nPotential lines:\n\nStart // 程式開始執行\n→ Step 1: Sort the input array nums in non-decreasing order // 方便後續跳過重複元素\n→ Step 2: Initialize result as a list containing the empty subset [] // 任何集合的子集都至少包含空集\n→ Decision: Are there any elements left to process? // 檢查是否需要進一步遞迴\n    Yes → Call Backtrack(startIndex = 0, currentSubset = []) // 從索引0開始遞迴\n        → Backtrack: for i from startIndex to len(nums)-1 // 遍歷所有可選元素\n            → Decision: Is i > startIndex and nums[i] == nums[i-1]? // 檢查是否為重複元素\n                Yes → Continue // 跳過重複元素以避免重複子集\n                No  → Step 3: Add nums[i] to currentSubset // 把當前元素加入子集\n                → Step 4: Append a copy of currentSubset to result // 將新子集加入結果\n                → Step 5: Call Backtrack(i+1, currentSubset) // 進一步擴展子集\n                → Step 6: Remove last element from currentSubset // 回溯，撤銷上一步的選擇\n        → End Backtrack // 完成本層遞迴\n    No  → End // 程式執行結束\n\nBut we need to be careful with indentation: Use spaces for indentation? In sample, they indent lines inside decisions. Let's mimic.\n\nLet's produce each line exactly. Also we may need to output the result at the end. Let's add Step 7: Return result // 最終回傳所有子集\n\nAlso, we need to mention End after returning result.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort the input array nums in non-decreasing order // 方便後續跳過重複元素  \n→ Step 2: Initialize result as a list containing the empty subset [] // 任何集合的子集都至少包含空集  \n→ Decision: Are there any elements left to process? // 檢查是否需要進一步遞迴  \n    Yes → Call Backtrack(startIndex = 0, currentSubset = []) // 從索引0開始遞迴  \n        → Backtrack: for i from startIndex to len(nums)-1 // 遍歷所有可選元素  \n            → Decision: Is i > startIndex and nums[i] == nums[i-1]? // 檢查是否為重複元素  \n                Yes → Continue // 跳過重複元素以避免重複子集  \n                No  → Step 3: Add nums[i] to currentSubset // 把當前元素加入子集  \n                → Step 4: Append a copy of currentSubset to result // 將新子集加入結果  \n                → Step 5: Call Backtrack(i+1, currentSubset) // 進一步擴展子集  \n                → Step 6: Remove last element from currentSubset // 回溯，撤銷上一步的選擇  \n        → End Backtrack // 完成本層遞迴  \n    No  → End // 程式執行結束  \n→ Step 7: Return result // 最終回傳所有子集  \nEnd // 程式結束執行"
    },
    {
      "title": "Random Pick Index",
      "source_file": "Leetcode/leetcode398.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\"], [[[1, 2, 3, 3, 3]], [3], [1], [3]]",
          "expected_output": "[null, 4, 0, 2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,4,0,2]'\nGot (Norm):      '[None,3,0,2]'\n--- (Raw) ---\nRaw Expected: '[null, 4, 0, 2]'\nRaw Got:      '[None, 3, 0, 2]'"
        }
      ],
      "generated_code": "import sys\nimport random\nfrom collections import defaultdict\nimport ast\n\nclass Solution:\n    def __init__(self, nums):\n        # 建立每個數值對應到其所有索引的映射\n        self.indices = defaultdict(list)\n        for i, num in enumerate(nums):\n            self.indices[num].append(i)\n\n    def pick(self, target):\n        # 隨機挑選對應索引中的一個\n        return random.choice(self.indices[target])\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # 由於輸入格式是兩個列表用逗號分隔，將其包裝成一個 tuple 以便 literal_eval 解析\n    ops, args = ast.literal_eval(\"(\" + data + \")\")\n    results = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            obj = Solution(*arg)\n            results.append(None)          # constructor 的返回值為 null\n        elif op == \"pick\":\n            results.append(obj.pick(*arg))\n    print(results)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line with explanation. Must not output actual code, just virtual code. The requirement: given array, we need to implement pick that selects random index among occurrences of target uniformly. Approach: pre-processing: build map from target to list of indices. In pick, get list and pick random element.\n\nSo produce steps: Start, Step 1: store array, build map. Then pick: retrieve list, random index from list length. Output chosen index.\n\nWe need to include arrow symbols and Decision. But we can produce flow. Since requirement to not output actual code, we must use virtual steps.\n\nLet's design:\n\nStart\n→ Step 1: 存儲傳入的數組 nums // 保存原始數組\n→ Step 2: 初始化空字典 targetIndices // 建立映射\n→ Step 3: 對於每個索引 i 在 nums 中\n    → Step 4: target = nums[i] // 取得當前元素\n    → Step 5: 如果 target 不在 targetIndices\n        → Step 6: targetIndices[target] = 空列表 // 創建新列表\n        → Step 7: 否則 // target 已存在\n            // (此行可略)\n    → Step 8: targetIndices[target].append(i) // 將索引加入對應列表\nEnd // 初始化完成\n\nPick function\nStart\n→ Step 1: listIndices = targetIndices[target] // 取得所有符合目標的索引列表\n→ Step 2: n = len(listIndices) // 數量\n→ Step 3: randIdx = random integer in [0, n-1] // 隨機選擇位置\n→ Step 4: return listIndices[randIdx] // 返回實際索引\nEnd\n\nWe need to use Decision arrow. Maybe include Decision for existence check: but assumption that target exists.\n\nAlso need to use Yes/No arrows. Let's embed Decision inside initialization.\n\nAlso we need to format each line as \"虛擬碼步驟 // 解釋\". Use arrow for each step.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 儲存傳入的數組 nums // 以便後續使用\n→ Step 2: 建立空字典 targetIndices // 用於映射每個值到其所有索引\n→ Step 3: Decision: 是否已遍歷完 nums? // 檢查是否還有未處理的元素\n    No  → Step 4: 取下次索引 i = current index // 取得當前元素索引\n    No  → Step 5: target = nums[i] // 取得當前元素值\n    No  → Decision: target 是否在 targetIndices? // 判斷映射中是否已存在此鍵\n        Yes → Step 6: targetIndices[target].append(i) // 將索引加入已存在列表\n        No  → Step 7: targetIndices[target] = [i] // 創建新列表並加入索引\n    No  → Step 8: 前進到下一個索引 // 繼續遍歷\n    Yes → End // 所有元素已處理，初始化完成\n\n// ---------------------------\n\nStart // pick 方法開始執行\n→ Step 1: indices = targetIndices[target] // 取得所有符合目標的索引列表\n→ Step 2: n = length(indices) // 取得列表長度\n→ Step 3: randPos = 隨機整數在 [0, n-1] // 隨機選擇位置\n→ Step 4: return indices[randPos] // 回傳對應的索引\nEnd // pick 方法執行結束"
    },
    {
      "title": "Sort Characters By Frequency",
      "source_file": "Leetcode/leetcode451.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"tree\"",
          "expected_output": "\"eert\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'eert'\nGot (Norm):      'eetr'\n--- (Raw) ---\nRaw Expected: '\"eert\"'\nRaw Got:      'eetr'"
        },
        {
          "example_index": 1,
          "input": "s = \"cccaaa\"",
          "expected_output": "\"aaaccc\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'aaaccc'\nGot (Norm):      'cccaaa'\n--- (Raw) ---\nRaw Expected: '\"aaaccc\"'\nRaw Got:      'cccaaa'"
        }
      ],
      "generated_code": "import sys\nfrom collections import Counter\n\ndef frequency_sort(s: str) -> str:\n    \"\"\"Return string sorted by decreasing character frequency.\"\"\"\n    counter = Counter(s)\n    # most_common returns items sorted by count descending\n    return ''.join(char * freq for char, freq in counter.most_common())\n\ndef main() -> None:\n    # Read all input from stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Extract the string value:\n    # If input contains quoted string, take content between first and last quote.\n    # Otherwise, try to strip a leading \"s = \" and any surrounding quotes.\n    start_quote = data.find('\"')\n    end_quote = data.rfind('\"')\n    if start_quote != -1 and end_quote != -1 and end_quote > start_quote:\n        s = data[start_quote + 1:end_quote]\n    else:\n        # Handle input like s = tree or s = \"tree\"\n        if data.lower().startswith('s ='):\n            s = data[3:].strip()\n            if s.startswith('\"') and s.endswith('\"'):\n                s = s[1:-1]\n        else:\n            s = data\n\n    result = frequency_sort(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm: frequency sort of characters descending by count. Steps: input string, count frequencies (map), create list of entries sorted by count descending, build result string by repeating char count times. Use virtual code syntax.\n\nWe need to output each line with arrow and explanation. Must include Start, End, Decision, etc. Provide step-by-step.\n\nLet's design:\n\nStart\n→ Step 1: 接收輸入字串 s // 取得要排序的字串\n→ Step 2: 建立頻率表 freq // 用字典記錄每個字元出現次數\n→ Decision: s 是否非空? // 確認字串不為空\n    Yes → Step 3: 逐字元遍歷 s，更新 freq // 計算每個字元出現次數\n    No  → Step 4: 回傳空字串 // 空字串直接返回\n→ Step 5: 轉換 freq 為列表 of (char, count) // 為排序做準備\n→ Step 6: 依 count 降序排序列表 // 主要排序規則\n→ Step 7: 建立結果字符串 result // 初始化結果\n→ Decision: 列表是否非空? // 檢查是否有字元\n    Yes → Step 8: 逐項將 char 重複 count 次，append to result // 依次拼接\n    No  → Step 9: result 為空字串 // 無字元情況\n→ Step 10: 回傳 result // 完成輸出\nEnd\n\nBut we need to use virtual code arrow syntax: \"→ Step x: ...\". Also Decision: with Yes → / No →.\n\nWe must ensure each line includes \"虛擬碼步驟\" and explanation after space and //.\n\nLet's craft lines:\n\nStart // 程式開始執行\n→ Step 1: Input string s // 取得待排序字串\n→ Step 2: Initialize empty map freq // 用於統計字符頻率\n→ Decision: s is not empty? // 檢查字串是否有內容\n    Yes → Step 3: For each character c in s, increment freq[c] // 統計頻率\n    No  → Step 4: Return empty string // 空字串直接返回\n→ Step 5: Convert freq map to list of (char, count) pairs // 為排序做準備\n→ Step 6: Sort list by count descending // 依頻率遞減排序\n→ Step 7: Initialize empty string result // 用於拼接結果\n→ Decision: list is not empty? // 是否存在字符\n    Yes → Step 8: For each (char, count) in sorted list, append char repeated count times to result // 拼接\n    No  → Step 9: result remains empty // 無字符\n→ Step 10: Return result // 輸出排序後的字串\nEnd // 程式結束\n\nBut the spec: Use 虛擬碼箭頭 and Decision etc. Should include \"Decision:\" with Yes/No lines.\n\nAlso we need each line with \"虛擬碼步驟\" and explanation after space and //.\n\nLet's write each line accordingly. Ensure \"Decision:\" line separate.\n\nAlso for Step 4 we might still be inside Decision, but we can include Step 4: Return empty string // but inside Decision block. Actually we can keep Step 4 as part of Decision branch.\n\nThe sample format shows indentation for branches but no indentation required? They had indent. We'll use indentation.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Input string s // 取得待排序字串  \n→ Step 2: Initialize empty map freq // 用於統計字符頻率  \n→ Decision: s is not empty? // 檢查字串是否有內容  \n Yes → Step 3: For each character c in s, increment freq[c] // 逐個字元更新頻率  \n No  → Step 4: Return empty string // 空字串直接返回  \n→ Step 5: Convert freq map to list of (char, count) pairs // 為排序做準備  \n→ Step 6: Sort list by count descending // 依頻率遞減排序  \n→ Step 7: Initialize empty string result // 用於拼接結果  \n→ Decision: list is not empty? // 是否存在字符  \n Yes → Step 8: For each (char, count) in sorted list, append char repeated count times to result // 拼接字符  \n No  → Step 9: result remains empty // 無字符時保持空串  \n→ Step 10: Return result // 輸出排序後的字串  \nEnd // 程式結束"
    },
    {
      "title": "Palindrome Pairs",
      "source_file": "Leetcode/leetcode336.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "words = [\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]",
          "expected_output": "[[0,1],[1,0],[3,2],[2,4]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0],[3,2],[2,4]]'\nGot (Norm):      '[[0,1],[0,1],[1,0],[1,0],[2,4],[3,2],[4,2],[4,3]]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0],[3,2],[2,4]]'\nRaw Got:      '[[0, 1], [0, 1], [1, 0], [1, 0], [2, 4], [3, 2], [4, 2], [4, 3]]'"
        },
        {
          "example_index": 1,
          "input": "words = [\"bat\",\"tab\",\"cat\"]",
          "expected_output": "[[0,1],[1,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0]]'\nGot (Norm):      '[[0,1],[0,1],[1,0],[1,0]]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0]]'\nRaw Got:      '[[0, 1], [0, 1], [1, 0], [1, 0]]'"
        },
        {
          "example_index": 2,
          "input": "words = [\"a\",\"\"]",
          "expected_output": "[[0,1],[1,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0]]'\nGot (Norm):      '[[0,1]]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0]]'\nRaw Got:      '[[0, 1]]'"
        }
      ],
      "generated_code": "import sys\nfrom typing import List, Dict\n\nclass TrieNode:\n    __slots__ = (\"children\", \"end_index\", \"pal_suffix\")\n    def __init__(self):\n        self.children: Dict[str, TrieNode] = {}\n        self.end_index: int = -1          # index of word ending here, -1 if none\n        self.pal_suffix: List[int] = []   # indices of words whose suffix from this node is palindrome\n\ndef is_palindrome(s: str) -> bool:\n    return s == s[::-1]\n\nclass Solution:\n    def palindromePairs(self, words: List[str]) -> List[List[int]]:\n        root = TrieNode()\n\n        # ---------- 建立反向 Trie ----------\n        for idx, word in enumerate(words):\n            node = root\n            rev = word[::-1]\n            for i, ch in enumerate(rev):\n                if ch not in node.children:\n                    node.children[ch] = TrieNode()\n                node = node.children[ch]\n                # 如果從這個位置到詞首是回文，則此節點可作為後綴匹配\n                if is_palindrome(word[:len(word)-i-1]):\n                    node.pal_suffix.append(idx)\n            node.end_index = idx\n\n        result = []\n\n        # ---------- 對每個詞進行搜尋 ----------\n        for idx, word in enumerate(words):\n            node = root\n            # 1. 逐字搜尋\n            for j, ch in enumerate(word):\n                # 若當前節點標記完整詞，且不是自身且剩餘部分是回文，則匹配\n                if node.end_index != -1 and node.end_index != idx and is_palindrome(word[j:]):\n                    result.append([idx, node.end_index])\n                if ch not in node.children:\n                    break\n                node = node.children[ch]\n            else:\n                # 若完整遍歷完畢，則還要考慮後綴為回文的詞\n                if node.end_index != -1 and node.end_index != idx:\n                    result.append([idx, node.end_index])\n\n            # 2. 之後檢查此節點的 pal_suffix 列表\n            for pidx in node.pal_suffix:\n                if pidx != idx:\n                    result.append([idx, pidx])\n\n        return result\n\ndef parse_input(data: str) -> List[str]:\n    \"\"\"\n    解析形如 'words = [\"abc\",\"def\"]' 或僅為 ['abc','def'] 的輸入。\n    \"\"\"\n    data = data.strip()\n    if not data:\n        return []\n    if '=' in data:\n        _, rhs = data.split('=', 1)\n        data = rhs.strip()\n    try:\n        words = eval(data, {\"__builtins__\": None}, {})\n    except Exception:\n        import json\n        words = json.loads(data)\n    if not isinstance(words, list):\n        raise ValueError(\"輸入必須為字串列表\")\n    return words\n\ndef main():\n    raw = sys.stdin.read()\n    words = parse_input(raw)\n    sol = Solution()\n    pairs = sol.palindromePairs(words)\n    print(pairs)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode for algorithm to find palindrome pairs. We must follow the output format: each line with \"虛擬碼步驟\" and comment. Use arrow etc. O(total length). Known solution: use Trie of reversed words, mapping word index. For each word, traverse prefix-suffix to check palindromes. We'll produce high-level steps.\n\nWe must not output actual code, just virtual code. We'll produce steps: Build Trie, store indices at nodes, also list of word indices whose suffix from node is palindrome. Then for each word, search reversed in Trie. Then collect pairs. Also check empty string special. Complexity linear.\n\nLet's produce pseudocode line by line.\n\nWe need to include Start, End, Decision. Provide simple steps.\n\nLet's outline:\n\nStart\n→ Step: Build trie of reversed words\n    For each word w with index i:\n        node = root\n        For each character c in reversed(w):\n            if child not exists: create\n            node = child\n        node.index = i // store index at end\n        // Also store in node list? We'll store palindrome suffix list at node maybe.\n\nAlso we need to store for each node the list of word indices whose remaining suffix is palindrome? Standard: When building, at each node during traversal, if remaining part of word is palindrome, add index to node.palindrome_suffix_list. That helps when searching.\n\nThen after building, for each word i:\n    Search in trie following characters of word (original order), keep track at each node.\n    At each node, if node.index != -1 and node.index != i and word[remaining part] is palindrome -> add pair (i,node.index)\n    After finishing traversal, for each index in node.palindrome_suffix_list, if index != i -> add pair (i,index)\n\nAlso need to handle empty string: pairs with any palindrome word.\n\nBut produce pseudocode.\n\nLet's write lines:\n\nStart // 程式開始\n\n→ Step 1: 初始化 Trie 及空陣列 pairs // 建立樹狀結構與結果儲存\n\n→ Decision: 是否存在空字串? // 特殊情況\n    Yes → Step 2: 對每個 palindrome 文字加入 (emptyIndex, idx) 和 (idx, emptyIndex) // 空字串與回文文字配對\n    No  → // 不執行\n\n→ Step 3: 建立 Trie 反向字串\n    For each word w, idx\n        node = root\n        For k from len(w)-1 downto 0\n            char = w[k]\n            if child not exist: create\n            node = child\n            // 檢查從此位置起的前綴是否為回文\n            if substring w[0..k] is palindrome\n                add idx to node.palList // 以便後續搜尋\n        node.endIndex = idx // 樹節點標記完整字串索引\n\n→ Step 4: 對每個字串 w, idx 進行搜尋\n    node = root\n    for j from 0 to len(w)-1\n        // 若此節點表示完整字串，且不是自身且剩餘字串回文\n        if node.endIndex != -1 and node.endIndex != idx and substring w[j..] is palindrome\n            add pair (idx, node.endIndex)\n        char = w[j]\n        if child not exist: break // 無法繼續\n        node = child\n    // 搜尋完字串後，將剩餘 palindrome suffix 列表中的索引加入\n    for each p in node.palList\n        if p != idx\n            add pair (idx, p)\n\n→ End // 程式結束\n\nWe need to follow format: each line \"虛擬碼步驟 // 解釋\". Use arrow \"→\". Also \"Decision:\" lines. The code uses indent.\n\nWe should separate steps lines accordingly. Provide each line with a comment after //.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始\n\n→ Step 1: 初始化 Trie root 及空陣列 pairs // 建立樹狀結構與結果儲存\n\n→ Decision: 是否存在空字串? // 特殊情況\n    Yes → Step 2: 對每個 palindrome 文字加入 (emptyIndex, idx) 和 (idx, emptyIndex) // 空字串與回文文字配對\n    No  → // 不執行\n\n→ Step 3: 建立 Trie 反向字串\n    For each word w, idx\n        node = root\n        For k from len(w)-1 downto 0\n            char = w[k]\n            if child not exist: create\n            node = child\n            // 檢查從此位置起的前綴是否為回文\n            if substring w[0..k] is palindrome\n                add idx to node.palList // 以便後續搜尋\n        node.endIndex = idx // 樹節點標記完整字串索引\n\n→ Step 4: 對每個字串 w, idx 進行搜尋\n    node = root\n    for j from 0 to len(w)-1\n        // 若此節點表示完整字串，且不是自身且剩餘字串回文\n        if node.endIndex != -1 and node.endIndex != idx and substring w[j..] is palindrome\n            add pair (idx, node.endIndex)\n        char = w[j]\n        if child not exist: break // 無法繼續\n        node = child\n    // 搜尋完字串後，將剩餘 palindrome suffix 列表中的索引加入\n    for each p in node.palList\n        if p != idx\n            add pair (idx, p)\n\nEnd // 程式結束"
    },
    {
      "title": "Longest Uncommon Subsequence II",
      "source_file": "Leetcode/leetcode522.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"aaa\",\"aaa\",\"aa\"]",
          "expected_output": "-1",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '-1'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: '-1'\nRaw Got:      '2'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findLUSlength(self, strs):\n        \"\"\"\n        Return the length of the longest uncommon subsequence among the given strings.\n        If no such subsequence exists, return -1.\n        \"\"\"\n        # Count occurrences of each string\n        freq = {}\n        for s in strs:\n            freq[s] = freq.get(s, 0) + 1\n\n        # Search for any string that appears only once\n        max_len = -1\n        for s in strs:\n            if freq[s] == 1:\n                max_len = max(max_len, len(s))\n\n        return max_len\n\n\nif __name__ == \"__main__\":\n    # Read the entire input from stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        print(-1)\n        sys.exit(0)\n\n    # Parse the input into a Python list\n    try:\n        strs = ast.literal_eval(data)\n        if not isinstance(strs, list):\n            raise ValueError\n    except Exception:\n        print(-1)\n        sys.exit(0)\n\n    # Ensure all elements are strings\n    if not all(isinstance(s, str) for s in strs):\n        print(-1)\n        sys.exit(0)\n\n    # Compute and print the result\n    solution = Solution()\n    result = solution.findLUSlength(strs)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps line by line with explanation, for the problem: longest uncommon subsequence length. Classic Leetcode problem 521. Approach: if there is any string that is unique (i.e., not equal to any other), then the longest uncommon subsequence length is its length. If all strings are same, answer -1. Because any subsequence of one string is also subsequence of others if equal. So answer: find any string that appears only once; if none, return -1. Implementation: count frequency of each string; find max length among strings with count 1; if none, -1.\n\nWe produce virtual code steps: Start → Read array strs → Build frequency map → For each string, record count. → Decision: if any string count==1? Yes → find max length among unique strings → Return max length. No → Return -1. End.\n\nNeed line by line with \"虛擬碼步驟\" and explanation. Use arrow. Provide each step line. Ensure proper formatting: \"虛擬碼\" e.g. \"Start\" or \"→ Step ...\".\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空字典 freq // 用於統計每個字串出現次數  \n→ Step 2: 對於每個字串 s in strs:  \n  → freq[s] = freq.get(s, 0) + 1 // 更新字典計數  \n→ Step 3: 建立空變數 maxLen = -1 // 預設為 -1，代表無解  \n→ Step 4: 對於每個字串 s in strs:  \n  → Decision: 若 freq[s] == 1? // 判斷 s 是否唯一  \n   Yes → maxLen = max(maxLen, len(s)) // 更新最大長度  \n   No → 進一步無操作  \n→ Decision: 若 maxLen == -1? // 判斷是否存在唯一字串  \n  Yes → Step 5: 回傳 -1 // 所有字串都重複，無不相同子序列  \n  No → Step 6: 回傳 maxLen // 回傳最大的唯一字串長度  \nEnd // 程式執行結束"
    },
    {
      "title": "Repeated DNA Sequences",
      "source_file": "Leetcode/leetcode187.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = 'AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT'",
          "expected_output": "[\"AAAAACCCCC\",\"CCCCCAAAAA\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"AAAAACCCCC\",\"CCCCCAAAAA\"]'\nGot (Norm):      '[\"CCCCCAAAAA\",\"AAAAACCCCC\"]'\n--- (Raw) ---\nRaw Expected: '[\"AAAAACCCCC\",\"CCCCCAAAAA\"]'\nRaw Got:      '[\"CCCCCAAAAA\",\"AAAAACCCCC\"]'"
        }
      ],
      "generated_code": "import sys\nimport json\n\ndef find_repeated_dna_sequences(s: str):\n    \"\"\"\n    找出 DNA 序列中所有長度為 10 的子串，且出現超過一次的子串。\n    \"\"\"\n    seen = set()\n    repeated = set()\n\n    # 迭代所有可能的起始位置，截取長度為 10 的子串\n    for i in range(len(s) - 9):\n        seq = s[i:i + 10]\n        if seq in seen:\n            repeated.add(seq)\n        else:\n            seen.add(seq)\n\n    return list(repeated)\n\ndef parse_input(data: str) -> str:\n    \"\"\"\n    解析輸入資料，提取 DNA 字串。\n    若輸入包含單引號，則取引號之間的內容；否則直接返回整個字串。\n    \"\"\"\n    data = data.strip()\n    if \"'\" in data:\n        first = data.find(\"'\")\n        last = data.rfind(\"'\")\n        return data[first + 1:last]\n    return data\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    raw_input = sys.stdin.read()\n    dna_sequence = parse_input(raw_input)\n\n    # 找出重複的 10 字母長度子串\n    repeated_sequences = find_repeated_dna_sequences(dna_sequence)\n\n    # 以 JSON 形式輸出，避免空格，符合範例要求\n    print(json.dumps(repeated_sequences, separators=(\",\", \":\")))",
      "virtual_code": "Thinking...\nWe need to produce a virtual code (pseudo-code) line by line, with explanation comments. The user wants code to find all 10-letter-long substrings that occur more than once in a string s. So we need to produce pseudocode that uses a hash map to count substrings, then collect those with count>1. Use Start, End, Decision etc.\n\nWe should include steps like reading s, determine length, loop over indices, extract substring of length 10, increment count in map, then after loop, iterate map to collect those >1, output list.\n\nWe need to follow format: each line with \"虛擬碼步驟 // 解釋\". Use arrow and structure.\n\nWe must not output actual code, just the pseudocode lines.\n\nLet's produce something like:\n\nStart // 程式開始執行\n→ Step 1: 初始化空字典 countMap // 用於記錄每個10字母序列的出現次數\n→ Step 2: 初始化空列表 result // 存放重複的序列\n→ Step 3: 取得輸入字串 s // DNA 序列\n→ Decision: 如果 s 長度 < 10? // 無法形成10字母序列\n    Yes → End // 程式結束\n    No  → Step 4: 設定 n = s 長度 // 方便迴圈\n→ Step 5: 迴圈 i 從 0 到 n-10 // 遍歷所有可能的起始位置\n    → Step 6: 取 substr = s[i:i+10] // 取出10字母子串\n    → Decision: substr 是否已在 countMap? // 判斷是否已出現\n        Yes → Step 7: countMap[substr] = countMap[substr] + 1 // 次數加 1\n        No  → Step 8: countMap[substr] = 1 // 首次出現，次數設為1\n→ Step 9: 迴圈 over countMap 中每個 key, value\n    → Decision: value > 1? // 是否重複\n        Yes → Step 10: 將 key 加入 result 列表 // 記錄重複序列\n→ Step 11: 輸出 result 列表 // 返回所有重複的10字母序列\nEnd // 程式執行結束\n\nMake sure each line includes arrow or decision. Use proper Chinese commentary. The arrow lines should include the pseudo-code and comment.\n\nMake sure to adhere to the format: \"虛擬碼步驟 // 解釋/說明\". Use \"→\" or \"Decision:\" lines accordingly.\n\nWe should include the Start and End lines. For Decision lines, we must show \"Decision: ... ?\" and indent subsequent lines with \"Yes →\" or \"No →\". Use proper indentation.\n\nAlso we should ensure we don't produce actual code, just pseudocode steps. We might mention variables like countMap, result, substr, n, i. That is fine.\n\nWe need to output each line separately. Probably we should avoid extra explanation outside comments. The format should be exactly as required: each line with \"虛擬碼步驟 // 解釋\".\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空字典 countMap // 用於記錄每個 10 字母序列的出現次數  \n→ Step 2: 初始化空列表 result // 存放重複的 10 字母序列  \n→ Step 3: 取得輸入字串 s // DNA 序列  \n→ Decision: 如果 s 長度 < 10? // 無法形成 10 字母序列  \n  Yes → End // 程式結束  \n  No  → Step 4: 設定 n = s 長度 // 方便迴圈  \n→ Step 5: 迴圈 i 從 0 到 n-10 // 遍歷所有可能的起始位置  \n  → Step 6: 取 substr = s[i:i+10] // 取出 10 字母子串  \n  → Decision: substr 是否已在 countMap? // 判斷是否已出現  \n    Yes → Step 7: countMap[substr] = countMap[substr] + 1 // 次數加 1  \n    No  → Step 8: countMap[substr] = 1 // 首次出現，次數設為 1  \n→ Step 9: 迴圈 over countMap 中每個 key, value // 遍歷所有已記錄的序列  \n  → Decision: value > 1? // 是否重複  \n    Yes → Step 10: 將 key 加入 result 列表 // 記錄重複序列  \n→ Step 11: 輸出 result 列表 // 返回所有重複的 10 字母序列  \nEnd // 程式執行結束"
    },
    {
      "title": "Find the Duplicate Number",
      "source_file": "Leetcode/leetcode287.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "nums = [3,1,3,4,2]",
          "expected_output": "O3",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'O3'\nGot (Norm):      '3'\n--- (Raw) ---\nRaw Expected: 'O3'\nRaw Got:      '3'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def findDuplicate(self, nums):\n        # Floyd's Tortoise and Hare algorithm\n        slow = fast = nums[0]\n\n        # 第一階段：尋找相遇點\n        while True:\n            slow = nums[slow]\n            fast = nums[nums[fast]]\n            if slow == fast:\n                break\n\n        # 第二階段：尋找入環點，即重複數字\n        slow = nums[0]\n        while slow != fast:\n            slow = nums[slow]\n            fast = nums[fast]\n\n        return slow\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 從輸入中抓取方括號內的內容，並轉成整數列表\n    match = re.search(r'\\[(.*?)\\]', data)\n    if not match:\n        print(\"0\")  # 若找不到數列，輸出 0（無重複）\n        return\n\n    nums = [int(num.strip()) for num in match.group(1).split(',') if num.strip()]\n\n    solution = Solution()\n    duplicate = solution.findDuplicate(nums)\n    print(duplicate)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code steps for solution: find duplicate number in array of size n+1 with numbers 1..n. Must not modify array and use only constant space. Classic Floyd's Tortoise and Hare cycle detection. Steps: set slow = nums[0], fast = nums[0]; then loop while true: slow=nums[slow], fast=nums[nums[fast]]; break when equal. Then find entrance: pointer1 = nums[0]; pointer2 = slow; while pointer1!=pointer2: pointer1=nums[pointer1]; pointer2=nums[pointer2]; return pointer1.\n\nWe need to produce virtual code line by line with explanation. Use Start, Decision, etc. Format: \"→ Step 1: ...\" etc.\n\nLet's create a flow.\n\nStart\n→ Step 1: Initialize slow ← nums[0] // set first pointer\n→ Step 2: Initialize fast ← nums[0] // set second pointer\n→ Decision: 是否已进入循环? (not necessary)\n→ Step 3: Repeat while true:\n    → Step 4: slow ← nums[slow] // move one step\n    → Step 5: fast ← nums[nums[fast]] // move two steps\n    → Decision: slow == fast? // check meeting\n        Yes → Break loop // cycle found\n        No  → Continue loop\n→ Step 6: Initialize ptr1 ← nums[0] // start from beginning\n→ Step 7: Initialize ptr2 ← slow // start from meeting point\n→ Decision: ptr1 == ptr2?\n    Yes → Step 8: return ptr1 // duplicate found\n    No  → Step 9: ptr1 ← nums[ptr1] // move one step\n           Step 10: ptr2 ← nums[ptr2] // move one step\n           → Go back to Decision\nEnd\n\nWe need to produce each line as \"→ Step X: ...\" with explanation. Use Decision lines appropriately.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: slow ← nums[0] // 初始化慢指標，指向陣列第一個元素  \n→ Step 2: fast ← nums[0] // 初始化快指標，指向陣列第一個元素  \n→ Decision: 是否開始尋找週期？ // 準備進入循環尋找相遇點  \n    Yes → Step 3: Loop ← true // 開始循環尋找相遇點  \n        → Step 4: slow ← nums[slow] // 慢指標每次前進一步  \n        → Step 5: fast ← nums[nums[fast]] // 快指標每次前進兩步  \n        → Decision: slow == fast? // 判斷兩指標是否相遇  \n            Yes → Step 6: Break Loop // 找到週期相遇點，退出循環  \n            No  → Step 7: Continue Loop // 未相遇，繼續執行 Step 4-5  \n→ Step 8: ptr1 ← nums[0] // 初始化指標 ptr1 從陣列起始點開始  \n→ Step 9: ptr2 ← slow // 初始化指標 ptr2 從相遇點開始  \n→ Decision: ptr1 == ptr2? // 判斷兩指標是否相遇，尋找入口  \n    Yes → Step 10: return ptr1 // ptr1 即為重複的數字，回傳結果  \n    No  → Step 11: ptr1 ← nums[ptr1] // ptr1 前進一步  \n           Step 12: ptr2 ← nums[ptr2] // ptr2 前進一步  \n           → Go back to Decision // 重複判斷直至相遇  \nEnd // 程式執行結束"
    },
    {
      "title": "Insert Delete GetRandom O(1) - Duplicates allowed",
      "source_file": "Leetcode/leetcode381.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedCollection\", \"insert\", \"insert\", \"insert\", \"getRandom\", \"remove\", \"getRandom\"], [[], [1], [1], [2], [], [1], []]",
          "expected_output": "[null, true, false, true, 2, true, 1]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,false,true,2,true,1]'\nGot (Norm):      '[null,true,false,true,2,true,2]'\n--- (Raw) ---\nRaw Expected: '[null, true, false, true, 2, true, 1]'\nRaw Got:      '[null, true, false, true, 2, true, 2]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport collections\n\nclass RandomizedCollection:\n    def __init__(self):\n        self.data = []\n        self.idx_map = collections.defaultdict(set)\n\n    def insert(self, val: int) -> bool:\n        self.data.append(val)\n        self.idx_map[val].add(len(self.data) - 1)\n        return len(self.idx_map[val]) == 1\n\n    def remove(self, val: int) -> bool:\n        if not self.idx_map[val]:\n            return False\n        remove_idx = self.idx_map[val].pop()\n        last_val = self.data[-1]\n        self.data[remove_idx] = last_val\n        self.idx_map[last_val].add(remove_idx)\n        self.idx_map[last_val].discard(len(self.data) - 1)\n        self.data.pop()\n        return True\n\n    def getRandom(self) -> int:\n        return random.choice(self.data)\n\ndef main():\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n\n    # Split the two JSON arrays that are separated by the first '],'\n    parts = raw_input.split('],', 1)\n    left = parts[0].rstrip() + ']'\n    right = parts[1].lstrip()\n\n    ops = json.loads(left)\n    args = json.loads(right)\n\n    obj = None\n    results = []\n\n    for op, arg in zip(ops, args):\n        if op == \"RandomizedCollection\":\n            obj = RandomizedCollection()\n            results.append(None)          # constructor returns null\n        elif op == \"insert\":\n            results.append(obj.insert(arg[0]))\n        elif op == \"remove\":\n            results.append(obj.remove(arg[0]))\n        elif op == \"getRandom\":\n            results.append(obj.getRandom())\n\n    # Output in JSON format to match the expected LeetCode style\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need produce virtual code steps line by line. Should represent the implementation of RandomizedCollection with O(1) operations. Use structure: Start, End, Decision, etc. Use arrow. Provide explanation after space comment. Should not output actual code. Just pseudo steps. We'll produce high-level algorithm. Use array list to store values and map value to set of indices. Steps: initialization, insert, remove, getRandom. Provide decision flows. Ensure each step includes comment. Let's produce.\n...done thinking.\n\nStart // 程式開始執行\n\n→ Step 1: 建立空動態陣列 list // 用於儲存所有元素的值，方便隨機存取\n→ Step 2: 建立映射 map: 數值 → 集合(index集合) // 用於追蹤每個值在 list 中的所有位置\n\n// ------------------------------\n// Insert 操作\n// ------------------------------\n→ Decision: 先檢查 map 是否存在 key val? // 判斷 val 是否已存在於集合\n    Yes → Step 3: 在 list 末尾加入 val // 即 list.append(val)\n    Yes → Step 4: 取得 val 對應的 index 集合 idxSet = map[val]\n    Yes → Step 5: 將新加入的位置 index = list.size - 1 加入 idxSet // idxSet.add(index)\n    Yes → Step 6: 回傳 false // val 已存在，插入後仍為重複項\n    No  → Step 7: 在 list 末尾加入 val // list.append(val)\n    No  → Step 8: 建立新集合 idxSet = {list.size - 1}\n    No  → Step 9: 在 map 中插入 key val → idxSet\n    No  → Step 10: 回傳 true // val 原本不存在，已成功加入\n\n// ------------------------------\n// Remove 操作\n// ------------------------------\n→ Decision: 檢查 map 中是否有 key val? // 判斷 val 是否存在\n    No  → Step 11: 回傳 false // val 不存在，無法移除\n    Yes → Step 12: 取得 val 對應的 index 集合 idxSet = map[val]\n    Yes → Step 13: 從 idxSet 取一個任意索引 lastIdx = idxSet任意元素\n    Yes → Step 14: 取得 list 的最後一個值 lastVal = list[list.size - 1]\n    Yes → Step 15: 將 list[lastIdx] 設為 lastVal // 交換位置\n    Yes → Step 16: 更新 lastVal 對應的索引集合 lastIdxSet = map[lastVal]\n    Yes → Step 17: 從 lastIdxSet 移除舊的最後位置 list.size - 1\n    Yes → Step 18: 若 lastVal != val, 將 lastIdx 加入 lastIdxSet // 更新為新位置\n    Yes → Step 19: 從 idxSet 移除 lastIdx // 移除要刪除的索引\n    Yes → Step 20: 若 idxSet 為空，從 map 刪除 key val\n    Yes → Step 21: list.pop() // 移除最後一個位置的元素\n    Yes → Step 22: 回傳 true // 成功移除\n\n// ------------------------------\n// getRandom 操作\n// ------------------------------\n→ Step 23: 生成隨機索引 r = 隨機整數(0, list.size - 1)\n→ Step 24: 回傳 list[r] // 隨機返回元素\n\nEnd // 程式執行結束"
    },
    {
      "title": "Palindrome Partitioning II",
      "source_file": "Leetcode/leetcode132.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"aab\"",
          "expected_output": "1",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '1'\nGot (Norm):      '5'\n--- (Raw) ---\nRaw Expected: '1'\nRaw Got:      '5'"
        },
        {
          "example_index": 1,
          "input": "s = \"a\"",
          "expected_output": "0",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '0'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: '0'\nRaw Got:      '2'"
        },
        {
          "example_index": 2,
          "input": "s = \"ab\"",
          "expected_output": "1",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '1'\nGot (Norm):      '5'\n--- (Raw) ---\nRaw Expected: '1'\nRaw Got:      '5'"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def minCut(self, s: str) -> int:\n        n = len(s)\n        if n == 0:\n            return 0\n        dp = [0] * n\n        pal = [[False] * n for _ in range(n)]\n\n        for i in range(n):\n            min_cut = i  # worst case: cut before each character\n            for j in range(i + 1):\n                if s[j] == s[i] and (i - j <= 1 or pal[j + 1][i - 1]):\n                    pal[j][i] = True\n                    if j == 0:\n                        min_cut = 0  # whole prefix is palindrome\n                    else:\n                        min_cut = min(min_cut, dp[j - 1] + 1)\n            dp[i] = min_cut\n\n        return dp[-1]\n\n\ndef parse_input(raw: str) -> str:\n    \"\"\"Extract the string value from raw input.\"\"\"\n    raw = raw.strip()\n    # If the input contains quotes, extract the part inside quotes\n    if raw.startswith('\"') and raw.endswith('\"'):\n        return raw[1:-1]\n    if raw.startswith(\"'\") and raw.endswith(\"'\"):\n        return raw[1:-1]\n    if '=\"' in raw or \"='\" in raw:\n        # Find first quote after the '=' sign\n        pos = raw.find('=') + 1\n        while pos < len(raw) and raw[pos] not in ('\"', \"'\"):\n            pos += 1\n        if pos < len(raw):\n            quote = raw[pos]\n            end = raw.find(quote, pos + 1)\n            if end != -1:\n                return raw[pos + 1:end]\n    # Fallback: use the whole trimmed line\n    return raw\n\n\ndef main() -> None:\n    raw_input = sys.stdin.read()\n    s = parse_input(raw_input)\n    result = Solution().minCut(s)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode for algorithm to compute minimum cuts for palindrome partitioning of a string s. Standard solution: DP with precomputed palindrome table. Outline: compute palindrome[i][j] true if s[i..j] palindrome. Then dp[i] minimal cuts for substring s[0..i]. dp[i] = 0 if palindrome[0][i] else min over j from 0 to i-1 of dp[j]+1 if palindrome[j+1][i] true. Start with dp[-1] = -1 maybe. Use loops.\n\nWe need to output line by line, each line with \"虛擬碼步驟 // 解釋\".\n\nUse arrow \"→\" for flow. Use \"Decision:\" etc. Provide pseudocode steps.\n\nLet's craft:\n\nStart\n→ Step 1: 讀入字串 s // Acquire input\n→ Step 2: 取得長度 n // n = len(s)\n→ Step 3: 初始化二維布林陣列 isPal[n][n] 為 False // Palindrome table\n→ Step 4: 建立單字 palindrome: for i in 0..n-1: isPal[i][i] = True // 單字符自為回文\n→ Step 5: 建立長度 2 的 palindrome: for i in 0..n-2: if s[i]==s[i+1] then isPal[i][i+1] = True\n→ Step 6: 建立長度 >2 的 palindrome: for len from 3 to n: for i 0..n-len: j=i+len-1; if s[i]==s[j] and isPal[i+1][j-1] then isPal[i][j]=True\n→ Step 7: 初始化 dp array size n, dp[i] = 0\n→ Step 8: 迴圈 i 0..n-1:\n    → Decision: 如果 isPal[0][i] then dp[i] = 0 // no cut needed\n    → Else:\n        → Step 9: 設 dp[i] = large\n        → Step 10: 迴圈 j 0..i-1:\n            → Decision: 如果 isPal[j+1][i] then\n                → Step 11: dp[i] = min(dp[i], dp[j]+1)\n→ Step 12: 輸出 dp[n-1] // 最小切割數\nEnd\n\nNeed to use arrow notation: \"→\" for steps, \"Decision:\" for conditions, \"Yes →\", \"No →\".\n\nLet's write each line. Should incorporate arrows. Use Chinese comments.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀入字串 s // 從使用者取得輸入字串  \n→ Step 2: 取得長度 n ← len(s) // 取得字串長度  \n→ Step 3: 初始化二維布林陣列 isPal[n][n] 為 False // 用來儲存子字串是否為回文  \n→ Step 4: 建立單字回文: for i in 0..n-1: isPal[i][i] ← True // 每個單字符自身為回文  \n→ Step 5: 建立長度為 2 的回文: for i in 0..n-2: if s[i]==s[i+1] then isPal[i][i+1] ← True // 判斷相鄰兩字是否相同  \n→ Step 6: 建立長度 >2 的回文: for len from 3 to n:  \n    for i in 0..n-len: j ← i+len-1  \n     Decision: 如果 s[i]==s[j] 且 isPal[i+1][j-1]? // 外側兩字相同且內層為回文  \n      Yes → isPal[i][j] ← True // 則整個子字串為回文  \n      No  → isPal[i][j] ← False // 否則非回文  \n→ Step 7: 初始化 dp 陣列大小 n: dp[i] ← 0 for all i // dp[i] 代表 s[0..i] 最小切割數  \n→ Step 8: 迴圈 i in 0..n-1:  \n    Decision: 如果 isPal[0][i]? // 整個前綴是否為回文  \n     Yes → dp[i] ← 0 // 不需要切割  \n     No  → Step 9: dp[i] ← ∞ // 初始化為無限大  \n      Step 10: 迴圈 j in 0..i-1:  \n       Decision: 如果 isPal[j+1][i]? // 從 j+1 到 i 是否為回文  \n        Yes → dp[i] ← min(dp[i], dp[j]+1) // 若是，考慮此切割方式  \n        No  → 無需執行  \n→ Step 11: 輸出 dp[n-1] // 回傳最小切割數  \nEnd // 程式執行結束"
    },
    {
      "title": "Find Median from Data Stream",
      "source_file": "Leetcode/leetcode295.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"], [[], [1], [2], [], [3], []]",
          "expected_output": "[null, null, null, 1.5, null, 2.0]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpudjlnwtz.py\", line 39, in <module>\n    args_list = ast.literal_eval(data[1].strip())\n                                 ~~~~^^^\nIndexError: list index out of range"
        }
      ],
      "generated_code": "import sys\nimport heapq\nimport ast\nimport json\n\nclass MedianFinder:\n    def __init__(self):\n        # 小根堆存儲較大的那一半\n        self.large = []\n        # 大根堆（用負數做小根堆）存儲較小的那一半\n        self.small = []\n\n    def addNum(self, num: int) -> None:\n        # 把新數加入小根堆（負值做大根堆）\n        heapq.heappush(self.small, -num)\n        # 保證小根堆的最大值 <= 大根堆的最小值\n        if self.small and self.large and (-self.small[0] > self.large[0]):\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        # 平衡兩堆大小，左堆可以比右堆多一個元素\n        if len(self.small) > len(self.large) + 1:\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        elif len(self.large) > len(self.small):\n            val = heapq.heappop(self.large)\n            heapq.heappush(self.small, -val)\n\n    def findMedian(self) -> float:\n        if len(self.small) > len(self.large):\n            return -self.small[0]\n        return (-self.small[0] + self.large[0]) / 2.0\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        sys.exit()\n    # 第一行是方法名列表，第二行是對應的參數列表\n    commands = ast.literal_eval(data[0].strip())\n    args_list = ast.literal_eval(data[1].strip())\n\n    results = []\n    obj = None\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"MedianFinder\":\n            obj = MedianFinder()\n            results.append(None)\n        elif cmd == \"addNum\":\n            obj.addNum(args[0])\n            results.append(None)\n        elif cmd == \"findMedian\":\n            results.append(obj.findMedian())\n        else:\n            # 若有其他方法，直接忽略或拋出錯誤\n            results.append(None)\n\n    # 使用 json.dumps 來得到符合 LeetCode 輸出格式的字串\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code lines with explanation for the described median finder. Use a class with two heaps: max-heap left and min-heap right. Steps: constructor initializes heaps. addNum: if left empty or num <= max(left), push to left else to right. Then balance sizes: if left size > right size +1, move top from left to right. If right size > left size, move top from right to left. findMedian: if sizes equal, median = (max(left)+min(right))/2. else median = max(left). Provide line-by-line pseudo code with arrows and explanation.\n\nMake sure use \"Start\", \"End\". Use \"Decision:\" lines for condition checks.\n\nLet's produce each step line with // explanation. Use indentation for nested decisions. Use arrows \"→\". Use \"Decision: If condition?\" lines.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類別 MedianFinder // 建立 MedianFinder 類別  \n→ Step 2: 初始化 maxHeap 為空最大堆 // 左側堆，存儲較小的一半  \n→ Step 3: 初始化 minHeap 為空最小堆 // 右側堆，存儲較大的一半  \n→ Step 4: 定義 addNum(num) 方法 // 加入新數字  \n→ Decision: 如果 maxHeap 為空 或 num <= maxHeap.top? // 判斷數字是否屬於左側  \n    Yes → Step 5: 將 num 推入 maxHeap // 放入左側堆  \n    No  → Step 6: 將 num 推入 minHeap // 放入右側堆  \n→ Step 7: 調整堆平衡  \n    Decision: 如果 maxHeap.size > minHeap.size + 1? // 左側過大  \n        Yes → Step 8: 將 maxHeap.top 移至 minHeap // 轉移頂點  \n    Decision: 如果 minHeap.size > maxHeap.size? // 右側過大  \n        Yes → Step 9: 將 minHeap.top 移至 maxHeap // 轉移頂點  \n→ Step 10: 定義 findMedian() 方法 // 返回當前中位數  \n    Decision: 如果 maxHeap.size == minHeap.size? // 數量相等  \n        Yes → Step 11: 返回 (maxHeap.top + minHeap.top) / 2.0 // 取平均  \n    Decision: 如果 maxHeap.size > minHeap.size? // 左側多一個  \n        Yes → Step 12: 返回 maxHeap.top // 直接取左側頂點  \n    No  → Step 13: 返回 minHeap.top // 右側多一個，取右側頂點  \nEnd // 程式執行結束"
    },
    {
      "title": "Group Anagrams",
      "source_file": "Leetcode/leetcode49.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]",
          "expected_output": "[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]'\nGot (Norm):      '[[\"eat\",\"tea\",\"ate\"],[\"tan\",\"nat\"],[\"bat\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]'\nRaw Got:      '[[\"eat\", \"tea\", \"ate\"], [\"tan\", \"nat\"], [\"bat\"]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nfrom collections import defaultdict\n\ndef group_anagrams(strs):\n    anagrams = defaultdict(list)\n    for s in strs:\n        key = tuple(sorted(s))          # 以排序後的字符元組作為鍵\n        anagrams[key].append(s)\n    return list(anagrams.values())\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整行資料\n    data = sys.stdin.read().strip()\n    # 取出等號右邊的列表字串\n    start = data.find('[')\n    end = data.rfind(']')\n    list_str = data[start:end+1]\n    # 轉成真正的 Python list\n    strs = ast.literal_eval(list_str)\n\n    result = group_anagrams(strs)\n    # 使用 json.dumps 以雙引號格式輸出\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines step by step with explanations, for grouping anagrams from array of strings. Use Start, End, Decision, etc. Provide each line with \"虛擬碼步驟 // 解釋\". Should be virtual code, no actual code, just steps. Must be in Traditional Chinese. Use arrow symbols. Provide grouping logic: use hash map keyed by sorted string or frequency signature.\n\nLet's produce:\n\nStart // start program\n→ Step 1: 初始化空哈希表 groups // create map key->list\n→ Step 2: 遍歷輸入陣列 strs // iterate each string\n    → Step 2a: 計算字符串的字母頻率簽名 signature // compute signature\n    → Decision: 如果 groups 中沒有此 signature? // check map\n        Yes → Step 2b: 在 groups 中建立新列表並加入當前字符串\n        No  → Step 2c: 把當前字符串加入對應列表\n→ Step 3: 從 groups 的值收集所有列表到結果列表 result // gather\nEnd // 結束\n\nWe might include more detailed steps. Ensure each line ends with // explanation. Use \"Yes →\", \"No →\". Use indentation? They used indentation in example. We can indent decisions accordingly. Provide arrows. Provide each line separated. Must not output actual code. Provide \"Step 1:\" etc.\n\nLet's create final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空哈希表 groups // 建立一個 map，鍵為字母簽名，值為字串列表  \n→ Step 2: 遍歷輸入陣列 strs // 逐個處理每個字串  \n    → Step 2a: 取得字串 s 的字母頻率簽名 signature // 例如將 s 排序或計算 26 個字母的計數  \n    → Decision: groups 中是否已有此 signature? // 判斷 map 是否包含此鍵  \n        Yes → Step 2b: 把 s 加入 groups[signature] 列表 // 已存在則直接加入相同簽名的群組  \n        No  → Step 2c: 建立新的列表 groups[signature] 並加入 s // 不存在則創建新群組  \n→ Step 3: 將 groups 的所有值（各個列表）收集為結果列表 result // 取得所有同類型字串的集合  \nEnd // 程式執行結束"
    },
    {
      "title": "Zuma Game",
      "source_file": "Leetcode/leetcode488.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "board = \"WRRBBW\", hand = \"RB\"",
          "expected_output": "-1",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpgwxrxt_v.py\", line 78, in <module>\n    result = sol.findMinStep(board_str, hand_str)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpgwxrxt_v.py\", line 51, in findMinStep\n    ans = dfs(board, initial_hand_tuple)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpgwxrxt_v.py\", line 40, in dfs\n    new_board = curr_board[:i] + color + curr_board[i:]\n                ~~~~~~~~~~~~~~~^~~~~~~\nTypeError: can only concatenate str (not \"tuple\") to str"
        },
        {
          "example_index": 1,
          "input": "board = \"WWRRBBWW\", hand = \"WRBRW\"",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpan3pg71g.py\", line 78, in <module>\n    result = sol.findMinStep(board_str, hand_str)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpan3pg71g.py\", line 51, in findMinStep\n    ans = dfs(board, initial_hand_tuple)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpan3pg71g.py\", line 40, in dfs\n    new_board = curr_board[:i] + color + curr_board[i:]\n                ~~~~~~~~~~~~~~~^~~~~~~\nTypeError: can only concatenate str (not \"tuple\") to str"
        },
        {
          "example_index": 2,
          "input": "board = \"G\", hand = \"GGGGG\"",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '-1'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '-1'"
        }
      ],
      "generated_code": "import sys\nimport collections\nfrom functools import lru_cache\n\ndef collapse(board: str) -> str:\n    \"\"\"Remove all consecutive groups of 3 or more balls repeatedly.\"\"\"\n    changed = True\n    while changed:\n        changed = False\n        i = 0\n        n = len(board)\n        while i < n:\n            j = i\n            while j < n and board[j] == board[i]:\n                j += 1\n            if j - i >= 3:\n                board = board[:i] + board[j:]\n                changed = True\n                break\n            i = j\n    return board\n\nclass Solution:\n    def findMinStep(self, board: str, hand: str) -> int:\n        hand_count = collections.Counter(hand)\n\n        @lru_cache(maxsize=None)\n        def dfs(curr_board: str, hand_tuple: tuple) -> int:\n            if not curr_board:\n                return 0\n            hand_dict = dict(zip(hand_tuple[::2], hand_tuple[1::2]))\n            memo_key = (curr_board, tuple(sorted(hand_dict.items())))\n            res = float('inf')\n\n            # Try inserting each ball at every possible position\n            for i in range(len(curr_board) + 1):\n                for color, cnt in hand_dict.items():\n                    if cnt == 0:\n                        continue\n                    new_board = curr_board[:i] + color + curr_board[i:]\n                    collapsed = collapse(new_board)\n                    new_hand_dict = hand_dict.copy()\n                    new_hand_dict[color] -= 1\n                    sub = dfs(collapsed, tuple(sorted(new_hand_dict.items())))\n                    if sub != float('inf'):\n                        res = min(res, sub + 1)\n            return res\n\n        # Start DFS with initial board and hand counts\n        initial_hand_tuple = tuple(sorted(hand_count.items()))\n        ans = dfs(board, initial_hand_tuple)\n        return ans if ans != float('inf') else -1\n\ndef parse_input(data: str):\n    \"\"\"Parse input which may be in format:\n       board = \"WRRBBW\", hand = \"RB\"\n    or just two whitespace separated strings.\"\"\"\n    board = hand = None\n    # Try regex extraction\n    import re\n    m_board = re.search(r'board\\s*=\\s*\"([^\"]*)\"', data)\n    m_hand = re.search(r'hand\\s*=\\s*\"([^\"]*)\"', data)\n    if m_board and m_hand:\n        board = m_board.group(1)\n        hand = m_hand.group(1)\n    else:\n        parts = data.strip().split()\n        if len(parts) >= 2:\n            board, hand = parts[0], parts[1]\n    return board, hand\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    if not raw_input.strip():\n        sys.exit()\n    board_str, hand_str = parse_input(raw_input)\n    sol = Solution()\n    result = sol.findMinStep(board_str, hand_str)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for solving the Zuma problem: minimal insertions to clear board using hand. Essentially known problem: Zuma Game, Leetcode 488. We need to produce pseudo code. The user wants step-by-step algorithm. We can outline recursive DFS with memoization, using counts of hand, board string. We'll produce virtual code lines with arrow. Use Start, End, Decision. Provide explanation after each line. The code must be pseudo. We'll structure:\n\nStart\n→ Step: 初始化 handCount map of color to count\n→ Step: 定義遞歸函式 dfs(board, handCount) -> min steps or INF\n→ Step: if board empty return 0\n→ Decision: if hand empty return INF\n→ Step: 將 board 轉換成 string key, handCount 轉成 string key for memo\n→ Decision: if memo contains key -> return memo value\n→ Step: initialize minStep = INF\n→ For each position i from 0 to len(board)\n→ Step: try inserting each color in hand with count>0\n→ Step: simulate insertion at i, then collapse chain\n→ Step: call dfs(newBoard, newHandCount) recursively\n→ Step: update minStep if result+1 < minStep\n→ After loop, memoize key with minStep\n→ Return minStep\n→ End of function\n\nThen after main: call dfs(board, handCount) -> ans, if ans INF -> -1 else ans\nReturn ans\nEnd\n\nWe need to include pseudo collapse procedure: repeatedly remove groups of >=3 same color adjacent. We can implement collapse by while loop. In pseudo we can have a function collapse(board) returns new board after all removals.\n\nWill produce each line as \"虛擬碼步驟 // 解釋\". Use arrow. Use Decision. We'll not output actual code. We'll keep each line short.\n\nLet's craft. Use Start and End at top-level. Use \"Step 1:\" etc.\n\nWe must ensure each line has \"虛擬碼步驟\" plus space then comment.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 handCount map (R,Y,B,G,W) → 0 // 讀取手牌並統計各色球數量  \n→ Decision: 如果 board 為空串? // 檢查是否已經勝利  \n  Yes → Step 2: 返回 0 // 無需插入任何球即可清空  \n  No  → Step 3: 定義遞歸函式 dfs(board, handCount) → minSteps // 從此處開始搜尋最少插入數  \n   → Function dfs  \n    → Step 4: 若 board 為空串 → 返回 0 // 清空成功  \n    → Decision: 若 handCount 全為 0? // 沒有球可插  \n      Yes → Step 5: 返回 INF // 無法完成  \n      No  → Step 6: 將 board 與 handCount 轉為 keyStr // 用於記憶化  \n      → Decision: 若 memo 已存 keyStr? // 檢查是否已計算  \n        Yes → Step 7: 返回 memo[keyStr] // 直接取得結果  \n        No  → Step 8: 設 minStep = INF // 初始化最小步數  \n       → For i from 0 to len(board) // 逐位置嘗試插入  \n        → For each color c with handCount[c] > 0 // 嘗試每種顏色  \n         → Step 9: newHand = handCount, newHand[c] -= 1 // 消耗一顆球  \n         → Step 10: newBoard = insert_at(board, i, c) // 在位置 i 插入顏色 c  \n         → Step 11: collapsed = collapse(newBoard) // 連鎖消除直到無法再消除  \n         → Step 12: result = dfs(collapsed, newHand) // 递归求解剩余情况  \n         → Decision: 若 result ≠ INF? // 成功路徑  \n           Yes → Step 13: minStep = min(minStep, result + 1) // 加上本次插入  \n         → End of inner loops  \n       → memo[keyStr] = minStep // 記錄結果  \n       → Step 14: 返回 minStep // 回傳當前最小步數  \n    → End Function dfs  \n→ Step 15: ans = dfs(board, handCount) // 呼叫遞歸求解  \n→ Decision: 若 ans == INF? // 無法清空  \n  Yes → Step 16: 返回 -1 // 返回失敗指示  \n  No  → Step 17: 返回 ans // 返回最小插入數  \nEnd // 程式執行結束"
    },
    {
      "title": "Roman to Integer",
      "source_file": "Leetcode/leetcode13.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 2,
          "input": "Input: s = \"MCMXCIV\"",
          "expected_output": "Output: 1994",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'Output:1994'\nGot (Norm):      '1994'\n--- (Raw) ---\nRaw Expected: 'Output: 1994'\nRaw Got:      '1994'"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef roman_to_int(s: str) -> int:\n    \"\"\"將羅馬數字字串轉換為整數。\"\"\"\n    roman_map = {\n        'I': 1, 'V': 5, 'X': 10, 'L': 50,\n        'C': 100, 'D': 500, 'M': 1000\n    }\n    total = 0\n    prev_value = 0\n    # 由右往左遍歷，便於處理減法規則\n    for ch in reversed(s):\n        value = roman_map[ch]\n        if value < prev_value:\n            total -= value\n        else:\n            total += value\n        prev_value = value\n    return total\n\ndef main() -> None:\n    \"\"\"從標準輸入讀取羅馬數字，輸出其整數值。\"\"\"\n    data = sys.stdin.read()\n    # 從輸入中抓取第一個被雙引號包住的羅馬數字字串\n    match = re.search(r'\"([IVXLCDM]+)\"', data)\n    if not match:\n        # 若找不到符合格式，直接結束\n        return\n    roman_str = match.group(1)\n    result = roman_to_int(roman_str)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step for converting Roman numeral string to integer. Provide each line with explanation, following the required format. Use arrows, decision blocks, etc. Let's produce algorithm: iterate through string, mapping values, check next char for subtractive pairs. Pseudocode:\n\nStart\n→ Step 1: Define map of roman symbols to values\n→ Step 2: Initialize total = 0, i = 0\n→ Decision: while i < length of string? // loop condition\n    Yes → Step 3: current = value of char at i\n    → Decision: i+1 < length and current < value of char at i+1? // subtractive?\n        Yes → Step 4: total += (value at i+1 - current); i += 2\n        No  → Step 5: total += current; i += 1\n    No → End loop\n→ End // return total\n\nMake sure to include decisions etc. Provide explanation each line.\n\nLet's output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義符號對應值表 // 建立 I→1, V→5, X→10, L→50, C→100, D→500, M→1000  \n→ Step 2: 初始化 total = 0, i = 0 // 用於累加結果與指向目前字符的指標  \n→ Decision: i < len(roman) ? // 是否還有字符未處理？  \n    Yes → Step 3: current = value_of(roman[i]) // 取得目前字符的數值  \n    → Decision: i+1 < len(roman) AND current < value_of(roman[i+1]) ? // 是否為可減法組合？  \n        Yes → Step 4: total += (value_of(roman[i+1]) - current) // 計算減法結果  \n        → Step 4a: i += 2 // 跳過兩個字符  \n        No  → Step 5: total += current // 直接累加  \n        → Step 5a: i += 1 // 前進一個字符  \n    No → End // 迴圈結束  \n→ End // 程式執行結束，total 為轉換後的整數結果"
    },
    {
      "title": "K^th Smallest Element in a Sorted Matrix",
      "source_file": "Leetcode/leetcode378.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8",
          "expected_output": "13",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp3sgqxsfn.py\", line 59, in <module>\n    matrix, k = parse_input(raw_data)\n                ^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp3sgqxsfn.py\", line 42, in parse_input\n    matrix = ast.literal_eval(matrix_match.group(1))\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[1,5,9]\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "matrix = [[-5]], k = 1",
          "expected_output": "-5",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp6xxh75mv.py\", line 59, in <module>\n    matrix, k = parse_input(raw_data)\n                ^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp6xxh75mv.py\", line 42, in parse_input\n    matrix = ast.literal_eval(matrix_match.group(1))\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[-5]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport re\n\ndef kth_smallest(matrix, k):\n    \"\"\"\n    使用二分搜尋「值」來找第 k 小的元素。\n    只用常數額外空間，時間複雜度為 O(n log(max-min))。\n    \"\"\"\n    n = len(matrix)\n    # 搜尋範圍的下界與上界\n    low = matrix[0][0]\n    high = matrix[-1][-1]\n\n    while low < high:\n        mid = (low + high) // 2\n        # 計算 ≤ mid 的元素個數\n        count = 0\n        # 由右下角開始往左掃描，這樣能一次排除整行\n        j = n - 1\n        for i in range(n):\n            while j >= 0 and matrix[i][j] > mid:\n                j -= 1\n            count += j + 1   # 這一行中前 j+1 個元素 ≤ mid\n\n        if count >= k:\n            high = mid\n        else:\n            low = mid + 1\n\n    return low\n\ndef parse_input(data):\n    \"\"\"\n    從標準輸入讀取 matrix 與 k。\n    支援形如 'matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8' 的文字。\n    \"\"\"\n    # 優先用正則表達式抓取\n    matrix_match = re.search(r'matrix\\s*=\\s*(\\[[^\\]]+\\])', data)\n    k_match = re.search(r'k\\s*=\\s*(-?\\d+)', data)\n    if matrix_match and k_match:\n        matrix = ast.literal_eval(matrix_match.group(1))\n        k = int(k_match.group(1))\n        return matrix, k\n\n    # 如果正則失敗，嘗試以換行分隔的方式\n    lines = data.strip().splitlines()\n    if len(lines) >= 2:\n        matrix = ast.literal_eval(lines[0].strip())\n        k = int(lines[1].strip())\n        return matrix, k\n\n    raise ValueError(\"無法解析輸入\")\n\nif __name__ == \"__main__\":\n    raw_data = sys.stdin.read()\n    if not raw_data.strip():\n        sys.exit()\n    matrix, k = parse_input(raw_data)\n    result = kth_smallest(matrix, k)\n    print(result)",
      "virtual_code": "Thinking...\nWe need produce virtual code for algorithm: find k-th smallest in sorted matrix n x n, each row and column sorted ascending. Classic problem: use binary search on value range (min to max) and count <= mid. Complexity O(n log (max-min)). Memory O(1). We'll produce virtual code steps: Start, get min and max from matrix, binary search loop, count <= mid, adjust low/high, when low == high output low. We'll produce each step with explanation. Ensure to follow format: each line: \"虛擬碼步驟 // 解釋/說明\". Use arrow and decision. Let's craft.\n\nWe'll include variable names: low, high, mid, count, etc. Use decision for loop condition, etc.\n\nWe'll produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: low ← matrix[0][0] // 初始化搜尋範圍下界為矩陣最小值\n→ Step 2: high ← matrix[n-1][n-1] // 初始化搜尋範圍上界為矩陣最大值\n→ Decision: 是否 low < high? // 判斷是否還有搜尋空間\n    Yes → Step 3: mid ← (low + high) / 2 // 計算中間值作為候選值\n    → Step 4: count ← 0 // 初始化計數器，記錄小於等於 mid 的元素數量\n    → Step 5: for i ← 0 to n-1 do // 逐行遍歷矩陣\n        → Decision: i < n? // 確保索引在合法範圍\n            Yes → Step 6: j ← n-1 // 從最右列開始往左掃描\n            → Decision: j ≥ 0 and matrix[i][j] > mid? // 若元素大於 mid，需往左移動\n                Yes → Step 7: j ← j - 1 // 向左移動一列\n                No  → Step 8: count ← count + (j + 1) // 這一行中前 j+1 個元素 <= mid，累加計數\n            No  → // 已完成本行遍歷，返回上一層\n        No  → // 所有行已處理完畢\n    → Decision: count ≥ k? // 判斷小於等於 mid 的數量是否足以包含第 k 小\n        Yes → Step 9: high ← mid // 若數量足夠，縮小上界\n        No  → Step 10: low ← mid + 1 // 若數量不足，縮小下界\n→ Decision: 是否 low < high? // 重新檢查搜尋範圍是否收斂\n    Yes → 回到 Step 3\n    No  → Step 11: result ← low // 搜尋完成，low 即為第 k 小的數字\nEnd // 程式執行結束，輸出結果 result"
    },
    {
      "title": "Kth Largest Element in a Stream",
      "source_file": "Leetcode/leetcode703.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"KthLargest\", \"add\", \"add\", \"add\", \"add\", \"add\"], [[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]",
          "expected_output": "[null, 4, 5, 5, 8, 8]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpze73b7u6.py\", line 58, in <module>\n    outputs.append(kth.add(arg))\n                   ^^^^^^^^^^^^\n  File \"/tmp/tmpze73b7u6.py\", line 19, in add\n    heapq.heappush(self.min_heap, val)  # insert new element\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nTypeError: '<' not supported between instances of 'list' and 'int'"
        },
        {
          "example_index": 1,
          "input": "[\"KthLargest\", \"add\", \"add\", \"add\", \"add\"], [[4, [7, 7, 7, 7, 8, 3]], [2], [10], [9], [9]]",
          "expected_output": "[null, 7, 7, 7, 8]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmphi7gtepr.py\", line 58, in <module>\n    outputs.append(kth.add(arg))\n                   ^^^^^^^^^^^^\n  File \"/tmp/tmphi7gtepr.py\", line 19, in add\n    heapq.heappush(self.min_heap, val)  # insert new element\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nTypeError: '<' not supported between instances of 'list' and 'int'"
        }
      ],
      "generated_code": "import sys\nimport heapq\nimport ast\n\nclass KthLargest:\n    \"\"\"\n    Maintains the k-th largest element in a stream of numbers.\n    \"\"\"\n    def __init__(self, k, nums):\n        self.k = k\n        self.min_heap = []          # min-heap to keep the largest k elements\n        for num in nums:\n            self.add(num)           # initialise heap with existing numbers\n\n    def add(self, val):\n        \"\"\"\n        Adds a new value to the stream and returns the current k-th largest.\n        \"\"\"\n        heapq.heappush(self.min_heap, val)  # insert new element\n        if len(self.min_heap) > self.k:      # keep heap size at most k\n            heapq.heappop(self.min_heap)    # remove smallest (k+1-th largest)\n        return self.min_heap[0]             # smallest in heap is k-th largest\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # Handle input that may be on one line or two lines\n    if '\\n' in data:\n        ops_str, args_str = data.splitlines()\n    else:\n        # Find the split between the two top-level lists\n        bracket_level = 0\n        split_index = None\n        for i, ch in enumerate(data):\n            if ch == '[':\n                bracket_level += 1\n            elif ch == ']':\n                bracket_level -= 1\n                if bracket_level == 0:\n                    split_index = i\n                    break\n        ops_str = data[:split_index + 1]\n        # Skip the comma and any whitespace after the first list\n        args_str = data[split_index + 2:].lstrip()\n\n    ops = ast.literal_eval(ops_str)\n    args = ast.literal_eval(args_str)\n\n    # Initialize the KthLargest object\n    first_k, first_nums = args[0]\n    kth = KthLargest(first_k, first_nums)\n\n    outputs = [None]  # constructor returns null\n    for op, arg in zip(ops[1:], args[1:]):\n        if op == 'add':\n            outputs.append(kth.add(arg))\n\n    print(outputs)",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code steps for class KthLargest that maintains kth largest. Essentially use min-heap of size k. Steps: Initialize heap with first k elements, then add remaining. add function push val to heap, if heap size > k pop smallest, return heap.peek.\n\nWe need to produce line by line pseudo-code with explanation. Format: each line \"虛擬碼步驟 // 解釋\". Use arrow symbols. Need to include Start, End. Provide decision points maybe for add: if heap size < k then push.\n\nWe'll produce code steps for constructor and add. We'll represent heap as min-heap.\n\nLet's produce.\n\nAlso include decision: if initial nums length > k: push first k, then add rest.\n\nBut pseudo-code can be simpler.\n\nLet's output.\n\nUse \"Start\" at beginning of constructor.\n\nWe'll present two sections: class initialization, add method.\n\nOk.\n...done thinking.\n\nStart // 建立 KthLargest 物件，設定 k 與初始分數流\n→ Step 1: 設定 變數 k ← input k // 存放要追蹤的第 k 高分\n→ Step 2: 建立 空的最小堆 Heap // 用於維持目前最小的 k 個分數\n→ Decision: nums 長度 ≤ k? // 決定初始堆是否已滿\n    Yes → Step 3: 對 nums 中每個分數 v: \n                → Step 3a: 將 v 插入 Heap // 直接加入，堆大小 ≤ k\n            End // 完成\n    No  → Step 4: 對 nums 的前 k 個分數 v: \n                → Step 4a: 將 v 插入 Heap // 填滿堆\n            → Step 5: 對 nums 後續的每個分數 v: \n                → Decision: v > Heap.peek()? // v 是否比目前最小分數大\n                    Yes → Step 5a: 將 v 插入 Heap // 加入堆\n                        → Step 5b: 從 Heap 刪除最小元素 // 讓堆保持 k 大小\n                    No  → Step 5c: 跳過 v // 不影響前 k 大分數\n            End // 完成\n\nEnd // 建構完成，準備接收新分數\n\nStart // add 方法，加入新分數並回傳目前第 k 高分\n→ Step 6: 將 val 插入 Heap // 新分數進入堆\n→ Decision: Heap.size > k? // 檢查堆是否超過 k\n    Yes → Step 7: 從 Heap 刪除最小元素 // 保持堆大小為 k\n    No  → Step 8: 什麼也不做 // 堆還未滿，保持所有分數\n→ Step 9: 回傳 Heap.peek() // Heap.peek() 為目前第 k 高分\nEnd // add 方法結束\n\nEnd // KthLargest 類別實作完成"
    },
    {
      "title": "Implement Rand10() Using Rand7()",
      "source_file": "Leetcode/leetcode470.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 1",
          "expected_output": "[2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2]'\nGot (Norm):      '[3]'\n--- (Raw) ---\nRaw Expected: '[2]'\nRaw Got:      '[3]'"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[2,8]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,8]'\nGot (Norm):      '[1,5]'\n--- (Raw) ---\nRaw Expected: '[2,8]'\nRaw Got:      '[1, 5]'"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "[3,8,10]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,8,10]'\nGot (Norm):      '[10,2,9]'\n--- (Raw) ---\nRaw Expected: '[3,8,10]'\nRaw Got:      '[10, 2, 9]'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport random\n\n# 模擬 API rand7()，實際測試環境會提供真實實作\ndef rand7() -> int:\n    \"\"\"產生均勻分佈的 1~7 隨機整數\"\"\"\n    return random.randint(1, 7)\n\nclass Solution:\n    def rand10(self) -> int:\n        \"\"\"\n        使用 rand7() 產生 1~10 的均勻隨機整數。\n        兩次 rand7() 組合成 1~49，若小於等於 40 則映射到 1~10，\n        其餘情況重試。\n        \"\"\"\n        while True:\n            # 兩次 rand7() 組合得到 1~49 的均勻分布\n            num = (rand7() - 1) * 7 + rand7()\n            if num <= 40:\n                # 映射到 1~10\n                return 1 + (num - 1) % 10\n\ndef main() -> None:\n    \"\"\"\n    主程式：\n    1. 讀取標準輸入，格式類似 'n = 3'。\n    2. 解析出 n。\n    3. 呼叫 Solution.rand10() n 次，收集結果。\n    4. 將結果以列表形式輸出。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析 'n = X' 的 X\n    match = re.search(r'n\\s*=\\s*(\\d+)', data)\n    if not match:\n        return\n\n    n = int(match.group(1))\n    solution = Solution()\n    results = [solution.rand10() for _ in range(n)]\n    print(results)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, line by line, with arrow and explanation. The requirement: We have rand7() API generating uniform 1-7. Need to implement rand10() using only rand7() and no other random functions.\n\nWe can use classic approach: generate 1-49 via two rand7 calls, map 1-40 to 1-10 (by modulo). If result > 40, discard and repeat. So steps: function rand10(); generate r = (rand7()-1)*7 + rand7() => uniform 1-49; if r <=40 then return (r-1)%10 + 1; else loop again.\n\nAlso need to handle possible recursion/loop. Provide virtual code lines.\n\nLet's craft virtual code:\n\nStart\n→ Step 1: Define function rand10()\n→ Step 2: Repeat\n→ Step 3:    r ← (rand7() - 1) * 7 + rand7() // combine two rand7 to get 1-49\n→ Step 4:    If r ≤ 40 then\n→ Step 5:        Return (r - 1) mod 10 + 1 // map to 1-10\n→ Step 6:    End If\n→ End Repeat\nEnd\n\nBut we need to format: Start, End, Decision, etc. Use arrow syntax.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 定義函式 rand10() // 建立產生 1-10 的函式\n→ Step 2: 開始迴圈 // 若產生失敗則重試\n→ Step 3:    r ← (rand7() - 1) * 7 + rand7() // 兩次 rand7 合併得到 1-49\n→ Step 4:    Decision: r ≤ 40? // 檢查是否在可映射範圍內\n→ Step 5:        Yes → Step 6: return (r - 1) mod 10 + 1 // 成功映射 1-10\n→ Step 6:        No  → Step 3: // 失敗則回到 Step 3 重新產生\n→ End // 程式執行結束\n\nBut we need to ensure proper numbering and not misalign. Also the \"Decision:\" line and then Yes/No branches need to align.\n\nWe can also express that Step 6 return; End loop.\n\nLet's produce final virtual code lines with explanation. Ensure we don't use actual code.\n\nI'll produce lines:\n\nStart // 程式開始執行\n→ Step 1: 定義函式 rand10() // 建立 rand10 函式\n→ Step 2: 循環開始 // 若結果不符合則重試\n→ Step 3:    r ← (rand7() - 1) * 7 + rand7() // 兩次 rand7 合併產生 1~49\n→ Step 4:    Decision: r ≤ 40? // 判斷是否在可接受範圍\n→ Step 5:        Yes → Step 6: return (r - 1) mod 10 + 1 // 成功時返回 1~10\n→ Step 6:        No  → Step 3: // 失敗則重複 Step 3 產生新值\n→ End // 程式執行結束\n\nBut Step numbers may conflict: Step 6 used twice. Use unique names: Step 5 is return, Step 6 is loop again.\n\nLet's adjust:\n\nStart // 程式開始執行\n→ Step 1: 定義函式 rand10() // 建立 rand10 函式\n→ Step 2: 循環開始 // 若結果不符合則重試\n→ Step 3:    r ← (rand7() - 1) * 7 + rand7() // 兩次 rand7 合併產生 1~49\n→ Step 4:    Decision: r ≤ 40? // 判斷是否在可接受範圍\n→ Step 5:        Yes → Step 6: return (r - 1) mod 10 + 1 // 成功時返回 1~10\n→ Step 6:        No  → Step 3: // 失敗則重複 Step 3 產生新值\n→ End // 程式執行結束\n\nThis is okay. Provide as answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義函式 rand10() // 建立 rand10 函式  \n→ Step 2: 循環開始 // 若結果不符合則重試  \n→ Step 3:    r ← (rand7() - 1) * 7 + rand7() // 兩次 rand7 合併產生 1~49  \n→ Step 4:    Decision: r ≤ 40? // 判斷是否在可接受範圍  \n→ Step 5:        Yes → Step 6: return (r - 1) mod 10 + 1 // 成功時返回 1~10  \n→ Step 6:        No  → Step 3: // 失敗則重複 Step 3 產生新值  \nEnd // 程式執行結束"
    },
    {
      "title": "Summary Ranges",
      "source_file": "Leetcode/leetcode228.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [0,1,2,4,5,7]",
          "expected_output": "[\"0->2\",\"4->5\",\"7\"]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp5ti2k56d.py\", line 26, in <module>\n    data = sys.stdin.read()\n           ^^^\nNameError: name 'sys' is not defined. Did you forget to import 'sys'?"
        },
        {
          "example_index": 1,
          "input": "nums = [0,2,3,4,6,8,9]",
          "expected_output": "[\"0\",\"2->4\",\"6\",\"8->9\"]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpeizrdw4e.py\", line 26, in <module>\n    data = sys.stdin.read()\n           ^^^\nNameError: name 'sys' is not defined. Did you forget to import 'sys'?"
        }
      ],
      "generated_code": "import re\nimport json\n\nclass Solution:\n    def summaryRanges(self, nums):\n        if not nums:\n            return []\n        res = []\n        start = end = nums[0]\n        for n in nums[1:]:\n            if n == end + 1:\n                end = n\n            else:\n                if start == end:\n                    res.append(str(start))\n                else:\n                    res.append(f\"{start}->{end}\")\n                start = end = n\n        if start == end:\n            res.append(str(start))\n        else:\n            res.append(f\"{start}->{end}\")\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    # Extract all integers from the input, regardless of formatting\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    sol = Solution()\n    result = sol.summaryRanges(nums)\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to produce a virtual code for the algorithm that given a sorted unique integer array nums returns ranges as strings. Classic \"summary ranges\". We need to produce step-by-step virtual code lines with explanation after each line. Use Start, End, Decision, etc. Each line: \"虛擬碼步驟 // 解釋\". Use arrow \"→\". Must not output actual code. Just pseudocode with arrows.\n\nLet's craft algorithm: Start; Initialize list result; if nums empty return empty; set start=nums[0], prev=nums[0]; iterate i from 1 to length-1: if nums[i] == prev+1 then continue (range continues); else close previous range: if start==prev -> append string of start else append start->prev; set start=nums[i]; prev=nums[i]; after loop, close last range similarly; End.\n\nWe should produce line-by-line steps.\n\nWe need to ensure each step includes explanation. Use \"Step\" numbers.\n\nLet's produce:\n\nStart\n→ Step 1: 初始化 result 為空列表 // 準備儲存範圍\n→ Decision: nums 是否為空? // 檢查輸入是否為空陣列\n    Yes → Step 2: 輸出 result // 空陣列對應空結果\n    No  → Step 3: 設定 start = nums[0], prev = nums[0] // 初始化第一個數\n→ Step 4: 從 i = 1 到 nums.length-1 逐個檢查 // 逐元素遍歷陣列\n    → Decision: nums[i] 是否等於 prev + 1? // 判斷是否連續\n        Yes → Step 5: 將 prev 更新為 nums[i] // 連續，延長範圍\n        No  → Step 6: 將前一段範圍加入 result // 關閉非連續段\n            → Decision: start == prev? // 判斷是單個還是區間\n                Yes → Step 7: result.append(start) // 單個數\n                No  → Step 8: result.append(start + \"->\" + prev) // 範圍\n            → Step 9: 設定 start = nums[i], prev = nums[i] // 開始新範圍\n    → Step 10: 更新 prev = nums[i] // 在連續時更新 prev\n→ Step 11: 迴圈結束後，將最後一段加入 result // 確保最後範圍被加入\n    → Decision: start == prev? // 判斷最後段是否單個\n        Yes → Step 12: result.append(start) // 單個數\n        No  → Step 13: result.append(start + \"->\" + prev) // 範圍\n→ End // 程式結束，返回 result\n\nBut we need to follow format: \"虛擬碼步驟 // 解釋\". Use arrow arrow as above. Each line \"→\". Use \"Decision:\" lines with indentation. Must use \"Yes →\" and \"No →\". Also each line includes explanation after comment.\n\nLet's write properly.\n\nAlso we need to mention return result. So final step before End is \"Return result\".\n\nBetter: \"→ Step 14: Return result // 返回最終範圍列表\".\n\nWe also need to mention that after step 5 we still update prev. But step 5 already sets prev. So okay.\n\nBut we need to ensure line numbering is consistent? Not required but helpful.\n\nAlso we must include Start and End lines. Use \"Start // 程式開始執行\". \"End // 程式執行結束\".\n\nNow produce final output.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 result 為空列表 // 準備儲存所有範圍  \n→ Decision: nums 是否為空? // 檢查輸入是否為空陣列  \n Yes → Step 2: 返回 result // 空陣列對應空結果  \n No  → Step 3: 設定 start = nums[0], prev = nums[0] // 初始化第一個數值  \n→ Step 4: 從 i = 1 到 nums.length-1 逐個檢查 // 逐元素遍歷陣列  \n → Decision: nums[i] 是否等於 prev + 1? // 判斷是否連續  \n  Yes → Step 5: 將 prev 更新為 nums[i] // 連續，延長當前範圍  \n  No  → Step 6: 將前一段範圍加入 result // 關閉非連續段  \n    → Decision: start == prev? // 判斷是單個還是區間  \n     Yes → Step 7: result.append(start) // 單個數  \n     No  → Step 8: result.append(start + \"->\" + prev) // 範圍  \n    → Step 9: 設定 start = nums[i], prev = nums[i] // 開始新範圍  \n → Step 10: 更新 prev = nums[i] // 確保 prev 為當前數值  \n→ Step 11: 迴圈結束後，將最後一段加入 result // 確保最後範圍被加入  \n → Decision: start == prev? // 判斷最後段是否單個  \n  Yes → Step 12: result.append(start) // 單個數  \n  No  → Step 13: result.append(start + \"->\" + prev) // 範圍  \n→ Step 14: 返回 result // 程式輸出所有範圍  \nEnd // 程式執行結束"
    },
    {
      "title": "Expression Add Operators",
      "source_file": "Leetcode/leetcode282.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "num = \"123\", target = 6",
          "expected_output": "[\"1*2*3\",\"1+2+3\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"1*2*3\",\"1+2+3\"]'\nGot (Norm):      '[\"1+2+3\",\"1*2*3\"]'\n--- (Raw) ---\nRaw Expected: '[\"1*2*3\",\"1+2+3\"]'\nRaw Got:      '[\"1+2+3\", \"1*2*3\"]'"
        },
        {
          "example_index": 1,
          "input": "num = \"232\", target = 8",
          "expected_output": "[\"2*3+2\",\"2+3*2\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"2*3+2\",\"2+3*2\"]'\nGot (Norm):      '[\"2+3*2\",\"2*3+2\"]'\n--- (Raw) ---\nRaw Expected: '[\"2*3+2\",\"2+3*2\"]'\nRaw Got:      '[\"2+3*2\", \"2*3+2\"]'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport json\n\nclass Solution:\n    def addOperators(self, num, target):\n        res = []\n\n        def backtrack(index, path, value, last):\n            if index == len(num):\n                if value == target:\n                    res.append(path)\n                return\n\n            for i in range(index + 1, len(num) + 1):\n                temp = num[index:i]\n                if len(temp) > 1 and temp[0] == '0':\n                    continue\n                curr = int(temp)\n                if index == 0:\n                    backtrack(i, temp, curr, curr)\n                else:\n                    backtrack(i, path + '+' + temp, value + curr, curr)\n                    backtrack(i, path + '-' + temp, value - curr, -curr)\n                    backtrack(i, path + '*' + temp, value - last + last * curr, last * curr)\n\n        backtrack(0, '', 0, 0)\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    num_match = re.search(r'num\\s*=\\s*\"([^\"]+)\"', data)\n    target_match = re.search(r'target\\s*=\\s*(-?\\d+)', data)\n    if not num_match or not target_match:\n        sys.exit(\"Invalid input format\")\n    num = num_match.group(1)\n    target = int(target_match.group(1))\n\n    solution = Solution()\n    result = solution.addOperators(num, target)\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm: expression add operators to match target. Use DFS recursion building expression and evaluating. We need steps with decisions etc. We must produce \"逐行\" lines with \"虛擬碼步驟\" and comment. Use arrow, Decision, Start, End. Provide each line. Should be comprehensive but not too long. We must produce steps but not actual code. Provide structure: Start, Step to initialize result list, Step: call DFS with position 0, current expression \"\", current value 0, previous operand 0. Then DFS function: if pos == len(num) then check current value == target -> add expression. Else loop over i from pos+1 to len: substring num[pos:i] as currStr. If currStr has leading zero and length >1 skip. Convert to int currNum. If pos==0: call DFS(i, currStr, currNum, currNum). Else: addition path: DFS(i, expr+'+'+currStr, curVal+currNum, currNum). Subtraction path: DFS(i, expr+'-'+currStr, curVal-currNum, -currNum). Multiplication path: DFS(i, expr+'*'+currStr, curVal - prev + prev*currNum, prev*currNum). Need to explain each. Provide steps. Use arrows to indicate call flow. Use Decision lines for loops and conditions. Provide comments. Use virtual arrow →. Ensure each line has a space after the virtual code then comment. Use brackets? The format is: \"虛擬碼步驟 // 解釋\". So just write like \"Start // 程式開始執行\". Then \"→ Step 1: ...\" etc. Use Decision: ... Yes→ ... No→ ... Indentation perhaps with spaces? The example uses indent 4 spaces. We can mimic.\n\nWe need to produce all steps. Let's craft.\n\nImportant: The algorithm recursion may be defined as function. We may treat Step 1: 定義遞迴函式 DFS. Then call. Provide decisions inside recursion: if pos==len(num). Then loop etc. Provide Decision lines for skip leading zero. Provide for each operator.\n\nLet's produce step lines:\n\nStart\n→ Step 1: 定義結果列表 results = [] // 儲存符合目標的表達式\n→ Step 2: 定義遞迴函式 DFS(pos, expr, curVal, prevNum) // pos:目前索引，expr:累積表達式，curVal:目前已計算值，prevNum:前一個操作數（用於乘法）\n    → Decision: pos == len(num)? // 是否已遍歷完整字串\n        Yes → Decision: curVal == target? // 計算結果是否等於目標\n            Yes → Step 3: results.append(expr) // 把符合條件的表達式加入結果\n            No → Step 4: // 無操作，返回\n        No  → Decision: for i in range(pos+1, len(num)+1)? // 遍歷剩餘子串作為下一個操作數\n            // 這裡使用迴圈，虛擬碼可寫為 Decision: i <= len(num)?  Yes→...\nBut we need step lines, not pseudo-code loops. Maybe we can express loop as a Step \"Decision: for i from pos+1 to len(num)\"? But we need each line with arrow. We can break into lines: \"→ Decision: i in range(pos+1, len(num)+1)?\" with Yes/No? That might be messy.\n\nAlternatively, we can write a Step \"→ Step 5: 取子串 currStr = num[pos:i]\" inside loop. But loops need representation.\n\nLet's adopt simpler: Use Step for loop header and inside. Use Decision for loop condition. Example: \"→ Decision: i <= len(num)?\". But we can treat loop as sequence of decisions: start i = pos+1; then Decision: i <= len(num)?; Yes → Step 5: ... ; increment i; return to Decision. Provide indentation.\n\nThis may produce many lines. But it's okay.\n\nLet's design.\n\nStart\n→ Step 1: results = [] // 初始化結果列表\n→ Step 2: 定義遞迴 DFS(pos, expr, curVal, prevNum) // pos:索引, expr:累積表達式, curVal:目前計算值, prevNum:前一個操作數（乘法用）\n    → Decision: pos == len(num)? // 已到字串尾\n        Yes → Decision: curVal == target?\n            Yes → Step 3: results.append(expr) // 表達式符合目標\n            No  → Step 4: // 什麼都不做，結束此路徑\n        No  → // 需要探索下一個子操作數\n            → Step 5: i = pos + 1 // 設定子串起始位置\n            → Decision: i <= len(num)? // 是否還有子串可取\n                Yes → Step 6: currStr = num[pos:i] // 取得子串\n                → Decision: currStr has leading zero and len>1? // 檢查是否為非法前導零\n                    Yes → Step 7: i = i + 1 // 跳過此子串，繼續迴圈\n                    No  → Step 8: currNum = int(currStr) // 轉成整數\n                        → Decision: pos == 0? // 第一個子串\n                            Yes → Step 9: DFS(i, currStr, currNum, currNum) // 直接使用\n                            No  → // 進行 +, -, *\n                                → Step 10: DFS(i, expr + '+' + currStr, curVal + currNum, currNum) // 加法\n                                → Step 11: DFS(i, expr + '-' + currStr, curVal - currNum, -currNum) // 減法\n                                → Step 12: DFS(i, expr + '*' + currStr, curVal - prevNum + prevNum * currNum, prevNum * currNum) // 乘法\n                → Step 13: i = i + 1 // 迴圈結束後增 i\n                → Back to Decision: i <= len(num)?\n    // End of DFS\n→ Step 14: DFS(0, '', 0, 0) // 開始遞迴\n→ Step 15: return results // 回傳所有符合的表達式\nEnd // 程式結束\n\nWe need to make sure each line includes code + comment. Use arrow for flow: \"→\". Indent using spaces maybe 4. Use Decision: with Yes→/No→ lines. Must include \"→\" at start of each line? The example: \"Start\", \"→ Step 1\". So we should start each line with \"→\" except Start and End. So for each line we put \"→\".\n\nThus:\n\nStart // 程式開始執行\n→ Step 1: results = [] // 初始化結果列表\n→ Step 2: 定義遞迴函式 DFS(pos, expr, curVal, prevNum) // pos: 索引, expr: 累積表達式, curVal: 當前計算值, prevNum: 前一操作數（乘法用）\n    → Decision: pos == len(num)? // 是否已遍歷完整字串\n        Yes → Decision: curVal == target?\n            Yes → Step 3: results.append(expr) // 表達式符合目標，加入結果\n            No  → Step 4: // 什麼也不做，結束此路徑\n        No  → // 需要探索下一個子操作數\n            → Step 5: i = pos + 1 // 設定子串起始位置\n            → Decision: i <= len(num)? // 仍有子串可取\n                Yes → Step 6: currStr = num[pos:i] // 取得子串\n                → Decision: currStr has leading zero and len>1? // 檢查前導零\n                    Yes → Step 7: i = i + 1 // 跳過非法子串，繼續迴圈\n                    No  → Step 8: currNum = int(currStr) // 轉成整數\n                        → Decision: pos == 0?\n                            Yes → Step 9: DFS(i, currStr, currNum, currNum) // 第一個子串直接使用\n                            No  → // 進行 +, -, *\n                                → Step 10: DFS(i, expr + '+' + currStr, curVal + currNum, currNum) // 加法\n                                → Step 11: DFS(i, expr + '-' + currStr, curVal - currNum, -currNum) // 減法\n                                → Step 12: DFS(i, expr + '*' + currStr, curVal - prevNum + prevNum * currNum, prevNum * currNum) // 乘法\n                → Step 13: i = i + 1 // 迴圈結束後遞增\n                → Back to Decision: i <= len(num)?\n    // End of DFS\n→ Step 14: DFS(0, '', 0, 0) // 開始遞迴\n→ Step 15: return results // 回傳所有符合的表達式\nEnd // 程式執行結束\n\nWe need to maintain indent for Decision lines? Example uses indent. We'll use 4 spaces before Decision lines inside. And the lines with arrows inside may also have arrow.\n\nHowever, the \"→\" arrow is before each line. For nested lines, we might still put arrow. Example:\n\n→ Decision: pos == len(num)? //...\n    Yes → Decision: curVal == target?\n\nThus we include arrow before Yes line too.\n\nThus we need to produce final output lines.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: results = [] // 初始化結果列表，存放所有符合目標的表達式\n→ Step 2: 定義遞迴函式 DFS(pos, expr, curVal, prevNum) // pos：目前索引；expr：已構造的表達式；curVal：目前已計算的數值；prevNum：上一個操作數（用於處理乘法優先級）\n    → Decision: pos == len(num)? // 已遍歷完字串\n        Yes → Decision: curVal == target?\n            Yes → Step 3: results.append(expr) // 表達式等於目標，加入結果\n            No  → Step 4: // 不符合目標，結束此路徑\n        No  → // 仍有字元可處理，進行下一個子操作數的選擇\n            → Step 5: i = pos + 1 // 設定子串起始位置\n            → Decision: i <= len(num)? // 是否還有子串可取\n                Yes → Step 6: currStr = num[pos:i] // 取得子串\n                → Decision: currStr has leading zero and len>1? // 檢查是否為非法前導零\n                    Yes → Step 7: i = i + 1 // 跳過此非法子串，繼續迴圈\n                    No  → Step 8: currNum = int(currStr) // 轉成整數\n                        → Decision: pos == 0? // 是否為第一個子串\n                            Yes → Step 9: DFS(i, currStr, currNum, currNum) // 第一個子串直接使用，更新 expr、curVal、prevNum\n                            No  → // 非第一個子串，需考慮三種運算符\n                                → Step 10: DFS(i, expr + '+' + currStr, curVal + currNum, currNum) // 加法\n                                → Step 11: DFS(i, expr + '-' + currStr, curVal - currNum, -currNum) // 減法\n                                → Step 12: DFS(i, expr + '*' + currStr, curVal - prevNum + prevNum * currNum, prevNum * currNum) // 乘法（考慮優先級）\n                → Step 13: i = i + 1 // 子串選擇結束後遞增 i\n                → Back to Decision: i <= len(num)? // 回到迴圈判斷\n    // End of DFS 定義\n→ Step 14: DFS(0, '', 0, 0) // 以起始位置 0、空表達式、初始值 0、prevNum 0 開始遞迴\n→ Step 15: return results // 回傳所有符合目標的表達式列表\nEnd // 程式執行結束"
    },
    {
      "title": "Time Based Key-Value Store",
      "source_file": "Leetcode/leetcode981.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"TimeMap\", \"set\", \"get\", \"get\", \"set\", \"get\", \"get\"], [[], [\"foo\", \"bar\", 1], [\"foo\", 1], [\"foo\", 3], [\"foo\", \"bar2\", 4], [\"foo\", 4], [\"foo\", 5]]",
          "expected_output": "[null, null, \"bar\", \"bar\", null, \"bar2\", \"bar2\"]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp9bh03je_.py\", line 35, in <module>\n    args_list = ast.literal_eval(parts[1])\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import defaultdict\nimport bisect\n\nclass TimeMap:\n    def __init__(self):\n        self.store = defaultdict(list)\n\n    def set(self, key, value, timestamp):\n        self.store[key].append((timestamp, value))\n\n    def get(self, key, timestamp):\n        if key not in self.store:\n            return \"\"\n        arr = self.store[key]\n        # 找到最小的索引 i 使得 arr[i][0] > timestamp\n        i = bisect.bisect_right(arr, (timestamp, chr(127)))\n        if i == 0:\n            return \"\"\n        return arr[i - 1][1]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 提取兩個列表：方法名和對應參數\n    parts = re.findall(r'\\[.*?\\]', data, re.S)\n    if len(parts) < 2:\n        sys.exit()\n\n    methods = ast.literal_eval(parts[0])\n    args_list = ast.literal_eval(parts[1])\n\n    tm = None\n    results = []\n\n    for method, args in zip(methods, args_list):\n        if method == \"TimeMap\":\n            tm = TimeMap()\n            results.append(None)\n        elif method == \"set\":\n            tm.set(*args)\n            results.append(None)\n        elif method == \"get\":\n            res = tm.get(*args)\n            results.append(res)\n        else:\n            results.append(None)\n\n    # 將結果轉成類似 LeetCode 的字串輸出\n    formatted = '[' + ', '.join('null' if v is None else f'\"{v}\"' for v in results) + ']'\n    print(formatted)",
      "virtual_code": "Thinking...\nWe need to output virtual code lines with explanation. Need to design TimeMap with set and get. Use dictionary mapping key to list of (timestamp,value) sorted. For get use binary search.\n\nWe produce step-by-step algorithm, not actual code, but pseudo. Use arrow. Let's produce lines:\n\nStart\n→ Step 1: 定義 TimeMap 類別 // 建立資料結構\n→ Step 2: 初始化內部字典 key_to_timestamps // 存儲每個 key 的時間戳列表\n→ Decision: 是否需要 set 邏輯? // ...\nThen define set method: Step 3: 接收 key,value,timestamp // ...\nStep 4: 若 key 未存在，新增空列表 // ...\nStep 5: 將 (timestamp,value) 附加到 key 對應的列表 // ...\nStep 6: 確保列表按時間戳升序 // 由於只按遞增 timestamp 調用 set，故不需排序\n\nDefine get method: Step 7: 接收 key, timestamp // ...\nStep 8: 若 key 不存在，返回空字符串 // ...\nStep 9: 取得 timestamps 列表 // ...\nStep 10: 進行二分搜尋，尋找最大小於等於 timestamp 的索引 // ...\nStep 11: 若找到索引，返回該索引的 value // ...\nStep 12: 否則返回空字符串 // ...\n\nEnd\n\nBut need to use Decision structure for binary search. Provide steps for binary search. We can create Decision: If low <= high? etc.\n\nAlso we should include comment for each line.\n\nLet's output with format: \"虛擬碼步驟 // 解釋\". Use arrow. Example: \"Start // 程式開始\". We'll use \"→\" to denote next line.\n\nWe'll start with \"Start\" line. Then \"→ TimeMap() // 初始化 TimeMap 類別\". But \"TimeMap()\" is a constructor. We'll break into steps. Let's produce.\n\nWe'll produce:\n\nStart // 程式開始\n→ Define Class TimeMap // 建立類別\n→ Step: Initialize dictionary key_to_values // 用於存儲 key → list[(timestamp, value)]\n\nDefine set method:\n→ Define set(key, value, timestamp) // 定義 set 函式\n→ Decision: key 是否已存在 in key_to_values? // 檢查 key 是否已有資料\n    Yes → Step: Append (timestamp, value) to key's list // 直接加入\n    No  → Step: 建立新列表並加入 (timestamp, value) // 初始化並加入\n\nDefine get method:\n→ Define get(key, timestamp) // 定義 get 函式\n→ Decision: key 是否存在? // 檢查 key\n    Yes → Step: 取 key 對應列表 // list = key_to_values[key]\n    No  → Step: 返回 \"\" // 沒有資料\n→ Decision: list 是否為空? // 檢查\n    Yes → Step: 返回 \"\" // 無資料\n    No  → Step: 進行二分搜尋 // 尋找最大 <= timestamp\n        → Step: low = 0, high = len(list)-1, result = -1 // 初始化\n        → Decision: low <= high? // 二分條件\n            Yes → Step: mid = (low+high)//2 // 計算中點\n            → Decision: list[mid].timestamp <= timestamp? // 判斷\n                Yes → Step: result = mid; low = mid+1 // 更新結果並往右移\n                No  → Step: high = mid-1 // 往左移\n            No  → Step: 終止二分\n        → Decision: result != -1? // 是否找到\n            Yes → Step: 返回 list[result].value // 回傳對應值\n            No  → Step: 返回 \"\" // 無符合時間戳\n\nEnd // 程式結束\n\nWe need to keep each line a single step. We used decisions with sub-steps indent. We must ensure each line has \"虛擬碼步驟 // 解釋\".\n\nWe need to use \"Yes →\" and \"No →\" lines. Each sub-step also has \"→\" or \"Yes →\". We'll keep format consistent.\n\nLet's craft final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Define Class TimeMap // 建立 TimeMap 類別\n→ Step: Initialize dictionary key_to_values // 用於存儲 key → list[(timestamp, value)]\n\n→ Define set(key, value, timestamp) // 定義 set 方法\n→ Decision: key 是否已存在 in key_to_values? // 檢查 key 是否已有資料\n    Yes → Step: Append (timestamp, value) to key's list // 直接加入\n    No  → Step: 建立新列表並加入 (timestamp, value) // 初始化並加入\n\n→ Define get(key, timestamp) // 定義 get 方法\n→ Decision: key 是否存在? // 檢查 key 是否存在\n    Yes → Step: list = key_to_values[key] // 取出對應的時間戳列表\n    No  → Step: Return \"\" // 若 key 不存在，直接回傳空字串\n→ Decision: list 是否為空? // 檢查列表是否為空\n    Yes → Step: Return \"\" // 無資料時回傳空字串\n    No  → Step: 開始二分搜尋 // 尋找最大 ≤ timestamp 的索引\n        → Step: low = 0, high = len(list)-1, result = -1 // 初始化變數\n        → Decision: low <= high? // 二分條件\n            Yes → Step: mid = (low + high) // 2 // 計算中點\n            → Decision: list[mid].timestamp <= timestamp? // 判斷是否符合時間\n                Yes → Step: result = mid; low = mid + 1 // 更新結果並往右搜尋\n                No  → Step: high = mid - 1 // 往左搜尋\n            No  → Step: 終止二分搜尋 // low > high 時結束循環\n        → Decision: result != -1? // 是否找到符合條件的索引\n            Yes → Step: Return list[result].value // 回傳對應的值\n            No  → Step: Return \"\" // 沒有符合條件時回傳空字串\n\nEnd // 程式執行結束\n```"
    },
    {
      "title": "Evaluate Division",
      "source_file": "Leetcode/leetcode399.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]",
          "expected_output": "[6.00000,0.50000,-1.00000,1.00000,-1.00000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp2fli13t4.py\", line 49, in <module>\n    ans = solution.calcEquation(equations, values, queries)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp2fli13t4.py\", line 9, in calcEquation\n    graph[a][b] = val\n    ~~~~~^^^\nTypeError: unhashable type: 'list'"
        },
        {
          "example_index": 1,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1.5,2.5,5.0], queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]",
          "expected_output": "[3.75000,0.40000,5.00000,0.20000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp_pciv_us.py\", line 49, in <module>\n    ans = solution.calcEquation(equations, values, queries)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp_pciv_us.py\", line 8, in calcEquation\n    for (a, b), val in zip(equations, values):\n        ^^^^^^\nValueError: too many values to unpack (expected 2)"
        },
        {
          "example_index": 2,
          "input": "equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]",
          "expected_output": "[0.50000,2.00000,-1.00000,-1.00000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpk_gqd9it.py\", line 49, in <module>\n    ans = solution.calcEquation(equations, values, queries)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpk_gqd9it.py\", line 8, in calcEquation\n    for (a, b), val in zip(equations, values):\n        ^^^^^^\nValueError: not enough values to unpack (expected 2, got 1)"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def calcEquation(self, equations, values, queries):\n        graph = defaultdict(dict)\n        for (a, b), val in zip(equations, values):\n            graph[a][b] = val\n            graph[b][a] = 1 / val\n\n        def dfs(src, dst, visited):\n            if src not in graph or dst not in graph:\n                return -1.0\n            if src == dst:\n                return 1.0\n            visited.add(src)\n            for neighbor, weight in graph[src].items():\n                if neighbor not in visited:\n                    res = dfs(neighbor, dst, visited)\n                    if res != -1.0:\n                        return weight * res\n            return -1.0\n\n        results = []\n        for u, v in queries:\n            results.append(dfs(u, v, set()))\n        return results\n\nif __name__ == \"__main__\":\n    # 讀取輸入，去除可能的外層單引號或雙引號\n    raw = sys.stdin.read().strip()\n    raw = raw.strip(\"'\\\"\")\n\n    # 將輸入分解成三個部分：equations、values、queries\n    try:\n        eq_part, rest = raw.split('values =', 1)\n        equations_str = eq_part.split('equations =', 1)[1].strip()\n        values_str, queries_str = rest.split('queries =', 1)\n    except ValueError:\n        # 若輸入格式不符合預期，直接終止\n        sys.exit(0)\n\n    equations = ast.literal_eval(equations_str)\n    values = ast.literal_eval(values_str)\n    queries = ast.literal_eval(queries_str)\n\n    solution = Solution()\n    ans = solution.calcEquation(equations, values, queries)\n\n    # 格式化輸出，保留五位小數\n    output = '[' + ','.join(f'{x:.5f}' for x in ans) + ']'\n    print(output)",
      "virtual_code": "Thinking...\nWe need to produce virtual code that solves division equations and queries, basically like LeetCode 399. Use graph with weights. We need to generate step-by-step algorithm. We'll produce Start, build graph, process queries with DFS or union find. We'll include explanation after each line. Use decision arrows. Provide each line with explanation.\n\nWe need to output in Chinese Traditional. Let's do it. We'll use virtual steps like:\n\nStart\n→ Step 1: 建立無向圖，將每個變量作為節點 // create adjacency list\n→ Step 2: 對於每個等式 Ai / Bi = val，添加邊 Ai -> Bi weight val，Bi -> Ai weight 1/val // add edges\n\nThen for queries:\n→ Step 3: For每個查詢 (C, D) 進行DFS尋找路徑 // search path\n    → Decision: 如果C或D不在圖中? // undefined variables\n        Yes → Step 4: 將結果設為 -1.0 // no answer\n        No → Step 5: 初始化 visited set // for DFS\n            → Step 6: 執行 DFS(C, D, product) // recursively multiply weights\n            → Decision: DFS 找到路徑? // found?\n                Yes → Step 7: 將 product 存入答案 // found product\n                No  → Step 8: 將答案設為 -1.0 // no path\n\nFinally End.\n\nLet's produce each line with explanation. Use arrow syntax. Use decisions. We'll make sure each line includes explanation after //. Provide Chinese explanation. Let's produce final.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 建立空的鄰接表 graph // 用來存放變量之間的比值關係\n→ Step 2: 對每個等式 Ai / Bi = val，執行\n    → Step 2.1: graph[Ai].append((Bi, val)) // Ai 到 Bi 的權重為 val\n    → Step 2.2: graph[Bi].append((Ai, 1/val)) // Bi 到 Ai 的權重為 1/val\n→ Step 3: 初始化答案列表 answers = [] // 用來收集所有查詢的結果\n→ Step 4: 對於每個查詢 (C, D)，執行\n    → Decision: C 或 D 不在 graph 中?\n        Yes → Step 5: answers.append(-1.0) // 變量未定義，無法計算\n        No  → Step 6: 建立空集合 visited = set() // 記錄已訪問節點\n            → Step 7: 執行 DFS 搜尋函式 dfs(node, target, prod)\n                → Step 7.1: 如果 node == target，返回 prod // 找到路徑，返回累積乘積\n                → Step 7.2: 將 node 加入 visited\n                → Step 7.3: 對於每個鄰接 (nbr, weight) 於 graph[node]\n                    → Decision: nbr 未被訪問？\n                        Yes → Step 7.3.1: result = dfs(nbr, target, prod * weight)\n                        → Decision: result 不是 None？\n                            Yes → Step 7.3.2: 返回 result // 成功找到路徑，傳回值\n                            No  → Step 7.3.3: 繼續搜尋下一個鄰接\n                → Step 7.4: 返回 None // 所有鄰接都失敗，路徑不存在\n            → Decision: dfs(C, D, 1.0) 是否返回非 None？\n                Yes → Step 8: answers.append(returned_value) // 存入計算結果\n                No  → Step 9: answers.append(-1.0) // 沒有路徑，無法計算\n→ Step 10: Return answers // 將所有查詢的答案輸出\nEnd // 程式執行結束\n```"
    },
    {
      "title": "Course Schedule II",
      "source_file": "Leetcode/leetcode210.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]",
          "expected_output": "[0,2,1,3]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[0,2,1,3]'\nGot (Norm):      '[0,1,2,3]'\n--- (Raw) ---\nRaw Expected: '[0,2,1,3]'\nRaw Got:      '[0, 1, 2, 3]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import deque\n\nclass Solution:\n    def findOrder(self, numCourses, prerequisites):\n        # 建立鄰接表與入度陣列\n        graph = [[] for _ in range(numCourses)]\n        indegree = [0] * numCourses\n\n        # 填入圖形與入度\n        for dest, src in prerequisites:\n            graph[src].append(dest)\n            indegree[dest] += 1\n\n        # 取所有入度為 0 的節點入列\n        queue = deque([i for i in range(numCourses) if indegree[i] == 0])\n        order = []\n\n        # Kahn 演算法\n        while queue:\n            node = queue.popleft()\n            order.append(node)\n            for neighbor in graph[node]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    queue.append(neighbor)\n\n        # 若能排完所有課程，回傳順序；否則回傳空列表\n        return order if len(order) == numCourses else []\n\ndef parse_input(input_str):\n    \"\"\"\n    解析輸入字串，例如：\n        'numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]'\n    回傳 (numCourses, prerequisites_list)\n    \"\"\"\n    # 取出 numCourses\n    num_courses_part = input_str.split('numCourses')[1].split(',')[0]\n    num_courses = int(num_courses_part.split('=')[1].strip())\n\n    # 取出 prerequisites\n    prereq_part = input_str.split('prerequisites')[1].strip()\n    # 可能有多個逗號，先去除前後空白\n    if prereq_part.startswith('='):\n        prereq_part = prereq_part[1:].strip()\n    prerequisites = ast.literal_eval(prereq_part)\n\n    return num_courses, prerequisites\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        print([])\n        sys.exit(0)\n\n    numCourses, prerequisites = parse_input(raw_input)\n\n    solution = Solution()\n    order = solution.findOrder(numCourses, prerequisites)\n    print(order)",
      "virtual_code": "Thinking...\nWe need to output virtual code steps for solving course schedule II problem (topological sort). We need to use steps: Start, build graph, indegree array, queue, result, loop, etc. Provide explanation each line. Use arrow and decision. Should not output real code. Use virtual code steps. Let's produce a step-by-step flow. Ensure each line has \"虛擬碼步驟\" followed by space then \"// 解釋\". Use arrow. Let's craft.\n\nWe must produce only the virtual code. Ok.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化鄰接表 graph[0…numCourses-1] 為空列表 // 用來存每門課的後續課程  \n→ Step 2: 初始化 indegree[0…numCourses-1] 為 0 // 用來記錄每門課的前置課程數  \n→ Step 3: 遍歷 prerequisites  \n  → For each pair [a, b]:  \n    → Add a 到 graph[b] 的鄰接表 // 表示 b 必須先學，之後才能學 a  \n    → indegree[a]++ // a 的前置課程數加一  \n→ Step 4: 建立一個 queue  \n  → For i from 0 to numCourses-1:  \n    → If indegree[i] == 0, queue.push(i) // 無前置課程的課先放入隊列  \n→ Step 5: 建立空列表 result // 存放最終課程順序  \n→ Decision: queue 是否為空? // 判斷是否還有可學的課程  \n  Yes → Step 6: pop cur from queue // 取出一門可學課程  \n    → result.append(cur) // 加入結果順序  \n    → For each neighbor in graph[cur]: // 對 cur 的後續課程  \n      → indegree[neighbor]-- // 減少前置課程數  \n      → If indegree[neighbor] == 0, queue.push(neighbor) // 若已無前置課程，加入隊列  \n    → 回到 Step 5 判斷 queue 是否為空  \n  No → Step 7: Decision: result.length == numCourses? // 檢查是否已安排所有課程  \n    Yes → Return result // 成功得到一個合法順序  \n    No → Return [] // 有環路，無法完成所有課程  \nEnd // 程式執行結束"
    },
    {
      "title": "Generate Random Point in a Circle",
      "source_file": "Leetcode/leetcode478.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]",
          "expected_output": "[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[-0.02493,-0.38077],[0.82314,0.38945],[0.36572,0.17248]]'\nGot (Norm):      '[None,[0.09345130249216525,-0.15688390090482116],[-0.32923760896702164,0.8101642849967265],[-0.07340030200775742,-0.8346922364595623]]'\n--- (Raw) ---\nRaw Expected: '[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]'\nRaw Got:      '[None, [0.09345130249216525, -0.15688390090482116], [-0.32923760896702164, 0.8101642849967265], [-0.07340030200775742, -0.8346922364595623]]'"
        }
      ],
      "generated_code": "import sys\nimport math\nimport random\nimport ast\n\nclass Solution:\n    def __init__(self, radius, x_center, y_center):\n        # 儲存圓的半徑與中心座標\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n\n    def randPoint(self):\n        # 產生均勻分布的隨機點\n        r = self.radius * math.sqrt(random.random())          # 產生半徑\n        theta = random.uniform(0, 2 * math.pi)                 # 產生角度\n        x = self.x_center + r * math.cos(theta)                # 計算 x 座標\n        y = self.y_center + r * math.sin(theta)                # 計算 y 座標\n        return [x, y]                                          # 回傳點\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        sys.exit()\n    ops = ast.literal_eval(data[0].strip())                   # 讀取操作列表\n    args_list = ast.literal_eval(data[1].strip())             # 讀取對應參數列表\n\n    obj = None\n    results = []\n\n    for op, args in zip(ops, args_list):\n        if op == \"Solution\":\n            obj = Solution(*args)\n            results.append(None)                              # 建構子回傳 None\n        elif op == \"randPoint\":\n            results.append(obj.randPoint())                   # 執行 randPoint\n        else:\n            # 如有其他方法可在此處擴充\n            results.append(None)\n\n    print(results)",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for algorithm. Steps: start, store radius, center, then randPoint: generate random radius sqrt(rand)*radius, random angle uniform 0 to 2π, compute x = x_center + r*cos(theta), y = y_center + r*sin(theta). Return [x, y]. Need to use decision maybe none. Just flow. Provide lines with arrow and comments. Ensure each line ends with comment after space. Use Start, End, Decision. No decision needed. Just simple steps. Provide virtual code.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 儲存 radius, x_center, y_center // 於建構子中記錄圓的半徑與中心座標\n→ Step 2: 定義函式 randPoint() // 建立產生隨機點的功能\n    → Step 2.1: 產生 uniform 隨機數 u ∈ [0,1) // 隨機數用於計算半徑\n    → Step 2.2: 計算 r = radius * sqrt(u) // 取得符合均勻分布的半徑\n    → Step 2.3: 產生 uniform 隨機角 θ ∈ [0, 2π) // 隨機角度\n    → Step 2.4: 計算 x = x_center + r * cos(θ) // 根據半徑與角度算出 x 座標\n    → Step 2.5: 計算 y = y_center + r * sin(θ) // 根據半徑與角度算出 y 座標\n    → Step 2.6: 回傳 [x, y] // 返回隨機點\nEnd // 程式執行結束"
    },
    {
      "title": "Remove Element",
      "source_file": "Leetcode/leetcode27.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "nums = [0,1,2,2,3,0,4,2], val = 2",
          "expected_output": "5, nums = [0,1,4,0,3,_,_,_]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '5,nums=[0,1,4,0,3,_,_,_]'\nGot (Norm):      '5,nums=[0,1,3,0,4,_,_,_]'\n--- (Raw) ---\nRaw Expected: '5, nums = [0,1,4,0,3,_,_,_]'\nRaw Got:      '5, nums = [0,1,3,0,4,_,_,_]'"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef remove_element(nums, val):\n    \"\"\"\n    Remove all occurrences of val from nums in-place.\n    Return the number of elements not equal to val.\n    \"\"\"\n    slow = 0\n    for fast in range(len(nums)):\n        if nums[fast] != val:\n            nums[slow] = nums[fast]\n            slow += 1\n    return slow\n\ndef parse_input(data):\n    \"\"\"\n    Parse input of the form:\n        nums = [a,b,c], val = d\n    and return the list of ints and the val.\n    \"\"\"\n    # Extract nums list\n    nums_match = re.search(r'nums\\s*=\\s*\\[([^\\]]*)\\]', data)\n    if not nums_match:\n        raise ValueError(\"Input does not contain nums\")\n    nums_str = nums_match.group(1)\n    nums = [int(x) for x in nums_str.split(',') if x.strip()]\n\n    # Extract val\n    val_match = re.search(r'val\\s*=\\s*([-]?\\d+)', data)\n    if not val_match:\n        raise ValueError(\"Input does not contain val\")\n    val = int(val_match.group(1))\n\n    return nums, val\n\nif __name__ == \"__main__\":\n    raw_data = sys.stdin.read().strip()\n    if not raw_data:\n        sys.exit(0)\n\n    nums, val = parse_input(raw_data)\n    k = remove_element(nums, val)\n\n    # Build output representation\n    parts = [str(x) for x in nums[:k]] + ['_' for _ in range(len(nums) - k)]\n    output = f\"{k}, nums = [{','.join(parts)}]\"\n    print(output)",
      "virtual_code": "Thinking...\nWe need to produce pseudo code steps for algorithm to remove elements in-place, return count k. Use Start, End, Decision arrows, etc. Each line: \"虛擬碼步驟 // 解釋\". No real code. Should be structured.\n\nWe need step-by-step: Start, initialize pointer, iterate, etc. Use decisions: if current element equals val, skip, else place at pointer, increment. Return pointer.\n\nWe need to maintain order may be changed, but can keep order.\n\nLet's produce steps:\n\nStart\n→ Step 1: 初始化 index = 0 // 指向未填充位置\n→ Step 2: 遍歷 i 從 0 到 nums.length-1 // 逐個檢查元素\n    → Decision: nums[i] == val? // 判斷是否為要移除的值\n        Yes → Step 3: 跳過該元素 // 不執行任何操作\n        No → Step 4: 將 nums[index] = nums[i] // 保存非 val 元素\n              → Step 5: index = index + 1 // 移動指標\n→ End // 結束遍歷\n→ Step 6: 返回 index // index 為 k，剩餘元素不重要\n\nAlso include maybe note that we may also use two-pointer method.\n\nMake sure to use the format: \"虛擬碼步驟 // 解釋\".\n\nLet's output each line.\n\nProbably need to include Start and End lines.\n\nAlso maybe mention sort in judge but not in algorithm.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 index = 0 // 指向即將填入非 val 元素的第一個位置  \n→ Step 2: 遍歷 i 從 0 到 nums.length-1 // 逐一檢查陣列中的每個元素  \n    → Decision: nums[i] == val? // 判斷目前元素是否是要移除的值  \n        Yes → Step 3: 跳過該元素 // 若是 val，直接不做任何操作  \n        No  → Step 4: 將 nums[index] = nums[i] // 把非 val 元素放到 index 位置  \n              → Step 5: index = index + 1 // index 前移，準備填寫下一個非 val 元素  \n→ End // 完成遍歷，所有非 val 元素已聚集在陣列前部  \n→ Step 6: 返回 index // index 即為 k，代表前 k 個元素均不等於 val，後面元素可忽略  \nEnd // 程式執行結束"
    },
    {
      "title": "Shuffle an Array",
      "source_file": "Leetcode/leetcode384.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"], [[[1, 2, 3]], [], [], []]",
          "expected_output": "[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[3,1,2],[1,2,3],[1,3,2]]'\nGot (Norm):      '[null,[3,2,1],[1,2,3],[3,2,1]]'\n--- (Raw) ---\nRaw Expected: '[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]'\nRaw Got:      '[null, [3, 2, 1], [1, 2, 3], [3, 2, 1]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport ast\n\nclass Solution:\n    \"\"\"\n    這個類別用來儲存原始陣列並提供重設與隨機洗牌的功能。\n    \"\"\"\n    def __init__(self, nums):\n        # 原始陣列的深複製，避免外部修改影響內部資料\n        self._original = list(nums)\n\n    def reset(self):\n        \"\"\"\n        把陣列重設回原始順序，並回傳重設後的陣列。\n        \"\"\"\n        return list(self._original)\n\n    def shuffle(self):\n        \"\"\"\n        使用 Fisher‑Yates 洗牌演算法隨機打亂陣列，\n        回傳打亂後的新陣列。\n        \"\"\"\n        shuffled = list(self._original)\n        n = len(shuffled)\n        for i in range(n - 1, 0, -1):\n            j = random.randint(0, i)\n            shuffled[i], shuffled[j] = shuffled[j], shuffled[i]\n        return shuffled\n\n\ndef parse_input(input_str: str):\n    \"\"\"\n    將類似 LeetCode 的輸入字串轉成兩個列表：\n    1. 方法名稱列表\n    2. 參數列表\n    \"\"\"\n    # 找出第一個結束方括號的位置（外層第一個列表的結束）\n    bracket_depth = 0\n    end_index = None\n    for i, ch in enumerate(input_str):\n        if ch == '[':\n            bracket_depth += 1\n        elif ch == ']':\n            bracket_depth -= 1\n            if bracket_depth == 0:\n                end_index = i\n                break\n    if end_index is None:\n        raise ValueError(\"Invalid input format\")\n    first_part = input_str[:end_index + 1]\n    second_part = input_str[end_index + 1 :].strip()\n    # 刪除可能在分隔處的逗號\n    if second_part.startswith(','):\n        second_part = second_part[1:]\n    # 用 ast.literal_eval 轉成 Python 物件\n    methods = ast.literal_eval(first_part)\n    args = ast.literal_eval(second_part)\n    return methods, args\n\n\ndef main():\n    \"\"\"\n    主程式，從標準輸入讀取資料，執行相對應的方法，\n    並將結果以 JSON 格式輸出。\n    \"\"\"\n    input_data = sys.stdin.read().strip()\n    if not input_data:\n        return\n    methods, args_list = parse_input(input_data)\n\n    obj = None\n    results = []\n    for method, args in zip(methods, args_list):\n        if method == \"Solution\":\n            obj = Solution(args[0])\n            results.append(None)\n        elif method == \"reset\":\n            results.append(obj.reset())\n        elif method == \"shuffle\":\n            results.append(obj.shuffle())\n        else:\n            # 若有其他方法名，直接忽略或可加入錯誤處理\n            results.append(None)\n\n    # 輸出結果，使用 json.dumps 可自動把 None 轉成 null\n    print(json.dumps(results))\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code line by line with explanations, no actual code. Use the arrow format. Provide steps: Start, constructor, store original, etc. Need shuffle using Fisher-Yates. Also reset returns original. Use array copies. Provide explanation. Ensure each line has \"虛擬碼步驟 // 解釋\". Include arrow characters, etc.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: 定義類別 Solution // 創建解決方案類\n→ Step 2: 定義成員變數 originalList // 保存原始陣列\n→ Step 3: 定義成員變數 currentList // 用於儲存目前陣列狀態\n→ Step 4: 定義建構子 Solution(nums) // 接收輸入陣列\n→ Decision: nums 是否為空? // 判斷陣列是否為空\n    Yes → Step 5: originalList ← 空陣列 // 空陣列時直接設定\n    No  → Step 6: originalList ← 深複製 nums // 複製陣列以避免引用問題\n→ Step 7: currentList ← 深複製 originalList // 初始化目前陣列\n→ End // 建構子結束\n→ Step 8: 定義方法 reset() // 重設陣列\n→ Step 9: currentList ← 深複製 originalList // 恢復到原始順序\n→ Step 10: Return currentList // 返回重設後陣列\n→ End // reset 方法結束\n→ Step 11: 定義方法 shuffle() // 隨機打亂陣列\n→ Step 12: For i from currentList.length - 1 down to 1 // Fisher-Yates 循環\n→ Decision: 隨機選擇 j 介於 0 和 i 之間 // 隨機索引\n    Yes → Step 13: 交換 currentList[i] 與 currentList[j] // 交換元素\n→ Step 14: Return currentList // 返回打亂後陣列\n→ End // shuffle 方法結束\nEnd // 程式執行結束\n\nBut must use arrow format like \"→ Step 1:\" etc. Also use Decision and Yes/No. Use indentation. Each line must include \"// 解釋\". Let's output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類別 Solution // 創建解決方案類  \n→ Step 2: 定義成員變數 originalList // 保存原始陣列的拷貝  \n→ Step 3: 定義成員變數 currentList // 用於儲存目前的陣列狀態  \n→ Step 4: 定義建構子 Solution(nums) // 接收輸入陣列  \n  Decision: nums 是否為空? // 判斷輸入陣列是否為空  \n   Yes → Step 5: originalList ← 空陣列 // 空陣列時直接設定為空  \n   No  → Step 6: originalList ← 深複製 nums // 複製輸入陣列以避免引用問題  \n→ Step 7: currentList ← 深複製 originalList // 初始化目前陣列為原始順序  \n→ End // 建構子結束  \n\n→ Step 8: 定義方法 reset() // 重設陣列  \n  Step 9: currentList ← 深複製 originalList // 恢復到原始順序  \n  Step 10: Return currentList // 返回重設後的陣列  \n→ End // reset 方法結束  \n\n→ Step 11: 定義方法 shuffle() // 隨機打亂陣列  \n  For i from currentList.length - 1 down to 1 // Fisher‑Yates 循環  \n   Decision: 隨機選擇 j 介於 0 與 i 之間 // 產生隨機索引  \n    Yes → Step 12: 交換 currentList[i] 與 currentList[j] // 交換元素  \n  Step 13: Return currentList // 返回打亂後的陣列  \n→ End // shuffle 方法結束  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Subsets",
      "source_file": "Leetcode/leetcode78.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nGot (Norm):      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nRaw Got:      '[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def subsets(self, nums):\n        res = []\n\n        def backtrack(start, path):\n            res.append(path[:])          # 收集目前子集\n            for i in range(start, len(nums)):\n                path.append(nums[i])     # 包含 nums[i]\n                backtrack(i + 1, path)   # 進一步遞迴\n                path.pop()               # 回溯\n\n        backtrack(0, [])\n        return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 取得等號右側的列表字串\n    if '=' in data:\n        _, expr = data.split('=', 1)\n    else:\n        expr = data\n    expr = expr.strip()\n\n    try:\n        nums = ast.literal_eval(expr)\n    except Exception:\n        nums = []\n\n    sol = Solution()\n    result = sol.subsets(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for generating all subsets (power set) of a unique-element integer array. We must output line by line, each line has \"虛擬碼步驟 // 解釋/說明\". Use arrow and decision structure.\n\nWe must not output actual code; just pseudo-steps.\n\nWe should include Start, End, Decision: etc.\n\nWe need to show recursion/backtracking or iterative. Choose backtracking.\n\nWe'll write steps like: Start // 程式開始\n\n→ Step 1: 定義函式 GenerateSubsets(nums) // 入口\n\n→ Step 2: 初始化 result 為空清單 // 存所有子集\n\n→ Step 3: 定義遞迴函式 Backtrack(start, current) // 從 start 開始遞迴\n\n→ Decision: 如果 start 等於 nums 長度? // 到達結尾\n\n    Yes → Step 4: 複製 current 並加入 result // 收集子集\n\n    No  → Step 5: // 迭代選取每個元素\n\n        → For i from start to nums長度-1:\n\n            → Decision: If i==start? (no, it's just loop)...\n\nBut we need structure; we can show decision inside loop: include current element then backtrack, then exclude.\n\nSimplify:\n\n→ Step 5: 先將 current 加入 result // 因為子集包含/不包含某個元素\n\n→ Step 6: 如果 start < nums長度? // 還有元素可處理\n\n    Yes → Step 7: 取元素 nums[start] // 選取\n\n    → Step 8: current 加上 nums[start] // 包含\n\n    → Step 9: Backtrack(start+1, current) // 進一步遞迴\n\n    → Step 10: current 移除最後一個元素 // 回溯\n\n    → Step 11: Backtrack(start+1, current) // 不選取\n\n    No  → // nothing\n\nBut better structure: typical backtracking: at each step, add current to result, then for i from start to n-1: push nums[i], backtrack(i+1), pop.\n\nThus we can represent with decisions: For loop; inside loop push/pop.\n\nWe need to use Decision: if start < nums長度? But easier: Use For loop step.\n\nLet's produce as:\n\nStart // 程式開始執行\n\n→ Step 1: 定義 GenerateSubsets(nums) // 主函式入口\n\n→ Step 2: 初始化 result 為空清單 // 儲存所有子集\n\n→ Step 3: 定義遞迴函式 Backtrack(start, current) // 參數: 起始索引、目前子集\n\n→ Decision: 是否已完成? // start 等於 nums 長度?\n\n    Yes → Step 4: 複製 current 並加入 result // 收集子集\n\n    No  → Step 5: // 在此階段將 current 加入 result (子集包含/不包含目前元素)\n\n→ Step 6: 迭代 for i from start to nums長度-1: // 選取未處理的元素\n\n        → Decision: 進行包含處理? // Always true\n\n            Yes → Step 7: current 加上 nums[i] // 包含此元素\n\n            → Step 8: Backtrack(i+1, current) // 進一步遞迴\n\n            → Step 9: current 移除最後一個元素 // 回溯\n\n        No  → // 省略\n\n→ Step 10: End of Backtrack // 回到上一層\n\n→ Step 11: 在 GenerateSubsets 中呼叫 Backtrack(0, 空清單) // 從頭開始\n\n→ Step 12: 回傳 result // 返回所有子集\n\nEnd // 程式結束\n\nBut need to ensure each line has \"虛擬碼步驟\" and comment.\n\nWe must not use actual code syntax; use generic steps.\n\nLet's craft each line:\n\nStart // 程式開始執行\n→ Step 1: 定義 GenerateSubsets(nums) // 主入口函式，傳入唯一元素整數陣列\n→ Step 2: 初始化 result 為空清單 // 用於儲存所有子集\n→ Step 3: 定義遞迴函式 Backtrack(start, current) // start 為目前索引，current 為正在構建的子集\n→ Decision: start 等於 nums 長度? // 判斷是否已處理完所有元素\n    Yes → Step 4: 複製 current 並加入 result // 收集完成的子集\n    No  → Step 5: // 在此階段加入目前子集，無論包含還是排除元素\n        → Step 5.1: 把 current 加入 result // 收集子集（包括此階段的選擇）\n→ Step 6: 迭代 i 從 start 到 nums長度-1 // 對剩餘元素做遍歷\n        → Decision: 處理元素 nums[i]? // 總是進行\n            Yes → Step 6.1: 把 nums[i] 加入 current // 包含此元素\n            → Step 6.2: Backtrack(i+1, current) // 進一步遞迴\n            → Step 6.3: 把 nums[i] 從 current 移除 // 回溯，恢復狀態\n        No  → // 不進行任何操作\n→ Step 7: Backtrack 完成 // 回到上一層\n→ Step 8: 在 GenerateSubsets 呼叫 Backtrack(0, 空清單) // 從頭開始構建子集\n→ Step 9: 回傳 result // 返回所有子集\nEnd // 程式執行結束\n\nBut the structure expects arrow notation: Use \"→\" and \"Yes →\" \"No →\".\n\nWe can indent decisions; but we can produce line by line as:\n\nStart // 程式開始執行\n→ Step 1: 定義 GenerateSubsets(nums) // 主入口函式\n→ Step 2: 初始化 result 為空清單 // 儲存所有子集\n→ Step 3: 定義遞迴函式 Backtrack(start, current) // 參數: 起始索引、目前子集\n→ Decision: start 等於 nums 長度? // 判斷是否已處理完所有元素\n    Yes → Step 4: 複製 current 並加入 result // 收集子集\n    No  → // 進一步處理\n        → Step 5: 把 current 加入 result // 收集目前階段子集\n→ Step 6: 迭代 i 從 start 到 nums長度-1 // 遍歷剩餘元素\n        → Decision: 處理元素 nums[i]? // 總是處理\n            Yes → Step 6.1: 把 nums[i] 加入 current // 包含\n            → Step 6.2: Backtrack(i+1, current) // 進一步遞迴\n            → Step 6.3: 把 nums[i] 從 current 移除 // 回溯\n            No  → // 無操作\n→ Step 7: Backtrack 完成 // 回到上一層\n→ Step 8: 在 GenerateSubsets 呼叫 Backtrack(0, 空清單) // 開始遞迴\n→ Step 9: 回傳 result // 返回所有子集\nEnd // 程式結束\n\nBut we need each line to have \"虛擬碼步驟\" and comment. So lines with decisions can be separate.\n\nLet's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 GenerateSubsets(nums) // 主入口函式，傳入唯一元素整數陣列  \n→ Step 2: 初始化 result 為空清單 // 用於儲存所有子集  \n→ Step 3: 定義遞迴函式 Backtrack(start, current) // start 為目前索引，current 為正在構建的子集  \n→ Decision: start 等於 nums 長度? // 判斷是否已處理完所有元素  \n    Yes → Step 4: 複製 current 並加入 result // 收集完成的子集  \n    No  → // 進一步處理  \n        → Step 5: 把 current 加入 result // 收集目前階段子集（不必選取任何額外元素）  \n→ Step 6: 迭代 i 從 start 到 nums長度-1 // 對剩餘元素做遍歷  \n        → Decision: 處理元素 nums[i]? // 總是處理  \n            Yes → Step 6.1: 把 nums[i] 加入 current // 包含此元素  \n            → Step 6.2: Backtrack(i+1, current) // 進一步遞迴  \n            → Step 6.3: 把 nums[i] 從 current 移除 // 回溯，恢復原狀  \n            No  → // 無操作  \n→ Step 7: Backtrack 完成 // 回到上一層  \n→ Step 8: 在 GenerateSubsets 呼叫 Backtrack(0, 空清單) // 從頭開始構建子集  \n→ Step 9: 回傳 result // 返回所有子集  \nEnd // 程式結束"
    },
    {
      "title": "Reconstruct Original Digits from English",
      "source_file": "Leetcode/leetcode423.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"owoztneoer\"",
          "expected_output": "\"012\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '012'\nGot (Norm):      '0127'\n--- (Raw) ---\nRaw Expected: '\"012\"'\nRaw Got:      '0127'"
        },
        {
          "example_index": 1,
          "input": "s = \"fviefuro\"",
          "expected_output": "\"45\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '45'\nGot (Norm):      '457'\n--- (Raw) ---\nRaw Expected: '\"45\"'\nRaw Got:      '457'"
        }
      ],
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\nclass Solution:\n    def originalDigits(self, s: str) -> str:\n        # Count each letter in the input string\n        count = Counter(s)\n\n        # Determine the quantity of each digit using unique identifiers\n        out = {}\n        out['0'] = count['z']\n        out['2'] = count['w']\n        out['4'] = count['u']\n        out['6'] = count['x']\n        out['8'] = count['g']\n\n        # For the remaining digits, subtract the already identified counts\n        out['3'] = count['h'] - out['8']\n        out['5'] = count['f'] - out['4']\n        out['7'] = count['s'] - out['6']\n        out['1'] = count['o'] - out['0'] - out['2'] - out['4']\n        out['9'] = count['i'] - out['5'] - out['6'] - out['8']\n\n        # Build the result string in ascending order\n        result = ''.join(k * out[k] for k in sorted(out.keys()))\n        return result\n\nif __name__ == \"__main__\":\n    # Read all input from stdin\n    raw_input = sys.stdin.read()\n    # Extract only lowercase letters (the digit words consist of lowercase letters)\n    letters = re.findall(r'[a-z]', raw_input)\n    s = ''.join(letters)\n\n    solution = Solution()\n    print(solution.originalDigits(s))",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for reconstructing digits from scrambled letters of words zero, one, two, three, four, five, six, seven, eight, nine. Standard Leetcode 423. Steps: count letters, determine digits uniquely: zero (z), two (w), four (u), six (x), eight (g), three (h), five (f), seven (s), one (o), nine (i). Output digits sorted ascending.\n\nWe must produce virtual code lines with arrows and decisions.\n\nWe'll produce algorithm steps: Input string s, Count letter frequency, Determine counts for each digit, Build result string by appending digit char repeated count times, Sort? Actually counts produce ascending order directly. Then output.\n\nWe'll produce virtual code in plain text, each line ending with comment.\n\nLet's craft steps:\n\nStart\n→ Step 1: Initialize frequency map freq[26] to 0 // count letters\n→ Step 2: For each char c in s: freq[c - 'a']++ // build freq\n→ Decision: Check for digit 0? // unique letter 'z'\n    Yes → Step 3: countZero = freq['z'-'a'] // count zero\n          freq['z'-'a'] -= countZero\n          // also reduce letters of \"zero\" by countZero times\n→ etc.\n\nBut we need structured representation. We can group decisions. Maybe each digit extraction as steps with decisions? The requirement: use Decision: lines with Yes→, No→. We can decide presence of unique letter >0? Then extract.\n\nSimplify: We can just set counts directly: countZero = freq['z']; freq... But still need decisions.\n\nWe can do:\n\nDecision: freq['z'] > 0? // check if zero exists\n    Yes → Step: countZero = freq['z'] // record\n          freq['z'] = 0\n          freq['e'] -= countZero\n          freq['r'] -= countZero\n          freq['o'] -= countZero\n\nBut we also need to ensure not negative; but typical algorithm.\n\nLet's produce sequential steps for each digit in order: 0,2,4,6,8,3,5,7,1,9.\n\nAt each digit we might decide extraction if count>0. But we can just assign counts directly, no decision needed. But requirement states we should use Decision and arrows. We'll include decision but trivial.\n\nWe should produce virtual code lines.\n\nOk let's craft.\n\nAlso after extraction, build result string:\n\n→ Step: result = \"\"\n→ Decision: countZero>0? // append zeros\n    Yes → Step: result += '0' repeated countZero times\n    No → Step: // nothing\nSimilar for others.\n\nBut we might compress: just for each digit: append char repeated count times.\n\nLet's produce.\n\nLet's write virtual steps:\n\nStart // program starts\n\n→ Step 1: Create array freq[26] all zeros // letter counts\n\n→ Step 2: For each character ch in input string s\n    → Step 2.1: freq[ch - 'a']++ // count\n\n→ Decision: freq['z'] > 0? // check zero\n    Yes → Step 3: countZero = freq['z']\n          // remove letters of \"zero\" countZero times\n          freq['z'] -= countZero\n          freq['e'] -= countZero\n          freq['r'] -= countZero\n          freq['o'] -= countZero\n    No  → Step 3: countZero = 0\n\nSimilarly for others.\n\nBut we might not need to subtract letters for unique ones as they are unique. For others we subtract accordingly.\n\nBut the algorithm subtracts for all digits after extraction.\n\nBut to keep simpler, we can just set counts based on unique letters and then adjust for overlapping.\n\nLet's design steps:\n\nExtract zeros, twos, fours, sixes, eights first.\n\nThen threes, fives, sevens, ones, nines.\n\nAt each extraction, adjust counts.\n\nWe need to maintain freq updates.\n\nOk.\n\nAfter extraction counts, build result.\n\nLet's produce final virtual code.\n\nWe'll produce about maybe 30-40 lines.\n\nLet's write.\n\n...done thinking.\n\n```\nStart // 程式開始執行\n\n→ Step 1: 初始化 freq[26] 為 0 // 用來統計字母頻率\n→ Step 2: 對輸入字串 s 的每個字母 ch\n    → Step 2.1: freq[ch - 'a']++ // 將字母加入頻率表\n\n// ---------- 先處理擁有唯一字母的數字 ----------\n→ Decision: freq['z' - 'a'] > 0? // 是否有 'z'（代表 0）\n    Yes → Step 3: count0 = freq['z' - 'a']\n          // 移除 \"zero\" 的字母\n          freq['z' - 'a'] -= count0\n          freq['e' - 'a'] -= count0\n          freq['r' - 'a'] -= count0\n          freq['o' - 'a'] -= count0\n    No  → Step 3: count0 = 0\n\n→ Decision: freq['w' - 'a'] > 0? // 是否有 'w'（代表 2）\n    Yes → Step 4: count2 = freq['w' - 'a']\n          freq['t' - 'a'] -= count2\n          freq['w' - 'a'] -= count2\n          freq['o' - 'a'] -= count2\n    No  → Step 4: count2 = 0\n\n→ Decision: freq['u' - 'a'] > 0? // 是否有 'u'（代表 4）\n    Yes → Step 5: count4 = freq['u' - 'a']\n          freq['f' - 'a'] -= count4\n          freq['o' - 'a'] -= count4\n          freq['u' - 'a'] -= count4\n          freq['r' - 'a'] -= count4\n    No  → Step 5: count4 = 0\n\n→ Decision: freq['x' - 'a'] > 0? // 是否有 'x'（代表 6）\n    Yes → Step 6: count6 = freq['x' - 'a']\n          freq['s' - 'a'] -= count6\n          freq['i' - 'a'] -= count6\n          freq['x' - 'a'] -= count6\n    No  → Step 6: count6 = 0\n\n→ Decision: freq['g' - 'a'] > 0? // 是否有 'g'（代表 8）\n    Yes → Step 7: count8 = freq['g' - 'a']\n          freq['e' - 'a'] -= count8\n          freq['i' - 'a'] -= count8\n          freq['g' - 'a'] -= count8\n          freq['h' - 'a'] -= count8\n    No  → Step 7: count8 = 0\n\n// ---------- 處理剩餘需要交叉判斷的數字 ----------\n→ Decision: freq['h' - 'a'] > 0? // 'h' 代表 3（剩下的三）\n    Yes → Step 8: count3 = freq['h' - 'a']\n          freq['t' - 'a'] -= count3\n          freq['h' - 'a'] -= count3\n          freq['r' - 'a'] -= count3\n          freq['e' - 'a'] -= count3\n    No  → Step 8: count3 = 0\n\n→ Decision: freq['f' - 'a'] > 0? // 'f' 代表 5（剩下的五）\n    Yes → Step 9: count5 = freq['f' - 'a']\n          freq['f' - 'a'] -= count5\n          freq['i' - 'a'] -= count5\n          freq['v' - 'a'] -= count5\n          freq['e' - 'a'] -= count5\n    No  → Step 9: count5 = 0\n\n→ Decision: freq['s' - 'a'] > 0? // 's' 代表 7（剩下的七）\n    Yes → Step 10: count7 = freq['s' - 'a']\n           freq['s' - 'a'] -= count7\n           freq['e' - 'a'] -= count7\n           freq['v' - 'a'] -= count7\n           freq['e' - 'a'] -= count7\n    No  → Step 10: count7 = 0\n\n→ Decision: freq['o' - 'a'] > 0? // 'o' 代表 1（剩下的零、二、四、八已除）\n    Yes → Step 11: count1 = freq['o' - 'a']\n           freq['o' - 'a'] -= count1\n           freq['n' - 'a'] -= count1\n           freq['e' - 'a'] -= count1\n    No  → Step 11: count1 = 0\n\n→ Decision: freq['i' - 'a'] > 0? // 'i' 代表 9（剩下的五、六、八、三、七已除）\n    Yes → Step 12: count9 = freq['i' - 'a']\n           freq['n' - 'a'] -= count9\n           freq['i' - 'a'] -= count9\n           freq['n' - 'a'] -= count9\n           freq['e' - 'a'] -= count9\n    No  → Step 12: count9 = 0\n\n// ---------- 建構結果字串 ----------\n→ Step 13: result = \"\"\n→ Step 14: 對每個數字 d 從 0 到 9\n    → Step 14.1: 將字符 ('0' + d) 重複 countd 次加入 result\n    // 這裡 countd 代表上述計算得到的對應數字次數\n\n→ End // 程式執行結束，result 即為升序排列的數字字串\n```"
    },
    {
      "title": "LFU Cache",
      "source_file": "Leetcode/leetcode460.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"LFUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"get\", \"put\", \"get\", \"get\", \"get\"], [[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]",
          "expected_output": "[null, null, null, 1, null, -1, 3, null, -1, 3, 4]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp6k5aleyo.py\", line 85, in <module>\n    main()\n  File \"/tmp/tmp6k5aleyo.py\", line 67, in main\n    ops, args = parse_input()\n                ^^^^^^^^^^^^^\n  File \"/tmp/tmp6k5aleyo.py\", line 60, in parse_input\n    args = ast.literal_eval(args_str)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict, OrderedDict\n\nclass LFUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.min_freq = 0\n        self.key_to_val_freq = {}          # key -> (value, freq)\n        self.freq_to_keys = defaultdict(OrderedDict)  # freq -> OrderedDict of keys\n\n    def _update(self, key: int):\n        value, freq = self.key_to_val_freq[key]\n        # Remove key from current freq list\n        del self.freq_to_keys[freq][key]\n        if not self.freq_to_keys[freq]:\n            del self.freq_to_keys[freq]\n            if self.min_freq == freq:\n                self.min_freq += 1\n        # Add key to next freq list\n        self.freq_to_keys[freq + 1][key] = None\n        self.key_to_val_freq[key] = (value, freq + 1)\n\n    def get(self, key: int) -> int:\n        if key not in self.key_to_val_freq:\n            return -1\n        self._update(key)\n        return self.key_to_val_freq[key][0]\n\n    def put(self, key: int, value: int) -> None:\n        if self.capacity == 0:\n            return\n        if key in self.key_to_val_freq:\n            # Update value and freq\n            self.key_to_val_freq[key] = (value, self.key_to_val_freq[key][1])\n            self._update(key)\n            return\n        if len(self.key_to_val_freq) >= self.capacity:\n            # Evict LFU key (LRU within that freq)\n            evict_key, _ = self.freq_to_keys[self.min_freq].popitem(last=False)\n            del self.key_to_val_freq[evict_key]\n            if not self.freq_to_keys[self.min_freq]:\n                del self.freq_to_keys[self.min_freq]\n        # Insert new key\n        self.key_to_val_freq[key] = (value, 1)\n        self.freq_to_keys[1][key] = None\n        self.min_freq = 1\n\ndef parse_input():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return [], []\n    if len(data) == 1:\n        # Assume both lists are on the same line separated by a comma\n        line = data[0]\n        parts = line.split('],', 1)\n        ops_str = parts[0] + ']'\n        args_str = '[' + parts[1].strip()\n        ops = ast.literal_eval(ops_str)\n        args = ast.literal_eval(args_str)\n    else:\n        ops = ast.literal_eval(data[0].strip())\n        args = ast.literal_eval(data[1].strip())\n    return ops, args\n\ndef main():\n    ops, args = parse_input()\n    result = []\n    cache = None\n    for op, arg in zip(ops, args):\n        if op == \"LFUCache\":\n            cache = LFUCache(arg[0])\n            result.append(None)\n        elif op == \"get\":\n            val = cache.get(arg[0])\n            result.append(val)\n        elif op == \"put\":\n            cache.put(arg[0], arg[1])\n            result.append(None)\n    # Convert None to 'null' for output consistency\n    out = ['null' if v is None else v for v in result]\n    print('[' + ', '.join(map(str, out)) + ']')\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for designing an LFU cache with O(1). So typical design: use two hashmaps: key->node, freq->ordered dict of nodes (maintain LRU). Also maintain minFreq. Steps: Initialize structures. get: if not exist return -1. else update freq: remove node from current freq list, increment freq, add to new freq list, update minFreq if needed. return value. put: if capacity 0 return. if key exists: update value, call get to update freq. else if size==capacity: evict least freq node: get list of minFreq, remove LRU node (head). delete key. Then insert new node with freq 1, add to freq list, set minFreq=1. Complexity O(1).\n\nWe need to produce virtual code step by step with arrows and explanation each line. Use Start, End. Provide indentation maybe.\n\nWe must not output actual code, only pseudo.\n\nWe need to adhere to format: each line \"虛擬碼步驟 // 解釋\". Use arrow '→' etc. We'll produce sequential steps for class initialization, get, put. But maybe combine into single flow? But user wants design and implement a data structure. So produce steps for class and methods. We'll break into steps like \"Start // 程式開始執行\". Then \"→ Step 1: Initialize capacity, current size, minFreq, keyMap, freqMap\" etc.\n\nLet's produce a stepwise algorithm: Start -> Init -> ... then get, then put. But maybe show each method as separate flow. Provide steps for each method.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: 定義類 LFUCache(capacity) // 建構函式\n    → Step 1.1: 設定 this.capacity = capacity // 容量\n    → Step 1.2: 設定 this.size = 0 // 目前元素數\n    → Step 1.3: 設定 this.minFreq = 0 // 最小頻率\n    → Step 1.4: 建立 keyMap = Map() // key -> node\n    → Step 1.5: 建立 freqMap = Map() // freq -> OrderedLinkedList of nodes\n    → Step 1.6: 定義 Node(key, value, freq) // 節點結構\n\n→ Step 2: 定義方法 get(key) // 取得值\n    → Decision: key 存在於 keyMap?\n        Yes → Step 2.1: 取 node = keyMap[key] // 找到節點\n            → Step 2.2: 更新頻率 = node.freq + 1 // freq 增加\n            → Step 2.3: 從 freqMap[node.freq] 刪除 node // 移除舊頻率鏈表\n            → Step 2.4: 若 freqMap[node.freq] 為空且 node.freq == minFreq → Step 2.5: minFreq++ // 若最小頻率鏈表空，升級\n            → Step 2.6: node.freq = updatedFreq // 設定新頻率\n            → Step 2.7: 若 freqMap[updatedFreq] 不存在，建立新鏈表 // 初始化新頻率表\n            → Step 2.8: 將 node 加到 freqMap[updatedFreq] 末尾 // LRU 位置\n            → Step 2.9: 回傳 node.value // 返回值\n        No  → Step 2.10: 回傳 -1 // 未找到\n\n→ Step 3: 定義方法 put(key, value) // 插入/更新\n    → Decision: capacity == 0?\n        Yes → End // 無效操作，直接返回\n        No  →\n    → Decision: key 存在於 keyMap?\n        Yes → Step 3.1: 更新 node.value = value // 改變值\n            → Step 3.2: 呼叫 get(key) // 更新頻率\n            → End\n        No  →\n            → Decision: size == capacity?\n                Yes → Step 3.3: 從 freqMap[minFreq] 取最舊節點 nodeToRemove // LRU 在 minFreq\n                    → Step 3.4: 從 freqMap[minFreq] 刪除 nodeToRemove // 刪除鏈表\n                    → Step 3.5: 從 keyMap 刪除 nodeToRemove.key // 移除映射\n                    → Step 3.6: size-- // 減少大小\n                No  → // 不需要 evict\n            → Step 3.7: 建立新節點 newNode(key, value, freq=1) // 新節點\n            → Step 3.8: 將 newNode 加入 keyMap[key] = newNode // 存儲\n            → Step 3.9: 若 freqMap[1] 不存在，建立鏈表 // 初始化 freq=1 表\n            → Step 3.10: 將 newNode 加到 freqMap[1] 末尾 // LRU 位置\n            → Step 3.11: minFreq = 1 // 重設最小頻率\n            → Step 3.12: size++ // 增加大小\n    → End // 方法結束\n\nEnd // 程式執行結束\n\nWe should include arrows properly. Use '→' and indentation maybe spaces. Let's provide each step as separate line.\n\nRemember each line: \"虛擬碼步驟 // 解釋\".\n\nLet's output accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義類 LFUCache(capacity) // 建構函式\n    → Step 1.1: 設定 this.capacity = capacity // 容量\n    → Step 1.2: 設定 this.size = 0 // 目前元素數\n    → Step 1.3: 設定 this.minFreq = 0 // 最小頻率\n    → Step 1.4: 建立 keyMap = Map() // key -> node\n    → Step 1.5: 建立 freqMap = Map() // freq -> OrderedLinkedList of nodes\n    → Step 1.6: 定義 Node(key, value, freq) // 節點結構\n→ Step 2: 定義方法 get(key) // 取得值\n    → Decision: key 存在於 keyMap?\n        Yes → Step 2.1: 取 node = keyMap[key] // 找到節點\n            → Step 2.2: 更新頻率 = node.freq + 1 // freq 增加\n            → Step 2.3: 從 freqMap[node.freq] 刪除 node // 移除舊頻率鏈表\n            → Step 2.4: 若 freqMap[node.freq] 為空且 node.freq == minFreq → Step 2.5: minFreq++ // 若最小頻率鏈表空，升級\n            → Step 2.6: node.freq = updatedFreq // 設定新頻率\n            → Step 2.7: 若 freqMap[updatedFreq] 不存在，建立新鏈表 // 初始化新頻率表\n            → Step 2.8: 將 node 加到 freqMap[updatedFreq] 末尾 // LRU 位置\n            → Step 2.9: 回傳 node.value // 返回值\n        No  → Step 2.10: 回傳 -1 // 未找到\n→ Step 3: 定義方法 put(key, value) // 插入/更新\n    → Decision: capacity == 0?\n        Yes → End // 無效操作，直接返回\n        No  →\n    → Decision: key 存在於 keyMap?\n        Yes → Step 3.1: 更新 node.value = value // 改變值\n            → Step 3.2: 呼叫 get(key) // 更新頻率\n            → End\n        No  →\n            → Decision: size == capacity?\n                Yes → Step 3.3: 從 freqMap[minFreq] 取最舊節點 nodeToRemove // LRU 在 minFreq\n                    → Step 3.4: 從 freqMap[minFreq] 刪除 nodeToRemove // 刪除鏈表\n                    → Step 3.5: 從 keyMap 刪除 nodeToRemove.key // 移除映射\n                    → Step 3.6: size-- // 減少大小\n                No  → // 不需要 evict\n            → Step 3.7: 建立新節點 newNode(key, value, freq=1) // 新節點\n            → Step 3.8: 將 newNode 加入 keyMap[key] = newNode // 存儲\n            → Step 3.9: 若 freqMap[1] 不存在，建立鏈表 // 初始化 freq=1 表\n            → Step 3.10: 將 newNode 加到 freqMap[1] 末尾 // LRU 位置\n            → Step 3.11: minFreq = 1 // 重設最小頻率\n            → Step 3.12: size++ // 增加大小\n→ End // 程式執行結束"
    },
    {
      "title": "Different Ways to Add Parentheses",
      "source_file": "Leetcode/leetcode241.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "expression = \"2-1-1\"",
          "expected_output": "[0,2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[0,2]'\nGot (Norm):      '[2,0]'\n--- (Raw) ---\nRaw Expected: '[0,2]'\nRaw Got:      '[2, 0]'"
        },
        {
          "example_index": 1,
          "input": "expression = \"2*3-4*5\"",
          "expected_output": "[-34,-14,-10,-10,10]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[-34,-14,-10,-10,10]'\nGot (Norm):      '[-34,-10,-14,-10,10]'\n--- (Raw) ---\nRaw Expected: '[-34,-14,-10,-10,10]'\nRaw Got:      '[-34, -10, -14, -10, 10]'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def diffWaysToCompute(self, expression: str):\n        memo = {}\n\n        def ways(expr: str):\n            if expr in memo:\n                return memo[expr]\n\n            res = []\n            for i, ch in enumerate(expr):\n                if ch in '+-*':\n                    left = ways(expr[:i])\n                    right = ways(expr[i+1:])\n                    for l in left:\n                        for r in right:\n                            if ch == '+':\n                                res.append(l + r)\n                            elif ch == '-':\n                                res.append(l - r)\n                            else:\n                                res.append(l * r)\n            if not res:\n                res.append(int(expr))\n            memo[expr] = res\n            return res\n\n        return ways(expression)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    # 將可能的「expression = \"...\"」格式解析成純表達式字串\n    match = re.search(r'expression\\s*=\\s*\"(.*?)\"', data)\n    if match:\n        expr = match.group(1)\n    else:\n        expr = data.replace('\"', '').strip()\n    sol = Solution()\n    result = sol.diffWaysToCompute(expr)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code, line by line, with arrow style. It's a typical \"different ways to add parentheses\" problem. We need to generate all results by recursively splitting expression at operators, computing left and right sub-results, combining. Use memoization to avoid recomputation. The algorithm:\n\nStart\n→ Input string expression\n→ Call helper function diffWays(expression)\n→ In helper: if cached, return cached\n→ If no operator, parse integer and return list [num]\n→ For each index i in expression:\n   if expression[i] is operator:\n      left = helper(expression[0:i])\n      right = helper(expression[i+1:]) \n      for each l in left:\n        for each r in right:\n           compute l op r\n           add to result list\n→ Cache result\n→ Return result list\n→ End\n\nWe need virtual code with explanations after each line. Use Start, End, Decision etc. We'll produce lines like:\n\nStart // 程式開始執行\n→ Step 1: 輸入字串 expression // 取得輸入的算式\n→ Step 2: 宣告 memo 為 空字典 // 用於快取子表達式結果\n→ Step 3: 呼叫 diffWays(expression) // 開始遞迴計算\n...\n\nNeed to produce each line. Let's enumerate:\n\n1 Start\n2 Step 1: 輸入字串 expression\n3 Step 2: 初始化 memo 为空字典\n4 Step 3: 定義遞迴函式 diffWays(expr)\n5 In diffWays: Decision: if expr in memo?\n   Yes → Return memo[expr]\n   No → Continue\n6 Decision: if expr 為純數字? (no operator)\n   Yes → 解析整數並回傳列表 [int]\n   No → proceed\n7 Step 4: 初始化 results 為空列表\n8 Step 5: 迭代 i from 0 to len(expr)-1\n9 Decision: if expr[i] 為運算符 ( + - * )\n   Yes → \n      ← Step 6: left = diffWays(expr[0:i]) // 計算左子表達式\n      ← Step 7: right = diffWays(expr[i+1:]) // 計算右子表達式\n      ← Step 8: 對於每 l in left\n          For 每 r in right\n             ← Step 9: calc = l op r\n             ← Step 10: 將 calc 加入 results\n   No → continue\n10 After loop: memo[expr] = results\n11 Return results\n12 End diffWays\n\nFinally after returning, Step 4: 輸出 diffWays(expression) // 顯示所有可能結果\n\nWe should format each line accordingly with arrow, maybe indentation. Let's create final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 輸入字串 expression // 取得輸入的算式\n→ Step 2: 初始化 memo 為空字典 // 用於快取子表達式結果\n→ Step 3: 定義遞迴函式 diffWays(expr) // 開始遞迴計算\n→ Decision: expr 是否已存在於 memo? // 檢查快取\n    Yes → Step 4: 返回 memo[expr] // 若已計算直接回傳\n    No  → Decision: expr 是否為純數字? // 若沒有運算符\n        Yes → Step 5: 解析整數並回傳列表 [int] // 結束遞迴\n        No  → Step 6: 初始化 results 為空列表 // 用於存放所有結果\n→ Step 7: 對於 i 從 0 到 len(expr)-1\n    → Decision: expr[i] 是否為運算符 (+, -, *)? // 找到分割點\n        Yes → Step 8: left = diffWays(expr[0:i]) // 計算左子表達式\n              Step 9: right = diffWays(expr[i+1:]) // 計算右子表達式\n              Step 10: 對於每 l 在 left\n                      對於每 r 在 right\n                          Step 11: calc = l op r // 按符號計算\n                          Step 12: 將 calc 加入 results // 存入結果列表\n        No  → Step 13: 繼續迭代 // 跳過非運算符位置\n→ Step 14: memo[expr] = results // 將結果快取\n→ Step 15: 返回 results // 回傳所有可能結果\nEnd // 程式執行結束\n\nStep 16: 輸出 diffWays(expression) // 顯示所有可能計算結果\n```"
    },
    {
      "title": "Random Pick with Weight",
      "source_file": "Leetcode/leetcode528.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"], [[[1,3]],[],[],[],[],[]]",
          "expected_output": "[null,1,1,1,1,0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,1,1,1,1,0]'\nGot (Norm):      '[null,1,1,0,1,1]'\n--- (Raw) ---\nRaw Expected: '[null,1,1,1,1,0]'\nRaw Got:      '[null, 1, 1, 0, 1, 1]'"
        }
      ],
      "generated_code": "import sys\nimport random\nimport bisect\nimport ast\nimport json\n\nclass Solution:\n    def __init__(self, w):\n        self.prefix_sum = []\n        total = 0\n        for weight in w:\n            total += weight\n            self.prefix_sum.append(total)\n        self.total = total\n\n    def pickIndex(self):\n        target = random.randint(1, self.total)\n        return bisect.bisect_left(self.prefix_sum, target)\n\ndef parse_input(data: str):\n    \"\"\"\n    解析輸入，支持兩種格式：\n    1. 多行：第一行是 commands，第二行是 arguments\n    2. 單行：commands 和 arguments 用 '],' 分隔\n    \"\"\"\n    data = data.strip()\n    if not data:\n        return [], []\n\n    # 先嘗試多行\n    if '\\n' in data:\n        lines = [line.strip() for line in data.splitlines() if line.strip()]\n        if len(lines) >= 2:\n            try:\n                cmds = ast.literal_eval(lines[0])\n                args = ast.literal_eval(lines[1])\n                return cmds, args\n            except Exception:\n                pass\n\n    # 單行分隔\n    idx = data.find('],')\n    if idx != -1:\n        part1 = data[:idx+1]\n        part2 = data[idx+2:].strip()\n        try:\n            cmds = ast.literal_eval(part1)\n            args = ast.literal_eval(part2)\n            return cmds, args\n        except Exception:\n            pass\n\n    # 最後備用：直接用逗號切分\n    try:\n        cmds_str, args_str = data.split(',', 1)\n        cmds = ast.literal_eval(cmds_str.strip())\n        args = ast.literal_eval(args_str.strip())\n        return cmds, args\n    except Exception:\n        return [], []\n\ndef main():\n    raw_input = sys.stdin.read()\n    commands, arguments = parse_input(raw_input)\n\n    results = []\n    obj = None\n\n    for cmd, arg in zip(commands, arguments):\n        if cmd == \"Solution\":\n            obj = Solution(arg[0])  # arg[0] 是 w\n            results.append(None)\n        elif cmd == \"pickIndex\":\n            if obj is None:\n                raise ValueError(\"pickIndex called before Solution is initialized\")\n            results.append(obj.pickIndex())\n        else:\n            # 忽略未知命令\n            results.append(None)\n\n    # 用 JSON 格式輸出，符合範例要求\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code steps line by line. Need to show steps for initializing prefix sums, generating random number, binary search to find index. Provide explanation after each line. Use arrow notation. Use Start, End, Decision. Let's craft steps:\n\nStart\n→ Step 1: 建立 prefixSum 數組 // 用於存儲累積權重\n→ Step 2: 計算 prefixSum[0] = w[0] // 第0個累積權重\n→ Step 3: For i from 1 to w.length-1: prefixSum[i] = prefixSum[i-1] + w[i] // 迭代累加\n→ Step 4: total = prefixSum[w.length-1] // 總權重\n→ Step 5: 函式 pickIndex()\n    → Step 6: 生成 randomDouble = random() * total // 隨機數 0~total\n    → Decision: 是否使用二分查找? // 二分查找可提升效率\n        Yes → Step 7: left = 0; right = w.length-1\n        → Step 8: While left < right:\n                mid = (left + right) // 2\n                Decision: 如果 randomDouble < prefixSum[mid]?\n                    Yes → right = mid // 搜尋左半邊\n                    No  → left = mid + 1 // 搜尋右半邊\n            End While\n        No → Step 9: For i from 0 to w.length-1:\n                If randomDouble < prefixSum[i]: return i\n    → Step 10: return left // 二分結果回傳\nEnd\n\nAlso need to include explanation comments after each line. Ensure format: line: `虛擬碼步驟 // 解釋/說明`. Use arrow '→'. Let's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 prefixSum 數組 // 用於存儲累積權重  \n→ Step 2: 計算 prefixSum[0] = w[0] // 第0個累積權重  \n→ Step 3: For i from 1 to w.length-1: prefixSum[i] = prefixSum[i-1] + w[i] // 迭代累加至整個陣列  \n→ Step 4: total = prefixSum[w.length-1] // 總權重，後續用於產生隨機數  \n→ Step 5: 函式 pickIndex() // 定義隨機挑選索引的函式  \n    → Step 6: 生成 randomDouble = random() * total // 產生 0~total 的隨機實數  \n    → Decision: 是否使用二分查找? // 若陣列較長則採用二分法提升效率  \n        Yes → Step 7: left = 0; right = w.length-1 // 二分查找範圍初始化  \n        → Step 8: While left < right: // 進行二分搜尋  \n                mid = (left + right) // 2 // 取中點索引  \n                Decision: 如果 randomDouble < prefixSum[mid]? // 判斷是否落在左半段  \n                    Yes → right = mid // 只需搜尋左半段  \n                    No  → left = mid + 1 // 需要搜尋右半段  \n            End While  \n        No → Step 9: For i from 0 to w.length-1: // 逐一檢查較慢方式  \n                If randomDouble < prefixSum[i]: return i // 找到符合條件的索引  \n    → Step 10: return left // 二分法找到的索引回傳  \nEnd // 程式執行結束"
    },
    {
      "title": "The K Weakest Rows in a Matrix",
      "source_file": "Leetcode/leetcode1337.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "mat = [[1,1,0,0,0],[1,1,1,1,0],[1,0,0,0,0],[1,1,0,0,0],[1,1,1,1,1]], k = 3",
          "expected_output": "[2,0,3]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmppo8epf_4.py\", line 49, in <module>\n    main()\n  File \"/tmp/tmppo8epf_4.py\", line 44, in main\n    mat, k = parse_input(raw_input)\n             ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmppo8epf_4.py\", line 40, in parse_input\n    raise ValueError(\"Input format not recognized\")\nValueError: Input format not recognized"
        },
        {
          "example_index": 1,
          "input": "mat = [[1,0,0,0],[1,1,1,1],[1,0,0,0],[1,0,0,0]], k = 2",
          "expected_output": "[0,2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpp4y91ipx.py\", line 49, in <module>\n    main()\n  File \"/tmp/tmpp4y91ipx.py\", line 44, in main\n    mat, k = parse_input(raw_input)\n             ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpp4y91ipx.py\", line 40, in parse_input\n    raise ValueError(\"Input format not recognized\")\nValueError: Input format not recognized"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def kWeakestRows(self, mat, k):\n        # Count soldiers in a row using binary search (since all 1's are before 0's)\n        def count_soldiers(row):\n            left, right = 0, len(row)\n            while left < right:\n                mid = (left + right) // 2\n                if row[mid] == 1:\n                    left = mid + 1\n                else:\n                    right = mid\n            return left\n\n        soldiers = [(count_soldiers(row), i) for i, row in enumerate(mat)]\n        soldiers.sort()\n        return [i for _, i in soldiers[:k]]\n\ndef parse_input(data: str):\n    \"\"\"\n    Parse input that may contain 'mat = ... , k = ...' or just two lines.\n    \"\"\"\n    # Try regex extraction first\n    mat_match = re.search(r'mat\\s*=\\s*(\\[[\\[\\],\\s]*\\])', data)\n    k_match = re.search(r'k\\s*=\\s*(\\d+)', data)\n    if mat_match and k_match:\n        mat_str = mat_match.group(1)\n        k = int(k_match.group(1))\n        mat = ast.literal_eval(mat_str)\n        return mat, k\n    # Fallback: assume first line is matrix, second line is k\n    lines = [line.strip() for line in data.strip().splitlines() if line.strip()]\n    if len(lines) >= 2:\n        mat = ast.literal_eval(lines[0])\n        k = int(lines[1])\n        return mat, k\n    raise ValueError(\"Input format not recognized\")\n\ndef main():\n    raw_input = sys.stdin.read()\n    mat, k = parse_input(raw_input)\n    result = Solution().kWeakestRows(mat, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, each line with \"→\" etc. Provide steps for algorithm. Shouldn't output actual code. Provide explanation per line. Should be in Traditional Chinese. Use Start, Decision, End. We should describe algorithm: count soldiers per row, use list of tuples, sort, pick first k. Or use priority queue. Provide generic pseudo. Steps line by line.\n\nWe'll produce: Start, Step: Input matrix mat and k, Step: Initialize list rows=[], Step: For each row index i from 0 to m-1, Step: Count soldiers by binary search or linear, add (soldierCount, i) to list, Step: Sort list by soldierCount then i, Step: Extract first k indices, Step: Output list, End.\n\nUse decision for counting using binary search: Decision: If mid ==1? Yes→ move left? Actually to find last 1. Provide steps. We'll use simple linear scan for clarity.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入矩陣 mat 與參數 k // 取得輸入的二元矩陣和要找出的最弱行數  \n→ Step 2: 初始化空清單 rows = [] // 用於儲存每一行的士兵數與行號  \n→ Step 3: For 每行 i 從 0 到 mat 行數-1 // 遍歷所有行  \n  → Decision: 是否需要計算行 i 的士兵數？ // 判斷是否進行計算  \n   Yes → Step 4: CountSoldiers(mat[i]) → 得到士兵數 count // 呼叫計數功能  \n    → Step 5: 將 (count, i) 加入 rows // 以 tuple 存入清單  \n→ Step 6: Sort rows 依據 count 升序，若相同則依 i 升序 // 將所有行按弱度排序  \n→ Step 7: 提取前 k 個 tuple 的行號並存入 result // 取得最弱 k 行的索引  \n→ Step 8: 輸出 result // 顯示最弱行的索引序列  \nEnd // 程式執行結束  \n\n// ---------- CountSoldiers 功能 ----------\n→ Function CountSoldiers(row)  \n  → Step 9: 初始化 count = 0  \n  → For 每個值 val 從 row 開始直到結束  \n    → Decision: val == 1?  \n     Yes → Step 10: count += 1 // 進行士兵計數  \n     No  → No action // 遇到 0 時停止（若已知所有 1 在左側可直接 break）  \n  → Return count // 回傳此行的士兵總數  \n// ---------- End CountSoldiers ----------"
    }
  ]
}