{
  "run_index": 47,
  "total_files_found": 391,
  "total_files_processed": 323,
  "files_skipped": 68,
  "files_failed_load": 0,
  "---": "--- (以下基於 *題目* 總數) ---",
  "total_problems_attempted": 334,
  "generation_and_validation_success_count": 298,
  "generation_or_validation_failure_count": 36,
  "failed_cases_details": [
    {
      "title": "統計文字行數",
      "source_file": "900.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "（假設 data.txt 內容如下）\\nHello\\nPython\\nWorld",
          "expected_output": "檔案共有 3 行",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '檔案共有3行'\nGot (Norm):      '檔案共有1行'\n--- (Raw) ---\nRaw Expected: '檔案共有 3 行'\nRaw Got:      '檔案共有 1 行'"
        }
      ],
      "generated_code": "import sys\n\ndef main() -> None:\n    \"\"\"\n    從標準輸入讀取所有資料，計算行數並輸出結果。\n    若沒有輸入資料，視為找不到檔案，輸出錯誤訊息。\n    \"\"\"\n    # 讀取全部輸入\n    data = sys.stdin.read()\n\n    # 若沒有輸入，表示檔案不存在或空檔\n    if not data.strip():\n        print(\"找不到檔案！\")\n        return\n\n    # 以換行符號分割，得到行列表\n    lines = data.splitlines()\n\n    # 輸出行數\n    print(f\"檔案共有 {len(lines)} 行\")\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code lines with explanation per line. The user wants to read a file and count lines. Use with syntax and try/except. Output format requires each line: \"虛擬碼步驟 // 解釋\". Use arrows etc.\n\nWe'll start with Start, then Decision? Actually open file may raise FileNotFoundError. So we can use try block. Virtual code: Start; → Decision: Try? Actually we can have \"→ Step: Try opening file\". Use try/except.\n\nUse arrow: \"→ Try:\" etc? Format: They used \"→ Step 1: ...\" and \"→ Decision: ...\". For try/except, we could use \"→ Try: 開啟檔案\" but maybe use \"→ Try:\" and then inside lines? We can use indentation.\n\nWe need each line with \"虛擬碼步驟\" like \"→ Try: 開啟檔案\" but maybe better: \"→ Try: 開啟名為 data.txt 的檔案\". Then inside try block, we can count lines: \"→ Step: 讀取檔案內容並計算行數\". Then \"→ Step: 輸出行數\". Then \"→ End Try\". For except: \"→ Except FileNotFoundError: 輸出『找不到檔案！』\". Use proper indentation. Use \"→ Decision:\" if needed? Actually no.\n\nWe need to maintain arrows: \"→\" for steps, \"Decision:\" for conditions. For try/except, we could treat except as a step: \"→ Except FileNotFoundError:\".\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Try: 開啟名為 data.txt 的檔案 // 嘗試以 read 模式開啟檔案\n    → with 檔案 as f: // 使用 with 以確保關閉\n        → Step: 讀取所有行並計算行數 // 讀取檔案行並計算總數\n        → Step: 輸出 '總共 X 行' // 顯示行數\n→ Except FileNotFoundError: // 捕捉檔案不存在的例外\n    → Step: 輸出 '找不到檔案！' // 顯示錯誤訊息\nEnd // 程式結束\n\nBut we need each line with arrow or decision. Indentation may be shown but each line separate. Use arrow for each. For with, we can have a step: \"→ with: ...\" and inside that step we could have nested steps but each line still begins with arrow maybe \"→ Step:\".\n\nBetter to maintain structure: Use \"→ Try:\" then indent lines, but each line still includes arrow at start? They may allow indentation but each line starts with \"→\".\n\nWe can format:\n\nStart // 程式開始執行\n→ Try: 開啟名為 data.txt 的檔案 // 嘗試以 read 模式開啟檔案\n    → with 檔案 as f: // 使用 with 以確保關閉\n        → Step: 讀取檔案所有行並計算行數 // 讀取檔案並計算行數\n        → Step: 輸出 '總共 X 行' // 顯示行數\n→ Except FileNotFoundError: // 捕捉檔案不存在的例外\n    → Step: 輸出 '找不到檔案！' // 顯示錯誤訊息\nEnd // 程式執行結束\n\nBut each line must have \"虛擬碼步驟\" and explanation separated by space. Use no indentation maybe just spaces to indicate blocks. But each line must have \"→\". For lines inside block we could still start with \"→\".\n\nWe can do:\n\nStart // 程式開始執行\n→ Try: 開啟名為 data.txt 的檔案 // 嘗試以 read 模式開啟檔案\n→     with 檔案 as f: // 使用 with 以確保關閉\n→         Step: 讀取檔案所有行並計算行數 // 讀取檔案並計算行數\n→         Step: 輸出 '總共 X 行' // 顯示行數\n→ Except FileNotFoundError: // 捕捉檔案不存在的例外\n→     Step: 輸出 '找不到檔案！' // 顯示錯誤訊息\nEnd // 程式結束\n\nBut maybe they don't want indentation characters. The example used no indentation inside decisions. They used \"→ Decision:\" and then \"Yes → Step\" inside. For try/except, we can treat except as separate step.\n\nThus we can produce:\n\nStart // 程式開始執行\n→ Try: 開啟名為 data.txt 的檔案 // 嘗試以 read 模式開啟檔案\n→ with 檔案 as f: // 使用 with 以確保關閉\n→ Step: 讀取檔案所有行並計算行數 // 讀取檔案並計算行數\n→ Step: 輸出 '總共 X 行' // 顯示行數\n→ Except FileNotFoundError: // 捕捉檔案不存在的例外\n→ Step: 輸出 '找不到檔案！' // 顯示錯誤訊息\nEnd // 程式結束\n\nThis seems simpler. We'll use \"with 檔案 as f:\" line. Might need \"→ with f as file:\" but okay.\n\nLet's output as per requirement.\n...done thinking.\n\nStart // 程式開始執行  \n→ Try: 開啟名為 data.txt 的檔案 // 嘗試以 read 模式開啟檔案  \n→ with 檔案 as f: // 使用 with 以確保檔案最後關閉  \n→ Step: 讀取檔案所有行並計算行數 // 讀取檔案並統計行數  \n→ Step: 輸出 '總共 X 行' // 顯示計算出的行數  \n→ Except FileNotFoundError: // 捕捉檔案不存在的例外  \n→ Step: 輸出 '找不到檔案！' // 顯示錯誤訊息  \nEnd // 程式執行結束"
    },
    {
      "title": "模擬擲骰子遊戲",
      "source_file": "800.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "print(roll_dice(5))",
          "expected_output": "[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,6,1,4,2]#(結果會隨機，每次可能不同)'\nGot (Norm):      '[6,5,1,6,3]'\n--- (Raw) ---\nRaw Expected: '[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)'\nRaw Got:      '[6, 5, 1, 6, 3]'"
        }
      ],
      "generated_code": "import random\nimport sys\n\ndef roll_dice(n):\n    \"\"\"Simulate rolling a six-sided die n times.\"\"\"\n    if n <= 0:\n        return []\n    results = []\n    for _ in range(n):\n        results.append(random.randint(1, 6))\n    return results\n\ndef main():\n    # Read entire input from stdin\n    code = sys.stdin.read()\n    # Execute the input code, which may call roll_dice\n    exec(code, globals())\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce step-by-step virtual code with explanation, following format: each line has virtual code step and // explanation. Use arrows and structure Start, End, Decision. The user wants a function roll_dice(n) that simulates n rolls of a six-sided die using random module and returns list of results.\n\nWe should produce a pseudo-code representation, not actual code. We need to mention import random, define function, create list, loop n times, append random.randint(1,6) to list, return list.\n\nAlso maybe a decision to check n > 0? Could include validation. Let's include a decision to check if n <= 0 then return empty list.\n\nWe should maintain line-by-line. Use \"Start\" then lines. Each line has arrow if needed. We can use indentation? But requirement: Use arrow arrows. They use \"→\" for steps. For decisions, use \"Decision:\" and indentation with Yes/No lines.\n\nLet's craft.\n\nStart // 程式開始執行\n→ Import random module // 導入隨機數模組\n→ Define function roll_dice(n) // 建立 roll_dice 函式\n    → Decision: n 是否小於等於 0? // 檢查 n 的合法性\n        Yes → Return empty list // n 非正數，直接回傳空串列\n        No  → \n            → Initialize empty list results = [] // 用於存放擲骰結果\n            → Loop i from 1 to n // 執行 n 次擲骰\n                → Append random.randint(1,6) to results // 隨機產生 1~6 並加入列表\n            → Return results // 回傳所有擲骰結果\nEnd // 程式執行結束\n\nEnsure each line has virtual code then // explanation. Indent decisions lines with extra indentation or just as separate lines.\n\nWe'll use spaces to indent inside decisions. Use arrow \"→\" at each step. For decisions, use \"Decision:\". For Yes/No branches, use \"Yes →\" and \"No →\".\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Import random module // 導入隨機數模組  \n→ Define function roll_dice(n) // 建立 roll_dice 函式  \n    → Decision: n 是否小於等於 0? // 檢查 n 的合法性  \n        Yes → Return empty list // n 非正數，直接回傳空串列  \n        No  →  \n            → Initialize empty list results = [] // 用於存放擲骰結果  \n            → Loop i from 1 to n // 執行 n 次擲骰  \n                → Append random.randint(1,6) to results // 隨機產生 1~6 並加入列表  \n            → Return results // 回傳所有擲骰結果  \nEnd // 程式執行結束"
    },
    {
      "title": "計算程式執行時間",
      "source_file": "800.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "import time\n\ndef slow_add(a, b):\n    time.sleep(2)\n    return a + b\n\nprint(measure_time(slow_add, 3, 5))",
          "expected_output": "約 2.0 秒 (依電腦執行環境略有差異)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '約2.0秒(依電腦執行環境略有差異)'\nGot (Norm):      '2.0'\n--- (Raw) ---\nRaw Expected: '約 2.0 秒 (依電腦執行環境略有差異)'\nRaw Got:      '2.0'"
        }
      ],
      "generated_code": "import time\n\ndef measure_time(func, *args):\n    \"\"\"測量函式執行所需秒數，並回傳四捨五入至小數點三位的值。\"\"\"\n    start = time.time()\n    func(*args)\n    end = time.time()\n    return round(end - start, 3)\n\nif __name__ == \"__main__\":\n    import sys\n    # 讀取整個標準輸入\n    code = sys.stdin.read()\n    # 執行輸入的程式碼，使用目前全域命名空間（已包含 measure_time）\n    exec(code, globals())",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation. We must not output actual code, but the structure. Use Start, End, Decision, arrows. For this function. Steps: import time, define function, start timer, call func with args, end timer, calculate duration, round to 3 decimal places, return result. The function returns maybe the result of func? Actually it says \"回傳結果\" meaning return result of function? It says measure_time(func,*args) 用來測量函數 func 執行所需的秒數，並回傳結果 (四捨五入到小數點 3 位)。 Might mean return the elapsed time rounded to 3 decimal places. So the function returns elapsed time. Should we also return func result? Usually measurement function returns time. We'll produce that.\n\nLet's craft virtual code:\n\nStart\n→ Import time module\n→ Define function measure_time(func, *args)\n    → Start timer: start = time.time()\n    → Call func(*args) → result\n    → End timer: end = time.time()\n    → Calculate elapsed = end - start\n    → Round elapsed to 3 decimals → rounded_time\n    → Return rounded_time\n\nEnd\n\nBut also we may need to capture result maybe for further use. But requirement: \"回傳結果\" refers to time. We'll produce that.\n\nWe need to include decisions? No decisions here.\n\nBut we might need to show that *args can be passed. Use arrow.\n\nWe will produce each line: \"Start // 程式開始執行\", \"→ Import time module // 導入 time 模組\", etc. Provide line numbers? Not required.\n\nMake sure each line has \"虛擬碼步驟\" + space + \"// 解釋\". So we use \"→\" at start.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Import time module // 導入 time 模組\n→ Define function measure_time(func, *args) // 宣告測量函式\n    → Record start time: start = time.time() // 取得執行開始時間\n    → Execute func with arguments: result = func(*args) // 執行目標函式\n    → Record end time: end = time.time() // 取得執行結束時間\n    → Compute duration: duration = end - start // 計算執行秒數\n    → Round to 3 decimals: rounded = round(duration, 3) // 四捨五入到小數點三位\n    → Return rounded // 回傳測量時間\nEnd // 程式結束\n\nWe must include \"Decision\" lines? Not needed. But might include \"Decision: If func is callable?\" Not necessary.\n\nBut we might include a decision about *args presence? Not needed.\n\nThus output is as above. Ensure proper indentation maybe indicated by spaces.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Import time module // 導入 time 模組  \n→ Define function measure_time(func, *args) // 宣告測量函式  \n    → Record start time: start = time.time() // 取得執行開始時間  \n    → Execute func with arguments: result = func(*args) // 執行目標函式  \n    → Record end time: end = time.time() // 取得執行結束時間  \n    → Compute duration: duration = end - start // 計算執行秒數  \n    → Round to 3 decimals: rounded = round(duration, 3) // 四捨五入到小數點三位  \n    → Return rounded // 回傳測量時間  \nEnd // 程式結束執行"
    },
    {
      "title": "學生資料類別設計",
      "source_file": "1100.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "Alice 的分數是 90\nBob 的分數是 80",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'Alice的分數是90\\nBob的分數是80'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: 'Alice 的分數是 90\\nBob 的分數是 80'\nRaw Got:      ''"
        }
      ],
      "generated_code": "import sys\n\nclass Student:\n    def __init__(self, name, score):\n        self.name = name\n        self.score = score\n\n    def show_info(self):\n        print(f'{self.name} 的分數是 {self.score}')\n\ndef main():\n    raw = sys.stdin.read().strip()\n    lines = raw.splitlines()\n    \n    students = []\n    if not raw or all(line.strip() == '' for line in lines):\n        # 沒有輸入時使用預設學生\n        students.append(Student('Alice', 90))\n        students.append(Student('Bob', 80))\n    else:\n        for line in lines:\n            parts = line.split()\n            if len(parts) >= 2:\n                name = parts[0]\n                try:\n                    score = int(parts[1])\n                except ValueError:\n                    score = 0\n                students.append(Student(name, score))\n    \n    for student in students:\n        student.show_info()\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nThe user wants to produce pseudo-code lines, each line ends with // explanation. They want a virtual code for defining a Student class, with init and method, create two objects and call show_info.\n\nWe need to output each line with \"→ Step\" or \"Start\" etc. Use virtual code structure. We need to ensure each line has \"虛擬碼步驟\" + space + \"// 解釋/說明\". Use arrow arrow '→'. Should include Start and End. For decision not necessary. Use proper indentation.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 定義 Class Student // 宣告 Student 類別\n→ Step 2: 在 Student 中 定義 __init__(self, name, score) // 建構子，接收姓名與分數\n→ Step 3: 內部執行 self.name = name // 設定姓名屬性\n→ Step 4: 內部執行 self.score = score // 設定分數屬性\n→ Step 5: 在 Student 中 定義 show_info(self) // 定義顯示資訊的方法\n→ Step 6: 內部執行 print(f\"{self.name} 的分數是 {self.score}\") // 輸出姓名與分數\n→ Step 7: 創建 student1 = Student(\"張三\", 88) // 建立第一個學生物件\n→ Step 8: 創建 student2 = Student(\"李四\", 92) // 建立第二個學生物件\n→ Step 9: 呼叫 student1.show_info() // 顯示第一個學生資訊\n→ Step 10: 呼叫 student2.show_info() // 顯示第二個學生資訊\nEnd // 程式執行結束\n\nNeed each line has the virtual code and // explanation. Let's ensure each line starts with \"Start\" or \"→\". The first line \"Start // 程式開始執行\". Subsequent lines with \"→\". All fine.\n\nLet's format accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 Class Student // 宣告 Student 類別  \n→ Step 2: 在 Student 中 定義 __init__(self, name, score) // 建構子，接收姓名與分數  \n→ Step 3: 內部執行 self.name = name // 設定姓名屬性  \n→ Step 4: 內部執行 self.score = score // 設定分數屬性  \n→ Step 5: 在 Student 中 定義 show_info(self) // 定義顯示資訊的方法  \n→ Step 6: 內部執行 print(f\"{self.name} 的分數是 {self.score}\") // 輸出姓名與分數  \n→ Step 7: 創建 student1 = Student(\"張三\", 88) // 建立第一個學生物件  \n→ Step 8: 創建 student2 = Student(\"李四\", 92) // 建立第二個學生物件  \n→ Step 9: 呼叫 student1.show_info() // 顯示第一個學生資訊  \n→ Step 10: 呼叫 student2.show_info() // 顯示第二個學生資訊  \nEnd // 程式執行結束"
    },
    {
      "title": "集合函數練習",
      "source_file": "600.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "{'apple', 'orange', 'grape', 'melon'}",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '{\"apple\",\"orange\",\"grape\",\"melon\"}'\nGot (Norm):      '{\"grape\",\"apple\",\"melon\",\"orange\"}'\n--- (Raw) ---\nRaw Expected: \"{'apple', 'orange', 'grape', 'melon'}\"\nRaw Got:      \"{'grape', 'apple', 'melon', 'orange'}\""
        }
      ],
      "generated_code": "def main():\n    import sys\n    # 讀取 stdin 以符合輸入要求，即使此題不需要使用輸入資料\n    _ = sys.stdin.read()\n\n    # 建立並操作 fruits 集合\n    fruits = {'apple', 'banana'}\n    fruits.add('orange')                    # 新增 'orange'\n    fruits.update(['grape', 'melon'])       # 同時新增 'grape' 與 'melon'\n    fruits.remove('banana')                 # 移除 'banana'\n    fruits.discard('pineapple')             # 嘗試移除不存在的 'pineapple'，不會拋錯\n\n    # 輸出最終集合\n    print(fruits)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code steps line by line, each with explanation, using arrows. Should start with Start, End. Include operations. Format: \"虛擬碼步驟 // 解釋\". Use Start, End. Use arrows →. Decision not needed. Use virtual steps like \"→ Step 1: fruits ← {'apple', 'banana'} // 初始化集合\". Then subsequent steps. Use add(), update(), remove(), discard(), print. Provide explanation.\n\nWe should be careful with spacing: After the step, a space then // explanation. Use the arrow. Each step likely one line. Ensure no code, just steps.\n\nLet's draft:\n\nStart // 程式開始執行\n→ Step 1: fruits ← {'apple', 'banana'} // 初始化集合\n→ Step 2: fruits.add('orange') // 新增 'orange'\n→ Step 3: fruits.update({'grape', 'melon'}) // 一次新增 'grape' 與 'melon'\n→ Step 4: fruits.remove('banana') // 移除 'banana'\n→ Step 5: fruits.discard('pineapple') // 嘗試移除不存在的 'pineapple'，不會拋錯\n→ Step 6: print(fruits) // 輸出最終集合\nEnd // 程式執行結束\n\nMake sure we include the arrow each time, consistent.\n\nWe need to use `→` before each step? The example shows \"→ Step 1: ...\". Yes.\n\nWe might include Step numbers. We must adhere to format.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: fruits ← {'apple', 'banana'} // 初始化集合，包含 'apple' 與 'banana'  \n→ Step 2: fruits.add('orange') // 使用 add() 新增 'orange' 到集合  \n→ Step 3: fruits.update({'grape', 'melon'}) // 使用 update() 同時新增 'grape' 與 'melon'  \n→ Step 4: fruits.remove('banana') // 使用 remove() 移除 'banana'，若不存在則拋出錯誤  \n→ Step 5: fruits.discard('pineapple') // 使用 discard() 嘗試移除 'pineapple'，元素不存在不拋錯誤  \n→ Step 6: print(fruits) // 輸出最終的集合內容  \nEnd // 程式執行結束"
    },
    {
      "title": "即時匯率查詢小工具",
      "source_file": "1200.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "按下「更新匯率」按鈕",
          "expected_output": "目前美元匯率：約 32.5 TWD",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '目前美元匯率：約32.5TWD'\nGot (Norm):      '目前美元匯率：約30.6TWD'\n--- (Raw) ---\nRaw Expected: '目前美元匯率：約 32.5 TWD'\nRaw Got:      '目前美元匯率：約 30.6 TWD'"
        }
      ],
      "generated_code": "import sys\nimport requests\n\ndef get_rate() -> float:\n    \"\"\"\n    連接匯率 API 並回傳美元兌台幣的匯率。\n    \"\"\"\n    url = \"https://api.exchangerate-api.com/v4/latest/USD\"\n    response = requests.get(url, timeout=10)\n    response.raise_for_status()  # 若 HTTP 回應不是 200，拋出例外\n    data = response.json()\n    return data[\"rates\"][\"TWD\"]\n\ndef main() -> None:\n    \"\"\"\n    主程式：讀取標準輸入，取得匯率，並輸出結果。\n    \"\"\"\n    # 讀取所有標準輸入以消耗資料；內容不會被使用\n    _ = sys.stdin.read()\n\n    try:\n        rate = get_rate()\n        print(f\"目前美元匯率：約 {rate} TWD\")\n    except Exception:\n        # 在無法取得匯率時給出錯誤訊息\n        print(\"更新失敗，請檢查網路連線\")\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines. Need to follow the format exactly: each line has \"虛擬碼步驟\" + space + \"// 解釋/說明\". Use arrow \"→\" etc.\n\nWe need to cover entire flow: Start, import, define fetch function, GUI creation, button click, update label. Must be sequential lines. Use decision maybe none. Provide virtual steps.\n\nLet's produce:\n\nStart\n→ Import modules: requests, tkinter\n→ Define function fetch_rate() → Send GET request → Parse JSON → Return TWD rate\n→ Create main window → Title \"美元兌台幣匯率\"\n→ Create label to display rate\n→ Create button \"更新匯率\" → Bind command to update function\n→ Define update_rate() → Call fetch_rate() → Update label text\n→ Initialize label with \"請點擊更新\"\n→ Run mainloop\nEnd\n\nAdd explanations after //.\n\nNeed to use arrow symbol \"→\" for steps. For definitions maybe \"Function:\"? Could use \"Step:\".\n\nI'll write:\n\nStart // 程式開始執行\n→ Step: 載入 requests 與 tkinter 模組 // 引入所需模組\n→ Step: 定義 fetch_rate() 函式 // 用於呼叫 API 取得匯率\n    → Step: 送出 GET 請求至 https://api.exchangerate-api.com/v4/latest/USD // 取得最新匯率資料\n    → Step: 解析回傳 JSON → 提取 rates.TWD // 取得美元兌台幣匯率\n    → Step: 回傳 TWD 匯率 // 結果傳回\n→ Step: 建立 Tkinter 視窗 main_window // 主畫面\n    → Step: 設定視窗標題為 \"美元兌台幣匯率\" // 標示功能\n→ Step: 建立 Label 顯示匯率 text \"請點擊更新\" // 初始訊息\n→ Step: 建立 Button 標示 \"更新匯率\" // 用戶觸發更新\n→ Step: 定義 update_rate() 函式 // 更新匯率並顯示\n    → Step: rate ← fetch_rate() // 呼叫函式取得最新匯率\n    → Step: label.config(text f\"USD/TWD = {rate}\") // 更新文字\n→ Step: 將 Button 的 command 設定為 update_rate() // 連結按鈕與功能\n→ Step: 執行 main_window.mainloop() // 啟動 GUI 事件迴圈\nEnd // 程式執行結束\n\nBut we need arrow only on steps lines. The inner steps within functions maybe not use arrow? Could use \"Step:\" but maintain arrow format. We need to follow \"使用虛擬碼的箭頭 (→, Yes →, No →) 和結構 (Start, End, Decision:)\".\n\nThus for function definition, we might not need arrow inside. Could just use \"Step:\" but the example shows \"→ Step 1:\" etc. We'll use arrow on each line.\n\nFor inner steps inside function, we can indent and still use arrow. Might be fine.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step: 載入 requests 與 tkinter 模組 // 引入所需模組\n→ Step: 定義 fetch_rate() 函式 // 用於呼叫 API 取得匯率\n    → Step: 送出 GET 請求至 https://api.exchangerate-api.com/v4/latest/USD // 取得最新匯率資料\n    → Step: 解析回傳 JSON → 提取 rates.TWD // 取得美元兌台幣匯率\n    → Step: 回傳 TWD 匯率 // 結果傳回\n→ Step: 建立 Tkinter 視窗 main_window // 主畫面\n    → Step: 設定視窗標題為 \"美元兌台幣匯率\" // 標示功能\n→ Step: 建立 Label 顯示匯率 text \"請點擊更新\" // 初始訊息\n→ Step: 建立 Button 標示 \"更新匯率\" // 用戶觸發更新\n→ Step: 定義 update_rate() 函式 // 更新匯率並顯示\n    → Step: rate ← fetch_rate() // 呼叫函式取得最新匯率\n    → Step: label.config(text f\"USD/TWD = {rate}\") // 更新文字\n→ Step: 將 Button 的 command 設定為 update_rate() // 連結按鈕與功能\n→ Step: 執行 main_window.mainloop() // 啟動 GUI 事件迴圈\nEnd // 程式執行結束"
    },
    {
      "title": "Insert Delete GetRandom O(1)",
      "source_file": "Leetcode/leetcode380.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedSet\", \"insert\", \"remove\", \"insert\", \"getRandom\", \"remove\", \"insert\", \"getRandom\"], [[], [1], [2], [2], [], [1], [2], []]",
          "expected_output": "[null, true, false, true, 2, true, false, 2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,false,true,2,true,false,2]'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: '[null, true, false, true, 2, true, false, 2]'\nRaw Got:      ''"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\n\nclass RandomizedSet:\n    \"\"\"一個能在 O(1) 時間內插入、刪除並隨機取元素的集合。\"\"\"\n    def __init__(self):\n        # 存儲元素的動態陣列\n        self.values = []\n        # 元素到其在 values 陣列中索引的映射\n        self.val_to_index = {}\n\n    def insert(self, val: int) -> bool:\n        \"\"\"如果 val 不存在，插入並返回 True；否則返回 False。\"\"\"\n        if val in self.val_to_index:\n            return False\n        self.values.append(val)\n        self.val_to_index[val] = len(self.values) - 1\n        return True\n\n    def remove(self, val: int) -> bool:\n        \"\"\"如果 val 存在，刪除並返回 True；否則返回 False。\"\"\"\n        if val not in self.val_to_index:\n            return False\n        idx = self.val_to_index[val]\n        last_val = self.values[-1]\n        # 把最後一個元素移到被刪除位置\n        self.values[idx] = last_val\n        self.val_to_index[last_val] = idx\n        # 移除最後一個元素\n        self.values.pop()\n        del self.val_to_index[val]\n        return True\n\n    def getRandom(self) -> int:\n        \"\"\"隨機返回一個元素。\"\"\"\n        return random.choice(self.values)\n\ndef main():\n    # 從標準輸入讀取整個輸入字串\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 將單引號轉換為雙引號以符合 json 格式\n    data = data.replace(\"'\", '\"')\n    try:\n        commands, args_list = json.loads(data)\n    except json.JSONDecodeError:\n        # 若輸入格式不符，直接結束\n        return\n\n    result = []\n    obj = None\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"RandomizedSet\":\n            obj = RandomizedSet()\n            result.append(None)  # null 對應 None\n        elif cmd == \"insert\":\n            res = obj.insert(args[0])\n            result.append(res)\n        elif cmd == \"remove\":\n            res = obj.remove(args[0])\n            result.append(res)\n        elif cmd == \"getRandom\":\n            res = obj.getRandom()\n            result.append(res)\n\n    # 將結果格式化為 [null, true, false, 2, ...]\n    out = []\n    for v in result:\n        if v is None:\n            out.append(\"null\")\n        elif isinstance(v, bool):\n            out.append(\"true\" if v else \"false\")\n        else:\n            out.append(str(v))\n    print(f\"[{', '.join(out)}]\")\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps, line by line, with explanations. The user wants RandomizedSet class. So we produce steps like:\n\nStart\n→ Step 1: 定義 RandomizedSet class\n→ Step 2: 初始化 vector list and unordered_map map\n...\n\nWe need to use virtual code with arrows. Also Decision structure.\n\nWe should produce pseudocode for each method: insert, remove, getRandom, constructor.\n\nWe need to keep lines with \"→\" and decision blocks.\n\nAlso need to use structure \"Start\", \"End\".\n\nWe also need to use \"Yes →\", \"No →\" etc.\n\nLet's design:\n\nStart\n→ Step 1: 定義 RandomizedSet 類別 // 開始定義類別\n→ Step 2: 內部成員: vector<int> nums; unordered_map<int, int> valToIndex; // 存儲元素與其索引\n→ Step 3: Constructor: 初始化空容器 // 構造函式\n\nInsert:\n→ Step 1: 判斷 val 是否已存在於 valToIndex\n    Yes → Step 2: 返回 false // 已存在，插入失敗\n    No → Step 3: 將 val 加入 nums 且索引為 nums.size() - 1\n        → Step 4: 更新 valToIndex[val] = nums.size() - 1\n        → Step 5: 返回 true // 插入成功\n\nRemove:\n→ Step 1: 判斷 val 是否存在於 valToIndex\n    Yes → Step 2: 取得索引 idx = valToIndex[val]\n        → Step 3: 取得最後一個元素 lastVal = nums.back()\n        → Step 4: 將 lastVal 放到 idx 位置: nums[idx] = lastVal\n        → Step 5: 更新 valToIndex[lastVal] = idx\n        → Step 6: 移除最後一個元素 nums.pop_back()\n        → Step 7: 刪除 valToIndex[val]\n        → Step 8: 返回 true\n    No → Step 2: 返回 false\n\nGetRandom:\n→ Step 1: 隨機產生索引 r = rand() % nums.size()\n→ Step 2: 返回 nums[r]\n\nEnd\n\nBut we need to keep \"Start\" and \"End\" maybe around class definition? Or we can start with \"Start\" and then End at end.\n\nThe format: Each line: virtual code step + space + // explanation.\n\nMake sure each line includes \"→\" for steps. Use indentation? Not necessary.\n\nWe can use \"Decision:\" for if. So maybe:\n\nDecision: val in valToIndex? // check existence\n\nYes → ...\n\nWe need to produce each step line by line. So we produce the pseudocode for entire class.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 定義 RandomizedSet 類別 // 定義類別\n    → Member: vector<int> nums // 存儲元素\n    → Member: unordered_map<int, int> valToIndex // 元素到索引映射\n→ Step 2: Constructor() 初始化 // 建構函式\n    → nums.clear()\n    → valToIndex.clear()\n→ Step 3: insert(val) // 插入方法\n    → Decision: val 在 valToIndex? // 檢查是否已存在\n        Yes → Return false // 已存在\n        No  → nums.append(val) // 將 val 加入\n            → valToIndex[val] = nums.size() - 1 // 記錄索引\n            → Return true // 插入成功\n→ Step 4: remove(val) // 移除方法\n    → Decision: val 在 valToIndex? // 檢查是否存在\n        Yes → idx = valToIndex[val] // 取得索引\n            → lastVal = nums.back() // 取得最後一個\n            → nums[idx] = lastVal // 用最後一個覆蓋\n            → valToIndex[lastVal] = idx // 更新映射\n            → nums.pop_back() // 移除最後一個\n            → valToIndex.erase(val) // 刪除映射\n            → Return true // 成功移除\n        No  → Return false // 不存在\n→ Step 5: getRandom() // 隨機取元素\n    → r = rand() % nums.size() // 隨機索引\n    → Return nums[r] // 回傳\nEnd // 程式執行結束\n\nWe need to ensure each line has \"虛擬碼步驟\" + space + \"// 解釋\". Also lines with arrows. For decisions, we should use \"Decision:\".\n\nWe need to indent? It may not be necessary. But we can use indentation for clarity.\n\nWe need to use \"→\" before each step. Also \"Yes →\", \"No →\".\n\nWe need to keep consistent format: \"虛擬碼步驟 // 解釋\" lines.\n\nLet's write each line exactly. For decisions, we use \"Decision:\".\n\nExample:\n\nStart // 程式開始執行\n\n→ Step 1: Define RandomizedSet class // 定義類別\n\n→ Member: vector<int> nums // 存儲元素\n\n...\n\nWe need to ensure each line ends with explanation. For decisions, we include explanation after //.\n\nWe need to produce lines like:\n\n→ Decision: val exists in valToIndex? // 檢查是否已存在\n\nYes → Return false // 已存在\n\nNo  → ... etc.\n\nOk.\n\nAlso need to maintain that each step is separate line. Use indentation to show nested steps? The format didn't require indentation but we can use spaces.\n\nBetter to keep each line as a separate line with \"→\". For nested steps we can indent with spaces.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 RandomizedSet 類別 // 建立類別結構  \n    → Member: vector<int> nums // 儲存所有元素的動態陣列  \n    → Member: unordered_map<int, int> valToIndex // 元素對應其索引的映射表  \n→ Step 2: Constructor() // 初始化空容器  \n    → nums.clear() // 清空元素陣列  \n    → valToIndex.clear() // 清空索引映射表  \n→ Step 3: insert(val) // 插入方法  \n    → Decision: val 是否已存在於 valToIndex? // 檢查元素是否重複  \n        Yes → Return false // 已存在，插入失敗  \n        No  → nums.append(val) // 把新值加入陣列  \n            → valToIndex[val] = nums.size() - 1 // 記錄新值的索引  \n            → Return true // 插入成功  \n→ Step 4: remove(val) // 移除方法  \n    → Decision: val 是否存在於 valToIndex? // 檢查元素是否存在  \n        Yes → idx = valToIndex[val] // 取得元素在陣列中的索引  \n            → lastVal = nums.back() // 取得陣列最後一個元素  \n            → nums[idx] = lastVal // 用最後一個元素覆蓋被刪除位置  \n            → valToIndex[lastVal] = idx // 更新最後一個元素的索引映射  \n            → nums.pop_back() // 刪除陣列最後一個元素  \n            → valToIndex.erase(val) // 移除該元素的索引映射  \n            → Return true // 成功移除  \n        No  → Return false // 元素不存在，移除失敗  \n→ Step 5: getRandom() // 隨機取得元素  \n    → r = rand() % nums.size() // 隨機產生索引  \n    → Return nums[r] // 回傳對應元素  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Flip Matrix",
      "source_file": "Leetcode/leetcode519.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"flip\", \"flip\", \"flip\", \"reset\", \"flip\"], [[3, 1], [], [], [], [], []]",
          "expected_output": "[null, [1,0], [2,0], [0,0], null, [2,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[1,0],[2,0],[0,0],null,[2,0]]'\nGot (Norm):      '[null,[2,0],[1,0],[0,0],null,[0,0]]'\n--- (Raw) ---\nRaw Expected: '[null, [1,0], [2,0], [0,0], null, [2,0]]'\nRaw Got:      '[null, [2, 0], [1, 0], [0, 0], null, [0, 0]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport ast\n\nclass Solution:\n    \"\"\"隨機翻轉矩陣中值為 0 的位置，確保每個位置被選到的機率相同。\"\"\"\n\n    def __init__(self, n_rows, n_cols):\n        # 行列\n        self.rows = n_rows\n        self.cols = n_cols\n        # 總數量\n        self.total = n_rows * n_cols\n        # 映射表，存放已翻轉的索引映射\n        self.flipped = {}\n\n    def flip(self):\n        \"\"\"隨機選擇一個仍為 0 的位置，翻轉為 1，並返回其行列座標。\"\"\"\n        # 隨機選擇一個索引\n        r = random.randint(0, self.total - 1)\n        # 取得實際位置（若已映射則取映射值）\n        x = self.flipped.get(r, r)\n        # 將總數減 1\n        self.total -= 1\n        # 更新映射，將 r 映射到最後一個可選索引\n        self.flipped[r] = self.flipped.get(self.total, self.total)\n        # 將一維索引轉回二維座標\n        return [x // self.cols, x % self.cols]\n\n    def reset(self):\n        \"\"\"將所有位置重置為 0。\"\"\"\n        self.total = self.rows * self.cols\n        self.flipped.clear()\n\ndef _parse_input():\n    \"\"\"解析 stdin，返回操作列表和參數列表。\"\"\"\n    lines = [line.strip() for line in sys.stdin if line.strip()]\n    if len(lines) == 1:\n        # 單行輸入，兩個列表以 '],' 分隔\n        split_index = lines[0].find('],')\n        ops_str = lines[0][:split_index + 1]\n        args_str = lines[0][split_index + 2:].strip()\n    else:\n        ops_str, args_str = lines[0], lines[1]\n    ops = ast.literal_eval(ops_str)\n    args = ast.literal_eval(args_str)\n    return ops, args\n\nif __name__ == \"__main__\":\n    ops, args = _parse_input()\n    result = []\n    obj = None\n    for op, param in zip(ops, args):\n        if op == \"Solution\":\n            obj = Solution(param[0], param[1])\n            result.append(None)\n        elif op == \"flip\":\n            result.append(obj.flip())\n        elif op == \"reset\":\n            obj.reset()\n            result.append(None)\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm. It's the classic random flip problem. We can flatten indices to 0..m*n-1, maintain available list or map from index to remaining index. Use reservoir like. Use a dictionary mapping from selected index to replacement.\n\nPseudo:\nStart\n→ Initialize m, n, total=m*n\n→ Initialize map empty\n→ Initialize count=total\nflip()\n    → if count==0: error\n    → pick rand between 0 and count-1\n    → actualIndex = map.get(rand) if exists else rand\n    → last = count-1\n    → map.put(rand, map.get(last) if exists else last)\n    → decrement count\n    → return actualIndex//convert to (i,j)\nreset()\n    → clear map\n    → count=total\n\nExplain steps.\n\nNeed to produce each line with \"虛擬碼步驟 // 解釋\". Use arrows. Use indentation for decision? Not needed.\n\nWe'll produce lines like:\n\nStart // 初始化程式\n→ Step: 初始化 m, n, total = m * n // 計算矩陣總元素\n→ Step: 建立空映射 map // 用於映射選擇到剩餘位置\n→ Step: 設置 count = total // 剩餘可選位置數\n\nflip()\n    → Step: 若 count == 0 則拋出錯誤 // 沒有空位\n    → Step: randIndex = randomInt(0, count-1) // 隨機選擇\n    → Step: actual = map.getOrDefault(randIndex, randIndex) // 取得實際位置\n    → Step: lastIndex = count - 1\n    → Step: map.put(randIndex, map.getOrDefault(lastIndex, lastIndex)) // 替換\n    → Step: count -= 1\n    → Step: i = actual / n; j = actual % n // 轉為行列\n    → Return [i, j] // 返回並已翻轉\n\nreset()\n    → Step: clear map // 清空映射\n    → Step: count = total // 重置計數\n\nEnd // 程式結束\n\nBut need arrow and formatting as specified. Use \"→\" before each step. The \"Start\" line uses no arrow? In example: \"Start // 程式開始執行\" then \"→ Step 1\". So we follow that.\n\nAlso indent decision: not needed because no decisions except count==0. But we can show \"Decision: count == 0?\" etc.\n\nLet's produce structured lines with \"Decision:\" and \"Yes →\", \"No →\". But maybe not needed. However spec: Use arrows and decision structure.\n\nWe'll include decision for count==0.\n\nLet's craft.\n\n```\nStart // 程式開始執行\n→ Step: m, n ← input // 獲取矩陣尺寸\n→ Step: total ← m * n // 計算總元素數\n→ Step: map ← empty dictionary // 存儲隨機映射\n→ Step: count ← total // 剩餘可選數量\nEnd // 初始化完成\n\nflip()\n    → Decision: 如果 count == 0? // 檢查是否還有空位\n        Yes → Step: Throw error // 無空位可選\n        No  →\n            → Step: randIndex ← randomInt(0, count-1) // 隨機選擇\n            → Step: actual ← map.getOrDefault(randIndex, randIndex) // 取得實際索引\n            → Step: lastIndex ← count - 1 // 最後一個可選索引\n            → Step: map.put(randIndex, map.getOrDefault(lastIndex, lastIndex)) // 更新映射\n            → Step: count ← count - 1 // 减少可選數量\n            → Step: i ← actual // n // 轉行\n            → Step: j ← actual mod n // 轉列\n            → Step: Return [i, j] // 回傳並已翻轉\n\nreset()\n    → Step: map.clear() // 清空映射\n    → Step: count ← total // 重置計數\n\nEnd // 程式結束\n```\n\nBut need \"→\" before each step line inside flip's No branch; we need to maintain indentation maybe spaces. Provide lines.\n\nMake sure each line has \"虛擬碼步驟\" + space + \"// 解釋\". We'll use \"→\" and indentation spaces. Use \"Decision:\" line as well. Provide them.\n\nLet's output final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: m, n ← input // 取得矩陣尺寸  \n→ Step: total ← m * n // 計算總元素數量  \n→ Step: map ← empty dictionary // 用於映射已選擇位置  \n→ Step: count ← total // 剩餘可選位置數  \n\nflip()  \n    → Decision: 如果 count == 0? // 檢查是否還有空位可選  \n        Yes → Step: Throw error // 無空位，拋出錯誤  \n        No  →  \n            → Step: randIndex ← randomInt(0, count-1) // 隨機選擇一個位置  \n            → Step: actual ← map.getOrDefault(randIndex, randIndex) // 取得實際索引  \n            → Step: lastIndex ← count - 1 // 最後一個可選位置  \n            → Step: map.put(randIndex, map.getOrDefault(lastIndex, lastIndex)) // 替換映射以維持隨機性  \n            → Step: count ← count - 1 // 減少可選位置數  \n            → Step: i ← actual // n // 計算行索引  \n            → Step: j ← actual mod n // 計算列索引  \n            → Step: Return [i, j] // 回傳並已翻轉位置  \n\nreset()  \n    → Step: map.clear() // 清空映射表  \n    → Step: count ← total // 重置可選位置數  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Remove Invalid Parentheses",
      "source_file": "Leetcode/leetcode301.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"()())()\"",
          "expected_output": "[\"(())()\",\"()()()\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"(())()\",\"()()()\"]'\nGot (Norm):      '[\"()()()\",\"(())()\"]'\n--- (Raw) ---\nRaw Expected: '[\"(())()\",\"()()()\"]'\nRaw Got:      '[\"()()()\", \"(())()\"]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport re\n\nclass Solution:\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        利用 BFS 搜尋最小刪除後可合法的字串集合\n        \"\"\"\n        # 檢查一個字串是否合法\n        def isValid(st):\n            cnt = 0\n            for ch in st:\n                if ch == '(':\n                    cnt += 1\n                elif ch == ')':\n                    cnt -= 1\n                    if cnt < 0:\n                        return False\n            return cnt == 0\n\n        level = {s}          # 目前層級所有可能的字串\n        while level:\n            # 先檢查本層級是否已有合法字串\n            valid = [item for item in level if isValid(item)]\n            if valid:\n                return valid\n\n            # 若無合法字串，產生下一層級（刪除一個括號）\n            next_level = set()\n            for item in level:\n                for i, ch in enumerate(item):\n                    if ch in ('(', ')'):\n                        next_level.add(item[:i] + item[i+1:])\n            level = next_level\n\n        return []  # 若完全無法合法化，回傳空串列表\n\ndef main():\n    # 從 stdin 讀取原始輸入\n    raw_data = sys.stdin.read().strip()\n\n    # 從輸入中擷取第一個被引號包住的字串，若無則直接使用整個輸入\n    match = re.search(r'[\"\\'](.*?)[\"\\']', raw_data, re.S)\n    s = match.group(1) if match else raw_data\n\n    solution = Solution()\n    result = solution.removeInvalidParentheses(s)\n\n    # 以 JSON 格式輸出結果，符合範例格式\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations. Steps: input string s. Need to compute min removals and generate all valid strings. Classic BFS or DFS with pruning. Approach: BFS level by level, generating all strings with one removal until we find valid ones. Or DFS with recursion removing left or right parentheses counts. For brevity, we can outline BFS. Virtual code: Start, Step 1 compute min removals? BFS. We'll produce pseudo. Let's write line by line.\n\nWe need unique strings. Use a set.\n\nImplement function isValid(str). Then BFS queue.\n\nWe'll produce code accordingly.\n\nEnsure each line has explanation.\n\nLet's produce ~15 lines.\n\nWe'll include Decision, Start, End.\n\nLet's do.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化隊列 queue ← {s} // 將原始字串加入搜尋隊列  \n→ Step 2: 初始化結果集 result ← ∅ // 用來存放所有符合條件的合法字串  \n→ Step 3: 初始化已處理集 visited ← ∅ // 防止重複處理相同字串  \n→ Step 4: 初始化標誌 found ← False // 用來判斷是否已找到合法字串  \n→ Decision: 若 queue 非空? // 繼續搜尋  \n    Yes → Step 5: 取出 queue 頭元素 current ← queue.pop_front() // 取得待驗證的字串  \n    → Decision: current 是否在 visited?  \n        Yes → Step 6: 跳過本次迴圈 // 已處理過，直接下一個  \n        No → Step 7: 將 current 加入 visited ← visited ∪ {current} // 記錄已處理  \n    → Step 8: 若 isValid(current) 且 found 為 False? // 第一層合法字串出現時  \n        Yes → Step 9: result ← result ∪ {current} // 加入結果  \n        → Step 10: found ← True // 標示已找到合法字串  \n    → Decision: found 為 True? // 若已找到合法字串，僅收集同層結果  \n        Yes → Step 11: 若 current 已合法，則不再產生子字串  \n        No  → Step 12: 若 current 不合法，則產生所有可能的子字串  \n            → For i in 0 .. len(current)-1  \n                → Decision: current[i] 是否為 '(' 或 ')'？  \n                    Yes → Step 13: 產生 new_str ← current[0:i] + current[i+1:] // 移除第 i 個括號  \n                        → Decision: new_str 是否已在 visited?  \n                            No → queue.push_back(new_str) // 加入下一層搜尋  \n    → End // 迴圈結束  \n→ Decision: queue 非空? // 繼續 BFS 或結束  \n    Yes → 回到 Decision: 若 queue 非空?  \n    No  → Step 14: End // 所有層搜尋完畢  \n→ End // 程式執行結束，返回 result 集合中所有合法字串"
    },
    {
      "title": "Compare Version Numbers",
      "source_file": "Leetcode/leetcode165.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "version1 = \"1.01\", version2 = \"1.001\"",
          "expected_output": "0",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '0'\nGot (Norm):      '-1'\n--- (Raw) ---\nRaw Expected: '0'\nRaw Got:      '-1'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def compareVersion(self, version1: str, version2: str) -> int:\n        # 將版本字串拆成整數清單\n        v1 = [int(x) for x in version1.split('.')]\n        v2 = [int(x) for x in version2.split('.')]\n        n, m = len(v1), len(v2)\n        # 比較每一層 revision\n        for i in range(max(n, m)):\n            num1 = v1[i] if i < n else 0\n            num2 = v2[i] if i < m else 0\n            if num1 < num2:\n                return -1\n            if num1 > num2:\n                return 1\n        return 0\n\ndef main():\n    # 讀取全部輸入\n    data = sys.stdin.read()\n    # 從輸入中找出兩個版本字串（含點號）\n    versions = re.findall(r'\\d+(?:\\.\\d+)*', data)\n    if len(versions) < 2:\n        # 若未找到足夠版本，直接輸出 0\n        print(0)\n        return\n    version1, version2 = versions[0], versions[1]\n    result = Solution().compareVersion(version1, version2)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for comparing two version strings. Must follow format: each line \"虛擬碼步驟 // 解釋\". Use arrows. We'll start with Start, then maybe Step: split versions, etc. Use Decision blocks. Must ensure we provide a line per step. Probably around 12-15 lines.\n\nLet's draft:\n\nStart // 程式開始執行\n→ Step 1: 定義 version1, version2  // 取得兩個版本字串\n→ Step 2: 用 '.' 分割 version1 為 list1 // 產生 revision 清單\n→ Step 3: 用 '.' 分割 version2 為 list2 // 產生 revision 清單\n→ Step 4: 設定 i = 0, n1 = length(list1), n2 = length(list2) // 索引初始化\n→ Decision: i < max(n1, n2) ? // 仍有未比較的 revision\n    Yes → Step 5: 取得 rev1 = (i < n1) ? integer(list1[i]) : 0 // 取 revision 或 0\n    → Step 6: 取得 rev2 = (i < n2) ? integer(list2[i]) : 0 // 取 revision 或 0\n    → Decision: rev1 < rev2 ?\n        Yes → Step 7: Return -1 // version1 小\n        No → Decision: rev1 > rev2 ?\n            Yes → Step 8: Return 1 // version1 大\n            No → Step 9: i = i + 1 // revision 相等，進行下一位\n    No → Step 10: i = i + 1 // 在最外層迴圈\n    No → Step 11: Return 0 // 所有 revision 相等\nEnd // 程式結束\n\nNeed to format exactly: each line \"虛擬碼步驟 // 解釋\". Use arrows for steps and decision indent. Provide indentation maybe spaces. Provide arrow in Step 5 etc. Provide '→ Decision:' lines. Let's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 version1, version2 // 取得兩個版本字串  \n→ Step 2: 將 version1 用 '.' 分割得到 list1 // 產生 revision 清單  \n→ Step 3: 將 version2 用 '.' 分割得到 list2 // 產生 revision 清單  \n→ Step 4: 設定 i = 0, n1 = len(list1), n2 = len(list2) // 索引初始化  \n→ Decision: i < max(n1, n2) ? // 是否還有未比較的 revision  \n Yes → Step 5: 計算 rev1 = (i < n1) ? int(list1[i]) : 0 // 取得 revision 或 0  \n  → Step 6: 計算 rev2 = (i < n2) ? int(list2[i]) : 0 // 取得 revision 或 0  \n  → Decision: rev1 < rev2 ?  \n   Yes → Step 7: Return -1 // version1 小於 version2  \n   No → Decision: rev1 > rev2 ?  \n    Yes → Step 8: Return 1 // version1 大於 version2  \n    No → Step 9: i = i + 1 // revision 相等，移至下一位  \n No → Step 10: i = i + 1 // 進行下一位比較  \nNo → Step 11: Return 0 // 所有 revision 相等  \nEnd // 程式執行結束"
    },
    {
      "title": "Top K Frequent Words",
      "source_file": "Leetcode/leetcode692.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "words = [\"i\",\"love\",\"leetcode\",\"i\",\"love\",\"coding\"], k = 2",
          "expected_output": "[\"i\",\"love\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"i\",\"love\"]'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: '[\"i\",\"love\"]'\nRaw Got:      ''"
        },
        {
          "example_index": 1,
          "input": "words = [\"the\",\"day\",\"is\",\"sunny\",\"the\",\"the\",\"the\",\"sunny\",\"is\",\"is\"], k = 4",
          "expected_output": "[\"the\",\"is\",\"sunny\",\"day\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"the\",\"is\",\"sunny\",\"day\"]'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: '[\"the\",\"is\",\"sunny\",\"day\"]'\nRaw Got:      ''"
        }
      ],
      "generated_code": "import sys\nfrom collections import Counter\n\nclass Solution:\n    def topKFrequent(self, words, k):\n        \"\"\"\n        找出最頻繁出現的 k 個字串。\n        先用 Counter 計數，之後以 (頻率降序, 字典序升序) 進行排序。\n        最後只取前 k 個字串回傳。\n        \"\"\"\n        # 1. 統計每個字的頻率\n        count = Counter(words)\n        # 2. 按 (-頻率, 字串) 排序，頻率越高越前面，頻率相同時字典序越小越前面\n        sorted_words = sorted(count.items(), key=lambda x: (-x[1], x[0]))\n        # 3. 取前 k 個字串\n        return [word for word, freq in sorted_words[:k]]\n\ndef main():\n    \"\"\"\n    讀取標準輸入，格式預期類似：\n        words = [\"i\",\"love\",\"leetcode\",\"i\",\"love\",\"coding\"], k = 2\n    透過 exec 執行，將得到 words 與 k 的變數，再呼叫 Solution。\n    最後把結果以 Python list 形式輸出。\n    \"\"\"\n    # 讀取整個輸入\n    input_data = sys.stdin.read().strip()\n    if not input_data:\n        return\n\n    # 使用 exec 執行，將 words 與 k 變數保存在 local_vars\n    local_vars = {}\n    try:\n        exec(input_data, {}, local_vars)\n    except Exception as e:\n        print(f\"輸入格式錯誤: {e}\", file=sys.stderr)\n        return\n\n    words = local_vars.get('words')\n    k = local_vars.get('k')\n\n    # 檢查取得的資料是否有效\n    if not isinstance(words, list) or not isinstance(k, int):\n        print(\"輸入格式錯誤: 必須提供 words 列表與整數 k\", file=sys.stderr)\n        return\n\n    # 取得答案\n    solution = Solution()\n    result = solution.topKFrequent(words, k)\n\n    # 輸出結果\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for algorithm: count frequencies, sort by freq desc and lex asc. We'll provide steps: start, input words, k, count, create list of (word, freq), sort using custom comparator, take first k, return.\n\nWe need to follow format: each line with virtual code step + // explanation. Use arrows and Decision.\n\nLet's produce:\n\nStart\n→ Step 1: words = input array; k = input int // get input\n→ Step 2: frequencyMap = empty hash // to store counts\n→ Step 3: For each word in words: increment frequencyMap[word] // count frequencies\n→ Step 4: entries = list of (word, freq) from frequencyMap // list for sorting\n→ Decision: entries not empty? // just continue\n    Yes → Step 5: sort entries by (freq desc, word asc) // custom sort\n    No  → Step 6: return empty list // no words\n→ Step 7: result = first k elements of entries // take top k\n→ Step 8: output = list of words from result // extract words\nEnd // finish\n\nAdd appropriate comments. Use virtual arrow for steps.\n\nLet's format accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: words = input array, k = input integer // 取得輸入的字串陣列與整數 k  \n→ Step 2: frequencyMap = {} // 建立空的雜湊表以儲存每個字的出現次數  \n→ Step 3: For each word in words: frequencyMap[word] += 1 // 統計每個字的頻率  \n→ Step 4: entries = List of (word, frequency) from frequencyMap // 將雜湊表轉為可排序的清單  \n→ Decision: entries is not empty? // 檢查是否有字可處理  \n  Yes → Step 5: sort entries by (frequency descending, word ascending) // 依頻率降序、同頻率時字典序升序排序  \n  No  → Step 6: return [] // 若無字，直接回傳空列表  \n→ Step 7: topK = first k elements of entries // 取出前 k 個最常見的字  \n→ Step 8: result = list of word from topK // 只保留字串部分作為回傳結果  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick Index",
      "source_file": "Leetcode/leetcode398.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\"], [[[1, 2, 3, 3, 3]], [3], [1], [3]]",
          "expected_output": "[null, 4, 0, 2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,4,0,2]'\nGot (Norm):      '[null,3,0,3]'\n--- (Raw) ---\nRaw Expected: '[null, 4, 0, 2]'\nRaw Got:      '[null, 3, 0, 3]'"
        }
      ],
      "generated_code": "import sys\nimport random\nfrom collections import defaultdict\n\nclass Solution:\n    \"\"\"根據給定的整數陣列初始化對象，並在 pick 時隨機返回目標元素的索引。\"\"\"\n    def __init__(self, nums):\n        # 建立從數值到其所有索引的映射，方便 O(1) 取得所有符合條件的索引\n        self.num_indices = defaultdict(list)\n        for i, num in enumerate(nums):\n            self.num_indices[num].append(i)\n\n    def pick(self, target):\n        \"\"\"隨機挑選一個符合 target 的索引，所有索引機率相等。\"\"\"\n        return random.choice(self.num_indices[target])\n\ndef main():\n    # 讀取整個輸入字串\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 把輸入分成兩個頂層列表：命令和參數\n    # 第一個 ']' 之後跟著 ','，所以用 find 來切割\n    first_end = data.find(']')\n    cmds_str = data[:first_end+1]\n    args_str = data[first_end+2:]  # 跳過 ', '\n\n    # 使用 eval 解析為 Python 物件，輸入格式已確定為合法\n    cmds = eval(cmds_str)\n    args = eval(args_str)\n\n    result = []\n    obj = None\n    for cmd, arg in zip(cmds, args):\n        if cmd == \"Solution\":\n            # Solution 的參數是 [[1,2,3,...]]，用 *arg 取得實際 nums\n            obj = Solution(*arg)\n            result.append(None)          # LeetCode 代表 null\n        else:\n            # 其它方法直接呼叫並將回傳值加入結果\n            ret = getattr(obj, cmd)(*arg)\n            result.append(ret)\n\n    # 轉換結果為 LeetCode 需要的字串格式\n    out = '[' + ', '.join('null' if x is None else str(x) for x in result) + ']'\n    print(out)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for described problem: random index pick for target. Provide pseudocode steps. Virtual code lines with explanation. Use arrows. Format as per requirement. We'll produce steps: start, init array, store mapping target->list of indices maybe, or store array and for pick, find indices via scanning but probability equal. Approach: store mapping from target to list of indices for quick retrieval. pick: random choice from list. Steps.\n\nLet's produce:\n\nStart\n→ Step 1: 初始化 Solution，接收 nums // Constructor\n→ Decision: 如果未存儲映射？ // 確保 mapping dict\n    Yes → Step 2: 創建空字典 target_to_indices // 初始化\n    No  → Skip // 已存在\n→ Decision: 遍歷 nums 的每個索引 i\n    Yes → Step 3: 將 i 加入 target_to_indices[nums[i]] // 建立索引列表\n    No  → Next // 完成\n→ End // 構造完成\n\nThen pick function:\n\nStart pick\n→ Step 1: 從 target_to_indices[target] 取得列表 indices // 找到目標索引\n→ Decision: 列表長度 > 0 ?\n    Yes → Step 2: 隨機選擇 index = 隨機整數(0, len-1) // 等機會\n    No  → Step 3: 返回 -1 // (不應該發生，因假設存在)\n→ Step 4: 返回 indices[index] // 取得隨機索引\nEnd pick\n\nBut need to follow format lines.\n\nAlso ensure arrow uses \"→\". Use Start, End.\n\nWe'll produce two separate functions. Maybe combine? The output may include multiple functions. We'll produce start for constructor, end, then start for pick.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 接收整數陣列 nums 作為建構參數 // 將輸入資料保存\n→ Decision: 是否需要建立目標至索引映射？ // 檢查是否已初始化\n    Yes → Step 2: 建立空字典 target_to_indices // 用於快速查詢索引列表\n    No  → Step 2a: 直接使用已存在的映射 // 若已存在則跳過\n→ Step 3: 從 0 到 nums.length-1 逐個索引 i\n→ Decision: 是否繼續處理索引 i？ // 檢查是否已遍歷完\n    Yes → Step 4: 取 nums[i] 為 key\n    → Step 5: 若 key 不在 target_to_indices 中，則 target_to_indices[key] ← 空列表\n    → Step 6: 把 i 加入 target_to_indices[key] // 保存索引\n    No  → Skip // 結束遍歷\nEnd // 建構完成，資料已整理好\n\nStart // pick 方法開始執行\n→ Step 1: 從 target_to_indices[target] 取得索引列表 indices // 取得所有匹配位置\n→ Decision: 列表 indices 是否為空？ // 檢查是否真的存在目標\n    Yes → Step 2: 返回 -1 // 處理不應發生的錯誤情況\n    No  → Step 3: 生成隨機整數 r 在 0 到 indices.length-1 之間 // 等機會選取\n    → Step 4: 返回 indices[r] // 回傳隨機選中的索引\nEnd // pick 方法結束執行"
    },
    {
      "title": "Palindrome Pairs",
      "source_file": "Leetcode/leetcode336.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "words = [\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]",
          "expected_output": "[[0,1],[1,0],[3,2],[2,4]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0],[3,2],[2,4]]'\nGot (Norm):      '[[3,2]]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0],[3,2],[2,4]]'\nRaw Got:      '[[3, 2]]'"
        },
        {
          "example_index": 1,
          "input": "words = [\"bat\",\"tab\",\"cat\"]",
          "expected_output": "[[0,1],[1,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0]]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0]]'\nRaw Got:      '[]'"
        },
        {
          "example_index": 2,
          "input": "words = [\"a\",\"\"]",
          "expected_output": "[[0,1],[1,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0]]'\nGot (Norm):      '[[1,0]]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0]]'\nRaw Got:      '[[1, 0]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def palindromePairs(self, words):\n        # 建立「逆字串 -> 索引」的字典\n        rev_to_index = {w[::-1]: i for i, w in enumerate(words)}\n        res = []\n\n        for i, word in enumerate(words):\n            # 遍歷所有切分位置，包括 0 和 len(word)\n            for cut in range(len(word) + 1):\n                prefix, suffix = word[:cut], word[cut:]\n\n                # 1. 前綴是回文，則檢查後綴的逆字串是否存在\n                if prefix == prefix[::-1]:\n                    rev_suffix = suffix[::-1]\n                    if rev_suffix in rev_to_index:\n                        j = rev_to_index[rev_suffix]\n                        if j != i:\n                            res.append([j, i])  # (j, i)\n\n                # 2. 後綴是回文，且 cut 不是 0（避免重複處理整個字串）\n                if cut != 0 and suffix == suffix[::-1]:\n                    rev_prefix = prefix[::-1]\n                    if rev_prefix in rev_to_index:\n                        j = rev_to_index[rev_prefix]\n                        if j != i:\n                            res.append([i, j])  # (i, j)\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 只取第一個 '[' 到最後一個 ']' 之間的部分並安全解析\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1 or start > end:\n        # 無法解析，直接輸出空列表\n        print([])\n        sys.exit(0)\n\n    words_str = data[start:end+1]\n    try:\n        words = ast.literal_eval(words_str)\n    except Exception:\n        # 解析失敗時輸出空列表\n        print([])\n        sys.exit(0)\n\n    sol = Solution()\n    result = sol.palindromePairs(words)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to generate a step-by-step pseudo-code for algorithm to find palindrome pairs with linear time sum lengths. We cannot output actual code. Provide steps with arrows. Need to explain each line. Should produce steps of algorithm: For each word, store reversed, etc. Classic solution: For each word, for each split, check if prefix is palindrome, etc. Complexity O(N * L^2) worst-case but if we use hash map it's O(total length). Actually typical solution O(total length * avg length). But we can propose algorithm: Build hash map of word to index. For each word, for each split position, check if prefix palindrome, suffix palindrome. Then look for reversed counterpart. This achieves O(total length^2)? But problem says O(total length). Usually solutions meet O(total length) by using efficient palindrome checks? We'll produce steps accordingly.\n\nWe'll produce pseudo-code:\n\nStart\n→ Build hash map word -> index\n→ For each word with index i:\n    → For split position from 0 to len(word):\n        → If prefix is palindrome:\n            → revSuffix = reverse(word[split:])\n            → If revSuffix in map and map[revSuffix] != i:\n                → Add pair (map[revSuffix], i)\n        → If suffix is palindrome and split > 0:\n            → revPrefix = reverse(word[:split])\n            → If revPrefix in map and map[revPrefix] != i:\n                → Add pair (i, map[revPrefix])\n→ End\n\nAdd empty string handling: if empty in list: for each word not palindrome: add (index, emptyIndex) and (emptyIndex, index). But we can mention optional.\n\nLet's generate pseudo-code lines accordingly. Ensure each line contains // explanation. Use arrow. Use decision steps. Provide final array. Should be lines.\n\nLet's craft.\n\nWe'll include steps: Build map; iterate words; for each split; decision if palindrome; find reversed counterpart; add pair.\n\nWe'll produce each line with arrow.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立字典 map: word → 索引 // 用於 O(1) 取索引  \n→ Step 2: 若存在空字串, 取得其索引 emptyIdx // 空字串與任何回文字串均能配對  \n\n→ Decision: 是否有空字串?  \n    Yes → Step 3: 對每個非空字串 wordIdx:  \n        → If words[wordIdx] 為回文  \n            → Add pair (wordIdx, emptyIdx) // 先加 i→空串  \n            → Add pair (emptyIdx, wordIdx) // 再加 空串→i  \n        → No  → // 空字串不存在，略過  \n\n→ Step 4: For each word, index i, 文字 word  \n    → For split from 0 to len(word):  \n        → Decision: 前綴 word[:split] 是否為回文?  \n            Yes → Step 5: 取 suffix = word[split:]  \n                → revSuffix = reverse(suffix)  \n                → Decision: revSuffix 是否在 map 且 map[revSuffix] ≠ i?  \n                    Yes → Add pair (map[revSuffix], i) // suffix 的逆與前綴回文可拼接  \n                    No  → // 無配對，繼續  \n            No  → // 前綴非回文，忽略  \n\n        → Decision: 後綴 word[split:] 是否為回文? 且 split > 0? // 避免重複處理全字串  \n            Yes → Step 6: 取 prefix = word[:split]  \n                → revPrefix = reverse(prefix)  \n                → Decision: revPrefix 是否在 map 且 map[revPrefix] ≠ i?  \n                    Yes → Add pair (i, map[revPrefix]) // 前綴的逆與後綴回文可拼接  \n                    No  → // 無配對，繼續  \n            No  → // 後綴非回文，忽略  \n\n→ End // 程式執行結束，結果已在答案陣列中\n\n此虛擬碼使用哈希表與兩層迴圈，總時間複雜度為 O(∑|words[i]|)（每個字元最多被檢查兩次），符合題目要求。"
    },
    {
      "title": "Repeated DNA Sequences",
      "source_file": "Leetcode/leetcode187.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = 'AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT'",
          "expected_output": "[\"AAAAACCCCC\",\"CCCCCAAAAA\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"AAAAACCCCC\",\"CCCCCAAAAA\"]'\nGot (Norm):      '[\"CCCCCAAAAA\",\"AAAAACCCCC\"]'\n--- (Raw) ---\nRaw Expected: '[\"AAAAACCCCC\",\"CCCCCAAAAA\"]'\nRaw Got:      '[\"CCCCCAAAAA\", \"AAAAACCCCC\"]'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport json\n\nclass Solution:\n    def findRepeatedDnaSequences(self, s: str):\n        \"\"\"\n        找出 DNA 序列中所有出現超過一次的 10 字元子序列。\n        \"\"\"\n        seen = set()          # 已經見過的子序列\n        repeated = set()      # 重複出現的子序列\n        for i in range(len(s) - 9):\n            seq = s[i:i + 10]\n            if seq in seen:\n                repeated.add(seq)   # 第二次及之後才加入結果\n            else:\n                seen.add(seq)\n        return list(repeated)\n\ndef main():\n    \"\"\"\n    讀取標準輸入中的 DNA 序列，並輸出所有重複的 10 字元子序列。\n    \"\"\"\n    data = sys.stdin.read().strip()\n\n    # 從輸入中提取出單引號或雙引號包住的 DNA 序列\n    s = ''\n    m = re.search(r\"'([^']*)'\", data)\n    if m:\n        s = m.group(1)\n    else:\n        m = re.search(r'\"([^\"]*)\"', data)\n        if m:\n            s = m.group(1)\n        else:\n            # 若沒有引號，直接使用整行文字\n            s = data\n\n    sol = Solution()\n    result = sol.findRepeatedDnaSequences(s)\n\n    # 使用 json.dumps 輸出，能得到符合範例的雙引號格式\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for algorithm: find all 10-letter substrings that appear more than once in a string. Approach: use hash map to count. Return list of substrings with count >1. Complexity O(n). We need to output step by step in virtual code with arrows, decisions etc. Each line: \"虛擬碼步驟 // 解釋\". Use arrow \"→\". Use Start, End, Decision.\n\nLet's produce:\n\nStart // start\n→ Step 1: 定義 n = length(s) // get length\n→ Decision: n < 10? // if shorter than 10 cannot have any 10-length substrings\n    Yes → Step 2: Return empty list // no result\n    No  → Step 3: 建立 hash map freq // map substring->count\n→ Step 4: 建立空集合 result // to store substrings that appear >1\n→ Step 5: for i from 0 to n-10 inclusive // iterate start indices\n    → Step 6: sub = s[i:i+10] // extract 10-length substring\n    → Decision: freq[sub] exists? // check if seen before\n        Yes → Step 7: freq[sub] +=1 // increment count\n            → Decision: freq[sub] == 2? // only add once when count becomes 2\n                Yes → Step 8: result.add(sub) // add to result\n                No  → // do nothing\n        No  → Step 9: freq[sub] = 1 // first time seen\n→ Step 10: Convert result set to list and return // final answer\nEnd // program finished\n\nWe need to format with arrows and include 'Yes →' 'No →' lines for decisions. Also we need to include comment after each line. Let's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 n = length(s) // 取得 DNA 序列長度  \n→ Decision: n < 10? // 判斷序列是否足夠長  \n  Yes → Step 2: 返回空列表 // 無 10 字元子序列  \n  No  → Step 3: 建立哈希表 freq // 用於計數子序列出現次數  \n→ Step 4: 建立空集合 result // 存放重複出現的 10 字元子序列  \n→ Step 5: 對 i 從 0 到 n-10 迭代 // 遍歷所有可能的起始位置  \n  → Step 6: sub = s[i : i+10] // 擷取 10 字元子序列  \n  → Decision: freq[sub] 存在? // 子序列是否已被遇到  \n    Yes → Step 7: freq[sub] += 1 // 次數加一  \n      Decision: freq[sub] == 2? // 只在第二次遇到時加入結果  \n       Yes → Step 8: result.add(sub) // 加入重複集合  \n       No  → // 其餘次數不處理  \n    No  → Step 9: freq[sub] = 1 // 第一次遇到，初始計數  \n→ Step 10: 將 result 轉成列表並返回 // 回傳所有重複子序列  \nEnd // 程式執行結束"
    },
    {
      "title": "Permutations",
      "source_file": "Leetcode/leetcode46.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nGot (Norm):      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nRaw Got:      '[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 2, 1], [3, 1, 2]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def permute(self, nums):\n        \"\"\"\n        Generate all permutations of the list nums.\n        \"\"\"\n        res = []\n\n        def backtrack(start):\n            # If we've fixed all positions, record a copy of the current permutation\n            if start == len(nums):\n                res.append(nums[:])\n                return\n            # Try each remaining element in the current position\n            for i in range(start, len(nums)):\n                nums[start], nums[i] = nums[i], nums[start]  # swap to fix element at position start\n                backtrack(start + 1)                         # recurse for the next position\n                nums[start], nums[i] = nums[i], nums[start]  # backtrack, restore original order\n\n        backtrack(0)\n        return res\n\nif __name__ == \"__main__\":\n    # Read the entire input\n    data = sys.stdin.read().strip()\n    if data:\n        # Extract the list part after '=' if present\n        if '=' in data:\n            _, list_str = data.split('=', 1)\n        else:\n            list_str = data\n        # Safely evaluate the list\n        nums = ast.literal_eval(list_str.strip())\n        solution = Solution()\n        result = solution.permute(nums)\n        # Print the result as a standard Python list representation\n        print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code, line by line, with explanations. It's a permutation generation. Provide start, steps. Use recursion or backtracking. Show steps.\n\nWe need no actual code, just steps with explanation.\n\nWe need to ensure formatting: \"虛擬碼步驟 // 解釋\". Use arrow. Start End. Decision: if? etc.\n\nLet's produce algorithm: \nStart\n→ Step 1: 定義結果列表 res\n→ Step 2: 定義遞迴函數 backtrack(curr, remaining)\n    → Decision: 若 remaining 為空? \n        Yes → Step 3: 將 curr 加入 res\n        No  → For each num in remaining:\n               → Step 4: 呼叫 backtrack(curr+num, remaining - num)\n→ Step 5: 呼叫 backtrack([], nums)\n→ Step 6: 回傳 res\nEnd\n\nAdd explanation comments after //.\n\nAlso include decision arrows Yes → and No →.\n\nWe need to use Chinese explanations. Provide line by line. Ensure each line includes a space before //.\n\nOk. Let's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空列表 res 用於存放所有排列 // 初始化結果容器  \n→ Step 2: 定義遞迴函數 backtrack(curr, remaining) // 用於構造排列  \n  → Decision: 如果 remaining 為空? // 判斷是否已完成一組排列  \n    Yes → Step 3: 把 curr 加到 res 中 // 完整排列加入結果  \n    No  → For each num in remaining: // 遍歷還未使用的數字  \n     → Step 4: 呼叫 backtrack(curr + [num], remaining \\ {num}) // 加入數字並遞迴  \n→ Step 5: 呼叫 backtrack([], nums) // 從空排列開始，使用所有數字  \n→ Step 6: 回傳 res // 返回所有生成的排列  \nEnd // 程式執行結束"
    },
    {
      "title": "Text Justification",
      "source_file": "Leetcode/leetcode68.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"], maxWidth = 16",
          "expected_output": "[\"This    is    an\",\"example  of text\",\"justification.  \"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"Thisisan\",\"exampleoftext\",\"justification.\"]'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: '[\"This    is    an\",\"example  of text\",\"justification.  \"]'\nRaw Got:      ''"
        },
        {
          "example_index": 1,
          "input": "words = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"], maxWidth = 16",
          "expected_output": "[\"What   must   be\",\"acknowledgment  \",\"shall be        \"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"Whatmustbe\",\"acknowledgment\",\"shallbe\"]'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: '[\"What   must   be\",\"acknowledgment  \",\"shall be        \"]'\nRaw Got:      ''"
        },
        {
          "example_index": 2,
          "input": "words = [\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"], maxWidth = 20",
          "expected_output": "[\"Science  is  what we\",\"understand      well\",\"enough to explain to\",\"a  computer.  Art is\",\"everything  else  we\",\"do                  \"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"Scienceiswhatwe\",\"understandwell\",\"enoughtoexplainto\",\"acomputer.Artis\",\"everythingelsewe\",\"do\"]'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: '[\"Science  is  what we\",\"understand      well\",\"enough to explain to\",\"a  computer.  Art is\",\"everything  else  we\",\"do                  \"]'\nRaw Got:      ''"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        完全對齊文字。每行長度恰好為 maxWidth。\n        \"\"\"\n        res = []          # 存放結果行\n        i = 0             # 目前尚未處理的單字索引\n        n = len(words)    # 單字總數\n\n        while i < n:\n            # 先計算目前行能放多少單字\n            line_len = len(words[i])      # 本行已累計的字符長度\n            j = i + 1                    # 下個待考慮的單字索引\n\n            # 嘗試把後面的單字都塞進這一行，直到不再符合 maxWidth\n            while j < n and line_len + 1 + len(words[j]) <= maxWidth:\n                line_len += 1 + len(words[j])   # 加一個空格 + 單字長度\n                j += 1\n\n            # 現在 words[i:j] 為本行的所有單字\n            line_words = words[i:j]\n            # 需要插入的空格總數\n            spaces_needed = maxWidth - sum(len(w) for w in line_words)\n            gaps = len(line_words) - 1        # 單字之間的空格槽數\n\n            # 判斷是否為最後一行或只有一個單字\n            if j == n or gaps == 0:\n                # 左對齊：單字之間留一個空格，行尾補足空格\n                line = ' '.join(line_words)\n                line += ' ' * (maxWidth - len(line))\n            else:\n                # 完全對齊：把空格平均分配，左側多餘空格先分配\n                space, extra = divmod(spaces_needed, gaps)\n                line_parts = []\n                for idx, w in enumerate(line_words[:-1]):  # 最後一個單字不加空格\n                    # 每個槽至少有 space 個空格，左側多出的 extra 個槽多加一個\n                    line_parts.append(w + ' ' * (space + (1 if idx < extra else 0)))\n                line_parts.append(line_words[-1])          # 最後一個單字\n                line = ''.join(line_parts)\n\n            res.append(line)  # 將完成的行加入結果\n            i = j            # 移到下一行的起始位置\n\n        return res\n\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入，並解析出 words 與 maxWidth\n    raw_input = sys.stdin.read().strip()\n\n    # 正則表達式提取兩個變數\n    pattern = r\"words\\s*=\\s*(\\[\\s*(?:['\\\"].*?['\\\"])?\\s*(?:,\\s*(?:['\\\"].*?['\\\"])?\\s*)*\\],)\\s*,\\s*maxWidth\\s*=\\s*(\\d+)\"\n    match = re.search(pattern, raw_input, re.S)\n    if not match:\n        # 若輸入格式不符合，直接結束\n        sys.exit(0)\n\n    words_str = match.group(1)\n    max_width = int(match.group(2))\n\n    # 轉成實際資料結構\n    words = ast.literal_eval(words_str)\n\n    # 執行對齊\n    solution = Solution()\n    result = solution.fullJustify(words, max_width)\n\n    # 輸出結果列表，與範例保持一致\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines, each with explanation, using Start, End, Decision. We need to describe algorithm. We'll need to loop over words, accumulate line words until exceed width, then produce line with spaces distribution. Include handling last line.\n\nWe produce steps:\n\nStart\n→ Step 1: 初始化索引 i = 0, 结果 list lines = []\n→ Decision: i < words.length? else End\nInside loop:\n→ Step 2: 计算当前行的 words 范围，start = i\n→ Step 3: 用 while 循环累计 next word length +1 spaces until exceed\n→ Step 4: 记录 end index exclusive\n→ Step 5: 计算单词数 count = end - start\n→ Decision: i == words.length-1? // last line check\nYes: build last line left-justified\nNo: build middle line full justification\nBuild line: compute totalChars = sum lengths\nspacesNeeded = maxWidth - totalChars\nif count==1 -> line = word + spaces\nelse slots = count-1\nbaseSpace = spacesNeeded // slots\nextra = spacesNeeded % slots\nconstruct string: for each word except last: append word + baseSpace + (extra>0?1:0) spaces, decrement extra\nappend last word\nAdd line to result\nSet i = end\nLoop back\n\nEnd\n→ Output lines\n\nWe'll need to include explanations each line.\n\nMake sure each line of virtual code ends with // explanation. Use arrows for steps, Decision etc.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: i ← 0; lines ← [] // 初始化指標與結果集合  \n→ Decision: i < words.length? // 是否還有未處理的單字？  \n    Yes → Step 2: start ← i // 記錄目前行的起始單字索引  \n    → Step 3: lengthSum ← 0 // 目前行已累計字符長度  \n    → Step 4: end ← i // end 為行結束後的索引（不包）  \n    → Decision: end < words.length AND lengthSum + words[end].length + (end-start) ≤ maxWidth?  \n        Yes → lengthSum ← lengthSum + words[end].length; end ← end + 1; // 加入單字並更新長度  \n        No  → // 不能再加入單字，行已完成  \n    → Step 5: count ← end - start // 行中單字數  \n    → Decision: i == words.length - 1? // 是否為最後一行？  \n        Yes → // 建立左對齊最後一行  \n            → Step 6: line ← words[start]  \n            → Decision: start+1 < end?  \n                Yes → For j from start+1 to end-1: line ← line + \" \" + words[j] // 單字之間加入一個空格  \n                No  → // 只有一個單字  \n            → Step 7: line ← line + repeat(\" \", maxWidth - length(line)) // 補足右側空格  \n        No  → // 建立完全對齊中間行  \n            → Step 8: totalChars ← sum(length(words[k]) for k in [start, end-1]) // 單字總長度  \n            → Step 9: spacesNeeded ← maxWidth - totalChars // 需插入的空格總數  \n            → Step 10: slots ← count - 1 // 單字間的空格槽數  \n            → Step 11: baseSpace ← spacesNeeded ÷ slots // 每槽至少空格數  \n            → Step 12: extra ← spacesNeeded mod slots // 左側多餘空格數  \n            → Step 13: line ← \"\"  \n            → For k from start to end-2:  \n                → line ← line + words[k] + repeat(\" \", baseSpace + (extra>0?1:0)) // 加入單字與空格  \n                → If extra>0: extra ← extra - 1  \n            → line ← line + words[end-1] // 最後一個單字不加空格  \n    → Step 14: lines ← lines + [line] // 將處理好的行加入結果  \n    → Step 15: i ← end // 將指標移至下一行的起始位置  \n→ Decision: i < words.length? // 是否還有未處理的單字？  \n    Yes → // 迴圈回到 Decision 判斷  \n    No  → // 所有行已處理完成  \nEnd // 程式執行結束，返回 lines（已完成全對齊與左對齊的文字列集合）"
    },
    {
      "title": "Insert Delete GetRandom O(1) - Duplicates allowed",
      "source_file": "Leetcode/leetcode381.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedCollection\", \"insert\", \"insert\", \"insert\", \"getRandom\", \"remove\", \"getRandom\"], [[], [1], [1], [2], [], [1], []]",
          "expected_output": "[null, true, false, true, 2, true, 1]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,false,true,2,true,1]'\nGot (Norm):      '[null,true,false,true,1,true,1]'\n--- (Raw) ---\nRaw Expected: '[null, true, false, true, 2, true, 1]'\nRaw Got:      '[null, true, false, true, 1, true, 1]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\nimport collections\n\nclass RandomizedCollection:\n    def __init__(self):\n        self.data = []                         # 存放所有元素\n        self.idx_map = collections.defaultdict(set)  # 每個值對應的索引集合\n\n    def insert(self, val):\n        # 插入後記錄索引\n        self.data.append(val)\n        self.idx_map[val].add(len(self.data) - 1)\n        # 若是第一次插入，返回 True，否則 False\n        return len(self.idx_map[val]) == 1\n\n    def remove(self, val):\n        # 若不存在該值，直接返回 False\n        if not self.idx_map[val]:\n            return False\n        # 取出任意一個索引\n        remove_idx = self.idx_map[val].pop()\n        last_val = self.data[-1]\n        # 用最後一個元素覆蓋要刪除的位置\n        self.data[remove_idx] = last_val\n        # 更新 last_val 的索引集合\n        self.idx_map[last_val].remove(len(self.data) - 1)\n        self.idx_map[last_val].add(remove_idx)\n        # 刪除最後一個元素\n        self.data.pop()\n        # 若該值已不存在，從字典中移除\n        if not self.idx_map[val]:\n            del self.idx_map[val]\n        return True\n\n    def getRandom(self):\n        # 隨機返回一個元素\n        return random.choice(self.data)\n\ndef format_value(v):\n    if v is None:\n        return 'null'\n    if isinstance(v, bool):\n        return 'true' if v else 'false'\n    return str(v)\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    # 解析兩個列表，可能是單行或多行輸入\n    try:\n        # 若是多行，直接按行拆分\n        parts = [line.strip() for line in raw_input.splitlines() if line.strip()]\n        if len(parts) >= 2:\n            ops = ast.literal_eval(parts[0])\n            args = ast.literal_eval(parts[1])\n        else:\n            # 單行情況：拆分第一個閉括號後的兩個列表\n            first_close = raw_input.find(']')\n            ops = ast.literal_eval(raw_input[:first_close + 1])\n            args = ast.literal_eval(raw_input[first_close + 2:])\n    except Exception:\n        # 解析失敗，直接退出\n        sys.exit(0)\n\n    rc = RandomizedCollection()\n    results = [None]  # 第一個操作是建構子，返回 null\n    for op, arg in zip(ops[1:], args[1:]):\n        if op == 'insert':\n            results.append(rc.insert(arg[0]))\n        elif op == 'remove':\n            results.append(rc.remove(arg[0]))\n        elif op == 'getRandom':\n            results.append(rc.getRandom())\n        else:\n            # 未知操作，視為 None\n            results.append(None)\n\n    output = '[' + ', '.join(format_value(v) for v in results) + ']'\n    print(output)",
      "virtual_code": "Thinking...\nWe need to produce virtual code, step-by-step, for RandomizedCollection. Use structure: Start, Step, Decision, etc. Provide explanation after each line. Each line includes virtual code step and // explanation. Use arrow for decisions. Provide algorithm: Use vector for elements, unordered_map from val to set of indices. In insert: add val to vector, add index to map set; if val not existed before return true else false. remove: check if map[val] not empty; if empty return false. Else get an index from set (any), remove from vector by swapping with last element, updating map for swapped value. Remove index from map set. If map set becomes empty, erase key. Return true. getRandom: pick random index in vector, return element. All O(1) average.\n\nWe need to output each step as virtual code lines, with explanation. Use arrow and decisions. Let's craft lines.\n\nWe should start with Start, then define class and constructor. But virtual code maybe at algorithmic level.\n\nWe'll write:\n\nStart // 程式開始執行\n\n→ Step 1: 初始化 vector elements, map indices // 建立空的元素列表和索引表\n\n→ Step 2: 定義 insert(val) // 插入方法開始\n\n→ Step 3: 取得 val 在 indices 中的集合 // 查詢是否已存在\n\n    Yes → Step 4: 插入 val 時標記為已存在 // 需要更新返回值\n\n    No  → Step 5: 插入 val 時標記為未存在 // 記錄返回值\n\n→ Decision: val 是否已存在? // 判斷返回值\n\n    Yes → Step 6: push_back(val) 到 elements // 添加新元素\n\n    No  → Step 7: push_back(val) 到 elements // 同樣添加\n\n→ Step 8: 在 indices[val] 添加新索引 (size-1) // 更新索引表\n\n→ Step 9: 返回 true/false 根據 val 是否首次插入 // 完成插入\n\nSimilarly for remove.\n\nBut we should structure as virtual code flow. Probably simpler: Steps for each function separately. Provide explanation.\n\nLet's produce:\n\nStart\n\n→ Step 1: 建立空的 elements 與 indices // 用於存放元素和索引集合\n\n→ Step 2: 定義 insert(val) // 插入操作\n\n    → Step 3: isNew = (indices[val] is empty) // 判斷是否為首次插入\n\n    → Step 4: elements.append(val) // 將 val 加入末尾\n\n    → Step 5: indices[val].add(elements.size - 1) // 記錄其索引\n\n    → Step 6: return isNew // 若第一次插入回 true，否則 false\n\n→ Step 7: 定義 remove(val) // 刪除操作\n\n    → Decision: indices[val] 是否非空? // 判斷是否存在\n\n        Yes → Step 8: 任取 idx = any index from indices[val] // 取得要刪除的索引\n\n        → Step 9: lastVal = elements[-1] // 取得最後一個元素\n\n        → Step 10: elements[idx] = lastVal // 用最後一個覆蓋要刪除的位置\n\n        → Step 11: indices[lastVal].remove(elements.size - 1) // 移除 lastVal 的最後索引\n\n        → Step 12: indices[lastVal].add(idx) // 加入新索引\n\n        → Step 13: elements.pop_back() // 刪除最後一個元素\n\n        → Step 14: indices[val].remove(idx) // 移除 val 的索引\n\n        → Decision: indices[val] 是否空? // 若不再存在該值\n\n            Yes → Step 15: indices.erase(val) // 刪除該鍵\n\n        → Step 16: return true // 成功刪除\n\n        No → Step 17: return false // 未找到要刪除\n\n→ Step 18: 定義 getRandom() // 隨機取值\n\n    → Step 19: idx = random integer in [0, elements.size-1] // 隨機索引\n\n    → Step 20: return elements[idx] // 返回隨機元素\n\nEnd\n\nMake sure each line is a virtual code step with // explanation. Use arrow symbols for decisions.\n\nBut ensure the format: \"虛擬碼步驟 [space] // 解釋\". So each line must be: something like \"Start // 程式開始執行\".\n\nUse arrows with \"→\".\n\nWe need to use \"Decision:\" for decisions. Example: \"Decision: indices[val] 是否非空?\" But the requirement: \"Decision:\" and use Yes→, No→. So we need to format:\n\nDecision: indices[val] 是否非空? // 判斷是否存在\n    Yes → ... \n    No  → ...\n\nOk.\n\nLet's craft each line accordingly.\n\nWe need to keep step numbers optional? They can be part of the description but not necessary. But in example, they used \"Step 1:\" etc. We'll keep.\n\nAlso we must use \"→\" arrow before steps after decisions.\n\nLet's produce.\n\nAlso note that inside steps we can include sub-steps with indentation.\n\nOk produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空的 vector elements 與 map indices // 用於存放所有元素與每個值對應的索引集合  \n\n→ Step 2: 定義 insert(val) // 插入方法開始  \n\n → Step 3: isNew ← (indices[val] is empty) // 判斷 val 是否首次插入  \n\n → Step 4: elements.append(val) // 把 val 加到列表末尾  \n\n → Step 5: indices[val].add(elements.size - 1) // 在索引表中記錄新元素的索引  \n\n → Step 6: return isNew // 若第一次插入回 true，否則 false  \n\n→ Step 7: 定義 remove(val) // 刪除方法開始  \n\n → Decision: indices[val] 是否非空? // 判斷 val 是否存在  \n\n  Yes → Step 8: idx ← any index from indices[val] // 取得一個要刪除的索引  \n\n   → Step 9: lastVal ← elements[-1] // 取得列表最後一個元素  \n\n   → Step 10: elements[idx] ← lastVal // 用最後一個元素覆蓋要刪除的位置  \n\n   → Step 11: indices[lastVal].remove(elements.size - 1) // 移除 lastVal 的最後索引  \n\n   → Step 12: indices[lastVal].add(idx) // 加入 lastVal 的新索引  \n\n   → Step 13: elements.pop_back() // 刪除列表最後一個元素  \n\n   → Step 14: indices[val].remove(idx) // 移除 val 的索引  \n\n   → Decision: indices[val] 是否空? // 若 val 已經不再存在  \n\n    Yes → Step 15: indices.erase(val) // 刪除該鍵  \n\n   → Step 16: return true // 成功刪除一個 val  \n\n  No  → Step 17: return false // val 不存在，無法刪除  \n\n→ Step 18: 定義 getRandom() // 隨機取值方法開始  \n\n → Step 19: idx ← random integer in [0, elements.size - 1] // 產生隨機索引  \n\n → Step 20: return elements[idx] // 返回對應的隨機元素  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Coin Change",
      "source_file": "Leetcode/leetcode322.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "coins = [1,2,5], amount = 11",
          "expected_output": "3",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp_i1q6aei.py\", line 37, in <module>\n    coins, amount = parse_input(input_data)\n                    ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp_i1q6aei.py\", line 30, in parse_input\n    amount_str = amount_part.split('=', 1)[1].strip()\n                 ~~~~~~~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def coinChange(self, coins, amount):\n        # DP array where dp[i] is the min number of coins to make amount i\n        dp = [float('inf')] * (amount + 1)\n        dp[0] = 0\n        for coin in coins:\n            for x in range(coin, amount + 1):\n                if dp[x - coin] + 1 < dp[x]:\n                    dp[x] = dp[x - coin] + 1\n        return dp[amount] if dp[amount] != float('inf') else -1\n\ndef parse_input(data: str):\n    \"\"\"\n    Parses input of the form:\n        coins = [1,2,5], amount = 11\n    or with arbitrary spaces.\n    Returns (coins, amount).\n    \"\"\"\n    data = data.strip()\n    if not data:\n        return [], 0\n    parts = data.split(',')\n    coins_part = parts[0].strip()\n    amount_part = parts[1].strip()\n    # Extract the list part using ast.literal_eval for safety\n    coins_str = coins_part.split('=', 1)[1].strip()\n    amount_str = amount_part.split('=', 1)[1].strip()\n    coins = ast.literal_eval(coins_str)\n    amount = int(amount_str)\n    return coins, amount\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read()\n    coins, amount = parse_input(input_data)\n    solution = Solution()\n    result = solution.coinChange(coins, amount)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce a virtual code for the coin change problem, with step-by-step explanation. We must use arrows and structure like Start, Decision, etc. Use dynamic programming approach. Provide step-by-step. Each line: \"虛擬碼步驟 // 解釋\". Use virtual arrow symbols. For DP, we use array dp of length amount+1, initialize dp[0]=0, others to inf. Then iterate amounts from 1 to amount, for each coin, update dp[amt] = min(dp[amt], dp[amt-coin]+1) if amt>=coin. Finally, return dp[amount] if not inf else -1. Provide in virtual pseudocode.\n\nWe need to be careful: the format demands: Start // 程式開始執行\n→ Step 1: ... etc.\n\nWe will output multiple lines accordingly.\n\nAlso ensure to include decision blocks if needed. For DP, we could include Decision: If amount <= 0? But main algorithm uses loops.\n\nWe'll produce a step-by-step:\n\nStart // 程式開始執行\n→ Step 1: 初始化 dp 陣列長度 amount+1，dp[0] = 0，其他設為無限大 // 建立 DP 表\n→ Step 2: 對 amt 從 1 到 amount 迭代 // 遍歷所有金額\n    → Decision: 若 amt >= coin? (for each coin) // 判斷是否能使用該硬幣\n        Yes → Step 3: 更新 dp[amt] = min(dp[amt], dp[amt-coin] + 1) // 更新最少硬幣數\n        No → (跳過)\n→ Step 4: Decision: 若 dp[amount] 為無限大? // 判斷是否可達\n    Yes → Step 5: 回傳 -1 // 無法組合\n    No → Step 6: 回傳 dp[amount] // 返回最少硬幣數\nEnd // 程式執行結束\n\nNeed to mention infinite loops? No.\n\nWe might want to show nested loops: for each amt, for each coin. Provide nested decisions.\n\nLet's produce the virtual code accordingly. Ensure each line uses arrow \"→\" and \"Start\" \"End\" labels. Use indentation maybe with tab? Not needed. Just format.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 dp 陣列長度 amount+1，dp[0] = 0，其他設為無限大 // 建立 DP 表以儲存最少硬幣數  \n→ Step 2: 對 amt 從 1 到 amount 迭代 // 逐一計算每個金額所需的最少硬幣數  \n  → Decision: 如果 amt 大於等於任何 coin? // 判斷是否能使用該硬幣  \n   Yes → Step 3: 更新 dp[amt] = min(dp[amt], dp[amt-coin] + 1) // 若可用，更新為更少的硬幣數  \n   No → (跳過) // 不適用此硬幣，繼續下一個硬幣  \n→ Step 4: Decision: 若 dp[amount] 為無限大? // 判斷是否可達目標金額  \n  Yes → Step 5: 回傳 -1 // 無法組成該金額，返回 -1  \n  No → Step 6: 回傳 dp[amount] // 返回最少硬幣數  \nEnd // 程式執行結束"
    },
    {
      "title": "Find Median from Data Stream",
      "source_file": "Leetcode/leetcode295.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"], [[], [1], [2], [], [3], []]",
          "expected_output": "[null, null, null, 1.5, null, 2.0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,1.5,null,2.0]'\nGot (Norm):      '[null,null,null,1.5,null,2]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, 1.5, null, 2.0]'\nRaw Got:      '[null, null, null, 1.5, null, 2]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport heapq\nimport json\n\nclass MedianFinder:\n    def __init__(self):\n        # 小根堆存放上半部分，maxHeap（大根堆）用負數存放下半部分\n        self.small = []  # max-heap (用負數實現)\n        self.large = []  # min-heap\n\n    def addNum(self, num: int) -> None:\n        # 先將數字放入小根堆（大根堆的負數版本）\n        heapq.heappush(self.small, -num)\n        # 如果兩堆有數且小根堆最大值大於大根堆最小值，需要調整\n        if self.small and self.large and (-self.small[0] > self.large[0]):\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        # 保持兩堆大小差不超過 1\n        if len(self.small) > len(self.large) + 1:\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        elif len(self.large) > len(self.small):\n            val = heapq.heappop(self.large)\n            heapq.heappush(self.small, -val)\n\n    def findMedian(self) -> float:\n        if len(self.small) > len(self.large):\n            return -self.small[0]\n        return (-self.small[0] + self.large[0]) / 2.0\n\ndef parse_input():\n    data = sys.stdin.read().strip()\n    if not data:\n        return [], []\n    # 嘗試將整個輸入視為兩個列表的元組\n    try:\n        cmds, args = ast.literal_eval('(' + data + ')')\n        return cmds, args\n    except Exception:\n        # 失敗則嘗試逐行解析\n        lines = data.splitlines()\n        if len(lines) >= 2:\n            cmds = ast.literal_eval(lines[0].strip())\n            args = ast.literal_eval(lines[1].strip())\n            return cmds, args\n        # 仍失敗則回傳空\n        return [], []\n\ndef main():\n    commands, arguments = parse_input()\n    result = []\n    obj = None\n    for cmd, arg in zip(commands, arguments):\n        if cmd == \"MedianFinder\":\n            obj = MedianFinder()\n            result.append(None)\n        elif cmd == \"addNum\":\n            obj.addNum(arg[0])\n            result.append(None)\n        elif cmd == \"findMedian\":\n            result.append(obj.findMedian())\n        else:\n            # 若有其他命令，視為 None\n            result.append(None)\n    # 輸出為 JSON，將 None 轉成 null\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode for MedianFinder class that supports addNum and findMedian. Likely using two heaps: max-heap for lower half, min-heap for upper half. Maintain size difference <=1. On addNum, insert into appropriate heap. On findMedian, if sizes equal, median is avg of tops; else median is top of bigger heap.\n\nWe output lines with virtual code steps. Format: \"Start // 程式開始執行\" etc.\n\nWe need to produce step-by-step algorithm for class. We need to describe class initialization, adding number, balancing heaps, computing median.\n\nWe must follow format: each line: virtual code step + space + \"// 解釋/說明\". Use arrow, Decision etc.\n\nWe should produce something like:\n\nStart\n→ Step 1: 初始化兩個堆 maxHeap (大根堆), minHeap (小根堆) // 建立兩個空堆\n→ Step 2: 定義 addNum(num) 方法 // 接收數字\n    → Decision: maxHeap 空或 num <= maxHeap.top()?\n        Yes → Insert num into maxHeap // 若 num 小於等於下限\n        No  → Insert num into minHeap // 否則\n    → Step 3: 調整堆大小差距\n        → Decision: maxHeap.size() > minHeap.size()+1?\n            Yes → Move maxHeap.top() to minHeap // 讓大小差不超過1\n        → Decision: minHeap.size() > maxHeap.size()+1?\n            Yes → Move minHeap.top() to maxHeap\n→ Step 4: 定義 findMedian() 方法\n    → Decision: maxHeap.size() == minHeap.size()?\n        Yes → Return (maxHeap.top() + minHeap.top()) / 2.0 // 平均\n        No → Decision: maxHeap.size() > minHeap.size()?\n            Yes → Return maxHeap.top()\n            No  → Return minHeap.top()\nEnd\n\nBut need to use \"→\" for steps. For decision, \"Decision:\".\n\nWe need to ensure each line ends with // explanation. Provide Chinese explanation.\n\nLet's produce line-by-line.\n\nInclude Start and End.\n\nAlso include class definition? Could be step: \"Define MedianFinder class\" etc.\n\nWe may also use \"Step 1:\" etc. But the format doesn't require numbering; just steps.\n\nBut use \"Step 1:\".\n\nOk produce.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: 定義 MedianFinder 類別 // 建立類別容器\n    → Step 2: 在建構子中初始化 maxHeap、minHeap // 大根堆、 小根堆\n        → Step 3: maxHeap ← 空大根堆 // 儲存下半部\n        → Step 4: minHeap ← 空小根堆 // 儲存上半部\n→ Step 5: 定義 addNum(num) 方法 // 插入新數字\n    → Decision: maxHeap 为空 或 num <= maxHeap.top()?\n        Yes → maxHeap.push(num) // 小於等於下半部最大值\n        No  → minHeap.push(num) // 大於上半部最小值\n    → Step 6: 調整堆平衡\n        → Decision: maxHeap.size() > minHeap.size() + 1 ?\n            Yes → minHeap.push(maxHeap.top()); maxHeap.pop() // 把最大值移到上半部\n        → Decision: minHeap.size() > maxHeap.size() + 1 ?\n            Yes → maxHeap.push(minHeap.top()); minHeap.pop() // 把最小值移到下半部\n→ Step 7: 定義 findMedian() 方法 // 計算目前中位數\n    → Decision: maxHeap.size() == minHeap.size() ?\n        Yes → Return (maxHeap.top() + minHeap.top()) / 2.0 // 平均兩個中間值\n        No → Decision: maxHeap.size() > minHeap.size() ?\n            Yes → Return maxHeap.top() // 下半部較多，返回最大值\n            No  → Return minHeap.top() // 上半部較多，返回最小值\nEnd // 程式執行結束\n\nNeed to ensure proper indentation. Provide arrow for decisions.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 MedianFinder 類別 // 建立容納兩堆的類別  \n  → Step 2: 在建構子中初始化 maxHeap、minHeap // 大根堆與小根堆  \n    → Step 3: maxHeap ← 空大根堆 // 儲存下半部元素  \n    → Step 4: minHeap ← 空小根堆 // 儲存上半部元素  \n→ Step 5: 定義 addNum(num) 方法 // 插入新數字  \n  → Decision: maxHeap 為空 或 num <= maxHeap.top() ? // 判斷該放入哪堆  \n    Yes → maxHeap.push(num) // 小於等於下半部最大值，放入大根堆  \n    No  → minHeap.push(num) // 大於上半部最小值，放入小根堆  \n  → Step 6: 調整堆平衡 // 讓兩堆大小差距不超過 1  \n    → Decision: maxHeap.size() > minHeap.size() + 1 ?  \n     Yes → minHeap.push(maxHeap.top()); maxHeap.pop() // 把最大值移到上半部  \n    → Decision: minHeap.size() > maxHeap.size() + 1 ?  \n     Yes → maxHeap.push(minHeap.top()); minHeap.pop() // 把最小值移到下半部  \n→ Step 7: 定義 findMedian() 方法 // 取得目前的中位數  \n  → Decision: maxHeap.size() == minHeap.size() ?  \n    Yes → Return (maxHeap.top() + minHeap.top()) / 2.0 // 平均兩個中間值  \n    No  → Decision: maxHeap.size() > minHeap.size() ?  \n     Yes → Return maxHeap.top() // 下半部較多，回傳最大值  \n     No  → Return minHeap.top() // 上半部較多，回傳最小值  \nEnd // 程式執行結束"
    },
    {
      "title": "Data Stream as Disjoint Intervals",
      "source_file": "Leetcode/leetcode352.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"SummaryRanges\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\"]\n[[], [1], [], [3], [], [7], [], [2], [], [6], []]",
          "expected_output": "[null, null, [[1, 1]], null, [[1, 1], [3, 3]], null, [[1, 1], [3, 3], [7, 7]], null, [[1, 3], [7, 7]], null, [[1, 3], [6, 7]]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,[[1,1]],null,[[1,1],[3,3]],null,[[1,1],[3,3],[7,7]],null,[[1,3],[7,7]],null,[[1,3],[6,7]]]'\nGot (Norm):      '[None,None,[[1,1]],None,[[1,1],[3,3]],None,[[1,1],[3,3],[7,7]],None,[[1,3],[7,7]],None,[[1,3],[6,7]]]'\n--- (Raw) ---\nRaw Expected: '[null, null, [[1, 1]], null, [[1, 1], [3, 3]], null, [[1, 1], [3, 3], [7, 7]], null, [[1, 3], [7, 7]], null, [[1, 3], [6, 7]]]'\nRaw Got:      '[None, None, [[1, 1]], None, [[1, 1], [3, 3]], None, [[1, 1], [3, 3], [7, 7]], None, [[1, 3], [7, 7]], None, [[1, 3], [6, 7]]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass SummaryRanges:\n    def __init__(self):\n        # 儲存 disjoint intervals，格式為 [[start1, end1], [start2, end2], ...]\n        self.intervals = []\n\n    def addNum(self, val: int) -> None:\n        new_start, new_end = val, val\n        merged = []\n        placed = False\n\n        for start, end in self.intervals:\n            if end + 1 < val:\n                # 當前區間完全在 val 的左側\n                merged.append([start, end])\n            elif val + 1 < start:\n                # 當前區間完全在 val 的右側，且 val 尚未插入\n                if not placed:\n                    merged.append([new_start, new_end])\n                    placed = True\n                merged.append([start, end])\n            else:\n                # val 與當前區間有重疊或相鄰，合併\n                new_start = min(new_start, start)\n                new_end = max(new_end, end)\n\n        if not placed:\n            merged.append([new_start, new_end])\n\n        self.intervals = merged\n\n    def getIntervals(self):\n        return self.intervals\n\ndef main():\n    # 讀取兩行輸入：操作名稱列表和對應參數列表\n    data = sys.stdin.read().strip().splitlines()\n    if len(data) < 2:\n        return\n    ops = ast.literal_eval(data[0].strip())\n    args = ast.literal_eval(data[1].strip())\n\n    res = []\n    obj = None\n\n    for op, arg in zip(ops, args):\n        if op == \"SummaryRanges\":\n            obj = SummaryRanges()\n            res.append(None)\n        elif op == \"addNum\":\n            obj.addNum(arg[0] if isinstance(arg, list) else arg)\n            res.append(None)\n        elif op == \"getIntervals\":\n            res.append(obj.getIntervals())\n        else:\n            # 不支援的操作，直接忽略或拋出錯誤\n            res.append(None)\n\n    print(res)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for SummaryRanges class with methods: constructor, addNum, getIntervals. Need to use virtual code arrow notation. Provide explanation per line. No actual code. Provide structure like Start, Steps, Decision. We need to outline algorithm: maintain sorted list of intervals, merging when adding. Let's produce algorithm pseudo-code:\n\n- Initialize intervals list empty.\n- addNum(value):\n  - Find position to insert. For each interval:\n    - If value within interval -> no change.\n    - If value == end+1 -> extend interval end.\n    - If value == start-1 -> extend start.\n    - If value between intervals: create new interval [value, value].\n    - After adjusting, check merging adjacent if needed.\n- getIntervals: return list.\n\nWe'll produce stepwise virtual code: Start, Steps for constructor, addNum, getIntervals. Use Decision nodes for checking conditions.\n\nLet's write lines:\n\nStart\n→ Step 1: Initialize intervals as empty list // 用於儲存 disjoint intervals\n→ End of constructor\n\nFor addNum:\n\nStart addNum\n→ Step 1: If intervals is empty → create new interval [value, value] and insert // 直接新增\n→ Decision: else find insertion point i where intervals[i].end < value ≤ intervals[i+1].start or value < intervals[0].start etc.\n\nWe'll produce generic pseudo:\n\n- For each interval in intervals:\n  - If value < interval.start - 1: // before current interval with gap\n    - Insert new interval before this interval\n    - Break\n  - If value == interval.start - 1: // extend left\n    - interval.start = value\n    - Check merge with previous interval\n    - Break\n  - If interval.start <= value <= interval.end: // already covered\n    - Break\n  - If value == interval.end + 1: // extend right\n    - interval.end = value\n    - Check merge with next interval\n    - Break\n\nAfter loop, if not inserted, append to end.\n\nNeed to produce explanation after each line.\n\nWe'll produce simplified pseudo-lines: use arrow, Decision.\n\nLet's craft final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 定義 SummaryRanges 類別 // 建立一個類別來管理數字流\n    → Constructor: intervals ← 空列表 // 以列表儲存 disjoint intervals\nEnd // SummaryRanges 物件已初始化\n\nStart addNum(value) // 新增一個整數到流中\n    → Decision: intervals 是否為空? // 檢查是否還沒有任何 interval\n        Yes → Step 2: intervals ← [[value, value]] // 空列表時直接新增一個 interval\n        No  → Step 3: i ← 0 // 從第一個 interval 開始檢查\n            → Decision: i < intervals.length? // 是否還有 interval 需要檢查\n                Yes →\n                    → Step 4: cur ← intervals[i] // 取得目前的 interval\n                    → Decision: value < cur.start - 1? // 值在前一個 interval 的左側且有空隙\n                        Yes →\n                            → Step 5: 在位置 i 前插入 [[value, value]] // 新增新 interval\n                            → End // 新增完成\n                    → Decision: value == cur.start - 1? // 值正好在左側邊界\n                        Yes →\n                            → Step 6: cur.start ← value // 伸長左端\n                            → Decision: i > 0 且 intervals[i-1].end + 1 == cur.start? // 是否需要合併前一個 interval\n                                Yes →\n                                    → Step 7: intervals[i-1].end ← cur.end // 合併兩個 interval\n                                    → Step 8: 刪除 intervals[i] // 刪除原本的 interval\n                            → End\n                    → Decision: cur.start ≤ value ≤ cur.end? // 值已被已有 interval 覆蓋\n                        Yes →\n                            → Step 9: End // 不做任何改動\n                    → Decision: value == cur.end + 1? // 值正好在右側邊界\n                        Yes →\n                            → Step 10: cur.end ← value // 伸長右端\n                            → Decision: i < intervals.length-1 且 cur.end + 1 == intervals[i+1].start? // 是否需要合併後一個 interval\n                                Yes →\n                                    → Step 11: cur.end ← intervals[i+1].end // 合併兩個 interval\n                                    → Step 12: 刪除 intervals[i+1] // 刪除後一個 interval\n                            → End\n                    → Step 13: i ← i + 1 // 移到下一個 interval\n                    → Decision: i < intervals.length? // 繼續檢查\n                        Yes → 回到 Decision: i < intervals.length?\n                        No  → Step 14: intervals ← intervals ∪ [[value, value]] // 沒有插入，直接加到最後\n                No  → // 已檢查完所有 interval，值仍未插入\n                    → Step 15: intervals ← intervals ∪ [[value, value]] // 新增新 interval\nEnd // addNum 處理完成\n\nStart getIntervals() // 取得目前所有 interval\n    → Step 16: return intervals // 回傳已排序且 disjoint 的 interval 列表\nEnd // getIntervals 完成\n```"
    },
    {
      "title": "Remove Duplicate Letters",
      "source_file": "Leetcode/leetcode316.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"bcabc\"",
          "expected_output": "\"abc\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'abc'\nGot (Norm):      'sabc'\n--- (Raw) ---\nRaw Expected: '\"abc\"'\nRaw Got:      'sabc'"
        },
        {
          "example_index": 1,
          "input": "s = \"cbacdcbc\"",
          "expected_output": "\"acdb\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'acdb'\nGot (Norm):      'sacdb'\n--- (Raw) ---\nRaw Expected: '\"acdb\"'\nRaw Got:      'sacdb'"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef removeDuplicateLetters(s: str) -> str:\n    \"\"\"\n    Remove duplicate letters so that each letter appears once and only once.\n    The resulting string is the smallest in lexicographical order.\n    \"\"\"\n    stack = []\n    seen = set()\n    # Record the last occurrence index of each character\n    last_occurrence = {c: i for i, c in enumerate(s)}\n\n    for i, c in enumerate(s):\n        if c not in seen:\n            # While the current character is smaller than the stack's top\n            # and the stack's top appears later again, we can pop it\n            while stack and c < stack[-1] and i < last_occurrence[stack[-1]]:\n                seen.discard(stack.pop())\n            stack.append(c)\n            seen.add(c)\n\n    return ''.join(stack)\n\ndef main() -> None:\n    # Read all input data\n    data = sys.stdin.read()\n    # Extract all alphabetic characters (handles inputs like `s = \"bcabc\"` or `bcabc`)\n    s = ''.join(re.findall(r'[a-zA-Z]', data))\n    if not s:\n        return\n    result = removeDuplicateLetters(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation. The algorithm: classic problem: remove duplicate letters to get smallest lexicographic string. Steps: Count frequency of each char; use stack (list) and visited set. Iterate chars, decrement freq, if visited skip. While stack non-empty and current char < top and top appears later (freq[top]>0), pop and mark not visited. Push current and mark visited. At end join stack.\n\nWe produce virtual code lines with arrow and explanations. Use Start, End, Decision. Provide each line.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: 定義 freq[26] 為每個字母出現次數 // 計算字母頻率\n→ Step 2: 初始化空堆疊 stack 與空集合 visited // 用於構建結果與判斷是否已使用\n→ Decision: 遍歷字符串 s 中的每個字符 c // 逐字處理\n    → Step 3: freq[c]-- // 每次遇到字母，頻率減一\n    → Decision: c 已在 visited? // 若已使用則跳過\n        Yes → Continue // 跳到下一個字母\n        No  →\n            → Decision: stack 非空且 c < stack.top() 且 freq[stack.top()] > 0? // 可否彈出較大字母\n                Yes → Step 4: stack.pop() 並從 visited 移除 popped // 把後續仍可出現的字母彈回\n                    → Continue 循環檢查條件\n                No  →\n                    → Step 5: stack.push(c) 並加入 visited // 將當前字母加入結果\nEnd // 將堆疊內容拼接為字符串並輸出結果\n\nBut we need each line with arrow and explanation. Use \"→\" for sequential. For loops and decisions, we can use Decision and arrow indentation.\n\nWe need to produce each line as separate, no actual code, just pseudo-steps.\n\nLet's create:\n\nStart // 程式開始執行\n→ Step 1: 計算字母頻率 freq // 初始化每個字母在 s 中出現的次數\n→ Step 2: 建立空堆疊 stack 與空集合 visited // 用於儲存結果順序與已使用字母\n→ Decision: 對 s 中每個字符 c 執行以下流程 // 開始遍歷\n    → Step 3: freq[c]-- // 將該字符的剩餘頻率減一\n    → Decision: c 已存在於 visited? // 若已使用則不處理\n        Yes → Continue // 跳過此字符\n        No  →\n            → Decision: stack 非空且 c < stack.top() 且 freq[stack.top()] > 0? // 判斷是否可彈出更大的字母\n                Yes → Step 4: stack.pop() 並從 visited 刪除 popped // 彈出並放回可後續使用\n                    → Continue // 重新檢查堆疊條件\n                No  →\n                    → Step 5: stack.push(c) 並將 c 加入 visited // 將當前字符加入結果\nEnd // 將 stack 中的字符拼接成字串並輸出\n\nWe might also need a final step to output.\n\nBut the requirement: produce virtual code and explanations. Each line has \"虛擬碼步驟\" + space + \"// 解釋/說明\". Must use arrows etc. Should include Start, End, Decision.\n\nWe must not output actual code. Use \"Step 1:\", \"Step 2:\" etc.\n\nBut maybe we can use \"Step 1:\" with arrow \"→\".\n\nLet's produce final answer. Ensure each line is separate line.\n\nLet's include the final join step.\n\nAdd Step 6: result = join(stack) // 將堆疊元素拼接為最終字串\n\nThen End.\n\nBut we need End after output. So:\n\n→ Step 6: result = join(stack) // 將堆疊內容連接成結果字串\n→ Step 7: 輸出 result // 給使用者回傳最小字母序列\nEnd // 程式結束\n\nBut we must maintain proper indentation for decision branches. Use indent via spaces.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算字母頻率 freq // 初始化每個字母在 s 中出現的次數  \n→ Step 2: 建立空堆疊 stack 與空集合 visited // 用於儲存結果順序與已使用字母  \n→ Decision: 對 s 中每個字符 c 執行以下流程 // 開始遍歷  \n    → Step 3: freq[c]-- // 將該字符的剩餘頻率減一  \n    → Decision: c 已存在於 visited? // 若已使用則不處理  \n        Yes → Continue // 跳過此字符  \n        No →  \n            → Decision: stack 非空且 c < stack.top() 且 freq[stack.top()] > 0? // 判斷是否可彈出更大的字母  \n                Yes → Step 4: stack.pop() 並從 visited 刪除 popped // 彈出並放回可後續使用  \n                    → Continue // 重新檢查堆疊條件  \n                No →  \n                    → Step 5: stack.push(c) 並將 c 加入 visited // 將當前字符加入結果  \n→ Step 6: result = join(stack) // 將堆疊內容連接成結果字串  \n→ Step 7: 輸出 result // 給使用者回傳最小字母序列  \nEnd // 程式結束"
    },
    {
      "title": "K^th Smallest Element in a Sorted Matrix",
      "source_file": "Leetcode/leetcode378.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8",
          "expected_output": "13",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpgxwab4hv.py\", line 39, in parse_input\n    parsed = eval(data, {})\n             ^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8\n           ^\nSyntaxError: invalid syntax\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"/tmp/tmpgxwab4hv.py\", line 53, in <module>\n    main()\n  File \"/tmp/tmpgxwab4hv.py\", line 48, in main\n    matrix, k = parse_input(raw)\n                ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpgxwab4hv.py\", line 42, in parse_input\n    raise ValueError(\"Input format not recognized\") from e\nValueError: Input format not recognized"
        },
        {
          "example_index": 1,
          "input": "matrix = [[-5]], k = 1",
          "expected_output": "-5",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp_prpa8dh.py\", line 39, in parse_input\n    parsed = eval(data, {})\n             ^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    matrix = [[-5]], k = 1\n           ^\nSyntaxError: invalid syntax\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"/tmp/tmp_prpa8dh.py\", line 53, in <module>\n    main()\n  File \"/tmp/tmp_prpa8dh.py\", line 48, in main\n    matrix, k = parse_input(raw)\n                ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp_prpa8dh.py\", line 42, in parse_input\n    raise ValueError(\"Input format not recognized\") from e\nValueError: Input format not recognized"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef kth_smallest(matrix, k):\n    n = len(matrix)\n    low, high = matrix[0][0], matrix[n - 1][n - 1]\n\n    while low <= high:\n        mid = (low + high) // 2\n        count = 0\n        row, col = n - 1, 0  # start from bottom-left\n        while row >= 0 and col < n:\n            if matrix[row][col] <= mid:\n                count += row + 1   # all elements above in this column are <= mid\n                col += 1\n            else:\n                row -= 1\n        if count >= k:\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low\n\ndef parse_input(data: str):\n    \"\"\"\n    Parses an input string of the form:\n        matrix = [[...]], k = ...\n    and returns the matrix and k as Python objects.\n    \"\"\"\n    pattern = r'matrix\\s*=\\s*(\\[[^\\]]*\\]),\\s*k\\s*=\\s*(\\d+)'\n    match = re.search(pattern, data)\n    if match:\n        matrix_str, k_str = match.group(1), match.group(2)\n        matrix = eval(matrix_str, {})\n        k = int(k_str)\n        return matrix, k\n    # Fallback: try to evaluate the whole string as a dict\n    try:\n        parsed = eval(data, {})\n        return parsed['matrix'], int(parsed['k'])\n    except Exception as e:\n        raise ValueError(\"Input format not recognized\") from e\n\ndef main():\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n    matrix, k = parse_input(raw)\n    result = kth_smallest(matrix, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line, with explanations. Need to solve problem: given n x n sorted matrix rows and columns ascending, find kth smallest element. Use binary search on value range or min-heap. Memory better than O(n^2). We can do binary search over value range and count elements <= mid. That uses O(1) memory. Complexity O(n log(max-min)). Provide virtual code steps.\n\nLet's produce:\n\nStart\n→ Step: read matrix and k\n→ Step: find min and max in matrix\n→ Decision: while low <= high\n    → Step: mid = low + (high-low)/2\n    → Step: count = countLessEqual(matrix, mid)\n    → Decision: if count >= k\n        Yes → Step: high = mid - 1\n        No  → Step: low = mid + 1\n→ Step: return low\n\nNeed to detail countLessEqual: iterate rows, use binary search or pointer. But simpler: pointer from bottom-left: count elements <= mid. Complexity O(n). Provide steps.\n\nSo we produce lines:\n\nStart // start program\n→ Step 1: Read matrix n x n and integer k // input\n→ Step 2: low = matrix[0][0] // smallest element\n→ Step 3: high = matrix[n-1][n-1] // largest element\n→ Decision: while low <= high\n    → Step 4: mid = low + (high - low) / 2 // middle value\n    → Step 5: count = 0 // initialize counter\n    → Step 6: row = n - 1 // start from bottom row\n    → Step 7: col = 0 // start from left column\n    → Decision: while row >= 0 and col < n\n        → Step 8: if matrix[row][col] <= mid\n            Yes → Step 9: count += row + 1 // all elements in this column above are <= mid\n            Yes → Step 10: col += 1 // move right\n            No  → Step 11: row -= 1 // move up\n    → Decision: if count >= k\n        Yes → Step 12: high = mid - 1 // kth element is <= mid, search left\n        No  → Step 13: low = mid + 1 // kth element > mid, search right\n→ Step 14: return low // low is kth smallest\nEnd // end program\n\nNeed to ensure arrow usage: Use \"→\" for steps, \"Decision:\" with indentation. For nested decision, use indentation.\n\nLet's produce formatted output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取 n×n 的矩陣與整數 k // 取得輸入資料  \n→ Step 2: low ← matrix[0][0] // 找到矩陣中最小的元素  \n→ Step 3: high ← matrix[n-1][n-1] // 找到矩陣中最大的元素  \n→ Decision: while low ≤ high // 在值域內做二分搜尋  \n  → Step 4: mid ← low + (high - low) / 2 // 計算中間值  \n  → Step 5: count ← 0 // 初始化小於等於 mid 的元素數量  \n  → Step 6: row ← n - 1 // 從最下列開始  \n  → Step 7: col ← 0 // 從最左列開始  \n  → Decision: while row ≥ 0 and col < n // 輪流掃描矩陣  \n     → Step 8: if matrix[row][col] ≤ mid  \n       Yes → Step 9: count ← count + row + 1 // 這列所有上方元素皆 ≤ mid  \n       Yes → Step 10: col ← col + 1 // 右移至下一列  \n       No  → Step 11: row ← row - 1 // 上移至上一列  \n  → Decision: if count ≥ k  \n     Yes → Step 12: high ← mid - 1 // kth 小於等於 mid，搜尋左側  \n     No  → Step 13: low ← mid + 1 // kth 大於 mid，搜尋右側  \n→ Step 14: return low // low 即為矩陣中第 k 小的元素  \nEnd // 程式執行結束"
    },
    {
      "title": "Kth Largest Element in a Stream",
      "source_file": "Leetcode/leetcode703.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"KthLargest\", \"add\", \"add\", \"add\", \"add\", \"add\"], [[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]",
          "expected_output": "[null, 4, 5, 5, 8, 8]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp8uzicecq.py\", line 47, in <module>\n    main()\n  File \"/tmp/tmp8uzicecq.py\", line 39, in main\n    results.append(obj.add(arg))\n                   ^^^^^^^^^^^^\n  File \"/tmp/tmp8uzicecq.py\", line 16, in add\n    heapq.heappush(self.min_heap, val)\nTypeError: '<' not supported between instances of 'list' and 'int'"
        },
        {
          "example_index": 1,
          "input": "[\"KthLargest\", \"add\", \"add\", \"add\", \"add\"], [[4, [7, 7, 7, 7, 8, 3]], [2], [10], [9], [9]]",
          "expected_output": "[null, 7, 7, 7, 8]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpm6cw7uok.py\", line 47, in <module>\n    main()\n  File \"/tmp/tmpm6cw7uok.py\", line 39, in main\n    results.append(obj.add(arg))\n                   ^^^^^^^^^^^^\n  File \"/tmp/tmpm6cw7uok.py\", line 16, in add\n    heapq.heappush(self.min_heap, val)\nTypeError: '<' not supported between instances of 'list' and 'int'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport heapq\nimport json\n\nclass KthLargest:\n    def __init__(self, k, nums):\n        \"\"\"初始化 k 和堆，將 nums 中的每個數值加入堆中\"\"\"\n        self.k = k\n        self.min_heap = []\n        for num in nums:\n            self.add(num)\n\n    def add(self, val):\n        \"\"\"把新分數加入堆，保持堆長度不超過 k，並回傳目前第 k 高的分數\"\"\"\n        heapq.heappush(self.min_heap, val)\n        if len(self.min_heap) > self.k:\n            heapq.heappop(self.min_heap)\n        return self.min_heap[0]\n\ndef main():\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n    # 把整段輸入包起來成為合法的 python 表達式，方便使用 ast.literal_eval 解析\n    wrapped = '[' + raw_input + ']'\n    ops, args = ast.literal_eval(wrapped)\n\n    results = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"KthLargest\":\n            # 第一次建立物件，arg 是 [k, nums]\n            k, nums = arg\n            obj = KthLargest(k, nums)\n            results.append(None)  # 根據題目輸出 null\n        elif op == \"add\":\n            # 呼叫 add 方法並儲存回傳值\n            results.append(obj.add(arg))\n        else:\n            raise ValueError(f\"未知操作 {op}\")\n\n    # 使用 json.dumps 以把 None 轉成 null，符合範例輸出格式\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for implementing KthLargest class with methods KthLargest(k, nums) and add(val). Use heap min-heap of size k. Outline steps: Initialize min-heap, push initial nums (if heap size < k push else if val > heap top push pop). For add: push val, if heap size > k pop, return heap top. Provide explanation each line.\n\nWe'll output with Start, Decision, etc. Must be \"逐行\". Use 虛擬碼 step. Let's produce something like:\n\nStart\n→ Step 1: 建立空的最小堆 // 用於儲存前k個最高分\n→ Step 2: 設定屬性 k = k // 目標排名\n→ Decision: nums 是否為空? // 若有初始分數\n   Yes → … else skip\n\nWe can just treat initialization of nums loop.\n\nOk let's craft.\n\nRemember to use 'Step' numbering maybe not required but example had 'Step 1:' etc. We'll include.\n\nOk produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立一個空的最小堆 Heap // 用來保持目前最高的 k 個分數  \n→ Step 2: 設定屬性 target = k // 需要追蹤的排名  \n→ Step 3: 設定屬性 heap = Heap // 將堆儲存為物件屬性  \n→ Step 4: 循環處理輸入陣列 nums  \n   → Decision: nums 是否為空? // 若沒有初始分數則跳過  \n   →   Yes → End // 直接結束初始化  \n   →   No  → 迴圈: 對每個 score in nums  \n      →   Step 5: 追加 score 到堆中 // 把新分數加入堆  \n      →   Decision: 堆大小 > target? // 堆已超過 k 個元素  \n           →   Yes → Step 6: 從堆中移除最小元素 // 保持堆長度為 k  \n           →   No  → End  \n→ Step 7: 針對 add(val) 方法  \n   → Decision: 堆是否為空? // 若堆尚未建立  \n   →   Yes → Step 8: 建立堆並把 val 插入 // 只在第一次 add 時使用  \n   →   No  → Step 9: 將 val 插入堆 // 新分數加入  \n   → Decision: 堆大小 > target? // 新增後堆長度是否超過 k  \n   →   Yes → Step 10: 移除最小元素 // 保持堆長度為 k  \n   →   No  → End  \n→ Step 11: 回傳堆頂元素 // 最小堆頂即為當前第 k 高分  \nEnd // 程式執行結束"
    },
    {
      "title": "Implement Trie (Prefix Tree)",
      "source_file": "Leetcode/leetcode208.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "['Trie', 'insert', 'search', 'search', 'startsWith', 'insert', 'search'], [[], ['apple'], ['apple'], ['app'], ['app'], ['app'], ['app']]",
          "expected_output": "[null, null, true, false, true, null, true]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,true,false,true,null,true]'\nGot (Norm):      '[None,None,True,False,True,None,True]'\n--- (Raw) ---\nRaw Expected: '[null, null, true, false, true, null, true]'\nRaw Got:      '[None, None, True, False, True, None, True]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass TrieNode:\n    \"\"\"節點結構，包含子節點映射與是否為單詞結束的標記。\"\"\"\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass Trie:\n    \"\"\"前綴樹實現。\"\"\"\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        \"\"\"將單詞插入前綴樹。\"\"\"\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                node.children[ch] = TrieNode()\n            node = node.children[ch]\n        node.is_end = True\n\n    def search(self, word: str) -> bool:\n        \"\"\"搜尋單詞是否已存在。\"\"\"\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return node.is_end\n\n    def startsWith(self, prefix: str) -> bool:\n        \"\"\"判斷是否存在以 prefix 為前綴的單詞。\"\"\"\n        node = self.root\n        for ch in prefix:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return True\n\ndef main() -> None:\n    \"\"\"主函式，從標準輸入讀取命令與參數，執行並輸出結果。\"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入為兩個列表的元組，例如 \"['Trie', 'insert'], [[], ['a']]\" 會轉成\n    # ('Trie', 'insert'), ([], ['a'])\n    try:\n        commands, args_list = ast.literal_eval(f\"({data})\")\n    except Exception as e:\n        # 若解析失敗，直接輸出空列表\n        print([])\n        return\n\n    trie = None\n    results = []\n\n    for cmd, args in zip(commands, args_list):\n        if cmd == 'Trie':\n            trie = Trie()\n            results.append(None)\n        elif cmd == 'insert':\n            trie.insert(args[0])\n            results.append(None)\n        elif cmd == 'search':\n            results.append(trie.search(args[0]))\n        elif cmd == 'startsWith':\n            results.append(trie.startsWith(args[0]))\n        else:\n            # 若未知命令，記錄 None\n            results.append(None)\n\n    # 輸出結果列表\n    print(results)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for a Trie implementation, line by line, with explanations. Use virtual code style as described. Use arrows and decision blocks. We'll need steps for class initialization, insert, search, startsWith. It's conceptual, not actual code. We'll produce pseudocode lines with explanation comments.\n\nWe need to use the format: \"虛擬碼步驟 // 解釋/說明\". Each line should have that. Use arrows →. The structure includes Start, End, Decision.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 定義 TrieNode 類別，包含 children 映射與 isEnd 標記 // 建立節點結構\n→ Step 2: 定義 Trie 類別，包含 root 節點 // 初始化 Trie\n→ Step 3: Trie() 初始化 root 為新 TrieNode // 建構子\n→ Step 4: insert(word) // 開始插入單詞\n    → Step 5: curr ← root // 從根節點開始\n    → Step 6: 對於每個字母 c 在 word 中\n        → Decision: curr.children 包含 c? // 檢查子節點是否存在\n            Yes → curr ← curr.children[c] // 移動到已存在子節點\n            No  → curr.children[c] ← 新 TrieNode(); curr ← curr.children[c] // 創建並移動\n    → Step 7: curr.isEnd ← true // 標記單詞結束\n→ Step 8: search(word) // 開始搜尋單詞\n    → Step 9: curr ← root\n    → Step 10: 對於每個字母 c 在 word 中\n        → Decision: curr.children 包含 c? // 檢查子節點是否存在\n            Yes → curr ← curr.children[c] // 移動\n            No  → Return false // 不存在，直接返回 false\n    → Step 11: Return curr.isEnd // 如果到達結尾並且是終點，返回 true\n→ Step 12: startsWith(prefix) // 開始判斷前綴\n    → Step 13: curr ← root\n    → Step 14: 對於每個字母 c 在 prefix 中\n        → Decision: curr.children 包含 c?\n            Yes → curr ← curr.children[c]\n            No  → Return false\n    → Step 15: Return true // 所有字母都存在，表示有前綴\nEnd // 程式執行結束\n\nBut we need to ensure each line is \"虛擬碼步驟 // 解釋\". Also arrows: Use \"→\". Use \"Decision:\" lines.\n\nWe can format as:\n\nStart // 程式開始執行\n→ Step 1: 定義 TrieNode 類別，包含 children 映射與 isEnd 標記 // 建立節點結構\n→ Step 2: 定義 Trie 類別，包含 root 節點 // 初始化 Trie\n→ Step 3: Trie() 初始化 root 為新 TrieNode // 建構子\n→ Step 4: insert(word) // 開始插入單詞\n    → Step 5: curr ← root // 從根節點開始\n    → Step 6: 對於每個字母 c 在 word 中\n        → Decision: curr.children 包含 c? // 檢查子節點是否存在\n            Yes → curr ← curr.children[c] // 移動到已存在子節點\n            No  → curr.children[c] ← 新 TrieNode(); curr ← curr.children[c] // 創建並移動\n    → Step 7: curr.isEnd ← true // 標記單詞結束\n→ Step 8: search(word) // 開始搜尋單詞\n    → Step 9: curr ← root\n    → Step 10: 對於每個字母 c 在 word 中\n        → Decision: curr.children 包含 c?\n            Yes → curr ← curr.children[c]\n            No  → Return false\n    → Step 11: Return curr.isEnd\n→ Step 12: startsWith(prefix) // 開始判斷前綴\n    → Step 13: curr ← root\n    → Step 14: 對於每個字母 c 在 prefix 中\n        → Decision: curr.children 包含 c?\n            Yes → curr ← curr.children[c]\n            No  → Return false\n    → Step 15: Return true\nEnd // 程式執行結束\n\nWe should ensure the lines with indentation or substeps still follow \"虛擬碼步驟 // 解釋\". The example shows indentation inside Decision: blocks. We need to maintain that.\n\nThus each line is: \"→ Step ...\" etc. The \"Decision:\" line: \"→ Decision: if ...\" The sub-lines: \"Yes → ...\", \"No → ...\". Let's adopt that.\n\nWe'll output each line with // comment.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 TrieNode 類別，包含 children 映射與 isEnd 標記 // 建立節點結構  \n→ Step 2: 定義 Trie 類別，包含 root 節點 // 初始化 Trie  \n→ Step 3: Trie() 初始化 root 為新 TrieNode // 建構子  \n\n→ Step 4: insert(word) // 開始插入單詞  \n    → Step 5: curr ← root // 從根節點開始  \n    → Step 6: 對於每個字母 c 在 word 中  \n        → Decision: curr.children 包含 c? // 檢查子節點是否存在  \n            Yes → curr ← curr.children[c] // 移動到已存在子節點  \n            No  → curr.children[c] ← 新 TrieNode(); curr ← curr.children[c] // 創建並移動  \n    → Step 7: curr.isEnd ← true // 標記單詞結束  \n\n→ Step 8: search(word) // 開始搜尋單詞  \n    → Step 9: curr ← root // 從根節點開始  \n    → Step 10: 對於每個字母 c 在 word 中  \n        → Decision: curr.children 包含 c? // 檢查子節點是否存在  \n            Yes → curr ← curr.children[c] // 移動  \n            No  → Return false // 不存在，直接返回 false  \n    → Step 11: Return curr.isEnd // 若到達結尾且是終點，返回 true  \n\n→ Step 12: startsWith(prefix) // 開始判斷前綴  \n    → Step 13: curr ← root // 從根節點開始  \n    → Step 14: 對於每個字母 c 在 prefix 中  \n        → Decision: curr.children 包含 c? // 檢查子節點是否存在  \n            Yes → curr ← curr.children[c] // 移動  \n            No  → Return false // 不存在，直接返回 false  \n    → Step 15: Return true // 所有字母都存在，表示有前綴  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Implement Rand10() Using Rand7()",
      "source_file": "Leetcode/leetcode470.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 1",
          "expected_output": "[2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2]'\nGot (Norm):      '[8]'\n--- (Raw) ---\nRaw Expected: '[2]'\nRaw Got:      '[8]'"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[2,8]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,8]'\nGot (Norm):      '[4,7]'\n--- (Raw) ---\nRaw Expected: '[2,8]'\nRaw Got:      '[4, 7]'"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "[3,8,10]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,8,10]'\nGot (Norm):      '[5,8,1]'\n--- (Raw) ---\nRaw Expected: '[3,8,10]'\nRaw Got:      '[5, 8, 1]'"
        }
      ],
      "generated_code": "import sys\nimport random\n\n# 假設 rand7() 由題目提供。為了示範，我們用 random 模組實作。\ndef rand7() -> int:\n    \"\"\"返回 1~7 的均勻隨機整數（示範用）。\"\"\"\n    return random.randint(1, 7)\n\nclass Solution:\n    def rand10(self) -> int:\n        \"\"\"\n        生成 1~10 的均勻隨機整數。\n        方法：用兩次 rand7() 合併產生 1~49 的均勻分布，\n              只接受 1~40，將其映射到 1~10；超出則重試。\n        \"\"\"\n        while True:\n            # 兩次 rand7() 合併成 1~49\n            num = (rand7() - 1) * 7 + rand7()  # 1~49\n            if num <= 40:\n                return 1 + (num - 1) % 10  # 轉換到 1~10\n\ndef main():\n    # 讀取輸入，例如 \"n = 3\"\n    data = sys.stdin.read().strip()\n    # 找出所有整數，假設輸入格式正確\n    nums = [int(s) for s in data.split() if s.isdigit()]\n    n = nums[0] if nums else 0\n\n    solution = Solution()\n    results = [solution.rand10() for _ in range(n)]\n    print(results)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code steps, line by line, with comments. Must not include actual code. Just structure with arrows and decisions. For generating rand10 from rand7. Typical solution: use 7*7=49 range, pick 1-40 mapping to 1-10. If >40, repeat. Implementation: generate two rand7, compute (a-1)*7 + b to get 1-49. If <=40, return (num-1)%10 +1. Else repeat.\n\nWe need virtual steps describing that.\n\nLet's produce:\n\nStart\n→ Step 1: Repeat loop\n    → Step 2: Call rand7() → assign to a\n    → Step 3: Call rand7() → assign to b\n    → Step 4: Compute num = (a-1)*7 + b // 1-49\n    → Decision: If num <= 40?\n        Yes → Step 5: Return (num-1)%10 + 1 // uniform 1-10\n        No  → Step 6: Go back to Step 1 // discard and retry\nEnd\n\nWe need to follow format: each line has \"虛擬碼步驟 // 解釋\". Use arrows.\n\nLet's format.\n\nAlso need to include Start and End lines. Use \"Start\" and \"End\".\n\nWe can include indentation or just arrows. Use \"→\" to indicate next step.\n\nSo:\n\nStart // 程式開始執行\n→ Step 1: Loop開始 // 重複生成直至得到有效數字\n    → Step 2: a ← rand7() // 取得第一個隨機數\n    → Step 3: b ← rand7() // 取得第二個隨機數\n    → Step 4: num ← (a-1)*7 + b // 合併成 1~49 的數字\n    → Decision: 如果 num <= 40? // 檢查是否在可接受範圍\n        Yes → Step 5: Return (num-1) mod 10 + 1 // 轉換為 1~10\n        No  → Step 6: 循環回 Step 1 // 超過 40 則重試\nEnd // 程式執行結束\n\nBut note formatting: we must keep \"虛擬碼步驟\" and comment after space. For decision, we need \"Decision: 如果 num <= 40? //\".\n\nWe need to ensure each line has a single line. We can indent nested steps with tab? Use spaces. Use arrow \"→\" before each step. For decisions, use \"Decision:\" line, then nested lines with indentation and arrow. Provide comments.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Loop開始 // 重複生成直至得到有效數字\n    → Step 2: a ← rand7() // 取得第一個隨機數\n    → Step 3: b ← rand7() // 取得第二個隨機數\n    → Step 4: num ← (a-1)*7 + b // 合併成 1~49 的數字\n    → Decision: 如果 num <= 40? // 檢查是否在可接受範圍\n        Yes → Step 5: Return (num-1) mod 10 + 1 // 轉換為 1~10\n        No  → Step 6: 循環回 Step 1 // 超過 40 則重試\nEnd // 程式執行結束"
    },
    {
      "title": "Reverse Integer",
      "source_file": "Leetcode/leetcode7.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "x = -123",
          "expected_output": "-321",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '-321'\nGot (Norm):      '0'\n--- (Raw) ---\nRaw Expected: '-321'\nRaw Got:      '0'"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef reverse(x: int) -> int:\n    \"\"\"\n    逆轉 32 位有符號整數的各位，若溢出則返回 0。\n    \"\"\"\n    INT_MAX = 2**31 - 1\n    INT_MIN = -2**31\n\n    rev = 0\n    while x != 0:\n        pop = x % 10      # 取得最低位\n        x //= 10          # 去掉最低位\n\n        # 檢查正溢位\n        if rev > INT_MAX // 10 or (rev == INT_MAX // 10 and pop > 7):\n            return 0\n        # 檢查負溢位\n        if rev < INT_MIN // 10 or (rev == INT_MIN // 10 and pop < -8):\n            return 0\n\n        rev = rev * 10 + pop\n    return rev\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 從輸入中尋找第一個整數（支持 'x = 123' 等格式）\n    match = re.search(r'-?\\d+', data)\n    if not match:\n        print(0)\n    else:\n        num = int(match.group())\n        result = reverse(num)\n        print(result)",
      "virtual_code": "Thinking...\nWe need produce pseudo-code lines with explanation, using Start, End, Decision, arrow. Use lines: Start, get sign, handle negative. Reverse digits, using overflow check without 64-bit. Approach: use 32-bit int, check overflow before multiply/add. We can detect overflow: if rev > (INT_MAX - digit)/10 then overflow.\n\nWe must simulate 32-bit signed boundaries: INT_MAX=2147483647, INT_MIN=-2147483648. We handle negative by storing sign.\n\nPseudo steps: Start, Input x. Set sign = (x < 0) ? -1 : 1. Set absX = abs(x) but careful with INT_MIN. But if x == INT_MIN, absX overflows. We can handle by using sign separately: use unsigned? But we cannot use 64-bit. But we can take absolute value by converting to int? Actually we can process digits by taking abs value via x negative? Approach: we can process by negative number approach: For negative, we can keep negative rev and subtract digits. But simpler: treat x as int; use long? can't. But we can process by while x != 0: pop = x % 10; x = x / 10; rev = rev*10 + pop; But we need to check overflow before updating rev.\n\nWe can use sign variable and treat rev as positive, then apply sign at end.\n\nEdge case INT_MIN: its absolute value can't fit. But we can use sign and pop via x % 10 will give negative digits for negative numbers? In many languages, -123 % 10 = -3? In C? In Java, -123 % 10 = -3. So we could use this.\n\nSimpler: Use approach where we always work with sign of rev. Let rev=0; While x != 0: pop = x % 10; x /= 10; // integer division toward zero. Then check overflow: If rev > INT_MAX/10 or (rev == INT_MAX/10 and pop > 7) return 0; same for negative: If rev < INT_MIN/10 or (rev == INT_MIN/10 and pop < -8) return 0; Then rev = rev*10 + pop; At the end return rev.\n\nThis handles INT_MIN.\n\nWe'll produce pseudocode accordingly.\n\nLet's produce lines:\n\nStart\n→ Step 1: x ← input //取得原始整數\n→ Step 2: rev ← 0 //初始化反轉結果\n→ Decision: 如果 x 為 0? //若為 0 直接回傳\n    Yes → Step 3: return 0\n    No  →\n→ Loop: While x ≠ 0 //開始處理每個位數\n    → Step 4: pop ← x % 10 //取得最低位數\n    → Step 5: x ← x / 10 //去除最低位\n    → Decision: 如果 rev > INT_MAX/10 或 (rev = INT_MAX/10 且 pop > 7)? //檢查正溢位\n        Yes → Step 6: return 0\n        No  →\n    → Decision: 如果 rev < INT_MIN/10 或 (rev = INT_MIN/10 且 pop < -8)? //檢查負溢位\n        Yes → Step 7: return 0\n        No  →\n    → Step 8: rev ← rev * 10 + pop //累加位數\n→ EndLoop\n→ Step 9: return rev //回傳反轉後的值\nEnd\n\nBut we need to use arrows and decisions properly.\n\nAlso need \"→ Decision:\" lines with indentation. Use indentation as in sample: two spaces after Decision. And Yes/No arrows.\n\nLet's craft final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: x ← input // 取得原始整數  \n→ Step 2: rev ← 0 // 初始化反轉結果  \n→ Decision: 如果 x 為 0? // 若為 0 直接回傳  \n  Yes → Step 3: return 0 // 回傳 0  \n  No → // 進行反轉流程  \n    → While x ≠ 0 // 開始處理每個位數  \n      → Step 4: pop ← x % 10 // 取得最低位數  \n      → Step 5: x ← x / 10 // 去除最低位  \n      → Decision: 如果 rev > INT_MAX/10 或 (rev = INT_MAX/10 且 pop > 7)? // 檢查正溢位  \n        Yes → Step 6: return 0 // 溢位，返回 0  \n        No → // 仍可繼續  \n           → Decision: 如果 rev < INT_MIN/10 或 (rev = INT_MIN/10 且 pop < -8)? // 檢查負溢位  \n             Yes → Step 7: return 0 // 溢位，返回 0  \n             No → // 仍可繼續  \n                 → Step 8: rev ← rev * 10 + pop // 累加位數  \n      → EndWhile // 位數處理完畢  \n→ Step 9: return rev // 回傳反轉後的整數  \nEnd // 程式執行結束"
    },
    {
      "title": "Word Ladder II",
      "source_file": "Leetcode/leetcode126.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
          "expected_output": "[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmphbl5uyv_.py\", line 52, in <module>\n    exec(data, globals())\n  File \"<string>\", line 1\n    beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\n    ^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]",
          "expected_output": "[]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpcmylmsdd.py\", line 52, in <module>\n    exec(data, globals())\n  File \"<string>\", line 1\n    beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\n    ^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "import sys\nimport json\nfrom collections import defaultdict, deque\n\nclass Solution:\n    def findLadders(self, beginWord, endWord, wordList):\n        wordSet = set(wordList)\n        if endWord not in wordSet:\n            return []\n\n        # BFS to find the shortest path lengths and parents mapping\n        layer = {beginWord: 0}\n        parents = defaultdict(list)\n        queue = deque([beginWord])\n\n        while queue:\n            word = queue.popleft()\n            step = layer[word]\n            for i in range(len(word)):\n                for c in 'abcdefghijklmnopqrstuvwxyz':\n                    new_word = word[:i] + c + word[i+1:]\n                    if new_word in wordSet:\n                        if new_word not in layer:\n                            layer[new_word] = step + 1\n                            queue.append(new_word)\n                            parents[new_word].append(word)\n                        elif layer[new_word] == step + 1:\n                            parents[new_word].append(word)\n\n        # If endWord was never reached, return empty list\n        if endWord not in parents:\n            return []\n\n        # DFS to reconstruct all shortest paths\n        res = []\n\n        def dfs(path, word):\n            if word == beginWord:\n                res.append(path[::-1])\n                return\n            for prev in parents[word]:\n                dfs(path + [prev], prev)\n\n        dfs([endWord], endWord)\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if data:\n        # The input is expected to be a valid Python expression that defines\n        # beginWord, endWord, and wordList. Execute it safely.\n        exec(data, globals())\n        solution = Solution()\n        result = solution.findLadders(beginWord, endWord, wordList)\n        # Output in JSON format (double quotes)\n        print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to produce pseudocode (virtual code) line by line with explanation comments after space. The pseudocode should solve the Word Ladder II problem (return all shortest transformation sequences). Need to provide a step-by-step algorithm, probably using BFS to find shortest paths, then DFS/backtracking to reconstruct paths, or use BFS with parent mapping. The user asks to produce virtual code with arrow syntax and decision nodes.\n\nWe must not output actual code; only virtual steps.\n\nWe need to include Start, End, Decision: etc. The code should be step-by-step.\n\nWe can design steps: Preprocess wordList into set for O(1) lookup. If endWord not in set, return empty. Use BFS to find levels, record parents. BFS queue; visited set. For each current word, generate all neighbor words by changing each letter. If neighbor in wordList and not visited, add to queue, record parent. If neighbor already visited on same level, record additional parent. Continue until level reaches endWord.\n\nAfter BFS, if no path to endWord, return empty. Else reconstruct paths using DFS from endWord back to beginWord using parents map, building sequences reversed.\n\nWe need to produce step-by-step lines with explanations.\n\nWe need to include arrows and decisions.\n\nWe can group steps: Setup, BFS, Parent mapping, Backtracking, Build result.\n\nLet's produce code lines:\n\nStart\n→ Initialize set wordSet from wordList // Convert list to set for O(1)\n→ If endWord not in wordSet: → Step: Return empty list // No path possible\n→ Initialize queue with beginWord // BFS queue\n→ Initialize visited map level[beginWord]=0 // track level of each word\n→ Initialize parents dict // mapping child -> list of parents\n→ Initialize foundLevel = -1 // level where endWord first found\n→ Decision: While queue not empty? // BFS loop\n    Yes → Pop current word // current word from queue\n    → Let currentLevel = level[current]\n    → If foundLevel != -1 and currentLevel > foundLevel: → End BFS // All shorter paths processed\n    → For each position i in current word: // generate neighbors\n        → For each letter c from 'a' to 'z':\n            → If c equals current[i], continue\n            → Construct newWord by replacing i with c\n            → If newWord not in wordSet, continue\n            → Decision: If newWord not in level? // First time seen\n                Yes → level[newWord] = currentLevel + 1 // assign level\n                → Add newWord to queue\n                → parents[newWord] = [current] // record parent\n                → Decision: If newWord == endWord? // Found end\n                    Yes → foundLevel = currentLevel + 1 // record level\n            No → // already visited\n                → Decision: If level[newWord] == currentLevel + 1? // same level\n                    Yes → parents[newWord].append(current) // add another parent\n    → End For loops\n→ End While\n→ Decision: If foundLevel == -1? // no path found\n    Yes → Step: Return empty list // no transformations\n→ Initialize result list // to hold sequences\n→ Define recursive DFS(currentWord, path)\n    → Decision: If currentWord == beginWord?\n        Yes → Append reversed path + [beginWord] to result // build sequence\n    No → For each parent in parents[currentWord]:\n        → DFS(parent, path + [currentWord]) // backtrack\n→ Call DFS(endWord, []) // start backtracking from endWord\n→ Return result // all shortest sequences\nEnd\n\nBut we need to maintain the virtual code line formatting: Each line with virtual code and comment.\n\nWe need to maintain arrow '→' after step lines, decisions with Yes→ etc. Also we might use indentation for nested steps. Use spaces for indentation. We need to use the exact format as the sample.\n\nLet's produce each line:\n\nStart // 程式開始執行\n→ Step 1: Initialize wordSet ← Set(wordList) // 將字典轉換成集合，方便 O(1) 查詢\n→ Decision: 若 endWord 不在 wordSet? // 檢查終點是否存在於字典\n    Yes → Step 2: Return [] // 若不存在，直接回傳空清單\n→ Step 3: 初始化 queue ← [beginWord] // BFS 的佇列，開始於 beginWord\n→ Step 4: 初始化 level_map ← {beginWord: 0} // 記錄每個字的層級（距離）\n→ Step 5: 初始化 parents_map ← {} // child → list of parent words\n→ Step 6: 初始化 foundLevel ← -1 // 第一層遇到 endWord 時記錄層級\n→ Decision: 佇列是否非空? // BFS 主迴圈\n    Yes →\n        → Step 7: current ← queue.pop(0) // 取出佇列首元素\n        → Step 8: currentLevel ← level_map[current] // 取得當前字的層級\n        → Decision: foundLevel 已設定且 currentLevel > foundLevel? // 已完成最短路徑\n            Yes → End // 結束 BFS\n        → Step 9: For i in 0..len(current)-1: // 逐字母產生鄰接字\n            → Step 10: For c in 'a'..'z':\n                → Decision: c == current[i]? // 跳過相同字母\n                    Yes → Continue\n                → Step 11: newWord ← current[:i] + c + current[i+1:] // 替換字母得到新字\n                → Decision: newWord 不在 wordSet? // 不是字典內字\n                    Yes → Continue\n                → Decision: newWord 未在 level_map? // 首次遇到\n                    Yes →\n                        → Step 12: level_map[newWord] ← currentLevel + 1\n                        → Step 13: queue.append(newWord)\n                        → Step 14: parents_map[newWord] ← [current]\n                        → Decision: newWord == endWord? // 找到終點\n                            Yes → foundLevel ← currentLevel + 1\n                    No →\n                        → Decision: level_map[newWord] == currentLevel + 1? // 同層級\n                            Yes → parents_map[newWord].append(current) // 再加一條父節點\n        → Step 15: End For (i)\n    No → End // 佇列為空，結束 BFS\n→ Decision: foundLevel == -1? // 是否有可行路徑\n    Yes → Step 16: Return [] // 無路徑，回傳空清單\n→ Step 17: 初始化 result ← [] // 儲存所有最短路徑\n→ Step 18: 定義遞迴函式 DFS(word, path)\n    → Decision: word == beginWord? // 到達起點\n        Yes →\n            → Step 19: result.append([beginWord] + list(reversed(path))) // 反轉 path 並加上 beginWord\n        No →\n            → Step 20: For parent in parents_map[word]:\n                → DFS(parent, path + [word]) // 回溯至父節點\n→ Step 21: 呼叫 DFS(endWord, []) // 從終點開始回溯\n→ Step 22: Return result // 回傳所有最短序列\nEnd // 程式執行結束\n\nBut ensure each line has \"虛擬碼步驟\" and comment after space. Use \"→\" for steps, \"Decision:\" for decisions, \"Yes →\", \"No →\" etc. We need to keep the indent structure for nested steps.\n\nAlso note we need to maintain the same arrow style as example: \"→ Decision:\" then sub-indented lines.\n\nLet's produce final output exactly with proper indentation: 4 spaces maybe for nested? But not necessary.\n\nLet's replicate sample style: They use \"→ Decision:\" then indent sub-steps with 4 spaces and \"Yes →\" etc. We'll mimic that.\n\nMake sure each line includes comment after a space.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Initialize wordSet ← Set(wordList) // 將字典轉換成集合，方便 O(1) 查詢  \n→ Decision: 若 endWord 不在 wordSet? // 檢查終點是否存在於字典  \n Yes → Step 2: Return [] // 若不存在，直接回傳空清單  \n→ Step 3: 初始化 queue ← [beginWord] // BFS 的佇列，開始於 beginWord  \n→ Step 4: 初始化 level_map ← {beginWord: 0} // 記錄每個字的層級（距離）  \n→ Step 5: 初始化 parents_map ← {} // child → list of parent words  \n→ Step 6: 初始化 foundLevel ← -1 // 第一層遇到 endWord 時記錄層級  \n→ Decision: 佇列是否非空? // BFS 主迴圈  \n Yes →  \n  → Step 7: current ← queue.pop(0) // 取出佇列首元素  \n  → Step 8: currentLevel ← level_map[current] // 取得當前字的層級  \n  → Decision: foundLevel 已設定且 currentLevel > foundLevel? // 已完成最短路徑  \n   Yes → End // 結束 BFS  \n  → Step 9: For i in 0..len(current)-1: // 逐字母產生鄰接字  \n   → Step 10: For c in 'a'..'z':  \n     → Decision: c == current[i]? // 跳過相同字母  \n      Yes → Continue  \n     → Step 11: newWord ← current[:i] + c + current[i+1:] // 替換字母得到新字  \n     → Decision: newWord 不在 wordSet? // 不是字典內字  \n      Yes → Continue  \n     → Decision: newWord 未在 level_map? // 首次遇到  \n      Yes →  \n       → Step 12: level_map[newWord] ← currentLevel + 1  \n       → Step 13: queue.append(newWord)  \n       → Step 14: parents_map[newWord] ← [current]  \n       → Decision: newWord == endWord? // 找到終點  \n        Yes → foundLevel ← currentLevel + 1  \n      No →  \n       → Decision: level_map[newWord] == currentLevel + 1? // 同層級  \n         Yes → parents_map[newWord].append(current) // 再加一條父節點  \n         No →  \n          // 不同層級，忽略"
    },
    {
      "title": "Generate Random Point in a Circle",
      "source_file": "Leetcode/leetcode478.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]",
          "expected_output": "[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[-0.02493,-0.38077],[0.82314,0.38945],[0.36572,0.17248]]'\nGot (Norm):      '[null,[0.6169531393993802,-0.19363438342869335],[0.36240116989426835,0.8906134533293787],[-0.24362605536484488,0.04827924591854009]]'\n--- (Raw) ---\nRaw Expected: '[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]'\nRaw Got:      '[null, [0.6169531393993802, -0.19363438342869335], [0.36240116989426835, 0.8906134533293787], [-0.24362605536484488, 0.04827924591854009]]'"
        }
      ],
      "generated_code": "import sys\nimport math\nimport random\nimport json\n\nclass Solution:\n    def __init__(self, radius, x_center, y_center):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n\n    def randPoint(self):\n        r = self.radius * math.sqrt(random.random())   # 均勻分佈於圓內\n        theta = random.uniform(0, 2 * math.pi)\n        x = self.x_center + r * math.cos(theta)\n        y = self.y_center + r * math.sin(theta)\n        return [x, y]\n\nif __name__ == \"__main__\":\n    # 讀取全部輸入，分行處理\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        sys.exit(0)\n\n    # 第一行: 指令列表, 第二行: 參數列表\n    commands = json.loads(data[0].strip())\n    args_list = json.loads(data[1].strip())\n\n    instance = None\n    results = []\n\n    for i, cmd in enumerate(commands):\n        if cmd == \"Solution\":\n            instance = Solution(*args_list[i])\n            results.append(None)          # 建構子回傳 null\n        else:\n            method = getattr(instance, cmd)\n            res = method(*args_list[i])\n            results.append(res)\n\n    # 輸出符合 JSON 的結果\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code line by line, with \"Start\", \"End\", \"Decision\", etc. We need to explain each line briefly. We should generate steps for a Solution class with constructor storing radius and center. randPoint() generates uniform random point in circle. The algorithm: generate random angle theta uniform [0, 2π). generate random radius r = sqrt(random_uniform(0,1))*radius. Then x = x_center + r*cos(theta), y = y_center + r*sin(theta). Return [x, y].\n\nWe must produce pseudo-code, not actual code. Use arrows. Each line with comment. Let's produce pseudo-code as per format.\n\nWe may start with \"Start // 程式開始執行\". Then arrow to \"Solution: 初始化物件\" but we need to show the class and constructor. But we can keep it pseudo. Let's structure:\n\nStart\n→ Step 1: 定義類別 Solution // 宣告 Solution 類\n→ Step 2: 定義屬性 radius, x_center, y_center // 儲存圓半徑與中心座標\n→ Step 3: 定義構造函數 Solution(radius, x_center, y_center) // 物件初始化\n    → Assign radius, x_center, y_center to instance // 將參數存入屬性\n→ Step 4: 定義方法 randPoint() // 產生隨機點\n    → Step 4.1: 產生隨機角度 θ ∈ [0, 2π) // 使用隨機數\n    → Step 4.2: 產生隨機值 u ∈ [0, 1) // 用於半徑計算\n    → Step 4.3: 計算半徑 r = sqrt(u) * radius // 均勻分佈\n    → Step 4.4: 計算 x = x_center + r * cos(θ) // 點的 x 座標\n    → Step 4.5: 計算 y = y_center + r * sin(θ) // 點的 y 座標\n    → Step 4.6: 返回 [x, y] // 結果\nEnd // 程式結束\n\nBut we need each line as separate with arrow or Start. For nested steps maybe indent? But the format doesn't require indentation, but we can indent with spaces for clarity. Use arrows and maybe indentation not necessary. Each line ends with comment.\n\nWe need \"虛擬碼步驟\" before comment. For each line we put like \"Start // 程式開始執行\". For nested steps, we can use indentation. Provide arrow for each step. Use \"→\" arrow before each line except Start/End.\n\nAlso \"Decision:\" only if there is a decision. But here there is none. So no Decision. So just Steps.\n\nLet's write final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類別 Solution // 宣告 Solution 類  \n→ Step 2: 定義屬性 radius, x_center, y_center // 儲存圓半徑與中心座標  \n→ Step 3: 定義構造函數 Solution(radius, x_center, y_center) // 物件初始化  \n  → Assign radius, x_center, y_center to instance // 將參數存入屬性  \n→ Step 4: 定義方法 randPoint() // 產生隨機點  \n  → Step 4.1: 產生隨機角度 θ ∈ [0, 2π) // 使用隨機數產生角度  \n  → Step 4.2: 產生隨機值 u ∈ [0, 1) // 用於半徑計算  \n  → Step 4.3: 計算半徑 r = sqrt(u) * radius // 均勻分佈在圓內  \n  → Step 4.4: 計算 x = x_center + r * cos(θ) // 取得點的 x 座標  \n  → Step 4.5: 計算 y = y_center + r * sin(θ) // 取得點的 y 座標  \n  → Step 4.6: 返回 [x, y] // 回傳隨機點  \nEnd // 程式執行結束"
    },
    {
      "title": "Shuffle an Array",
      "source_file": "Leetcode/leetcode384.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"], [[[1, 2, 3]], [], [], []]",
          "expected_output": "[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[3,1,2],[1,2,3],[1,3,2]]'\nGot (Norm):      '[null,[1,2,3],[1,2,3],[2,3,1]]'\n--- (Raw) ---\nRaw Expected: '[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]'\nRaw Got:      '[null, [1, 2, 3], [1, 2, 3], [2, 3, 1]]'"
        }
      ],
      "generated_code": "import sys\nimport random\nimport ast\nimport json\n\nclass Solution:\n    def __init__(self, nums):\n        # 儲存原始陣列的複製\n        self.original = list(nums)\n\n    def reset(self):\n        # 回傳原始陣列\n        return list(self.original)\n\n    def shuffle(self):\n        # Fisher–Yates 隨機打亂陣列\n        arr = list(self.original)\n        n = len(arr)\n        for i in range(n):\n            j = random.randint(i, n - 1)\n            arr[i], arr[j] = arr[j], arr[i]\n        return arr\n\ndef main():\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 將輸入轉換成 tuple(ops, args)\n    ops, args = ast.literal_eval('(' + data + ')')\n    result = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            obj = Solution(arg[0] if arg else [])\n            result.append(None)\n        elif op == \"reset\":\n            result.append(obj.reset())\n        elif op == \"shuffle\":\n            result.append(obj.shuffle())\n    # 輸出為 JSON 格式以符合範例\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code with explanation, step by step for this algorithm: random shuffle of array, with reset. So we need to design class Solution with constructor, reset, shuffle. Use Fisher-Yates shuffle.\n\nWe need to output virtual code line by line.\n\nLet's outline:\n\nStart // Program start\n\n→ Step 1: Define class Solution // 定義Solution類別\n\n→ Step 2: Declare fields: original array, current array // 儲存原始與當前陣列\n\n→ Step 3: Constructor: Solution(nums) // 初始化物件\n\n    → Step 3.1: Copy nums to original // 保存原始陣列\n    → Step 3.2: Set current to a copy of original // 初始化當前陣列\n\n→ Step 4: Method reset() // 重置方法\n\n    → Step 4.1: Set current to copy of original // 重置為原始\n    → Step 4.2: Return current // 回傳重置後陣列\n\n→ Step 5: Method shuffle() // 隨機排列\n\n    → Step 5.1: For i from 0 to n-1 // 從頭遍歷陣列\n        → Decision: Generate random index j in [i, n-1] // 隨機選擇位置\n        → Step 5.2: Swap current[i] and current[j] // 交換\n    → Step 5.3: Return current // 回傳隨機陣列\n\nEnd // 程式結束\n\nBut need to format each line with virtual code arrow, etc.\n\nWe need to include \"→\" arrow for steps. For decisions, use \"Decision:\".\n\nWe need to produce each line: \"Start // 程式開始執行\" etc.\n\nUse arrow for nested steps.\n\nWe need to be careful: For nested steps, indentation? The format may show indentation but not required. Use spaces.\n\nWe will output each line as: \"→ Step X: ...\" with comment.\n\nMake sure each line contains the code and comment.\n\nAlso need to show Decision lines.\n\nLet's produce.\n\nWe need to produce exactly lines, not mention line numbers.\n\nAlso maybe use \"Step 1:\" etc.\n\nBut they said use `虛擬碼步驟` + `[空格]` + `// 解釋/說明`. So each line must be something like:\n\n\"Start // 程式開始執行\"\n\n\"→ Step 1: 定義類別 Solution // ...\"\n\nMake sure to include arrow for each step.\n\nAlso decisions:\n\n\"Decision: 如果 j 生成隨機值?\" etc.\n\nBut maybe simpler: no decision for random generation; just step.\n\nBut we can show \"Decision: 如果 i < n?\".\n\nBut not necessary.\n\nLet's produce simple algorithm.\n\nWe need to include \"reset\" and \"shuffle\" methods.\n\nLet's produce code.\n\nWe'll include fields as steps.\n\nOk.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類別 Solution // 建立 Solution 類別  \n→ Step 2: 宣告兩個陣列原始陣列 original, 當前陣列 current // 用於存放初始值與隨機排列  \n→ Step 3: 建構子 Solution(nums) // 初始化物件  \n  → Step 3.1: original ← copy of nums // 將傳入陣列複製作原始版本  \n  → Step 3.2: current ← copy of original // 初始時 current 與 original 相同  \n→ Step 4: 方法 reset() // 重置為原始配置  \n  → Step 4.1: current ← copy of original // 把 current 重新設為 original 的複製  \n  → Step 4.2: return current // 回傳已重置的陣列  \n→ Step 5: 方法 shuffle() // 隨機打亂陣列  \n  → Step 5.1: for i from 0 to length(current)-1  \n    → Decision: 產生隨機索引 j 在範圍 [i, length(current)-1] // 決定交換位置  \n      → Step 5.2: swap current[i] with current[j] // 交換元素  \n  → Step 5.3: return current // 回傳隨機排列後的陣列  \nEnd // 程式執行結束"
    },
    {
      "title": "Subsets",
      "source_file": "Leetcode/leetcode78.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nGot (Norm):      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nRaw Got:      '[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def subsets(self, nums):\n        res = []\n        def backtrack(start, path):\n            res.append(path[:])\n            for i in range(start, len(nums)):\n                path.append(nums[i])\n                backtrack(i + 1, path)\n                path.pop()\n        backtrack(0, [])\n        return res\n\ndef parse_input(data):\n    data = data.strip()\n    if data.startswith(\"nums\"):\n        idx = data.find('[')\n        if idx != -1:\n            data = data[idx:]\n    return ast.literal_eval(data)\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read()\n    nums = parse_input(input_data)\n    sol = Solution()\n    result = sol.subsets(nums)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for generating all subsets of a unique integer array. Use recursion/backtracking. Provide each line with explanation. Must use arrow syntax. Let's produce steps: Start, Input array, Initialize result list, Define backtrack function, call backtrack with start 0 and current subset empty. Backtrack: add current subset to result. Loop i from start to end, add nums[i] to current subset, call backtrack(i+1, subset), remove last. Then End.\n\nWe'll format each line: \"Start // 程式開始執行\". Next \"→ Step 1: 取得輸入陣列 nums // 讀取唯一整數陣列\". Then \"→ Step 2: 初始化 result 為空集合 // 用來存所有子集\". Then define backtrack: \"→ Step 3: 定義函式 backtrack(start, subset) // 從索引 start 開始遞迴\". Then inside backtrack: \"→ Step 4: 把 subset 複製到 result // 將目前子集加入結果\". Then loop: \"→ Decision: i 變量從 start 到 nums.length-1? // 遍歷剩餘元素\". For each i: \"→ Step 5: 把 nums[i] 加到 subset // 選擇當前元素\". \"→ Step 6: backtrack(i+1, subset) // 深度遞迴到下一層\". \"→ Step 7: 移除 subset 最後一個元素 // 回溯\". End loop, End backtrack. Call: \"→ Step 8: backtrack(0, []) // 從索引 0 開始，空子集\". \"→ Step 9: 回傳 result // 回傳所有子集\". End.\n\nNeed each line with arrow formatting. For decision we use \"Decision: 如果 i <= ...? //\". But we need to express loop. Let's use Decision for loop condition.\n\nWe need to show start and end of backtrack function perhaps as \"→ Step 3: 定義 backtrack(start, subset) // 開始遞迴定義\" and then lines inside. Might need to mark End of backtrack. Use \"→ End backtrack // 回到上一層\". And \"End // 程式結束\". We'll produce each line accordingly.\n\nMake sure each line includes arrow or indentation? The example uses arrow for steps: \"→ Step 1:\". Decision lines: \"Decision:\" etc. Use spaces indent. Let's produce.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得輸入陣列 nums // 讀取唯一整數陣列  \n→ Step 2: 初始化 result 為空集合 // 用來存所有子集  \n→ Step 3: 定義函式 backtrack(start, subset) // 開始遞迴定義  \n→ Step 4: 把 subset 複製到 result // 將目前子集加入結果  \n→ Decision: i 變量從 start 到 nums.length-1? // 遍歷剩餘元素  \n  Yes → Step 5: 把 nums[i] 加到 subset // 選擇當前元素  \n  Yes → Step 6: backtrack(i+1, subset) // 深度遞迴到下一層  \n  Yes → Step 7: 移除 subset 最後一個元素 // 回溯  \n  No  →  // i 已超過陣列範圍，結束循環  \n→ End backtrack // 回到上一層  \n→ Step 8: backtrack(0, []) // 從索引 0 開始，空子集  \n→ Step 9: 回傳 result // 回傳所有子集  \nEnd // 程式執行結束"
    },
    {
      "title": "Largest Palindrome Product",
      "source_file": "Leetcode/leetcode479.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 2",
          "expected_output": "987",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '987'\nGot (Norm):      '999'\n--- (Raw) ---\nRaw Expected: '987'\nRaw Got:      '999'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def largestPalindrome(self, n: int) -> int:\n        \"\"\"Return the largest palindromic product of two n‑digit numbers modulo 1337.\"\"\"\n        if n == 1:\n            return 9\n\n        low = 10 ** (n - 1)\n        high = 10 ** n - 1\n\n        # Generate palindromes from largest to smallest.\n        for first in range(high, low - 1, -1):\n            s = str(first)\n\n            # Even‑length palindrome (e.g., 9009 for n = 2)\n            even_pal = int(s + s[::-1])\n            if self._has_factor(even_pal, low, high):\n                return even_pal % 1337\n\n            # Odd‑length palindrome (e.g., 906609 for n = 3)\n            odd_pal = int(s + s[-2::-1]) if len(s) > 1 else int(s)\n            if self._has_factor(odd_pal, low, high):\n                return odd_pal % 1337\n\n        # Should never reach here for n >= 1\n        return -1\n\n    def _has_factor(self, pal: int, low: int, high: int) -> bool:\n        \"\"\"\n        Check whether the palindrome 'pal' can be expressed as the product\n        of two n‑digit numbers (i.e., numbers in [low, high]).\n        \"\"\"\n        for a in range(high, low - 1, -1):\n            if pal % a == 0:\n                b = pal // a\n                if low <= b <= high:\n                    return True\n        return False\n\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    m = re.search(r'\\d+', data)\n    if not m:\n        return\n    n = int(m.group(0))\n    solution = Solution()\n    result = solution.largestPalindrome(n)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output pseudo-code lines following the format, with each line containing \"虛擬碼步驟 // 解釋\". We need to solve: given integer n, find largest palindrome that is product of two n-digit numbers, return mod 1337. This is the same as Leetcode 906. Approach: iterate a from high to low (10^n-1 down to 10^(n-1)), b from a down to 10^(n-1). For each product, check palindrome, update max. Early break: if product <= max found, break inner loop. At the end, return max % 1337. We need to produce pseudo-code lines accordingly. Use arrows and decisions. Must use Start, End, Decision. Provide line by line.\n\nWe'll produce something like:\n\nStart\n→ Step 1: 計算最小 n 位數 low = 10^(n-1) // 10^(n-1)\n→ Step 2: 計算最大 n 位數 high = 10^n - 1\n→ Step 3: 初始化最大回文 maxPal = 0\n→ Decision: 是否還有 a 值? // 循環 a from high to low\n    Yes → Step 4: 設定 a = high - (countA) // 每次減一\n    → Decision: 是否還有 b 值? // 循環 b from a to low\n        Yes → Step 5: 設定 b = a - (countB)\n        → Step 6: 計算 product = a * b\n        → Decision: product <= maxPal? // 早期跳過\n            Yes → Step 7: 進入下一 b\n            No  → Step 8: 判斷 product 是否為回文\n                → Decision: product 是回文? // 判斷函式\n                    Yes → Step 9: 更新 maxPal = product\n                    No  → Step 10: 繼續\n        → Decision: b > low? // 內層是否結束\n            Yes → Step 11: 回到 Step 5\n            No  → Step 12: 內層結束\n    → Decision: a > low? // 外層是否結束\n        Yes → Step 13: 回到 Step 4\n        No  → Step 14: 外層結束\n→ Step 15: 回傳 maxPal mod 1337\nEnd\n\nBut we need to adhere to arrow format. Usually we would use \"Decision:\" lines and nested indent. Provide \"Yes →\" and \"No →\" with indent. Each step has a number maybe. Provide each line as one. Use indentation for nested decisions. We can show like:\n\nStart // 程式開始\n→ Step 1: low = 10^(n-1) // 計算 n 位數的最小值\n→ Step 2: high = 10^n - 1 // 計算 n 位數的最大值\n→ Step 3: maxPal = 0 // 初始化最大回文\n→ Decision: 是否存在 a? // 循環 a 從 high 到 low\n    Yes → Step 4: a = high - (high - low) // 設定 a\n    → Decision: 是否存在 b? // 循環 b 從 a 到 low\n        Yes → Step 5: b = a - (a - low) // 設定 b\n        → Step 6: prod = a * b // 計算乘積\n        → Decision: prod <= maxPal? // 若已小於已知最大，跳過\n            Yes → Step 7: 繼續 b 循環\n            No  → Step 8: isPalindrome(prod) // 判斷是否回文\n                → Decision: isPalindrome 為真?\n                    Yes → Step 9: maxPal = prod // 更新最大回文\n                    No  → Step 10: 繼續 b 循環\n        → Decision: b > low? // 內層結束判斷\n            Yes → Step 11: 迴到 Step 5\n            No  → Step 12: 內層結束\n    → Decision: a > low? // 外層結束判斷\n        Yes → Step 13: 迴到 Step 4\n        No  → Step 14: 外層結束\n→ Step 15: return maxPal % 1337 // 結果取模\nEnd\n\nBut we must ensure each line contains only one step and explanation. The above has some lines that are nested inside decisions; we might need to separate each sub-step into its own line. Also we need to use arrow \"→\" before each step, not after \"Yes\". For decisions we need \"Decision:\" line and then indent the Yes → and No → lines.\n\nLet's produce proper formatted pseudo-code:\n\n```\nStart // 程式開始\n→ Step 1: low = 10^(n-1) // 取得 n 位數最小值\n→ Step 2: high = 10^n - 1 // 取得 n 位數最大值\n→ Step 3: maxPal = 0 // 初始化最大回文\n→ Decision: a = high; a >= low; a-- // 迴圈外層\n    Yes → Step 4: b = a; b >= low; b-- // 內層迴圈\n        → Step 5: prod = a * b // 計算乘積\n        → Decision: prod <= maxPal? // 若小於已知最大，直接跳過\n            Yes → Step 6: 內層跳過 // 不做任何事，直接回到 b--\n            No  → Step 7: isPal = isPalindrome(prod) // 判斷是否回文\n                → Decision: isPal? // 判斷結果\n                    Yes → Step 8: maxPal = prod // 更新最大回文\n                    No  → Step 9: // 何也不做\n        → Decision: b > low? // 內層結束判斷\n            Yes → Step 10: 迴到 Step 4\n            No  → Step 11: 內層結束\n    → Decision: a > low? // 外層結束判斷\n        Yes → Step 12: 迴到 Step 4\n        No  → Step 13: 外層結束\n→ Step 14: return maxPal % 1337 // 回傳結果\nEnd // 程式結束\n```\n\nBut we need each line containing \"虛擬碼步驟 // 解釋\". So we must avoid multiline pseudo-code; each line only one statement. For loops we can do \"Step: for a from high downto low\" but we need to show decisions.\n\nWe can structure:\n\nStart\n→ Step 1: low = 10^(n-1)\n→ Step 2: high = 10^n - 1\n→ Step 3: maxPal = 0\n→ Decision: a = high; a >= low; a-- // 外層迴圈\n    Yes → Step 4: b = a; b >= low; b-- // 內層迴圈\n        → Step 5: prod = a * b\n        → Decision: prod <= maxPal? \n            Yes → Step 6: // skip to next b\n            No  → Step 7: isPal = isPalindrome(prod)\n                → Decision: isPal?\n                    Yes → Step 8: maxPal = prod\n                    No  → Step 9: // nothing\n        → Decision: b > low? \n            Yes → Step 10: // continue b loop\n            No  → Step 11: // end inner loop\n    → Decision: a > low? \n        Yes → Step 12: // continue a loop\n        No  → Step 13: // end outer loop\n→ Step 14: return maxPal % 1337\nEnd\n\nBut we still have \"Decision: a = high; a >= low; a--\" which is not a decision but a loop. But we can represent loops as decision: e.g., \"Decision: a >= low?\" and inside Yes do Step and decrement. Might be clearer.\n\nLet's produce final pseudo-code lines with decisions.\n\n```\nStart // 程式開始\n→ Step 1: low = 10^(n-1) // 計算 n 位數最小值\n→ Step 2: high = 10^n - 1 // 計算 n 位數最大值\n→ Step 3: maxPal = 0 // 初始化最大回文\n→ Decision: a = high // 設定 a 為最大值\n    Yes → Step 4: a >= low // 檢查 a 是否還在範圍\n        Yes → Step 5: b = a // 內層起始值\n            Yes → Step 6: b >= low // 檢查 b 是否還在範圍\n                Yes → Step 7: prod = a * b // 計算乘積\n                → Decision: prod <= maxPal? // 若已小於已知最大\n                    Yes → Step 8: // 跳過本次 b\n                    No  → Step 9: isPal = isPalindrome(prod) // 判斷回文\n                        → Decision: isPal?\n                            Yes → Step 10: maxPal = prod // 更新最大回文\n                            No  → Step 11: // 無操作\n                → Decision: b > low? // 內層結束判斷\n                    Yes → Step 12: // 繼續下個 b\n                    No  → Step 13: // 內層結束\n            → Decision: a > low? // 外層結束判斷\n                Yes → Step 14: // 繼續下個 a\n                No  → Step 15: // 外層結束\n→ Step 16: return maxPal % 1337 // 結果取模\nEnd // 程式結束\n```\n\nBut it's too messy. We need to keep each line with simple step. Might use while loops represented as decisions.\n\nMaybe better: Use pseudo-code for loops explicitly:\n\n```\nStart // 程式開始\n→ Step 1: low = 10^(n-1) // 計算 n 位數最小值\n→ Step 2: high = 10^n - 1 // 計算 n 位數最大值\n→ Step 3: maxPal = 0 // 初始化最大回文\n→ Step 4: a = high // 設定 a 為最大值\n→ Decision: a >= low? // 外層迴圈條件\n    Yes → Step 5: b = a // 內層起始值\n        → Decision: b >= low? // 內層迴圈條件\n            Yes → Step 6: prod = a * b // 計算乘積\n            → Decision: prod <= maxPal? // 若小於已知最大\n                Yes → Step 7: // 跳過本次 b\n                No  → Step 8: isPal = isPalindrome(prod) // 判斷回文\n                    → Decision: isPal?\n                        Yes → Step 9: maxPal = prod // 更新最大回文\n                        No  → Step 10: // 無操作\n            → Decision: b > low? // 內層結束判斷\n                Yes → Step 11: // 內層迴圈繼續\n                No  → Step 12: // 內層結束\n        → Decision: a > low? // 外層結束判斷\n            Yes → Step 13: // 外層迴圈繼續\n            No  → Step 14: // 外層結束\n→ Step 15: return maxPal % 1337 // 結果取模\nEnd // 程式結束\n```\n\nBut still we need to represent the decrement of a and b. Maybe step 5 after inner loops we should do b = b - 1 and go back. But we can mention \"b = b - 1\" as part of Step 11 or 13.\n\nLet's attempt a cleaner format:\n\n```\nStart // 程式開始\n→ Step 1: low = 10^(n-1) // 最小 n 位數\n→ Step 2: high = 10^n - 1 // 最大 n 位數\n→ Step 3: maxPal = 0 // 初始化最大回文\n→ Step 4: a = high // 外層起始值\n→ Decision: a >= low? // 外層迴圈條件\n    Yes → Step 5: b = a // 內層起始值\n        → Decision: b >= low? // 內層迴圈條件\n            Yes → Step 6: prod = a * b // 計算乘積\n            → Decision: prod <= maxPal? // 若已小於已知最大\n                Yes → Step 7: // 跳過本次 b\n                No  → Step 8: isPal = isPalindrome(prod) // 判斷回文\n                    → Decision: isPal?\n                        Yes → Step 9: maxPal = prod // 更新最大回文\n                        No  → Step 10: // 無操作\n            → Step 11: b = b - 1 // 迴圈遞減\n            → Step 12: // 回到內層判斷\n        → Step 13: // 回到內層判斷\n    → Step 14: a = a - 1 // 迴圈遞減\n    → Step 15: // 回到外層判斷\n→ Step 16: return maxPal % 1337 // 結果取模\nEnd // 程式結束\n```\n\nNow we have loops but not explicit. We have Step 11 and 14 as decrement. We also need to go back to decision statements. We might use comments to show \"return to decision\". But the format only allows \"虛擬碼步驟 // 解釋\" per line. We can include comments like \"// 回到內層判斷\". That is fine.\n\nWe might want to structure decisions more elegantly:\n\nUse `Decision: a >= low?` then Yes -> proceed, No -> exit. At the end of loop body, we decrement a and go back to Decision. But the pseudo-code above does that.\n\nLet's produce final answer with each line. Use proper Chinese comments. Each line includes arrow at beginning. We can include \"Decision:\" lines and \"Yes →\" \"No →\" with indent.\n\nLet's produce:\n\n```\nStart // 程式開始\n→ Step 1: low = 10^(n-1) // 取得 n 位數最小值\n→ Step 2: high = 10^n - 1 // 取得 n 位數最大值\n→ Step 3: maxPal = 0 // 初始化最大回文\n→ Step 4: a = high // 設定 a 為最大 n 位數\n→ Decision: a >= low? // 外層迴圈條件\n    Yes → Step 5: b = a // 內層起始值\n        → Decision: b >= low? // 內層迴圈條件\n            Yes → Step 6: prod = a * b // 計算乘積\n            → Decision: prod <= maxPal? // 若已小於已知最大\n                Yes → Step 7: // 跳過本次 b\n                No  → Step 8: isPal = isPalindrome(prod) // 判斷是否回文\n                    → Decision: isPal?\n                        Yes → Step 9: maxPal = prod // 更新最大回文\n                        No  → Step 10: // 無需更新\n            → Step 11: b = b - 1 // 內層遞減\n            → Step 12: // 回到內層判斷\n        → Step 13: // 回到內層判斷\n    → Step 14: a = a - 1 // 外層遞減\n    → Step 15: // 回到外層判斷\n→ Step 16: return maxPal % 1337 // 回傳結果\nEnd // 程式結束\n```\n\nBut still we need to represent \"回到內層判斷\" and \"回到外層判斷\" lines maybe not necessary. But we might keep them as comments to indicate loop continuation.\n\nHowever, the format demands that each line contain a step and comment, not a label \"回到內層判斷\" without code. But we can keep comment. So Step 12 and Step 13 are just comments with no action. But still they are lines. That's okay.\n\nBut to be more concise, we might merge the decrement steps with decision loops, but keep clarity.\n\nAlternatively, we can use while loops pseudo-code:\n\n```\nWhile a >= low:\n    While b >= low:\n        prod = a * b\n        if prod <= maxPal: break\n        if isPalindrome(prod): maxPal = prod\n        b = b - 1\n    a = a - 1\n```\n\nBut we need to convert into the required format.\n\nLet's craft final answer with each step. Ensure we follow guidelines.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始\n→ Step 1: low = 10^(n-1) // 取得 n 位數最小值\n→ Step 2: high = 10^n - 1 // 取得 n 位數最大值\n→ Step 3: maxPal = 0 // 初始化最大回文\n→ Step 4: a = high // 設定 a 為最大 n 位數\n→ Decision: a >= low? // 外層迴圈條件\n    Yes → Step 5: b = a // 內層起始值\n        → Decision: b >= low? // 內層迴圈條件\n            Yes → Step 6: prod = a * b // 計算乘積\n            → Decision: prod <= maxPal? // 若已小於已知最大\n                Yes → Step 7: // 跳過本次 b\n                No  → Step 8: isPal = isPalindrome(prod) // 判斷是否回文\n                    → Decision: isPal?\n                        Yes → Step 9: maxPal = prod // 更新最大回文\n                        No  → Step 10: // 無需更新\n            → Step 11: b = b - 1 // 內層遞減\n            → Step 12: // 回到內層判斷\n        → Step 13: // 回到內層判斷\n    → Step 14: a = a - 1 // 外層遞減\n    → Step 15: // 回到外層判斷\n→ Step 16: return maxPal % 1337 // 回傳結果\nEnd // 程式結束"
    },
    {
      "title": "Contains Duplicate III",
      "source_file": "Leetcode/leetcode220.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,1], indexDiff = 3, valueDiff = 0",
          "expected_output": "true",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpw7pm2heu.py\", line 63, in <module>\n    main()\n  File \"/tmp/tmpw7pm2heu.py\", line 47, in main\n    nums = eval(val)\n           ^^^^^^^^^\n  File \"<string>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "nums = [1,5,9,1,5,9], indexDiff = 2, valueDiff = 3",
          "expected_output": "false",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpvdbppwmd.py\", line 63, in <module>\n    main()\n  File \"/tmp/tmpvdbppwmd.py\", line 47, in main\n    nums = eval(val)\n           ^^^^^^^^^\n  File \"<string>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport bisect\n\nclass Solution:\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\n        \"\"\"Return True if there exists i != j such that\n        |i-j| <= k and |nums[i]-nums[j]| <= t.\"\"\"\n        window = []  # sorted list of values in the current window\n        for i, num in enumerate(nums):\n            # Find the leftmost element >= num - t\n            pos = bisect.bisect_left(window, num - t)\n            if pos < len(window) and abs(window[pos] - num) <= t:\n                return True\n\n            # Insert current number into the sorted window\n            bisect.insort(window, num)\n\n            # Maintain window size of at most k\n            if len(window) > k:\n                # Remove the element that is now out of the window\n                out_val = nums[i - k]\n                idx = bisect.bisect_left(window, out_val)\n                # pop the first occurrence of out_val\n                window.pop(idx)\n\n        return False\n\ndef main():\n    # Read the entire input, strip whitespace\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # The input is expected to be like:\n    # nums = [1,2,3,1], indexDiff = 3, valueDiff = 0\n    parts = [p.strip() for p in data.split(',')]\n    nums = None\n    indexDiff = None\n    valueDiff = None\n    for part in parts:\n        if '=' not in part:\n            continue\n        key, val = part.split('=', 1)\n        key = key.strip()\n        val = val.strip()\n        if key == 'nums':\n            nums = eval(val)\n        elif key == 'indexDiff':\n            indexDiff = int(val)\n        elif key == 'valueDiff':\n            valueDiff = int(val)\n\n    # Ensure all required values are present\n    if nums is None or indexDiff is None or valueDiff is None:\n        print('false')\n        return\n\n    sol = Solution()\n    result = sol.containsNearbyAlmostDuplicate(nums, indexDiff, valueDiff)\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step. We need to find if any pair satisfies conditions: |i-j| <= indexDiff and |nums[i]-nums[j]| <= valueDiff. Approach: use sliding window with hash map or tree. But for virtual code, we can describe algorithm.\n\nWe produce start, loops, decisions. Possibly nested loops but optimized.\n\nLet's produce generic algorithm: For each i, maintain window of indices j < i with j >= i - indexDiff. For each j in window, check value difference. Could use hash map of values to indices but need absolute difference <= valueDiff. Use TreeSet to find if there is value in [nums[i]-valueDiff, nums[i]+valueDiff]. But for virtual code, we can describe.\n\nWe'll produce:\n\nStart\n→ Step 1: Initialize data structure (e.g., balanced BST) to store values of current window // store nums[j] for j in window\n→ For i from 0 to nums.length-1: // iterate over array\n    → Step 2: If i > indexDiff: // remove element out of window\n        → Step 3: Remove nums[i-indexDiff-1] from BST // maintain window size\n    → Step 4: Search BST for any value within [nums[i]-valueDiff, nums[i]+valueDiff] // if found\n        → Yes → Return true // pair exists\n    → Step 5: Add nums[i] to BST // add current element for future pairs\n→ End // No pair found, return false\n\nWe need to include decision arrows, etc.\n\nBut need to incorporate removal and search steps with decisions. Use \"Decision:\" for searching.\n\nAlso need to handle if found return.\n\nLet's format each line:\n\nStart // 程式開始執行\n→ Step 1: 初始化一個平衡樹 BST 以存放當前滑動窗口中的元素值 // 用於快速查找區間內的值\n→ Step 2: 從 i = 0 開始迭代整個陣列 // i 為左端點索引\n    → Decision: 是否需要移除超出滑動窗口的元素? // 當 i > indexDiff 時\n        Yes → Step 3: 從 BST 中移除 nums[i - indexDiff - 1] // 移除最舊的元素以維持窗口大小\n        No  → // 不做任何操作\n    → Step 4: 在 BST 中搜尋是否存在值於區間 [nums[i] - valueDiff, nums[i] + valueDiff] // 檢查右端點索引\n        Yes → Step 5: 返回 true // 找到符合條件的索引對\n        No  → // 繼續\n    → Step 6: 將 nums[i] 插入 BST // 為未來的 j 提供參考\n→ End // 所有元素都已檢查，未找到符合條件的索引對，返回 false\n\nWe also need to include Return false at end.\n\nAdd Step 7: 返回 false // 結果\n\nThus lines:\n\nStart // ...\n→ Step 1: ...\n→ Step 2: ...\n    → Decision: ...\n        Yes → Step 3: ...\n        No  → // no operation\n    → Step 4: ...\n        Yes → Step 5: return true\n        No  → // continue\n    → Step 6: ...\n→ Step 7: return false\nEnd // 程式結束\n\nNeed to keep the same format: each line \"虛擬碼步驟 [space] // 解釋\"\n\nBut for nested decisions, need to indent? The example uses indentation for Decision lines. We will use same style.\n\nLet's craft final answer accordingly.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 初始化一個平衡樹 BST 以存放當前滑動窗口中的元素值 // 用於快速查找區間內的值\n→ Step 2: 從 i = 0 開始迭代整個陣列 // i 為左端點索引\n    → Decision: i > indexDiff? // 判斷是否超出滑動窗口\n        Yes → Step 3: 從 BST 中移除 nums[i - indexDiff - 1] // 移除最舊的元素以維持窗口大小\n        No  → // 無需移除\n    → Decision: BST 中是否存在值於區間 [nums[i] - valueDiff, nums[i] + valueDiff]? // 檢查右端點索引\n        Yes → Step 4: 返回 true // 找到符合條件的索引對\n        No  → // 繼續\n    → Step 5: 將 nums[i] 插入 BST // 為未來的 j 提供參考\n→ Step 6: 返回 false // 所有元素已檢查，未找到符合條件的索引對\nEnd // 程式執行結束\n```"
    },
    {
      "title": "Course Schedule",
      "source_file": "Leetcode/leetcode207.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "numCourses = 2, prerequisites = [[1,0]]",
          "expected_output": "true",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpqaqh10hu.py\", line 62, in <module>\n    main()\n  File \"/tmp/tmpqaqh10hu.py\", line 51, in main\n    data[key.strip()] = ast.literal_eval(val.strip())\n                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[1\n     ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "numCourses = 2, prerequisites = [[1,0],[0,1]]",
          "expected_output": "false",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpyokhhbtf.py\", line 62, in <module>\n    main()\n  File \"/tmp/tmpyokhhbtf.py\", line 51, in main\n    data[key.strip()] = ast.literal_eval(val.strip())\n                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[1\n     ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import deque\n\nclass Solution:\n    def canFinish(self, numCourses, prerequisites):\n        \"\"\"\n        使用拓撲排序 (Kahn's Algorithm) 判斷是否存在循環。\n        若所有節點都能被訪問，則可以完成所有課程。\n        \"\"\"\n        # 建立鄰接表與入度表\n        graph = [[] for _ in range(numCourses)]\n        indegree = [0] * numCourses\n\n        for dest, src in prerequisites:\n            graph[src].append(dest)\n            indegree[dest] += 1\n\n        # 將入度為 0 的節點加入佇列\n        queue = deque([i for i in range(numCourses) if indegree[i] == 0])\n        visited = 0\n\n        while queue:\n            node = queue.popleft()\n            visited += 1\n            for neighbor in graph[node]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    queue.append(neighbor)\n\n        # 若訪問的節點數與課程數相同，表示無循環\n        return visited == numCourses\n\ndef main():\n    \"\"\"\n    讀取輸入格式：'numCourses = X, prerequisites = [[a,b], ...]'\n    解析後呼叫 Solution.canFinish，並輸出 'true' 或 'false'。\n    \"\"\"\n    data_str = sys.stdin.read().strip()\n    if not data_str:\n        return\n\n    # 依逗號分割成 key=value 片段\n    parts = [p.strip() for p in data_str.split(',')]\n    data = {}\n    for part in parts:\n        if not part:\n            continue\n        key, val = part.split('=', 1)\n        # 用 ast.literal_eval 只允許字面量，避免 eval 安全風險\n        data[key.strip()] = ast.literal_eval(val.strip())\n\n    numCourses = data.get('numCourses')\n    prerequisites = data.get('prerequisites', [])\n\n    solution = Solution()\n    result = solution.canFinish(numCourses, prerequisites)\n    # 轉成小寫字串以符合題目要求\n    print(str(result).lower())\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code algorithm to check if can finish all courses given prerequisites. Essentially check for cycles in directed graph; if cycle, can't finish. Use DFS or Kahn's algorithm. Provide step-by-step virtual code lines with explanation. Use Start, End, Decision etc. We'll produce a simple algorithm: Build adjacency list, visited, recStack. DFS each node. If cycle found return false else true.\n\nWe'll output line by line: Start, Step: Build graph, Step: Initialize arrays, Step: DFS loop, Step: DFS function, Decision: cycle? etc. Provide comments.\n\nMake sure each line ends with `// 解釋`. Use arrow arrow etc.\n\nWe should include arrow indentations like \"→\". Use Decision with Yes and No.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立圖形鄰接表 adjacency ← 空字典 // 為每門課建立空鄰接表  \n→ Step 2: 對於每個 (a, b) 在 prerequisites  \n→     adjacency[b] ← adjacency[b] ∪ {a} // 以 b 為前提，a 需要被加入 b 的鄰接節點  \n→ Step 3: 建立 visited 與 recursionStack 陣列，長度為 numCourses，初始值為 false // 用於 DFS 記錄訪問狀態與遞迴棧  \n→ Step 4: 建立 canFinish 為 true // 預設可以完成，若發現循環則改為 false  \n→ Step 5: 對於 course 0 到 numCourses-1  \n→     Decision: 是否已訪問 course?  \n→         Yes → 继续 // 已經檢查過，跳過  \n→         No  → Step 6: 進行 DFS(course) // 從未訪問的課開始 DFS  \n→ Decision: canFinish 為 true?  \n→     Yes → End // 所有課都能完成，程式結束  \n→     No  → End // 發現循環，程式結束  \n\nStep 6: DFS(course)  \n→ Decision: recursionStack[course] 為 true?  \n→     Yes → canFinish ← false // 循環檢測到，設定失敗  \n→     No  → 继续 // 沒有在遞迴棧，繼續往下  \n→ Decision: visited[course] 為 true?  \n→     Yes → 继续 // 已經走過，直接返回  \n→     No  → Step 7: visited[course] ← true // 標記為已訪問  \n→ → recursionStack[course] ← true // 標記為遞迴棧  \n→ → 對於 neighbour in adjacency[course]  \n→     Decision: 是否已訪問 neighbour?  \n→         Yes → 继续 // 先前已經走過  \n→         No  → Step 8: DFS(neighbour) // 進一步遞迴  \n→ → recursionStack[course] ← false // 從遞迴棧移除  \n→ → Return // 回到上一層呼叫  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick with Weight",
      "source_file": "Leetcode/leetcode528.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"], [[[1,3]],[],[],[],[],[]]",
          "expected_output": "[null,1,1,1,1,0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,1,1,1,1,0]'\nGot (Norm):      '[null,1,0,1,0,0]'\n--- (Raw) ---\nRaw Expected: '[null,1,1,1,1,0]'\nRaw Got:      '[null, 1, 0, 1, 0, 0]'"
        }
      ],
      "generated_code": "import sys\nimport random\nimport bisect\nimport json\nimport ast\n\nclass Solution:\n    def __init__(self, w):\n        # 建立前綴和與總重量\n        self.prefix_sum = []\n        total = 0\n        for weight in w:\n            total += weight\n            self.prefix_sum.append(total)\n        self.total = total\n\n    def pickIndex(self):\n        # 隨機產生 1 ~ total 的整數\n        target = random.randint(1, self.total)\n        # 二分搜尋得到最小索引使 prefix_sum[idx] >= target\n        return bisect.bisect_left(self.prefix_sum, target)\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入並解析成兩個元素的元組\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    # 使用 ast.literal_eval 以安全方式解析\n    ops, args = ast.literal_eval(data)\n\n    res = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            # 建構物件，參數為一個列表\n            obj = Solution(arg[0])\n            res.append(None)\n        elif op == \"pickIndex\":\n            # 呼叫 pickIndex，沒有額外參數\n            res.append(obj.pickIndex())\n        else:\n            # 若有其他方法，忽略或可自行擴充\n            pass\n\n    # 輸出結果，使用 json.dumps 以得到 null 等格式\n    print(json.dumps(res))",
      "virtual_code": "Thinking...\nWe need to output virtual code for solution. We need to describe algorithm: precompute prefix sums, total sum. For pickIndex, generate random number between 1 and total, binary search prefix sums to find index. Use virtual code lines.\n\nWe must adhere to format: each line: virtual step + space + // explanation.\n\nUse Start, End, Decision, arrows. Use indentation for decision branches. For binary search steps we can outline.\n\nLet's produce steps:\n\nStart\n→ Step 1: Initialize prefix array and total sum from w // build cumulative weights\n→ Step 2: For each index i, compute prefix[i] = prefix[i-1] + w[i] // accumulate\n→ Step 3: Set total = prefix[last] // total weight\nEnd\n\nFor pickIndex function:\n\nStart\n→ Function pickIndex\n→ Step 1: Generate random integer r in [1, total] // uniform selection\n→ Decision: Find smallest index i where prefix[i] >= r // binary search\n    → Step 2: Return i // selected index\nEnd\n\nWe need to use arrow '→' at each step.\n\nWe might need to show binary search steps: left, right, mid. Use decision branches.\n\nLet's design:\n\nStart\n→ Step 1: r ← random integer from 1 to total\n→ Decision: r <= prefix[0]? // check first\n    Yes → Return 0\n    No → Decision: r <= prefix[1]? ...\nBut better to show binary search generically.\n\nWe can write:\n\n→ Step 2: low ← 0, high ← len(prefix)-1 // init bounds\n→ Decision: low < high? // binary search loop\n    Yes → Step 3: mid ← (low + high) // 2\n           Decision: prefix[mid] < r? // r is larger\n                Yes → low ← mid + 1\n                No  → high ← mid\n           → Go back to Decision low < high?\n    No → Return low // low==high is index\n\nOk.\n\nNow produce final output.\n\nRemember each line: virtual code + space + // explanation.\n\nMake sure to maintain formatting exactly.\n\nLet's generate.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Build prefix array and total weight from w // 計算前綴和及總重量  \n→ Decision: 迭代 w 以建立 prefix  \n  Yes → Step 2: prefix[i] ← (i==0? w[0] : prefix[i-1] + w[i]) // 累加每個元素  \n  No  → End // 完成前綴和計算  \n→ Step 3: total ← prefix[last] // 紀錄總重量  \nEnd // 初始設定結束  \n\n---  \n\nFunction pickIndex // 定義隨機選取索引的函式  \n→ Step 1: r ← random integer in [1, total] // 產生均勻隨機數  \n→ Step 2: low ← 0, high ← len(prefix) - 1 // 初始化二分搜尋區間  \n→ Decision: low < high? // 判斷是否還有多個候選  \n  Yes → Step 3: mid ← (low + high) // 2 // 取中點  \n   Decision: prefix[mid] < r? // r 大於前綴和  \n    Yes → low ← mid + 1 // 搜尋右半段  \n    No  → high ← mid // 搜尋左半段  \n   → 回到 Decision: low < high? // 重複搜尋  \n  No  → Step 4: Return low // low==high 為最終索引  \nEnd // 函式執行結束"
    },
    {
      "title": "The K Weakest Rows in a Matrix",
      "source_file": "Leetcode/leetcode1337.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "mat = [[1,1,0,0,0],[1,1,1,1,0],[1,0,0,0,0],[1,1,0,0,0],[1,1,1,1,1]], k = 3",
          "expected_output": "[2,0,3]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp84ck57dm.py\", line 25, in <module>\n    data = ast.literal_eval(f\"({raw_input})\")\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    (mat = [[1,1,0,0,0],[1,1,1,1,0],[1,0,0,0,0],[1,1,0,0,0],[1,1,1,1,1]], k = 3)\n     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "mat = [[1,0,0,0],[1,1,1,1],[1,0,0,0],[1,0,0,0]], k = 2",
          "expected_output": "[0,2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpwnnnvpvf.py\", line 25, in <module>\n    data = ast.literal_eval(f\"({raw_input})\")\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    (mat = [[1,0,0,0],[1,1,1,1],[1,0,0,0],[1,0,0,0]], k = 2)\n     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def kWeakestRows(self, mat, k):\n        def count_soldiers(row):\n            left, right = 0, len(row)\n            while left < right:\n                mid = (left + right) // 2\n                if row[mid] == 1:\n                    left = mid + 1\n                else:\n                    right = mid\n            return left\n\n        soldiers = [(count_soldiers(row), i) for i, row in enumerate(mat)]\n        soldiers.sort()\n        return [i for _, i in soldiers[:k]]\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n    # Parse input like: \"mat = [[1,1,0], [1,0,0]], k = 2\"\n    data = ast.literal_eval(f\"({raw_input})\")\n    mat = data[\"mat\"]\n    k = data[\"k\"]\n\n    sol = Solution()\n    result = sol.kWeakestRows(mat, k)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to output virtual code lines in Chinese, each line: \"虛擬碼步驟 // 解釋\". We need to describe algorithm. Use Start, End, Decision. We need to not output actual code, just virtual steps.\n\nWe need to generate algorithm for k weakest rows: compute soldier count per row (binary matrix sorted), we can binary search each row or just count until first 0. Then we need to sort rows by count then index. Then output first k indices. Virtual steps: Input matrix, input k. For each row i: count soldiers. Then create list of (count, index). Sort by count ascending then index ascending. Then take first k indices. Output them.\n\nWe can include steps like: Start, Input matrix, Input k, For each row, Count soldiers via binary search, Store pair, After loop, Sort list by (count, index), Initialize result list, For first k elements, add index to result, Output result, End.\n\nNeed to use arrow \"→\" to indicate next step, and decisions with Yes → No →.\n\nLet's produce lines. Ensure each line has \"虛擬碼步驟 // 解釋\". Steps include indentation perhaps for decision branches. We can produce something like:\n\nStart // 程式開始\n→ Input mat, k // 取得矩陣和 k 的值\n→ Initialize empty list pairs // 用於存放 (soldierCount, rowIndex)\n→ For i from 0 to m-1: // 遍歷每一行\n    → Count soldiers in row i via binary search // 由於 1 在左側，使用二分查找快速計數\n    → Append (count, i) to pairs // 记录该行信息\n→ Sort pairs by count ascending, then index ascending // 按士兵数和行号排序\n→ Initialize empty list result // 存放最弱 k 行的索引\n→ For j from 0 to k-1: // 取前 k 个\n    → Append pairs[j].index to result // 加入索引\n→ Output result // 返回结果\nEnd // 程式結束\n\nBut need to use arrows: \"→ Step\". Also decision: maybe for binary search: Decision: 找到第一個 0? Yes/No. But we can keep simple.\n\nWe can show binary search as:\n\n→ Decision: row[i][mid] == 1? // 判断中间值\n    Yes → left = mid+1 // 继续在右侧搜索\n    No  → right = mid-1 // 在左侧搜索\n\nBut might be too many lines. However requirement: Provide virtual code step by step. Could include detailed binary search inside loop.\n\nLet's produce a moderate number of lines: maybe around 20.\n\nOk. Let's craft.\n\nUse indentation with tab or spaces? Use spaces.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Input mat, k // 取得二元矩陣和 k 的值\n→ Initialize list pairs = [] // 存放每行的士兵數與索引\n→ For i in 0 .. m-1: // 遍歷每一行\n    → left = 0, right = n-1 // 二分搜尋範圍\n    → While left <= right: // 二分搜尋尋找第一個 0\n        → mid = (left + right) // 2\n        → Decision: mat[i][mid] == 1? // 判斷中間元素是否為 1\n            Yes → left = mid + 1 // 尋找右半段\n            No  → right = mid - 1 // 尋找左半段\n    → soldierCount = left // left 為第一個 0 的索引，也即 1 的數量\n    → Append (soldierCount, i) to pairs // 記錄行資訊\n→ Sort pairs by first (soldierCount) ascending, then second (i) ascending // 按士兵數和行號排序\n→ Initialize list result = [] // 儲存最弱 k 行索引\n→ For j in 0 .. k-1: // 取前 k 個\n    → Append pairs[j].second to result // 加入行索引\n→ Output result // 回傳結果\nEnd // 程式結束\n\nWe need each line to be separate, with \"虛擬碼步驟 // 解釋\". Also arrows at start of each step line. For lines inside loops, maybe indent with spaces, but still each line counts.\n\nWe can also include arrow for \"Decision:\" lines.\n\nWe need to use \"Decision:\" prefix before condition. Use \"Decision: ...\" Then branch lines start with Yes → and No →.\n\nMake sure each line has arrow: \"→\" before step text. For Decision lines, maybe \"Decision:\" line has no arrow? But specification: Use virtual code's arrows (→, Yes →, No →). So for Decision we should have \"Decision:\" line preceded by \"→\" maybe. Let's produce:\n\n→ Decision: mat[i][mid] == 1? // 判斷中間元素是否為 1\n    Yes → left = mid + 1 // 尋找右半段\n    No  → right = mid - 1 // 尋找左半段\n\nMake sure indenting. Each line separate.\n\nAlso need \"Start // 程式開始執行\" with arrow? The example uses \"Start //\". So we don't use arrow before Start, just \"Start\". So pattern:\n\nStart // 程式開始執行\n→ Input mat, k // ...\n→ Initialize list pairs = [] // ...\n→ For i in 0 .. m-1: // ...\n    → left = 0, right = n-1 // ...\n    → While left <= right: // ...\n        → mid = (left + right) // 2 // ...\n        → Decision: mat[i][mid] == 1? // 判斷中間元素是否為 1\n            Yes → left = mid + 1 // ...\n            No  → right = mid - 1 // ...\n    → soldierCount = left // ...\n    → Append (soldierCount, i) to pairs // ...\n→ Sort pairs by first (soldierCount) ascending, then second (i) ascending // ...\n→ Initialize list result = [] // ...\n→ For j in 0 .. k-1: // ...\n    → Append pairs[j].second to result // ...\n→ Output result // ...\nEnd // 程式結束\n\nNeed to ensure each line ends with // explanation.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input mat, k // 取得二元矩陣與要求的 k 值  \n→ Initialize list pairs = [] // 用於存放每行的士兵數與行索引  \n→ For i in 0 .. m-1: // 遍歷每一行  \n    → left = 0, right = n-1 // 二分搜尋範圍設定  \n    → While left <= right: // 開始二分搜尋第一個 0  \n        → mid = (left + right) // 2 // 計算中間位置  \n        → Decision: mat[i][mid] == 1? // 判斷中間元素是否為 1  \n            Yes → left = mid + 1 // 右半段繼續搜尋  \n            No  → right = mid - 1 // 左半段繼續搜尋  \n    → soldierCount = left // left 為第一個 0 的索引，即 1 的個數  \n    → Append (soldierCount, i) to pairs // 記錄此行資訊  \n→ Sort pairs by first (soldierCount) ascending, then second (i) ascending // 按士兵數和行號排序  \n→ Initialize list result = [] // 儲存最弱 k 行的索引  \n→ For j in 0 .. k-1: // 取前 k 個最弱行  \n    → Append pairs[j].second to result // 加入行索引  \n→ Output result // 回傳結果  \nEnd // 程式結束"
    },
    {
      "title": "Cracking the Safe",
      "source_file": "Leetcode/leetcode753.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 1, k = 2",
          "expected_output": "\"10\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '10'\nGot (Norm):      '01'\n--- (Raw) ---\nRaw Expected: '\"10\"'\nRaw Got:      '01'"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef crack_safe(n: int, k: int) -> str:\n    \"\"\"產生最短可解鎖安全箱的輸入字串（De Bruijn 序列）。\"\"\"\n    if n == 1:\n        # n = 1 時每個字元本身即為一個長度 1 的序列\n        return ''.join(str(i) for i in range(k))\n\n    seen = set()\n    res = []\n\n    def dfs(node: str):\n        \"\"\"Hierholzer 的 DFS，產生 De Bruijn 圖的歐拉路徑。\"\"\"\n        for x in map(str, range(k)):\n            nei = node + x\n            if nei not in seen:\n                seen.add(nei)\n                dfs(nei[1:])      # 進入下一節點\n                res.append(x)     # 在回溯時把字元加到結果\n\n    start = \"0\" * (n - 1)\n    dfs(start)\n    # 把起始節點的字元加到序列末尾，形成線性序列\n    return ''.join(res) + start\n\ndef main() -> None:\n    data = re.findall(r'\\d+', sys.stdin.read())\n    if len(data) < 2:\n        return\n    n, k = map(int, data[:2])\n    result = crack_safe(n, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code lines to solve the problem: find a string of minimal length over alphabet size k that contains every possible length-n sequence (a De Bruijn sequence) as a substring. This is a classic problem. So algorithm: produce de Bruijn sequence B(k,n) of length k^n, plus (n-1) extra characters to wrap-around to allow the last sequences? Usually De Bruijn sequence of order n on alphabet k is cyclic of length k^n and contains each n-length sequence exactly once as a substring. For the safe: you input digits sequentially, the system checks the most recent n digits each time. To unlock at some point, we just need the input string to contain the password as a substring. So any de Bruijn sequence suffices. The minimal length string that contains all n-length sequences is k^n + n - 1, because a cyclic sequence of length k^n can be linearized by appending first n-1 characters to allow all substrings of length n. But we just need to contain the correct password; the minimal length that guarantees to include any possible password is k^n + n - 1. So algorithm: produce de Bruijn sequence using standard algorithm (preferably lexicographic). So produce sequence via DFS (Hierholzer's algorithm on de Bruijn graph). Steps: construct graph where nodes are strings of length n-1; edges correspond to digits appended. Use DFS to find Eulerian cycle. Then output sequence of digits. Then append first n-1 digits of sequence to linear string. Output that. Implementation detail: Use recursive DFS function visit(node). For each digit from 0 to k-1: edge = node + digit; if edge not visited: mark visited, visit(next node), append digit to sequence. After DFS, sequence reversed gives cycle. Then take sequence + first n-1 of sequence.\n\nWe need to provide virtual code lines with explanation, step by step. Not actual code but structure. So produce steps: Start, Initialize variables, Build graph, DFS, Build sequence, Append prefix, End. Use decision arrows for loops and recursion. Use \"Yes →\" etc. Provide explanation after each line. Should be in Chinese Traditional.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 輸入 k 與 n // 取得字母表大小與密碼長度\n→ Step 2: 建立空集合 visitedEdges // 追蹤已使用的邊\n→ Step 3: 建立空串 seq // 用於儲存生成的 De Bruijn 序列\n→ Decision: 如果 n = 1? // 特殊情況，單字元密碼\n    Yes → Step 4: seq ← 0,1,…,k-1 的連續字串 // 所有單字元都出現一次\n    No  → Step 5: 進行一般 De Bruijn 生成\n→ Step 5: 定義函式 DFS(node) // node 為長度 n-1 的字串\n    → Decision: 是否所有從 node 出發的邊已被訪問? // 判斷是否結束\n        Yes → Step 6: 返回 // 回到上一層呼叫\n        No  → For each digit d in [0, k-1] (lexicographic order)\n            → Step 7: edge ← node + d // 從 node 到下一節點的邊\n            → Decision: edge 是否已在 visitedEdges? \n                Yes → Next d // 跳過已使用的邊\n                No  → Step 8: visitedEdges ← visitedEdges ∪ {edge} // 標記為已使用\n                    → Step 9: DFS(nodeNext = node[1:]+d) // 進入下一節點\n                    → Step 10: seq ← seq + d // 在回溯時把 d 加入序列\n→ Step 11: 呼叫 DFS(node0 = \"0\"*(n-1)) // 從全 0 的節點開始\n→ Step 12: seq ← seq + first (n-1) 個字元 of seq // 轉成線性序列以覆蓋尾部子字串\n→ Step 13: 輸出 seq // 這就是最短可解鎖安全箱的輸入字串\nEnd // 程式執行結束"
    }
  ]
}