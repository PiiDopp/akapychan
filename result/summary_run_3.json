{
  "run_index": 3,
  "total_files_found": 391,
  "total_files_processed": 323,
  "files_skipped": 68,
  "files_failed_load": 0,
  "---": "--- (以下基於 *題目* 總數) ---",
  "total_problems_attempted": 334,
  "generation_and_validation_success_count": 286,
  "generation_or_validation_failure_count": 48,
  "failed_cases_details": [
    {
      "title": "統計文字行數",
      "source_file": "900.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "（假設 data.txt 內容如下）\\nHello\\nPython\\nWorld",
          "expected_output": "檔案共有 3 行",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '檔案共有3行'\nGot (Norm):      '找不到檔案！'\n--- (Raw) ---\nRaw Expected: '檔案共有 3 行'\nRaw Got:      '找不到檔案！'"
        }
      ],
      "generated_code": "import sys\n\ndef main():\n    # 讀取 stdin（如果有傳入資料，先消耗；若沒有則立即回傳空字串）\n    sys.stdin.read()\n\n    try:\n        # 使用 with 語法安全開啟檔案\n        with open('data.txt', 'r', encoding='utf-8') as f:\n            lines = f.readlines()          # 讀取所有行\n            print('檔案共有', len(lines), '行')  # 輸出行數\n    except FileNotFoundError:\n        # 檔案不存在時顯示錯誤訊息\n        print('找不到檔案！')\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code steps line by line. Each line: 虛擬碼步驟 + space + // 解釋. Use Start, End, Decision:, with arrow. Use with, try/except. So something like:\n\nStart // 程式開始執行\n→ Decision: 檔案是否存在? // 先判斷檔案是否存在\n    Yes → Step: 開啟檔案 with open('data.txt', 'r') as f // 使用 with 開啟檔案\n    No → Step: 輸出 '找不到檔案！' // 檔案不存在時顯示訊息\n→ Step: 讀取檔案內容為 lines = f.readlines() // 讀取所有行\n→ Step: 計算行數 count = len(lines) // 取得行數\n→ Step: 輸出 count // 顯示行數\nEnd // 程式結束\n\nBut we must include try/except for file opening. So maybe:\n\nStart\n→ Step: try\n→ Step:     with open('data.txt', 'r') as f\n→ Step:         lines = f.readlines()\n→ Step:         count = len(lines)\n→ Step:         print(count)\n→ Step: except FileNotFoundError\n→ Step:     print('找不到檔案！')\nEnd\n\nWe need to use Decision arrow maybe not necessary. But we can have Decision to handle exception.\n\nThe requirement: Use with and try/except. So produce step by step.\n\nWe should use `Decision: try?`? But better to show a Decision about whether file open succeeds? Not necessary.\n\nWe can simply show:\n\nStart // 程式開始\n→ Step: try // 嘗試打開檔案\n→ Step:     with open('data.txt', 'r') as f // 使用 with 語法打開檔案\n→ Step:         lines = f.readlines() // 讀取所有行\n→ Step:         count = len(lines) // 計算行數\n→ Step:         print(count) // 輸出行數\n→ Decision: 例外: FileNotFoundError? // 若檔案不存在則觸發此例外\n    Yes → Step: print('找不到檔案！') // 顯示錯誤訊息\n    No  → End // 沒有例外，程式結束\nEnd\n\nBut we should not use 'End' twice. Instead after printing maybe End.\n\nWe need each line include the 虛擬碼步驟 and explanation. Let's format accordingly.\n\nBetter structure:\n\nStart // 程式開始執行\n→ Decision: 嘗試打開檔案? // 開始 try 例外處理\n    Yes → Step: with open('data.txt', 'r') as f // 使用 with 開啟檔案\n    No  → Decision: 例外: FileNotFoundError? // 若開啟失敗\n        Yes → Step: print('找不到檔案！') // 檔案不存在時顯示訊息\n        No  → End // 其他例外不處理\n→ Step: lines = f.readlines() // 讀取所有行\n→ Step: count = len(lines) // 計算行數\n→ Step: print(count) // 輸出行數\nEnd // 程式結束\n\nBut we need to handle the fact that if file open fails, we don't execute further steps. We can use nested Decision.\n\nHowever simpler: just write try/except block as virtual code. That is:\n\nStart\n→ Step: try // 嘗試執行開檔案\n→ Step:     with open('data.txt', 'r') as f // 打開檔案\n→ Step:         lines = f.readlines() // 讀取內容\n→ Step:         count = len(lines) // 行數\n→ Step:         print(count) // 輸出\n→ Decision: except FileNotFoundError? // 例外檔案不存在\n    Yes → Step: print('找不到檔案！') // 顯示錯誤訊息\nEnd\n\nBut we need arrow formatting for Decision: Yes / No. In except block, we don't need No path. But we can use Yes arrow.\n\nLet's craft final answer accordingly.\n\nEnsure each line ends with // explanation. Use virtual code arrow. We'll output as code block.\n\nLet's produce:\n\n```\nStart // 程式開始執行\n→ Step: try // 嘗試執行以下區塊\n→ Step:     with open('data.txt', 'r') as f // 使用 with 開啟檔案\n→ Step:         lines = f.readlines() // 讀取所有行\n→ Step:         count = len(lines) // 計算行數\n→ Step:         print(count) // 輸出行數\n→ Decision: except FileNotFoundError? // 檔案不存在時進入此分支\n    Yes → Step: print('找不到檔案！') // 顯示錯誤訊息\nEnd // 程式執行結束\n```\n\nThat's it. Ensure each line has explanation. Use proper indentation? Not necessary. But each line as described. Let's produce final.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step: try // 嘗試執行以下區塊\n→ Step:     with open('data.txt', 'r') as f // 使用 with 語法開啟檔案\n→ Step:         lines = f.readlines() // 讀取所有行\n→ Step:         count = len(lines) // 計算行數\n→ Step:         print(count) // 輸出行數\n→ Decision: except FileNotFoundError? // 檔案不存在時進入此分支\n    Yes → Step: print('找不到檔案！') // 顯示錯誤訊息\nEnd // 程式執行結束\n```"
    },
    {
      "title": "模擬擲骰子遊戲",
      "source_file": "800.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "print(roll_dice(5))",
          "expected_output": "[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,6,1,4,2]#(結果會隨機，每次可能不同)'\nGot (Norm):      '[5,2,3,5,4]'\n--- (Raw) ---\nRaw Expected: '[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)'\nRaw Got:      '[5, 2, 3, 5, 4]'"
        }
      ],
      "generated_code": "import random\nimport sys\n\ndef roll_dice(n):\n    \"\"\"模擬擲 n 次六面骰，回傳結果串列。\"\"\"\n    results = []\n    for _ in range(n):\n        results.append(random.randint(1, 6))\n    return results\n\ndef main():\n    # 從標準輸入讀取程式碼，並執行\n    code = sys.stdin.read()\n    if code.strip():\n        exec(code, globals())\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. Steps: Start, step: import random, define function roll_dice(n), inside function initialize results list, loop i from 1 to n, generate random integer 1-6, append to list, after loop return list, End. Provide explanation per line. Format: each line \"虛擬碼步驟 // 解釋\". Use arrow syntax: \"Start // ...\", \"→ Step 1: import random // ...\", \"→ Step 2: Define function roll_dice(n) // ...\", \"→ Step 3: Initialize results list // ...\", \"→ Step 4: For i in 1 to n: // ...\" but need structure: loop. Use Decision? Not needed. Use \"→ Step 5: Generate random int 1-6 // ...\", \"→ Step 6: Append to results // ...\", \"→ Step 7: Return results // ...\", \"End // ...\".\n\nBut we need to show loop structure maybe: \"→ Step 4: For each i from 1 to n: // 開始迴圈\". \"→   Step 5: ...\". \"→   Step 6: ...\". \"→ Step 7: Return results // ...\". Ensure arrow indent or use whitespace? Use spaces. The example uses indentation by indenting inside decision branches. So we can indent steps inside loop with a tab or 4 spaces. Use \"→   Step 5:\" etc.\n\nWe should also include function definition lines with \"→ Step 2:\" etc. We need to include the function name, parameter. No real code.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: Import random 模組 // 允許產生亂數\n→ Step 2: Define function roll_dice(n) // 接收擲骰次數\n→   Step 3: Initialize empty list results // 儲存所有擲骰結果\n→   Step 4: For i from 1 to n // 迴圈擲 n 次\n→     Step 5: Generate random integer between 1 and 6 // 模擬擲骰\n→     Step 6: Append the random number to results // 保存結果\n→   Step 7: Return results // 回傳結果串列\nEnd // 程式執行結束\n\nBut we need arrow syntax: \"→ Step 1:\" etc. The steps inside loop should be indented but still preceded by \"→\". We should ensure each line has an arrow. Indentation may use spaces before arrow. Example: \"→   Step 3:\" etc. Provide explanation after comment. Each line ends with // Explanation.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Import random 模組 // 允許產生亂數  \n→ Step 2: Define function roll_dice(n) // 接收擲骰次數  \n→   Step 3: Initialize empty list results // 儲存所有擲骰結果  \n→   Step 4: For i from 1 to n // 迴圈擲 n 次  \n→     Step 5: Generate random integer between 1 and 6 // 模擬擲骰  \n→     Step 6: Append the random number to results // 保存結果  \n→   Step 7: Return results // 回傳結果串列  \nEnd // 程式執行結束"
    },
    {
      "title": "計算程式執行時間",
      "source_file": "800.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "import time\n\ndef slow_add(a, b):\n    time.sleep(2)\n    return a + b\n\nprint(measure_time(slow_add, 3, 5))",
          "expected_output": "約 2.0 秒 (依電腦執行環境略有差異)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '約2.0秒(依電腦執行環境略有差異)'\nGot (Norm):      '2.0'\n--- (Raw) ---\nRaw Expected: '約 2.0 秒 (依電腦執行環境略有差異)'\nRaw Got:      '2.0'"
        }
      ],
      "generated_code": "import time\nimport sys\n\ndef measure_time(func, *args):\n    \"\"\"\n    測量傳入函式 func 執行所需的秒數，並回傳四捨五入到小數點 3 位的結果。\n    \"\"\"\n    start = time.perf_counter()   # 記錄開始時間\n    result = func(*args)          # 執行目標函式\n    end = time.perf_counter()     # 記錄結束時間\n    elapsed = end - start         # 計算經過的秒數\n    return round(elapsed, 3)      # 四捨五入到三位小數\n\ndef main():\n    \"\"\"\n    讀取標準輸入，將內容視為 Python 程式碼執行。\n    程式碼中可直接使用 measure_time 函式。\n    \"\"\"\n    script = sys.stdin.read()         # 讀取整個輸入\n    # 建立執行環境，允許程式碼使用 measure_time\n    exec_namespace = {\"measure_time\": measure_time}\n    exec(script, exec_namespace)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for the function measure_time(func, *args) that measures execution time using time module, round to 3 decimal places, return result. We should include steps like import time, define function, record start, call func, record end, compute elapsed, round, return.\n\nWe need to use structure with Start, End, Decision, arrows. Provide each line: \"虛擬碼步驟 // 解釋\".\n\nLet's produce:\n\nStart\n→ Step 1: 匯入 time 模組 // 引入時間功能\n→ Step 2: 定義函數 measure_time(func, *args) // 建立測時函式\n    → Step 3: start = time.perf_counter() // 記錄起始時間\n    → Step 4: result = func(*args) // 執行目標函式\n    → Step 5: end = time.perf_counter() // 記錄結束時間\n    → Step 6: elapsed = end - start // 計算執行時間\n    → Step 7: elapsed_rounded = round(elapsed, 3) // 四捨五入至小數點三位\n    → Decision: 是否需要回傳結果? // 這裡回傳測試結果\n        Yes → Step 8: return elapsed_rounded, result // 回傳時間與函式結果\nEnd\n\nBut ensure format: Use \"Start\", \"End\". Use Decision: if needed. Provide arrows. Each line includes virtual code step then // explanation.\n\nLet's produce exactly.\n\nAlso note we should not output real code. But it's okay if we write \"import time\" etc. That's virtual code.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: import time // 匯入 time 模組以取得高精度計時功能\n→ Step 2: define function measure_time(func, *args) // 定義一個測量執行時間的函式\n    → Step 3: start = time.perf_counter() // 取得程式開始時的高精度時間\n    → Step 4: result = func(*args) // 執行傳入的函式，並將結果存回 result\n    → Step 5: end = time.perf_counter() // 取得程式結束時的高精度時間\n    → Step 6: elapsed = end - start // 計算函式執行所經過的秒數\n    → Step 7: elapsed_rounded = round(elapsed, 3) // 將秒數四捨五入到小數點三位\n    → Decision: 是否需要回傳測試結果? // 這裡決定是否同時回傳函式執行結果\n        Yes → Step 8: return elapsed_rounded, result // 回傳測量時間和原函式結果\nEnd // 程式執行結束"
    },
    {
      "title": "學生資料類別設計",
      "source_file": "1100.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "Alice 的分數是 90\nBob 的分數是 80",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'Alice的分數是90\\nBob的分數是80'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: 'Alice 的分數是 90\\nBob 的分數是 80'\nRaw Got:      ''"
        }
      ],
      "generated_code": "class Student:\n    def __init__(self, name, score):\n        self.name = name\n        self.score = score\n\n    def show_info(self):\n        print(f'{self.name} 的分數是 {self.score}')\n\n\ndef main():\n    import sys\n    data = sys.stdin.read().strip()\n    # 若無輸入，使用預設的兩個學生\n    if not data:\n        s1 = Student('Alice', 90)\n        s2 = Student('Bob', 80)\n        s1.show_info()\n        s2.show_info()\n        return\n\n    # 解析輸入，每一行應為「姓名 分數」\n    students = []\n    for line in data.splitlines():\n        parts = line.strip().split()\n        if len(parts) < 2:\n            continue  # 跳過不完整的行\n        name = parts[0]\n        try:\n            score = int(parts[1])\n        except ValueError:\n            score = 0  # 若分數無法轉成整數，預設 0\n        students.append(Student(name, score))\n\n    # 印出所有學生資訊\n    for student in students:\n        student.show_info()\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code lines with explanation after space. No actual code. Just pseudo code lines with arrows etc. Provide step-by-step: Start, define class Student, etc. The user wants to define class with init, method show_info, create two instances and call show_info. We'll produce virtual steps accordingly.\n\nMake sure each line has \"虛擬碼步驟\" + space + \"// 解釋/說明\". Use arrows. E.g., Start, → Step: Define class Student. But we need to use proper pseudo code structure: Start, then arrow lines. Possibly we should include Decision lines? Not necessary. We'll just list.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 定義 Class Student // 定義學生類別\n→ Step 2: 於 __init__(self, name, score) 初始化屬性 // 建構子設定姓名與分數\n→ Step 3: 定義方法 show_info(self) // 建立顯示資訊的方法\n→ Step 4: 在 show_info() 中輸出 'name 的分數是 score' // 顯示學生姓名與分數\n→ Step 5: 建立物件 student1 = Student('Alice', 88) // 創建第一個學生實例\n→ Step 6: 建立物件 student2 = Student('Bob', 76) // 創建第二個學生實例\n→ Step 7: 呼叫 student1.show_info() // 顯示第一位學生資訊\n→ Step 8: 呼叫 student2.show_info() // 顯示第二位學生資訊\nEnd // 程式執行結束\n\nBut we should also show arrows for each step. They said use 虛擬碼箭頭 (→, Yes →, No →) and structure (Start, End, Decision:). So we can use Start and End. Steps can use arrow. The steps may be numbered or labeled. Use \"Step\" maybe but not necessary. We need each line with \"虛擬碼步驟\" then space then comment. We can incorporate the step description.\n\nWe need to follow the output format. Each line: \"虛擬碼步驟\" then space then \"// 解釋/說明\". So we must produce something like:\n\nStart // 程式開始執行\n→ Step: 定義 Class Student // 定義學生類別\n→ Step: __init__(self, name, score) 初始化屬性 // 建構子設定姓名與分數\n→ Step: 定義方法 show_info(self) // 建立顯示資訊的方法\n→ Step: 在 show_info() 中輸出 'name 的分數是 score' // 顯示學生姓名與分數\n→ Step: 建立物件 student1 = Student('Alice', 88) // 創建第一個學生實例\n→ Step: 建立物件 student2 = Student('Bob', 76) // 創建第二個學生實例\n→ Step: 呼叫 student1.show_info() // 顯示第一位學生資訊\n→ Step: 呼叫 student2.show_info() // 顯示第二位學生資訊\nEnd // 程式執行結束\n\nBut we need to ensure we don't output actual code, but just pseudocode lines. Use arrow.\n\nWe need to ensure that each line after \"虛擬碼步驟\" includes explanation. The \"虛擬碼步驟\" can be like \"Step 1: ...\". Should be consistent.\n\nWe'll output accordingly. Ensure it's in Traditional Chinese. Use \"虛擬碼步驟\" or \"Step\". The example uses \"Step\". So we can use \"Step 1:\" etc.\n\nThus produce lines:\n\nStart // 程式開始執行\n→ Step 1: 定義 Class Student // 定義學生類別\n→ Step 2: __init__(self, name, score) 初始化屬性 // 建構子設定姓名與分數\n→ Step 3: 定義方法 show_info(self) // 建立顯示資訊的方法\n→ Step 4: 在 show_info() 中輸出 'name 的分數是 score' // 顯示學生姓名與分數\n→ Step 5: 建立物件 student1 = Student('Alice', 88) // 創建第一個學生實例\n→ Step 6: 建立物件 student2 = Student('Bob', 76) // 創建第二個學生實例\n→ Step 7: 呼叫 student1.show_info() // 顯示第一位學生資訊\n→ Step 8: 呼叫 student2.show_info() // 顯示第二位學生資訊\nEnd // 程式執行結束\n\nYes. Ensure no actual code like \"Student('Alice', 88)\"? It's okay but it's just pseudo code. But maybe we should avoid actual string. But it's still fine.\n\nBetter keep the pseudo representation but not real code. But it's okay.\n\nLet's output accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義 Class Student // 定義學生類別\n→ Step 2: __init__(self, name, score) 初始化屬性 // 建構子設定姓名與分數\n→ Step 3: 定義方法 show_info(self) // 建立顯示資訊的方法\n→ Step 4: 在 show_info() 中輸出 'name 的分數是 score' // 顯示學生姓名與分數\n→ Step 5: 建立物件 student1 = Student('Alice', 88) // 創建第一個學生實例\n→ Step 6: 建立物件 student2 = Student('Bob', 76) // 創建第二個學生實例\n→ Step 7: 呼叫 student1.show_info() // 顯示第一位學生資訊\n→ Step 8: 呼叫 student2.show_info() // 顯示第二位學生資訊\nEnd // 程式執行結束"
    },
    {
      "title": "集合函數練習",
      "source_file": "600.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "{'apple', 'orange', 'grape', 'melon'}",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '{\"apple\",\"orange\",\"grape\",\"melon\"}'\nGot (Norm):      '{\"grape\",\"orange\",\"melon\",\"apple\"}'\n--- (Raw) ---\nRaw Expected: \"{'apple', 'orange', 'grape', 'melon'}\"\nRaw Got:      \"{'grape', 'orange', 'melon', 'apple'}\""
        }
      ],
      "generated_code": "import sys\n\ndef main():\n    # 讀取輸入（此程式不需要任何輸入，只是為了符合需求）\n    _ = sys.stdin.read()\n\n    # 建立初始集合\n    fruits = {'apple', 'banana'}\n\n    # 新增 'orange'\n    fruits.add('orange')\n\n    # 一次新增 'grape' 與 'melon'\n    fruits.update(['grape', 'melon'])\n\n    # 移除 'banana'\n    fruits.remove('banana')\n\n    # 嘗試移除不存在的 'pineapple'\n    fruits.discard('pineapple')\n\n    # 輸出最終集合\n    print(fruits)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step, with each line containing \"虛擬碼步驟\" then a space then \"// 解釋/說明\". Use virtual code arrow, structure. Let's craft.\n\nStart // 程式開始執行\n\n→ Step 1: Initialize fruits = {'apple', 'banana'} // 建立集合\n\n→ Step 2: Call fruits.add('orange') // 新增 'orange' 到集合\n\n→ Step 3: Call fruits.update(['grape', 'melon']) // 一次新增 'grape' 與 'melon'\n\n→ Step 4: Call fruits.remove('banana') // 移除 'banana'，若不存在會拋錯\n\n→ Step 5: Call fruits.discard('pineapple') // 嘗試移除 'pineapple'，不存在則不拋錯\n\n→ Step 6: Output fruits // 顯示最終集合\n\nEnd // 程式結束\n\nWe must include decision? No decisions. Just steps.\n\nLet's produce each line. Ensure arrow at beginning: \"→\" then step description. For start use \"Start\". End use \"End\". Provide explanation after //.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Initialize fruits = {'apple', 'banana'} // 建立集合 fruits  \n→ Step 2: Call fruits.add('orange') // 新增 'orange' 到集合  \n→ Step 3: Call fruits.update(['grape', 'melon']) // 一次新增 'grape' 與 'melon'  \n→ Step 4: Call fruits.remove('banana') // 移除 'banana'，若不存在將拋錯  \n→ Step 5: Call fruits.discard('pineapple') // 嘗試移除 'pineapple'，不存在則不拋錯  \n→ Step 6: Output fruits // 顯示最終集合  \nEnd // 程式執行結束"
    },
    {
      "title": "即時匯率查詢小工具",
      "source_file": "1200.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "按下「更新匯率」按鈕",
          "expected_output": "目前美元匯率：約 32.5 TWD",
          "actual_output_or_error": "[Validation Error] Code execution timed out (10s)."
        }
      ],
      "generated_code": "import sys\nimport requests\nimport tkinter as tk\n\n# ---------- 取得匯率 ----------\ndef fetch_rate():\n    \"\"\"\n    取得美金對台幣(TWD)的匯率。\n    成功時回傳浮點數匯率；失敗時回傳 None。\n    \"\"\"\n    try:\n        url = 'https://api.exchangerate-api.com/v4/latest/USD'\n        resp = requests.get(url, timeout=5)\n        resp.raise_for_status()\n        data = resp.json()\n        return float(data['rates']['TWD'])\n    except Exception:\n        return None\n\n# ---------- GUI -------------\nroot = tk.Tk()\nroot.title('匯率查詢')\n\nlabel = tk.Label(root, text='請按下按鈕更新匯率', font=('Arial', 12))\nlabel.pack(pady=10)\n\ndef update_label():\n    \"\"\"\n    取得匯率並更新標籤顯示。\n    \"\"\"\n    rate = fetch_rate()\n    if rate is None:\n        label.config(text='更新失敗，請檢查網路連線')\n    else:\n        # 以一位小數顯示，避免多餘的 0\n        formatted = f\"{rate:.2f}\".rstrip('0').rstrip('.')\n        label.config(text=f'美元兌台幣: 約 {formatted} TWD')\n\ntk.Button(root, text='更新匯率', command=update_label).pack(pady=5)\n\n# ---------- CLI -------------\ndef cli_output():\n    \"\"\"\n    若標準輸入包含「更新匯率」字串，則印出匯率。\n    \"\"\"\n    input_text = sys.stdin.read().strip()\n    if '更新匯率' in input_text:\n        rate = fetch_rate()\n        if rate is None:\n            print('更新失敗，請檢查網路連線')\n        else:\n            formatted = f\"{rate:.2f}\".rstrip('0').rstrip('.')\n            print(f'目前美元匯率：約 {formatted} TWD')\n\n# ---------- 主程式入口 ----------\nif __name__ == '__main__':\n    # 先處理 CLI 輸入，若有則印出結果\n    cli_output()\n    # 再啟動 GUI 事件迴圈\n    root.mainloop()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations, following the format: each line: \"虛擬碼步驟 // 解釋/說明\". Use arrow notation. Include Start, End, Decision. Provide steps for importing modules, setting up tkinter window, defining function to fetch rate, update label, create button, main loop. Use Decision for error handling maybe.\n\nWe must not output real code, only virtual code. Provide each line. Use Chinese. Use \"→\" for sequence. Provide \"Decision:\" lines where needed. Ensure formatting as sample.\n\nLet's write:\n\nStart\n→ Import requests // 導入requests模組\n→ Import tkinter as tk // 導入tkinter模組\n→ Define API_URL = 'https://api.exchangerate-api.com/v4/latest/USD' // API網址\n→ Step 1: 建立主視窗 root = tk.Tk() // 創建Tk窗口\n→ Step 2: 設置視窗標題 root.title('USD to TWD 匯率') // 設定窗口標題\n→ Step 3: 創建標籤 label = tk.Label(root, text='匯率: 加載中...', font=('Arial', 14)) // 標籤顯示匯率\n→ Step 4: 放置標籤 label.pack(pady=20) // 將標籤放置在窗口\n→ Step 5: 創建按鈕 update_button = tk.Button(root, text='更新匯率', command=fetch_rate) // 按鈕觸發更新\n→ Step 6: 放置按鈕 update_button.pack(pady=10) // 按鈕放置\n→ Step 7: 定義函數 fetch_rate() // 定義取得匯率的函數\n    → Decision: 如果已經連接到網路? // 判斷網路狀態\n        Yes → Step 7.1: 透過 requests.get(API_URL) 取得資料 // 取得JSON\n        No  → Step 7.2: 更新標籤 label.config(text='無法連接網路') // 顯示錯誤\n    → Step 7.3: Decision: 如果回傳狀態碼 200? // 檢查成功\n        Yes → Step 7.4: 解析 JSON 取得 rates['TWD'] // 取TWD匯率\n        No  → Step 7.5: 更新標籤 label.config(text='取得匯率失敗') // 顯示失敗\n    → Step 7.6: Decision: 如果成功取得匯率? // 確認匯率\n        Yes → Step 7.7: 更新標籤 label.config(text=f'美元兌台幣: {rate}') // 顯示匯率\n        No  → Step 7.8: 更新標籤 label.config(text='匯率資料遺失') // 顯示遺失\n→ Step 8: 主程序結束前呼叫 fetch_rate() 以初始載入匯率 // 初始化匯率\n→ Step 9: root.mainloop() // 啟動Tk事件迴圈\nEnd\n\nWe need each line separate. Use indentation? The example uses indentation for nested decision lines. Let's format accordingly. Use \"→\" for sequence lines. Use \"Decision:\" lines. Provide explanation after \"//\".\n\nWe must avoid actual code. Provide only virtual steps.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Import requests // 導入 requests 模組以發送 HTTP 請求  \n→ Import tkinter as tk // 導入 tkinter 模組以建立 GUI  \n→ 定義 API_URL = 'https://api.exchangerate-api.com/v4/latest/USD' // 設定匯率 API 的 URL  \n→ Step 1: 建立主視窗 root = tk.Tk() // 創建 Tk 主視窗  \n→ Step 2: 設置視窗標題 root.title('USD to TWD 匯率') // 給窗口一個標題  \n→ Step 3: 創建標籤 label = tk.Label(root, text='匯率: 加載中...', font=('Arial', 14)) // 標籤顯示匯率資訊  \n→ Step 4: 放置標籤 label.pack(pady=20) // 把標籤放到窗口中  \n→ Step 5: 創建按鈕 update_button = tk.Button(root, text='更新匯率', command=fetch_rate) // 按鈕點擊時呼叫 fetch_rate  \n→ Step 6: 放置按鈕 update_button.pack(pady=10) // 把按鈕放到窗口中  \n→ Step 7: 定義函數 fetch_rate() // 定義用來取得並更新匯率的函數  \n    → Decision: 如果網路可用? // 檢查是否能連接網路  \n        Yes → Step 7.1: 發送 GET 請求取得 JSON 資料 // 用 requests.get 取得 API 回應  \n        No  → Step 7.2: 更新標籤 label.config(text='無法連接網路') // 顯示網路錯誤訊息  \n    → Step 7.3: Decision: 回應狀態碼是否為 200? // 檢查 API 回應是否成功  \n        Yes → Step 7.4: 解析 JSON 取得 rates['TWD'] // 抽取美元兌台幣的匯率值  \n        No  → Step 7.5: 更新標籤 label.config(text='取得匯率失敗') // 顯示失敗訊息  \n    → Step 7.6: Decision: 是否成功取得匯率? // 確認匯率是否存在  \n        Yes → Step 7.7: 更新標籤 label.config(text=f'美元兌台幣: {rate}') // 顯示最新匯率  \n        No  → Step 7.8: 更新標籤 label.config(text='匯率資料遺失') // 顯示遺失訊息  \n→ Step 8: 呼叫 fetch_rate() 以初始載入匯率 // 在程序啟動時先取得一次匯率  \n→ Step 9: root.mainloop() // 啟動 tkinter 事件迴圈，等待使用者互動  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Flip Matrix",
      "source_file": "Leetcode/leetcode519.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"flip\", \"flip\", \"flip\", \"reset\", \"flip\"], [[3, 1], [], [], [], [], []]",
          "expected_output": "[null, [1,0], [2,0], [0,0], null, [2,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[1,0],[2,0],[0,0],null,[2,0]]'\nGot (Norm):      '[null,[0,0],[2,0],[1,0],null,[1,0]]'\n--- (Raw) ---\nRaw Expected: '[null, [1,0], [2,0], [0,0], null, [2,0]]'\nRaw Got:      '[null, [0, 0], [2, 0], [1, 0], null, [1, 0]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, m, n):\n        self.m = m\n        self.n = n\n        self.total = m * n          # total cells\n        self.flipped = {}           # mapping for random index\n\n    def flip(self):\n        # 隨機選擇一個未翻轉的索引\n        r = random.randint(0, self.total - 1)\n        # 實際索引：若已映射則取映射值，否則直接用 r\n        x = self.flipped.get(r, r)\n\n        # 把最後一個未翻轉的索引映射到 r\n        last = self.total - 1\n        self.flipped[r] = self.flipped.get(last, last)\n        self.total -= 1\n\n        # 把線性索引轉回 (row, col)\n        return [x // self.n, x % self.n]\n\n    def reset(self):\n        self.total = self.m * self.n\n        self.flipped.clear()\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 解析輸入為兩個列表：commands 與 arguments\n    raw = '[' + data + ']'\n    commands, arguments = json.loads(raw)\n\n    result = []\n    sol = None\n\n    for cmd, arg in zip(commands, arguments):\n        if cmd == \"Solution\":\n            sol = Solution(*arg)\n            result.append(None)\n        elif cmd == \"flip\":\n            result.append(sol.flip())\n        elif cmd == \"reset\":\n            sol.reset()\n            result.append(None)\n\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to produce virtual code in lines with comments. The algorithm: Use reservoir or mapping approach. Typical solution: keep list of all indices from 0 to m*n-1. On flip, pick random r in [0, remaining-1], get value idx = mapping.get(r, r); mapping[r] = mapping.get(remaining-1, remaining-1); decrement remaining. Convert idx to (i,j). Reset clears mapping and remaining.\n\nImplement virtual code: start, initialize variables m,n,total, remaining, mapping. flip: choose random index, get actual index, map update, compute row, col, return [row,col]. reset: reset remaining, clear mapping.\n\nWe need to show steps, with arrow and decisions. Each line has \"虛擬碼步驟\" and comment. Use Chinese comments. Provide structure with Start, End, Decision. Should minimize random calls: one per flip.\n\nLet's produce lines:\n\nStart\n→ Step 1: 初始化 m, n, total = m*n, remaining = total, mapping = 空哈希表 // 設置矩陣尺寸與空值映射\n→ Decision: 是否需要重置? // 只在 reset 時執行\n    No → End\n\nBut need separate steps for methods. We'll create separate flows: Init, flip, reset. Could treat each method as sub-block.\n\nBetter: Start; define class Solution; then define constructor; then define flip; then define reset; End.\n\nWe must follow output format: each line with virtual code step and comment. Use arrow.\n\nLet's craft:\n\nStart // 程式開始執行\n\n→ Step 1: 定義類 Solution // 建立類別\n\n→ Step 2: Solution(m, n): // 建構子\n    → Step 3: 設定 this.m = m, this.n = n // 儲存維度\n    → Step 4: this.total = m * n // 總格數\n    → Step 5: this.remaining = this.total // 還未被翻轉的格數\n    → Step 6: this.mapping = 空哈希表 // 用於映射抽取\n\n→ Step 7: flip(): // 隨機翻轉\n    → Step 8: r = 隨機整數 [0, this.remaining - 1] // 選擇剩餘格子中的一個\n    → Decision: mapping 是否包含 r? // 判斷 r 是否已映射\n        Yes → actual = mapping[r] // 若有映射，取對應格子\n        No  → actual = r // 否則直接用 r\n    → Step 9: last = this.remaining - 1 // 最後一個未被翻轉的格子\n    → Decision: mapping 是否包含 last? // 判斷 last 是否已映射\n        Yes → mapping[r] = mapping[last] // 把最後一個映射給 r\n        No  → mapping[r] = last // 直接映射\n    → Step 10: this.remaining -= 1 // 已翻轉一格\n    → Step 11: row = actual // this.m? // 行索引\n    → Step 12: col = actual % this.n // 列索引\n    → Step 13: return [row, col] // 返回並翻轉\n\n→ Step 14: reset(): // 重置\n    → Step 15: this.remaining = this.total // 還原剩餘格數\n    → Step 16: this.mapping.clear() // 清空映射\n\nEnd // 程式執行結束\n\nNeed to ensure each line has a space after 虛擬碼步驟 before //.\n\nAlso use arrows appropriately. But we can keep one line per step, using arrows for decision branches.\n\nThe example uses indentation for decisions: use tab? Just indent lines with arrow. Use the format:\n\n→ Decision: ... \n    Yes → ...\n    No  → ...\n\nWe need to ensure the comments after //.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類 Solution // 建立類別  \n→ Step 2: Solution(m, n): // 建構子  \n  → Step 3: 設定 this.m = m, this.n = n // 儲存維度  \n  → Step 4: this.total = m * n // 總格數  \n  → Step 5: this.remaining = this.total // 還未被翻轉的格數  \n  → Step 6: this.mapping = 空哈希表 // 用於映射抽取  \n→ Step 7: flip(): // 隨機翻轉  \n  → Step 8: r = 隨機整數 [0, this.remaining - 1] // 選擇剩餘格子中的一個  \n  → Decision: mapping 是否包含 r? // 判斷 r 是否已映射  \n   Yes → Step 9: actual = mapping[r] // 取對應格子  \n   No  → Step 9: actual = r // 直接使用 r  \n  → Step 10: last = this.remaining - 1 // 最後一個未被翻轉的格子  \n  → Decision: mapping 是否包含 last? // 判斷 last 是否已映射  \n   Yes → Step 11: mapping[r] = mapping[last] // 把最後一個映射給 r  \n   No  → Step 11: mapping[r] = last // 直接映射  \n  → Step 12: this.remaining -= 1 // 已翻轉一格  \n  → Step 13: row = actual // 行索引  \n  → Step 14: col = actual % this.n // 列索引  \n  → Step 15: return [row, col] // 返回並翻轉  \n→ Step 16: reset(): // 重置  \n  → Step 17: this.remaining = this.total // 還原剩餘格數  \n  → Step 18: this.mapping.clear() // 清空映射  \nEnd // 程式執行結束"
    },
    {
      "title": "Search in Rotated Sorted Array",
      "source_file": "Leetcode/leetcode33.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [4,5,6,7,0,1,2], target = 0",
          "expected_output": "4",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpwmqj_fa4.py\", line 37, in <module>\n    nums, target = parse_input(raw_input)\n                   ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpwmqj_fa4.py\", line 29, in parse_input\n    target_str = target_part.split('=', 1)[1].strip()\n                 ~~~~~~~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        },
        {
          "example_index": 1,
          "input": "nums = [4,5,6,7,0,1,2], target = 3",
          "expected_output": "-1",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpuojl1xcu.py\", line 37, in <module>\n    nums, target = parse_input(raw_input)\n                   ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpuojl1xcu.py\", line 29, in parse_input\n    target_str = target_part.split('=', 1)[1].strip()\n                 ~~~~~~~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def search(self, nums, target):\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            if nums[left] <= nums[mid]:  # left half is sorted\n                if nums[left] <= target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            else:  # right half is sorted\n                if nums[mid] < target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n        return -1\n\ndef parse_input(data):\n    \"\"\"Parse input like 'nums = [4,5,6,7,0,1,2], target = 0'.\"\"\"\n    parts = [p.strip() for p in data.split(',')]\n    nums_part = parts[0]\n    target_part = parts[1] if len(parts) > 1 else ''\n    nums_str = nums_part.split('=', 1)[1].strip()\n    target_str = target_part.split('=', 1)[1].strip()\n    nums = ast.literal_eval(nums_str)\n    target = int(target_str)\n    return nums, target\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    if raw_input:\n        nums, target = parse_input(raw_input)\n        result = Solution().search(nums, target)\n        print(result)",
      "virtual_code": "Thinking...\nWe need produce pseudo-code lines with explanations. The requirement: Use virtual code with arrows, structure, each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision. We must not output actual code. Just steps. We should produce algorithm for searching target in rotated sorted array O(log n). So steps: start, set low=0, high=length-1, loop while low <= high, mid = (low+high)/2, if nums[mid]==target return mid, else check which half is sorted: if nums[low] <= nums[mid] then left half sorted; if target in [nums[low], nums[mid]) then high=mid-1 else low=mid+1; else right half sorted; if target in (nums[mid], nums[high]] then low=mid+1 else high=mid-1. End loop return -1. We'll produce each step line. Use arrows for flow. For decision lines, use \"Decision:\" etc.\n\nWe need to list lines sequentially. Provide explanation for each line. Must use \"虛擬碼步驟\" before explanation. For example:\n\nStart // 程式開始執行\n\n→ Step 1: low ← 0 // 初始化低指標為陣列起點\n\n→ Step 2: high ← n - 1 // 初始化高指標為陣列結尾\n\n→ Decision: 是否還有元素未檢查? (low ≤ high) // 檢查迴圈條件\n\nYes → Step 3: mid ← (low + high) / 2 // 計算中間索引\n\n... etc.\n\nWe must produce a step-by-step. Include \"End\" after return -1.\n\nLet's produce 20-25 lines.\n\nAlso ensure each line ends with comment. Use Chinese comments. Must not output code but pseudo-code. Use arrow \"→\" for flow. Use indentation for nested decisions? We can indent with spaces.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: low ← 0 // 設定搜尋範圍左端\n→ Step 2: high ← nums.length - 1 // 設定搜尋範圍右端\n→ Decision: low ≤ high? // 判斷是否還有區間需要搜尋\n    Yes → Step 3: mid ← (low + high) / 2 // 取中間索引\n    Yes → Decision: nums[mid] = target? // 檢查中間值是否為目標\n        Yes → Step 4: return mid // 找到目標，返回索引\n        No → Decision: nums[low] ≤ nums[mid]? // 判斷左半段是否有序\n            Yes → Decision: nums[low] ≤ target < nums[mid]? // 目標是否在左半段\n                Yes → Step 5: high ← mid - 1 // 限縮搜尋至左半段\n                No  → Step 6: low ← mid + 1 // 目標在右半段，移到右側\n            No  → Decision: nums[mid] < target ≤ nums[high]? // 目標是否在右半段\n                Yes → Step 7: low ← mid + 1 // 移至右半段\n                No  → Step 8: high ← mid - 1 // 移至左半段\n    No  → Step 9: return -1 // 未找到目標，返回 -1\nEnd // 程式結束\n\nEnsure each line contains \"→\" except Start/End. The decisions indentation may need spaces. Also include arrow for decisions lines? They use \"Decision:\" lines. Use \"→ Decision:\" at beginning of line. We can produce.\n\nLet's write final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: low ← 0 // 設定搜尋範圍左端  \n→ Step 2: high ← nums.length - 1 // 設定搜尋範圍右端  \n→ Decision: low ≤ high? // 判斷是否還有區間需要搜尋  \n  Yes → Step 3: mid ← (low + high) / 2 // 取中間索引  \n  Yes → Decision: nums[mid] = target? // 檢查中間值是否為目標  \n    Yes → Step 4: return mid // 找到目標，返回索引  \n    No → Decision: nums[low] ≤ nums[mid]? // 判斷左半段是否有序  \n      Yes → Decision: nums[low] ≤ target < nums[mid]? // 目標是否在左半段  \n       Yes → Step 5: high ← mid - 1 // 限縮搜尋至左半段  \n       No → Step 6: low ← mid + 1 // 目標在右半段，移到右側  \n      No → Decision: nums[mid] < target ≤ nums[high]? // 目標是否在右半段  \n       Yes → Step 7: low ← mid + 1 // 移至右半段  \n       No → Step 8: high ← mid - 1 // 移至左半段  \n  No → Step 9: return -1 // 未找到目標，返回 -1  \nEnd // 程式結束"
    },
    {
      "title": "Find K Pairs with Smallest Sums",
      "source_file": "Leetcode/leetcode373.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums1 = [1,7,11], nums2 = [2,4,6], k = 3",
          "expected_output": "[[1,2],[1,4],[1,6]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[1,2],[1,4],[1,6]]'\nGot (Norm):      '[[[1,2],[1,4],[1,6]]]'\n--- (Raw) ---\nRaw Expected: '[[1,2],[1,4],[1,6]]'\nRaw Got:      '[[[1,2],[1,4],[1,6]]]'"
        },
        {
          "example_index": 1,
          "input": "nums1 = [1,1,2], nums2 = [1,2,3], k = 2",
          "expected_output": "[[1,1],[1,1]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[1,1],[1,1]]'\nGot (Norm):      '[[[1,1],[1,1]]]'\n--- (Raw) ---\nRaw Expected: '[[1,1],[1,1]]'\nRaw Got:      '[[[1,1],[1,1]]]'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport heapq\nimport ast\n\nclass Solution:\n    def kSmallestPairs(self, nums1, nums2, k):\n        if not nums1 or not nums2:\n            return []\n        heap = []\n        res = []\n        # 初始化堆，使用 nums1 前 min(k, len(nums1)) 個元素與 nums2[0]\n        for i in range(min(k, len(nums1))):\n            heapq.heappush(heap, (nums1[i] + nums2[0], i, 0))\n        # 取出最小和，直到得到 k 個對\n        while heap and len(res) < k:\n            _, i, j = heapq.heappop(heap)\n            res.append([nums1[i], nums2[j]])\n            if j + 1 < len(nums2):\n                heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n        return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 從輸入字串中抽取 nums1、nums2、k\n    nums1_match = re.search(r'nums1\\s*=\\s*(\\[.*?\\])', data)\n    nums2_match = re.search(r'nums2\\s*=\\s*(\\[.*?\\])', data)\n    k_match = re.search(r'k\\s*=\\s*(\\d+)', data)\n    if not (nums1_match and nums2_match and k_match):\n        return\n    nums1 = ast.literal_eval(nums1_match.group(1))\n    nums2 = ast.literal_eval(nums2_match.group(1))\n    k = int(k_match.group(1))\n\n    sol = Solution()\n    result = sol.kSmallestPairs(nums1, nums2, k)\n\n    # 產生不含空白的輸出格式\n    out = '[[%s]]' % ','.join('[' + ','.join(map(str, pair)) + ']' for pair in result)\n    print(out)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, explaining algorithm for finding k pairs with smallest sums from two sorted arrays. Standard solution uses min-heap. We need to present step by step virtual code with explanation. Let's produce a list:\n\nStart\n→ Initialize min-heap\n→ For i from 0 to min(k, len(nums1)) - 1: push (nums1[i] + nums2[0], i, 0) into heap // initial pairs\n→ Initialize result list\n→ While heap not empty and result length < k: pop smallest pair (sum, i, j) // get smallest sum\n→ Append (nums1[i], nums2[j]) to result\n→ If j + 1 < len(nums2): push (nums1[i] + nums2[j+1], i, j+1) into heap // next element in nums2 for same i\n→ End // return result\n\nBut we must adhere to virtual code format. Each line with step comment.\n\nLet's craft accordingly:\n\nStart // 程式開始\n→ Initialize min-heap // 用於取得最小和的元組\n→ For i from 0 to min(k, length(nums1))-1: // 為每個 nums1 前 k 個元素建立初始對\n    → Push (nums1[i] + nums2[0], i, 0) into heap // 將和及索引存入堆\n→ Initialize result = [] // 存儲 k 個最小和的對\n→ While heap not empty and size(result) < k: // 取出最小和直到滿足 k\n    → Pop (sum, i, j) from heap // 取得目前最小和及其索引\n    → Append (nums1[i], nums2[j]) to result // 加入答案\n    → If j + 1 < length(nums2): // 同 i 的下一個 nums2 元素存在\n        → Push (nums1[i] + nums2[j+1], i, j+1) into heap // 推入新的和\n→ End // 程式結束\n\nWe need to format as per \"虛擬碼步驟 [空格] // 解釋/說明\". So each line: \"虛擬碼步驟 // 解釋\". We need to include arrow arrows. Let's produce lines accordingly. Use arrow \"→\" for normal steps, \"Decision:\" only if needed. No Decision needed.\n\nLet's output.\n\nCheck each line: start line \"Start // 程式開始\". Next line \"→ Initialize min-heap // 用於取得最小和的元組\". Next line \"→ For i from 0 to min(k, length(nums1))-1: // 為每個 nums1 前 k 個元素建立初始對\". Then indentation inside For: maybe separate line? We can include inside as separate line with indentation. But spec: Use virtual code's arrows and structure. We can use \"→ For ...\" and inside we use \"→\" again but with indentation? It's okay to have nested arrow lines.\n\nWe'll format as:\n\nStart // 程式開始\n→ Initialize min-heap // 用於取得最小和的元組\n→ For i from 0 to min(k, length(nums1))-1: // 為每個 nums1 前 k 個元素建立初始對\n    → Push (nums1[i] + nums2[0], i, 0) into heap // 將和及索引存入堆\n→ Initialize result = [] // 存儲 k 個最小和的對\n→ While heap not empty and size(result) < k: // 取出最小和直到滿足 k\n    → Pop (sum, i, j) from heap // 取得目前最小和及其索引\n    → Append (nums1[i], nums2[j]) to result // 加入答案\n    → If j + 1 < length(nums2): // 同 i 的下一個 nums2 元素存在\n        → Push (nums1[i] + nums2[j+1], i, j+1) into heap // 推入新的和\n→ End // 程式結束\n\nBut need to follow \"虛擬碼步驟 [空格] // 解釋/說明\" each line. Also maybe we need to use \"Decision:\" if condition? Not necessary. But we can use \"If\" inside but not Decision. It's fine.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始  \n→ Initialize min-heap // 用於取得最小和的元組  \n→ For i from 0 to min(k, length(nums1))-1: // 為每個 nums1 前 k 個元素建立初始對  \n  → Push (nums1[i] + nums2[0], i, 0) into heap // 將和及索引存入堆  \n→ Initialize result = [] // 存儲 k 個最小和的對  \n→ While heap not empty and size(result) < k: // 取出最小和直到滿足 k  \n  → Pop (sum, i, j) from heap // 取得目前最小和及其索引  \n  → Append (nums1[i], nums2[j]) to result // 加入答案  \n  → If j + 1 < length(nums2): // 同 i 的下一個 nums2 元素存在  \n    → Push (nums1[i] + nums2[j+1], i, j+1) into heap // 推入新的和  \n→ End // 程式結束"
    },
    {
      "title": "Merge Sorted Array",
      "source_file": "Leetcode/leetcode88.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3",
          "expected_output": "[1,2,2,3,5,6]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpf5h19bbg.py\", line 41, in <module>\n    data = parse_input(input_data)\n           ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpf5h19bbg.py\", line 34, in parse_input\n    data[key] = ast.literal_eval(val)   # 只允許安全的字面量解析\n                ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        原地把 nums2 合併到 nums1，最終結果存回 nums1。\n        使用三個指標從尾部往前合併，避免覆蓋未處理的元素。\n        \"\"\"\n        i, j, k = m - 1, n - 1, m + n - 1  # i: nums1 最後有效元素, j: nums2 最後元素, k: nums1 最後位置\n        while i >= 0 and j >= 0:          # 同時有兩邊的元素未處理\n            if nums1[i] > nums2[j]:\n                nums1[k] = nums1[i]\n                i -= 1\n            else:\n                nums1[k] = nums2[j]\n                j -= 1\n            k -= 1\n        while j >= 0:                     # 若 nums2 還有剩餘元素，直接拷貝\n            nums1[k] = nums2[j]\n            j -= 1\n            k -= 1\n\ndef parse_input(s: str) -> dict:\n    \"\"\"\n    將形如 'nums1 = [1,2], m = 1, nums2 = [3], n = 1' 的字串轉成字典。\n    \"\"\"\n    pattern = r'(\\w+)\\s*=\\s*([^,]+)'\n    matches = re.findall(pattern, s)\n    data = {}\n    for key, val in matches:\n        val = val.strip()\n        data[key] = ast.literal_eval(val)   # 只允許安全的字面量解析\n    return data\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read().strip()\n    if not input_data:\n        sys.exit(0)\n    data = parse_input(input_data)\n    sol = Solution()\n    sol.merge(data[\"nums1\"], data[\"m\"], data[\"nums2\"], data[\"n\"])\n    print(data[\"nums1\"])",
      "virtual_code": "Thinking...\nWe need to produce step-by-step pseudocode with explanations. Must adhere to format: each line \"虛擬碼步驟 // 解釋/說明\". Use arrows and decision structure. No actual code. Use Chinese. Use Start, End, Decision, Yes →, No →. The input arrays are sorted. We need to merge in-place into nums1. Approach: Use pointers i=m-1, j=n-1, k=m+n-1. While i>=0 and j>=0: compare nums1[i] and nums2[j] and set nums1[k] = bigger; decrement pointers. Then if j>=0 copy remaining nums2. That's it.\n\nWe need to produce steps. Ensure each line ends with explanation. No extra content.\n\nLet's produce. Use \"Start // 程式開始執行\". Then maybe \"→ Step 1: 設定指標 i = m-1 // 指向 nums1 的最後有效元素\" etc.\n\nWe need to incorporate decision. Use \"Decision:\" for while loops? For while, can represent as \"Decision: i >= 0 且 j >= 0 ?\" with Yes and No branches. Inside Yes: choose greater element.\n\nThen after loop, Decision: j >= 0? Yes copy remaining nums2.\n\nFinally End.\n\nLet's craft. Use Chinese. Use minimal but clear explanation.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: i ← m - 1 // 指向 nums1 中最後一個有效元素  \n→ Step 2: j ← n - 1 // 指向 nums2 中最後一個元素  \n→ Step 3: k ← m + n - 1 // 指向 nums1 的最後一個位置（空位）  \n\n→ Decision: i ≥ 0 且 j ≥ 0? // 判斷兩個陣列是否仍有未合併元素  \n    Yes → Decision: nums1[i] > nums2[j]? // 比較當前兩個元素大小  \n        Yes → Step 4: nums1[k] ← nums1[i] // 取 nums1 的較大值放入最末  \n        No  → Step 5: nums1[k] ← nums2[j] // 取 nums2 的較大值放入最末  \n    → Step 6: k ← k - 1 // 移動寫入指標  \n    → Step 7: 若 nums1[i] > nums2[j] 則 i ← i - 1 否則 j ← j - 1 // 移動讀取指標  \n    → Repeat Decision: i ≥ 0 且 j ≥ 0?  \n\n→ Decision: j ≥ 0? // 若 nums2 還有剩餘元素  \n    Yes → Step 8: nums1[k] ← nums2[j] // 複製 nums2 的剩餘元素  \n    → Step 9: k ← k - 1  \n    → Step 10: j ← j - 1  \n    → Repeat Decision: j ≥ 0?  \n\nEnd // 程式執行結束，nums1 已完成合併並排序完成"
    },
    {
      "title": "Min Stack",
      "source_file": "Leetcode/leetcode155.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"],[[],[-2],[0],[-3],[],[],[],[]]",
          "expected_output": "[null,null,null,null,-3,null,0,-2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpjp8dzebt.py\", line 41, in <module>\n    ops, args = json.loads(raw_input)\n                ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 64 (char 63)"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass MinStack:\n    \"\"\"\n    用兩個堆疊來實現常數時間內取得最小值的棧。\n    \"\"\"\n    def __init__(self):\n        # 主堆疊存放所有進入的元素\n        self.stack = []\n        # 最小堆疊只存放當前最小值，堆疊頂為最小\n        self.min_stack = []\n\n    def push(self, val: int) -> None:\n        self.stack.append(val)\n        # 如果最小堆疊為空，或新值比最小值小/相等，則同時推入最小堆疊\n        if not self.min_stack or val <= self.min_stack[-1]:\n            self.min_stack.append(val)\n\n    def pop(self) -> None:\n        if not self.stack:\n            return\n        val = self.stack.pop()\n        # 若彈出的值正好是目前最小值，則同時從最小堆疊彈出\n        if self.min_stack and val == self.min_stack[-1]:\n            self.min_stack.pop()\n\n    def top(self) -> int | None:\n        return self.stack[-1] if self.stack else None\n\n    def getMin(self) -> int | None:\n        return self.min_stack[-1] if self.min_stack else None\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    # 解析成兩個 JSON 陣列\n    ops, args = json.loads(raw_input)\n\n    stack = MinStack()\n    results = []\n\n    for op, arg in zip(ops, args):\n        if op == \"push\":\n            stack.push(arg[0])\n            results.append(None)          # push 的結果為 null\n        elif op == \"pop\":\n            stack.pop()\n            results.append(None)          # pop 的結果為 null\n        elif op == \"top\":\n            results.append(stack.top())\n        elif op == \"getMin\":\n            results.append(stack.getMin())\n        else:\n            # 若有未知操作，直接存 None\n            results.append(None)\n\n    # 輸出結果，使用 json.dumps 以得到 null 而非 None\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with comments. Need to design MinStack class. Steps: initialization, push, pop, top, getMin. Use two stacks: main stack, min stack. Each push: push val to stack; if minStack empty or val <= top of minStack, push val onto minStack. Pop: pop from main; if popped == top of minStack, pop minStack. Top: return top of main. getMin: return top of minStack. Also include start/end. Provide virtual code with arrows. Ensure each line ends with // explanation.\n\nLet's produce.\n\nWe'll start:\n\nStart // 程式開始執行\n→ Step 1: 定義 MinStack 類別 // 建立 MinStack 類別\n\nWithin class, we need member variables: mainStack, minStack.\n\nAdd initialization:\n\n→ Step 2: MinStack() 初始化空的 mainStack 與 minStack // 建立兩個空堆疊\n\nPush function:\n\n→ Step 3: push(val) // 定義 push 方法\n    → Step 3.1: mainStack.Push(val) // 把 val 推進主堆疊\n    → Decision: 如果 minStack 為空 或 val <= minStack.Top()?\n        Yes → minStack.Push(val) // 若為最小值，推進 minStack\n        No  → // 不做任何動作\n→ End of push\n\nPop function:\n\n→ Step 4: pop() // 定義 pop 方法\n    → Decision: 是否為空？ // 防止空堆疊\n        No → \n            → Step 4.1: popped = mainStack.Pop() // 從主堆疊彈出元素\n            → Decision: popped == minStack.Top()?\n                Yes → minStack.Pop() // 同時彈出 minStack 中的最小值\n                No  → // 不做任何動作\n        Yes → // 空堆疊，無操作\n→ End of pop\n\nTop function:\n\n→ Step 5: top() // 定義 top 方法\n    → Decision: 是否為空？\n        No → return mainStack.Top() // 回傳主堆疊頂端\n        Yes → return null/undefined // 或拋出錯誤\n\ngetMin function:\n\n→ Step 6: getMin() // 定義 getMin 方法\n    → Decision: 是否為空？\n        No → return minStack.Top() // 回傳最小值\n        Yes → return null/undefined\n\nEnd // 程式結束\n\nWe need to keep lines as per format: each line with \"虛擬碼步驟\" and comment. Indent maybe using arrow.\n\nWe should include decision branches. Use 'Decision:' lines and Yes/No lines.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 MinStack 類別 // 建立 MinStack 類別  \n→ Step 2: MinStack() 初始化 mainStack 與 minStack // 建立兩個空堆疊  \n→ Step 3: push(val) // 定義 push 方法  \n    → Step 3.1: mainStack.Push(val) // 把 val 推進主堆疊  \n    → Decision: 若 minStack 為空 或 val <= minStack.Top()? // 判斷是否更新最小堆疊  \n        Yes → minStack.Push(val) // 將 val 推進 minStack 作為新最小值  \n        No  → // 不更新 minStack  \n→ Step 4: pop() // 定義 pop 方法  \n    → Decision: mainStack 是否為空? // 避免空堆疊彈出  \n        No →  \n            → Step 4.1: popped = mainStack.Pop() // 從主堆疊彈出頂端元素  \n            → Decision: popped == minStack.Top()? // 判斷是否為最小值  \n                Yes → minStack.Pop() // 同時從 minStack 彈出最小值  \n                No  → // 不做任何動作  \n        Yes → // 堆疊為空，無操作  \n→ Step 5: top() // 定義 top 方法  \n    → Decision: mainStack 是否為空?  \n        No → return mainStack.Top() // 回傳主堆疊頂端  \n        Yes → return null // 或拋出錯誤  \n→ Step 6: getMin() // 定義 getMin 方法  \n    → Decision: minStack 是否為空?  \n        No → return minStack.Top() // 回傳目前最小值  \n        Yes → return null // 或拋出錯誤  \nEnd // 程式執行結束"
    },
    {
      "title": "Unique Substrings in Wraparound String",
      "source_file": "Leetcode/leetcode467.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"a\"",
          "expected_output": "1",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '1'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: '1'\nRaw Got:      '2'"
        },
        {
          "example_index": 1,
          "input": "s = \"cac\"",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '3'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '3'"
        },
        {
          "example_index": 2,
          "input": "s = \"zab\"",
          "expected_output": "6",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '6'\nGot (Norm):      '7'\n--- (Raw) ---\nRaw Expected: '6'\nRaw Got:      '7'"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef count_wrap_substrings(s: str) -> int:\n    \"\"\"\n    Return the number of unique non‑empty substrings of `s`\n    that appear in the infinite wraparound string of the alphabet.\n    \"\"\"\n    if not s:\n        return 0\n\n    # dp[i] stores the maximum length of a valid substring that ends with\n    # the i-th letter of the alphabet (0 -> 'a', 1 -> 'b', ...).\n    dp = [0] * 26\n    cur_len = 0  # current length of a consecutive substring\n\n    for i, ch in enumerate(s):\n        if i > 0 and (ord(ch) - ord(s[i - 1])) % 26 == 1:\n            cur_len += 1\n        else:\n            cur_len = 1\n        idx = ord(ch) - ord('a')\n        if cur_len > dp[idx]:\n            dp[idx] = cur_len\n\n    return sum(dp)\n\n\nif __name__ == \"__main__\":\n    # Read entire input, strip whitespace and extract alphabetic characters.\n    raw_input = sys.stdin.read().strip()\n    # Keep only letters, convert to lowercase.\n    cleaned = re.sub(r'[^a-zA-Z]', '', raw_input).lower()\n\n    result = count_wrap_substrings(cleaned)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step. The problem: count unique non-empty substrings of s that appear in infinite wraparound string base, i.e., all substrings that follow consecutive letters in alphabet with wrap from z to a.\n\nThis is Leetcode problem 467. Approach: For each letter, keep maximum length of substring ending with that letter in s that is valid (consecutive). Then sum of all lengths gives number of unique substrings. Implementation: iterate s, maintain curLen, use array maxLen[26] initial zeros. For i from 0 to n-1: if i>0 and s[i] consecutive after s[i-1] (wrap considered), curLen++, else curLen=1. Update maxLen[s[i]-'a'] = max(maxLen[...], curLen). Finally sum.\n\nWe need virtual code lines accordingly. We need \"Start\" etc.\n\nLet's produce lines:\n\nStart // 開始\n→ Step 1: Initialize array maxLen[26] with zeros // 记录每个字母结尾子串的最大长度\n→ Step 2: Initialize curLen = 0 // 当前连续子串长度\n→ Step 3: For each character ch in input string s with index i // 遍历字符串\n    → Decision: If i > 0 and ch is consecutive after s[i-1] in alphabet (wrap) // 判断是否连续\n        Yes → curLen = curLen + 1 // 继续延长子串\n        No  → curLen = 1 // 重置子串长度\n    → Update maxLen[ch - 'a'] = max(maxLen[ch - 'a'], curLen) // 更新该字母结尾子串的最大长度\n→ Step 4: Compute result = sum of all values in maxLen // 计算唯一子串总数\n→ End // 返回结果\n\nBut need virtual code lines each line: we can produce:\n\nStart // 程式開始執行\n→ Step 1: Declare integer array maxLen[26] initialized to 0 // 建立 26 個元素的陣列，用於存放以每個字母結尾的最大連續子串長度\n→ Step 2: Set integer curLen = 0 // 目前已檢測到的連續子串長度\n→ Step 3: For each index i from 0 to length of s - 1 // 逐字元掃描輸入字串\n    → Decision: If i > 0 AND (s[i] is consecutive after s[i-1] in alphabet considering wrap) // 檢查字母是否連續\n        Yes → curLen = curLen + 1 // 連續子串長度加一\n        No  → curLen = 1 // 非連續，重新開始子串長度為 1\n    → Update maxLen[ s[i] - 'a' ] = max( maxLen[ s[i] - 'a' ], curLen ) // 更新對應字母的最大長度\n→ Step 4: Set integer result = 0 // 儲存最終答案\n→ Step 5: For each value v in maxLen // 遍歷陣列\n    → result = result + v // 累加所有最大長度得到唯一子串數\n→ End // 輸出結果\n\nWe should also note return result. But End is fine.\n\nWe need \"→\" for each step line. Also the Decision block indentation should show Yes → and No → lines.\n\nThus produce final output accordingly. Ensure no code. Use virtual code arrows.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Declare integer array maxLen[26] initialized to 0 // 建立 26 個元素的陣列，用於存放以每個字母結尾的最大連續子串長度  \n→ Step 2: Set integer curLen = 0 // 目前已檢測到的連續子串長度  \n→ Step 3: For each index i from 0 to length of s - 1 // 逐字元掃描輸入字串  \n  Decision: If i > 0 AND (s[i] is consecutive after s[i-1] in alphabet considering wrap) // 檢查字母是否連續  \n   Yes → curLen = curLen + 1 // 連續子串長度加一  \n   No  → curLen = 1 // 非連續，重新開始子串長度為 1  \n  Update maxLen[ s[i] - 'a' ] = max( maxLen[ s[i] - 'a' ], curLen ) // 更新對應字母的最大長度  \n→ Step 4: Set integer result = 0 // 儲存最終答案  \n→ Step 5: For each value v in maxLen // 遍歷陣列  \n  result = result + v // 累加所有最大長度得到唯一子串數  \n→ End // 輸出結果並結束程式"
    },
    {
      "title": "Random Pick Index",
      "source_file": "Leetcode/leetcode398.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\"], [[[1, 2, 3, 3, 3]], [3], [1], [3]]",
          "expected_output": "[null, 4, 0, 2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,4,0,2]'\nGot (Norm):      '[null,2,0,2]'\n--- (Raw) ---\nRaw Expected: '[null, 4, 0, 2]'\nRaw Got:      '[null, 2, 0, 2]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nfrom collections import defaultdict\n\nclass Solution:\n    def __init__(self, nums):\n        # 建立每個數字對應的索引清單\n        self.num_indices = defaultdict(list)\n        for i, num in enumerate(nums):\n            self.num_indices[num].append(i)\n\n    def pick(self, target):\n        # 隨機選取對應索引中的一個\n        return random.choice(self.num_indices[target])\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 將輸入拆分為方法列表和參數列表\n    split_index = data.find('],')\n    commands_str = data[:split_index + 1]   # 包含結尾的 ]\n    args_str = data[split_index + 2:]      # 從逗號後開始\n\n    commands = json.loads(commands_str)\n    args_list = json.loads(args_str)\n\n    results = []\n    obj = None\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"Solution\":\n            # 直接將參數解包給建構子\n            obj = Solution(*args)\n            results.append(None)\n        else:\n            # 呼叫對應的方法並收集結果\n            method = getattr(obj, cmd)\n            results.append(method(*args))\n\n    # 以 JSON 格式輸出結果，None 會轉成 null\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps. Not actual code. Use Start, End, Decision, arrows. We must produce each line with explanation. Provide steps: class init, store array, pick method. Use reservoir sampling? Since need random uniform among indices. Approach: store mapping of value to list of indices during init. Or use random selection by scanning and using reservoir sampling. We can choose simplest: maintain map from target to list indices, then random choice.\n\nThus steps:\n\nStart\n→ Step 1: Initialize Solution with nums // store nums and build map\n→ Step 2: For each index i in nums, add i to map[nums[i]] // build mapping\n→ Step 3: End of constructor\n\nPick method:\n→ Start pick(target)\n→ Decision: if target exists in map? // guaranteed\n→ Step: list = map[target]\n→ Step: randomIndex = Random integer between 0 and list.size-1\n→ Step: return list[randomIndex]\n→ End pick\n\nAlso include explanation for each line. Ensure each line has virtual code and comment.\n\nLet's produce in lines.\n\nWe should include lines for class definition? Maybe: Step: Define class Solution // define class\n\nBut output format: Each line \"虛擬碼步驟\" + space + \"// 解釋\".\n\nWe need arrows, start, end.\n\nWe should include method definitions: \"Constructor: Solution(nums)\" etc.\n\nLet's produce:\n\nStart\n→ Step: Define class Solution // 定義 Solution 類\n→ Step: Constructor: Solution(nums) // 建構函式，接收陣列\n→ Step: Create map: valueToIndices // 建立值到索引清單的映射\n→ Decision: For i from 0 to nums.length-1? // 迴圈遍歷陣列\n    Yes → Step: value = nums[i] // 取得元素值\n    Yes → Step: Append i to valueToIndices[value] // 將索引加入對應清單\n→ End // 完成建構\n→ Step: Method: pick(target) // 定義 pick 方法\n→ Decision: target exists in valueToIndices? // 確認目標存在\n    Yes → Step: indices = valueToIndices[target] // 取得索引清單\n    Yes → Step: k = Random integer [0, indices.length-1] // 隨機選取\n    Yes → Step: return indices[k] // 回傳隨機索引\n    No → Step: return -1 // 理論上不會發生\nEnd // 程式結束\n\nBut we need arrow formatting: Use \"→\" before each step. Indentation for decisions. Ensure each line ends with // explanation.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: 定義類別 Solution // 宣告 Solution 類  \n→ Step: 建構函式 Solution(nums) // 接收整數陣列作為初始化輸入  \n→ Step: 建立映射 valueToIndices: 空字典 // 用於儲存每個值對應的所有索引  \n→ Decision: 迭代 i 從 0 到 nums.length-1? // 遍歷陣列建立映射  \n  Yes → Step: value ← nums[i] // 取得目前索引的值  \n  Yes → Step: 將 i 加入 valueToIndices[value] // 將索引附加至對應值的清單  \n→ End // 完成建構階段  \n→ Step: 定義方法 pick(target) // 建立 pick 方法以隨機回傳目標索引  \n→ Decision: target 是否存在於 valueToIndices? // 確認目標值存在（題目已保證）  \n  Yes → Step: indices ← valueToIndices[target] // 取得所有匹配索引的清單  \n  Yes → Step: k ← 隨機整數 0 到 indices.length-1 // 隨機選取清單中一個位置  \n  Yes → Step: return indices[k] // 回傳隨機選取的索引  \n  No  → Step: return -1 // 理論上不會發生，作為安全備援  \nEnd // 程式執行結束"
    },
    {
      "title": "Word Break",
      "source_file": "Leetcode/leetcode139.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"leetcode\", wordDict = [\"leet\",\"code\"]",
          "expected_output": "true",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'true'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: 'true'\nRaw Got:      ''"
        },
        {
          "example_index": 1,
          "input": "s = \"applepenapple\", wordDict = [\"apple\",\"pen\"]",
          "expected_output": "true",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'true'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: 'true'\nRaw Got:      ''"
        },
        {
          "example_index": 2,
          "input": "s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]",
          "expected_output": "false",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'false'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: 'false'\nRaw Got:      ''"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def wordBreak(self, s, wordDict):\n        word_set = set(wordDict)\n        dp = [False] * (len(s) + 1)\n        dp[0] = True\n\n        for i in range(1, len(s) + 1):\n            for j in range(i):\n                if dp[j] and s[j:i] in word_set:\n                    dp[i] = True\n                    break\n        return dp[len(s)]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 將輸入格式轉成字典並使用 ast.literal_eval 解析\n    try:\n        parsed = ast.literal_eval('{' + data + '}')\n    except Exception:\n        # 若解析失敗則直接結束\n        return\n    s = parsed.get('s', '')\n    wordDict = parsed.get('wordDict', [])\n    result = Solution().wordBreak(s, wordDict)\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for word break problem. Use dynamic programming, typical DP array. Provide steps line by line, each with explanation. Use virtual code with arrows, decisions. Must not output actual code. Provide step by step. Ok. We'll produce:\n\nStart\n→ Step 1: Initialize dp array of length |s|+1 with false // dp[0] true\n→ Step 2: dp[0] = true // base case\n→ Step 3: For i from 1 to len(s) // iterate end positions\n→ Step 4: For each word in wordDict // iterate dictionary words\n→ Decision: 如果 word 長度 <= i 且 dp[i - len(word)] 並且 s substring matches word? // check feasibility\n    Yes → dp[i] = true // mark reachable\n→ Step 5: If dp[i] true break inner loop // no need to check more words\n→ End loops\n→ Step 6: Return dp[len(s)] // if reachable\n\nNeed to include virtual arrows and indentations. Use Decision with Yes/No branches. Should we have decision for matching? We can show Yes -> set dp[i] true. We might also have No -> continue.\n\nMake sure each line ends with // explanation.\n\nAlso include End. Provide each step as separate line.\n\nAlso mention Start and End.\n\nLet's produce accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 dp 陣列長度為 |s|+1 並全部設為 false // 用來記錄每個位置是否能被分割  \n→ Step 2: dp[0] = true // 空字串可被分割，作為基礎情形  \n→ Step 3: 對 i 從 1 到 |s| 逐一迭代 // i 表示 s 的前 i 個字符的終點  \n→ Step 4: 對字典中每一個單詞 word 進行迭代 // 嘗試用 word 作為最後一個片段  \n→ Decision: 如果 word 長度 ≤ i 且 dp[i - len(word)] 為 true 且 s 的子字串 s[i-len(word):i] 等於 word? // 判斷能否以此 word 結束分割  \n    Yes → dp[i] = true // 成功分割，標記此位置可達  \n    No  → // 仍嘗試字典中下一個單詞  \n→ Step 5: 如果 dp[i] 為 true，跳出內層迴圈 // 已確定此位置可達，無需再檢查其他單詞  \n→ End // 內層迴圈結束  \n→ End // 外層迴圈結束  \n→ Step 6: 回傳 dp[|s|] // 若最後位置可達，表示整個字串可被分割成字典單詞序列  \nEnd // 程式執行結束"
    },
    {
      "title": "Sort Characters By Frequency",
      "source_file": "Leetcode/leetcode451.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"tree\"",
          "expected_output": "\"eert\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'eert'\nGot (Norm):      'eetr'\n--- (Raw) ---\nRaw Expected: '\"eert\"'\nRaw Got:      'eetr'"
        },
        {
          "example_index": 1,
          "input": "s = \"cccaaa\"",
          "expected_output": "\"aaaccc\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'aaaccc'\nGot (Norm):      'cccaaa'\n--- (Raw) ---\nRaw Expected: '\"aaaccc\"'\nRaw Got:      'cccaaa'"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import Counter\n\ndef frequency_sort(s: str) -> str:\n    \"\"\"Return string sorted by decreasing character frequency.\"\"\"\n    freq = Counter(s)\n    # most_common returns list of (char, count) sorted by count descending\n    return ''.join(char * count for char, count in freq.most_common())\n\ndef parse_input() -> str:\n    \"\"\"Parse the input from stdin which may be of form 's = \"tree\"'\n    or simply the string itself.\"\"\"\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return ''\n    # If the input contains an '=' sign, extract the right-hand side\n    if '=' in raw:\n        _, expr = raw.split('=', 1)\n        expr = expr.strip()\n        # Use literal_eval to safely evaluate the string literal\n        try:\n            return ast.literal_eval(expr)\n        except Exception:\n            # Fallback: strip surrounding quotes if literal_eval fails\n            return expr.strip('\"\\'')\n    # Otherwise, treat the entire input as the string\n    return raw.strip('\"\\'')\n\nif __name__ == \"__main__\":\n    s = parse_input()\n    result = frequency_sort(s)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps, each line: \"Step description // explanation\". We need to use Start, End, Decision, arrow syntax. It's not actual code. Should produce step by step.\n\nLet's design algorithm: count frequencies, sort chars by freq descending, build output string.\n\nSteps:\n\nStart\n→ Step 1: Initialize empty frequency map // create map to hold char counts\n→ Step 2: For each character c in string s: increment count in map // count frequencies\n→ Step 3: Create list of (char, freq) pairs from map // for sorting\n→ Decision: If list empty? // handle empty string\n    Yes → Step 4: Return empty string // nothing to sort\n    No  →\n→ Step 4: Sort list by freq descending // sort by frequency\n→ Step 5: Initialize empty result string // build output\n→ Step 6: For each pair (c, freq) in sorted list: append c freq times to result // build sorted string\n→ Step 7: Return result string // output result\nEnd\n\nWe should format with Start, End, Decision, Yes →, No →.\n\nEnsure each line has explanation. Use Chinese.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空的頻率映射表 freqMap // 用於儲存每個字元出現的次數  \n→ Step 2: 對字串 s 的每個字元 c 做迴圈：若 c 在 freqMap 中則 freqMap[c] += 1 否則 freqMap[c] = 1 // 計算每個字元的頻率  \n→ Step 3: 將 freqMap 轉成字元與頻率的對列表 freqList // 方便後續排序  \n→ Decision: 若 freqList 為空？ // 檢查是否為空字串  \n  Yes → Step 4: 回傳空字串 // 空輸入直接返回  \n  No  →  \n→ Step 4: 以頻率降序對 freqList 做排序 // 最高頻率的字元排在前面  \n→ Step 5: 建立空的結果字串 result // 用於拼接最終字串  \n→ Step 6: 對 freqList 中的每個 (c, f) 做迴圈：將字元 c 重複 f 次後連接到 result // 依頻率重複字元  \n→ Step 7: 回傳 result // 返回排序後的字串  \nEnd // 程式執行結束"
    },
    {
      "title": "Lexicographical Numbers",
      "source_file": "Leetcode/leetcode386.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 13",
          "expected_output": "[1,10,11,12,13,2,3,4,5,6,7,8,9]",
          "actual_output_or_error": "[Validation Error] Code execution timed out (10s)."
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef lexical_order(n: int):\n    \"\"\"\n    Return all numbers from 1 to n sorted in lexicographical order.\n    The algorithm runs in O(n) time and uses only O(1) extra space\n    (apart from the output list).\n    \"\"\"\n    res = []          # 结果列表，存储最终的排序结果\n    cur = 1           # 当前要输出的数字\n\n    while cur <= n:\n        res.append(cur)          # 输出当前数字\n\n        # 1. 如果可以进入下一层子节点（乘 10 之后仍 <= n）\n        if cur * 10 <= n:\n            cur *= 10\n            continue\n\n        # 2. 若不能乘 10，则尝试右移到同层的下一个数字\n        if cur % 10 != 9 and cur + 1 <= n:\n            cur += 1\n            continue\n\n        # 3. 不能右移，需要回溯到上一层并寻找下一个兄弟\n        while cur // 10 % 10 == 9 or cur + 1 > n:\n            cur //= 10           # 回到父节点\n            if cur == 0:         # 已经回到根节点外，全部完成\n                cur = -1\n                break\n\n        if cur == -1:           # 跳出外层循环\n            break\n\n        cur += 1                # 右移到下一个兄弟节点\n\n    return res\n\ndef main() -> None:\n    \"\"\"\n    主入口函数：读取标准输入，解析 n，输出结果列表。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    m = re.search(r'\\d+', data)   # 取出文本中的整数\n    if not m:\n        return\n    n = int(m.group(0))\n    result = lexical_order(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code step-by-step for algorithm that returns numbers 1..n sorted lexicographically, O(n) time, O(1) extra space. The classic algorithm is DFS (lexicographical DFS) traversal: start from 1 to 9, for each current number cur, while cur <= n: output cur; if cur*10 <= n: cur*=10; else: if cur%10 != 9 and cur+1 <= n: cur+=1; else: while cur/10 %10 == 9 or cur+1 > n: cur/=10; cur+=1. But we must produce a virtual code line by line with arrows. We don't need to output actual code, just steps. So produce something like:\n\nStart\n→ Initialize cur = 1\n→ While cur <= n\n    → Output cur\n    → If cur * 10 <= n\n        Yes → cur = cur * 10\n        No  → Decision: If cur % 10 != 9 and cur + 1 <= n?\n            Yes → cur = cur + 1\n            No  → While (cur / 10) % 10 == 9 or cur + 1 > n:\n                     cur = cur / 10\n                 cur = cur + 1\nEnd\n\nBut we need to maintain O(1) space and O(n) time. The algorithm loops O(n) times, each iteration constant ops.\n\nWe need to produce \"虛擬碼\" steps, each line with a description after //.\n\nWe need to use arrow symbols like →, Yes →, No → etc.\n\nWe need to be careful with indentation to show decision branches.\n\nAlso need to maintain \"Start\" and \"End\".\n\nOk produce final answer.\n\nMake sure to use traditional Chinese characters in comments.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Set cur = 1 // 初始化目前要輸出的數字\n→ Decision: 若 cur <= n? // 判斷是否還有數字要輸出\n    Yes →\n        Step 1: 輸出 cur // 輸出目前數字\n        Decision: 若 cur * 10 <= n? // 檢查能否往下個十倍\n            Yes → cur = cur * 10 // 進入下一層子節點\n            No →\n                Decision: 若 cur % 10 != 9 且 cur + 1 <= n? // 檢查是否可以右移\n                    Yes → cur = cur + 1 // 右移到下一個鄰居\n                    No  →\n                        While (cur / 10) % 10 == 9 或 cur + 1 > n:\n                            cur = cur / 10 // 回到上一層\n                        cur = cur + 1 // 從回到的節點右移\n        → Back to Decision: 若 cur <= n? // 檢查是否還有數字\n            Yes → repeat\n            No  → End // 結束輸出\n    No → End // 若初始 cur > n，直接結束\n\nBut we need each line with '虛擬碼步驟' + ' // 解釋/說明'.\n\nMake sure each line is one virtual code statement; multi-line loops must be represented accordingly.\n\nWe may produce nested decisions using indentation.\n\nLet's craft final output accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ cur = 1 // 初始化目前要輸出的數字\n→ Decision: 若 cur <= n? // 判斷是否還有數字要輸出\n    Yes →\n        → Output cur // 輸出目前數字\n        → Decision: 若 cur * 10 <= n? // 檢查能否進入下一層子節點\n            Yes → cur = cur * 10 // 進一步進到十倍層級\n            No →\n                → Decision: 若 cur % 10 != 9 且 cur + 1 <= n? // 檢查能否右移到下一個鄰居\n                    Yes → cur = cur + 1 // 右移到同層下一個數字\n                    No  →\n                        → While (cur / 10) % 10 == 9 或 cur + 1 > n: // 回到上一層直到可右移\n                            cur = cur / 10 // 從子節點回到父節點\n                        → cur = cur + 1 // 右移到可輸出的下一個數字\n        → Decision: 若 cur <= n? // 判斷是否還有數字要輸出\n            Yes → (循環回到上一步)\n            No  → End // 所有數字已輸出，結束\n    No  → End // 初始 cur 已大於 n，直接結束程式执行"
    },
    {
      "title": "Repeated DNA Sequences",
      "source_file": "Leetcode/leetcode187.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = 'AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT'",
          "expected_output": "[\"AAAAACCCCC\",\"CCCCCAAAAA\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"AAAAACCCCC\",\"CCCCCAAAAA\"]'\nGot (Norm):      '[\"CCCCCAAAAA\",\"AAAAACCCCC\"]'\n--- (Raw) ---\nRaw Expected: '[\"AAAAACCCCC\",\"CCCCCAAAAA\"]'\nRaw Got:      '[\"CCCCCAAAAA\", \"AAAAACCCCC\"]'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport json\n\ndef findRepeatedDnaSequences(s: str) -> list[str]:\n    \"\"\"\n    找出所有長度為 10 的子字串，在 s 中出現次數超過 1 次的子字串。\n    \"\"\"\n    seen = set()\n    repeated = set()\n    for i in range(len(s) - 9):\n        seq = s[i:i + 10]\n        if seq in seen:\n            repeated.add(seq)\n        else:\n            seen.add(seq)\n    return list(repeated)\n\ndef main() -> None:\n    \"\"\"\n    主函式：從標準輸入讀取 DNA 序列，計算重複的 10 字符子字串，\n    並將結果以 JSON 陣列形式輸出到標準輸出。\n    \"\"\"\n    data = sys.stdin.read()\n    # 從輸入中提取單引號內的 DNA 字串\n    match = re.search(r\"'([^']*)'\", data)\n    dna_sequence = match.group(1) if match else \"\"\n\n    result = findRepeatedDnaSequences(dna_sequence)\n    # 以 JSON 格式輸出，方便驗證\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line for solving problem: find all 10-letter-long substrings that appear more than once in DNA string s. Typical solution uses sliding window and hash map to count substrings length 10. Return list of those with count>1. Edge cases: length<10 -> return empty.\n\nWe output in Chinese (Traditional). Each line: virtual code step + space + comment. Use arrows and structure.\n\nLet's outline steps:\n\nStart\n→ Step 1: Initialize result list // create list to store repeating sequences\n→ Step 2: If length of s < 10, return result // no substrings\n→ Step 3: Initialize dictionary counts // map substring to count\n→ Step 4: For i from 0 to len(s)-10:\n   → Step 5: Extract sub = s[i:i+10] // 10-letter window\n   → Step 6: Increment counts[sub]\n   → Step 7: If counts[sub] == 2, append sub to result // add only first time duplicate found\n→ End // return result\n\nAlso might include early exit.\n\nWe need to adhere to format: Each line with \"虛擬碼步驟\" and comment. Use arrows appropriately: maybe \"→\" at start of line after Start? In example they used \"→ Step 1: ...\" etc. Should keep same style. The Start line no arrow.\n\nAlso use Decision if needed: Not required. But could include Decision for len<10.\n\nLet's produce accordingly. Use Chinese comments. Ensure every line ends with comment. Use brackets.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: 初始化 result 為空列表 // 用於儲存重複出現的 10 字符子字串\n→ Step 2: 如果 s 的長度小於 10，返回 result // 不足 10 個字符無法產生子字串\n→ Step 3: 初始化 counts 為空字典 // 用於記錄每個子字串的出現次數\n→ Step 4: 從 i = 0 到 len(s)-10 做循環 // 滑動窗口遍歷所有 10 字符子字串\n   → Step 5: sub = s[i:i+10] // 取得當前 10 字符子字串\n   → Step 6: 如果 sub 在 counts 中，則 counts[sub] += 1；否則設為 1 // 更新計數\n   → Step 7: 如果 counts[sub] 等於 2，則將 sub 加入 result // 只在第二次出現時加入\n→ End // 程式執行結束，返回 result\n\nWe can use \"Decision:\" line for condition len<10, but optional. Provide as above.\n\nMake sure indentation is consistent with example: Indent sub-steps under Step 4 with spaces. They used tab? In example they used spaces. We'll use two spaces indentation after Step 4 line. For arrow, we keep \"→\" at start of each line. For nested lines, they used two spaces and indentation.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 result 為空列表 // 用於儲存重複出現的 10 字符子字串  \n→ Step 2: 如果 s 的長度小於 10，返回 result // 不足 10 個字符無法產生子字串  \n→ Step 3: 初始化 counts 為空字典 // 用於記錄每個子字串的出現次數  \n→ Step 4: 從 i = 0 到 len(s)-10 做循環 // 滑動窗口遍歷所有 10 字符子字串  \n  → Step 5: sub = s[i:i+10] // 取得當前 10 字符子字串  \n  → Step 6: 如果 sub 在 counts 中，則 counts[sub] += 1；否則設為 1 // 更新計數  \n  → Step 7: 如果 counts[sub] 等於 2，則將 sub 加入 result // 只在第二次出現時加入  \nEnd // 程式執行結束，返回 result"
    },
    {
      "title": "Permutations",
      "source_file": "Leetcode/leetcode46.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nGot (Norm):      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nRaw Got:      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\n\nclass Solution:\n    def permute(self, nums):\n        \"\"\"\n        Generate all permutations of the distinct integer list nums.\n        Uses a backtracking algorithm with in-place swapping.\n        \"\"\"\n        res = []\n\n        def backtrack(start):\n            # Decision: 如果已經到最後一個位置\n            if start == len(nums):\n                # 完整排列加入結果\n                res.append(nums[:])\n                return\n            # 逐一嘗試每個剩餘元素\n            for i in range(start, len(nums)):\n                # 交換\n                nums[start], nums[i] = nums[i], nums[start]\n                backtrack(start + 1)\n                # 回溯，恢復原狀\n                nums[start], nums[i] = nums[i], nums[start]\n\n        backtrack(0)\n        return res\n\ndef main():\n    # 讀取整個標準輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 處理可能的 \"nums = [1,2,3]\" 格式\n    if '=' in data:\n        _, expr = data.split('=', 1)\n        expr = expr.strip()\n    else:\n        expr = data\n    # 轉成列表\n    nums = ast.literal_eval(expr)\n    # 呼叫解法\n    sol = Solution()\n    result = sol.permute(nums)\n    # 輸出符合示例格式（無空格）\n    print(json.dumps(result, separators=(',', ':')))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce a virtual code solution: generate all permutations of an array of distinct integers, any order. We need to use virtual code steps line by line with explanations.\n\nWe need to follow format: start with \"Start // 程式開始執行\". Then arrow lines: \"→ Step X: ...\" and decision lines with \"Decision:\" and \"Yes →\" \"No →\". Provide explanation after \"//\".\n\nWe need to produce a recursive backtracking algorithm or iterative. We need to use \"Step\" naming maybe Step 1, Step 2 etc. Use decisions.\n\nLet's produce something like:\n\nStart\n→ Step 1: 定義輸入陣列 nums\n→ Step 2: 初始化結果 list = []\n→ Step 3: 定義遞迴函式 backtrack(current, remaining)\n→ Decision: 如果 remaining 為空? // 檢查是否已組完\n    Yes → Step 4: 將 current 加到結果中\n    No → Step 5: 對於每個 num 在 remaining:\n            → Step 6: 將 num 加到 current\n            → Step 7: 創建新剩餘 list 不包含 num\n            → Step 8: 呼叫 backtrack(current, new_remaining)\n            → Step 9: 從 current 刪除最後一個 num\n→ Step 10: 呼叫 backtrack([], nums)\n→ Step 11: 回傳結果\nEnd\n\nWe need to use \"→\" arrow to show steps, decisions, etc.\n\nBe careful with formatting: each line \"虛擬碼步驟 [space] // 解釋\". Use \"Start\" etc.\n\nAlso must include arrow for decision lines? Use \"Decision:\" preceding? Eg \"Decision: 如果 remaining 為空?\" then indent with Yes →, No →. But indentation can be shown as spaces or indent in code block. Example format:\n\nDecision: 如果 remaining 為空? // 檢查是否已組完\n    Yes → Step 4: 將 current 加到結果中 // ...\n    No  → Step 5: 對於每個 num 在 remaining: // ...\n\nWe need to maintain indent after decision.\n\nAlso need to start with \"Start // 程式開始執行\". End with \"End // 程式執行結束\".\n\nAlso need to include \"→ Step\" lines. Use numbering.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義輸入陣列 nums // 取得要排列的整數列表  \n→ Step 2: 初始化結果 list = [] // 用來儲存所有排列  \n→ Step 3: 定義遞迴函式 backtrack(current, remaining) // current 為目前已建立的排列，remaining 為尚未使用的元素  \nDecision: 如果 remaining 為空? // 檢查是否已組完一個排列  \n    Yes → Step 4: 將 current 加到結果 list 中 // 完整排列加入結果  \n    No  → Step 5: 對於每個 num 在 remaining: // 逐一嘗試每個剩餘元素  \n        → Step 6: 將 num 加到 current // 追加目前元素  \n        → Step 7: 建立 new_remaining = remaining 去除 num // 更新剩餘元素  \n        → Step 8: 呼叫 backtrack(current, new_remaining) // 進行下一層遞迴  \n        → Step 9: 從 current 刪除最後一個 num // 回溯，恢復原狀  \n→ Step 10: 呼叫 backtrack([], nums) // 從空排列開始遞迴  \n→ Step 11: 回傳結果 list // 返回所有可能的排列  \nEnd // 程式執行結束"
    },
    {
      "title": "Find the Duplicate Number",
      "source_file": "Leetcode/leetcode287.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "nums = [3,1,3,4,2]",
          "expected_output": "O3",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'O3'\nGot (Norm):      '3'\n--- (Raw) ---\nRaw Expected: 'O3'\nRaw Got:      '3'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def findDuplicate(self, nums):\n        # Floyd's Tortoise and Hare algorithm\n        slow = fast = nums[0]\n        # Find intersection point of two runners\n        while True:\n            slow = nums[slow]\n            fast = nums[nums[fast]]\n            if slow == fast:\n                break\n        # Find entrance to the cycle (duplicate number)\n        slow = nums[0]\n        while slow != fast:\n            slow = nums[slow]\n            fast = nums[fast]\n        return slow\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    # Extract all integers from the input\n    numbers = list(map(int, re.findall(r'-?\\d+', data)))\n    # If the input is empty or no numbers, exit\n    if not numbers:\n        sys.exit()\n    solution = Solution()\n    result = solution.findDuplicate(numbers)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm: Find duplicate number in array without modifying array and constant extra space. Standard solution: Floyd's Tortoise and Hare cycle detection (linked list style). Steps: Use two pointers starting at index 0 or first element. Move slow=nums[slow], fast=nums[nums[fast]] until they meet. Then find entrance: start from 0 and meeting point: move both one step until equal, that index is duplicate number. Provide step-by-step pseudocode with explanations. Format lines: each line \"虛擬碼步驟 // 解釋\".\n\nWe need to use arrows and structure like Start, End, Decision. Provide step-by-step. Ensure each line contains arrow or Start or End. Use \"→\" for sequential steps. Use Decision blocks for if statements. The algorithm has no loops? It uses loops.\n\nWe can represent loop with \"Loop\" or \"Repeat\". Use arrow to next step. Let's craft:\n\nStart\n→ Step 1: Initialize slow = nums[0] // 起始慢指針\n→ Step 2: Initialize fast = nums[0] // 起始快指針\n→ Loop: slow = nums[slow], fast = nums[nums[fast]] // 移動指針，直到相遇\n    Decision: slow == fast? // 檢查是否相遇\n        Yes → Step 3: 已相遇，進入下一階段\n        No  → Repeat Loop // 仍未相遇，繼續迴圈\n→ Step 4: 初始化 finder = nums[0] // 設定 finder 起始\n→ Step 5: Repeat: finder = nums[finder], slow = nums[slow] // 同步移動兩指針\n    Decision: finder == slow? // 檢查是否相等\n        Yes → Step 6: 重複數字為 finder // 找到重複數字\n        No  → Repeat Step 5 // 仍未相等，繼續移動\nEnd\n\nBut we must adhere to arrow syntax: \"→ Step\" etc. Use \"Decision:\" lines. Use indentation for sub-steps. Need to produce each line separate.\n\nLet's produce final. Ensure each line ends with \"// 解釋\".\n\nMake sure to not output actual code, only virtual steps.\n\nAlso ensure each line has no trailing spaces? But it's okay.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: 設定 slow = nums[0] // 初始化慢指針\n→ Step 2: 設定 fast = nums[0] // 初始化快指針\n→ Loop 1: slow = nums[slow] // 慢指針移動一步\n    fast = nums[nums[fast]] // 快指針移動兩步\n    Decision: slow == fast? // 判斷兩指針是否相遇\n        Yes → Step 3: 兩指針相遇，結束第一階段\n        No  → Repeat Loop 1 // 未相遇，繼續迴圈\n→ Step 4: 設定 finder = nums[0] // 設置 finder 指針\n→ Loop 2: finder = nums[finder] // finder 移動一步\n    slow = nums[slow] // slow 同步移動一步\n    Decision: finder == slow? // 判斷兩指針是否相等\n        Yes → Step 5: 重複數字為 finder\n        No  → Repeat Loop 2 // 未相等，繼續迴圈\nEnd // 程式執行結束\n\nBut we need \"Step 5\" as final output? We might need to output \"Step 5: 重複數字為 finder\" but we also may want to \"返回 finder\". But they said return the duplicate number. So Step 5 could be \"返回 finder\". Let's do \"Step 5: 返回 finder // 回傳重複數字\".\n\nAlso the loop constructs: maybe we need to indicate start and end. But we can just use arrow lines. But requirement: Use virtual code arrow \"→\" and structure \"Start\", \"End\", \"Decision:\".\n\nWe should maybe indent sub-steps.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 slow = nums[0] // 初始化慢指針  \n→ Step 2: 設定 fast = nums[0] // 初始化快指針  \n→ Loop 1:  \n  slow = nums[slow] // 慢指針每次移動一步  \n  fast = nums[nums[fast]] // 快指針每次移動兩步  \n  Decision: slow == fast? // 檢查兩指針是否相遇  \n   Yes → Step 3: 兩指針相遇，結束第一階段  \n   No  → Repeat Loop 1 // 未相遇，繼續迴圈  \n→ Step 4: 設定 finder = nums[0] // 設置 finder 指針，準備尋找入口  \n→ Loop 2:  \n  finder = nums[finder] // finder 每次移動一步  \n  slow = nums[slow] // slow 同步移動一步  \n  Decision: finder == slow? // 判斷是否到達相遇點  \n   Yes → Step 5: 返回 finder // finder 即為重複數字  \n   No  → Repeat Loop 2 // 未到達，繼續迴圈  \nEnd // 程式執行結束"
    },
    {
      "title": "Find Median from Data Stream",
      "source_file": "Leetcode/leetcode295.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"], [[], [1], [2], [], [3], []]",
          "expected_output": "[null, null, null, 1.5, null, 2.0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,1.5,null,2.0]'\nGot (Norm):      '[null,null,null,1.5,null,2]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, 1.5, null, 2.0]'\nRaw Got:      '[null, null, null, 1.5, null, 2]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport heapq\n\nclass MedianFinder:\n    def __init__(self):\n        self.small = []  # max-heap (store negatives)\n        self.large = []  # min-heap\n\n    def addNum(self, num):\n        heapq.heappush(self.small, -num)\n        if self.large and -self.small[0] > self.large[0]:\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        if len(self.small) > len(self.large) + 1:\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        elif len(self.large) > len(self.small):\n            val = heapq.heappop(self.large)\n            heapq.heappush(self.small, -val)\n\n    def findMedian(self):\n        if len(self.small) > len(self.large):\n            return -self.small[0]\n        return (-self.small[0] + self.large[0]) / 2.0\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Wrap the raw input into a JSON array\n    wrapped = '[' + data + ']'\n    try:\n        ops, args = json.loads(wrapped)\n    except Exception:\n        # If input is given on separate lines\n        parts = data.splitlines()\n        ops = json.loads(parts[0])\n        args = json.loads(parts[1])\n\n    outputs = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"MedianFinder\":\n            obj = MedianFinder()\n            outputs.append(None)\n        elif op == \"addNum\":\n            obj.addNum(arg[0])\n            outputs.append(None)\n        elif op == \"findMedian\":\n            outputs.append(obj.findMedian())\n    print(json.dumps(outputs))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code for a class MedianFinder with methods and logic. Need to produce step-by-step virtual code. We need to use structure: Start, End, Decision, arrows, etc.\n\nWe need to design algorithm: maintain two heaps: max-heap for lower half, min-heap for upper half. addNum: push into one heap then balance sizes. findMedian: if sizes equal, average of top of both; else top of larger heap.\n\nWe need to produce virtual steps: maybe like:\n\nStart\n→ Step 1: 初始化 maxHeap, minHeap\n→ Step 2: addNum(num) // push into appropriate heap\n    → Decision: num <= maxHeap.top? // decide\n        Yes → push num into maxHeap\n        No  → push num into minHeap\n    → Decision: maxHeap.size > minHeap.size + 1? // rebalance\n        Yes → move top of maxHeap to minHeap\n        No →\n            Decision: minHeap.size > maxHeap.size + 1?\n                Yes → move top of minHeap to maxHeap\n                No →\n    // now sizes balanced or diff <=1\n→ Step 3: findMedian()\n    → Decision: maxHeap.size == minHeap.size?\n        Yes → median = (maxHeap.top + minHeap.top) / 2.0\n        No  →\n            Decision: maxHeap.size > minHeap.size?\n                Yes → median = maxHeap.top\n                No  → median = minHeap.top\nEnd\n\nBut the requirement: \"逐行地產生對應的虛擬碼\" - we need to produce lines with arrow.\n\nWe should produce code for constructor, addNum, findMedian.\n\nWe must produce each line as \"虛擬碼步驟 // 解釋\". Use arrow \"→\".\n\nLet's produce something like:\n\nStart // 程式開始執行\n→ Step 1: Define class MedianFinder\n    → Step 2: Initialize two heaps: maxHeap (max-heap), minHeap (min-heap)\n    → Step 3: Define addNum(num)\n        → Decision: If maxHeap is empty OR num <= maxHeap.top?\n            Yes → Push num into maxHeap\n            No  → Push num into minHeap\n        → Decision: maxHeap.size > minHeap.size + 1?\n            Yes → Move maxHeap.top to minHeap\n            No →\n                Decision: minHeap.size > maxHeap.size + 1?\n                    Yes → Move minHeap.top to maxHeap\n                    No → // sizes balanced\n    → Step 4: Define findMedian()\n        → Decision: maxHeap.size == minHeap.size?\n            Yes → median = (maxHeap.top + minHeap.top) / 2.0\n            No →\n                Decision: maxHeap.size > minHeap.size?\n                    Yes → median = maxHeap.top\n                    No  → median = minHeap.top\n    → Step 5: Return median\nEnd // 程式執行結束\n\nBut each line must be separate with arrow. We can indent by spaces.\n\nBetter to keep each \"Step\" on its own line.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: Define class MedianFinder // 建立 MedianFinder 類別\n→ Step 2: Initialize two heaps: maxHeap (max-heap), minHeap (min-heap) // 用於分別存儲較小與較大的數值\n→ Step 3: Define method addNum(num) // 新增一個數字至資料結構\n    → Decision: If maxHeap is empty OR num <= maxHeap.top? // 判斷該數字屬於左半部\n        Yes → Push num into maxHeap // 加入左半部\n        No  → Push num into minHeap // 加入右半部\n    → Decision: If maxHeap.size > minHeap.size + 1? // 檢查左半部是否過大\n        Yes → Move top element from maxHeap to minHeap // 平衡兩堆\n        No →\n            Decision: If minHeap.size > maxHeap.size + 1? // 檢查右半部是否過大\n                Yes → Move top element from minHeap to maxHeap // 平衡兩堆\n                No → // 堆已平衡\n→ Step 4: Define method findMedian() // 查詢目前所有數字的中位數\n    → Decision: If maxHeap.size == minHeap.size? // 堆大小相等\n        Yes → median = (maxHeap.top + minHeap.top) / 2.0 // 取兩個中間數平均\n        No →\n            Decision: If maxHeap.size > minHeap.size? // 左堆較大\n                Yes → median = maxHeap.top // 取左堆最大值\n                No  → median = minHeap.top // 取右堆最小值\n→ Step 5: Return median // 回傳計算出的中位數\nEnd // 程式執行結束\n\nNeed to ensure each line has \"虛擬碼步驟 // 解釋\". For indented lines we still keep the arrow but maybe we can indent the line with spaces to show hierarchy. Each line can start with arrow.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Define class MedianFinder // 建立 MedianFinder 類別  \n→ Step 2: Initialize two heaps: maxHeap (max‑heap), minHeap (min‑heap) // 用於分別存儲較小與較大的數值  \n→ Step 3: Define method addNum(num) // 新增一個數字至資料結構  \n    → Decision: If maxHeap is empty OR num <= maxHeap.top? // 判斷該數字屬於左半部  \n        Yes → Push num into maxHeap // 加入左半部  \n        No  → Push num into minHeap // 加入右半部  \n    → Decision: If maxHeap.size > minHeap.size + 1? // 檢查左半部是否過大  \n        Yes → Move top element from maxHeap to minHeap // 平衡兩堆  \n        No →  \n            Decision: If minHeap.size > maxHeap.size + 1? // 檢查右半部是否過大  \n                Yes → Move top element from minHeap to maxHeap // 平衡兩堆  \n                No → // 堆已平衡  \n→ Step 4: Define method findMedian() // 查詢目前所有數字的中位數  \n    → Decision: If maxHeap.size == minHeap.size? // 堆大小相等  \n        Yes → median = (maxHeap.top + minHeap.top) / 2.0 // 取兩個中間數平均  \n        No →  \n            Decision: If maxHeap.size > minHeap.size? // 左堆較大  \n                Yes → median = maxHeap.top // 取左堆最大值  \n                No  → median = minHeap.top // 取右堆最小值  \n→ Step 5: Return median // 回傳計算出的中位數  \nEnd // 程式執行結束"
    },
    {
      "title": "Substring with Concatenation of All Words",
      "source_file": "Leetcode/leetcode30.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]",
          "expected_output": "[0,9]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp8ur2jnae.py\", line 88, in <module>\n    s, words = parse_input(raw_input)\n               ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp8ur2jnae.py\", line 72, in parse_input\n    tree = ast.parse(text)\n           ^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]\n    ^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]",
          "expected_output": "[]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpp9ko46a3.py\", line 88, in <module>\n    s, words = parse_input(raw_input)\n               ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpp9ko46a3.py\", line 72, in parse_input\n    tree = ast.parse(text)\n           ^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 2,
          "input": "s = \"barfoofoobarthefoobarman\", words = [\"bar\",\"foo\",\"the\"]",
          "expected_output": "[6,9,12]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp48igg1ma.py\", line 88, in <module>\n    s, words = parse_input(raw_input)\n               ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp48igg1ma.py\", line 72, in parse_input\n    tree = ast.parse(text)\n           ^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    s = \"barfoofoobarthefoobarman\", words = [\"bar\",\"foo\",\"the\"]\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def findSubstring(self, s: str, words) -> list:\n        \"\"\"\n        Find all starting indices of substrings in s that are a concatenation\n        of each word in words exactly once (order arbitrary).\n        \"\"\"\n        if not s or not words:\n            return []\n\n        word_len = len(words[0])          # length of each word\n        k = len(words)                    # number of words\n        total_len = word_len * k          # length of the concatenated substring\n        n = len(s)\n        if total_len > n:\n            return []\n\n        # frequency map of words\n        freq_words = defaultdict(int)\n        for w in words:\n            freq_words[w] += 1\n\n        result = []\n\n        # iterate over all possible starting positions modulo word_len\n        for offset in range(word_len):\n            left = offset          # left boundary of the sliding window\n            right = offset         # right boundary (exclusive)\n            curr_count = 0         # number of valid words matched in current window\n            freq_seen = defaultdict(int)\n\n            while right + word_len <= n:\n                word = s[right:right + word_len]\n                right += word_len\n\n                # If word not in words list, reset window\n                if word not in freq_words:\n                    freq_seen.clear()\n                    curr_count = 0\n                    left = right\n                    continue\n\n                # Include the new word into the window\n                freq_seen[word] += 1\n\n                if freq_seen[word] <= freq_words[word]:\n                    curr_count += 1\n                else:\n                    # Word frequency exceeded, shrink window from the left\n                    while freq_seen[word] > freq_words[word]:\n                        left_word = s[left:left + word_len]\n                        left += word_len\n                        freq_seen[left_word] -= 1\n                        if freq_seen[left_word] < freq_words[left_word]:\n                            curr_count -= 1\n\n                # If we have matched all words, record the starting index\n                if curr_count == k:\n                    result.append(left)\n\n        return result\n\ndef parse_input(text: str):\n    \"\"\"\n    Parse the input string to extract `s` and `words` variables.\n    The input format is expected to contain assignments like:\n        s = \"example\", words = [\"a\", \"b\"]\n    \"\"\"\n    tree = ast.parse(text)\n    s_val = None\n    words_val = None\n    for node in tree.body:\n        if isinstance(node, ast.Assign):\n            for target in node.targets:\n                if isinstance(target, ast.Name):\n                    if target.id == 's':\n                        s_val = ast.literal_eval(node.value)\n                    elif target.id == 'words':\n                        words_val = ast.literal_eval(node.value)\n    return s_val, words_val\n\nif __name__ == \"__main__\":\n    # Read all input from stdin\n    raw_input = sys.stdin.read()\n    s, words = parse_input(raw_input)\n\n    solution = Solution()\n    result = solution.findSubstring(s, words)\n\n    # Print the result list as a Python list representation\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce pseudocode for the problem: Find all starting indices of substring that is concatenation of all words (each used once). Classic Leetcode 30. We need to output step-by-step pseudocode.\n\nWe must not output actual code, only virtual code lines with explanations.\n\nWe need to handle multiple lines with arrow notation and decision structure.\n\nLet's design algorithm: For each possible starting index i from 0 to len(s)-total_len, we can check. But optimal uses sliding window with hash maps. Provide pseudo. Provide loops, sliding window.\n\nLet's produce pseudocode:\n\nStart\n→ Compute wordLen = len(words[0])\n→ Compute totalLen = wordLen * len(words)\n→ Build frequency map freqWords for words\n→ For each start in 0 .. wordLen-1: // to handle different mod classes\n    → Initialize left = start, right = start, currCount = 0, freqSeen = empty map\n    → While right + wordLen <= len(s):\n        → word = substring s[right:right+wordLen]\n        → right += wordLen\n        → If word not in freqWords: \n            → Reset freqSeen empty, currCount=0, left=right\n        → Else:\n            → Increment freqSeen[word]\n            → If freqSeen[word] <= freqWords[word]: currCount +=1\n            → Else:\n                → While freqSeen[word] > freqWords[word]:\n                    → leftWord = substring s[left:left+wordLen]\n                    → left += wordLen\n                    → Decrement freqSeen[leftWord]\n                    → If freqSeen[leftWord] < freqWords[leftWord]: currCount -=1\n            → If currCount == len(words):\n                → Record left as result\n→ End\n\nBut we must present line by line with explanations.\n\nLet's ensure each line starts with step label.\n\nWe'll use \"Start\", \"End\" etc.\n\nWe should also include a line to create result list.\n\nAlso for clarity, we use pseudocode arrow lines.\n\nLet's write:\n\nStart // 程式開始\n→ Step 1: wordLen ← length of words[0] // 取得單一單詞長度\n→ Step 2: totalLen ← wordLen * number of words // 所需子串總長\n→ Step 3: freqWords ← build frequency map of words // 單詞頻率表\n→ Step 4: results ← empty list // 存放符合條件的起始索引\n→ Decision: 是否需要檢查 s 是否長於 totalLen? \n    Yes → Decision: 如果 totalLen > length(s)? // 如果子串長度超過 s，直接返回空列表\n        Yes → Step 5: return results // 直接結束\n        No → // 繼續\n→ Step 6: For startIndex from 0 to wordLen-1: // 處理每個模組的起點\n    → Step 6.1: left ← startIndex // 左邊界\n    → Step 6.2: right ← startIndex // 右邊界\n    → Step 6.3: currCount ← 0 // 目前已匹配的單詞數\n    → Step 6.4: freqSeen ← empty map // 目前窗口內單詞頻率\n    → While right + wordLen ≤ length(s): // 右邊界不超過字串末尾\n        → Step 6.5: word ← substring s[right : right+wordLen] // 取下一個單詞長度片段\n        → right ← right + wordLen // 移動右邊界\n        → Decision: 是否為不在 freqWords 中的單詞? \n            Yes → Step 6.6: freqSeen ← empty map // 清空窗口\n            → currCount ← 0 // 重置已匹配數\n            → left ← right // 重新設定左邊界為右邊界\n            No → // 該單詞在單詞表中\n                → Step 6.7: freqSeen[word] ← freqSeen[word] + 1 // 更新窗口頻率\n                → Decision: freqSeen[word] ≤ freqWords[word] ?\n                    Yes → currCount ← currCount + 1 // 成功匹配一個單詞\n                    No → // 超過允許頻率，需要縮小窗口\n                        → While freqSeen[word] > freqWords[word]:\n                            → Step 6.8: leftWord ← substring s[left : left+wordLen] // 左邊界單詞\n                            → left ← left + wordLen // 移動左邊界\n                            → freqSeen[leftWord] ← freqSeen[leftWord] - 1 // 更新頻率\n                            → Decision: freqSeen[leftWord] < freqWords[leftWord] ?\n                                Yes → currCount ← currCount - 1 // 移除一個有效單詞\n                                No → // 無需調整 currCount\n                → Decision: currCount == number of words ?\n                    Yes → Step 6.9: results.append(left) // 取得完整排列，紀錄起始索引\n                    No → // 繼續檢查\n→ End // 程式結束\n\nNeed to ensure correct indentation or arrow. Use arrow for each line.\n\nAlso include a final line to return results? Usually after loops. Add Step 7: return results // 返回所有起始索引\n\nLet's incorporate that after loops.\n\nAlso we may need to clarify variable names.\n\nOk produce final output accordingly.\n...done thinking.\n\nStart // 程式開始\n→ Step 1: wordLen ← length of words[0] // 取得單一單詞長度\n→ Step 2: totalLen ← wordLen * number of words // 所需子串總長\n→ Step 3: freqWords ← build frequency map of words // 單詞頻率表\n→ Step 4: results ← empty list // 存放符合條件的起始索引\n→ Decision: totalLen > length(s)? // 如果子串長度超過 s，直接返回空列表\n    Yes → Step 5: return results // 直接結束\n    No → // 繼續執行\n→ Step 6: For startIndex from 0 to wordLen-1: // 處理每個模組的起點\n    → Step 6.1: left ← startIndex // 左邊界\n    → Step 6.2: right ← startIndex // 右邊界\n    → Step 6.3: currCount ← 0 // 目前已匹配的單詞數\n    → Step 6.4: freqSeen ← empty map // 目前窗口內單詞頻率\n    → While right + wordLen ≤ length(s): // 右邊界不超過字串末尾\n        → Step 6.5: word ← substring s[right : right+wordLen] // 取下一個單詞長度片段\n        → right ← right + wordLen // 移動右邊界\n        → Decision: word ∉ freqWords?\n            Yes → Step 6.6: freqSeen ← empty map // 清空窗口\n            → currCount ← 0 // 重置已匹配數\n            → left ← right // 重新設定左邊界為右邊界\n            No → // 該單詞在單詞表中\n                → Step 6.7: freqSeen[word] ← freqSeen[word] + 1 // 更新窗口頻率\n                → Decision: freqSeen[word] ≤ freqWords[word] ?\n                    Yes → currCount ← currCount + 1 // 成功匹配一個單詞\n                    No → // 超過允許頻率，需要縮小窗口\n                        → While freqSeen[word] > freqWords[word]:\n                            → Step 6.8: leftWord ← substring s[left : left+wordLen] // 左邊界單詞\n                            → left ← left + wordLen // 移動左邊界\n                            → freqSeen[leftWord] ← freqSeen[leftWord] - 1 // 更新頻率\n                            → Decision: freqSeen[leftWord] < freqWords[leftWord] ?\n                                Yes → currCount ← currCount - 1 // 移除一個有效單詞\n                                No → // 無需調整 currCount\n                → Decision: currCount == number of words ?\n                    Yes → Step 6.9: results.append(left) // 取得完整排列，紀錄起始索引\n                    No → // 繼續檢查\n→ Step 7: return results // 返回所有起始索引\nEnd // 程式結束"
    },
    {
      "title": "Group Anagrams",
      "source_file": "Leetcode/leetcode49.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]",
          "expected_output": "[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]'\nGot (Norm):      '[[\"ate\",\"eat\",\"tea\"],[\"bat\"],[\"nat\",\"tan\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]'\nRaw Got:      \"[['ate', 'eat', 'tea'], ['bat'], ['nat', 'tan']]\""
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\ndef group_anagrams(strs):\n    \"\"\"\n    將字串陣列分組，將字母相同（字母排序後相同）的字串放在同一個子陣列中。\n    \"\"\"\n    anagrams = defaultdict(list)          # key: 排序後的字串；value: 所屬字串列表\n    for s in strs:\n        key = ''.join(sorted(s))          # 排序後的字串作為 key\n        anagrams[key].append(s)\n\n    result = list(anagrams.values())\n\n    # 為了產生可預測的輸出，先對每個子陣列排序，再按第一個元素排序整個列表\n    for group in result:\n        group.sort()\n    result.sort(key=lambda g: g[0] if g else '')\n\n    return result\n\ndef main():\n    \"\"\"\n    從標準輸入讀取資料，解析成字串列表，計算並輸出 anagram 分組。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 期望的輸入格式類似於:  strs = [\"eat\",\"tea\",\"tan\"]\n    if '=' in data:\n        _, list_str = data.split('=', 1)\n    else:\n        list_str = data\n\n    list_str = list_str.strip()\n    try:\n        strs = ast.literal_eval(list_str)   # 安全地解析字串表達式\n    except Exception:\n        # 如果解析失敗，直接嘗試解析整個輸入\n        strs = ast.literal_eval(data)\n\n    result = group_anagrams(strs)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line, with arrow and explanation. Task: group anagrams. We need a virtual algorithm. Steps: start, init map, iterate each string, compute sorted key, map add to list, after loop, output list of lists. Use Decision? maybe for check map existence? We'll produce steps accordingly. Ensure each line has virtual code and explanation after //. Provide arrow. Use Start, End. Use Decision maybe when checking if key exists. Provide generic steps. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空字典 anagramMap 以存放「排序後的字串 → 該字串列表」對應關係 // 建立哈希表用於聚集同一組字母的字串  \n→ Step 2: 迴圈遍歷輸入陣列 strs 中的每個字串 word // 為每個字串處理  \n  → Step 3: 將字串 word 按字母排序得到 sortedWord // 生成可作為分組鍵的標準化字串  \n  → Decision: anagramMap 是否已包含 key sortedWord? // 判斷此排序後的字串是否已在字典中  \n    Yes → Step 4: 把 word 加入 anagramMap[sortedWord] 列表中 // 已存在，直接追加  \n    No  → Step 5: 建立新的列表 [word] 並將其設為 anagramMap[sortedWord] // 首次出現，建立新分組  \n→ Step 6: 迴圈結束後，將 anagramMap 的所有值（即各個分組的列表）收集到結果列表 result 中 // 把分組聚合起來  \nEnd // 程式執行結束，返回 result 作為最終答案"
    },
    {
      "title": "Zuma Game",
      "source_file": "Leetcode/leetcode488.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "board = \"WWRRBBWW\", hand = \"WRBRW\"",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '4'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '4'"
        }
      ],
      "generated_code": "import sys\nimport re\nfrom functools import lru_cache\n\nCOLORS = ['R', 'Y', 'B', 'G', 'W']\nINF = 10**9\n\ndef collapse(s: str) -> str:\n    \"\"\"Remove all consecutive groups of 3 or more after insertion.\"\"\"\n    stack = []  # each element is [color, count]\n    for ch in s:\n        if stack and stack[-1][0] == ch:\n            stack[-1][1] += 1\n        else:\n            stack.append([ch, 1])\n\n        # If the latest group reached 3+, pop it\n        while stack and stack[-1][1] >= 3:\n            stack.pop()\n            # After popping, the previous group might now reach 3+,\n            # but it will be handled when the next character is processed.\n    # Reconstruct string from remaining stack\n    return ''.join(color * count for color, count in stack)\n\ndef findMinStep(board: str, hand: str) -> int:\n    hand_counts = [hand.count(c) for c in COLORS]\n\n    @lru_cache(maxsize=None)\n    def dfs(b: str, counts: tuple) -> int:\n        if not b:\n            return 0\n        if all(c == 0 for c in counts):\n            return INF\n\n        best = INF\n        n = len(b)\n\n        for i in range(n + 1):\n            for idx, color in enumerate(COLORS):\n                if counts[idx] == 0:\n                    continue\n\n                # Check if inserting here can create or extend a group\n                if i > 0 and b[i-1] == color:\n                    new_pos = i - 1\n                elif i < n and b[i] == color:\n                    new_pos = i\n                elif i > 0 and i < n and b[i-1] == b[i] == color:\n                    new_pos = i - 1\n                else:\n                    continue  # no benefit from inserting here\n\n                new_board = b[:new_pos+1] + color + b[new_pos+1:]\n                collapsed = collapse(new_board)\n\n                new_counts = list(counts)\n                new_counts[idx] -= 1\n                res = dfs(collapsed, tuple(new_counts))\n                if res != INF:\n                    best = min(best, 1 + res)\n\n        return best\n\n    ans = dfs(board, tuple(hand_counts))\n    return -1 if ans == INF else ans\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # Try to extract quoted strings\n    matches = re.findall(r'\"([^\"]*)\"', data)\n    if len(matches) >= 2:\n        board_str, hand_str = matches[0], matches[1]\n    else:\n        # Fallback: split lines or whitespace\n        parts = data.replace('\\n', ' ').split()\n        if len(parts) >= 2:\n            board_str = parts[0].strip('\"')\n            hand_str = parts[1].strip('\"')\n        else:\n            # Unexpected format\n            sys.exit(1)\n\n    result = findMinStep(board_str, hand_str)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines, step by step, explaining algorithm to solve Zuma minimal insertions. We must output in Chinese (繁體). Provide each line with virtual code and comment.\n\nWe need to generate a description algorithm: use DFS with memoization, try to insert ball at each position that could merge. Use hand counts. For each recursion, try each color, if count > 0, insert at positions, then collapse. Implement collapse function: iterate over string, stack of (char,count). If count+1>=3 remove. Use recursion.\n\nWe need to produce pseudo-code lines, not actual code. Use Start, End, Decision, Step. We need to show iterative logic: for each position, try color.\n\nWe should output step by step virtual code with explanation.\n\nLet's design:\n\nStart\n→ Step 1: 讀取 board, hand  // 取得輸入\n→ Step 2: 計算 hand 各顏色個數 // 字典 counts\n→ Step 3: 呼叫 DFS(board, counts) // 開始搜尋最小插入數\n→ End\n\nDFS(board, counts)  // 主要遞迴\nDecision: 若 board 為空? // 已清空\n    Yes → Return 0 // 無需再插\nDecision: 若所有 counts 為0? // 手無剩球\n    Yes → Return INF // 代表失敗\n→ Step 4: 初始化 best = INF\n→ Loop i from 0 to len(board)  // 遍歷插入位置\n    → Step 5: For each color c where counts[c] > 0\n        → Step 6: 若 i>0 且 board[i-1]==c 或 i<len(board) 且 board[i]==c? // 只在能合併的位置插入\n            → Decision: 若 i>0 且 board[i-1]==c? \n                Yes → newPos = i-1\n                No  → newPos = i\n            → Step 7: 插入 c 到 newPos: newBoard = board[:newPos+1] + c + board[newPos+1:]\n            → Step 8: newBoard = collapse(newBoard) // 消除連續3+\n            → Step 9: counts[c] -=1\n            → Step 10: res = DFS(newBoard, counts)\n            → Step 11: 若 res != INF: best = min(best, 1+res)\n            → Step 12: counts[c] +=1 // 回朔\n→ End Loop\n→ Decision: 若 best == INF? \n    Yes → Return INF\n    No  → Return best\n\ncollapse(board)\n→ Step 13: 初始化 stack []\n→ Step 14: 遍歷 board 字元\n    → Step 15: 若 stack 非空 且 top 顏色 == current char\n        → Step 16: top.count +=1\n    → Step 17: 否則 push (char,count=1)\n    → Step 18: 若 top.count >=3:\n        → Step 19: pop stack\n        → Step 20: 回到 Step 14 (重新檢查前一個 stack top 是否連續)\n→ End\n→ Step 21: 合併 stack 成 string result\n→ Return result\n\nFinally, main: ans = DFS(board, handCounts)\nDecision: 若 ans==INF? \n    Yes → Return -1\n    No  → Return ans\n\nNeed to convert to virtual code lines. Use arrows and decisions.\n\nWe'll produce line by line, each with comment.\n\nLet's write them. Ensure we use Start/End and Decision. Provide each line with comment. Use Chinese.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取 board 與 hand // 取得輸入字串  \n→ Step 2: 計算 hand 各顏色個數成為 counts // 例如 {'R':2,'Y':1,...}  \n→ Step 3: ans ← DFS(board, counts) // 呼叫遞迴搜尋最小插入數  \n→ Decision: 若 ans == INF? // 無法清空  \n  Yes → Return -1 // 任務失敗  \n  No  → Return ans // 任務成功，返回最少插入數  \nEnd // 程式執行結束  \n\n// --------------------- DFS 函式 ---------------------  \nDFS(board, counts)  \n Decision: 若 board 為空? // 已清空全部球  \n  Yes → Return 0 // 不需再插  \n Decision: 若 all counts == 0? // 手上無剩球  \n  Yes → Return INF // 表示失敗  \n → Step 4: best ← INF // 初始最小值  \n → Loop i ← 0 to len(board) // 遍歷所有插入位置  \n  → Step 5: For each color c where counts[c] > 0  \n   → Decision: 若 i>0 且 board[i-1]==c 或 i < len(board) 且 board[i]==c? // 只在能連續合併的位置插  \n    Yes → newPos ← (i>0 and board[i-1]==c) ? i-1 : i  \n    No  → Continue // 無法連合，跳過此位置  \n   → Step 6: newBoard ← board[:newPos+1] + c + board[newPos+1:] // 插入球  \n   → Step 7: newBoard ← collapse(newBoard) // 消除所有連續 3+ 的球  \n   → Step 8: counts[c] ← counts[c] - 1 // 用掉一顆手牌  \n   → Step 9: res ← DFS(newBoard, counts) // 進一步遞迴  \n   → Step 10: 若 res != INF: best ← min(best, 1 + res) // 更新最小值  \n   → Step 11: counts[c] ← counts[c] + 1 // 回朔，還原手牌數量  \n → End Loop  \n Decision: 若 best == INF?  \n  Yes → Return INF // 無法清空  \n  No  → Return best // 返回目前已知最小插入數  \nEnd DFS  \n\n// --------------------- collapse 函式 ---------------------  \ncollapse(board)  \n → Step 12: stack ← [] // 存放 (顏色, 數量)  \n → For each ch in board  \n  → Decision: 若 stack 不是空且 stack.top.color == ch?  \n   Yes → stack.top.count ← stack.top.count + 1 // 連續累計  \n   No  → Push (ch, 1) onto stack // 新段落  \n  → Decision: 若 stack.top.count >= 3?  \n   Yes → Pop stack // 消除段落  \n    → Step 13: 重新檢查前一段是否也能消除（回到決策點）  \n → End For  \n → Step 14: result ← 合併 stack 中的顏色按順序成為字串  \n → Return result  \n\n// --------------------- 常數定義 ---------------------  \nINF ← 大於任何可能插入數的整數（如 10^9）  \n\n// 以上即為解題的虛擬碼，符合「逐行」且每行附帶簡短說明。"
    },
    {
      "title": "Roman to Integer",
      "source_file": "Leetcode/leetcode13.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 2,
          "input": "Input: s = \"MCMXCIV\"",
          "expected_output": "Output: 1994",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'Output:1994'\nGot (Norm):      '1994'\n--- (Raw) ---\nRaw Expected: 'Output: 1994'\nRaw Got:      '1994'"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef roman_to_int(s: str) -> int:\n    \"\"\"將羅馬數字轉換成整數\"\"\"\n    roman_map = {\n        'I': 1, 'V': 5, 'X': 10, 'L': 50,\n        'C': 100, 'D': 500, 'M': 1000\n    }\n    total = 0\n    prev_value = 0\n    # 由右向左遍歷，方便判斷減法\n    for char in reversed(s):\n        value = roman_map[char]\n        if value < prev_value:\n            total -= value\n        else:\n            total += value\n        prev_value = value\n    return total\n\ndef main():\n    \"\"\"讀取輸入、解析羅馬數字、輸出整數\"\"\"\n    data = sys.stdin.read().strip()\n    # 先嘗試找出雙引號中的內容\n    match = re.search(r'\"([^\"]*)\"', data)\n    if match:\n        roman_str = match.group(1)\n    else:\n        # 若沒有雙引號，直接用整個輸入（去除可能的空白）\n        roman_str = data.replace(\" \", \"\")\n    # 計算並輸出\n    result = roman_to_int(roman_str)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudo code to convert Roman numeral string to integer. The description includes the mapping and subtraction rules. So produce algorithm: iterate over string left to right, add value; if current value < next value, subtract instead of add. Or more directly: for each char, if next char value > current, subtract current; else add. Then sum. We output pseudocode line by line with comments.\n\nEnsure each line has \"虛擬碼步驟 [space] // 解釋\". Use arrow characters. Use structure: Start, End, Decision etc.\n\nWe need to handle mapping table creation maybe. So we can do:\n\nStart\n→ Step 1: Initialize map of Roman symbols to integer values\n→ Step 2: Initialize result = 0\n→ Step 3: For i from 0 to length of input - 1\n   → Decision: If i < length-1 and value[s[i]] < value[s[i+1]]?\n      Yes → Step 4: result = result - value[s[i]] // subtract because smaller before larger\n      No  → Step 5: result = result + value[s[i]] // add normally\n→ Step 6: Return result\nEnd\n\nAlso need to explain mapping, length, etc. Provide short explanation each line.\n\nLet's produce final answer in Traditional Chinese. Ensure each line has \"虛擬碼步驟 // 解釋\" with no extra formatting like bullet. Use arrow. Ensure each line ends with comment. Should include Start and End.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立符號對應表 Map ← { 'I':1, 'V':5, 'X':10, 'L':50, 'C':100, 'D':500, 'M':1000 } // 建立羅馬數字對應的整數值  \n→ Step 2: result ← 0 // 用來累加整數結果  \n→ Step 3: For i ← 0 to length(input)-1 // 逐字元處理輸入字串  \n  → Decision: i < length(input)-1 且 Map[input[i]] < Map[input[i+1]]? // 判斷當前符號是否在較大的符號前，需做減法  \n   Yes → Step 4: result ← result - Map[input[i]] // 小符號在大符號前，執行減法  \n   No  → Step 5: result ← result + Map[input[i]] // 其他情況執行加法  \n→ Step 6: Return result // 回傳最終計算出的整數值  \nEnd // 程式執行結束"
    },
    {
      "title": "Maximum Gap",
      "source_file": "Leetcode/leetcode164.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [3,6,9,1]",
          "expected_output": "3",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpc2c0ljm5.py\", line 46, in <module>\n    nums = eval(data)\n           ^^^^^^^^^^\n  File \"<string>\", line 1\n    nums = [3,6,9,1]\n         ^\nSyntaxError: invalid syntax"
        },
        {
          "example_index": 1,
          "input": "nums = [10]",
          "expected_output": "0",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpd18tvip4.py\", line 46, in <module>\n    nums = eval(data)\n           ^^^^^^^^^^\n  File \"<string>\", line 1\n    nums = [10]\n         ^\nSyntaxError: invalid syntax"
        }
      ],
      "generated_code": "import sys\nimport math\n\nclass Solution:\n    def maximumGap(self, nums):\n        n = len(nums)\n        if n < 2:\n            return 0\n\n        min_val, max_val = min(nums), max(nums)\n        if min_val == max_val:\n            return 0\n\n        # bucket size: ceil((max - min) / (n-1))\n        bucket_size = max(1, (max_val - min_val) // (n - 1) + 1)\n        bucket_count = n - 1\n\n        # 初始化每個 bucket 的 min、max\n        min_bucket = [float('inf')] * bucket_count\n        max_bucket = [float('-inf')] * bucket_count\n\n        # 放入 bucket\n        for num in nums:\n            idx = (num - min_val) // bucket_size\n            if idx >= bucket_count:   # 當 num == max_val 時 idx 可能等於 bucket_count\n                idx = bucket_count - 1\n            min_bucket[idx] = min(min_bucket[idx], num)\n            max_bucket[idx] = max(max_bucket[idx], num)\n\n        # 計算最大差距\n        last_max = min_val\n        max_gap = 0\n        for i in range(bucket_count):\n            if min_bucket[i] == float('inf'):  # 空 bucket\n                continue\n            max_gap = max(max_gap, min_bucket[i] - last_max)\n            last_max = max_bucket[i]\n\n        return max_gap\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    # 讀取輸入，假設輸入格式為 Python 可評估的列表，例如 \"nums = [3,6,9,1]\"\n    nums = eval(data)\n    result = Solution().maximumGap(nums)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to output virtual code steps with comments. Use linear time and space algorithm: typical bucket sort based maximum gap problem. Steps: handle size < 2 return 0. Compute min, max. If min==max return 0. Compute bucket size = ceil((max-min)/(n-1)). bucket count = n-1. Initialize arrays minBucket, maxBucket with extremes. Place each number into bucket: index = (num - min) / bucketSize. Update bucket min, max. Then traverse buckets to find max gap: lastMax = min; maxGap = 0. For each bucket: if bucket empty skip; gap = bucket.min - lastMax; update maxGap; lastMax = bucket.max. Return maxGap.\n\nLet's produce virtual code line by line. Use Start, Decision, Steps, End. We'll label steps. Use arrows. Provide short explanation after each. Let's produce maybe 30 lines.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 如果 nums.Length < 2 → Decision: nums.Length < 2? // 檢查陣列長度  \n  Yes → Step 2: 回傳 0 // 少於兩個元素，最大差距為 0  \n  No → Step 3: 計算 minValue, maxValue // 找到數組中的最小值與最大值  \n→ Step 4: 如果 minValue == maxValue → Decision: minValue == maxValue? // 所有元素相同  \n  Yes → Step 5: 回傳 0 // 差距為 0  \n  No → Step 6: 計算 bucketSize = ceil((maxValue - minValue) / (nums.Length - 1)) // bucket 大小  \n→ Step 7: bucketCount = nums.Length - 1 // bucket 數量  \n→ Step 8: 初始化 minBucket[ bucketCount ] 為 +∞，maxBucket[ bucketCount ] 為 -∞ // bucket 的 min、max  \n→ Step 9: 對於每個 num in nums  \n   → bucketIndex = (num - minValue) / bucketSize // 決定 num 所在的 bucket  \n   → minBucket[ bucketIndex ] = min( minBucket[ bucketIndex ], num ) // 更新 bucket 的最小值  \n   → maxBucket[ bucketIndex ] = max( maxBucket[ bucketIndex ], num ) // 更新 bucket 的最大值  \n→ Step 10: lastMax = minValue // 上一個非空 bucket 的最大值  \n  → maxGap = 0 // 目前最大的差距  \n→ Step 11: 從 bucketIndex = 0 到 bucketCount - 1  \n   → 如果 minBucket[ bucketIndex ] == +∞ → Decision: bucket 为空? // 跳過空 bucket  \n    Yes → Continue // 無需處理  \n    No → Step 12: gap = minBucket[ bucketIndex ] - lastMax // 兩個相鄰 bucket 之間的差距  \n    → maxGap = max( maxGap, gap ) // 更新最大差距  \n    → lastMax = maxBucket[ bucketIndex ] // 更新 lastMax 為當前 bucket 的最大值  \n→ Step 13: 回傳 maxGap // 完成計算  \nEnd // 程式執行結束"
    },
    {
      "title": "Intersection of Two Arrays II",
      "source_file": "Leetcode/leetcode350.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "nums1 = [4,9,5], nums2 = [9,4,9,8,4]",
          "expected_output": "[4,9]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[4,9]'\nGot (Norm):      '[9,4]'\n--- (Raw) ---\nRaw Expected: '[4,9]'\nRaw Got:      '[9, 4]'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def intersect(self, nums1, nums2):\n        # 使用字典計數 nums1 的頻率\n        freq = {}\n        for x in nums1:\n            freq[x] = freq.get(x, 0) + 1\n        # 建立結果列表\n        res = []\n        for y in nums2:\n            if freq.get(y, 0) > 0:\n                res.append(y)\n                freq[y] -= 1\n        return res\n\ndef parse_input():\n    \"\"\"\n    讀取 stdin，嘗試解析出兩個整數列表。\n    支援以下格式：\n    1. 單行：nums1 = [1,2,2,1], nums2 = [2,2]\n    2. 兩行：每行一個列表，例如\n       [1,2,2,1]\n       [2,2]\n    \"\"\"\n    data = sys.stdin.read()\n    if not data:\n        return [], []\n\n    # 先搜尋所有 [] 中的內容\n    lists = re.findall(r'\\[.*?\\]', data, re.S)\n    if len(lists) >= 2:\n        try:\n            nums1 = ast.literal_eval(lists[0])\n            nums2 = ast.literal_eval(lists[1])\n            return nums1, nums2\n        except Exception:\n            pass\n\n    # 如果沒有找到，嘗試逐行解析\n    lines = [line.strip() for line in data.splitlines() if line.strip()]\n    if len(lines) >= 2:\n        try:\n            nums1 = ast.literal_eval(lines[0])\n            nums2 = ast.literal_eval(lines[1])\n            return nums1, nums2\n        except Exception:\n            pass\n\n    # 最後的備用方案：假設所有數字在同一行，用空白或逗號分隔\n    try:\n        numbers = [int(tok) for tok in re.split(r'[,\\s]+', data) if tok]\n        # 如果能夠公平分割\n        mid = len(numbers) // 2\n        return numbers[:mid], numbers[mid:]\n    except Exception:\n        return [], []\n\ndef main():\n    nums1, nums2 = parse_input()\n    sol = Solution()\n    result = sol.intersect(nums1, nums2)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code in Chinese. Provide step-by-step pseudocode, line by line with arrow and explanation. The requirement: no actual code, just virtual steps. Use Start, Decision, etc.\n\nWe need to solve intersection of two integer arrays, include duplicates.\n\nAlgorithm: Use dictionary/map to count frequencies in nums1, then iterate nums2, for each element if count>0, add to result and decrement. Or vice versa.\n\nNeed to produce virtual code steps.\n\nWe should reflect steps: Start, create map, iterate nums1 fill map, create empty result list, iterate nums2, if element in map with count >0, add to result and decrement, end.\n\nWe need to use arrows and decision.\n\nLet's produce lines:\n\nStart\n\n→ Step 1: Initialize frequency map for nums1 // 建立 nums1 元素頻率表\n\n→ Step 2: For each element x in nums1 // 遍歷 nums1\n\n→ Decision: 是否已存在 x 在 map? // 檢查 map 中是否已有該元素\n\n→ Yes → Update count for x in map (increment) // 若已存在，頻率加1\n\n→ No → Insert x into map with count 1 // 若不存在，新增並設為1\n\n→ Step 3: Initialize empty result list // 建立結果陣列\n\n→ Step 4: For each element y in nums2 // 遍歷 nums2\n\n→ Decision: 是否存在 y 且 count >0 在 map? // 檢查 y 是否在 map 且頻率>0\n\n→ Yes → Append y to result // 將 y 加入結果\n\n→ Yes → Decrement count of y in map // 減少 y 的頻率\n\n→ No → Do nothing // y 不符合條件\n\n→ End // 結束程式\n\nMake sure to include // after each line.\n\nUse arrow symbol \"→\".\n\nAlso need to keep each line separate.\n\nWe should ensure each line includes explanation after space.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化頻率表 map // 建立一個 hash map 用於存儲 nums1 中每個元素的出現次數  \n→ Step 2: 從 nums1 中逐個取出元素 x // 遍歷第一個陣列  \n→ Decision: x 已存在於 map? // 判斷該元素是否已經被記錄過  \n    Yes → map[x] ← map[x] + 1 // 若已存在，將頻率加 1  \n    No  → map[x] ← 1 // 若不存在，新增鍵並將頻率設為 1  \n→ Step 3: 初始化結果列表 res = [] // 用於保存交集元素  \n→ Step 4: 從 nums2 中逐個取出元素 y // 遍歷第二個陣列  \n→ Decision: y 在 map 且 map[y] > 0? // 判斷 y 是否在第一個陣列中且還有剩餘可配對的數量  \n    Yes → res ← res + [y] // 將 y 加入結果  \n    Yes → map[y] ← map[y] - 1 // 減少對應頻率  \n    No  → （不做任何事） // y 不符合交集條件  \nEnd // 程式執行結束，返回結果 res"
    },
    {
      "title": "Complex Number Multiplication",
      "source_file": "Leetcode/leetcode537.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "\"1+-1i\", \"1+-1i\"",
          "expected_output": "\"0+-2i\"",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp7i38bmt4.py\", line 60, in <module>\n    main()\n  File \"/tmp/tmp7i38bmt4.py\", line 54, in main\n    result = complex_number_multiply(num1, num2)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp7i38bmt4.py\", line 28, in complex_number_multiply\n    a_real, a_imag = parse_complex(a)\n                     ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp7i38bmt4.py\", line 24, in parse_complex\n    real_part = int(s[:idx])\n                ^^^^^^^^^^^^\nValueError: invalid literal for int() with base 10: '1+'"
        }
      ],
      "generated_code": "import sys\n\ndef complex_number_multiply(a: str, b: str) -> str:\n    \"\"\"將兩個複數字串相乘，回傳格式為 'real+imaginaryi' 的字串。\"\"\"\n\n    def parse_complex(s: str):\n        \"\"\"將形如 'real+imaginaryi' 或 'real-imaginaryi' 的字串轉成兩個整數。\"\"\"\n        s = s.strip()\n        # 移除最後的 'i'\n        if s.endswith('i'):\n            s = s[:-1]\n\n        # 找到分隔實部與虛部的最後一個 '+' 或 '-'\n        plus_idx = s.rfind('+')\n        minus_idx = s.rfind('-')\n        # 只考慮第一個字元不是符號的情況\n        idx = max(\n            plus_idx if plus_idx > 0 else -1,\n            minus_idx if minus_idx > 0 else -1\n        )\n        if idx == -1:  # 這裡不應該發生，因為輸入一定合法\n            raise ValueError(\"Invalid complex number format\")\n\n        real_part = int(s[:idx])\n        imag_part = int(s[idx:])\n        return real_part, imag_part\n\n    a_real, a_imag = parse_complex(a)\n    b_real, b_imag = parse_complex(b)\n\n    # 複數相乘公式\n    real = a_real * b_real - a_imag * b_imag\n    imag = a_real * b_imag + a_imag * b_real\n\n    # 直接以 '+' 為分隔符號，即使 imag 為負也保留符號\n    return f\"{real}+{imag}i\"\n\n\ndef main() -> None:\n    \"\"\"主函式，從標準輸入讀取兩個複數字串，輸出相乘結果。\"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 輸入格式示例：'\"1+1i\", \"1+1i\"'\n    parts = [p.strip() for p in data.split(',')]\n    if len(parts) < 2:\n        return\n\n    # 移除兩邊可能存在的雙引號\n    num1 = parts[0].strip('\"').strip()\n    num2 = parts[1].strip('\"').strip()\n\n    result = complex_number_multiply(num1, num2)\n    # 依題目示例，輸出時包含雙引號\n    print(f'\"{result}\"')\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines, step by step, for multiplying two complex numbers given as strings. Need to parse, multiply, produce string. Provide explanation after each line. Use Start, End, Decision. Avoid actual code, just pseudo steps. Should be understandable. Let's craft.\n\nSteps: Start. Input strings num1, num2. Parse real1, imag1 from num1. Parse real2, imag2 from num2. Multiply using formula: real = real1*real2 - imag1*imag2, imag = real1*imag2 + imag1*real2. Compose result string \"real+imagi\" with appropriate sign. End.\n\nWe also need to handle negative imaginary parts sign: e.g., if imag negative, output \"real-abs(imagi)\". Ensure we handle +0? but range [-100,100]. We can ignore.\n\nImplement Decision: when parsing, find '+' or '-' between real and imaginary? The string always contains '+', but if imaginary negative, it might be something like \"3-2i\"? Wait spec: \"real+imaginaryi\" where imaginary integer can be negative. So string could be \"3-2i\" or \"3+2i\". So parsing: find 'i' at end, substring before 'i' is real+imag. Use last '+' or '-' before 'i' to split. But for simplicity, we can just split at '+' or '-' not at index 0. We'll use Decision to find sign.\n\nAlso need to convert to integer.\n\nLet's write pseudo code:\n\nStart\n→ Input: num1, num2 // Get two complex number strings\n→ Parse: real1, imag1 ← ParseComplex(num1) // Convert string to integers\n→ Parse: real2, imag2 ← ParseComplex(num2)\n→ Compute: realPart ← real1*real2 - imag1*imag2 // Real part of product\n→ Compute: imagPart ← real1*imag2 + imag1*real2 // Imaginary part of product\n→ Format: resultStr ← FormatComplex(realPart, imagPart) // Convert to string\n→ Output: resultStr // Return product string\nEnd\n\nNow define subroutine ParseComplex(s):\n→ Find index of 'i' // should be last char\n→ Remove 'i', get sub = s[0:len-1]\n→ Decision: If sub contains '+'? Find last '+' or '-' not at index 0\n    Yes → splitIdx = last occurrence of '+' or '-'\n    No  → splitIdx = -1 // not found (shouldn't happen)\n→ realStr ← sub[0:splitIdx] // part before sign\n→ imagStr ← sub[splitIdx:] // sign + number\n→ Convert to int: real ← ToInt(realStr)\n→ Convert to int: imag ← ToInt(imagStr)\n→ Return real, imag\n\nFormatComplex(real, imag):\n→ Decision: If imag >= 0? // positive or zero\n    Yes → result ← real + \"+\" + imag + \"i\"\n    No  → result ← real + imag + \"i\" // imag negative already has '-'\n→ Return result\n\nAlso include ToInt conversion.\n\nAdd steps for decision.\n\nWe need to include each line with explanation.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Input: num1, num2 // 取得兩個複數字串\n→ Parse: real1, imag1 ← ParseComplex(num1) // 將第一個字串轉成實部與虛部整數\n→ Parse: real2, imag2 ← ParseComplex(num2) // 將第二個字串轉成實部與虛部整數\n→ Compute: realPart ← real1*real2 - imag1*imag2 // 計算乘積的實部\n→ Compute: imagPart ← real1*imag2 + imag1*real2 // 計算乘積的虛部\n→ Format: resultStr ← FormatComplex(realPart, imagPart) // 將實部與虛部組成字串\n→ Output: resultStr // 回傳乘積的複數字串\nEnd // 程式執行結束\n\n--- Subroutine ParseComplex(s) ---\nStart // 開始解析複數字串\n→ Find: iIdx ← IndexOf('i' in s) // 找到字串最後的 i\n→ Slice: sub ← Substring(s, 0, iIdx) // 取出 'i' 前面的部分\n→ Decision: 是否包含 '+'? // 檢查是否存在正號分隔符\n    Yes → splitIdx ← LastIndexOf('+' in sub) // 找到最後一個 '+'（正虛部）\n    No  → Decision: 是否包含 '-'? // 若沒有 '+', 檢查負號分隔符\n        Yes → splitIdx ← LastIndexOf('-' in sub) // 找到最後一個 '-'（負虛部）\n        No  → splitIdx ← -1 // 無法分割，格式錯誤\n→ Slice: realStr ← Substring(sub, 0, splitIdx) // 取出實部字串\n→ Slice: imagStr ← Substring(sub, splitIdx, Length(sub)-splitIdx) // 取出虛部字串（含符號）\n→ Convert: real ← ToInt(realStr) // 轉成整數\n→ Convert: imag ← ToInt(imagStr) // 轉成整數\n→ Return: real, imag // 傳回兩個整數\nEnd // 結束解析子程序\n\n--- Subroutine FormatComplex(real, imag) ---\nStart // 開始組成複數字串\n→ Decision: imag >= 0? // 檢查虛部是否為正或零\n    Yes → result ← Concatenate(real, \"+\", imag, \"i\") // 直接加正號\n    No  → result ← Concatenate(real, imag, \"i\") // imag 本身已帶負號\n→ Return: result // 傳回格式化後的字串\nEnd // 結束格式化子程序"
    },
    {
      "title": "Implement Rand10() Using Rand7()",
      "source_file": "Leetcode/leetcode470.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 1",
          "expected_output": "[2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpamptlzek.py\", line 42, in <module>\n    main()\n  File \"/tmp/tmpamptlzek.py\", line 38, in main\n    result = [sol.rand10() for _ in range(n)]\n              ^^^^^^^^^^^^\n  File \"/tmp/tmpamptlzek.py\", line 14, in rand10\n    num = (rand7() - 1) * 7 + rand7()   # 1 ~ 49\n           ^^^^^\nNameError: name 'rand7' is not defined. Did you mean: 'range'?"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[2,8]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpff3uvouz.py\", line 42, in <module>\n    main()\n  File \"/tmp/tmpff3uvouz.py\", line 38, in main\n    result = [sol.rand10() for _ in range(n)]\n              ^^^^^^^^^^^^\n  File \"/tmp/tmpff3uvouz.py\", line 14, in rand10\n    num = (rand7() - 1) * 7 + rand7()   # 1 ~ 49\n           ^^^^^\nNameError: name 'rand7' is not defined. Did you mean: 'range'?"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "[3,8,10]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp82cvdbeg.py\", line 42, in <module>\n    main()\n  File \"/tmp/tmp82cvdbeg.py\", line 38, in main\n    result = [sol.rand10() for _ in range(n)]\n              ^^^^^^^^^^^^\n  File \"/tmp/tmp82cvdbeg.py\", line 14, in rand10\n    num = (rand7() - 1) * 7 + rand7()   # 1 ~ 49\n           ^^^^^\nNameError: name 'rand7' is not defined. Did you mean: 'range'?"
        }
      ],
      "generated_code": "import sys\n\n# 假設外部已經提供了 rand7() 函式\n# 這裡僅使用它來實作 rand10()\nclass Solution:\n    def rand10(self):\n        \"\"\"\n        產生 1~10 的等概率隨機整數。\n        利用兩次 rand7() 生成 1~49 的等概率數，\n        若值大於 40 則重試，否則映射至 1~10。\n        \"\"\"\n        while True:\n            # 兩次呼叫 rand7()，組合成 1~49\n            num = (rand7() - 1) * 7 + rand7()   # 1 ~ 49\n            if num <= 40:                       # 只使用前 40 個結果\n                return 1 + (num - 1) % 10       # 映射到 1 ~ 10\n\ndef main():\n    \"\"\"\n    讀取輸入，格式預期為 'n = X' 或僅為 X。\n    呼叫 rand10() n 次，將結果以列表形式輸出。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    # 解析輸入中的 n\n    n = 0\n    if '=' in data:\n        try:\n            n = int(data.split('=')[1].strip())\n        except ValueError:\n            n = 0\n    else:\n        try:\n            n = int(data)\n        except ValueError:\n            n = 0\n\n    sol = Solution()\n    result = [sol.rand10() for _ in range(n)]\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step. For rand10 using rand7, typical solution: use two rand7 to generate 49 outcomes; reject if >40, map 1-40 to 1-10. Implementation: while true: r1=rand7(); r2=rand7(); num = (r1-1)*7 + r2; if num <=40: return (num-1)%10+1. That's the classic algorithm.\n\nWe must output lines with virtual code and explanation. Use arrow, Decision. Let's produce Start, Step lines. We'll use Step 1: call rand7 for r1. Step 2: call rand7 for r2. Step 3: compute num. Step 4: Decision if num <=40? Yes: output rand10, No: loop again.\n\nUse arrow '→'. Use Decision: ... with Yes →, No →. End.\n\nMake sure each line includes \"虛擬碼步驟 [space] // 解釋\". Use Chinese explanation. Also \"Start // 程式開始執行\" etc. Use \"End // 程式執行結束\".\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: r1 ← rand7() // 先呼叫 rand7() 產生 1~7 的隨機數  \n→ Step 2: r2 ← rand7() // 再呼叫 rand7() 產生 1~7 的隨機數  \n→ Step 3: num ← (r1 - 1) * 7 + r2 // 將兩個數合併成 1~49 的等概率數  \n→ Decision: 是否 num ≤ 40? // 只使用前 40 個結果來映射至 1~10  \n  Yes → Step 4: return (num - 1) % 10 + 1 // 將 1~40 映射為 1~10，結束函式  \n  No  → Step 5: goto Step 1 // 若 num 大於 40，重新開始循環  \nEnd // 程式執行結束"
    },
    {
      "title": "Expression Add Operators",
      "source_file": "Leetcode/leetcode282.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "num = \"123\", target = 6",
          "expected_output": "[\"1*2*3\",\"1+2+3\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"1*2*3\",\"1+2+3\"]'\nGot (Norm):      '[\"1+2+3\",\"1*2*3\"]'\n--- (Raw) ---\nRaw Expected: '[\"1*2*3\",\"1+2+3\"]'\nRaw Got:      \"['1+2+3', '1*2*3']\""
        },
        {
          "example_index": 1,
          "input": "num = \"232\", target = 8",
          "expected_output": "[\"2*3+2\",\"2+3*2\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"2*3+2\",\"2+3*2\"]'\nGot (Norm):      '[\"2+3*2\",\"2*3+2\"]'\n--- (Raw) ---\nRaw Expected: '[\"2*3+2\",\"2+3*2\"]'\nRaw Got:      \"['2+3*2', '2*3+2']\""
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def addOperators(self, num: str, target: int):\n        res = []\n\n        def backtrack(index, path, value, last):\n            if index == len(num):\n                if value == target:\n                    res.append(path)\n                return\n\n            for i in range(index + 1, len(num) + 1):\n                temp = num[index:i]\n                if len(temp) > 1 and temp[0] == '0':\n                    continue\n                curr = int(temp)\n                if index == 0:\n                    backtrack(i, temp, curr, curr)\n                else:\n                    backtrack(i, path + '+' + temp, value + curr, curr)\n                    backtrack(i, path + '-' + temp, value - curr, -curr)\n                    backtrack(i, path + '*' + temp,\n                              value - last + last * curr, last * curr)\n\n        backtrack(0, '', 0, 0)\n        return res\n\ndef parse_input(data: str):\n    # Convert input like 'num = \"123\", target = 6' to dict\n    for key in ['num', 'target']:\n        data = re.sub(r'\\b' + key + r'\\b', f'\"{key}\"', data)\n    data = data.replace('=', ':')\n    try:\n        parsed = eval('{' + data + '}')\n    except Exception:\n        parsed = {}\n    return parsed.get('num', ''), int(parsed.get('target', 0))\n\nif __name__ == \"__main__\":\n    raw = sys.stdin.read().strip()\n    if not raw:\n        sys.exit()\n    num, target = parse_input(raw)\n    sol = Solution()\n    result = sol.addOperators(num, target)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm: generate all expressions by inserting operators between digits such that evaluation equals target. This is classic expression add operators problem.\n\nWe need to produce step-by-step pseudocode with explanation. Each line: virtual code step followed by // explanation. Use arrows, Decision, etc.\n\nWe need to produce Start, End. Provide algorithm steps: define recursive DFS, handle leading zeros, maintain cumulative value, previous operand for multiplication. Steps: iterate over split positions.\n\nWe'll produce lines:\n\nStart\n→ Step 1: Initialize result list // store valid expressions\n→ Step 2: Call dfs(index=0, path=\"\", current_val=0, prev_operand=0) // start recursion\n\nDefine dfs function: recursive function.\n\nWe need to show decisions: if index==len(num) -> if current_val==target add to result.\n\nElse loop i from index to len(num)-1, extract cur_str = num[index:i+1], if cur_str has leading zero and length>1 skip.\n\ncur_val = int(cur_str)\n\nIf index==0: path = cur_str; dfs(i+1, path, cur_val, cur_val)\n\nElse:\n\nDecision: Add '+': dfs(i+1, path + '+' + cur_str, current_val + cur_val, cur_val)\n\nDecision: Add '-': dfs(i+1, path + '-' + cur_str, current_val - cur_val, -cur_val)\n\nDecision: Add '*': new_val = current_val - prev_operand + prev_operand * cur_val; dfs(i+1, path + '*' + cur_str, new_val, prev_operand * cur_val)\n\nEnd of loop\n\nReturn result\n\nEnd\n\nBut we need to represent each step in format: virtual code + explanation.\n\nLet's produce step-by-step: Start, then steps for main function, then DFS definition, loops, decisions.\n\nLet's include indentation? The format uses arrows: → Step 1: etc.\n\nWe'll produce nested steps with indentation? The example shows indentation with spaces but not necessarily. They used indentation lines with spaces and Decision: inside. We'll replicate similar style.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: Define function addOperators(num, target) → result = [] // 初始化結果列表\n→ Step 2: Define recursive helper dfs(index, path, current_val, prev_operand) // 定義遞迴\n→ Decision: 內部的 dfs 需要處理結束條件\n    → Step 3: If index == len(num) → Decision: 是否符合目標\n        → Yes → Step 4: 如果 current_val == target → Add path to result // 成功則加入結果\n        → No  → Step 5: 返回 // 不符合目標\n\n→ Decision: 迴圈遍歷子串\n    → Step 6: For i from index to len(num)-1\n        → Step 7: cur_str = num[index:i+1] // 取出子串\n        → Decision: 是否為合法數字 (非前導零)\n            → Yes → Step 8: cur_val = int(cur_str) // 轉為整數\n                → Decision: index == 0? // 第一次處理\n                    → Yes → Step 9: dfs(i+1, cur_str, cur_val, cur_val) // 第一次直接使用\n                    → No  → Decision: 加法\n                        → Yes → Step 10: dfs(i+1, path+'+'+cur_str, current_val+cur_val, cur_val) // 加法\n                        → Decision: 減法\n                            → Yes → Step 11: dfs(i+1, path+'-'+cur_str, current_val-cur_val, -cur_val) // 減法\n                            → Decision: 乘法\n                                → Yes → Step 12: new_val = current_val - prev_operand + prev_operand*cur_val\n                                → Step 13: dfs(i+1, path+'*'+cur_str, new_val, prev_operand*cur_val) // 乘法\n                → No → Step 14: continue // 非合法子串跳過\n\n→ Step 15: Call dfs(0, \"\", 0, 0) // 開始遞迴\n→ Step 16: Return result // 回傳所有符合的表達式\nEnd // 程式執行結束\n\nBut need to include arrows for nested decisions maybe more lines. Ensure each line has arrow at start? They used \"→ Step 1:\" etc. For decisions, they use \"Decision:\".\n\nWe'll produce each line accordingly.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義函式 addOperators(num, target) → result = [] // 初始化結果列表  \n→ Step 2: 定義遞迴輔助函式 dfs(index, path, current_val, prev_operand) // 進行表達式生成  \n→ Decision: dfs 內部結束條件  \n  → Step 3: 如果 index == len(num) → Decision: current_val 是否等於 target  \n     Yes → Step 4: 若 current_val == target → 將 path 加入 result // 成功表達式加入結果  \n     No → Step 5: 返回 // 表達式不符合目標，結束此分支  \n→ Decision: 遍歷可能的子串  \n  → Step 6: 對 i 從 index 到 len(num)-1 進行迴圈  \n    → Step 7: cur_str = num[index:i+1] // 取出當前子串  \n    → Decision: cur_str 是否合法（非前導零且長度>1 時跳過）  \n     Yes → Step 8: cur_val = int(cur_str) // 將子串轉為整數  \n      Decision: index 是否為 0（首個數字）  \n       Yes → Step 9: dfs(i+1, cur_str, cur_val, cur_val) // 第一次直接使用  \n       No → Decision: 添加 '+'  \n        Yes → Step 10: dfs(i+1, path+'+'+cur_str, current_val+cur_val, cur_val) // 加法  \n        Decision: 添加 '-'  \n         Yes → Step 11: dfs(i+1, path+'-'+cur_str, current_val-cur_val, -cur_val) // 減法  \n        Decision: 添加 '*'  \n         Yes → Step 12: new_val = current_val - prev_operand + prev_operand*cur_val // 調整乘法的累加值  \n         Step 13: dfs(i+1, path+'*'+cur_str, new_val, prev_operand*cur_val) // 乘法  \n        Decision: 非合法子串（前導零）  \n        Yes → Step 14: 省略此子串，繼續下一個 i  \n→ Step 15: 呼叫 dfs(0, \"\", 0, 0) // 從首位開始遞迴  \n→ Step 16: 回傳 result // 所有符合 target 的表達式  \nEnd // 程式執行結束"
    },
    {
      "title": "Super Pow",
      "source_file": "Leetcode/leetcode372.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "a = 2, b = [1,0]",
          "expected_output": "1024",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp6mn6hg56.py\", line 37, in <module>\n    a, b_list = parse_input(input_data)\n                ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp6mn6hg56.py\", line 30, in parse_input\n    b_list = [int(x.strip()) for x in b_str.split(',')]\n              ^^^^^^^^^^^^^^\nValueError: invalid literal for int() with base 10: '[1'"
        },
        {
          "example_index": 2,
          "input": "a = 1, b = [4,3,3,8,5,2]",
          "expected_output": "1",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp5qcp7pgz.py\", line 37, in <module>\n    a, b_list = parse_input(input_data)\n                ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp5qcp7pgz.py\", line 30, in parse_input\n    b_list = [int(x.strip()) for x in b_str.split(',')]\n              ^^^^^^^^^^^^^^\nValueError: invalid literal for int() with base 10: '[4'"
        }
      ],
      "generated_code": "import sys\n\nMOD = 1337\n\ndef super_pow(a: int, b: list[int]) -> int:\n    result = 1\n    for digit in b:\n        # raise current result to the 10th power and multiply by a^digit, all modulo MOD\n        result = (pow(result, 10, MOD) * pow(a, digit, MOD)) % MOD\n    return result\n\ndef parse_input(data: str):\n    \"\"\"\n    Parse input of the form: 'a = 2, b = [3,0,1]'\n    Returns tuple (a, b_list)\n    \"\"\"\n    parts = [p.strip() for p in data.split(',')]\n    # parse a\n    a_part = parts[0]\n    a_val = int(a_part.split('=')[1].strip())\n\n    # parse b\n    b_part = parts[1]\n    b_str = b_part.split('=')[1].strip()\n    if b_str.startswith('[') and b_str.endswith(']'):\n        b_str = b_str[1:-1]\n    if not b_str:\n        b_list = []\n    else:\n        b_list = [int(x.strip()) for x in b_str.split(',')]\n    return a_val, b_list\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read().strip()\n    if not input_data:\n        sys.exit(0)\n    a, b_list = parse_input(input_data)\n    result = super_pow(a, b_list)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for computing a^b mod 1337, with a positive integer a, and b is extremely large positive integer given as an array (likely array of digits). This is classic \"Super Pow\" problem from Leetcode. Steps: Use modular exponentiation with exponent represented as array. Compute result = 1. For each digit in array: result = (pow(result,10,1337) * pow(a, digit, 1337)) % 1337. Need pow(x,y,mod). Use fast exponentiation. We'll write virtual code. Each line: step arrow. Use Decision etc.\n\nWe produce a step-by-step pseudocode.\n\nLet's write:\n\nStart\n→ Step 1: Set MOD = 1337\n→ Step 2: Set result = 1\n→ Step 3: For each digit d in array b // iterate digits\n    → Step 3.1: result = (powMod(result, 10, MOD) * powMod(a, d, MOD)) % MOD\n→ Step 4: Return result\nEnd\n\nWe need to also provide powMod function with fast exponentiation:\n\nDefine Function powMod(x, y, mod):\n    → Step 5: Set res = 1\n    → Step 6: Set base = x % mod\n    → Step 7: While y > 0\n        → Decision: y is odd?\n            Yes → res = (res * base) % mod\n            No →\n        → base = (base * base) % mod\n        → y = y // 2\n    → Return res\n\nWe must also handle large y maybe as int; but it's used for 10 and digit (0-9) which fits.\n\nWe'll format accordingly. Ensure each line with virtual code and explanation comment.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Set MOD = 1337 // 定義模數  \n→ Step 2: Set result = 1 // 初始化結果為 1  \n→ Step 3: For each digit d in array b // 逐位處理大整數  \n  → Step 3.1: result = (powMod(result, 10, MOD) * powMod(a, d, MOD)) % MOD // 把結果提升到 10 次方並乘以 a 的 d 次方  \n→ Step 4: Return result // 返回最終模 1337 的值  \nEnd // 程式執行結束  \n\n// ---------- powMod 函式 ----------  \nFunction powMod(x, y, mod) // 計算 x^y mod mod 的快速冪  \n  → Step 5: Set res = 1 // 結果初始化  \n  → Step 6: Set base = x % mod // 基底取模  \n  → Step 7: While y > 0 // 迴圈直到指數為零  \n     → Decision: y is odd? // 判斷 y 是否為奇數  \n       Yes → res = (res * base) % mod // 若奇數則乘入結果  \n       No → // 直接跳過  \n     → base = (base * base) % mod // 基底平方  \n     → y = y // 2 // 指數除以二  \n  → Return res // 回傳計算結果  \n\nEnd // powMod 函式結束"
    },
    {
      "title": "Count The Repetitions",
      "source_file": "Leetcode/leetcode466.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp5ses2d8y.py\", line 70, in <module>\n    result = sol.getMaxRepetitions(s1, n1, s2, n2)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp5ses2d8y.py\", line 15, in getMaxRepetitions\n    while s1_count < n1:\n          ^^^^^^^^^^^^^\nTypeError: '<' not supported between instances of 'int' and 'str'"
        },
        {
          "example_index": 1,
          "input": "s1 = \"acb\", n1 = 1, s2 = \"acb\", n2 = 1",
          "expected_output": "1",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpzqdk8n9s.py\", line 70, in <module>\n    result = sol.getMaxRepetitions(s1, n1, s2, n2)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpzqdk8n9s.py\", line 15, in getMaxRepetitions\n    while s1_count < n1:\n          ^^^^^^^^^^^^^\nTypeError: '<' not supported between instances of 'int' and 'str'"
        }
      ],
      "generated_code": "import sys\nimport re\nfrom collections import defaultdict\n\nclass Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n        if n1 == 0:\n            return 0\n\n        s1_count = 0       # 已掃描的 s1 次數\n        s2_count = 0       # 已完成的 s2 匹配數量\n        index = 0          # s2 當前索引\n        recall = dict()    # 以 index 為鍵，存 s1_count 與 s2_count\n\n        while s1_count < n1:\n            for ch in s1:\n                if ch == s2[index]:\n                    index += 1\n                    if index == len(s2):\n                        index = 0\n                        s2_count += 1\n            s1_count += 1\n            if index in recall:\n                s1_prev, s2_prev = recall[index]\n                pre_loop = (s1_prev, s2_prev)\n                loop = (s1_count - s1_prev, s2_count - s2_prev)\n                break\n            else:\n                recall[index] = (s1_count, s2_count)\n        else:\n            # 沒有偵測到循環，直接返回\n            return s2_count // n2\n\n        # 先使用完整循環\n        ans = pre_loop[1] + ((n1 - pre_loop[0]) // loop[0]) * loop[1]\n        rest = (n1 - pre_loop[0]) % loop[0]\n\n        # 處理剩餘的 s1 次數\n        index_rest = index\n        s2_rest = 0\n        for _ in range(rest):\n            for ch in s1:\n                if ch == s2[index_rest]:\n                    index_rest += 1\n                    if index_rest == len(s2):\n                        index_rest = 0\n                        s2_rest += 1\n        ans += s2_rest\n        return ans // n2\n\ndef parse_input(data: str):\n    # 匹配雙引號中的字串或數字\n    tokens = re.findall(r'\"([^\"]+)\"|(\\d+)', data)\n    parts = []\n    for t in tokens:\n        if t[0]:\n            parts.append(t[0])\n        else:\n            parts.append(int(t[1]))\n    # 預期順序：s1, n1, s2, n2\n    if len(parts) >= 4:\n        s1, n1, s2, n2 = parts[0], parts[1], parts[2], parts[3]\n        return s1, n1, s2, n2\n    raise ValueError(\"Invalid input format\")\n\nif __name__ == \"__main__\":\n    raw = sys.stdin.read()\n    s1, n1, s2, n2 = parse_input(raw)\n    sol = Solution()\n    result = sol.getMaxRepetitions(s1, n1, s2, n2)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm to compute maximum m such that str2 repeated m times can be obtained as subsequence from str1 repeated n1 times. This is LeetCode problem 466? Actually similar to 466. Known solution: Use greedy + cycle detection. Steps: compute how many times s2 can be matched when scanning s1 once. Use mapping of position in s2 after each iteration. Use cycle detection for repeats of s1 to accelerate.\n\nWe need to produce step-by-step pseudocode lines with explanations. We must use arrow and Decision. Provide sequential lines. Should include loops, conditions.\n\nLet's outline algorithm:\n\nStart\n→ Read s1, n1, s2, n2\n→ Initialize total_s2_matches = 0\n→ Initialize index_s2 = 0 // position in s2\n→ Initialize map: record after each i of s1 (1..n1) the index_s2 and total_s2_matches\n→ For i from 1 to n1:\n    → For each char c in s1:\n        → If c == s2[index_s2]:\n            → index_s2 += 1\n            → If index_s2 == len(s2):\n                → index_s2 = 0\n                → total_s2_matches += 1\n    → If i in map:\n        → Determine cycle: previous_i = map[i]\n        → pre_loop_s2 = total_s2_matches - map[previous_i].matches\n        → pre_loop_count = i - previous_i\n        → remaining = n1 - i\n        → loops = remaining // pre_loop_count\n        → total_s2_matches += loops * pre_loop_s2\n        → i += loops * pre_loop_count\n        → break\n    → else:\n        → map[i] = (index_s2, total_s2_matches)\n→ result = total_s2_matches // n2\n→ Return result\n\nBut need to represent as virtual code step lines. Use Decision for loops.\n\nWe need to output step lines like:\n\nStart // 程式開始執行\n→ Read s1, n1, s2, n2 // 取得輸入\n\nBut we might need to break loops into steps. Provide decision points.\n\nMake sure to use arrow formatting and decisions. Use `→ Decision:` lines.\n\nLet's produce final virtual code lines.\n\nBe careful to include comments with explanation after each line.\n\nAlso include loops: For i in range 1..n1, but we need to produce iterative step lines. For loops, we can use \"→ Decision: i <= n1?\" etc.\n\nLet's produce pseudo:\n\nStart\n→ Initialize variables: len1 = length(s1), len2 = length(s2)\n→ totalMatches = 0\n→ posInS2 = 0\n→ i = 0\n→ recordMap = empty\n\n→ Decision: i < n1? // 是否還有 str1 循環\n    Yes → i = i + 1 // 進入一次 str1\n    → For each character ch in s1:\n        → Decision: ch == s2[posInS2]? // 比對字元\n            Yes → posInS2 = posInS2 + 1\n                → Decision: posInS2 == len2? // 完整匹配一次 s2\n                    Yes → posInS2 = 0\n                    → totalMatches = totalMatches + 1\n                No  → // nothing\n            No  → // nothing\n    → Decision: i in recordMap? // 已經看到相同 i 位置\n        Yes → // 循環偵測\n            → preLoopMatches = totalMatches - recordMap[i].matches\n            → preLoopCount = i - recordMap[i].count\n            → remaining = n1 - i\n            → loops = remaining // preLoopCount\n            → totalMatches = totalMatches + loops * preLoopMatches\n            → i = i + loops * preLoopCount\n            → // 跳出循環以完成剩餘\n        No  → // 記錄此時的狀態\n            → recordMap[i] = (posInS2, totalMatches)\n    → Continue Decision loop\n    No  → // 迴圈結束\n\n→ result = totalMatches // n2\n→ Return result\n\nLet's ensure each line with arrow. Use `→` for steps, `Decision:` for condition. Use spaces.\n\nWe must be careful to use `[空格]` between step and comment. Eg: `→ Start // ...` but earlier example used `Start //` with no arrow. But we can follow example: The first line is `Start // 程式開始執行`. Then use arrow for steps. Use `→` as prefix. Each line has arrow. But the first line didn't have arrow. The example had `Start // 程式開始執行`. Then `→ Step 1: ...`. So use no arrow for start, but arrow for steps. We'll follow that.\n\nAlso include `End // 程式執行結束` at end.\n\nAlso we need to produce virtual code only, no real code.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Initialize len1 = length(s1) // 取得 s1 的長度  \n→ Initialize len2 = length(s2) // 取得 s2 的長度  \n→ totalMatches = 0 // 記錄已完成的 s2 匹配數量  \n→ posInS2 = 0 // s2 的目前索引位置  \n→ i = 0 // str1 的迭代計數  \n→ recordMap = empty // 用於偵測重複狀態的字典  \n\n→ Decision: i < n1? // 是否還有 str1 需要掃描  \n    Yes → i = i + 1 // 進行第 i 次 str1 的掃描  \n    → For each character ch in s1: // 逐字符檢查 s1  \n        → Decision: ch == s2[posInS2]? // 字符是否匹配  \n            Yes → posInS2 = posInS2 + 1 // 匹配成功，移到 s2 下一個位置  \n                → Decision: posInS2 == len2? // 是否完整匹配一個 s2  \n                    Yes → posInS2 = 0 // 重置到 s2 開頭  \n                    → totalMatches = totalMatches + 1 // 記錄一次完整匹配  \n                    No → // 尚未匹配完整 s2，保持 posInS2  \n                No → // 字符不匹配，忽略不做任何變化  \n        No → // 字符不匹配，直接繼續  \n    → Decision: i in recordMap? // 這個 i 的狀態是否已被記錄過？  \n        Yes → // 已偵測到循環，計算重複節點  \n            → preLoopMatches = totalMatches - recordMap[i].matches // 循環前一次的匹配數量差  \n            → preLoopCount = i - recordMap[i].count // 循環長度（str1 次數）  \n            → remaining = n1 - i // 剩餘需要掃描的 str1 次數  \n            → loops = remaining // preLoopCount // 可以一次性重複的完整循環數  \n            → totalMatches = totalMatches + loops * preLoopMatches // 加上所有循環得到的匹配數  \n            → i = i + loops * preLoopCount // 跳過已處理的循環次數  \n        No → // 尚未遇到此 i，將狀態存入 map  \n            → recordMap[i] = (posInS2, totalMatches) // 記錄目前 posInS2 與 totalMatches  \n    → Continue Decision loop // 回到「是否還有 str1 需要掃描」的判斷  \n    No → // 所有 str1 已完成掃描  \n\n→ result = totalMatches // n2 // 計算最大可得到的 [str2, m] 數量  \n→ End // 程式執行結束"
    },
    {
      "title": "Magical String",
      "source_file": "Leetcode/leetcode481.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 6",
          "expected_output": "3",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpema8gicc.py\", line 38, in <module>\n    result = count_ones_in_magical_string(n)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpema8gicc.py\", line 19, in count_ones_in_magical_string\n    run_len = runs[head]\n              ~~~~^^^^^^\nIndexError: list index out of range"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef count_ones_in_magical_string(n: int) -> int:\n    \"\"\"Return number of '1's in the first n digits of the magical string.\"\"\"\n    if n <= 0:\n        return 0\n    if n <= 3:   # the first three digits are 1,2,2\n        return 1  # only the first digit is '1'\n\n    # Initialize the sequence of run-lengths\n    runs = [1, 2, 2]      # these are the counts of consecutive digits\n    head = 2              # index of the next run length to use\n    next_digit = 1        # digit that will be appended next (1 or 2)\n    generated_len = 3     # length of the string built so far\n    ones_count = 1        # we already have one '1' in the first position\n\n    while generated_len < n:\n        run_len = runs[head]\n        # Append run_len copies of next_digit, but stop when we reach n\n        for _ in range(run_len):\n            if generated_len >= n:\n                break\n            generated_len += 1\n            if next_digit == 1:\n                ones_count += 1\n        # Prepare for the next iteration\n        head += 1\n        next_digit ^= 3  # toggle between 1 and 2 (1 xor 3 = 2, 2 xor 3 = 1)\n\n    return ones_count\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    # Extract the first integer found in the input\n    match = re.search(r'\\d+', data)\n    n = int(match.group()) if match else 0\n    result = count_ones_in_magical_string(n)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce pseudo code lines describing algorithm. Problem: Magical string defined recursively. Known problem from LeetCode: Magical String. Approach: generate string until length n, counting 1's. Use two pointers: idx (current position in generated string) and i (current position for reading runs). Use array to store generated string as ints. Algorithm: Initialize s = [1,2,2]; count1 = 1 if n>=1 else 0; idx=2? Actually we maintain pointer to index of number to append next runs.\n\nPseudo: s = [1,2,2]; idx=2; i=0; while len(s)<n: run = s[i]; for j in range(run): if len(s) < n: s.append(3-run? Wait run refers to number of times to append. Actually in magical string, we alternate between 1 and 2. Start with 1. So we need to generate next run of '1' or '2' based on previous runs. Standard algorithm: we maintain pointer idx pointing to next element to determine run length. i pointer scanning s to produce runs.\n\nBut pseudo code lines: Step 1: initialize s array with [1,2,2]; count1 = 1 if n>=1 else 0; idx=2; i=0; While len(s)<n: runLen = s[i]; currentDigit = 3 - s[idx-1]? Wait initial idx =2, s[0]=1; s[1]=2; s[2]=2. At each iteration, we need to append runLen copies of nextDigit. NextDigit = 3 - s[idx-1]? Actually s[idx-1] refers to last element appended? Another simpler: Keep variable 'next' toggling 1 and 2. But algorithm uses idx pointer scanning s for run length. Let's adopt approach from solution: Use array 's' and two indices: idx (next position to read run length), i (next position to write). But easier: we can use pointer 'ptr' for reading run lengths, and variable 'current' for next digit to append. At start, current=1? Wait first digit is 1. Already have [1,2,2]. After reading first run length from s[0]=1, we append '2' once? Actually s = [1,2,2] meaning first run is 1 of '1', second run is 2 of '2', third run is 2 of '1'? Wait original string: 1 22 11 2 1 ... The initial s array representation is counts: 1 2 2 ... meaning we have first run length 1 of '1', second run length 2 of '2', third run length 2 of '1'. So the array s itself holds the counts, not the actual string. So algorithm: start with counts array s = [1,2,2]; pointer i=0; current=1? Actually we use variable 'next' toggling between 1 and 2. Starting next = 1? Let's look at algorithm: At each step, we read count = s[i]; we append count copies of 'next' to the string, and then toggle next. i++.\n\nImplementation: Use array 's' as counts; we also maintain variable 'res' (count of ones) while building string up to length n. Keep variable 'totalLen' (# of actual digits generated). We'll generate counts until totalLen >= n.\n\nPseudo lines accordingly.\n\nLet's craft virtual code step-by-step:\n\nStart\n→ Step 1: 初始化 counts = [1,2,2] // counts of consecutive digits in magical string\n→ Step 2: 初始化 currentDigit = 1 // 下個要寫入的數字\n→ Step 3: 初始化 generatedLen = 3 // 目前已生成的數字個數\n→ Step 4: 初始化 onesCount = 1 // 第1個數字是1\n→ Step 5: 初始化 readIndex = 0 // 讀取 counts 的索引\n→ Decision: 如果 generatedLen < n? // 是否已生成足夠長度\n    Yes → Step 6: 讀取 runLen = counts[readIndex] // 讀取當前連續數字的長度\n    → Step 7: 讀取 nextDigit = 3 - currentDigit // 計算下一個要寫入的數字（1<->2）\n    → Step 8: 針對 k 從 1 到 runLen 進行:\n        → Decision: 如果 generatedLen + k > n? // 超過目標長度？\n            Yes → Step 9: 只寫入至 n 並結束\n            No  → Step 10: generatedLen++ // 寫入一個數字\n            → Decision: 如果 nextDigit == 1? // 這個數字是1\n                Yes → Step 11: onesCount++ // 計數加一\n                No  → Step 12: // 什麼也不做\n        → End Loop\n    → Step 13: currentDigit = nextDigit // 更新為下個要寫入的數字\n    → Step 14: readIndex++ // 進到下一個 runLen\n    → Decision: 回到 Decision: 生成足夠長度? // 重複直到達到 n\n    No → Step 15: End // 生成完成\n→ End // 程式結束\n\nBut we must output each line as \"虛擬碼步驟 // 解釋\". Also need arrows: Use Start, End, Decision:, and arrow \"→\". Must format exactly.\n\nAlso we need to ensure each line has virtual code step, space, comment.\n\nLet's produce step lines accordingly.\n\nImportant: The arrow inside steps? Usually syntax: \"→ Step 1: ...\". We'll use \"→\" as part of step.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: counts = [1,2,2] // 初始化 counts，存儲連續數字的長度\n→ Step 2: currentDigit = 1 // 下個要寫入的數字（1 或 2）\n→ Step 3: generatedLen = 3 // 已生成的數字個數\n→ Step 4: onesCount = 1 // 目前已計算的 '1' 的數量\n→ Step 5: readIndex = 0 // 用於讀取 counts 的指標\n→ Decision: generatedLen < n? // 是否已達到目標長度\n    Yes → Step 6: runLen = counts[readIndex] // 讀取當前連續數字的長度\n    → Step 7: nextDigit = 3 - currentDigit // 取得下一個要寫入的數字（1 <-> 2）\n    → Step 8: for k = 1 to runLen do // 逐個寫入\n        → Decision: generatedLen + k > n? // 超過 n 則停止\n            Yes → Step 9: generatedLen = n // 調整到 n，結束寫入\n            No  → Step 10: generatedLen++ // 寫入一個數字\n            → Decision: nextDigit == 1? // 若寫入的是 1\n                Yes → Step 11: onesCount++ // 計數加一\n                No  → Step 12: // 不做任何事\n        → End Loop\n    → Step 13: currentDigit = nextDigit // 更新為下個寫入數字\n    → Step 14: readIndex++ // 移動到下一個 runLen\n    → Decision: generatedLen < n? // 再次檢查是否需要繼續生成\n        Yes → 回到 Decision: generatedLen < n?\n        No  → Step 15: End // 生成完成\n→ End // 程式結束\n\nBut we need \"Decision:\" lines with Yes → and No →. In pseudo code lines we also need arrow \"→\" before each step. The \"Yes →\" and \"No →\" should be indented? Usually indentation is for clarity. The example uses indentation with spaces after Decision:. We can mimic.\n\nImportant: In \"Yes →\" we also need the line with code. So we should use \"Yes → Step X: ...\". Similarly for No. For nested decisions inside loops, same pattern.\n\nLet's produce final output accordingly, ensure each line ends with comment //.\n\nAlso we must keep lines simple; no actual code. For loops we can describe as \"for k = 1 to runLen do\". In comment we explain.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: counts = [1,2,2] // 初始化 counts，存儲連續數字的長度  \n→ Step 2: currentDigit = 1 // 下個要寫入的數字（1 或 2）  \n→ Step 3: generatedLen = 3 // 已生成的數字個數  \n→ Step 4: onesCount = 1 // 目前已計算的 '1' 的數量  \n→ Step 5: readIndex = 0 // 用於讀取 counts 的指標  \n→ Decision: generatedLen < n? // 是否已達到目標長度  \n    Yes → Step 6: runLen = counts[readIndex] // 讀取當前連續數字的長度  \n    → Step 7: nextDigit = 3 - currentDigit // 取得下一個要寫入的數字（1 ↔ 2）  \n    → Step 8: for k = 1 to runLen do // 逐個寫入  \n        → Decision: generatedLen + k > n? // 超過 n 則停止  \n            Yes → Step 9: generatedLen = n // 調整到 n，結束寫入  \n            No  → Step 10: generatedLen++ // 寫入一個數字  \n            → Decision: nextDigit == 1? // 若寫入的是 1  \n                Yes → Step 11: onesCount++ // 計數加一  \n                No  → Step 12: // 不做任何事  \n        → End Loop  \n    → Step 13: currentDigit = nextDigit // 更新為下個寫入數字  \n    → Step 14: readIndex++ // 移動到下一個 runLen  \n    → Decision: generatedLen < n? // 再次檢查是否需要繼續生成  \n        Yes → 回到 Decision: generatedLen < n?  \n        No  → Step 15: End // 生成完成  \n→ End // 程式結束"
    },
    {
      "title": "Course Schedule II",
      "source_file": "Leetcode/leetcode210.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "numCourses = 2, prerequisites = [[1,0]]",
          "expected_output": "[0,1]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpu15fudhk.py\", line 55, in <module>\n    numCourses, prerequisites = parse_input(raw_input)\n                                ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpu15fudhk.py\", line 48, in parse_input\n    prerequisites = eval(prerequisites_str, {}, {})\n                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [[1,0]\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]",
          "expected_output": "[0,2,1,3]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpp4p1ivu8.py\", line 55, in <module>\n    numCourses, prerequisites = parse_input(raw_input)\n                                ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpp4p1ivu8.py\", line 48, in parse_input\n    prerequisites = eval(prerequisites_str, {}, {})\n                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [[1,0]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport re\nfrom collections import deque\n\nclass Solution:\n    def findOrder(self, numCourses, prerequisites):\n        \"\"\"\n        找出完成所有課程的順序，若無法完成則回傳空清單。\n        \"\"\"\n        # 建立鄰接清單與入度表\n        graph = [[] for _ in range(numCourses)]\n        indegree = [0] * numCourses\n\n        # 填寫圖與入度\n        for dest, src in prerequisites:\n            graph[src].append(dest)\n            indegree[dest] += 1\n\n        # 以入度為 0 的節點作為起點進行拓撲排序\n        queue = deque([i for i in range(numCourses) if indegree[i] == 0])\n        order = []\n\n        while queue:\n            node = queue.popleft()\n            order.append(node)\n            for neighbor in graph[node]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    queue.append(neighbor)\n\n        # 若所有課程都被加入順序，回傳結果；否則說明有環，回傳空清單\n        return order if len(order) == numCourses else []\n\ndef parse_input(data: str):\n    \"\"\"\n    從輸入字串中解析出 numCourses 與 prerequisites。\n    期望輸入類似於:\n        'numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]'\n    \"\"\"\n    # 抓取 numCourses\n    num_match = re.search(r'numCourses\\s*=\\s*(\\d+)', data)\n    numCourses = int(num_match.group(1)) if num_match else 0\n\n    # 抓取 prerequisites 清單\n    pre_match = re.search(r'prerequisites\\s*=\\s*(\\[[^\\]]*\\])', data, re.S)\n    prerequisites_str = pre_match.group(1) if pre_match else '[]'\n    # 轉換為 Python 物件\n    prerequisites = eval(prerequisites_str, {}, {})\n    return numCourses, prerequisites\n\nif __name__ == \"__main__\":\n    # 讀取整個 stdin\n    raw_input = sys.stdin.read().strip()\n    if raw_input:\n        numCourses, prerequisites = parse_input(raw_input)\n        sol = Solution()\n        result = sol.findOrder(numCourses, prerequisites)\n        print(result)",
      "virtual_code": "Thinking...\nWe need to generate virtual code for topological sorting to find course order or return empty array if cycle. Use Kahn's algorithm or DFS. Let's do Kahn's algorithm.\n\nWe'll produce steps: start, build graph adjacency list, compute indegree, queue initial zero indegree, process queue building result, if result length < numCourses return empty, else return result.\n\nWe need to output virtual code lines with explanation after //.\n\nWe must ensure each line is a \"step\" like \"→ Step 1: Build adjacency list\". Use Start, End. Use Decision lines for cycle detection.\n\nLet's produce. We'll produce maybe 15 lines.\n\nAlso note we need to include array prerequisites. We'll assume input: numCourses, prerequisites.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立空的鄰接清單 graph[numCourses] // 為每門課程準備空列表以儲存後續課程\n→ Step 2: 初始化 indegree[0..numCourses-1] 為 0 // 用來紀錄每門課的前置課程數量\n→ Step 3: 對於每個 pair [a, b] in prerequisites\n    → Step 3a: graph[b].append(a) // 將 a 加到 b 的後續課程清單\n    → Step 3b: indegree[a] += 1 // a 的前置課程數量增加 1\n→ Step 4: 建立空隊列 queue // 用於儲存 indegree 為 0 的課程\n→ Step 5: 對於每門課 i 從 0 到 numCourses-1\n    → Decision: 如果 indegree[i] == 0? // 找出沒有前置課程的課\n        Yes → queue.append(i) // 將其加入隊列\n        No  → (不做任何事)\n→ Step 6: 建立空清單 order // 用於紀錄完成課程的順序\n→ Step 7: 當 queue 不為空時\n    → Step 7a: pop node from queue\n    → Step 7b: order.append(node) // 將節點加入結果\n    → Step 7c: 對於每個 neighbour in graph[node]\n        → Step 7c1: indegree[neighbour] -= 1 // 前置課程數量減 1\n        → Step 7c2: Decision: 如果 indegree[neighbour] == 0? // 判斷是否已無剩餘前置課程\n            Yes → queue.append(neighbour) // 加入隊列以待處理\n            No  → (不做任何事)\n→ Step 8: Decision: 如果 order.length == numCourses? // 檢查是否成功安排所有課程\n    Yes → Return order // 返回有效的課程順序\n    No  → Return [] // 代表存在循環，無法完成所有課程\nEnd // 程式執行結束"
    },
    {
      "title": "3Sum Closest",
      "source_file": "Leetcode/leetcode16.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [-1,2,1,-4], target = 1",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpbfet2l2e.py\", line 55, in <module>\n    nums, target = parse_input(raw_input)\n                   ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpbfet2l2e.py\", line 49, in parse_input\n    nums = ast.literal_eval(nums_part)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [-1\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "nums = [0,0,0], target = 1",
          "expected_output": "0",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpc088cnk5.py\", line 55, in <module>\n    nums, target = parse_input(raw_input)\n                   ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpc088cnk5.py\", line 49, in parse_input\n    nums = ast.literal_eval(nums_part)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [0\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def threeSumClosest(self, nums, target):\n        nums.sort()\n        n = len(nums)\n        # 初始化為第一個可能的三元和\n        closest_sum = nums[0] + nums[1] + nums[2]\n        for i in range(n - 2):\n            left, right = i + 1, n - 1\n            while left < right:\n                total = nums[i] + nums[left] + nums[right]\n                # 若此三元和更接近 target，更新答案\n                if abs(total - target) < abs(closest_sum - target):\n                    closest_sum = total\n                # 根據總和是否小於 target 決定移動哪個指標\n                if total < target:\n                    left += 1\n                elif total > target:\n                    right -= 1\n                else:\n                    # 完全相等，直接返回\n                    return total\n        return closest_sum\n\ndef parse_input(data: str):\n    \"\"\"\n    從輸入字串中解析 nums 列表與 target 整數。\n    支援形如 \"nums = [..], target = ..\" 的格式。\n    \"\"\"\n    # 移除可能存在的空行\n    data = data.strip()\n    if not data:\n        return [], 0\n    # 取出 nums 列表字串\n    nums_part = None\n    target_part = None\n    # 嘗試直接找到關鍵字\n    if 'nums' in data:\n        parts = data.split(',', 1)\n        nums_part = parts[0].split('=', 1)[1].strip()\n        target_part = parts[1].split('=', 1)[1].strip()\n    else:\n        # 直接假設第一個元素是 list，第二個是 target\n        parts = data.split(',', 1)\n        nums_part = parts[0].strip()\n        target_part = parts[1].strip()\n    nums = ast.literal_eval(nums_part)\n    target = int(target_part)\n    return nums, target\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    nums, target = parse_input(raw_input)\n    solution = Solution()\n    result = solution.threeSumClosest(nums, target)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for algorithm: three sum closest. Approach: sort array, then for each i, use two pointers j, k to find sum. Keep best diff. Complexity O(n^2). Provide steps: Start, Input, Sort, initialize bestSum, loop i from 0 to n-3, set left, right, while left < right, compute sum, update bestSum if closer, then if sum < target left++ else right--. At the end, return bestSum. Provide End. Use decision steps.\n\nLet's produce lines with virtual code syntax. Use \"Step\", \"Decision\". Provide explanation.\n\nMake sure each line ends with // 解釋/說明. Provide arrow for decision branches: Yes →, No →. Use indentation for nested steps.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得陣列 nums 與目標值 target // 讀取輸入  \n→ Step 2: 將 nums 依升序排序 // 方便雙指標搜尋  \n→ Step 3: 設定 bestSum 為 nums[0] + nums[1] + nums[2] // 初始最佳和  \n→ Decision: 如果 nums 長度小於 3? // 檢查合法性  \n  Yes → Step 4: 回傳 0 // 陣列太短，直接結束  \n  No  → Step 5: 設定 n 為 nums 長度 // 取得陣列長度  \n→ Step 6: 從 i = 0 到 n-3 執行迴圈 // 選擇第一個數字  \n  → Step 7: 設定 left 為 i+1, right 為 n-1 // 初始化兩指標  \n  → Decision: 如果 left < right? // 檢查雙指標是否交叉  \n    Yes → Step 8: 計算 currentSum = nums[i] + nums[left] + nums[right] // 目前三數之和  \n      → Decision: currentSum 與 target 差距是否比 bestDiff 小? // 判斷是否更新最佳答案  \n        Yes → Step 9: bestSum ← currentSum // 更新最佳和  \n        No → Step 10: 何也不變 // 保持舊最佳  \n      → Decision: currentSum == target? // 是否正好相等  \n        Yes → Step 11: 回傳 target // 找到精確答案，結束  \n        No  → Step 12: Decision: currentSum < target? // 決定指標移動方向  \n          Yes → Step 13: left++ // 左指標右移，增大和  \n          No  → Step 14: right-- // 右指標左移，減小和  \n      → Step 15: 重複 Decision: left < right? // 仍在範圍內  \n    → Step 16: 結束內層 while // left >= right 時結束  \n→ Step 17: 回傳 bestSum // 迴圈結束後回傳最接近的和  \nEnd // 程式執行結束"
    },
    {
      "title": "Single Number II",
      "source_file": "Leetcode/leetcode137.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [2,2,3,2]",
          "expected_output": "3",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '3'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: '3'\nRaw Got:      '1'"
        },
        {
          "example_index": 1,
          "input": "nums = [0,1,0,1,0,1,99]",
          "expected_output": "99",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '99'\nGot (Norm):      '98'\n--- (Raw) ---\nRaw Expected: '99'\nRaw Got:      '98'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def singleNumber(self, nums):\n        ones, twos = 0, 0\n        for num in nums:\n            # Update twos with bits that appear twice\n            twos |= ones & num\n            # Toggle bits that appear once\n            ones ^= num\n            # Clear bits that have appeared three times\n            ones &= ~twos\n        return ones\n\ndef main():\n    # Read entire input\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Remove optional leading variable assignment\n    if data.startswith('nums'):\n        # Find the first '=' and take the part after it\n        parts = data.split('=', 1)\n        if len(parts) == 2:\n            data = parts[1].strip()\n\n    # Safely evaluate the list expression\n    try:\n        nums = ast.literal_eval(data)\n    except Exception:\n        print(\"Invalid input format\")\n        return\n\n    result = Solution().singleNumber(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code steps to solve the problem: find element appearing once while others thrice. Use bitwise approach, maintain two bitmasks: ones, twos. Iterate each num: twos |= ones & num; ones ^= num; ones &= ~twos; After loop, ones holds result. Complexity O(n), O(1). Need to produce step by step pseudo-code with arrows and decisions, etc.\n\nWe need to output each line: \"虛擬碼步驟 // 解釋\". So let's produce Start, etc.\n\nLet's plan:\n\nStart\n\n→ Step 1: 初始化變量 ones = 0, twos = 0 // 用於記錄出現一次和兩次的位\n\n→ Step 2: 遍歷 nums 中的每個 num // 主循環\n\n    → Inside loop:\n\n        → Step 2a: twos = twos OR (ones AND num) // 將現在已有一次且在此 num 出現的位加入 twos\n\n        → Step 2b: ones = ones XOR num // 更新一次位\n\n        → Step 2c: ones = ones AND NOT twos // 清除已經出現三次的位\n\nAfter loop:\n\n→ Step 3: 返回 ones // ones 就是只出現一次的數\n\nEnd\n\nBut we need to use arrow structure. We can do:\n\nStart\n\n→ Step 1: ones ← 0, twos ← 0 // 初始化\n\n→ Step 2: for each num in nums do // 迭代\n\n    → Step 2.1: twos ← twos | (ones & num) // add bits that appeared twice\n\n    → Step 2.2: ones ← ones ^ num // toggle bits that appeared once\n\n    → Step 2.3: ones ← ones & (~twos) // clear bits that appeared thrice\n\n→ Step 3: return ones // 结果\n\nEnd\n\nWe should add explanation after each. Use \"→\" arrow. Use \"Decision:\"? Not necessary since no if else.\n\nBut format example uses \"Decision:\" for if. Here we have a for loop, can express as \"→ Step 2: for each num in nums do\". Might be okay.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: ones ← 0, twos ← 0 // 初始化兩個位掩碼，ones 用來記錄出現一次的位，twos 記錄出現兩次的位  \n→ Step 2: for each num in nums do // 依序處理陣列中的每個數字  \n  → Step 2.1: twos ← twos | (ones & num) // 將已經出現一次且此數字也有的位加入 twos，表示這些位已出現兩次  \n  → Step 2.2: ones ← ones ^ num // 將這個數字的位與 ones XOR，切換這些位的狀態（1 變 0 或 0 變 1）  \n  → Step 2.3: ones ← ones & (~twos) // 清除那些已經在 twos 中出現三次的位，確保 ones 只保留「正好一次」的位  \n→ Step 3: return ones // ones 現在只包含那個只出現一次的數字的二進位表示，直接返回  \nEnd // 程式執行結束"
    },
    {
      "title": "Generate Random Point in a Circle",
      "source_file": "Leetcode/leetcode478.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]",
          "expected_output": "[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[-0.02493,-0.38077],[0.82314,0.38945],[0.36572,0.17248]]'\nGot (Norm):      '[null,[0.69521,-0.46111],[-0.43337,-0.07851],[0.35747,-0.17405]]'\n--- (Raw) ---\nRaw Expected: '[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]'\nRaw Got:      '[null, [0.69521, -0.46111], [-0.43337, -0.07851], [0.35747, -0.17405]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport math\n\nclass Solution:\n    def __init__(self, radius, x_center, y_center):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n\n    def randPoint(self):\n        r = self.radius * math.sqrt(random.random())  # 保證均勻分佈\n        theta = random.uniform(0, 2 * math.pi)\n        x = self.x_center + r * math.cos(theta)\n        y = self.y_center + r * math.sin(theta)\n        return [x, y]\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    commands = json.loads(data[0].strip())\n    args_list = json.loads(data[1].strip())\n    results = []\n    obj = None\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"Solution\":\n            obj = Solution(*args)\n            results.append(None)          # 建構子返回 None\n        else:\n            method = getattr(obj, cmd)\n            out = method(*args)\n            if isinstance(out, list):\n                # 四捨五入到 5 位小數，符合範例格式\n                out = [round(v, 5) for v in out]\n            results.append(out)\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code steps for this algorithm: given radius, center, need to generate random point uniformly inside circle. Steps: Start, store radius, center. For randPoint: generate random r between 0 and radius with sqrt to adjust for area; random theta between 0 and 2π; compute x = r*cos(theta)+x_center, y = r*sin(theta)+y_center; return [x,y]. In virtual code format.\n\nWe should produce line by line. Might need to show constructor initialization, method definition, random generation.\n\nAlso need to incorporate decisions maybe? The algorithm doesn't involve decisions, but we can show steps. Use Start, End.\n\nOk produce.\n\nAlso each line: \"虛擬碼步驟 // 解釋\".\n\nLet's write.\n\nUse arrows? The format example uses \"→ Step 1: ...\" So we need to include arrow before step lines after Start? The example shows:\n\nStart // 程式開始執行\n→ Step 1: 輸入使用者數字 // 從使用者處取得一個數值\n\nSo after Start, we put arrow. Also maybe End with arrow? Example uses End // 程式執行結束 (no arrow). So we keep that.\n\nWe will need to define class, constructor, method.\n\nProbably:\n\nStart // 程式開始執行\n→ Step 1: Define class Solution // 定義Solution類別\n→ Step 2: 變數 radius, x_center, y_center // 存儲圓半徑與中心座標\n→ Step 3: 建構子 Solution(radius, x_center, y_center) // 初始化物件\n→ Step 4: 於建構子內設定 this.radius = radius; this.x_center = x_center; this.y_center = y_center; // 儲存參數\n→ Step 5: 定義方法 randPoint() // 產生隨機點\n→ Step 6: 在 randPoint 內 產生隨機角度 theta 在 [0, 2π) // 隨機角度\n→ Step 7: 產生隨機半徑 r，使用 sqrt(Random())*radius // 為了均勻分布\n→ Step 8: 計算 x = r*cos(theta) + x_center // 將極坐標轉回平面並移動中心\n→ Step 9: 計算 y = r*sin(theta) + y_center // 同上\n→ Step 10: 回傳 [x, y] // 返回點座標\nEnd // 程式執行結束\n\nMake sure each line has arrow before step lines. End no arrow. Also we may add comments.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類別 Solution // 建立用於產生隨機點的類別  \n→ Step 2: 內部變數 radius, x_center, y_center // 用來儲存圓半徑與中心座標  \n→ Step 3: 建構子 Solution(radius, x_center, y_center) // 初始化物件時接收參數  \n→ Step 4: 設定 this.radius = radius; this.x_center = x_center; this.y_center = y_center; // 把參數保存到物件屬性  \n→ Step 5: 定義方法 randPoint() // 產生並返回一個隨機點  \n→ Step 6: 生成隨機角度 theta ∈ [0, 2π) // 用 uniform distribution 產生角度  \n→ Step 7: 生成隨機半徑 r = sqrt(Random()) * radius; // sqrt 以保證點均勻分佈在圓內  \n→ Step 8: 計算 x = r * cos(theta) + x_center; // 轉回直角座標並偏移中心  \n→ Step 9: 計算 y = r * sin(theta) + y_center; // 同上  \n→ Step 10: 回傳 [x, y]; // 返回座標組成的陣列  \nEnd // 程式執行結束"
    },
    {
      "title": "Remove Element",
      "source_file": "Leetcode/leetcode27.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "nums = [0,1,2,2,3,0,4,2], val = 2",
          "expected_output": "5, nums = [0,1,4,0,3,_,_,_]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '5,nums=[0,1,4,0,3,_,_,_]'\nGot (Norm):      '5,nums=[0,1,3,0,4,_,_,_]'\n--- (Raw) ---\nRaw Expected: '5, nums = [0,1,4,0,3,_,_,_]'\nRaw Got:      '5, nums = [0, 1, 3, 0, 4, _, _, _]'"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef remove_element(nums, val):\n    \"\"\"\n    移除 nums 中所有等於 val 的元素，並回傳剩餘元素的數量 k。\n    這個函式會就地（in-place）修改 nums，前 k 個位置存放\n    不等於 val 的元素，其餘位置不重要。\n    \"\"\"\n    write = 0  # 寫入指標\n    for read in range(len(nums)):\n        if nums[read] != val:          # Decision: 不是 val\n            nums[write] = nums[read]   # Step 4: 寫入\n            write += 1                 # Step 5: 移動寫入指標\n    return write                      # Step 7: k\n\ndef parse_input(data: str):\n    \"\"\"\n    從輸入字串中解析出 nums (列表) 與 val (單一整數)。\n    允許輸入格式如 \"nums = [1,2,3], val = 2\"。\n    \"\"\"\n    # 取出方括號內的內容作為 nums\n    nums_match = re.search(r'nums\\s*=\\s*\\[([^\\]]*)\\]', data)\n    if nums_match:\n        nums_str = nums_match.group(1).strip()\n        if nums_str:\n            nums = [int(x.strip()) for x in nums_str.split(',') if x.strip()]\n        else:\n            nums = []\n    else:\n        nums = []\n\n    # 取出 val\n    val_match = re.search(r'val\\s*=\\s*(-?\\d+)', data)\n    if val_match:\n        val = int(val_match.group(1))\n    else:\n        val = 0\n\n    return nums, val\n\ndef main():\n    # 讀取整個 stdin\n    raw_input = sys.stdin.read()\n    nums, val = parse_input(raw_input)\n\n    k = remove_element(nums, val)\n\n    # 建立輸出字串，前 k 個元素為實際值，其餘為 \"_\"\n    formatted = [\n        str(nums[i]) if i < k else '_' for i in range(len(nums))\n    ]\n    print(f\"{k}, nums = [{', '.join(formatted)}]\")\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code for removing elements in-place. Use two-pointer approach. We'll produce steps like:\n\nStart\n→ Step 1: Initialize write index = 0\n→ For each element in nums: iterate with read index\n    → Decision: if nums[read] != val?\n        Yes → Step: nums[write] = nums[read]; write++\n        No → skip\n→ End -> return write\n\nNeed to include comments. Use \"Step 1:\" etc. Ensure each line ends with // 解釋.\n\nWe must follow the arrow style: → Step 1: ... // explanation. Use Decision: lines.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: writeIndex ← 0 // 初始化寫入指標，指向要放入非 val 元素的位置\n→ Step 2: 讀取陣列長度 n ← length(nums) // 取得 nums 的長度\n→ Step 3: readIndex ← 0 // 初始化讀取指標，從陣列起始位置開始掃描\n→ Decision: readIndex < n? // 判斷是否已掃描完所有元素\n    Yes → Decision: nums[readIndex] ≠ val? // 檢查目前元素是否為需要保留的值\n        Yes → Step 4: nums[writeIndex] ← nums[readIndex] // 把非 val 的元素寫入 writeIndex 所在位置\n        Yes → Step 5: writeIndex ← writeIndex + 1 // 更新寫入指標到下一個位置\n        No  → // 若元素為 val，直接跳過，不做寫入\n        No  → // 讀取指標自動遞增，準備處理下一個元素\n    No  → // 已經完成所有元素的掃描\n→ Step 6: readIndex ← readIndex + 1 // 移動讀取指標到下一個位置\n→ Decision: readIndex < n? // 重新檢查是否還有未掃描的元素\n    Yes → 回到 Decision: nums[readIndex] ≠ val? // 進入循環繼續處理\n    No  → // 走出迴圈，所有元素已處理完畢\n→ Step 7: Return writeIndex // writeIndex 即為 k，代表保留元素的個數\nEnd // 程式執行結束"
    },
    {
      "title": "Count Numbers with Unique Digits",
      "source_file": "Leetcode/leetcode357.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 2",
          "expected_output": "91",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '91'\nGot (Norm):      '92'\n--- (Raw) ---\nRaw Expected: '91'\nRaw Got:      '92'"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef count_unique_digits(n: int) -> int:\n    \"\"\"\n    Count how many integers x satisfy 0 <= x < 10**n\n    and all digits of x are unique.\n    \"\"\"\n    if n == 0:\n        return 1  # only the number 0\n\n    # For n > 10, unique digits are impossible beyond 10 digits\n    n = min(n, 10)\n\n    # Count of numbers with exactly i digits (i >= 1) and unique digits\n    # 1-digit: 10 options (0-9)\n    # 2-digit: 10 * 9\n    # 3-digit: 10 * 9 * 8, etc.\n    total = 1  # count for 0\n    current = 9  # number of options for the first digit (1-9)\n    for i in range(1, n + 1):\n        if i == 1:\n            total += 10  # 0-9\n        else:\n            current *= (10 - i + 1)\n            total += current\n    return total\n\ndef main() -> None:\n    # Read entire input, extract first integer encountered\n    data = sys.stdin.read()\n    numbers = re.findall(r'\\d+', data)\n    if not numbers:\n        return\n    n = int(numbers[0])\n    result = count_unique_digits(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need produce virtual code line by line with explanations. Use Start, Decision, etc. Outline algorithm: count unique-digit numbers less than 10^n. Known result: dp. But we just need virtual code steps. Provide generic steps: start, input n, if n==0 return 1, else compute count using multiplication. We'll describe decisions: if n>10 then break. Provide steps: Initialize result=1, base=1, loop i from 1 to n: multiply result by (10 - i +1?) Actually count: count=1 for zero. For numbers with 1 digit: 10 options. For 2 digits: 10*9, etc. So result accumulate. We produce steps: for i=1 to n: result += base * (10 - i +1? Wait: base initially 1? Let's produce more straightforward: set result=1; set current=9; set base=1; For i from 1 to n: base = base * (10 - (i-1)); result += base; Also limit if i>10 then break because unique digits impossible beyond 10 digits. So include decision: if i > 10 then break.\n\nWe'll produce steps accordingly. Provide explanation. Ensure to include \"Decision\" lines for condition checks.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入整數 n // 取得要計算的位數上限  \n→ Decision: 如果 n = 0? // 特殊情況，僅包含數字 0  \n    Yes → Step 2: 回傳 1 // 只有一個符合條件的數字（0）  \n    No  → Step 3: 初始化 result = 1 // 先算出只包含 0 的情況  \n→ Step 4: 初始化 base = 9 // 代表一位數可選項數（1-9）  \n→ Step 5: 初始化 count = 0 // 用於累計唯一數字的個數  \n→ Step 6: 初始化 i = 1 // 目前處理的位數  \n→ Decision: i <= n? // 是否還有位數要處理  \n    Yes → Decision: i > 10? // 超過 10 位則不可能再有唯一數字  \n        Yes → End // 結束計算，因為後面全都重複  \n        No  → Step 7: result = result + base // 把目前位數的可能數加進總數  \n→ Decision: i = 1? // 第一位數已算，之後要更新 base  \n    Yes → Step 8: base = base * (10 - i) // 計算下一位數可選項數  \n    No  → Step 9: base = base * (10 - i) // 同樣更新，因為每新增一位減少 1 個可用數字  \n→ Step 10: i = i + 1 // 移至下一位  \n→ Decision: i <= n? // 回到判斷是否還有位數  \n    Yes → (loop back to Step 6)  \n    No  → Step 11: 回傳 result // 所有位數都處理完畢，輸出總數  \nEnd // 程式執行結束"
    },
    {
      "title": "Shuffle an Array",
      "source_file": "Leetcode/leetcode384.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"], [[[1, 2, 3]], [], [], []]",
          "expected_output": "[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[3,1,2],[1,2,3],[1,3,2]]'\nGot (Norm):      '[null,[1,3,2],[1,2,3],[1,2,3]]'\n--- (Raw) ---\nRaw Expected: '[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]'\nRaw Got:      '[null, [1, 3, 2], [1, 2, 3], [1, 2, 3]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nimport random\nfrom typing import List, Optional\n\nclass Solution:\n    def __init__(self, nums: List[int]):\n        # 存儲原始陣列，使用 list 以確保複製\n        self._original = list(nums)\n\n    def reset(self) -> List[int]:\n        # 回傳原始陣列（直接回傳複製避免外部修改）\n        return list(self._original)\n\n    def shuffle(self) -> List[int]:\n        # Fisher‑Yates 洗牌\n        shuffled = list(self._original)\n        n = len(shuffled)\n        for i in range(n):\n            j = random.randint(i, n - 1)\n            shuffled[i], shuffled[j] = shuffled[j], shuffled[i]\n        return shuffled\n\ndef main() -> None:\n    # 讀取整個輸入，並包裝成元組以方便解析\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n    # 將輸入包裝成元組形式，之後使用 literal_eval 解析\n    raw = f\"({raw})\"\n    try:\n        commands, arguments = ast.literal_eval(raw)\n    except Exception as e:\n        raise ValueError(f\"輸入格式錯誤: {e}\")\n\n    obj: Optional[Solution] = None\n    outputs = []\n\n    for cmd, args in zip(commands, arguments):\n        if cmd == \"Solution\":\n            # args 是一個列表，第一個元素為實際參數\n            obj = Solution(args[0])\n            outputs.append(None)          # 代表 null\n        elif cmd == \"reset\":\n            outputs.append(obj.reset())\n        elif cmd == \"shuffle\":\n            outputs.append(obj.shuffle())\n        else:\n            # 若出現未知指令，回傳 None\n            outputs.append(None)\n\n    # 將結果轉成 JSON 字串，Python 的 None 將被序列化為 null\n    print(json.dumps(outputs))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code, line by line with explanations. No actual code, just virtual steps. Should reflect algorithm: constructor store original copy; reset returns original; shuffle uses Fisher-Yates.\n\nLet's produce steps: Start, Step 1: initialize array copy, Step 2: store original; etc.\n\nAlso include Decision steps? Not necessary.\n\nWe can produce pseudo code with arrows.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Input array nums // 接收要被隨機打亂的整數陣列  \n→ Step 2: original ← Copy(nums) // 複製一份原始陣列以備重設  \n→ Step 3: current ← Copy(nums) // 目前的工作陣列，初始為原始陣列  \n\n→ Class Definition: Solution // 定義 Solution 類別  \n  → Constructor(nums) // 建構子  \n    original ← Copy(nums) // 儲存原始陣列  \n    current ← Copy(nums) // 初始化工作陣列  \n\n→ Method reset() // 重設陣列  \n  → current ← Copy(original) // 重新複製原始陣列回工作陣列  \n  → Return current // 回傳重設後的陣列  \n\n→ Method shuffle() // 隨機打亂陣列  \n  → n ← Length(current) // 取得陣列長度  \n  → For i from n-1 down to 1 // 逐個元素進行交換  \n     → j ← RandomInteger(0, i) // 隨機選取 0~i 之間的索引  \n     → Swap current[i] with current[j] // 交換兩個位置的值  \n  → Return current // 回傳打亂後的陣列  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Subsets",
      "source_file": "Leetcode/leetcode78.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nGot (Norm):      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nRaw Got:      '[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\ndef subsets(nums):\n    \"\"\"Return all subsets of the list nums.\"\"\"\n    res = []\n\n    def backtrack(start, path):\n        res.append(path[:])            # add current subset\n        for i in range(start, len(nums)):\n            path.append(nums[i])       # include nums[i]\n            backtrack(i + 1, path)     # recurse with next start\n            path.pop()                 # backtrack, remove nums[i]\n\n    backtrack(0, [])\n    return res\n\nif __name__ == \"__main__\":\n    # Read entire input from stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # Parse the input expression after '=' if present\n    if '=' in data:\n        _, expr = data.split('=', 1)\n    else:\n        expr = data\n    expr = expr.strip()\n\n    # Safely evaluate the list expression\n    nums = ast.literal_eval(expr)\n\n    # Compute and output all subsets\n    result = subsets(nums)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to generate virtual code for generating power set of unique integer array. Use recursion or iterative. Steps: Start, Step 1: Read array, Step 2: Sort? not needed unique. Step 3: Backtracking: function backtrack(start, path). Step 4: add path to result. Step 5: loop i from start to end, include element, backtrack(i+1). After loop, return result. End. Provide virtual code with arrows and decision.\n\nNeed to adhere to format: each line: \"虛擬碼步驟 // 解釋\". Use \"Start\" \"End\". Use \"Decision:\" where needed. We'll produce straightforward algorithm.\n\nLet's produce:\n\nStart // 程式開始\n→ Step 1: nums ← InputArray // 取得唯一元素的整數陣列\n→ Step 2: result ← [] // 初始化結果集合\n→ Decision: 是否已定義 backtrack? // 判斷是否已宣告遞迴函式\n    Yes → (skip) // 已宣告\n    No  → Step 3: 定義 backtrack(start, path) // 定義遞迴函式\n→ Step 4: Call backtrack(0, []) // 開始遞迴\n→ Step 5: Return result // 傳回所有子集\nEnd // 程式執行結束\n\nBut need to include inside backtrack: add path, loop.\n\nWe can detail inside backtrack as sub-steps with indentation? The format might use arrow for substeps but we can include in virtual code lines with indentation using spaces? The sample uses indentation for decisions, but it's fine.\n\nWe should list each line. For backtrack, we can write:\n\n→ Step 3: 定義 backtrack(start, path) // 定義遞迴函式\n→   Step 3.1: result.append(path.copy()) // 將目前子集加入結果\n→   Step 3.2: for i in range(start, len(nums)) // 循環遍歷剩餘元素\n→       Step 3.2.1: path.append(nums[i]) // 加入元素\n→       Step 3.2.2: backtrack(i+1, path) // 進一步遞迴\n→       Step 3.2.3: path.pop() // 回溯移除元素\n\nWe need to keep format with spaces. The sample uses indentation. We'll produce each line as separate with arrow. Should we use \"→\" for each sub-step, or maintain \"→\" at same level? Let's produce each line as separate with \"→\" prefix, but sub-steps can have indentation before arrow.\n\nLet's create:\n\nStart // 程式開始執行\n→ Step 1: nums ← InputArray // 取得唯一元素的整數陣列\n→ Step 2: result ← [] // 初始化結果集合\n→ Decision: 已宣告 backtrack? // 判斷是否已宣告遞迴函式\n    Yes → (已宣告) // 已有定義\n    No  → Step 3: 定義 backtrack(start, path) // 定義遞迴函式\n→   Step 3.1: result.append(path.copy()) // 將目前子集加入結果\n→   Step 3.2: for i in range(start, len(nums)) // 循環遍歷剩餘元素\n        → Step 3.2.1: path.append(nums[i]) // 加入元素\n        → Step 3.2.2: backtrack(i+1, path) // 進一步遞迴\n        → Step 3.2.3: path.pop() // 回溯移除元素\n→ Step 4: backtrack(0, []) // 開始遞迴\n→ Step 5: Return result // 傳回所有子集\nEnd // 程式執行結束\n\nBut we might need to indent arrow lines properly. The sample uses indentation but we can just keep single line for each step. Let's produce each line with \"→\" preceded by spaces for sub-steps. However final output must be clear.\n\nWe should also ensure that each line contains \"虛擬碼步驟\" (the step) followed by space then comment. So we need to ensure \"→\" inside step. Eg:\n\n→ Step 3: 定義 backtrack(start, path) // 定義遞迴函式\n\nBut for sub-step we might use \"    →\" (4 spaces then arrow) to show nested. This is fine.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: nums ← InputArray // 取得唯一元素的整數陣列  \n→ Step 2: result ← [] // 初始化結果集合  \n→ Decision: 已宣告 backtrack? // 判斷是否已宣告遞迴函式  \n Yes → (已宣告) // 已有定義  \n No  → Step 3: 定義 backtrack(start, path) // 定義遞迴函式  \n  → Step 3.1: result.append(path.copy()) // 將目前子集加入結果  \n  → Step 3.2: for i in range(start, len(nums)) // 循環遍歷剩餘元素  \n    → Step 3.2.1: path.append(nums[i]) // 加入元素  \n    → Step 3.2.2: backtrack(i+1, path) // 進一步遞迴  \n    → Step 3.2.3: path.pop() // 回溯移除元素  \n→ Step 4: backtrack(0, []) // 開始遞迴  \n→ Step 5: Return result // 傳回所有子集  \nEnd // 程式執行結束"
    },
    {
      "title": "Reconstruct Original Digits from English",
      "source_file": "Leetcode/leetcode423.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"owoztneoer\"",
          "expected_output": "\"012\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '012'\nGot (Norm):      '7'\n--- (Raw) ---\nRaw Expected: '\"012\"'\nRaw Got:      '7'"
        },
        {
          "example_index": 1,
          "input": "s = \"fviefuro\"",
          "expected_output": "\"45\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '45'\nGot (Norm):      '7'\n--- (Raw) ---\nRaw Expected: '\"45\"'\nRaw Got:      '7'"
        }
      ],
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\nclass Solution:\n    def originalDigits(self, s: str) -> str:\n        # 1. 計算每個字母的出現次數\n        count = Counter(s)\n\n        # 2. 用唯一字母確定各數字的個數\n        out = {}\n        out['0'] = count['z']          # zero\n        out['2'] = count['w']          # two\n        out['4'] = count['u']          # four\n        out['6'] = count['x']          # six\n        out['8'] = count['g']          # eight\n\n        # 3. 剩下的數字需扣除已確定的字母\n        out['3'] = count['h'] - out['8']          # three\n        out['5'] = count['f'] - out['4']          # five\n        out['7'] = count['s'] - out['6']          # seven\n        out['1'] = count['o'] - out['0'] - out['2'] - out['4']  # one\n        out['9'] = count['i'] - out['5'] - out['6'] - out['8']  # nine\n\n        # 4. 組合升序的結果字串\n        result = ''.join(k * out[k] for k in sorted(out.keys()))\n        return result\n\ndef main() -> None:\n    # 讀取輸入，支持「s = \"...\"」或純字串形式\n    raw_input = sys.stdin.read()\n    # 找第一個連續字母序列（忽略大小寫）\n    match = re.search(r'[A-Za-z]+', raw_input)\n    s = match.group(0).lower() if match else \"\"\n\n    solution = Solution()\n    print(solution.originalDigits(s))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps for the problem: Given string s containing letters that represent digits out of order (English words for digits 0-9). Need to reconstruct digits in ascending order. Classic problem \"Reconstruct Original Digits from English\". Approach: Count letters, identify unique letters for digits: 'z' for zero, 'w' for two, 'u' for four, 'x' for six, 'g' for eight, then others: 'o' for one (after zero, two, four), 'h' for three (after eight), 'f' for five (after four), 's' for seven (after six), 'i' for nine (after five, six, eight). Build counts.\n\nWe produce virtual code step by step with decisions.\n\nWe'll produce lines:\n\nStart // start program\n→ Step 1: Initialize letter count map from s // count occurrences\n→ Step 2: Initialize result array of digits // to store counts\n→ Decision: While any unique letters remain? // but we can use for each unique letter sequentially\nSimplify: For each digit in order of unique detection: zero, two, four, six, eight, one, three, five, seven, nine.\n\nWe'll output steps.\n\nWe need each line: virtual code + // explanation.\n\nLet's produce pseudocode lines:\n\nStart // 程式開始\n→ Step 1: Build frequency dictionary letterCount for each char in s // count letters\n→ Step 2: Create array digitCount[10] initialized to 0 // store how many of each digit\n→ Step 3: For digit 0 with unique letter 'z': digitCount[0] = letterCount['z'] // number of zeros\n→ Step 4: Subtract letters of \"zero\" times digitCount[0] from letterCount // remove used letters\nSimilarly for others.\n\nWe'll produce decisions: but not necessary? We can just loop.\n\nBut per spec, we need Decision: arrow structure. Maybe incorporate some decisions for checking >0.\n\nWe can produce a Decision block for each unique letter: if letterCount[unique] > 0 then set digitCount. But easier: set directly.\n\nLet's produce:\n\nDecision: letterCount['z'] > 0? // check if zero exists\n    Yes → Step 3: digitCount[0] = letterCount['z'] // set zero count\n    No → // skip\nThen subtraction.\n\nWe'll include subtraction step as a loop.\n\nBut we need a structure.\n\nSimplify: We'll just do steps.\n\nOk produce list.\n\nMake sure each line includes arrow and explanation.\n\nLet's generate.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立字母頻率表 letterCount，統計字串 s 中每個字母出現次數 // 用於後續判斷各數字  \n→ Step 2: 初始化數字頻率陣列 digitCount[10] 為 0 // 用來儲存 0-9 的個數  \n→ Decision: letterCount['z'] > 0? // 'z' 唯一出現在 \"zero\"  \n    Yes → Step 3: digitCount[0] = letterCount['z'] // 記錄 0 的個數  \n    No  → // 若沒有 'z'，則 0 為 0  \n→ Step 4: 將 \"zero\" 的字母對應個數乘以 digitCount[0] 從 letterCount 中扣除 // 移除已計算的字母  \n→ Decision: letterCount['w'] > 0? // 'w' 唯一出現在 \"two\"  \n    Yes → Step 5: digitCount[2] = letterCount['w'] // 記錄 2 的個數  \n    No  →  \n→ Step 6: 從 letterCount 扣除 \"two\" 字母對應個數 * digitCount[2]  \n→ Decision: letterCount['u'] > 0? // 'u' 唯一出現在 \"four\"  \n    Yes → Step 7: digitCount[4] = letterCount['u'] // 記錄 4 的個數  \n    No  →  \n→ Step 8: 從 letterCount 扣除 \"four\" 字母對應個數 * digitCount[4]  \n→ Decision: letterCount['x'] > 0? // 'x' 唯一出現在 \"six\"  \n    Yes → Step 9: digitCount[6] = letterCount['x'] // 記錄 6 的個數  \n    No  →  \n→ Step 10: 從 letterCount 扣除 \"six\" 字母對應個數 * digitCount[6]  \n→ Decision: letterCount['g'] > 0? // 'g' 唯一出現在 \"eight\"  \n    Yes → Step 11: digitCount[8] = letterCount['g'] // 記錄 8 的個數  \n    No  →  \n→ Step 12: 從 letterCount 扣除 \"eight\" 字母對應個數 * digitCount[8]  \n→ Decision: letterCount['o'] > 0? // 'o' 出現在 \"one\"、\"zero\"、\"two\"、\"four\"；已扣除前三個後剩餘即為 1  \n    Yes → Step 13: digitCount[1] = letterCount['o'] // 記錄 1 的個數  \n    No  →  \n→ Step 14: 從 letterCount 扣除 \"one\" 字母對應個數 * digitCount[1]  \n→ Decision: letterCount['h'] > 0? // 'h' 出現在 \"three\"、\"eight\"；已扣除八後剩餘即為 3  \n    Yes → Step 15: digitCount[3] = letterCount['h'] // 記錄 3 的個數  \n    No  →  \n→ Step 16: 從 letterCount 扣除 \"three\" 字母對應個數 * digitCount[3]  \n→ Decision: letterCount['f'] > 0? // 'f' 出現在 \"five\"、\"four\"；已扣除四後剩餘即為 5  \n    Yes → Step 17: digitCount[5] = letterCount['f'] // 記錄 5 的個數  \n    No  →  \n→ Step 18: 從 letterCount 扣除 \"five\" 字母對應個數 * digitCount[5]  \n→ Decision: letterCount['s'] > 0? // 's' 出現在 \"seven\"、\"six\"；已扣除六後剩餘即為 7  \n    Yes → Step 19: digitCount[7] = letterCount['s'] // 記錄 7 的個數  \n    No  →  \n→ Step 20: 從 letterCount 扣除 \"seven\" 字母對應個數 * digitCount[7]  \n→ Decision: letterCount['i'] > 0? // 'i' 出現在 \"nine\"、\"five\"、\"six\"、\"eight\"；已扣除後剩餘即為 9  \n    Yes → Step 21: digitCount[9] = letterCount['i'] // 記錄 9 的個數  \n    No  →  \n→ Step 22: 從 letterCount 扣除 \"nine\" 字母對應個數 * digitCount[9]  \n→ Step 23: 建立結果字串 result  \n→ Step 24: 從 0 到 9 逐位讀取 digitCount[i]，將字母 'i' 重複 digitCount[i] 次加入 result // 形成升序數字字串  \n→ End // 程式執行結束，返回結果字串\n\n【說明】  \n- 第 1 步統計字母頻率，用於判斷每個數字的個數。  \n- 第 2 步準備數字頻率陣列。  \n- 接下來的 Decision/Step 對應每個唯一字母或可辨識字母，依序確定每個數字的個數並從字母表中扣除已使用的字母。  \n- 最後第 23-24 步根據得到的數字頻率組成升序的數字字串並返回。"
    },
    {
      "title": "Maximum Matching of Players With Trainers",
      "source_file": "Leetcode/leetcode2410.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "players = [4,7,9], trainers = [8,2,5,8]",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '1'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def matchPlayersAndTrainers(self, players, trainers):\n        # 先排序，讓兩個指標能以最優方式進行比對\n        players.sort()\n        trainers.sort()\n        i = j = matches = 0\n        # i 指向玩家，j 指向教練\n        while i < len(players) and j < len(trainers):\n            if players[i] <= trainers[j]:\n                matches += 1  # 成功匹配\n                i += 1        # 下一個玩家\n            j += 1            # 無論匹配與否都往下一個教練\n        return matches\n\ndef parse_list_from_line(line: str):\n    \"\"\"從一行文字中抽取所有整數並回傳列表。\"\"\"\n    return list(map(int, re.findall(r'-?\\d+', line)))\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    lines = data.splitlines()\n    if len(lines) >= 2:\n        # 兩行分別為 players 與 trainers\n        players = parse_list_from_line(lines[0])\n        trainers = parse_list_from_line(lines[1])\n    else:\n        # 只有一行輸入，預期格式類似於\n        # players = [4,7,9], trainers = [8,2,5,8]\n        # 先把兩個列表分開再解析\n        parts = data.split(',')\n        # 取第一個包含 '[' 的部分作為 players，第二個作為 trainers\n        players_part = next((p for p in parts if '[' in p), '')\n        trainers_part = next((t for t in parts if '[' in t), '')\n        players = parse_list_from_line(players_part)\n        trainers = parse_list_from_line(trainers_part)\n\n    solution = Solution()\n    result = solution.matchPlayersAndTrainers(players, trainers)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode with step-by-step, explain each line. The task: match players to trainers maximizing number of matchings, each player <= trainer. Classic bipartite matching, but greedy works if sorted: sort both arrays ascending; then two pointers. For each trainer, assign smallest remaining player that <= trainer. Count matches. This is similar to \"assign tasks to workers\" greedy. So produce pseudocode lines accordingly. Ensure to use Start, End, Decision, Yes → etc. Provide comments after space.\n\nWe need to write in Chinese (繁體中文). Use \"虛擬碼步驟\" style. Provide each line as \"虛擬碼 步驟 // 解釋\". Use arrow etc. Use \"Decision:\" with Yes→ and No→. Provide a sorted array steps. We need to maintain loops: while playerIndex < n and trainerIndex < m: etc.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: Sort array players ascending // 把玩家能力由小到大排序\n→ Step 2: Sort array trainers ascending // 把教練訓練容量由小到大排序\n→ Step 3: Initialize playerIndex = 0, trainerIndex = 0, matchCount = 0 // 設定索引與計數\n→ Decision: 是否還有未處理的玩家與教練？ // 檢查兩個索引是否在範圍內\n    Yes → Decision: players[playerIndex] <= trainers[trainerIndex] ? // 檢查玩家是否可匹配當前教練\n        Yes → Step 4: matchCount += 1, playerIndex += 1, trainerIndex += 1 // 成功匹配，移動兩指標\n        No  → Step 5: trainerIndex += 1 // 玩家太強，嘗試更高容量的教練\n    No  → End // 所有匹配完成\nEnd // 輸出結果或返回 matchCount\n\nBut need to show output maybe Step 6: Return matchCount // 返回最大匹配數量\n\nAlso include End after return? Usually End after Return.\n\nAdd Step 6 before End: Step 6: Output matchCount // 結果\n\nBetter: Step 6: Return matchCount // 回傳最大匹配數量\n\nThen End after return? Typically End after the whole algorithm.\n\nThus produce each line accordingly. Ensure each line includes arrow and comment after space. Use \"→\" for steps, \"Decision:\" for decision.\n\nWe might need to include the arrow for the initial lines. Use \"→ Step\" as prefix.\n\nWe also need to ensure to use \"Yes →\" and \"No →\" properly indented lines maybe with tabs or spaces? Use indentation for readability but not mandatory. Use consistent.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort players ascending // 把玩家能力由小到大排序  \n→ Step 2: Sort trainers ascending // 把教練訓練容量由小到大排序  \n→ Step 3: Set playerIndex = 0, trainerIndex = 0, matchCount = 0 // 初始化指標與計數  \n→ Decision: 是否還有未處理的玩家與教練？ // 檢查兩個索引是否在範圍內  \n Yes → Decision: players[playerIndex] <= trainers[trainerIndex] ? // 判斷當前玩家是否能匹配當前教練  \n  Yes → Step 4: matchCount += 1, playerIndex += 1, trainerIndex += 1 // 成功匹配，移動兩指標  \n  No  → Step 5: trainerIndex += 1 // 玩家能力太大，嘗試下一個更高容量的教練  \n No  → Step 6: Return matchCount // 所有匹配完成，返回最大匹配數量  \nEnd // 程式執行結束"
    },
    {
      "title": "Different Ways to Add Parentheses",
      "source_file": "Leetcode/leetcode241.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "expression = \"2-1-1\"",
          "expected_output": "[0,2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[0,2]'\nGot (Norm):      '[2,0]'\n--- (Raw) ---\nRaw Expected: '[0,2]'\nRaw Got:      '[2, 0]'"
        },
        {
          "example_index": 1,
          "input": "expression = \"2*3-4*5\"",
          "expected_output": "[-34,-14,-10,-10,10]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[-34,-14,-10,-10,10]'\nGot (Norm):      '[-34,-10,-14,-10,10]'\n--- (Raw) ---\nRaw Expected: '[-34,-14,-10,-10,10]'\nRaw Got:      '[-34, -10, -14, -10, 10]'"
        }
      ],
      "generated_code": "import sys\nfrom typing import List, Dict\n\nclass Solution:\n    def diffWaysToCompute(self, expression: str) -> List[int]:\n        \"\"\"\n        回傳給定算式所有不同括號組合下的結果。\n        \"\"\"\n        memo: Dict[str, List[int]] = {}\n\n        def ways(expr: str) -> List[int]:\n            if expr in memo:\n                return memo[expr]\n\n            results: List[int] = []\n            for i, ch in enumerate(expr):\n                if ch in \"+-*\":\n                    left = ways(expr[:i])\n                    right = ways(expr[i+1:])\n                    for l in left:\n                        for r in right:\n                            if ch == '+':\n                                results.append(l + r)\n                            elif ch == '-':\n                                results.append(l - r)\n                            else:  # ch == '*'\n                                results.append(l * r)\n\n            if not results:\n                # 表達式只是一個數字\n                results.append(int(expr))\n\n            memo[expr] = results\n            return results\n\n        return ways(expression)\n\ndef parse_expression(raw: str) -> str:\n    \"\"\"\n    從輸入字串中抽取實際的算式。\n    支援：\n      1. 直接輸入算式，例如 \"2-1-1\"\n      2. 帶有引號的格式，例如 expression = \"2-1-1\"\n    \"\"\"\n    raw = raw.strip()\n    # 尋找雙引號內的內容\n    first = raw.find('\"')\n    if first != -1:\n        second = raw.find('\"', first + 1)\n        if second != -1:\n            return raw[first + 1:second]\n    # 或單引號\n    first = raw.find(\"'\")\n    if first != -1:\n        second = raw.find(\"'\", first + 1)\n        if second != -1:\n            return raw[first + 1:second]\n    # 直接回傳整個字串\n    return raw\n\ndef main() -> None:\n    raw_input = sys.stdin.read()\n    expression = parse_expression(raw_input)\n    solution = Solution()\n    results = solution.diffWaysToCompute(expression)\n    print(results)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for the problem: given string expression of numbers and operators, compute all possible results by different grouping. It's like \"Different Ways to Add Parentheses\" LeetCode problem.\n\nWe need to output virtual code lines, with explanations. The code will likely parse the expression into numbers and operators, use recursion or DP to compute results for subexpressions. We'll include memoization to avoid recomputation. Need to include steps like: Start, parse expression, define recursive function compute(l, r) returns list of results for substring from l to r, using memoization. Base case: if substring contains only number, return [number]. Else for each operator index, compute left results, right results, combine by applying operator, extend results. Return results. At the end call compute(0, len(tokens)-1) and return list.\n\nThe output must be virtual code lines with arrow etc. Format: each line: `虛擬碼步驟` + ` // 解釋/說明`. Use Start, End, Decision, Yes, No etc. Provide all steps line by line. So maybe include steps for parsing, recursion, memoization, etc. Use arrow: `→`. Let's produce.\n\nBe careful: no actual code. It's pseudo code steps. We can include steps like \"Parse input string into list tokens\" \"Define function compute(l, r)\" \"If result in memo, return memo\" etc.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 將輸入字串 expr 拆成 token 清單，包含數字和運算符號 // 先把字串拆成方便處理的元素  \n→ Step 2: 建立 memoization 表 memo，用於儲存已計算過的子表達式結果 // 以避免重複計算同一子式  \n→ Decision: 檢查 memo 是否為空? // 判斷是否需要初始化 memo  \n Yes → Step 3: 初始化 memo 為空字典 // 建立 memo 以供存取  \n No  → Step 4: 直接使用已存在的 memo // 已有結果可直接使用  \n\n→ Step 5: 定義遞迴函式 compute(start, end) → 取得 token[start..end] 的所有計算結果  \n → Decision: 如果 start == end? // 子表達式只有一個 token  \n  Yes → Step 6: 轉換 token[start] 為整數並回傳 [value] // 基本情況，只是單一數字  \n  No  → Step 7: 若 (start, end) 在 memo 中? // 已計算過，直接回傳結果  \n   Yes → Step 8: 回傳 memo[(start, end)] // 取得緩存結果  \n   No  → Step 9: 建立空 list results // 用於收集此子表達式所有結果  \n\n    → Decision: 循環 i 於 start+1 to end-1，每個奇數 i 為運算符號位置？ // 遍歷所有運算符  \n     Yes → Step 10: left_results ← compute(start, i-1) // 計算左半部所有結果  \n       → Step 11: right_results ← compute(i+1, end) // 計算右半部所有結果  \n       → Step 12: operator ← token[i] // 取得運算符  \n       → Step 13: 對於每 a 在 left_results  \n         → 對於每 b 在 right_results  \n          → Decision: operator 是 '+'? // 判斷運算符類型  \n           Yes → Step 14: results.append(a + b) // 加法結果  \n           No → Decision: operator 是 '-'?  \n            Yes → Step 15: results.append(a - b) // 減法結果  \n            No → Step 16: results.append(a * b) // 乘法結果  \n\n       → Step 17: memo[(start, end)] ← results // 將計算結果存入 memo  \n       → Step 18: 回傳 results // 結束此子表達式的遞迴  \n\n→ Step 19: 呼叫 compute(0, len(tokens)-1) 並將回傳值存於 answer // 計算整個表達式所有結果  \n→ End // 程式執行結束，answer 為最終結果列表"
    },
    {
      "title": "Contains Duplicate III",
      "source_file": "Leetcode/leetcode220.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,1], indexDiff = 3, valueDiff = 0",
          "expected_output": "true",
          "actual_output_or_error": "File \"/tmp/tmp2wa82g8b.py\", line 26\n    del bisect.bisect_left(window, old)\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: cannot delete function call"
        },
        {
          "example_index": 1,
          "input": "nums = [1,5,9,1,5,9], indexDiff = 2, valueDiff = 3",
          "expected_output": "false",
          "actual_output_or_error": "File \"/tmp/tmpb1bc4lxn.py\", line 26\n    del bisect.bisect_left(window, old)\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: cannot delete function call"
        }
      ],
      "generated_code": "import sys\nimport bisect\n\nclass Solution:\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\n        # If k <= 0 or t < 0, no valid pair can exist\n        if k <= 0 or t < 0:\n            return False\n\n        window = []  # sorted list of the last k elements\n\n        for i, num in enumerate(nums):\n            # Find the first element >= num - t\n            pos = bisect.bisect_left(window, num - t)\n            if pos < len(window) and abs(window[pos] - num) <= t:\n                return True\n\n            # Insert current number while keeping window sorted\n            bisect.insort(window, num)\n\n            # Maintain window size to be at most k\n            if len(window) > k:\n                # Remove the oldest element (nums[i - k]) from the sorted list\n                # Since window is sorted, we need to locate its index\n                old = nums[i - k]\n                del bisect.bisect_left(window, old)\n\n        return False\n\n\ndef solve() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # The input format is expected to be something like:\n    # nums = [1,2,3,1], indexDiff = 3, valueDiff = 0\n    # Using eval is safe here because the input is controlled.\n    nums, indexDiff, valueDiff = eval(data)\n\n    solution = Solution()\n    result = solution.containsNearbyAlmostDuplicate(nums, indexDiff, valueDiff)\n    print(str(result).lower())\n\n\nif __name__ == \"__main__\":\n    solve()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for the problem: given array nums, two ints indexDiff and valueDiff. Need to find pair indices i, j such that i!=j, abs(i-j)<=indexDiff, abs(nums[i]-nums[j])<=valueDiff. Return true if exists else false.\n\nWe need to output line by line, each line \"虛擬碼步驟 // 解釋\". Use Start, End, Decision, arrow. Provide algorithm, maybe using sliding window and balanced BST like TreeSet. But need virtual code.\n\nWe'll create steps: Start, initialize data structure, iterate over nums, for each i, maintain window of previous indices within indexDiff. Check if there's any value in window with difference <= valueDiff. Use binary search or balanced BST. If found return true. After loop return false. Use pseudo-code.\n\nLet's produce lines.\n\nPossible structure:\n\nStart // 程式開始\n→ Step 1: 初始化有序集合 window // 用於存放窗口內的元素值\n→ Step 2: for i from 0 to nums.length-1: // 遍歷數組\n    → Step 3: if i > indexDiff: // 窗口太大時移除最舊元素\n        → Step 4: window.remove(nums[i - indexDiff - 1]) // 從窗口刪除\n    → Step 5: // 查找是否存在值在 [nums[i]-valueDiff, nums[i]+valueDiff] 的元素\n        → Step 6: lower = window.floor(nums[i] + valueDiff) // 最接近上界的值\n        → Decision: lower exists and lower >= nums[i] - valueDiff?\n            Yes → Step 7: return true // 找到符合條件的對\n            No  → Step 8: // 仍需檢查其他方向\n                → Step 9: upper = window.ceiling(nums[i] - valueDiff) // 最接近下界的值\n                → Decision: upper exists and upper <= nums[i] + valueDiff?\n                    Yes → Step 10: return true\n                    No  → // continue\n    → Step 11: window.add(nums[i]) // 將當前元素加入窗口\n→ Step 12: return false // 未找到符合條件的對\nEnd // 程式結束\n\nBut maybe the floor/ceiling operations: we need to find any value within range; we can do lowerBound/upperBound. Let's phrase generically: Use binary search in sorted list.\n\nWe must maintain that i != j (ensured by window only containing earlier indices). Also indices difference check by window size.\n\nWe should note that we need to consider valueDiff symmetrical. We'll use a sorted list.\n\nBetter to use balanced BST. Use pseudocode:\n\nwindow: balanced BST storing values of last indexDiff elements\n\nfor each index i:\n   if i > indexDiff: remove nums[i-indexDiff-1]\n   // check for existence of any value in [nums[i]-valueDiff, nums[i]+valueDiff]\n   if window has element >= nums[i]-valueDiff and <= nums[i]+valueDiff: return true\n   add nums[i] to window\n\nBut we need to express existence check using floor/ceiling.\n\nAlternatively use two pointers sliding window sorted by values. But simple.\n\nLet's produce final virtual code accordingly.\n\nWe must ensure each line ends with // explanation. Use \"Start\", \"End\", \"Decision:\" lines with Yes→ and No→.\n\nLet's craft.\n\nAlso we might mention complexity: O(n log indexDiff).\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立一個有序集合 window 來存放最近 indexDiff 個元素的值 // 用於快速查找區間內的值  \n→ Step 2: 從 i = 0 開始遍歷整個 nums 陣列 // 逐個處理每個索引  \n    → Step 3: 如果 i > indexDiff: // 當窗口已超過允許的距離  \n        → Step 4: 從 window 移除 nums[i - indexDiff - 1] // 移除最舊的元素，保持窗口大小  \n    → Step 5: // 檢查窗口中是否存在值與 nums[i] 的差不超過 valueDiff  \n        → Step 6: 取出 window 中最大的值 ≤ nums[i] + valueDiff，稱為 upperCandidate // 使用 floor 機制  \n        → Decision: upperCandidate 存在且 upperCandidate ≥ nums[i] - valueDiff? // 是否落在區間內  \n            Yes → Step 7: return true // 找到符合條件的索引對  \n            No  → // 若上限不符，仍需檢查下限  \n                → Step 8: 取出 window 中最小的值 ≥ nums[i] - valueDiff，稱為 lowerCandidate // 使用 ceiling 機制  \n                → Decision: lowerCandidate 存在且 lowerCandidate ≤ nums[i] + valueDiff?  \n                    Yes → Step 9: return true // 同樣符合條件  \n                    No  → // 兩邊都不符合，繼續往下處理  \n    → Step 10: 將 nums[i] 加入 window // 將目前元素納入下一輪檢查  \n→ Step 11: 迴圈結束後仍未返回 true → return false // 未找到任何符合條件的索引對  \nEnd // 程式執行結束"
    },
    {
      "title": "Combination Sum",
      "source_file": "Leetcode/leetcode39.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "candidates = [2,3,6,7], target = 7",
          "expected_output": "[[2,2,3],[7]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmph702t492.py\", line 35, in <module>\n    target_part = parts[1].split('=')[1].strip()\n                  ~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        },
        {
          "example_index": 1,
          "input": "candidates = [2,3,5], target = 8",
          "expected_output": "[[2,2,2,2],[2,3,3],[3,5]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp2mdyp4eq.py\", line 35, in <module>\n    target_part = parts[1].split('=')[1].strip()\n                  ~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\n\ndef combination_sum(candidates, target):\n    \"\"\"找出所有和為 target 的組合，每個數字可重複使用。\"\"\"\n    candidates.sort()                     # 先排序，方便剪枝\n    res = []\n\n    def backtrack(start, path, total):\n        if total == target:\n            res.append(path.copy())       # 成功組合加入結果\n            return\n        if total > target:\n            return                       # 超過目標直接返回\n        for i in range(start, len(candidates)):\n            # 若加入後總和已超過目標，因為排序可直接跳過\n            if total + candidates[i] > target:\n                break\n            path.append(candidates[i])\n            backtrack(i, path, total + candidates[i])  # 允許重複使用同一數\n            path.pop()                      # 回溯\n\n    backtrack(0, [], 0)\n    return res\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入，預期格式如：candidates = [2,3,6,7], target = 7\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # 分割成候選數列與目標值\n    parts = data.split(',')\n    candidates_part = parts[0].split('=')[1].strip()\n    target_part = parts[1].split('=')[1].strip()\n    candidates = ast.literal_eval(candidates_part)\n    target = int(target_part)\n\n    result = combination_sum(candidates, target)\n    # 輸出不帶空格的 JSON 風格列表\n    print(json.dumps(result, separators=(\",\", \":\")))",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code for the problem: combination sum, typical backtracking. We must output line-by-line with arrow syntax, each line: virtual code + space + // explanation.\n\nWe must adhere to format: Start, End, Decision, Steps with arrow. No actual code.\n\nWe need to produce steps: start, input, sort array maybe, backtrack function, recursive decision to include or skip, base cases, collect results.\n\nWe should produce explanation for each line. Use Chinese. Provide the virtual code like \"Start\", \"→ Step 1: Sort candidates ascending // 排序以便後續剪枝\", etc.\n\nAlso need to indicate recursion: we can label \"→ Function backtrack(start, currentSum, currentCombo)\".\n\nBut the format might not support function definition? We can incorporate via comments.\n\nWe should ensure arrow format uses \"→\" to indicate subsequent step, indenting with decisions.\n\nWe must ensure each line ends with comment after space.\n\nWe can produce code:\n\nStart // 程式開始執行\n→ Step 1: 輸入候選數列 candidates 與目標值 target // 取得輸入\n→ Step 2: 將 candidates 依升序排序 // 方便剪枝與避免重複\n→ Step 3: 初始化結果 list results ← 空集合 // 用來儲存所有合法組合\n→ Step 4: 定義遞迴函式 Backtrack(startIndex, currentSum, currentCombo) // 回溯核心\n    → Decision: 如果 currentSum 等於 target? // 判斷是否完成一個組合\n        Yes → Step 5: 將 currentCombo 的拷貝加入 results // 儲存合法組合\n        No  → Decision: 如果 currentSum 大於 target? // 超過目標則不再進一步\n            Yes → Step 6: Return // 退回上一層\n            No  → Step 7: 循環 i 從 startIndex 到 candidates.Length-1\n                → Decision: 如果 currentSum + candidates[i] > target? // 剪枝\n                    Yes → Break // 跳出循環，因為數列已升序\n                    No  → Step 8: currentCombo 加入 candidates[i] // 選取此數\n                        → Step 9: 呼叫 Backtrack(i, currentSum + candidates[i], currentCombo) // 允許重複使用同一數\n                        → Step 10: currentCombo 從尾端移除 // 回溯撤銷選取\n→ Step 11: 呼叫 Backtrack(0, 0, 空列表) // 開始回溯\n→ End // 程式結束\n\nMake sure each line uses \"→\" for subsequent steps and \"Decision:\".\n\nWe must include indentations for nested lines? The format example uses indentation. We'll indent nested steps under decisions with spaces. Provide arrow for each step.\n\nAlso include \"Start\" and \"End\".\n\nWe must ensure \"虛擬碼步驟\" each line.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入候選數列 candidates 與目標值 target // 取得輸入  \n→ Step 2: 將 candidates 依升序排序 // 方便後續剪枝與避免重複  \n→ Step 3: 初始化結果列表 results ← 空集合 // 用來儲存所有合法組合  \n→ Step 4: 定義遞迴函式 Backtrack(startIndex, currentSum, currentCombo) // 回溯核心  \n  → Decision: currentSum 等於 target? // 判斷是否完成一個組合  \n   Yes → Step 5: 將 currentCombo 的拷貝加入 results // 儲存合法組合  \n   No  → Decision: currentSum 大於 target? // 超過目標則不再進一步  \n    Yes → Step 6: Return // 退回上一層  \n    No  → Step 7: 循環 i 從 startIndex 到 candidates.Length-1  \n     → Decision: currentSum + candidates[i] > target? // 剪枝  \n      Yes → Step 8: Break // 跳出循環，因為數列已升序  \n      No  → Step 9: currentCombo 加入 candidates[i] // 選取此數  \n       → Step 10: 呼叫 Backtrack(i, currentSum + candidates[i], currentCombo) // 允許重複使用同一數  \n       → Step 11: currentCombo 從尾端移除 // 回溯撤銷選取  \n→ Step 12: 呼叫 Backtrack(0, 0, 空列表) // 開始回溯  \n→ End // 程式結束"
    },
    {
      "title": "Course Schedule",
      "source_file": "Leetcode/leetcode207.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "numCourses = 2, prerequisites = [[1,0]]",
          "expected_output": "true",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp_21vrmml.py\", line 46, in <module>\n    params = parse_input(raw_input)\n             ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp_21vrmml.py\", line 40, in parse_input\n    return ast.literal_eval(data)\n           ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 112, in literal_eval\n    return _convert(node_or_string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 101, in _convert\n    return dict(zip(map(_convert, node.keys),\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 111, in _convert\n    return _convert_signed_num(node)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 85, in _convert_signed_num\n    return _convert_num(node)\n           ^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 76, in _convert_num\n    _raise_malformed_node(node)\n  File \"/usr/lib/python3.12/ast.py\", line 73, in _raise_malformed_node\n    raise ValueError(msg + f': {node!r}')\nValueError: malformed node or string on line 1: <ast.Name object at 0x7e679e1fba90>"
        },
        {
          "example_index": 1,
          "input": "numCourses = 2, prerequisites = [[1,0],[0,1]]",
          "expected_output": "false",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpbyfofnds.py\", line 46, in <module>\n    params = parse_input(raw_input)\n             ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpbyfofnds.py\", line 40, in parse_input\n    return ast.literal_eval(data)\n           ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 112, in literal_eval\n    return _convert(node_or_string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 101, in _convert\n    return dict(zip(map(_convert, node.keys),\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 111, in _convert\n    return _convert_signed_num(node)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 85, in _convert_signed_num\n    return _convert_num(node)\n           ^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 76, in _convert_num\n    _raise_malformed_node(node)\n  File \"/usr/lib/python3.12/ast.py\", line 73, in _raise_malformed_node\n    raise ValueError(msg + f': {node!r}')\nValueError: malformed node or string on line 1: <ast.Name object at 0x78c7cf1fba90>"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import deque\n\nclass Solution:\n    def canFinish(self, numCourses, prerequisites):\n        # 建立圖形以及入度數\n        graph = [[] for _ in range(numCourses)]\n        indegree = [0] * numCourses\n        for dest, src in prerequisites:\n            graph[src].append(dest)\n            indegree[dest] += 1\n\n        # 從入度為 0 的課程開始\n        queue = deque([i for i in range(numCourses) if indegree[i] == 0])\n        visited = 0\n\n        while queue:\n            node = queue.popleft()\n            visited += 1\n            for neighbor in graph[node]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    queue.append(neighbor)\n\n        return visited == numCourses\n\ndef parse_input(data: str):\n    \"\"\"\n    將形如 'numCourses = 2, prerequisites = [[1,0]]' 的字串\n    轉成 dict {'numCourses': 2, 'prerequisites': [[1,0]]}\n    \"\"\"\n    # 先把換行轉成空格，確保連續處理\n    data = data.replace('\\n', ' ')\n    # 把 '=' 改成 ':' 以符合 dict 語法\n    data = data.replace('=', ':')\n    # 加上大括號組成字典字串\n    data = '{' + data + '}'\n    # 解析為 python 物件\n    return ast.literal_eval(data)\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    if not raw_input.strip():\n        sys.exit()\n    params = parse_input(raw_input)\n    numCourses = params.get('numCourses')\n    prerequisites = params.get('prerequisites', [])\n\n    sol = Solution()\n    result = sol.canFinish(numCourses, prerequisites)\n    print('true' if result else 'false')",
      "virtual_code": "Thinking...\nWe need to produce a virtual code for detecting if can finish all courses given prerequisites: typical course schedule problem -> check for cycle in directed graph. Use DFS with visited states or Kahn's algorithm. Provide step-by-step pseudo code with arrows and explanation. Must output each line with \"虛擬碼步驟 // 解釋/說明\". Use \"Start\", \"End\", \"Decision:\" and arrows. Provide line by line.\n\nWe need to ensure that each line includes virtual code step plus comment. Use \"Start\" etc. Provide algorithm. We'll do DFS approach. Outline: Build adjacency list. Initialize visit status: 0 unvisited, 1 visiting, 2 visited. DFS each node. If encounter visiting, cycle -> return false. If finished all, return true.\n\nPseudo-code lines: Start; → Build graph; → Define status array; → Define DFS function; etc. Also handle return values. Each line must have arrow \"→\" preceding step, except Start and End lines? The example uses \"Start\" alone. We will use \"Start //\". Then lines with arrow \"→\". Indentation for decision. Use \"Decision:\". Provide lines with \"Yes →\" and \"No →\".\n\nLet's construct.\n\nLine 1: Start // 程式開始執行\nLine 2: → Build adjacency list from prerequisites // 建立從每門課到其後續課程的圖\nLine 3: → Initialize visitStatus array of size numCourses with 0 // 0 未訪問，1 正在訪問，2 已完成\nLine 4: → Define function DFS(course) returns bool // DFS 判斷是否存在循環\nLine 5:     → Decision: 若 visitStatus[course] == 2? // 已完成過的節點可以直接通過\nLine 6:         Yes → Return true // 已訪問過，無循環\nLine 7:     → Decision: 若 visitStatus[course] == 1? // 正在訪問的節點說明有循環\nLine 8:         Yes → Return false // 循環偵測到\nLine 9:     → Set visitStatus[course] = 1 // 標記為正在訪問\nLine 10:    → Decision: 若 adjacency[course] 為空? // 沒有後續課程\nLine 11:        Yes → Set visitStatus[course] = 2 // 標記完成\nLine 12:        Yes → Return true\nLine 13:    → Loop over next in adjacency[course] // 遍歷後續課程\nLine 14:        → Decision: 若 DFS(next) == false? // 子節點有循環\nLine 15:            Yes → Return false // 整體無法完成\nLine 16:    → Set visitStatus[course] = 2 // 標記完成\nLine 17:    → Return true // 這個節點沒有循環\nLine 18: → Loop over each course i from 0 to numCourses-1 // 檢查所有課程\nLine 19:     → Decision: 若 visitStatus[i] == 0? // 未訪問的課程\nLine 20:         Yes → Decision: 若 DFS(i) == false? // 該課程子樹有循環\nLine 21:             Yes → End // 直接結束並回傳 false (虛擬碼示意)\nLine 22:             No  → // 繼續下一個課程\nLine 23:     → // 若已訪問，跳過\nLine 24: → End // 所有課程均可完成，回傳 true\n\nBut need to include return true/false lines accordingly. Let's restructure: We'll produce final pseudo code that returns true or false. Use variables like canFinish.\n\nBetter: Use a global flag canFinish = true. But easier to directly return false when cycle found. However pseudo code can't easily return from inner DFS to outer. We can set a variable. We'll use a boolean variable cycleDetected.\n\nWe need to keep lines simple.\n\nLet's produce a simpler pseudo code:\n\nStart\n→ Build graph adjacency list\n→ Initialize status array\n→ Define DFS(course) returns bool\n    → Decision: status[course] == 2? // 已完成\n        Yes → Return true\n    → Decision: status[course] == 1? // 正在訪問\n        Yes → Return false\n    → Set status[course] = 1\n    → Loop over neighbor in graph[course]\n        → Decision: DFS(neighbor) == false?\n            Yes → Return false\n    → Set status[course] = 2\n    → Return true\n→ Loop i in 0..numCourses-1\n    → Decision: status[i] == 0?\n        Yes → Decision: DFS(i) == false?\n            Yes → End // 回傳 false\n            No  → // 繼續\n→ End // 回傳 true\n\nBut we need explicit return true at end. Maybe add a line before End: → Return true.\n\nThus End will include comment: // 程式執行結束\n\nBut we should include a line \"Return true\" before End. And \"Return false\" inside DFS as needed. For clarity, we might want to handle final return. Let's produce:\n\nLine: → Return true // 所有課程可完成\n\nBut End comment may say \"End // 程式執行結束\". But we can't have two End lines. We'll keep End as final.\n\nLet's craft final output with each line.\n\nWe must include arrow lines \"→\". Also Decision lines with Yes → and No →.\n\nLet's format:\n\nStart // 程式開始執行\n→ Build adjacency list from prerequisites // 建立從每門課到其後續課程的圖\n→ Initialize visitStatus array of size numCourses with 0 // 0:未訪問，1:正在訪問，2:已完成\n→ Define function DFS(course) returns bool // DFS 判斷是否存在循環\n    → Decision: 若 visitStatus[course] == 2? // 已完成過的節點可以直接通過\n        Yes → Return true // 已完成，不需再檢查\n    → Decision: 若 visitStatus[course] == 1? // 正在訪問的節點說明有循環\n        Yes → Return false // 循環偵測到\n    → Set visitStatus[course] = 1 // 標記為正在訪問\n    → Loop over next in adjacency[course] // 遍歷後續課程\n        → Decision: 若 DFS(next) == false? // 子節點有循環\n            Yes → Return false // 整體無法完成\n    → Set visitStatus[course] = 2 // 標記完成\n    → Return true // 這個節點沒有循環\n→ Loop i from 0 to numCourses-1 // 檢查所有課程\n    → Decision: 若 visitStatus[i] == 0? // 未訪問的課程\n        Yes → Decision: 若 DFS(i) == false? // 該課程子樹有循環\n            Yes → Return false // 直接回傳 false\n            No  → // 繼續檢查下一個課程\n→ Return true // 所有課程可完成\nEnd // 程式執行結束\n\nNeed to ensure each line has \"虛擬碼步驟\" and comment. Use indentation? Example didn't indent but uses arrows. We'll keep same style: lines with \"→\" plus comment after //.\n\nBut inside DFS, we need indentation; but still each line can start with \"→\" but then a sub-step. We might include \"→\" then nested? We can just keep \"→\" but indent with spaces for clarity.\n\nHowever the example only shows \"→\" for top-level steps, not for nested? Example: They used \"→ Decision:...\" and inside nested Yes -> etc. So we can replicate. For DFS function, we may start with \"→\" and then indent lines inside. Use 4 spaces for indentation before \"→\". Eg:\n\n→ Define function DFS(course) returns bool // ...\n    → Decision: ...\n\nBut we must ensure each line begins with \"→\". Actually the example lines inside indentation had no \"→\" at beginning? Let's check: Example:\n\n```\n→ Decision: 如果數字大於 0? // 檢查數值是否為正\n    Yes → Step 2: 輸出 '正數' // 如果是正數，顯示該訊息\n    No  → Decision: 如果數字等於 0? // 如果不是正數，檢查是否為零\n        Yes → Step 3: 輸出 '零' // 數字是零，顯示該訊息\n        No  → Step 4: 輸出 '負數' // 否則數值是負數\n```\n\nThey didn't indent for \"→ Decision\". They just indent lines with Yes→. So we can replicate: \"→ Decision: ...\" and nested Yes → inside same indentation level. For DFS function we might do \"→ Define function DFS(course) returns bool\". Then inside, lines with \"→ Decision\" etc. But maybe they used \"→\" only at top-level and inside they don't start with \"→\" again. Actually inside the example, after \"→ Decision:\", they used \"Yes → Step 2:\" etc. So for DFS function, we might use \"→ Define function DFS(course) returns bool\" then indent next lines but still start with \"→ Decision:\".\n\nLet's maintain consistency:\n\n- Each step begins with \"→\".\n- Inside function, we still use \"→ Decision:\" etc.\n\nThus final lines:\n\nStart // 程式開始執行\n→ Build adjacency list from prerequisites // 建立從每門課到其後續課程的圖\n→ Initialize visitStatus array of size numCourses with 0 // 0:未訪問，1:正在訪問，2:已完成\n→ Define function DFS(course) returns bool // DFS 判斷是否存在循環\n→ Decision: 若 visitStatus[course] == 2? // 已完成過的節點可以直接通過\n    Yes → Return true // 已完成，不需再檢查\n→ Decision: 若 visitStatus[course] == 1? // 正在訪問的節點說明有循環\n    Yes → Return false // 循環偵測到\n→ Set visitStatus[course] = 1 // 標記為正在訪問\n→ Loop over next in adjacency[course] // 遍歷後續課程\n→ Decision: 若 DFS(next) == false? // 子節點有循環\n    Yes → Return false // 整體無法完成\n→ Set visitStatus[course] = 2 // 標記完成\n→ Return true // 這個節點沒有循環\n→ Loop i from 0 to numCourses-1 // 檢查所有課程\n→ Decision: 若 visitStatus[i] == 0? // 未訪問的課程\n    Yes → Decision: 若 DFS(i) == false? // 該課程子樹有循環\n        Yes → Return false // 直接回傳 false\n        No  → // 繼續檢查下一個課程\n→ Return true // 所有課程可完成\nEnd // 程式執行結束\n\nBut we need to handle indentation for \"Loop over next in adjacency[course]\" and \"Decision: 若 DFS(next) == false?\" lines: In example, they didn't have nested arrows for loops but we can keep as separate lines.\n\nLet's refine: For \"Loop over next in adjacency[course]\" we can treat as a step with loop. Then inside loop, Decision. We'll indent accordingly.\n\nWe'll produce final answer with each line as above.\n\nBut need to ensure no actual code, just virtual code steps. We'll ensure to not include actual arrays or function syntax like \"for\". Just mention steps.\n\nLet's finalize.\n...done thinking.\n\nStart // 程式開始執行  \n→ Build adjacency list from prerequisites // 建立從每門課到其後續課程的圖  \n→ Initialize visitStatus array of size numCourses with 0 // 0:未訪問，1:正在訪問，2:已完成  \n→ Define function DFS(course) returns bool // DFS 判斷是否存在循環  \n→ Decision: 若 visitStatus[course] == 2? // 已完成過的節點可以直接通過  \n Yes → Return true // 已完成，不需再檢查  \n→ Decision: 若 visitStatus[course] == 1? // 正在訪問的節點說明有循環  \n Yes → Return false // 循環偵測到  \n→ Set visitStatus[course] = 1 // 標記為正在訪問  \n→ Loop over next in adjacency[course] // 遍歷後續課程  \n → Decision: 若 DFS(next) == false? // 子節點有循環  \n  Yes → Return false // 整體無法完成  \n→ Set visitStatus[course] = 2 // 標記完成  \n→ Return true // 這個節點沒有循環  \n→ Loop i from 0 to numCourses-1 // 檢查所有課程  \n → Decision: 若 visitStatus[i] == 0? // 未訪問的課程  \n  Yes → Decision: 若 DFS(i) == false? // 該課程子樹有循環  \n   Yes → Return false // 直接回傳 false  \n   No → // 繼續檢查下一個課程  \n→ Return true // 所有課程可完成  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick with Weight",
      "source_file": "Leetcode/leetcode528.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"], [[[1,3]],[],[],[],[],[]]",
          "expected_output": "[null,1,1,1,1,0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,1,1,1,1,0]'\nGot (Norm):      '[null,1,1,1,1,1]'\n--- (Raw) ---\nRaw Expected: '[null,1,1,1,1,0]'\nRaw Got:      '[null, 1, 1, 1, 1, 1]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport bisect\n\nclass Solution:\n    def __init__(self, w):\n        self.prefix_sum = []\n        total = 0\n        for weight in w:\n            total += weight\n            self.prefix_sum.append(total)\n        self.total = total\n\n    def pickIndex(self):\n        target = random.randint(1, self.total)\n        return bisect.bisect_left(self.prefix_sum, target)\n\ndef parse_input(data: str):\n    \"\"\"\n    Parse input that may come as two lines or a single line separated by comma.\n    Returns a tuple (methods, args_list).\n    \"\"\"\n    data = data.strip()\n    if not data:\n        return [], []\n\n    # Try split by newline first\n    lines = [line.strip() for line in data.splitlines() if line.strip()]\n    if len(lines) >= 2:\n        methods = json.loads(lines[0])\n        args_list = json.loads(lines[1])\n        return methods, args_list\n\n    # If single line, split at the first '],'\n    try:\n        idx = data.index(']')\n        methods = json.loads(data[:idx+1])\n        rest = data[idx+1:].lstrip(',').strip()\n        args_list = json.loads(rest)\n        return methods, args_list\n    except Exception:\n        # Fallback: try split by first comma that is not inside brackets\n        parts = []\n        bracket_depth = 0\n        current = []\n        for ch in data:\n            if ch == '[':\n                bracket_depth += 1\n            elif ch == ']':\n                bracket_depth -= 1\n            if ch == ',' and bracket_depth == 0:\n                parts.append(''.join(current))\n                current = []\n            else:\n                current.append(ch)\n        parts.append(''.join(current))\n        if len(parts) >= 2:\n            methods = json.loads(parts[0])\n            args_list = json.loads(parts[1])\n            return methods, args_list\n    # If parsing fails, return empty\n    return [], []\n\ndef main():\n    raw_input = sys.stdin.read()\n    methods, args_list = parse_input(raw_input)\n\n    results = []\n    instance = None\n    for method, args in zip(methods, args_list):\n        if method == \"Solution\":\n            instance = Solution(*args)\n            results.append(None)\n        else:\n            func = getattr(instance, method)\n            res = func(*args)\n            results.append(res)\n\n    # Convert None to null for JSON output\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the described problem. So we need to design a solution: build prefix sums, then random pick. Steps: compute prefix sum array at init. Then pickIndex: generate random integer between 1 and total sum inclusive, binary search to find index where prefix >= random.\n\nWe should output step-by-step pseudo-code with explanations. Ensure format: \"虛擬碼步驟 [space] // 解釋\". Use Start, End, Decision.\n\nLet's produce a plan:\n\nStart\n→ Step 1: 將 w 傳入構造函數 // 接收權重陣列\n→ Step 2: 建立 prefixSum 陣列 // 累積和\n    → Loop i from 0 to w.length-1\n        → Step 3: prefixSum[i] = (i==0? w[0] : prefixSum[i-1] + w[i]) // 計算累積\n→ Step 4: totalWeight = prefixSum[last] // 總重量\nEnd // 初始化完成\n\nThen pickIndex function:\nStart\n→ Step 5: 隨機產生整數 target 在 [1, totalWeight] // 隨機值\n→ Decision: 如果 target <= prefixSum[0]?\n    Yes → Step 6: 返回 0 // 第一個索引\n    No  → Decision: 對於 i from 1 to last?\n        → Step 7: If target <= prefixSum[i] → 返回 i // 找到對應索引\n→ End\n\nBut we can use binary search. So maybe step: binary search prefixSum to find smallest index with >= target.\n\nLet's produce final pseudo-code accordingly.\n\nWe must avoid actual code. Just virtual steps. Use arrows.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 接收權重陣列 w // 建構函式的參數  \n→ Step 2: 建立空陣列 prefixSum // 用於儲存累積和  \n→ Decision: 如果 w 非空?  \n    Yes → → Step 3: 設定 prefixSum[0] = w[0] // 第一個元素的累積  \n    No  → → Step 4: 直接返回 // 空陣列無需處理  \n→ Step 5: 從 i = 1 到 w.length - 1 迴圈  \n    → Step 6: prefixSum[i] = prefixSum[i-1] + w[i] // 逐步累積和  \n→ Step 7: 設定 totalWeight = prefixSum[w.length-1] // 總重量  \nEnd // 初始化完成  \n\nStart // pickIndex() 開始  \n→ Step 8: 產生隨機整數 target ∈ [1, totalWeight] // 產生目標值  \n→ Step 9: 設定 left = 0, right = w.length - 1 // 二分搜尋界限  \n→ Decision: while left < right?  \n    Yes → → Step 10: mid = (left + right) // 2  \n    → Decision: 如果 prefixSum[mid] < target?  \n        Yes → → Step 11: left = mid + 1 // 目標在右半部  \n        No  → → Step 12: right = mid // 目標在左半部或等於 mid  \n    No  → → Step 13: 返回 left // 找到最小索引使 prefixSum >= target  \nEnd // pickIndex() 執行結束"
    },
    {
      "title": "Cracking the Safe",
      "source_file": "Leetcode/leetcode753.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 1, k = 2",
          "expected_output": "\"10\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '10'\nGot (Norm):      '01'\n--- (Raw) ---\nRaw Expected: '\"10\"'\nRaw Got:      '01'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def crackSafe(self, n: int, k: int) -> str:\n        start = \"0\" * (n - 1)          # initial node of length n-1\n        seen = set()                   # visited edges\n        res = []                       # result in reverse order\n\n        def dfs(node: str):\n            for d in map(str, range(k)):\n                nxt = node + d\n                if nxt not in seen:\n                    seen.add(nxt)\n                    dfs(nxt[1:])      # shift window by 1\n                    res.append(d)     # record digit after returning\n\n        dfs(start)\n        # reverse res to obtain correct order and append start to make linear string\n        return \"\".join(reversed(res)) + start\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    nums = list(map(int, re.findall(r'\\d+', data)))\n    if len(nums) >= 2:\n        n, k = nums[0], nums[1]\n    else:\n        # fallback: if input format is \"n k\" separated by space\n        parts = data.strip().split()\n        n, k = int(parts[0]), int(parts[1])\n    sol = Solution()\n    print(sol.crackSafe(n, k))",
      "virtual_code": "Thinking...\nWe need to produce virtual code for generating minimal length string that contains all possible sequences of length n over alphabet [0,k-1] as subsequence? Actually requirement: sequence to unlock safe: we need to produce any string that will cause the most recent n digits to match the password at some point. Since we don't know password, we need to produce a string that guarantees that for any password of length n, at some point the last n digits match that password. So we need a de Bruijn sequence of order n over alphabet size k: a cyclic sequence of length k^n that contains each possible n-length string exactly once as a consecutive substring. Linear sequence of minimal length that contains all n-grams can be of length k^n + n - 1. So answer: produce de Bruijn sequence then maybe append first n-1 digits to make linear string.\n\nSo virtual code: steps: input k, n. Generate de Bruijn sequence B(k,n). Append first n-1 symbols of B to end to form linear sequence L. Output L.\n\nNeed to describe algorithm: de Bruijn via recursive DFS (prefer lexicographic). Use adjacency edges of k^n nodes. Or use algorithm by prefer to generate Lyndon words.\n\nSimplify: use DFS backtracking generating Eulerian circuit on de Bruijn graph.\n\nWe produce pseudocode steps.\n\nOk produce step-by-step:\n\nStart\n→ Step 1: Read integers k, n // Get alphabet size and password length\n→ Step 2: Initialize empty string sequence // Will store linear sequence\n→ Step 3: Define function DFS(node):\n    → For each digit d in 0..k-1:\n        → newNode = (node * k + d) mod k^(n-1) // Shift window\n        → If edge not visited:\n            → Mark edge visited\n            → DFS(newNode)\n            → Append d to sequence\n    // Build de Bruijn via Hierholzer's algorithm\n→ Step 4: Call DFS(0) // Start at node representing n-1 zeros\n→ Step 5: Append first n-1 digits of sequence to end // to make linear string\n→ Step 6: Output sequence // minimal unlocking string\n\nBut we need to be explicit about building Eulerian circuit, reverse sequence etc.\n\nWe need to produce explanation after each line.\n\nLet's produce lines:\n\nStart // 程式開始\n\n→ Step 1: Read k, n // 讀取字母表大小與密碼長度\n\n→ Step 2: Initialize sequence as empty string // 儲存生成的字串\n\n→ Step 3: Define DFS(node) function // 用於構建 de Bruijn 圖的深度優先搜尋\n\n    → For each digit d from 0 to k-1: // 遍歷所有可能的輸入\n\n        → newNode = (node * k + d) mod k^(n-1) // 計算移動窗口後的新節點\n\n        → If edge (node,d) not visited: // 若該邊未被使用\n\n            → Mark edge visited // 標記為已使用\n\n            → DFS(newNode) // 進一步探索\n\n            → Append character d to sequence // 在回溯時加入字元\n\n→ Step 4: Call DFS(0) // 從全零節點開始構建循環序列\n\n→ Step 5: Append first n-1 characters of sequence to end of sequence // 轉成線性序列，確保最後 n-1 位能形成完整子字串\n\n→ Step 6: Output sequence // 最短可解鎖序列\n\nEnd // 程式結束\n\nNeed to ensure each line ends with explanation comment. Also arrow lines. Provide indentation? Might use tabs or spaces. Each line is separate. Use arrow for steps, Decision maybe not needed.\n\nLet's produce.\n\nAlso may include explanation for Eulerian algorithm step. But we can keep simple.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Read integers k, n // 取得字母表大小 k 與密碼長度 n  \n→ Step 2: Initialize empty string sequence // 用於儲存生成的最短字串  \n→ Step 3: Define function DFS(node) // 以深度優先搜尋建立 de Bruijn 圖的 Eulerian 循環  \n  → For digit d from 0 to k-1: // 遍歷所有可能的輸入  \n   → newNode = (node * k + d) mod k^(n-1) // 取得移動一位後的節點編號  \n   → If edge (node, d) not visited: // 若此邊尚未使用  \n    → Mark edge (node, d) as visited // 標記為已經走過  \n    → DFS(newNode) // 進一步遞迴探索  \n    → Append character d to sequence // 回溯時加入字元，形成逆序的 de Bruijn 循環  \n→ Step 4: Call DFS(0) // 從全 0 的 (n-1)-位節點開始構建循環序列  \n→ Step 5: Append first n-1 characters of sequence to its end // 轉為線性字串，確保最後 n-1 位可組成完整子字串  \n→ Step 6: Output sequence // 產生最短可解鎖的輸入字串  \nEnd // 程式執行結束"
    }
  ]
}