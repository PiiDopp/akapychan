{
  "run_index": 43,
  "total_files_found": 391,
  "total_files_processed": 323,
  "files_skipped": 68,
  "files_failed_load": 0,
  "---": "--- (以下基於 *題目* 總數) ---",
  "total_problems_attempted": 334,
  "generation_and_validation_success_count": 304,
  "generation_or_validation_failure_count": 30,
  "failed_cases_details": [
    {
      "title": "統計文字行數",
      "source_file": "900.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "（假設 data.txt 內容如下）\\nHello\\nPython\\nWorld",
          "expected_output": "檔案共有 3 行",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '檔案共有3行'\nGot (Norm):      '檔案共有1行'\n--- (Raw) ---\nRaw Expected: '檔案共有 3 行'\nRaw Got:      '檔案共有 1 行'"
        }
      ],
      "generated_code": "import sys\n\ndef main() -> None:\n    \"\"\"\n    主程式：\n    1. 讀取標準輸入 (stdin)，即使此題不需要使用輸入，仍然按規定完成讀取。\n    2. 嘗試開啟名為 'data.txt' 的檔案，並計算其行數。\n    3. 若檔案不存在，印出錯誤訊息。\n    \"\"\"\n    # 讀取 stdin，對程式邏輯沒有實際影響，但符合「必須讀取」的規定\n    _ = sys.stdin.read()\n\n    file_path = 'data.txt'\n    try:\n        # 使用 with 語法確保檔案正確關閉\n        with open(file_path, 'r', encoding='utf-8') as f:\n            lines = f.readlines()\n            print(f'檔案共有 {len(lines)} 行')\n    except FileNotFoundError:\n        # 檔案不存在時的錯誤處理\n        print('找不到檔案！')\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line, with \"虛擬碼步驟\" and explanation. Use arrow, Decision, etc. Use with and try/except. Provide steps like Start, End. Must not output actual code, only virtual steps. Provide Chinese comments.\n\nWe need to produce the virtual code steps. Let's design:\n\nStart\n→ Step 1: 宣告檔案名稱為 'data.txt' // 指定要開啟的檔案\n→ Decision: 檔案是否存在? // 檢查檔案是否存在\n    Yes → Step 2: 開啟檔案並使用 with 語法 // 確保檔案安全關閉\n        → Step 3: 讀取所有行到列表 lines // 取得檔案內容\n        → Step 4: 計算行數 row_count = len(lines) // 取得行數\n        → Step 5: 輸出行數 // 顯示結果\n    No  → Decision: 嘗試打開檔案? // 嘗試開啟檔案來捕捉錯誤\n        Yes → Step 6: ... Actually we would use try/except\nBut the spec: \"請使用 with 語法搭配 try / except\" So we need to show try/except structure. Probably we show:\n\n→ Step 1: 開始 try\n    → Step 2: with open(file) as f:\n        → Step 3: lines = f.readlines()\n        → Step 4: row_count = len(lines)\n        → Step 5: print row_count\n    → Decision: try 成功? // if no exception\n        Yes → End\n        No  → Step 6: 捕捉 FileNotFoundError\n            → Step 7: print '找不到檔案！'\nEnd\n\nBut we need also to check file existence? Actually with try/except is enough: open file may raise FileNotFoundError. So we don't need pre-check. So simpler:\n\nStart\n→ Step 1: 設定 file_path = 'data.txt'\n→ Decision: 是否需要檢查檔案? // can skip, rely on exception\n→ Step 2: Begin try block\n    → Step 3: with open(file_path, 'r') as f:\n        → Step 4: lines = f.readlines()\n        → Step 5: row_count = len(lines)\n        → Step 6: print row_count\n    → Decision: 例外發生? // if no exception\n        Yes → Step 7: 捕捉 FileNotFoundError\n            → Step 8: print '找不到檔案！'\n        No → Step 9: End // 程式結束\nEnd\n\nNeed to use arrows and Decision syntax.\n\nMake sure each line ends with // 解釋.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 file_path = 'data.txt' // 定義要開啟的檔案路徑  \n→ Decision: 直接嘗試開啟檔案並處理異常? // 以 try/except 方式處理不存在的情況  \n    Yes → Step 2: Begin try block // 開啟 try 區塊  \n        → Step 3: with open(file_path, 'r') as f: // 使用 with 讀取檔案，確保關閉  \n            → Step 4: lines = f.readlines() // 讀取所有行到列表  \n            → Step 5: row_count = len(lines) // 計算行數  \n            → Step 6: print(row_count) // 輸出總行數  \n        → Decision: try 執行成功? // 檢查是否有異常  \n            Yes → Step 7: End // 無錯誤，結束程式  \n            No → Step 8: 捕捉 FileNotFoundError // 檔案不存在的例外處理  \n                → Step 9: print('找不到檔案！') // 顯示錯誤訊息  \nEnd // 程式執行結束"
    },
    {
      "title": "模擬擲骰子遊戲",
      "source_file": "800.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "print(roll_dice(5))",
          "expected_output": "[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,6,1,4,2]#(結果會隨機，每次可能不同)'\nGot (Norm):      '[2,6,5,3,3]'\n--- (Raw) ---\nRaw Expected: '[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)'\nRaw Got:      '[2, 6, 5, 3, 3]'"
        }
      ],
      "generated_code": "import random\nimport sys\n\ndef roll_dice(n):\n    \"\"\"擲 n 次六面骰，回傳結果列表。\"\"\"\n    return [random.randint(1, 6) for _ in range(n)]\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入，並執行其中的 Python 程式碼\n    # 這樣即可處理如 'print(roll_dice(5))' 之類的輸入\n    code = sys.stdin.read()\n    exec(code, globals())",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line, each line: \"虛擬碼步驟 // 解釋/說明\". Use arrow, Decision: etc. Since function roll_dice(n). Use random module. Steps: import random, define function, initialize list, loop n times, generate random int 1-6, append, return list. End.\n\nWe must use \"Start\" and \"End\". Also show function definition as Step maybe. Use arrow.\n\nWe need to produce in traditional Chinese.\n\nOk. Let's craft:\n\nStart\n→ Import: random // 引入 random 模組\n→ Function: roll_dice(n) // 定義 roll_dice 函式，接受參數 n\n    → Step: results = [] // 初始化結果列表\n    → Decision: n > 0? // 確保 n 為正數\n        Yes → Step: i = 0 // 初始化迴圈變數\n        → Decision: i < n? // 判斷是否還需擲骰\n            Yes → Step: roll = random.randint(1, 6) // 擲一次骰子\n            → Step: results.append(roll) // 把結果加入列表\n            → Step: i += 1 // 迴圈變數遞增\n            → Decision: i < n? // 重新判斷\n                Yes → repeat previous block\n                No → Step: return results // 所有擲完後回傳結果\n            No → Step: return results // n 為 0 時直接回傳空列表\n        No → Step: return results // n 為負數時直接回傳空列表\nEnd\n\nBut need to format each line with // explanation.\n\nWe need each line separated.\n\nAlso we might use \"Yes →\" and \"No →\" with indentation. Each line must contain 虛擬碼步驟 + space + // 解釋. We need to use Start and End. The decision lines should show Decision: etc.\n\nLet's produce final output accordingly. Ensure each line is one statement. Use indent maybe spaces but we keep arrow indentation. Use Chinese explanation.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Import: random // 引入 random 模組以便產生亂數  \n→ Function: roll_dice(n) // 定義 roll_dice 函式，參數 n 表示擲骰次數  \n → Step: results = [] // 初始化一個空列表來存放每次擲骰的結果  \n → Decision: n > 0? // 判斷 n 是否為正數，避免無效的迴圈  \n  Yes → Step: i = 0 // 設定迴圈計數器 i  \n  → Decision: i < n? // 只要 i 小於 n 就繼續擲骰  \n   Yes → Step: roll = random.randint(1, 6) // 擲一次六面骰子，得到 1~6 的數字  \n   → Step: results.append(roll) // 將骰子結果加入 results 列表  \n   → Step: i += 1 // 將計數器加一，準備下一次迴圈  \n   → Decision: i < n? // 重新判斷是否還有剩餘擲骰次數  \n    Yes → repeat previous block // 若 i 還小於 n，回到擲骰動作  \n    No → Step: return results // 當 i >= n 時，回傳所有結果  \n  No → Step: return results // 若 n 為 0 或負數，直接回傳空列表  \nEnd // 程式執行結束"
    },
    {
      "title": "計算程式執行時間",
      "source_file": "800.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "import time\n\ndef slow_add(a, b):\n    time.sleep(2)\n    return a + b\n\nprint(measure_time(slow_add, 3, 5))",
          "expected_output": "約 2.0 秒 (依電腦執行環境略有差異)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '約2.0秒(依電腦執行環境略有差異)'\nGot (Norm):      '2.0'\n--- (Raw) ---\nRaw Expected: '約 2.0 秒 (依電腦執行環境略有差異)'\nRaw Got:      '2.0'"
        }
      ],
      "generated_code": "import sys\nimport time\n\ndef measure_time(func, *args):\n    \"\"\"測量 func 執行所需秒數，並四捨五入到小數點 3 位。\"\"\"\n    start = time.time()\n    func(*args)\n    end = time.time()\n    return round(end - start, 3)\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取完整程式碼並執行\n    user_code = sys.stdin.read()\n    exec(user_code, globals())",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code line by line with explanation. The requirement: Use time module, write function measure_time(func, *args), measure execution time in seconds, return rounded to 3 decimal places. We need to output in the specified format: each line: virtual code step + space + // explanation.\n\nUse arrows and structure: Start, End, Decision:, maybe not many decisions. The function will likely have:\n\nStart\n→ Step 1: import time // import time module\n→ Step 2: define function measure_time(func, *args) // define function\n    → Step 3: record start_time = time.time() // capture start time\n    → Step 4: result = func(*args) // call the function\n    → Step 5: elapsed = time.time() - start_time // compute elapsed\n    → Step 6: rounded_time = round(elapsed, 3) // round to 3 decimals\n    → Step 7: return rounded_time, result // return time and result? The requirement says \"回傳結果 (四捨五入到小數點 3 位)\" might be ambiguous: do we return the time or the result? It says measure time and return result? Usually return elapsed time. Could also return result? Let's assume return elapsed time and maybe result? The requirement: \"用來測量函數 func 執行所需的秒數，並回傳結果 (四捨五入到小數點 3 位)\" So maybe return elapsed seconds. Let's just return the time. Might also return result but ambiguous. We'll include returning both? Let's interpret as return elapsed time. Provide only elapsed. Ok.\n\nWe need to include End. Also we may include \"Decision:\"? No. But the format expects to use arrow. We might not need decisions. But we should still use arrow for each step.\n\nLet's craft lines:\n\nStart // 程式開始執行\n→ Step 1: import time // 匯入 time 模組\n→ Step 2: define function measure_time(func, *args) // 定義 measure_time 函式\n    → Step 3: start_time = time.time() // 記錄開始時間\n    → Step 4: result = func(*args) // 執行傳入的函式\n    → Step 5: elapsed = time.time() - start_time // 計算耗時\n    → Step 6: rounded_time = round(elapsed, 3) // 四捨五入到小數點三位\n    → Step 7: return rounded_time // 回傳測量到的秒數\nEnd // 程式執行結束\n\nBut need to include explanation after each line.\n\nAlso maybe the function should return elapsed and result? We can add a comment. But to be safe, we could note that we return time only. The requirement ambiguous. We'll mention \"回傳耗時\" in explanation.\n\nLet's output each line accordingly.\n\nWe need to ensure indentation for nested steps: use 4 spaces indentation. Example from prompt: Use arrow after indentation. The example shows indentation with spaces. We can replicate.\n\nAlso each line must have \"虛擬碼步驟\" then space then \"// 解釋/說明\".\n\nThus we need to write:\n\nStart // 程式開始執行\n\n→ Step 1: import time // 匯入 time 模組\n\n→ Step 2: define function measure_time(func, *args) // 定義 measure_time 函式\n\n    → Step 3: start_time = time.time() // 記錄開始時間\n\n    → Step 4: result = func(*args) // 執行傳入的函式\n\n    → Step 5: elapsed = time.time() - start_time // 計算耗時\n\n    → Step 6: rounded_time = round(elapsed, 3) // 四捨五入到小數點三位\n\n    → Step 7: return rounded_time // 回傳測量到的秒數\n\nEnd // 程式執行結束\n\nThis meets the format.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: import time // 匯入 time 模組\n→ Step 2: define function measure_time(func, *args) // 定義 measure_time 函式\n    → Step 3: start_time = time.time() // 記錄開始時間\n    → Step 4: result = func(*args) // 執行傳入的函式\n    → Step 5: elapsed = time.time() - start_time // 計算耗時\n    → Step 6: rounded_time = round(elapsed, 3) // 四捨五入到小數點三位\n    → Step 7: return rounded_time // 回傳測量到的秒數\nEnd // 程式執行結束"
    },
    {
      "title": "集合函數練習",
      "source_file": "600.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "{'apple', 'orange', 'grape', 'melon'}",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '{\"apple\",\"orange\",\"grape\",\"melon\"}'\nGot (Norm):      '{\"apple\",\"grape\",\"orange\",\"melon\"}'\n--- (Raw) ---\nRaw Expected: \"{'apple', 'orange', 'grape', 'melon'}\"\nRaw Got:      \"{'apple', 'grape', 'orange', 'melon'}\""
        }
      ],
      "generated_code": "import sys\n\ndef main():\n    # 讀取並忽略任何輸入，因為此題不需要外部數據\n    sys.stdin.read()\n\n    # 1. 建立初始集合\n    fruits = {'apple', 'banana'}\n\n    # 2. 使用 add() 新增 'orange'\n    fruits.add('orange')\n\n    # 3. 使用 update() 同時新增 'grape' 與 'melon'\n    fruits.update(['grape', 'melon'])\n\n    # 4. 使用 remove() 移除 'banana'\n    fruits.remove('banana')\n\n    # 5. 使用 discard() 嘗試移除不存在的 'pineapple'（不會拋錯）\n    fruits.discard('pineapple')\n\n    # 6. 輸出最終集合\n    print(fruits)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step with explanation, following format. Each line: \"虛擬碼步驟 // 解釋\". Use arrows. Use Start and End. Decision not needed.\n\nWe need to show steps:\n\nStart\n→ Step 1: 初始化 fruits = {'apple', 'banana'} // 建立集合\n→ Step 2: fruits.add('orange') // 新增 'orange'\n→ Step 3: fruits.update(['grape', 'melon']) // 同時新增 'grape' 與 'melon'\n→ Step 4: fruits.remove('banana') // 移除 'banana'\n→ Step 5: fruits.discard('pineapple') // 嘗試移除不存在的 'pineapple'\n→ Step 6: print(fruits) // 輸出集合\nEnd\n\nMake sure each line includes arrow, colon, etc. Use \"→\" arrow, maybe indent? The example uses indentation for decisions. We can just use simple lines.\n\nLet's produce lines with arrow at beginning: \"→ Step ...\". Provide explanation after //.\n\nStart and End lines as shown.\n\nThus final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: fruits ← {'apple', 'banana'} // 建立初始集合  \n→ Step 2: fruits.add('orange') // 使用 add() 新增 'orange'  \n→ Step 3: fruits.update(['grape', 'melon']) // 使用 update() 同時新增 'grape' 與 'melon'  \n→ Step 4: fruits.remove('banana') // 使用 remove() 移除 'banana'  \n→ Step 5: fruits.discard('pineapple') // 使用 discard() 嘗試移除不存在的 'pineapple'（不會拋錯）  \n→ Step 6: print(fruits) // 輸出最終集合  \nEnd // 程式執行結束"
    },
    {
      "title": "即時匯率查詢小工具",
      "source_file": "1200.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "按下「更新匯率」按鈕",
          "expected_output": "目前美元匯率：約 32.5 TWD",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '目前美元匯率：約32.5TWD'\nGot (Norm):      '目前美元匯率：約30.57TWD'\n--- (Raw) ---\nRaw Expected: '目前美元匯率：約 32.5 TWD'\nRaw Got:      '目前美元匯率：約 30.57 TWD'"
        }
      ],
      "generated_code": "import sys\nimport requests\nimport tkinter as tk\nfrom tkinter import ttk\n\ndef fetch_rate() -> str:\n    \"\"\"\n    取得 USD 對 TWD 的匯率，回傳格式為\n    '目前美元匯率：約 <rate> TWD'\n    若失敗則回傳錯誤訊息。\n    \"\"\"\n    try:\n        url = \"https://api.exchangerate-api.com/v4/latest/USD\"\n        r = requests.get(url, timeout=5)\n        r.raise_for_status()\n        data = r.json()\n        rate = data[\"rates\"][\"TWD\"]\n        return f\"目前美元匯率：約 {rate} TWD\"\n    except Exception:\n        return \"更新失敗，請檢查網路連線\"\n\ndef create_gui() -> None:\n    \"\"\"\n    建立 tkinter GUI，包含顯示匯率的標籤與更新按鈕。\n    \"\"\"\n    win = tk.Tk()\n    win.title(\"匯率查詢\")\n\n    # 標籤用於顯示匯率訊息\n    label = ttk.Label(win, text=\"請按下按鈕更新匯率\", font=(\"Arial\", 12))\n    label.pack(pady=10)\n\n    # 更新按鈕點擊時呼叫 fetch_rate() 並更新標籤文字\n    def on_refresh() -> None:\n        msg = fetch_rate()\n        label.config(text=msg)\n\n    ttk.Button(win, text=\"更新匯率\", command=on_refresh).pack(pady=5)\n\n    win.mainloop()\n\nif __name__ == \"__main__\":\n    # 判斷是否有從標準輸入接收到資料\n    if not sys.stdin.isatty():\n        # 讀取所有輸入\n        input_text = sys.stdin.read().strip()\n        # 若輸入中包含「更新匯率」字樣，則印出最新匯率\n        if \"更新匯率\" in input_text:\n            print(fetch_rate())\n    else:\n        # 沒有輸入時，啟動 GUI\n        create_gui()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line with explanation, following format. Steps include importing requests, creating tkinter window, button, function to fetch API, parse JSON, update label. Use arrow structure. Use Start and End. Provide decision? maybe not needed but we can show error check. Let's produce.\n\nMake sure each line: \"虛擬碼步驟 // 解釋\" Example: \"Start // 程式開始執行\".\n\nUse arrow \"→\" to show next step.\n\nLet's craft:\n\nStart\n\n→ Import requests // 導入 HTTP 請求模組\n→ Import tkinter, ttk // 導入 GUI 模組\n→ Create main window // 建立 tkinter 視窗\n→ Set window title 'USD to TWD' // 設定標題\n→ Create Label to display rate // 建立顯示匯率的標籤\n→ Create Button 'Refresh' // 建立更新按鈕\n→ Define function fetch_rate() // 定義抓取匯率的函式\n→ Inside fetch_rate: 將 URL 設為 API 地址 // 設定 API URL\n→ Make GET request to URL // 發送 GET 請求\n→ Decision: 如果回應成功? // 檢查 HTTP 狀態\n    Yes → Parse JSON // 解析 JSON\n    → Get 'rates' dict // 取得 rates\n    → Get TWD rate // 取得 TWD 匯率\n    → Update Label text with rate // 更新標籤文字\n    No  → Update Label text with 'Error' // 失敗時顯示錯誤\n→ Button command = fetch_rate // 設定按鈕事件\n→ Call fetch_rate() 初始載入 // 初始取得匯率\n→ 主循環 start // 開始 GUI 主循環\n→ End // 程式結束\n\nNeed to use \"→\" for each step after start. For nested decisions we indent maybe with spaces. The format shows using \"→\" before each step and indentation for decision branches. Use \"Decision:\" lines. Good.\n\nLet's output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Import requests // 導入 HTTP 請求模組  \n→ Import tkinter, ttk // 導入 GUI 模組  \n→ Create main window // 建立 tkinter 視窗  \n→ Set window title 'USD to TWD' // 設定視窗標題  \n→ Create Label to display rate // 建立顯示匯率的標籤  \n→ Create Button 'Refresh' // 建立更新按鈕  \n→ Define function fetch_rate() // 定義抓取匯率的函式  \n→ Inside fetch_rate: 設定 API URL 為 'https://api.exchangerate-api.com/v4/latest/USD' // 設定 API 端點  \n→ Make GET request to URL // 發送 HTTP GET 請求  \n→ Decision: 回應狀態碼 200? // 檢查是否成功  \n    Yes → Parse JSON response // 解析回傳的 JSON  \n    → 取得 'rates' 字典 // 取得匯率表  \n    → 取得 'TWD' 匯率值 // 取出台幣匯率  \n    → 更新 Label 文字為 \"USD to TWD: {rate}\" // 顯示最新匯率  \n    No  → 更新 Label 文字為 \"Error: 無法取得匯率\" // 顯示錯誤訊息  \n→ Button command = fetch_rate // 設定按鈕點擊事件  \n→ 初始呼叫 fetch_rate() // 啟動時即顯示一次匯率  \n→ 主循環 start // 開始 tkinter 事件迴圈  \n→ End // 程式執行結束"
    },
    {
      "title": "Random Flip Matrix",
      "source_file": "Leetcode/leetcode519.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"flip\", \"flip\", \"flip\", \"reset\", \"flip\"], [[3, 1], [], [], [], [], []]",
          "expected_output": "[null, [1,0], [2,0], [0,0], null, [2,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[1,0],[2,0],[0,0],null,[2,0]]'\nGot (Norm):      '[null,[1,0],[0,0],[2,0],null,[1,0]]'\n--- (Raw) ---\nRaw Expected: '[null, [1,0], [2,0], [0,0], null, [2,0]]'\nRaw Got:      '[null, [1, 0], [0, 0], [2, 0], null, [1, 0]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, m, n):\n        self.m = m\n        self.n = n\n        self.total = m * n          # number of remaining 0s\n        self.mapping = {}           # index mapping for used positions\n\n    def flip(self):\n        # Pick a random index in the remaining range\n        rand = random.randint(0, self.total - 1)\n        # Map the chosen index to the real position\n        idx = self.mapping.get(rand, rand)\n        # Prepare the last available index\n        last = self.total - 1\n        # Update mapping so that the chosen spot is now taken\n        self.mapping[rand] = self.mapping.get(last, last)\n        # Reduce the number of available spots\n        self.total -= 1\n        # Convert back to 2D coordinates\n        return [idx // self.n, idx % self.n]\n\n    def reset(self):\n        self.total = self.m * self.n\n        self.mapping.clear()\n\nif __name__ == \"__main__\":\n    # Read the entire input\n    data_str = sys.stdin.read().strip()\n    if not data_str:\n        sys.exit()\n\n    # Wrap the input so that json.loads can parse it as a list of two lists\n    data = json.loads(f'[{data_str}]')\n    ops, args_list = data\n\n    result = []\n    solution = None\n    for op, args in zip(ops, args_list):\n        if op == \"Solution\":\n            solution = Solution(*args)\n            result.append(None)\n        elif op == \"flip\":\n            res = solution.flip()\n            result.append(res)\n        elif op == \"reset\":\n            solution.reset()\n            result.append(None)\n\n    # Output the results in JSON format\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with comments. We need to describe algorithm. We need minimal random calls: Use reservoir approach? Actually typical solution: treat grid as 1D array of size m*n. Maintain list of available indices or use mapping technique: random index from 0..remaining-1, pick mapping. Use dictionary mapping for swapped indices.\n\nAlgorithm:\n- total = m*n\n- remain = total\n- map = empty dict\n- flip():\n   - if remain == 0: maybe return None\n   - rand = random integer [0, remain-1]\n   - idx = map.get(rand, rand)\n   - last = remain-1\n   - map[rand] = map.get(last, last)\n   - remove last mapping? Not necessary\n   - remain -=1\n   - return [idx//n, idx % n]\n- reset():\n   - map.clear()\n   - remain = total\n\nWe produce virtual code line by line. Use arrows and Decision etc.\n\nLet's produce step-by-step.\n\nNeed Start, End.\n\nLet's produce:\n\nStart // 程式開始\n→ Step 1: 初始化 m, n, total ← m * n, remain ← total, mapping ← 空字典 // 設置矩陣大小與可用位置\n→ Step 2: 函式 flip() // 定義隨機翻轉\n    → Decision: 若 remain == 0? // 無空格可翻轉\n        Yes → Step 3: 返回 null // 或拋例外\n        No  → Step 4: 隨機生成 rand ← 隨機整數 [0, remain-1] // 只呼叫一次隨機\n        → Step 5: idx ← mapping.get(rand, rand) // 取得真實索引\n        → Step 6: last ← remain - 1\n        → Step 7: mapping[rand] ← mapping.get(last, last) // 將剩餘最後位置映射到 rand\n        → Step 8: remain ← remain - 1\n        → Step 9: 返回 [idx // n, idx % n] // 轉回 2D\n→ Step 10: 函式 reset() // 重置矩陣\n    → Step 11: mapping.clear()\n    → Step 12: remain ← total\nEnd // 程式結束\n\nBut we need use arrow syntax and indent. Use \"Decision:\" with Yes → and No →. Use \"→\" to next step. Provide comments.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: m, n ← 輸入參數; total ← m * n; remain ← total; mapping ← 空字典 // 初始化矩陣大小與剩餘可翻轉位置\n→ Step 2: 函式 flip() // 定義隨機翻轉邏輯\n    → Decision: 若 remain == 0? // 判斷是否還有空格可翻轉\n        Yes → Step 3: 返回 null // 或拋出例外，表示矩陣已滿\n        No  → Step 4: rand ← 隨機整數 [0, remain-1] // 只呼叫一次 random\n        → Step 5: idx ← mapping.get(rand, rand) // 取得真實索引，若不存在則直接使用 rand\n        → Step 6: last ← remain - 1\n        → Step 7: mapping[rand] ← mapping.get(last, last) // 把最後一個可用位置映射到 rand，以保持映射完整\n        → Step 8: remain ← remain - 1 // 減少可用位置數量\n        → Step 9: 返回 [idx // n, idx % n] // 將一維索引轉回二維座標\n→ Step 10: 函式 reset() // 重置矩陣\n    → Step 11: mapping.clear() // 清空映射表\n    → Step 12: remain ← total // 將剩餘位置恢復為全部\nEnd // 程式執行結束"
    },
    {
      "title": "Remove Invalid Parentheses",
      "source_file": "Leetcode/leetcode301.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "s = \"(a)())()\"",
          "expected_output": "[\"(a())()\",\"(a)()()\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"(a())()\",\"(a)()()\"]'\nGot (Norm):      '[\"(a)()()\",\"(a())()\"]'\n--- (Raw) ---\nRaw Expected: '[\"(a())()\",\"(a)()()\"]'\nRaw Got:      '[\"(a)()()\", \"(a())()\"]'"
        }
      ],
      "generated_code": "import sys\nimport json\nfrom collections import deque\n\nclass Solution:\n    def removeInvalidParentheses(self, s: str):\n        \"\"\"\n        Return all possible results after removing the minimum number of\n        invalid parentheses to make the string valid.\n        \"\"\"\n        def is_valid(st: str) -> bool:\n            \"\"\"Check whether a string has balanced parentheses.\"\"\"\n            balance = 0\n            for ch in st:\n                if ch == '(':\n                    balance += 1\n                elif ch == ')':\n                    balance -= 1\n                    if balance < 0:\n                        return False\n            return balance == 0\n\n        # BFS: level by level removal\n        level = {s}\n        while level:\n            # collect all valid strings in current level\n            valid = [item for item in level if is_valid(item)]\n            if valid:\n                return valid\n            next_level = set()\n            for item in level:\n                for i, ch in enumerate(item):\n                    if ch in ('(', ')'):\n                        nxt = item[:i] + item[i+1:]\n                        if nxt not in next_level:\n                            next_level.add(nxt)\n            level = next_level\n        return []\n\n\nif __name__ == \"__main__\":\n    # Read entire input\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        s = \"\"\n    else:\n        # Handle possible format like: s = \"()())()\"\n        if raw_input.startswith(\"s =\"):\n            # Find first and last quotation marks\n            first_quote = raw_input.find('\"')\n            last_quote = raw_input.rfind('\"')\n            if first_quote != -1 and last_quote != -1 and last_quote > first_quote:\n                s = raw_input[first_quote + 1:last_quote]\n            else:\n                # Fallback: strip the prefix\n                s = raw_input[4:].strip()\n        else:\n            s = raw_input\n\n    solution = Solution()\n    result = solution.removeInvalidParentheses(s)\n    # Output as JSON array to match expected double-quoted format\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need produce virtual code steps for algorithm: given string s with parentheses and letters, remove minimum number of invalid parentheses to make string valid. Return list of unique strings. Classic problem: Remove Invalid Parentheses. Use BFS or DFS with pruning. Usually use DFS with counting removals left. Approach: first compute number of misplaced left and right parentheses to remove. Then DFS generate all possible strings by removing parentheses, skip duplicates, ensure min removals. Or BFS level by level: start with s, generate neighbors by removing one char if it is parentheses; use visited set; first level where string valid, return list of such. That ensures minimum removals.\n\nWe need produce virtual code steps in Chinese, step-by-step with arrow syntax.\n\nLet's design algorithm using BFS approach, easier to describe. Steps:\n\n1. Start: initialize queue with original string, visited set.\n2. While queue not empty:\n   - Pop front string cur.\n   - If cur is valid: add to result list. Mark foundValid true.\n   - If foundValid: continue (don't generate further children).\n   - Else generate all children by removing one char at each index if char is '(' or ')', form new string newStr. If not visited, add to queue and visited.\n3. After loop, return result.\n\nAdditionally, need function to check validity: traverse string, maintain count, if count negative return false, after loop if count zero return true.\n\nAlso need to ensure uniqueness: visited set ensures.\n\nOk produce virtual code lines accordingly.\n\nBe careful to produce arrow and indentation. Each line must have \"虛擬碼步驟 // 解釋\". Use indentation for Decision: etc.\n\nLet's produce.\n\nWe'll output:\n\nStart // 程式開始執行\n→ Step 1: 定義函式 isValid(str) // 檢查括號合法性\n    → Decision: str 為合法括號? // 判斷是否合法\n        Yes → 返回 true // 合法\n        No → 返回 false // 不合法\nEnd // isValid 函式結束\n\nBut we may embed in main algorithm.\n\nLet's produce simpler: In main:\n\nStart\n→ Step 1: 定義結果列表 result = [] // 存放最小刪除後的合法字串\n→ Step 2: 定義隊列 queue = [s] // BFS 開始\n→ Step 3: 定義已訪問集合 visited = {s} // 防止重複\n→ Step 4: 定義布林 found = false // 是否已找到合法字串\n→ Decision: queue 非空? // 進入 BFS\n    Yes →\n        → Step 5: 取出 queue 前項 cur // 取得目前字串\n        → Decision: isValid(cur)? // 判斷合法性\n            Yes →\n                → Step 6: result.append(cur) // 加入結果\n                → Step 7: found = true // 設定已找到\n            No →\n                → Decision: found? // 是否已找到合法字串\n                    Yes → // 若已找到，不再擴展\n                        → Step 8: 省略 // 不產生子節點\n                    No  →\n                        → Step 9: 為 i in 0..len(cur)-1\n                            → Decision: cur[i] 為 '(' 或 ')' ? // 只刪除括號\n                                Yes →\n                                    → Step 10: newStr = cur[:i] + cur[i+1:] // 移除第 i 個字符\n                                    → Decision: newStr not in visited? // 防重複\n                                        Yes →\n                                            → Step 11: queue.append(newStr) // 加入隊列\n                                            → Step 12: visited.add(newStr) // 標記已訪問\n                                No → // 不是括號，跳過\n        → Step 13: 循環到下一項\n    No → // queue 為空\n→ End // BFS 完成\n→ Step 14: 返回 result // 結果\n\nBut we need to ensure each line is separate and includes arrow. Use indentation for Decision lines etc.\n\nNeed to maintain proper formatting.\n\nLet's produce final output.\n\nAlso need isValid function defined earlier. Could incorporate as Step 1.\n\nBut per requirement, we need to output virtual code step by step with explanation each line. Should not produce actual code.\n\nLet's craft final answer.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義函式 isValid(str) // 檢查字串括號是否合法  \n  → Decision: str 的括號平衡? // 判斷合法性  \n    Yes → 返回 true // 完全平衡  \n    No → 返回 false // 有不平衡  \nEnd // isValid 函式結束  \n\n→ Step 2: result = [] // 儲存所有合法且最少刪除的字串  \n→ Step 3: queue = [s] // BFS 以原字串為起點  \n→ Step 4: visited = {s} // 防止重複處理相同字串  \n→ Step 5: found = false // 是否已找到合法字串  \n\n→ Decision: queue 非空? // 進入 BFS 循環  \n  Yes →  \n   → Step 6: cur = queue.pop(0) // 取出前一個字串  \n   → Decision: isValid(cur)? // 判斷 cur 是否合法  \n     Yes →  \n      → Step 7: result.append(cur) // 加入結果  \n      → Step 8: found = true // 設定已找到合法字串  \n      → Step 9: continue // 下一輪循環  \n     No →  \n      → Decision: found? // 是否已找到合法字串  \n        Yes → // 已找到，停止擴展此層  \n         → Step 10: 省略 // 不產生子節點  \n       No →  \n        → Step 11: for i in range(len(cur)) // 檢查每個位置  \n          → Decision: cur[i] 是 '(' 或 ')' ? // 只考慮括號  \n            Yes →  \n             → Step 12: newStr = cur[:i] + cur[i+1:] // 刪除第 i 個字符  \n             → Decision: newStr 不在 visited? // 防止重複  \n               Yes →  \n                → Step 13: queue.append(newStr) // 加入隊列  \n                 → Step 14: visited.add(newStr) // 標記已訪問  \n                    No → 省略 // 已處理過  \n             No → 省略 // 不是括號，跳過  \n        → Step 15: 回到循環頂部  \n\n  No → // queue 已空，結束循環  \n\n→ Step 16: return result // 將所有合法字串回傳  \nEnd // 程式執行結束"
    },
    {
      "title": "Min Stack",
      "source_file": "Leetcode/leetcode155.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"],[[],[-2],[0],[-3],[],[],[],[]]",
          "expected_output": "[null,null,null,null,-3,null,0,-2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmppxx7kctv.py\", line 63, in <module>\n    main()\n  File \"/tmp/tmppxx7kctv.py\", line 39, in main\n    arguments = ast.literal_eval(right)\n                ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[[],[-2],[0],[-3],[],[],[],[]]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\n\nclass MinStack:\n    def __init__(self):\n        self.stack = []\n        self.min_stack = []\n\n    def push(self, val: int) -> None:\n        self.stack.append(val)\n        if not self.min_stack or val <= self.min_stack[-1]:\n            self.min_stack.append(val)\n\n    def pop(self) -> None:\n        if not self.stack:\n            return\n        val = self.stack.pop()\n        if self.min_stack and val == self.min_stack[-1]:\n            self.min_stack.pop()\n\n    def top(self) -> int:\n        return self.stack[-1] if self.stack else None\n\n    def getMin(self) -> int:\n        return self.min_stack[-1] if self.min_stack else None\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Split the input into the command list and the arguments list\n    idx = data.find('],')\n    left = data[:idx + 1]          # the command list string\n    right = '[' + data[idx + 2:]   # the arguments list string\n\n    commands = ast.literal_eval(left)\n    arguments = ast.literal_eval(right)\n\n    result = []\n    stack = None\n\n    for cmd, arg in zip(commands, arguments):\n        if cmd == 'MinStack':\n            stack = MinStack()\n            result.append(None)\n        elif cmd == 'push':\n            stack.push(arg[0])\n            result.append(None)\n        elif cmd == 'pop':\n            stack.pop()\n            result.append(None)\n        elif cmd == 'top':\n            result.append(stack.top())\n        elif cmd == 'getMin':\n            result.append(stack.getMin())\n\n    # Convert the Python list to a JSON-like string for the expected output format\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines, not actual code, just steps. Format: \"虛擬碼步驟 // 解釋\". We need to design MinStack with O(1) per operation.\n\nWe need to output steps: Start, etc.\n\nWe need to design algorithm: using two stacks: main stack and min stack. Or using one stack with pairs. Provide steps.\n\nSo produce a flow diagram description.\n\nLet's output step-by-step. Provide Start, initialization, push, pop, top, getMin, End.\n\nInclude decision branches for empty stack. Use arrows.\n\nLet's produce each line: e.g.,\n\nStart // 程式開始\n\n→ Step 1: 建立空主堆疊 mainStack // 主堆疊儲存所有值\n\n→ Step 2: 建立空最小堆疊 minStack // 儲存目前最小值\n\n→ Step 3: 接收操作命令 // 等待使用者指令\n\nThen branch for each operation:\n\nDecision: 操作為 push? etc.\n\nBut we just need to produce virtual code steps, not interactive. Maybe design functions individually.\n\nSimpler: Provide each function as steps.\n\nE.g.,\n\n→ Function push(val) // 開始 push 操作\n\n→ Decision: 若 minStack 為空 或 val ≤ minStack.top()？\n\n    Yes → minStack.push(val) // 新值為最小值，入最小堆疊\n\n    No →  // 不更新最小堆疊\n\n→ mainStack.push(val) // 入主堆疊\n\nEnd function\n\nSimilar for pop, top, getMin.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始\n\n→ Step 1: 建立空主堆疊 mainStack // 用來儲存所有進入堆疊的值  \n→ Step 2: 建立空最小堆疊 minStack   // 用來儲存目前堆疊中的最小值  \n\n→ Function push(val) // 開始 push 操作  \n → Decision: 如果 minStack 為空 或 val ≤ minStack.top()? // 判斷是否為新最小值  \n  Yes → minStack.push(val) // 新值成為最小值，入最小堆疊  \n  No  → // 不更新 minStack  \n → mainStack.push(val) // 把 val 入主堆疊  \n→ End Function // push 完成  \n\n→ Function pop() // 開始 pop 操作  \n → Decision: 若 mainStack 非空？ // 確保堆疊不為空  \n  Yes →  \n   → val = mainStack.pop() // 先從主堆疊移除頂部元素  \n   → Decision: 若 val = minStack.top()? // 若移除的元素是最小值  \n     Yes → minStack.pop() // 同時從最小堆疊移除  \n     No  → // 不須改動 minStack  \n  No  → // 堆疊為空，無操作  \n→ End Function // pop 完成  \n\n→ Function top() // 開始 top 操作  \n → Decision: 若 mainStack 非空？  \n  Yes → return mainStack.top() // 回傳主堆疊頂部值  \n  No  → return null/錯誤訊息 // 堆疊為空  \n→ End Function // top 完成  \n\n→ Function getMin() // 開始 getMin 操作  \n → Decision: 若 minStack 非空？  \n  Yes → return minStack.top() // 回傳目前最小值  \n  No  → return null/錯誤訊息 // 堆疊為空  \n→ End Function // getMin 完成  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Add Strings",
      "source_file": "Leetcode/leetcode415.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "num1 = \"11\", num2 = \"123\"",
          "expected_output": "\"134\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '134'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: '\"134\"'\nRaw Got:      ''"
        },
        {
          "example_index": 1,
          "input": "num1 = \"456\", num2 = \"77\"",
          "expected_output": "\"533\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '533'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: '\"533\"'\nRaw Got:      ''"
        },
        {
          "example_index": 2,
          "input": "num1 = \"0\", num2 = \"0\"",
          "expected_output": "\"0\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '0'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: '\"0\"'\nRaw Got:      ''"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def addStrings(self, num1: str, num2: str) -> str:\n        i, j = len(num1) - 1, len(num2) - 1\n        carry = 0\n        res = []\n\n        while i >= 0 or j >= 0 or carry:\n            x = int(num1[i]) if i >= 0 else 0\n            y = int(num2[j]) if j >= 0 else 0\n            total = x + y + carry\n            res.append(str(total % 10))\n            carry = total // 10\n            i -= 1\n            j -= 1\n\n        return ''.join(reversed(res))\n\ndef _strip_quotes(s: str) -> str:\n    s = s.strip()\n    if len(s) >= 2 and s[0] == s[-1] and s[0] in ('\"', \"'\"):\n        return s[1:-1]\n    return s\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    if len(data) >= 2:\n        num1 = _strip_quotes(data[0])\n        num2 = _strip_quotes(data[1])\n    else:\n        tokens = sys.stdin.read().split()\n        if len(tokens) >= 2:\n            num1 = _strip_quotes(tokens[0])\n            num2 = _strip_quotes(tokens[1])\n        else:\n            # Fallback: no valid input\n            sys.exit(0)\n\n    solution = Solution()\n    result = solution.addStrings(num1, num2)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to output virtual code line by line with explanation, no actual code. Steps: Start, input strings, set carry 0, pointers at end, loop until both pointers negative and carry 0. In loop: get digit1 if pointer>=0 else 0, same for digit2. Sum= d1+d2+carry. Result digit = sum mod 10, new carry = sum/10. Prepend to result string (build using list). Decrement pointers. After loop, reverse result or build by adding to front. End.\n\nWe must use virtual code syntax: Start, Step, Decision, Yes/No. Use arrows. Provide each line: \"虛擬碼步驟 // 解釋\".\n\nWe need to produce steps for this algorithm. We must not produce actual code. Use pseudo-language. Let's craft lines:\n\nStart\n→ Step 1: Initialize i ← len(num1) - 1, j ← len(num2) - 1, carry ← 0, result ← empty list // 將指標設在兩字串末尾，準備累加\n→ Decision: While i >= 0 OR j >= 0 OR carry > 0? // 判斷是否還有位數需要處理\n    Yes → Step 2: digit1 ← (i >= 0) ? int(num1[i]) : 0 // 取得 num1 目前位數，若已到頭則 0\n    → Step 3: digit2 ← (j >= 0) ? int(num2[j]) : 0 // 取得 num2 目前位數\n    → Step 4: sum ← digit1 + digit2 + carry // 計算三個數字之和\n    → Step 5: result.append(sum mod 10) // 將結果位加入暫存\n    → Step 6: carry ← sum div 10 // 計算進位\n    → Step 7: i ← i - 1 // 移動到前一位\n    → Step 8: j ← j - 1\n    No → // 循環結束\n→ Step 9: Reverse result and convert to string // 逆序並組成最終字串\n→ Step 10: Return result // 輸出和\n\nEnd\n\nBut we need to ensure we follow the format: each line \"虛擬碼步驟 // 解釋\". Use arrows and Decision. The Decision block should include Yes/No sub-lines indented. The example shows indenting lines after Decision with spaces. We must include arrow for each step within Decision? The example shows \"Yes → Step 2: ...\", \"No  → Decision: ...\". So we need to mimic that. We'll produce as such.\n\nLet's format:\n\nStart // 程式開始執行\n→ Step 1: i ← len(num1) - 1, j ← len(num2) - 1, carry ← 0, result ← [] // 初始化指標、進位與結果容器\n→ Decision: i >= 0 OR j >= 0 OR carry > 0? // 判斷是否仍有位數需要加總\n    Yes → Step 2: digit1 ← (i >= 0) ? int(num1[i]) : 0 // 取得 num1 目前位數，若已到頭則 0\n    → Step 3: digit2 ← (j >= 0) ? int(num2[j]) : 0 // 取得 num2 目前位數\n    → Step 4: sum ← digit1 + digit2 + carry // 計算三個數字之和\n    → Step 5: result.append(sum mod 10) // 把單位位存入結果\n    → Step 6: carry ← sum div 10 // 更新進位\n    → Step 7: i ← i - 1 // 移動到前一位\n    → Step 8: j ← j - 1\n    No  → // 迴圈結束，所有位數已處理\n→ Step 9: Reverse result and convert to string // 逆序並組成最終字串\n→ Step 10: Return result // 回傳相加結果\nEnd // 程式結束\n\nBut the Decision: inside the block we need Yes → lines; after Yes block, we need No block maybe as separate line with indentation. In example they used \"No  → Decision:\" but here we just close. So \"No  → // 迴圈結束\" is okay.\n\nEnsure each line has \" // 解釋\". We must not output code, just pseudo. So we can use \"int(num1[i])\" as pseudo conversion from char to integer; okay.\n\nLet's provide final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: i ← len(num1) - 1, j ← len(num2) - 1, carry ← 0, result ← [] // 初始化指標、進位與結果容器  \n→ Decision: i ≥ 0 OR j ≥ 0 OR carry > 0? // 判斷是否仍有位數需要加總  \n Yes → Step 2: digit1 ← (i ≥ 0) ? int(num1[i]) : 0 // 取得 num1 目前位數，若已到頭則 0  \n  → Step 3: digit2 ← (j ≥ 0) ? int(num2[j]) : 0 // 取得 num2 目前位數  \n  → Step 4: sum ← digit1 + digit2 + carry // 計算三個數字之和  \n  → Step 5: result.append(sum mod 10) // 把單位位存入結果  \n  → Step 6: carry ← sum div 10 // 更新進位  \n  → Step 7: i ← i - 1 // 移動到前一位  \n  → Step 8: j ← j - 1 // 移動到前一位  \n No  → // 迴圈結束，所有位數已處理  \n→ Step 9: Reverse result and convert to string // 逆序並組成最終字串  \n→ Step 10: Return result // 回傳相加結果  \nEnd // 程式結束"
    },
    {
      "title": "Random Pick Index",
      "source_file": "Leetcode/leetcode398.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\"], [[[1, 2, 3, 3, 3]], [3], [1], [3]]",
          "expected_output": "[null, 4, 0, 2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,4,0,2]'\nGot (Norm):      '[null,3,0,2]'\n--- (Raw) ---\nRaw Expected: '[null, 4, 0, 2]'\nRaw Got:      '[null, 3, 0, 2]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nimport random\nfrom collections import defaultdict\n\nclass Solution:\n    def __init__(self, nums):\n        \"\"\"儲存每個數字對應的索引列表。\"\"\"\n        self.indices = defaultdict(list)\n        for i, num in enumerate(nums):\n            self.indices[num].append(i)\n\n    def pick(self, target):\n        \"\"\"隨機選取目標值對應的索引。\"\"\"\n        return random.choice(self.indices[target])\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 以一個括號包起來，使其成為合法的 tuple，方便 literal_eval 解析\n    ops, args_list = ast.literal_eval(\"(\" + data + \")\")\n\n    obj = None\n    results = []\n\n    for op, args in zip(ops, args_list):\n        if op == \"Solution\":\n            # 參數為一個 list 包含 nums\n            obj = Solution(args[0])\n            results.append(None)  # 建構子不回傳值，對應 LeetCode 的 null\n        else:\n            # 呼叫 pick 方法\n            res = getattr(obj, op)(args[0])\n            results.append(res)\n\n    # 輸出結果，將 None 轉成 JSON 的 null\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines, step by step, using the described format. Should produce code steps: class, constructor, pick method, maybe building a hashmap from target to list of indices, then pick randomly from list. Or use reservoir sampling approach to avoid storing all indices? The requirement: random index of target. Implementation: Preprocess in constructor: build a dictionary mapping each number to list of indices. Then pick: get list, choose random index. But random uniform from indices. Use random number generator: choose random from 0 to len-1. So steps: Start, Step: Build mapping, Step: store array, etc. Then pick method: Start pick, get indices list, compute random index, return actual index. Use random module. Provide comments.\n\nWe need to output virtual code lines: each line with arrow \"→\". Use \"Start\" and \"End\". Use Decision etc. But for class we can do:\n\nStart // 程式開始執行\n→ Step 1: 定義類別 Solution // 定義 Solution 類別\n→ Step 2: 實作建構子 __init__(self, nums) // 建構子接收 nums\n→ Step 3: 建立字典 target_to_indices // 字典映射目標值到索引列表\n→ Step 4: 迴圈遍歷 nums，填充字典 // 為每個元素添加其索引\n→ Step 5: 儲存 nums 作為實例變數 // 以備未來使用\n→ Step 6: 實作 pick(self, target) // pick 方法\n→ Step 7: 取得 target 對應的索引列表 // indices = target_to_indices[target]\n→ Step 8: 確認索引列表非空 // Decision: 如果 indices 為空? // 但根據假設必定存在\n→ Step 9: 產生隨機整數 r 在 0 到 len(indices)-1 之間 // random_index = random.randint(0, len(indices)-1)\n→ Step 10: 回傳 indices[random_index] // 返回隨機選取的索引\nEnd // 程式結束\n\nBut we need to follow arrow pattern: Use \"→\" at beginning of each step, and indent decisions. Let's create properly.\n\nWe need to use \"Decision:\" if there is any conditional. For \"if indices empty\" but not needed. We can include it but skip. But better to keep as per style.\n\nAlso we may show import random at top. So include step: \"Import random module\".\n\nLet's produce final answer in proper format.\n...done thinking.\n\nStart // 程式開始執行  \n→ Import random module // 匯入 random 以便產生隨機數  \n→ Step 1: 定義類別 Solution // 建立 Solution 類別  \n→ Step 2: 實作建構子 __init__(self, nums) // 建構子接收整數陣列  \n→ Step 3: 建立字典 target_to_indices // 目標值對應的索引列表  \n→ Step 4: 迴圈遍歷 nums，將每個元素的索引加入對應字典鍵下的列表  \n→ Step 5: 儲存 nums 作為實例變數 // 方便後續使用  \n→ Step 6: 實作 pick(self, target) 方法 // 隨機選取目標值的索引  \n→ Step 7: 取得 target 對應的索引列表 indices = self.target_to_indices[target] // 取出所有符合的索引  \n→ Decision: 如果 indices 為空? // 根據題目假設一定存在，這裡作安全檢查  \n    No  → Step 8: 產生隨機整數 r 在 0 到 len(indices)-1 之間 r = random.randint(0, len(indices)-1) // 產生隨機位置  \n    → Step 9: 回傳 indices[r] // 返回隨機選取的索引  \n→ End // 程式執行結束"
    },
    {
      "title": "Repeated DNA Sequences",
      "source_file": "Leetcode/leetcode187.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = 'AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT'",
          "expected_output": "[\"AAAAACCCCC\",\"CCCCCAAAAA\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"AAAAACCCCC\",\"CCCCCAAAAA\"]'\nGot (Norm):      '[\"CCCCCAAAAA\",\"AAAAACCCCC\"]'\n--- (Raw) ---\nRaw Expected: '[\"AAAAACCCCC\",\"CCCCCAAAAA\"]'\nRaw Got:      '[\"CCCCCAAAAA\", \"AAAAACCCCC\"]'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport json\n\ndef findRepeatedDnaSequences(s: str):\n    \"\"\"\n    找出 DNA 字串中所有 10 字母長度的子字串\n    並且出現次數大於 1 的子字串，返回列表。\n    \"\"\"\n    seen = set()\n    repeated = set()\n    for i in range(len(s) - 9):          # 只需遍歷到 len(s)-10 位置\n        seq = s[i:i + 10]                # 取得 10 字母長度的子字串\n        if seq in seen:                  # 已經見過，加入重複集合\n            repeated.add(seq)\n        else:                            # 第一次見到，加入 seen\n            seen.add(seq)\n    return list(repeated)\n\ndef main():\n    # 從標準輸入讀取整個內容\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 從輸入中擷取第一個單引號包起來的字串\n    match = re.search(r\"'([^']*)'\", data)\n    if match:\n        s = match.group(1)\n    else:\n        # 若沒有單引號，假設整個輸入就是 DNA 字串\n        s = data\n\n    result = findRepeatedDnaSequences(s)\n\n    # 使用 json.dumps 讓輸出為雙引號的 JSON 陣列，符合範例格式\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the problem: find all 10-letter substrings that occur more than once in a DNA string s. Provide virtual code lines with comments. Need step-by-step algorithm, maybe sliding window and hash set or map. Should include Start, End, Decision. Use arrow syntax. Provide explanation after space. Each line: `虛擬碼步驟 // 解釋`. Should be in Traditional Chinese. Provide the solution algorithm.\n\nWe'll produce virtual code:\n\nStart\n→ Step 1: 初始化空集合 result // 存儲重複的10字串\n→ Step 2: 初始化空字典 count // 用於計數每個10字串\n→ Decision: s長度 < 10? // 若不足10則無重複\n    Yes → End // 結束，返回空集合\n    No  → Step 3: 遍歷所有長度為10的子串 (i從0到len(s)-10)\n        → Step 3.1: substring = s.substring(i, i+10)\n        → Step 3.2: count[substring] = count.get(substring,0)+1\n→ Step 4: 遍歷count字典\n    → Decision: count[seq] > 1? // 若出現多次\n        Yes → result.add(seq) // 加入結果\n        No  → 跳過\n→ End // 返回result\n\nBut need to use virtual code syntax with arrows, decisions. Let's use \"→\" for steps, \"Decision:\" lines with \"Yes →\" \"No →\". Provide code in lines.\n\nLet's produce lines:\n\nStart // 程式開始\n→ Step 1: 初始化空集合 result // 用於存放重複的 10 字母序列\n→ Step 2: 初始化空字典 count // 用於統計每個 10 字母序列的出現次數\n→ Decision: s.length < 10? // 如果 DNA 序列長度不足 10，無法有重複\n    Yes → End // 結束，返回空集合\n    No  → Step 3: 計算所有 10 字母長度的子串\n        → Step 3.1: for i from 0 to s.length - 10\n            → Step 3.1.1: sub = s.substring(i, i+10) // 取得當前子串\n            → Step 3.1.2: count[sub] = count.get(sub, 0) + 1 // 增加計數\n→ Step 4: 遍歷字典 count\n    → Decision: count[seq] > 1? // 檢查是否重複\n        Yes → result.add(seq) // 加入結果集合\n        No  → // 不重複，忽略\n→ End // 程式結束，返回 result\n\nBut the output format demands each line contains \"虛擬碼步驟 [space] // 解釋\". So each line separate, with no indentation maybe but we can keep indent for readability. Need to ensure arrow formatting like \"→\" and \"Decision:\" lines.\n\nLet's craft:\n\n```\nStart // 程式開始執行\n→ Step 1: 初始化空集合 result // 用於儲存所有重複出現的 10 字母序列\n→ Step 2: 初始化空字典 count // 用於計算每個 10 字母序列的出現次數\n→ Decision: s.length < 10? // 若 DNA 字串長度不足 10，則不可能有重複\n    Yes → End // 結束程式，返回空集合\n    No  → Step 3: 逐個檢查所有長度為 10 的子串\n        → Step 3.1: for i from 0 to s.length - 10\n            → Step 3.1.1: sub = s.substring(i, i+10) // 取得當前子串\n            → Step 3.1.2: count[sub] = count.get(sub, 0) + 1 // 計數累加\n→ Step 4: 遍歷字典 count\n    → Decision: count[seq] > 1? // 判斷該子串是否重複\n        Yes → result.add(seq) // 加入結果集合\n        No  → // 不重複，忽略\n→ End // 程式執行結束，返回 result\n```\n\nWe need to ensure each line includes explanation after //. Each line should have \"虛擬碼步驟\" which is the actual step. Use \"Step\" words. Use \"Decision:\" lines.\n\nLet's provide final answer in Traditional Chinese.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空集合 result // 用於儲存所有重複出現的 10 字母序列  \n→ Step 2: 初始化空字典 count // 用於計算每個 10 字母序列的出現次數  \n→ Decision: s.length < 10? // 若 DNA 字串長度不足 10，則不可能有重複  \n Yes → End // 結束程式，返回空集合  \n No  → Step 3: 逐個檢查所有長度為 10 的子串  \n  → Step 3.1: for i from 0 to s.length - 10  \n   → Step 3.1.1: sub = s.substring(i, i+10) // 取得當前子串  \n   → Step 3.1.2: count[sub] = count.get(sub, 0) + 1 // 計數累加  \n→ Step 4: 遍歷字典 count  \n  → Decision: count[seq] > 1? // 判斷該子串是否重複  \n   Yes → result.add(seq) // 加入結果集合  \n   No  → // 不重複，忽略  \n→ End // 程式執行結束，返回 result"
    },
    {
      "title": "Permutations",
      "source_file": "Leetcode/leetcode46.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nGot (Norm):      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nRaw Got:      '[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 2, 1], [3, 1, 2]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def permute(self, nums):\n        \"\"\"返回 nums 的所有排列\"\"\"\n        res = []\n\n        def backtrack(start):\n            # 基本情況：已經固定完所有位置\n            if start == len(nums):\n                res.append(nums[:])      # 需要複製一份\n                return\n            # 從 start 開始的所有位置做交換\n            for i in range(start, len(nums)):\n                nums[start], nums[i] = nums[i], nums[start]\n                backtrack(start + 1)\n                nums[start], nums[i] = nums[i], nums[start]  # 回溯\n\n        backtrack(0)\n        return res\n\ndef read_nums_from_stdin():\n    \"\"\"\n    讀取 stdin，並解析出數字列表。\n    允許的輸入形式例如:\n        nums = [1,2,3]\n    或僅僅輸入:\n        [1,2,3]\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return []\n\n    # 若有 '='，取 '=' 之後的部分\n    if '=' in data:\n        _, arr = data.split('=', 1)\n        arr = arr.strip()\n    else:\n        arr = data\n\n    # 使用 ast.literal_eval 解析安全\n    try:\n        nums = ast.literal_eval(arr)\n    except Exception:\n        # 若解析失敗，回傳空列表\n        nums = []\n\n    # 確保得到的是列表\n    if not isinstance(nums, list):\n        nums = []\n\n    return nums\n\nif __name__ == \"__main__\":\n    nums = read_nums_from_stdin()\n    solution = Solution()\n    result = solution.permute(nums)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to output step-by-step virtual code for generating all permutations of an array of distinct integers. Use Start, End, Decision, arrow, etc. Provide explanation each line. Use \"虛擬碼步驟\" and // explanation.\n\nWe must not output real code. Use pseudo steps like \"Step 1: Initialize result list\" etc.\n\nAlso the input is array nums.\n\nWe need algorithm: backtracking. Steps: define recursive function permute(current, remaining). Add to result when remaining empty.\n\nLet's produce lines:\n\nStart // program starts\n\n→ Step 1: 將 nums 轉為 list // convert input\n\n→ Step 2: 初始化 result 為空列表 // store permutations\n\n→ Step 3: 定義遞迴函數 backtrack(path, remaining) // recursion\n\n→ Step 4: Decision: remaining 是否為空？ // base case\n\n    Yes → Step 5: 把 path 加入 result // record permutation\n\n    No  → Step 6: 對於 remaining 中每個元素 i // iterate\n\n        → Step 7: newPath = path + i // add element\n\n        → Step 8: newRemaining = remaining - i // remove\n\n        → Step 9: backtrack(newPath, newRemaining) // recursive call\n\n→ Step 10: 呼叫 backtrack([], nums) // start recursion\n\n→ Step 11: 回傳 result // return permutations\n\nEnd // end\n\nMake sure each line has \"→\" except Start/End? We can use arrows for each step after Start.\n\nAlso include Decision lines with Yes/No arrows. Provide concise explanation.\n\nLet's craft.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 將輸入的 nums 轉為列表 // 方便後續操作  \n→ Step 2: 初始化 result 為空列表 // 用來收集所有排列  \n→ Step 3: 定義遞迴函數 backtrack(path, remaining) // path 是目前已選取的元素，remaining 是尚未選取的  \n→ Step 4: Decision: remaining 是否為空？ // 檢查是否已生成完整排列  \n  Yes → Step 5: 將 path 加入 result // 完整排列完成，加入結果  \n  No  → Step 6: 對於 remaining 中每個元素 i 循環 // 探索每一個可能的下一步  \n    → Step 7: newPath = path + i // 在路徑上加上選取的元素  \n    → Step 8: newRemaining = remaining - i // 從剩餘中移除已選元素  \n    → Step 9: backtrack(newPath, newRemaining) // 進行下一層遞迴  \n→ Step 10: 呼叫 backtrack([], nums) // 從空路徑開始遞迴  \n→ Step 11: 回傳 result // 返回所有可能的排列  \nEnd // 程式執行結束"
    },
    {
      "title": "Insert Delete GetRandom O(1) - Duplicates allowed",
      "source_file": "Leetcode/leetcode381.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedCollection\", \"insert\", \"insert\", \"insert\", \"getRandom\", \"remove\", \"getRandom\"], [[], [1], [1], [2], [], [1], []]",
          "expected_output": "[null, true, false, true, 2, true, 1]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpqmsfqq4q.py\", line 68, in <module>\n    main()\n  File \"/tmp/tmpqmsfqq4q.py\", line 42, in main\n    cmds = json.loads(parts[0].strip())\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 337, in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 353, in raw_decode\n    obj, end = self.scan_once(s, idx)\n               ^^^^^^^^^^^^^^^^^^^^^^\njson.decoder.JSONDecodeError: Expecting ',' delimiter: line 1 column 24 (char 23)"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nfrom collections import defaultdict\n\nclass RandomizedCollection:\n    def __init__(self):\n        self.data = []\n        self.idx_map = defaultdict(set)\n\n    def insert(self, val: int) -> bool:\n        self.data.append(val)\n        self.idx_map[val].add(len(self.data) - 1)\n        return len(self.idx_map[val]) == 1\n\n    def remove(self, val: int) -> bool:\n        if not self.idx_map[val]:\n            return False\n        remove_idx = self.idx_map[val].pop()\n        last_val = self.data[-1]\n        self.data[remove_idx] = last_val\n        self.idx_map[last_val].add(remove_idx)\n        self.idx_map[last_val].discard(len(self.data) - 1)\n        self.data.pop()\n        return True\n\n    def getRandom(self) -> int:\n        return random.choice(self.data)\n\ndef main():\n    input_text = sys.stdin.read().strip()\n    if not input_text:\n        return\n    # Parse input into commands and arguments\n    lines = input_text.splitlines()\n    if len(lines) >= 2:\n        cmds = json.loads(lines[0].strip())\n        args = json.loads(lines[1].strip())\n    else:\n        # Handle single-line input format: [\"cmd1\",\"cmd2\"], [[],[1],...]\n        parts = input_text.split(',', 1)\n        cmds = json.loads(parts[0].strip())\n        args = json.loads(parts[1].strip())\n\n    result = []\n    obj = None\n    for cmd, arg in zip(cmds, args):\n        if cmd == \"RandomizedCollection\":\n            obj = RandomizedCollection()\n            result.append(None)\n        elif cmd == \"insert\":\n            res = obj.insert(arg[0])\n            result.append(res)\n        elif cmd == \"remove\":\n            res = obj.remove(arg[0])\n            result.append(res)\n        elif cmd == \"getRandom\":\n            res = obj.getRandom()\n            result.append(res)\n        else:\n            # Unknown command, append None\n            result.append(None)\n\n    # Output results in JSON format (null/true/false)\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode for RandomizedCollection, supporting insert, remove, getRandom, each O(1) average. Use a vector list of values, and a map from value to set of indices. For insert: add to list, add index to map. Return true if value was not previously present. For remove: if not present return false. Else, get an index from set, remove that index from set. Swap last element into that position if not the last. Update indices sets. Pop last. Return true. getRandom: random index in list size. Return list[index].\n\nWe need to output step-by-step lines with explanations, each line a \"虛擬碼步驟\" and explanation.\n\nWe need to produce algorithm flow. Since it's a class, maybe start with class definition, constructor, methods, each step inside.\n\nBut format demands Start, End, Decision, etc. We can outline the entire process for each function.\n\nLet's produce pseudocode in lines. Use arrows →, decisions.\n\nWe must not output actual code; just pseudocode steps.\n\nLet's start with \"Start\" for class initialization, etc.\n\nProbably better to break into functions.\n\nMaybe:\n\nStart // 程式開始執行\n→ Step: 初始化空的 RandomizedCollection // 初始化資料結構\n    → Step 1: list ← [] // 存放所有元素\n    → Step 2: map ← {} // value -> set of indices\n→ End\n\nThen functions:\n\nInsert(val):\nStart // insert 開始\n→ Decision: map 是否包含 val? // 判斷 val 是否已存在\n    Yes → Step: 在 map[val] 中加入新索引 // 新增位置\n        → Step: list.append(val) // 把 val 加到末尾\n        → Step: map[val].add(list.size-1) // 索引放入集合\n        → Step: Return false // 之前已存在，插入不算新\n    No → Step: list.append(val)\n        → Step: map[val] ← {list.size-1}\n        → Step: Return true // 新元素\nEnd\n\nRemove(val):\nStart // remove 開始\n→ Decision: map 是否包含 val? // 判斷 val 是否存在\n    Yes → Step: idx ← 任意元素 map[val] 中的索引 // 取一個索引\n        → Step: map[val].remove(idx) // 移除此索引\n        → Decision: idx 等於 list.size-1? // 判斷是否是最後一個元素\n            Yes → Step: list.pop() // 刪除最後一個\n            No  → Step: lastVal ← list.last() // 取得最後一個值\n                → Step: list[idx] ← lastVal // 把最後一個覆蓋 idx\n                → Step: list.pop() // 刪除最後一個\n                → Step: map[lastVal].remove(list.size) // 刪除舊索引\n                → Step: map[lastVal].add(idx) // 加入新索引\n        → Decision: map[val] 是否為空? // 判斷是否還有此 val\n            Yes → Step: delete map[val] // 移除空集合\n        → Step: Return true // 成功刪除\n    No → Step: Return false // 未找到元素\nEnd\n\nGetRandom():\nStart // getRandom 開始\n→ Step: idx ← 隨機整數 0 ~ list.size-1 // 隨機索引\n→ Step: Return list[idx] // 回傳對應值\nEnd\n\nBut need to keep lines with \"虛擬碼步驟\" and comment after. Ensure each line starts with \"虛擬碼步驟\". For example: \"Start // 程式開始執行\".\n\nBetter to show \"Start\" lines, \"Decision:\" etc. Use arrows. Let's produce a sequence.\n\nWe need to ensure each line has \"虛擬碼步驟\" then a space then comment.\n\nLet's produce final answer accordingly.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: list ← [] // 建立儲存所有元素的陣列\n→ Step 2: map ← {} // 建立鍵值對，value → 集合 of 索引\nEnd // 初始結構建立完畢\n\n// ---------- insert(val) ----------\nStart // insert 開始\n→ Decision: map 包含 key val? // 檢查 val 是否已存在\n    Yes → Step 1: idx ← list.size // 取得即將新增的索引\n        → Step 2: list.append(val) // 把 val 加到陣列末端\n        → Step 3: map[val].add(idx) // 將新索引加入集合\n        → Step 4: Return false // val 已存在，插入不算新\n    No → Step 1: idx ← list.size\n        → Step 2: list.append(val)\n        → Step 3: map[val] ← {idx} // 建立新集合並加入索引\n        → Step 4: Return true // 成功新增一次\nEnd // insert 完成\n\n// ---------- remove(val) ----------\nStart // remove 開始\n→ Decision: map 包含 key val? // 檢查 val 是否存在\n    Yes → Step 1: idx ← map[val].any() // 取得任意一個索引\n        → Step 2: map[val].remove(idx) // 移除該索引\n        → Decision: idx == list.size-1? // 判斷是否是最後一個元素\n            Yes → Step 1: list.pop() // 直接移除最後一個\n            No  → Step 1: lastVal ← list.last() // 取得最後一個值\n                → Step 2: list[idx] ← lastVal // 用最後一個覆蓋被刪位置\n                → Step 3: list.pop() // 刪除最後一個\n                → Step 4: map[lastVal].remove(list.size) // 移除舊索引\n                → Step 5: map[lastVal].add(idx) // 加入新索引\n        → Decision: map[val] 是否為空? // 判斷是否還有同值\n            Yes → Step 1: delete map[val] // 若空集合則刪除鍵\n        → Step 1: Return true // 成功刪除一個\n    No → Step 1: Return false // 沒有此元素\nEnd // remove 完成\n\n// ---------- getRandom() ----------\nStart // getRandom 開始\n→ Step 1: idx ← randomInt(0, list.size-1) // 隨機取得索引\n→ Step 2: Return list[idx] // 回傳對應的值\nEnd // getRandom 完成\n```"
    },
    {
      "title": "Minimum Genetic Mutation",
      "source_file": "Leetcode/leetcode433.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "startGene = \"AACCGGTT\", endGene = \"AACCGGTA\", bank = [\"AACCGGTA\"]",
          "expected_output": "1",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '1'\nGot (Norm):      '-1'\n--- (Raw) ---\nRaw Expected: '1'\nRaw Got:      '-1'"
        },
        {
          "example_index": 1,
          "input": "startGene = \"AACCGGTT\", endGene = \"AAACGGTA\", bank = [\"AACCGGTA\",\"AACCGCTA\",\"AAACGGTA\"]",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '-1'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '-1'"
        }
      ],
      "generated_code": "import sys\nfrom collections import deque\n\nclass Solution:\n    def minMutation(self, start, end, bank):\n        \"\"\"計算最少突變步數，若無法轉換則回傳 -1\"\"\"\n        if end not in bank:\n            return -1\n\n        bank_set = set(bank)\n        genes = ['A', 'C', 'G', 'T']\n        queue = deque([(start, 0)])\n        visited = set([start])\n\n        while queue:\n            current, steps = queue.popleft()\n            if current == end:\n                return steps\n\n            for i in range(len(current)):\n                for g in genes:\n                    mutation = current[:i] + g + current[i + 1:]\n                    if mutation in bank_set and mutation not in visited:\n                        visited.add(mutation)\n                        queue.append((mutation, steps + 1))\n\n        return -1\n\ndef main():\n    data_str = sys.stdin.read().strip()\n    if not data_str:\n        return\n    # 把輸入的文字包裝成字典形式，使用 eval 取得資料\n    # 例如：startGene = \"AACCGGTT\", endGene = \"AACCGGTA\", bank = [\"AACCGGTA\"]\n    try:\n        data_str = \"{\" + data_str + \"}\"\n        data = eval(data_str, {\"__builtins__\": None}, {})\n        start_gene = data[\"startGene\"]\n        end_gene = data[\"endGene\"]\n        bank = data[\"bank\"]\n    except Exception as e:\n        print(-1)\n        return\n\n    sol = Solution()\n    result = sol.minMutation(start_gene, end_gene, bank)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step, using the syntax with Start, → Step, Decision: etc. The problem is classic Minimum Genetic Mutation. We need BFS to find min steps. Steps: convert bank to set. If endGene not in set: return -1. Use queue with startGene, steps=0. While queue: for each gene in level: for each position, try 4 letters, if new gene in bank and not visited: add to queue, visited. If new gene == endGene: return steps+1. After loop level increments. If queue empty: return -1.\n\nNeed to produce virtual code lines with explanation. Each line: e.g., \"Start // 程式開始執行\". Then steps. Use arrow formatting: \"→ Step: ...\" etc. Ensure each line ends with comment. Use appropriate indentation for decisions.\n\nLet's craft:\n\nStart\n→ Step 1: 將 bank 轉成 Set genes // 方便 O(1) 查找\n→ Decision: endGene 是否在 genes? // 必須存在才可能轉換\n    Yes → Step 2: 初始化 queue 為 [startGene]，steps=0，visited = {startGene} // BFS 基礎\n    No  → Step 3: 返回 -1 // 無法達成\n→ Decision: startGene 是否等於 endGene? // 直接相同不需 mutation\n    Yes → Step 4: 返回 0 // 已是目標基因\n    No  → \n        → Step 5: While queue 非空 // BFS 主循環\n            → Step 6: levelSize = queue.size() // 一層深度\n            → Step 7: for i in 1..levelSize\n                → Step 8: current = queue.pop()\n                → Step 9: for pos in 0..7\n                    → Step 10: for c in ['A','C','G','T']\n                        → Decision: current[pos] 與 c 是否相同? // 避免重複字符\n                            Yes → Continue\n                            No  →\n                                → Step 11: nextGene = current[0:pos] + c + current[pos+1:] // 替換字符\n                                → Decision: nextGene 是否在 genes 且未被訪問? // 有效且未處理\n                                    Yes →\n                                        → Step 12: 若 nextGene == endGene? // 找到目標\n                                            → Decision: 是? \n                                                Yes → Step 13: 返回 steps+1 // 最短步數\n                                                No  →\n                                                    → Step 14: queue.add(nextGene)\n                                                    → Step 15: visited.add(nextGene) // 標記已訪問\n                                    No → Continue\n            → Step 16: steps += 1 // 完成一層，深度加一\n        → Step 17: 返回 -1 // queue 清空仍未找到\nEnd\n\nBut need arrow format exactly: \"→ Decision: ...\". And indentation. Use spaces after arrows? It's fine. Ensure each line ends with // 解釋. We must include explanation after each line. For decisions, we need sub-lines. Use indentation: maybe two spaces or 4? The example used 4 spaces indent? They used \"    Yes → ...\". So mimic. Let's produce final.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 將 bank 轉成 Set genes // 方便 O(1) 查找\n→ Decision: endGene 是否在 genes? // 必須存在才可能轉換\n    Yes → Step 2: 初始化 queue 為 [startGene]，steps=0，visited = {startGene} // BFS 基礎\n    No  → Step 3: 返回 -1 // 無法達成\n→ Decision: startGene 是否等於 endGene? // 直接相同不需 mutation\n    Yes → Step 4: 返回 0 // 已是目標基因\n    No  →\n        → Step 5: While queue 非空 // BFS 主循環\n            → Step 6: levelSize = queue.size() // 一層深度\n            → Step 7: for i in 1..levelSize\n                → Step 8: current = queue.pop()\n                → Step 9: for pos in 0..7\n                    → Step 10: for c in ['A','C','G','T']\n                        → Decision: current[pos] 與 c 是否相同? // 避免重複字符\n                            Yes → Continue\n                            No  →\n                                → Step 11: nextGene = current[0:pos] + c + current[pos+1:] // 替換字符\n                                → Decision: nextGene 是否在 genes 且未被訪問? // 有效且未處理\n                                    Yes →\n                                        → Step 12: 若 nextGene == endGene? // 找到目標\n                                            → Decision: 是? \n                                                Yes → Step 13: 返回 steps+1 // 最短步數\n                                                No  →\n                                                    → Step 14: queue.add(nextGene)\n                                                    → Step 15: visited.add(nextGene) // 標記已訪問\n                                    No → Continue\n            → Step 16: steps += 1 // 完成一層，深度加一\n        → Step 17: 返回 -1 // queue 清空仍未找到\nEnd // 程式執行結束\n```"
    },
    {
      "title": "Find Median from Data Stream",
      "source_file": "Leetcode/leetcode295.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"], [[], [1], [2], [], [3], []]",
          "expected_output": "[null, null, null, 1.5, null, 2.0]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpbo4e3kdm.py\", line 53, in <module>\n    ops, args_list = parse_input(raw_input)\n                     ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpbo4e3kdm.py\", line 46, in parse_input\n    args = json.loads(args_part)\n           ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 337, in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 353, in raw_decode\n    obj, end = self.scan_once(s, idx)\n               ^^^^^^^^^^^^^^^^^^^^^^\njson.decoder.JSONDecodeError: Expecting ',' delimiter: line 1 column 30 (char 29)"
        }
      ],
      "generated_code": "import sys\nimport json\nimport heapq\n\nclass MedianFinder:\n    \"\"\"雙堆做法，維持小半最大堆和大半最小堆。\"\"\"\n    def __init__(self):\n        self.small = []  # max-heap（用負數實現）\n        self.large = []  # min-heap\n\n    def addNum(self, num: int) -> None:\n        \"\"\"加入一個數字，並保持兩堆大小差不超過 1。\"\"\"\n        heapq.heappush(self.small, -num)\n        # 先把 max-heap 的最大值移到 min-heap，以確保兩堆分層正確\n        if self.small and self.large and (-self.small[0] > self.large[0]):\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n\n        # 平衡兩堆大小\n        if len(self.small) > len(self.large) + 1:\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        elif len(self.large) > len(self.small):\n            val = heapq.heappop(self.large)\n            heapq.heappush(self.small, -val)\n\n    def findMedian(self) -> float:\n        \"\"\"返回目前所有數字的中位數。\"\"\"\n        if len(self.small) > len(self.large):\n            return -self.small[0]\n        else:\n            return (-self.small[0] + self.large[0]) / 2.0\n\ndef parse_input(data: str):\n    \"\"\"\n    將類似 LeetCode 的輸入格式拆成兩個列表：\n    ops   = [\"MedianFinder\", \"addNum\", ...]\n    args  = [[], [1], ...]\n    \"\"\"\n    parts = data.split('],', 1)\n    if len(parts) != 2:\n        raise ValueError(\"輸入格式錯誤\")\n    ops_part = parts[0] + ']'\n    args_part = '[' + parts[1]\n    ops = json.loads(ops_part)\n    args = json.loads(args_part)\n    return ops, args\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n    ops, args_list = parse_input(raw_input)\n\n    result = []\n    obj = None\n    for op, args in zip(ops, args_list):\n        if op == \"MedianFinder\":\n            obj = MedianFinder()\n            result.append(None)\n        elif op == \"addNum\":\n            obj.addNum(args[0])\n            result.append(None)\n        elif op == \"findMedian\":\n            med = obj.findMedian()\n            result.append(med)\n        else:\n            # 若有未知操作，跳過\n            result.append(None)\n    # 輸出 JSON 格式，None 將轉成 null\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for implementing MedianFinder class with methods. Use virtual code steps with arrows, decisions, etc. Provide step-by-step algorithm: using two heaps, max heap for lower half, min heap for upper half. Steps: addNum: push into appropriate heap, balance sizes. findMedian: if sizes equal, average of tops; else top of larger heap. We'll produce virtual code lines, each line with explanation. Ensure Start, End. Use decision for balancing. Each step should be line of virtual code. Use arrows.\n\nWe need to output lines. Let's plan:\n\nStart\n→ Step: Define class MedianFinder // class skeleton\n→ Step: Declare maxHeap // to store lower half\n→ Step: Declare minHeap // to store upper half\n→ Step: Constructor // init heaps\n\nNow addNum method:\n→ Step: If maxHeap empty or num <= maxHeap.top() then push to maxHeap else push to minHeap // decide heap\n→ Decision: If size(maxHeap) > size(minHeap)+1? // need balancing\n    Yes → Step: Move top from maxHeap to minHeap // balance\n    No →\n→ Decision: If size(minHeap) > size(maxHeap)+1?\n    Yes → Step: Move top from minHeap to maxHeap\n    No →\nReturn\n\nfindMedian method:\n→ Decision: If size(maxHeap)==size(minHeap)?\n    Yes → Step: Return (maxHeap.top()+minHeap.top())/2.0 // average\n    No →\n        Decision: If size(maxHeap)>size(minHeap)?\n            Yes → Step: Return maxHeap.top() // max heap larger\n            No → Step: Return minHeap.top() // min heap larger\nEnd\n\nAlso need to consider return type double.\n\nAdd comments. Each line ends with // explanation.\n\nLet's produce virtual code. Ensure using arrow \"→\". For decision indentation, maybe indent by tab or spaces.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step: 定義 class MedianFinder // 建立 MedianFinder 類別\n→ Step: 宣告 maxHeap: 儲存較小一半的數字，使用最大堆 (Max-Heap)\n→ Step: 宣告 minHeap: 儲存較大一半的數字，使用最小堆 (Min-Heap)\n→ Step: MedianFinder() 初始化 // 建構子，建立空堆\n    → Step: maxHeap ← 空堆 // 初始化最大堆\n    → Step: minHeap ← 空堆 // 初始化最小堆\nEnd // 建構子完成\n\nStart // addNum 方法開始\n→ Step: addNum(int num) // 將新數字加入資料結構\n    → Decision: 若 maxHeap 為空 或 num ≤ maxHeap.top()？ // 判斷應加入哪一堆\n        Yes → Step: maxHeap.push(num) // 將數字加入最大堆\n        No  → Step: minHeap.push(num) // 將數字加入最小堆\n    → Decision: 若 maxHeap.size() > minHeap.size() + 1？ // 最大堆太大，需要平衡\n        Yes → Step: minHeap.push(maxHeap.top()) // 把最大堆頂移到最小堆\n        No  →\n    → Decision: 若 minHeap.size() > maxHeap.size() + 1？ // 最小堆太大，需要平衡\n        Yes → Step: maxHeap.push(minHeap.top()) // 把最小堆頂移到最大堆\n        No  →\nEnd // addNum 方法完成\n\nStart // findMedian 方法開始\n→ Step: findMedian() // 回傳目前所有數字的中位數\n    → Decision: 若 maxHeap.size() == minHeap.size()？ // 堆大小相等\n        Yes → Step: return (maxHeap.top() + minHeap.top()) / 2.0 // 取兩堆頂平均\n        No →\n            → Decision: 若 maxHeap.size() > minHeap.size()？ // 最大堆較大\n                Yes → Step: return maxHeap.top() // 最大堆頂即為中位數\n                No  → Step: return minHeap.top() // 最小堆頂即為中位數\nEnd // findMedian 方法完成\nEnd // 程式執行結束"
    },
    {
      "title": "Zuma Game",
      "source_file": "Leetcode/leetcode488.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "board = \"WWRRBBWW\", hand = \"WRBRW\"",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '4'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '4'"
        }
      ],
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\nINF = 10 ** 9\n\ndef find_min_steps(board: str, hand: str) -> int:\n    hand_counts = Counter(hand)\n    memo = {}\n\n    def dfs(cur_board: str) -> int:\n        if not cur_board:\n            return 0\n        key = (cur_board, tuple(sorted(hand_counts.items())))\n        if key in memo:\n            return memo[key]\n\n        best = INF\n        i = 0\n        n = len(cur_board)\n        while i < n:\n            j = i\n            while j < n and cur_board[j] == cur_board[i]:\n                j += 1\n            color = cur_board[i]\n            need = 3 - (j - i)\n            if need <= 0:\n                i = j\n                continue\n            if hand_counts[color] >= need:\n                hand_counts[color] -= need\n                sub = dfs(cur_board[:i] + cur_board[j:])\n                hand_counts[color] += need\n                if sub != INF:\n                    best = min(best, sub + need)\n            i = j\n\n        memo[key] = best\n        return best\n\n    ans = dfs(board)\n    return ans if ans != INF else -1\n\n\ndef main():\n    data = sys.stdin.read()\n    if not data.strip():\n        return\n\n    # Try to parse input like: board = \"WRRBBW\", hand = \"RB\"\n    m = re.search(r'board\\s*=\\s*\"([A-Z]+)\"\\s*,\\s*hand\\s*=\\s*\"([A-Z]+)\"', data)\n    if m:\n        board = m.group(1)\n        hand = m.group(2)\n    else:\n        # Fallback: first word is board, second is hand\n        parts = data.strip().split()\n        board = parts[0]\n        hand = parts[1] if len(parts) > 1 else \"\"\n\n    result = find_min_steps(board, hand)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. It's a typical Zuma game: find minimum insertions to clear board, BFS/DFS with state: board string + hand counts. Classic Leetcode problem Zuma Game. We need algorithm: use DFS recursion with memoization, trying to insert each color that has at least one ball, at each possible position where insertion could reduce board. Use function compress to remove groups. Return min steps or -1.\n\nWe need to output virtual code steps line by line, each with explanation. We need to include Start, End, Decision, arrows. We need to describe algorithm step by step. Not actual code but virtual steps. We should include pseudo algorithm: function solve(board, hand) etc. Use recursion, backtracking, memo. Outline steps. Let's produce structured steps.\n\nWe'll do:\n\nStart\n→ Step 1: Define function minInsertions(board, handCounts) // Entry point\n→ Decision: if board empty? // base case\n    Yes → Step 2: Return 0 // no insertions needed\n    No  → Step 3: If no balls left in hand? // cannot proceed\n            Yes → Step 4: Return INF // impossible\n            No  → Step 5: Generate stateKey (board + handCounts)\n            → Decision: if stateKey in memo? // memoization\n                Yes → Step 6: Return memo[stateKey]\n                No  → Step 7: Initialize minSteps = INF\n                → Step 8: For each color in handCounts with count>0\n                    → Step 9: For each possible insertion position in board\n                        → Step 10: If insertion can create at least 3 same color in a row? // else skip\n                            → Step 11: Simulate insertion: newBoard = insertAndCollapse(board, pos, color)\n                            → Step 12: handCounts[color]--\n                            → Step 13: result = minInsertions(newBoard, handCounts)\n                            → Step 14: handCounts[color]++ // backtrack\n                            → Step 15: If result != INF\n                                → Step 16: minSteps = min(minSteps, 1 + result)\n                → Step 17: memo[stateKey] = minSteps\n                → Step 18: Return minSteps\n→ Step 19: If minSteps == INF? // no solution\n            Yes → Step 20: Return -1\n            No  → Step 21: Return minSteps\nEnd\n\nAlso include helper functions: insertAndCollapse, compress. Provide steps for them.\n\nLet's output accordingly.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 定義函式 minInsertions(board, handCount) // 入口函式，返回最小插入數\n    → Decision: 若 board 為空？ // 基本終止條件\n        Yes → Step 2: 回傳 0 // 盤面已清空，不需再插入\n        No  → Step 3: 若手牌 handCount 全為 0？ // 無法再插入球\n                Yes → Step 4: 回傳 INF // 表示無法清空\n                No  → Step 5: 產生狀態鍵 stateKey = board + handCount // 用於備忘錄\n                → Decision: 若 stateKey 已存在於 memo？ // 是否已計算過\n                    Yes → Step 6: 回傳 memo[stateKey] // 直接取記憶值\n                    No  → Step 7: 初始化 minSteps = INF // 目前最小插入數\n                    → Step 8: 對每種顏色 color，若 handCount[color] > 0？\n                        → Step 9: 對 board 的每個可插入位置 pos？\n                            → Decision: 若在 pos 插入 color 能形成 3 個以上相同顏色？ // 只嘗試有效插入\n                                Yes → Step 10: 執行 newBoard = insertAndCollapse(board, pos, color) // 插入並消除\n                                → Step 11: handCount[color] -= 1 // 用掉一顆手牌\n                                → Step 12: result = minInsertions(newBoard, handCount) // 递归求解\n                                → Step 13: handCount[color] += 1 // 回溯，恢復手牌\n                                → Decision: 若 result ≠ INF？ // 有可行解\n                                    Yes → Step 14: minSteps = min(minSteps, 1 + result) // 更新最小插入數\n                                No  → Step 15: 什麼也不做 // 此路徑失敗\n                            No  → Step 16: 什麼也不做 // 插入無效，跳過\n                        → Step 17: 所有位置嘗試完畢\n                    → Step 18: memo[stateKey] = minSteps // 記錄此狀態的最小解\n                    → Step 19: 回傳 minSteps\n→ Step 20: 若 minInsertions(board, handCount) 為 INF？ // 最終判斷是否可解\n        Yes → Step 21: 回傳 -1 // 不能清空\n        No  → Step 22: 回傳 minInsertions(board, handCount) // 返回最小插入數\nEnd // 程式執行結束\n```\n\n**說明函式 `insertAndCollapse(board, pos, color)`**  \n```\nStart // 插入並消除的子流程\n→ Step 1: 在 board[pos] 前插入 color，得到 tmpBoard\n→ Step 2: 初始化 resultBoard = tmpBoard\n→ Step 3: 重複執行 collapseLoop：\n        → Decision: 在 resultBoard 中是否存在 3 個以上連續相同顏色的子串？\n            Yes → Step 4: 刪除該子串，更新 resultBoard\n            No  → Step 5: 跳出 collapseLoop\n→ Step 6: 回傳 resultBoard // 所有連鎖消除完成後的盤面\nEnd // 子流程結束\n```\n\n**說明函式 `collapseLoop`**  \n```\nStart\n→ Step 1: 從左到右掃描 resultBoard，找出相同顏色的連續區段\n→ Step 2: 若區段長度 ≥ 3，標記該區段\n→ Step 3: 如果沒有區段被標記，跳出\n→ Step 4: 刪除所有被標記的區段，形成新的 resultBoard\n→ Step 5: 重複 Step 1 // 可能再次產生連鎖\nEnd\n```\n\n以上虛擬碼以結構化步驟呈現了 Zuma 變種版的「最小插入」問題的完整演算法，包含遞迴、備忘錄、插入與消除邏輯，並逐行附上簡短直觀說明。"
    },
    {
      "title": "Intersection of Two Arrays II",
      "source_file": "Leetcode/leetcode350.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "nums1 = [4,9,5], nums2 = [9,4,9,8,4]",
          "expected_output": "[4,9]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[4,9]'\nGot (Norm):      '[9,4]'\n--- (Raw) ---\nRaw Expected: '[4,9]'\nRaw Got:      '[9, 4]'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import Counter\n\nclass Solution:\n    def intersect(self, nums1, nums2):\n        \"\"\"Return the intersection of two integer lists, keeping multiplicities.\"\"\"\n        count1 = Counter(nums1)\n        result = []\n        for num in nums2:\n            if count1.get(num, 0) > 0:\n                result.append(num)\n                count1[num] -= 1\n        return result\n\ndef parse_input(data: str):\n    \"\"\"Parse stdin data into two integer lists.\"\"\"\n    # Try to find list literals in the input string\n    list_strings = re.findall(r'\\[.*?\\]', data, flags=re.DOTALL)\n    if len(list_strings) >= 2:\n        nums1 = ast.literal_eval(list_strings[0])\n        nums2 = ast.literal_eval(list_strings[1])\n    else:\n        # Fallback: split by lines and parse each line as a list\n        lines = [line.strip() for line in data.strip().splitlines() if line.strip()]\n        if len(lines) >= 2:\n            nums1 = ast.literal_eval(lines[0])\n            nums2 = ast.literal_eval(lines[1])\n        else:\n            # If only one list is provided, assume the other is empty\n            nums1 = ast.literal_eval(lines[0]) if lines else []\n            nums2 = []\n    return nums1, nums2\n\nif __name__ == \"__main__\":\n    raw_data = sys.stdin.read()\n    nums1, nums2 = parse_input(raw_data)\n    sol = Solution()\n    intersection = sol.intersect(nums1, nums2)\n    print(intersection)",
      "virtual_code": "Thinking...\nWe need to produce virtual code in the specified format, with explanation comments. No actual code, just pseudo steps. Use arrows etc. Must be line by line. The task: given two integer arrays nums1 and nums2, return intersection array with multiplicities. We can approach: use hash map to count occurrences in nums1, then iterate nums2, if count>0 add to result and decrement. We'll produce pseudo code steps.\n\nEnsure Start, End markers, Decision lines.\n\nLet's draft:\n\nStart // program start\n→ Step 1: Initialize mapCount = empty map // store frequencies from nums1\n→ Step 2: For each num in nums1: // populate map\n    → Step 3: mapCount[num] += 1\n→ Step 4: Initialize result = empty list // store intersection\n→ Step 5: For each num in nums2:\n    → Decision: If mapCount contains num and mapCount[num] > 0? // check if num available\n        Yes → Step 6: Append num to result\n        Yes → Step 7: Decrement mapCount[num] by 1\n        No  → // do nothing\n→ End // return result\n\nNeed to embed decision inside loops? We'll do Decision inside loop, but need arrow alignment.\n\nPseudo code with arrows:\n\nStart\n→ Step 1: Create empty mapCount // count of nums1\n→ Step 2: For each element x in nums1\n    → Step 3: mapCount[x] = mapCount.get(x, 0) + 1\n→ Step 4: Create empty list result // store intersection\n→ Step 5: For each element y in nums2\n    → Decision: mapCount contains y and mapCount[y] > 0? // is y in map with positive count\n        Yes → Step 6: Append y to result\n        Yes → Step 7: mapCount[y] = mapCount[y] - 1\n        No  → // nothing\nEnd\n\nBut we need to maintain syntax: Use arrow \"→\" for sequential. For Decision: we indent. We need to ensure each line is a separate pseudo code line with explanation.\n\nLet's craft each line:\n\nStart // 程式開始執行\n→ Step 1: Initialize mapCount = {} // 建立一個空字典用於存放 nums1 中每個數字的頻率\n→ Step 2: For each num in nums1: // 遍歷 nums1 以統計頻率\n    → Step 3: mapCount[num] = mapCount.get(num, 0) + 1 // 將 num 的計數增加 1\n→ Step 4: Initialize result = [] // 建立一個空列表用於儲存交集結果\n→ Step 5: For each num in nums2: // 遍歷 nums2 以找出交集\n    → Decision: mapCount contains num AND mapCount[num] > 0? // 檢查 num 是否在 mapCount 且計數未用完\n        Yes → Step 6: Append num to result // 將 num 加入結果\n        Yes → Step 7: mapCount[num] = mapCount[num] - 1 // 減少該數字的計數\n        No  → // 不符合條件，直接跳過\nEnd // 程式執行結束\n\nNeed to ensure each line has a single virtual code step with explanation after //. The Decision block has sub-steps lines but we need to keep them as separate lines with indentation. Use arrow for Yes, No lines.\n\nCheck format: Each line must contain \"虛擬碼步驟\" + space + \"// 解釋/說明\".\n\nSo e.g.,\n\nStart // 程式開始執行\n\n→ Step 1: Initialize mapCount = {} // 建立一個空字典用於存放 nums1 中每個數字的頻率\n\nWe have arrow, space, colon, then explanation after //. Good.\n\nFor Decision line:\n\n→ Decision: mapCount contains num AND mapCount[num] > 0? // 檢查 num 是否在 mapCount 且計數未用完\n\nThen indent Yes → Step 6: ... etc.\n\nWe need to maintain indentation spaces maybe two spaces for nested? The example uses tabs maybe. Use 4 spaces? The example shows indentation of 4 spaces after Decision. Use 4 spaces before Yes arrow. We'll maintain 4 spaces indentation.\n\nThus produce final answer.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Initialize mapCount = {} // 建立一個空字典用於存放 nums1 中每個數字的頻率  \n→ Step 2: For each num in nums1: // 遍歷 nums1 以統計頻率  \n    → Step 3: mapCount[num] = mapCount.get(num, 0) + 1 // 將 num 的計數增加 1  \n→ Step 4: Initialize result = [] // 建立一個空列表用於儲存交集結果  \n→ Step 5: For each num in nums2: // 遍歷 nums2 以找出交集  \n    → Decision: mapCount contains num AND mapCount[num] > 0? // 檢查 num 是否在 mapCount 且計數未用完  \n        Yes → Step 6: Append num to result // 將 num 加入結果  \n        Yes → Step 7: mapCount[num] = mapCount[num] - 1 // 減少該數字的計數  \n        No  → // 不符合條件，直接跳過  \nEnd // 程式執行結束"
    },
    {
      "title": "Complex Number Multiplication",
      "source_file": "Leetcode/leetcode537.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "\"1+-1i\", \"1+-1i\"",
          "expected_output": "\"0+-2i\"",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpeq36vomy.py\", line 41, in <module>\n    main()\n  File \"/tmp/tmpeq36vomy.py\", line 37, in main\n    result = multiply_complex(num1, num2)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpeq36vomy.py\", line 13, in multiply_complex\n    a_real, a_imag = parse_complex(a)\n                     ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpeq36vomy.py\", line 8, in parse_complex\n    raise ValueError(f\"Invalid complex number format: {s}\")\nValueError: Invalid complex number format: 1+-1i"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef parse_complex(s: str) -> tuple[int, int]:\n    \"\"\"將複數字串解析為 (實部, 虛部)。\"\"\"\n    m = re.match(r'^([+-]?\\d+)([+-]\\d+)i$', s)\n    if not m:\n        raise ValueError(f\"Invalid complex number format: {s}\")\n    return int(m.group(1)), int(m.group(2))\n\ndef multiply_complex(a: str, b: str) -> str:\n    \"\"\"計算兩個複數相乘並回傳字串。\"\"\"\n    a_real, a_imag = parse_complex(a)\n    b_real, b_imag = parse_complex(b)\n    real_part = a_real * b_real - a_imag * b_imag\n    imag_part = a_real * b_imag + a_imag * b_real\n    return f\"{real_part}+{imag_part}i\"\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入，支援「\"a+bi\", \"c+di\"」或兩行各一個複數\n    if ',' in data:\n        parts = [p.strip() for p in data.split(',')]\n    else:\n        parts = [p.strip() for p in data.split()]\n        if len(parts) < 2:\n            parts = [p.strip() for p in data.splitlines()]\n\n    if len(parts) < 2:\n        raise ValueError(\"Input must contain two complex numbers\")\n\n    num1 = parts[0].strip('\"').strip(\"'\")\n    num2 = parts[1].strip('\"').strip(\"'\")\n    result = multiply_complex(num1, num2)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. The user wants: \"Given two complex numbers num1 and num2 as strings, return a string of the complex number that represents their multiplications.\" So we need algorithm: parse string into real1, imag1, parse num2 similarly. Multiply: (a+bi)*(c+di) = (ac - bd) + (ad + bc)i. Output string \"real+imaginaryi\". Need handle negative imaginary part? The output format is \"real+imaginaryi\" but if imaginary negative? Usually \"real+imaginaryi\" with minus sign included: e.g., \"1-2i\". So we can just convert to string: realPart + (imagPart>=0? \"+\" : \"\") + imagPart + \"i\".\n\nWe need virtual code step-by-step, using the arrow and decision format. We need to produce each line as \"虛擬碼步驟 // 解釋\". Let's craft steps.\n\nStart: Begin program.\n\nStep 1: Input num1, num2 as strings.\n\nStep 2: Parse num1 into real1, imag1 using parseComplex function.\n\nBut we may break parseComplex into steps: find 'i', split at '+' or '-', etc.\n\nSimplify: we can parse by locating last '+' or '-' before 'i' to separate real and imaginary.\n\nBut we can also use regex? but we cannot output actual code; just steps.\n\nWe need to decide: Step 2a: Extract real1 and imag1 from num1.\n\nStep 2b: Similarly for num2.\n\nThen Step 3: Compute realResult = real1*real2 - imag1*imag2.\n\nStep 4: Compute imagResult = real1*imag2 + imag1*real2.\n\nStep 5: Format result string.\n\nStep 6: Return result.\n\nNeed to include decisions? e.g., Decision: if imagResult negative? But formatting handles sign.\n\nMaybe also Decision: if input string contains '-', but we handle negative.\n\nCould produce a Decision: If imaginary part extracted includes '-'? But we can handle in parse.\n\nSimplify: Use parseComplex steps: find position of 'i', slice before i, find index of last '+' or '-' not at start, split.\n\nAlso handle negative real part: e.g., \"-1+2i\". The '-' at start indicates negative real. Need to find sign before imaginary part. So we find the last occurrence of '+' or '-' after the first character. Use that to split.\n\nBut we can simply state in step: Find index of '+' or '-' that separates real and imag. Use that to parse.\n\nOk.\n\nWe also need to ensure we comply with \"逐行\" each line with code and comment.\n\nLet's produce:\n\nStart\n\n→ Step 1: 取得輸入字串 num1, num2 // 取得兩個複數字串\n\n→ Step 2: 呼叫 parseComplex(num1) 取得 real1, imag1 // 解析第一個複數\n\n→ Step 3: 呼叫 parseComplex(num2) 取得 real2, imag2 // 解析第二個複數\n\n→ Step 4: 計算 realPart = real1 * real2 - imag1 * imag2 // 實部乘法規則\n\n→ Step 5: 計算 imagPart = real1 * imag2 + imag1 * real2 // 虛部乘法規則\n\n→ Step 6: 呼叫 formatComplex(realPart, imagPart) 產生字串 // 格式化輸出\n\n→ Step 7: 回傳結果字串 // 回傳最終複數字串\n\nEnd\n\nBut we need to include virtual code syntax with arrows and decisions. But parseComplex can be broken into steps:\n\nDecision: If string contains '-' at position >0? But we can keep simple.\n\nWe can show parseComplex as:\n\n→ Function parseComplex(s):\n\n    → 找到字串中最後一次出現 '+' 或 '-' (不包括字串首位) 的位置 // 分離實部與虛部\n\n    → 取 substr 前段為 realStr, 後段去掉 'i' 為 imagStr // 處理分隔\n\n    → 轉換 realStr、imagStr 為整數 // 取得數值\n\n    → 回傳 real, imag\n\nBut we need to show as separate steps maybe.\n\nLet's produce overall algorithm steps, but also include parseComplex subroutine.\n\nThe user expects a step-by-step. So we might include subroutine steps inside main.\n\nWe'll present:\n\nStart\n\n→ Step 1: Input num1, num2 // 取得兩個複數字串\n\n→ Step 2: 呼叫 parseComplex(num1) 取得 real1, imag1 // 解析第一個複數\n\n→ Step 3: 呼叫 parseComplex(num2) 取得 real2, imag2 // 解析第二個複數\n\n→ Step 4: 計算 realPart = real1 * real2 - imag1 * imag2 // 實部乘法規則\n\n→ Step 5: 計算 imagPart = real1 * imag2 + imag1 * real2 // 虛部乘法規則\n\n→ Step 6: 呼叫 formatComplex(realPart, imagPart) 取得 resultStr // 格式化輸出\n\n→ Step 7: 回傳 resultStr // 返回最終結果\n\nEnd\n\nThen we need to detail parseComplex and formatComplex as separate virtual code blocks maybe, but they also need to be in the same output. We can embed them after the main steps.\n\nBut requirement: \"逐行輸出\" means each line in the output must contain virtual code step with comment. We can separate subfunctions as blocks.\n\nSo we can write:\n\nStart\n\n→ Step 1: 取得 num1, num2 // 讀取輸入複數字串\n\n...\n\nThen after End, we can define functions? But might be separate? The spec didn't forbid. But we can include as part of overall flow.\n\nBut we need to maintain the arrow indentation: For subfunctions, we can indent lines.\n\nThe spec: Use 虛擬碼的箭頭 (`→`, `Yes →`, `No →`) and結構 (`Start`, `End`, `Decision:`). So we need to show decisions if any. We might use decision inside parseComplex: If s starts with '-', but that's handled by split.\n\nBetter: Use Decision: If s contains '-' as separator? But we can skip.\n\nSimplify: Provide subroutine parseComplex as separate block with steps.\n\nLet's produce final output:\n\nStart // 程式開始執行\n\n→ Step 1: 取得輸入字串 num1, num2 // 讀取兩個複數字串\n\n→ Step 2: 呼叫 parseComplex(num1) 取得 real1, imag1 // 解析第一個複數\n\n→ Step 3: 呼叫 parseComplex(num2) 取得 real2, imag2 // 解析第二個複數\n\n→ Step 4: 計算 realPart = real1 * real2 - imag1 * imag2 // 實部計算\n\n→ Step 5: 計算 imagPart = real1 * imag2 + imag1 * real2 // 虛部計算\n\n→ Step 6: 呼叫 formatComplex(realPart, imagPart) 取得 resultStr // 組成輸出字串\n\n→ Step 7: 回傳 resultStr // 返回結果\n\nEnd // 程式執行結束\n\n// Subroutine: parseComplex\n\nStart parseComplex // 解析複數字串\n\n→ Decision: 找到最後一次 '+' 或 '-'（不在首位） // 確定實部與虛部分隔點\n\n    Yes → 取得分隔索引 idx // idx 為分隔符位置\n\n→ Step 1: realStr = s.substring(0, idx) // 取實部子字串\n\n→ Step 2: imagStr = s.substring(idx, s.length - 1) // 取虛部子字串（去掉 'i'）\n\n→ Step 3: real = parseInt(realStr) // 轉整數\n\n→ Step 4: imag = parseInt(imagStr) // 轉整數\n\n→ Step 5: 回傳 real, imag // 結果返回\n\nEnd parseComplex\n\n// Subroutine: formatComplex\n\nStart formatComplex // 將數值組成複數字串\n\n→ Step 1: 如果 imagPart >= 0\n\n    Yes → result = realPart + \"+\" + imagPart + \"i\" // 正號格式\n\n    No  → result = realPart + imagPart + \"i\" // 負號已在 imagPart 中\n\n→ Step 2: 回傳 result // 結果返回\n\nEnd formatComplex\n\nBut we need to keep \"逐行\" meaning each line must have the pattern: 虛擬碼步驟 [space] // 解釋. So each line must contain code and comment.\n\nWe need to include decisions with \"Decision:\" lines and Yes → and No →.\n\nThus we should format accordingly.\n\nLet's rewrite carefully.\n\nWe need to use arrow \"→\" for steps.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Step 1: 讀取輸入字串 num1, num2 // 取得兩個複數字串\n→ Step 2: 呼叫 parseComplex(num1) 取得 real1, imag1 // 解析第一個複數\n→ Step 3: 呼叫 parseComplex(num2) 取得 real2, imag2 // 解析第二個複數\n→ Step 4: 計算 realPart = real1 * real2 - imag1 * imag2 // 實部乘法\n→ Step 5: 計算 imagPart = real1 * imag2 + imag1 * real2 // 虛部乘法\n→ Step 6: 呼叫 formatComplex(realPart, imagPart) 取得 resultStr // 產生輸出字串\n→ Step 7: 回傳 resultStr // 返回最終結果\nEnd // 程式結束執行\n\nNow subroutine parseComplex:\n\nStart parseComplex // 解析複數字串\n→ Decision: 找到最後一次 '+' 或 '-'（不在首位） // 確定分隔符\n    Yes → Step 1: 設定 idx = 分隔符位置 // 分隔點索引\n→ Step 2: realStr = s.substring(0, idx) // 取得實部字串\n→ Step 3: imagStr = s.substring(idx, s.length - 1) // 取得虛部字串（去掉 i）\n→ Step 4: real = parseInt(realStr) // 轉整數\n→ Step 5: imag = parseInt(imagStr) // 轉整數\n→ Step 6: 回傳 real, imag // 返回解析結果\nEnd parseComplex // 子程序結束\n\nSimilarly formatComplex:\n\nStart formatComplex // 組成複數字串\n→ Decision: imagPart >= 0 // 判斷符號\n    Yes → Step 1: result = realPart + \"+\" + imagPart + \"i\" // 正號\n    No  → Step 1: result = realPart + imagPart + \"i\" // 負號已在 imagPart\n→ Step 2: 回傳 result // 返回格式化字串\nEnd formatComplex // 子程序結束\n\nHowever, note the requirement: \"每行必須包含：虛擬碼步驟 + [空格] + // 解釋/說明\" So each line must have code then space then comment. In decisions, the \"Decision:\" line also counts as code. Then we need to indent \"Yes →\" and \"No →\" lines with maybe spaces? Should be each line separate.\n\nAlso we need to keep the arrow \"→\" at start of each step. For decisions, we use \"Decision:\" but we need an arrow? Example: \"Decision: 如果數字大於 0?\" So we can write \"Decision: 如果數字大於 0?\" with comment. But we also need \"Yes →\" and \"No →\" lines.\n\nThus, we can produce:\n\nDecision: 找到最後一次 '+' 或 '-'（不在首位） // 確定分隔符\n\n    Yes → Step 1: idx = 分隔符位置 // 分隔點索引\n\nBut each line should start with either \"Decision:\" or \"→\". For indent lines, maybe we indent with spaces. But to be safe, each line still begins with the code token. We'll put a leading tab for indent but it's still part of line. But the spec: \"每行必須包含：虛擬碼步驟 + [空格] + // 解釋/說明\" So we can have \"    Yes → Step 1: ...\" but that's fine.\n\nWe must ensure each line has code and comment. For \"Decision:\" lines, we can have comment after it. For \"Yes →\" and \"No →\" lines, we also add comment.\n\nLet's write final output.\n\nBut we also need to show the final result string formation inside formatComplex; for negative imag we just concatenate; but we must ensure that negative sign appears properly. For example imag = -5 => imagPart + \"i\" gives \"-5i\". So formatComplex code is good.\n\nLet's craft final output.\n\nWe need to output all lines. Ensure we use correct Chinese characters.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 讀取輸入字串 num1, num2 // 取得兩個複數字串\n→ Step 2: 呼叫 parseComplex(num1) 取得 real1, imag1 // 解析第一個複數\n→ Step 3: 呼叫 parseComplex(num2) 取得 real2, imag2 // 解析第二個複數\n→ Step 4: 計算 realPart = real1 * real2 - imag1 * imag2 // 實部乘法規則\n→ Step 5: 計算 imagPart = real1 * imag2 + imag1 * real2 // 虛部乘法規則\n→ Step 6: 呼叫 formatComplex(realPart, imagPart) 取得 resultStr // 組成輸出字串\n→ Step 7: 回傳 resultStr // 返回最終結果\nEnd // 程式結束執行\n\nStart parseComplex // 解析複數字串\nDecision: 找到最後一次 '+' 或 '-'（不在首位） // 確定實部與虛部分隔符\n    Yes → Step 1: idx = 分隔符位置 // 分隔點索引\n→ Step 2: realStr = s.substring(0, idx) // 取得實部子字串\n→ Step 3: imagStr = s.substring(idx, s.length - 1) // 取得虛部子字串（去掉 'i'）\n→ Step 4: real = parseInt(realStr) // 轉成整數\n→ Step 5: imag = parseInt(imagStr) // 轉成整數\n→ Step 6: 回傳 real, imag // 返回解析結果\nEnd parseComplex // 子程序結束\n\nStart formatComplex // 組成複數字串\nDecision: imagPart >= 0 // 判斷虛部符號\n    Yes → Step 1: result = realPart + \"+\" + imagPart + \"i\" // 虛部為正，加入 '+' 符號\n    No  → Step 1: result = realPart + imagPart + \"i\" // 虛部為負，直接連接\n→ Step 2: 回傳 result // 返回格式化字串\nEnd formatComplex // 子程序結束"
    },
    {
      "title": "Implement Rand10() Using Rand7()",
      "source_file": "Leetcode/leetcode470.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 1",
          "expected_output": "[2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2]'\nGot (Norm):      '[9]'\n--- (Raw) ---\nRaw Expected: '[2]'\nRaw Got:      '[9]'"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[2,8]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,8]'\nGot (Norm):      '[1,10]'\n--- (Raw) ---\nRaw Expected: '[2,8]'\nRaw Got:      '[1, 10]'"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "[3,8,10]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,8,10]'\nGot (Norm):      '[6,2,7]'\n--- (Raw) ---\nRaw Expected: '[3,8,10]'\nRaw Got:      '[6, 2, 7]'"
        }
      ],
      "generated_code": "import os\nimport sys\nimport re\n\n# 隨機產生 1~7 的函式，使用 OS 隨機字節，避免使用內建 random API\ndef rand7() -> int:\n    return (int.from_bytes(os.urandom(1), 'little') % 7) + 1\n\nclass Solution:\n    # 產生 1~10 的隨機數，利用 rand7 並進行拒絕採樣\n    def rand10(self) -> int:\n        while True:\n            # 兩次 rand7 組合成 1~49 的均勻分布\n            num = (rand7() - 1) * 7 + rand7()  # 1~49\n            if num <= 40:                     # 只保留 1~40，確保均勻映射到 1~10\n                return 1 + (num - 1) % 10\n\ndef main() -> None:\n    # 讀取所有輸入\n    data = sys.stdin.read()\n    # 從輸入中找第一個整數（假設輸入類似 \"n = 3\"）\n    match = re.search(r'\\d+', data)\n    if not match:\n        return\n    n = int(match.group())\n    sol = Solution()\n    results = [sol.rand10() for _ in range(n)]\n    print(results)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code lines step by step for generating rand10 from rand7. Approach: Use rejection sampling: generate 2 rand7 values to produce range 1-49, reject >40, map to 1-10. Or use 3 rand7 to get 1-343. Simpler: use 2 rand7: produce 1-49 by (a-1)*7 + b. If >40 reject. Then output (result-1)%10 +1.\n\nSo steps: Start. Step: generate a = rand7(); Step: generate b=rand7(); Step: compute x = (a-1)*7 + b; Decision: if x <=40? Yes: Step: return (x-1)%10 +1. No: Go back to start (rejection loop). End.\n\nWe need to show virtual code lines with explanation. Use arrows.\n\nWe must use only Start, End, Decision, Step. Use arrow for branching.\n\nLet's produce:\n\nStart // 程式開始\n\n→ Step 1: a ← rand7() // 取得第一個隨機數\n\n→ Step 2: b ← rand7() // 取得第二個隨機數\n\n→ Step 3: x ← (a - 1) * 7 + b // 將兩個數合併成 1~49\n\n→ Decision: 如果 x ≤ 40? // 只保留 1~40 的有效範圍\n\n    Yes → Step 4: return (x - 1) mod 10 + 1 // 轉換為 1~10\n\n    No → Go back to Step 1 // 重試\n\nEnd // 程式結束\n\nWe need each line with // explanation.\n\nWe need to ensure format: \"虛擬碼步驟 [空格] // 解釋\". For decisions, indent accordingly.\n\nLet's output exactly.\n\nBe careful: Each line starts with either Start, → Step..., → Decision..., etc.\n\nNeed to keep \"→\" arrow.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: a ← rand7() // 取得第一個隨機數，範圍為 1~7  \n→ Step 2: b ← rand7() // 取得第二個隨機數，範圍為 1~7  \n→ Step 3: x ← (a - 1) * 7 + b // 組合成 1~49 的隨機數  \n→ Decision: 如果 x ≤ 40? // 只保留 1~40 的有效範圍，以便均勻映射到 1~10  \n    Yes → Step 4: return (x - 1) mod 10 + 1 // 把 1~40 轉換為 1~10，並返回結果  \n    No → Step 1 // 如果 x > 40，丟棄並重新開始，重新產生 a, b  \nEnd // 程式執行結束"
    },
    {
      "title": "Evaluate Division",
      "source_file": "Leetcode/leetcode399.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]",
          "expected_output": "[6.00000,0.50000,-1.00000,1.00000,-1.00000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpsr1l3j8h.py\", line 41, in <module>\n    equations = ast.literal_eval(eq_match.group(1))\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[\"a\",\"b\"]\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1.5,2.5,5.0], queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]",
          "expected_output": "[3.75000,0.40000,5.00000,0.20000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpw85dv9jn.py\", line 41, in <module>\n    equations = ast.literal_eval(eq_match.group(1))\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[\"a\",\"b\"]\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 2,
          "input": "equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]",
          "expected_output": "[0.50000,2.00000,-1.00000,-1.00000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpq1nk_r_4.py\", line 41, in <module>\n    equations = ast.literal_eval(eq_match.group(1))\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[\"a\",\"b\"]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def calcEquation(self, equations, values, queries):\n        graph = defaultdict(dict)\n        for (a, b), val in zip(equations, values):\n            graph[a][b] = val\n            graph[b][a] = 1.0 / val\n\n        def dfs(src, dst, visited):\n            if src not in graph or dst not in graph:\n                return -1.0\n            if src == dst:\n                return 1.0\n            visited.add(src)\n            for neighbor, weight in graph[src].items():\n                if neighbor not in visited:\n                    res = dfs(neighbor, dst, visited)\n                    if res != -1.0:\n                        return weight * res\n            return -1.0\n\n        results = []\n        for u, v in queries:\n            results.append(dfs(u, v, set()))\n        return results\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    eq_match = re.search(r'equations\\s*=\\s*(\\[[^\\]]*\\])', data)\n    val_match = re.search(r'values\\s*=\\s*(\\[[^\\]]*\\])', data)\n    qry_match = re.search(r'queries\\s*=\\s*(\\[[^\\]]*\\])', data)\n\n    if not (eq_match and val_match and qry_match):\n        print(\"[]\")\n        sys.exit()\n\n    equations = ast.literal_eval(eq_match.group(1))\n    values = ast.literal_eval(val_match.group(1))\n    queries = ast.literal_eval(qry_match.group(1))\n\n    solution = Solution()\n    ans = solution.calcEquation(equations, values, queries)\n    formatted = \"[\" + \",\".join(f\"{x:.5f}\" for x in ans) + \"]\"\n    print(formatted)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, line by line, with comments. The problem is the \"Evaluate Division\" Leetcode problem. We need to produce pseudocode: building graph, BFS/DFS to answer queries, handle missing variables. The output should be line by line: Start, Build graph, For each query, check existence, run DFS, produce result or -1.0, End.\n\nWe should not output actual code, only virtual code with arrows. Use \"→\" for steps, \"Decision:\" lines, \"Yes →\", \"No →\". Provide explanation after each line.\n\nLet's design steps:\n\n1. Start // Start execution\n2. Build graph: adjacency list from equations to neighbors with weight values. Use dictionary mapping variable -> list of (neighbor, weight). (maybe using loop over equations). Provide line: \"→ Build graph from equations\" // Build adjacency.\n\n3. Process queries: For each query in queries list: Check if both variables exist in graph; if not, answer -1.0; else run DFS to find ratio. Use stack or queue; maintain visited set; accumulate product along path.\n\n4. For each query, maybe use \"Decision: 如果 Cj 和 Dj 都在圖中?\" // check existence.\n\n5. If yes, start DFS: \"→ DFS(Cj, Dj, visited, product)\" // search.\n\n6. In DFS: if current==target, return product; else explore neighbors not visited; multiply weight.\n\n7. If DFS finds result, record; else -1.0.\n\nFinally, End.\n\nWe need to show step-by-step lines.\n\nWe should use indentation? In example, they used indent for nested decisions.\n\nLet's produce virtual code:\n\nStart\n→ Build adjacency graph from equations and values\n    Decision: For each equation Ai/Bi = val\n        Yes → Add edge Ai -> Bi weight val\n        Yes → Add edge Bi -> Ai weight 1/val\n→ Initialize answers list\n→ For each query [C, D] in queries\n    Decision: If C or D not in graph?\n        Yes → Append -1.0 to answers\n        No  → Decision: If C == D?\n            Yes → Append 1.0 to answers\n            No  → Decision: Find ratio via DFS\n                Yes → Call DFS(C, D, visited, product=1)\n                    Decision: If DFS returns value?\n                        Yes → Append value to answers\n                        No  → Append -1.0 to answers\nEnd\n\nBut we need more details. We need to produce each line separately, with explanation comment. Use \"→\" arrow for each step.\n\nLet's produce a list:\n\n1. Start // 程式開始執行\n2. → Build graph // 建立變數之間的鄰接關係\n3. → For i in 0 .. equations.size-1 // 逐個處理方程式\n4.    Decision: 以 Ai/Bi = values[i] 產生雙向邊\n5.        Yes → Add edge Ai -> Bi weight values[i]\n6.        Yes → Add edge Bi -> Ai weight 1/values[i]\n7. → 初始化答案列表 // 用來儲存每個查詢結果\n8. → For each query [C, D] in queries // 逐個處理查詢\n9.    Decision: C 或 D 是否不在 graph?\n10.       Yes → Append -1.0 // 無法計算\n11.       No  → Decision: C == D?\n12.           Yes → Append 1.0 // 相同變數比值為 1\n13.           No  → Call DFS to find ratio\n14.              → DFS(current, target, visited, product) // 遞迴搜尋\n15.              Decision: current == target?\n16.                 Yes → Return product // 找到路徑\n17.                 No  → For each neighbor in graph[current]\n18.                    Decision: neighbor 未訪問過?\n19.                       Yes → Call DFS(neighbor, target, visited, product * weight)\n20.                           Decision: 子遞迴返回值是否有效?\n21.                               Yes → Return 值\n22.                               No  → 連續搜尋下一個鄰居\n23.                 No → Return 無效值\n24.          Decision: DFS 返回值有效?\n25.              Yes → Append 值\n26.              No  → Append -1.0\n27. End // 程式結束\n\nBut we need to use \"→\" for each line and \"Decision:\" for decisions. Also we need indentation maybe. We can use indentation as in example: 4 spaces. We need to produce each line individually. Use explanation after //.\n\nLet's craft final output accordingly. Ensure each line ends with comment.\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Build graph // 建立變數之間的鄰接關係\n    → For i from 0 to equations.size-1 // 逐個處理方程式\n        Decision: Ai/Bi = values[i] // 決定要為雙向邊加入兩個方向\n            Yes → Add edge Ai → Bi with weight values[i] // Ai/Bi = val\n            Yes → Add edge Bi → Ai with weight 1/values[i] // 反向比值\n→ Initialize answers list // 用來儲存每個查詢結果\n→ For each query [C, D] in queries // 逐個處理查詢\n    Decision: C 或 D 是否不在 graph? // 判斷變數是否已知\n        Yes → Append -1.0 to answers // 無法計算，直接回傳 -1.0\n        No  → Decision: C == D? // 同一變數比值為 1\n            Yes → Append 1.0 to answers // 相同變數比值為 1\n            No  → Decision: 找到比值需要搜尋圖\n                Yes → Call DFS(C, D, visited = {}, product = 1.0) // 遞迴搜尋\n                    → DFS(current, target, visited, product)\n                        Decision: current == target? // 找到目標\n                            Yes → Return product // 成功找到路徑\n                            No  → Decision: 循環所有鄰接節點\n                                → For each (neighbor, weight) in graph[current]\n                                    Decision: neighbor 未訪問過? // 防止循環\n                                        Yes → Mark neighbor 為 visited\n                                        Yes → Call DFS(neighbor, target, visited, product * weight) // 繼續搜尋\n                                            Decision: 子遞迴返回值是否有效? // 判斷是否找到路徑\n                                                Yes → Return 值 // 路徑成功\n                                                No  → Continue 迴圈尋找下一個鄰居\n                                    No  → 連續尋找下一個鄰居\n                                No  → Return 無效值 // 所有鄰居都沒路徑\n                    Decision: DFS 返回值有效? // 判斷搜尋結果\n                        Yes → Append 值到 answers // 找到比值\n                        No  → Append -1.0 to answers // 沒有可行路徑\nEnd // 程式執行結束\n```"
    },
    {
      "title": "Concatenated Words",
      "source_file": "Leetcode/leetcode472.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "words = [\"cat\",\"cats\",\"catsdogcats\",\"dog\",\"dogcatsdog\",\"hippopotamuses\",\"rat\",\"ratcatdogcat\"]",
          "expected_output": "[\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]'\nGot (Norm):      '[\"dogcatsdog\",\"catsdogcats\",\"ratcatdogcat\"]'\n--- (Raw) ---\nRaw Expected: '[\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]'\nRaw Got:      \"['dogcatsdog', 'catsdogcats', 'ratcatdogcat']\""
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findAllConcatenatedWordsInADict(self, words):\n        # 按字長升序排序，保證「短詞」已先處理\n        words.sort(key=len)\n        # 已處理過的短詞集合\n        shorter_set = set()\n        res = []\n\n        # 判斷是否能由已存在的單字組合而成\n        def can_form(word):\n            n = len(word)\n            dp = [False] * (n + 1)\n            dp[0] = True  # 空字可「組合」\n            for i in range(1, n + 1):\n                for j in range(i):\n                    if dp[j] and word[j:i] in shorter_set:\n                        dp[i] = True\n                        break\n            return dp[n]\n\n        for w in words:\n            if not w:\n                continue\n            if can_form(w):\n                res.append(w)\n            shorter_set.add(w)\n        return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 取得第一個 '[' 到最後一個 ']' 之間的字串並解析成列表\n    start = data.find('[')\n    end = data.rfind(']') + 1\n    if start == -1 or end == -1:\n        # 若輸入不包含列表，直接輸出空列表\n        print([])\n        return\n    list_str = data[start:end]\n    try:\n        words = ast.literal_eval(list_str)\n    except Exception:\n        # 解析失敗時輸出空列表\n        print([])\n        return\n\n    sol = Solution()\n    result = sol.findAllConcatenatedWordsInADict(words)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output pseudocode line-by-line with explanations. The requirement: return all concatenated words in the list. Need to process words sorted by length maybe. Use Trie or DP. Use set for lookup. For each word, check if can be formed by other words (not using itself). DP: for word, iterate splits; use DP array. Also can skip word itself when building set? Approach: sort words by length ascending. Use a set of words processed so far (shorter). For each word, check if concatenated using set. If yes, add to result. After checking, add word to set. Use DP.\n\nNow produce pseudocode lines. Each line: \"虛擬碼步驟 // 解釋\". Use arrow '→', 'Decision:', 'Start', 'End'.\n\nLet's craft.\n\nStart\n\n→ Sort words by length ascending // 以字長升序排列，保證短詞先處理\n\n→ Initialize set `shorterSet` empty // 存放已處理的短詞，供查詢\n\n→ Initialize result list `concatenatedWords` empty // 存放符合條件的單字\n\n→ For each word `w` in words // 遍歷每個單字\n\n    → If canConcatenate(w, shorterSet) // 判斷 w 是否由 shorterSet 中的單字組成\n\n        Yes → Add w to concatenatedWords // 符合條件，加入結果\n\n    → Add w to shorterSet // 無論是否合併，將 w 加入集合供後續使用\n\n→ Return concatenatedWords // 回傳所有連接詞\n\nNow define canConcatenate function:\n\n→ Define function canConcatenate(word, dict) // 檢查 word 是否可由 dict 內單字組成\n\n    → Initialize DP array of size len(word)+1 with false // DP[i] 表示前 i 個字可組合\n\n    → DP[0] ← true // 空字可組合\n\n    → For i from 1 to len(word) // 遍歷位置\n\n        → For j from 0 to i-1 // 選取分割點\n\n            → If DP[j] is true AND substring word[j:i] in dict\n\n                Yes → DP[i] ← true\n\n                → Break // 找到一次即可\n\n    → Return DP[len(word)] // 若整個字可組合則為 true\n\nWe also need to skip the word itself in dict if it is same as word; but since dict only contains shorter words (due to sorting), we don't need to worry. However, if same length duplicates? Not duplicates, but we process ascending; words of same length might be processed earlier but can be used? Problem statement says at least two shorter words, not necessarily distinct. Shorter words means length less than current? Typically the definition requires at least two words from list (could be same) but cannot use itself. Since we process ascending, words of same length will not be in set until processed after current, so current cannot use same length. So correct.\n\nAdd comment for sorting. Provide pseudocode.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Sort words by length ascending // 先排長度最短的單字，確保「短詞」已經可用  \n→ Initialize set `shorterSet` empty // 存放已處理的短詞，供查詢使用  \n→ Initialize result list `concatenatedWords` empty // 存放符合條件的單字  \n→ For each word `w` in words // 遍歷每個單字  \n  → Decision: 是否可以由 `shorterSet` 補成？ // 判斷 w 是否為連接詞  \n    Yes → Add w to concatenatedWords // 符合條件，加入結果  \n  → Add w to shorterSet // 無論結果如何，將 w 加入集合以供後續使用  \n→ Return concatenatedWords // 回傳所有連接詞  \nEnd // 程式執行結束  \n\nDefine function canConcatenate(word, dict) // 檢查 word 是否可由 dict 內單字組成  \n→ Initialize DP array of size len(word)+1 with false // DP[i] 表示前 i 個字可組合  \n→ DP[0] ← true // 空字可組合  \n→ For i from 1 to len(word) // 遍歷位置  \n  → For j from 0 to i-1 // 選取分割點  \n    Decision: DP[j] 為 true 且 word[j:i] 在 dict 中?  \n      Yes → DP[i] ← true // 找到合法分割，標記為可組合  \n      No → 继续下一个 j  \n  → 结束 i 循环  \n→ Return DP[len(word)] // 若整個字可組合則為 true，否則 false  \nEnd of function"
    },
    {
      "title": "Course Schedule II",
      "source_file": "Leetcode/leetcode210.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "numCourses = 2, prerequisites = [[1,0]]",
          "expected_output": "[0,1]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpgcytdmzo.py\", line 46, in <module>\n    main()\n  File \"/tmp/tmpgcytdmzo.py\", line 38, in main\n    m_pre = re.search(r'prerequisites\\s*=\\s*(\\[\\[.*?\\]\\]|[])', data, re.S)\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/re/__init__.py\", line 177, in search\n    return _compile(pattern, flags).search(string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/re/__init__.py\", line 307, in _compile\n    p = _compiler.compile(pattern, flags)\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/re/_compiler.py\", line 745, in compile\n    p = _parser.parse(p, flags)\n        ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/re/_parser.py\", line 979, in parse\n    p = _parse_sub(source, state, flags & SRE_FLAG_VERBOSE, 0)\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/re/_parser.py\", line 460, in _parse_sub\n    itemsappend(_parse(source, state, verbose, nested + 1,\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/re/_parser.py\", line 862, in _parse\n    p = _parse_sub(source, state, sub_verbose, nested + 1)\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/re/_parser.py\", line 460, in _parse_sub\n    itemsappend(_parse(source, state, verbose, nested + 1,\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/re/_parser.py\", line 568, in _parse\n    raise source.error(\"unterminated character set\",\nre.error: unterminated character set at position 33"
        },
        {
          "example_index": 1,
          "input": "numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]",
          "expected_output": "[0,1,2,3]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpi2vy5osc.py\", line 46, in <module>\n    main()\n  File \"/tmp/tmpi2vy5osc.py\", line 38, in main\n    m_pre = re.search(r'prerequisites\\s*=\\s*(\\[\\[.*?\\]\\]|[])', data, re.S)\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/re/__init__.py\", line 177, in search\n    return _compile(pattern, flags).search(string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/re/__init__.py\", line 307, in _compile\n    p = _compiler.compile(pattern, flags)\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/re/_compiler.py\", line 745, in compile\n    p = _parser.parse(p, flags)\n        ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/re/_parser.py\", line 979, in parse\n    p = _parse_sub(source, state, flags & SRE_FLAG_VERBOSE, 0)\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/re/_parser.py\", line 460, in _parse_sub\n    itemsappend(_parse(source, state, verbose, nested + 1,\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/re/_parser.py\", line 862, in _parse\n    p = _parse_sub(source, state, sub_verbose, nested + 1)\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/re/_parser.py\", line 460, in _parse_sub\n    itemsappend(_parse(source, state, verbose, nested + 1,\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/re/_parser.py\", line 568, in _parse\n    raise source.error(\"unterminated character set\",\nre.error: unterminated character set at position 33"
        },
        {
          "example_index": 2,
          "input": "numCourses = 1, prerequisites = []",
          "expected_output": "[0]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpxr7r1t41.py\", line 46, in <module>\n    main()\n  File \"/tmp/tmpxr7r1t41.py\", line 38, in main\n    m_pre = re.search(r'prerequisites\\s*=\\s*(\\[\\[.*?\\]\\]|[])', data, re.S)\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/re/__init__.py\", line 177, in search\n    return _compile(pattern, flags).search(string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/re/__init__.py\", line 307, in _compile\n    p = _compiler.compile(pattern, flags)\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/re/_compiler.py\", line 745, in compile\n    p = _parser.parse(p, flags)\n        ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/re/_parser.py\", line 979, in parse\n    p = _parse_sub(source, state, flags & SRE_FLAG_VERBOSE, 0)\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/re/_parser.py\", line 460, in _parse_sub\n    itemsappend(_parse(source, state, verbose, nested + 1,\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/re/_parser.py\", line 862, in _parse\n    p = _parse_sub(source, state, sub_verbose, nested + 1)\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/re/_parser.py\", line 460, in _parse_sub\n    itemsappend(_parse(source, state, verbose, nested + 1,\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/re/_parser.py\", line 568, in _parse\n    raise source.error(\"unterminated character set\",\nre.error: unterminated character set at position 33"
        }
      ],
      "generated_code": "import sys\nimport re\nfrom collections import deque\n\ndef find_order(num_courses, prerequisites):\n    # 建立鄰接清單與入度陣列\n    graph = [[] for _ in range(num_courses)]\n    indegree = [0] * num_courses\n\n    for dest, src in prerequisites:\n        graph[src].append(dest)\n        indegree[dest] += 1\n\n    # 先把所有入度為 0 的節點放進佇列\n    queue = deque([i for i in range(num_courses) if indegree[i] == 0])\n    order = []\n\n    while queue:\n        node = queue.popleft()\n        order.append(node)\n        for neighbor in graph[node]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                queue.append(neighbor)\n\n    return order if len(order) == num_courses else []\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 取得 numCourses\n    m_num = re.search(r'numCourses\\s*=\\s*(\\d+)', data)\n    num_courses = int(m_num.group(1)) if m_num else 0\n\n    # 取得 prerequisites 清單\n    m_pre = re.search(r'prerequisites\\s*=\\s*(\\[\\[.*?\\]\\]|[])', data, re.S)\n    prereq_str = m_pre.group(1) if m_pre else '[]'\n    prerequisites = eval(prereq_str)\n\n    result = find_order(num_courses, prerequisites)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for problem: topological sort of directed graph using prerequisites. We'll output step-by-step virtual code. Provide explanation after each line. Should include Start, Decision, etc. We need to show algorithm: build adjacency list, indegree, queue, process, if cycle return empty array.\n\nWe'll output in lines. Use Start, End. Use arrows. Provide concise explanation.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空的 adjacency list 與 indegree 陣列，長度為 numCourses // 初始化圖資料結構  \n→ Step 2: 針對 prerequisites 中每個 (a, b)  \n  → Step 2a: 將 a 加入 b 的鄰接清單 // 表示從 b 到 a 的邊  \n  → Step 2b: indegree[a]++ // a 的入度加一  \n→ Step 3: 建立空的 queue  \n→ Decision: 依序檢查所有課程 0 ~ numCourses-1  \n  Yes → Step 3a: 若 indegree[i] == 0，將 i 加入 queue // 無前置課程即可開始  \n  No  → 跳過  \n→ Step 4: 建立空的答案清單 result  \n→ Decision: queue 是否非空？  \n  Yes → Step 5: 取出 queue 前端節點 cur  \n    → Step 5a: result.append(cur) // 記錄完成順序  \n    → Step 5b: 針對 cur 的每個鄰接節點 next  \n      → Step 5b1: indegree[next]-- // 移除一條邊  \n      → Decision: indegree[next] == 0?  \n       Yes → Step 5b2: queue.append(next) // 現已無前置課程可進入 queue  \n       No  → 跳過  \n    → Step 5c: 回到 Decision: queue 是否非空？（重複第 5 步）  \n  No  → Step 6: 退出循環  \n→ Step 7: Decision: result.size() == numCourses?  \n  Yes → End // 所有課程都已排好順序，返回 result  \n  No  → Step 8: result = [] // 無法完成所有課程，返回空陣列  \n→ End // 程式執行結束"
    },
    {
      "title": "Word Ladder II",
      "source_file": "Leetcode/leetcode126.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
          "expected_output": "[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]'\nGot (Norm):      'Invalidinputformat:name\"beginWord\"isnotdefined'\n--- (Raw) ---\nRaw Expected: '[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]'\nRaw Got:      \"Invalid input format: name 'beginWord' is not defined\""
        },
        {
          "example_index": 1,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]",
          "expected_output": "[]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[]'\nGot (Norm):      'Invalidinputformat:name\"beginWord\"isnotdefined'\n--- (Raw) ---\nRaw Expected: '[]'\nRaw Got:      \"Invalid input format: name 'beginWord' is not defined\""
        }
      ],
      "generated_code": "import sys\nfrom collections import defaultdict, deque\n\nclass Solution:\n    def findLadders(self, beginWord: str, endWord: str, wordList: list[str]) -> list[list[str]]:\n        word_set = set(wordList)\n        if endWord not in word_set:\n            return []\n\n        # BFS to find the shortest distance of each word and build parents map\n        layer = {beginWord: 0}\n        parents = defaultdict(list)\n        queue = deque([beginWord])\n\n        while queue:\n            word = queue.popleft()\n            step = layer[word]\n            for i in range(len(word)):\n                for c in 'abcdefghijklmnopqrstuvwxyz':\n                    new_word = word[:i] + c + word[i+1:]\n                    if new_word in word_set:\n                        if new_word not in layer:\n                            layer[new_word] = step + 1\n                            queue.append(new_word)\n                            parents[new_word].append(word)\n                        elif layer[new_word] == step + 1:\n                            parents[new_word].append(word)\n\n        res = []\n        if endWord not in parents:\n            return []\n\n        # DFS to build all paths from endWord back to beginWord\n        def dfs(path: list[str], word: str):\n            if word == beginWord:\n                res.append(path[::-1])  # reverse to get correct order\n                return\n            for prev in parents[word]:\n                dfs(path + [prev], prev)\n\n        dfs([endWord], endWord)\n        return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Convert the input string into a dictionary\n    # Expected format: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\"]\n    try:\n        # Replace '=' with ':' to form a valid dict literal\n        dict_literal = '{' + data.replace('=', ':') + '}'\n        params = eval(dict_literal)\n    except Exception as e:\n        print(f\"Invalid input format: {e}\")\n        return\n\n    beginWord = params.get('beginWord')\n    endWord = params.get('endWord')\n    wordList = params.get('wordList')\n\n    solution = Solution()\n    result = solution.findLadders(beginWord, endWord, wordList)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps to solve Word Ladder II problem (LeetCode 126). The virtual code should be line by line with explanations. Use Start, Decision, etc. Should outline steps: BFS to build graph and distances, then DFS/backtracking to build all shortest paths.\n\nWe need to produce steps not actual code. Each line: \"虛擬碼步驟 // 解釋\". Use arrow arrow etc. Provide steps. Let's produce algorithm: Start, Check endWord in wordList else return empty. Build adjacency map via BFS, track distance map. Use queue. While queue not empty, pop word, for each possible transformation generate next words, if not visited, set distance, add neighbor. After BFS build graph where edges only to nodes with distance+1. Then DFS from beginWord to endWord following graph to build all paths, using recursion with backtracking. Finally return all paths.\n\nLet's produce virtual steps.\n\nWe need to use structure: Start, Decision, → Step X, etc. Provide clear structure.\n\nWe can include comments.\n\nLet's craft steps:\n\nStart // program start\n\n→ Decision: 是否 endWord 在 wordList? // check\n\n    Yes → Step 1: 初始化 distance map, graph, queue, visited set // prepare data structures\n\n    No  → Step 2: 回傳空清單 // no solution\n\nThen BFS:\n\n→ Step 3: queue.enqueue(beginWord) // start BFS\n\n→ While queue not empty // BFS loop\n\n    → Step 4: word = queue.dequeue()\n\n    → For each position i in word\n\n        → Step 5: 將 word 的第 i 位改為 a-z 產生 nextWord\n\n        → Decision: nextWord 是否在 wordList? // only consider valid words\n\n            Yes → Decision: nextWord 是否已在 distance map? // not visited\n\n                Yes → Step 6: distance[nextWord] = distance[word]+1; queue.enqueue(nextWord)\n\n                No  → Step 7: distance[nextWord] = distance[word]+1; graph[word].add(nextWord); // add edge\n\n            No  → Next\n\nAfter BFS: if endWord not in distance map => return empty\n\nThen build graph adjacency only shortest paths: Actually we already added edges only when distance next == distance[word]+1. Might need to ensure graph built accordingly.\n\nThen DFS:\n\n→ Step 8: path = [beginWord]; results = []\n\n→ Step 9: DFS(currentWord, path)\n\n    → Decision: currentWord == endWord?\n\n        Yes → results.append(copy of path)\n\n        No → For neighbor in graph[currentWord]:\n\n                path.append(neighbor)\n\n                DFS(neighbor, path)\n\n                path.pop()\n\nFinally return results.\n\nWe should structure lines accordingly. Provide arrow lines. Use \"Decision:\" and indent. Provide explanation comments.\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Decision: endWord 是否在 wordList? // 檢查目標字是否可達\n    Yes → Step 1: 初始化 distance, graph, queue, visited // 建立距離表、鄰接表、佇列及已訪標記\n    No  → Step 2: 回傳空清單 // 若目標字不存在於字典，無法完成轉換\n\n→ Step 3: queue.enqueue(beginWord) // BFS 從起始字開始\n→ While queue not empty // BFS 主迴圈\n    → Step 4: word = queue.dequeue() // 取出目前字\n    → For i = 0 to len(word)-1 // 逐字母嘗試改變\n        → Step 5: 將 word 的第 i 位改為 a~z 產生 nextWord // 產生所有可能的下一個字\n        → Decision: nextWord 是否在 wordList? // 只考慮字典中的合法字\n            Yes → Decision: nextWord 是否已在 distance? // 是否已被訪問過\n                Yes → Step 6: distance[nextWord] = distance[word] + 1; queue.enqueue(nextWord) // 設定距離並加入佇列\n                No  → Step 7: distance[nextWord] = distance[word] + 1; graph[word].add(nextWord) // 只在最短距離上加入邊\n            No  → Next // 若不是字典字，直接忽略\n→ Decision: endWord 是否在 distance? // 判斷是否找到目標\n    Yes → Step 8: path = [beginWord]; results = [] // 準備回溯\n    No  → Step 9: 回傳空清單 // 無法到達目標\n\n→ Step 10: DFS(currentWord, path) // 從起始字開始深度優先搜尋\n    → Decision: currentWord == endWord? // 到達終點\n        Yes → results.append(copy of path) // 收集一條完整最短路徑\n        No → For neighbor in graph[currentWord]: // 遍歷所有鄰接且符合距離的字\n                path.append(neighbor) // 進一步\n                DFS(neighbor, path) // 遞迴\n                path.pop() // 回溯\n→ Step 11: 回傳 results // 所有最短轉換序列\nEnd // 程式執行結束\n```"
    },
    {
      "title": "Generate Random Point in a Circle",
      "source_file": "Leetcode/leetcode478.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]",
          "expected_output": "[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[-0.02493,-0.38077],[0.82314,0.38945],[0.36572,0.17248]]'\nGot (Norm):      '[null,[0.6154792780504345,0.5355947698490112],[-0.05599606911109547,0.6271961006040636],[-0.14182806846791982,-0.6909622219893248]]'\n--- (Raw) ---\nRaw Expected: '[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]'\nRaw Got:      '[null, [0.6154792780504345, 0.5355947698490112], [-0.05599606911109547, 0.6271961006040636], [-0.14182806846791982, -0.6909622219893248]]'"
        }
      ],
      "generated_code": "import json\nimport random\nimport math\nimport sys\n\nclass Solution:\n    def __init__(self, radius: float, x_center: float, y_center: float):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n\n    def randPoint(self):\n        # 以極座標生成均勻分布的隨機點\n        r = self.radius * math.sqrt(random.random())   # 保證半徑分布均勻\n        theta = random.uniform(0, 2 * math.pi)          # 角度在 0~2π 之間\n        x = self.x_center + r * math.cos(theta)\n        y = self.y_center + r * math.sin(theta)\n        return [x, y]\n\nif __name__ == \"__main__\":\n    # 讀取標準輸入，第一行為操作名稱列表，第二行為對應參數列表\n    raw_lines = [line.strip() for line in sys.stdin if line.strip()]\n    if not raw_lines:\n        sys.exit(0)\n\n    ops = json.loads(raw_lines[0])\n    args_list = json.loads(raw_lines[1]) if len(raw_lines) > 1 else []\n\n    obj = None\n    results = []\n\n    for op, args in zip(ops, args_list):\n        if op == \"Solution\":\n            obj = Solution(*args)\n            results.append(None)        # 建構子對應的結果為 null\n        else:\n            method = getattr(obj, op)\n            res = method(*args)\n            results.append(res)\n\n    # 輸出為 JSON 格式，Python 的 None 會轉為 null\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce pseudocode for solution. Must be in lines: Start, steps, decision, etc. The pseudocode should describe generating random point inside circle uniformly. Approach: generate random radius sqrt(U)*R and random angle U2*2π. Then convert to coordinates. The pseudocode: Start, store radius, x_center, y_center. Step: generate random number u1 in [0,1). Step: generate random number u2 in [0,1). Step: compute r = sqrt(u1)*radius. Step: compute theta = 2π*u2. Step: compute x = x_center + r*cos(theta). Step: compute y = y_center + r*sin(theta). Return [x, y]. That's all. Use pseudocode arrows. Let's format accordingly. Ensure each line ends with // explanation. Use Chinese explanation. Provide Start and End. Use Decision maybe not necessary but we can show decision if needed for boundary check? Not needed. But we can add a decision for inside circle but by construction it's inside. Might not need. Provide Steps only.\n\nWe must not output actual code, only pseudocode. Provide each line. We'll include arrows as specified.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: 儲存參數 radius, x_center, y_center // 初始化圓心與半徑\n→ Step 2: 產生隨機數 u1 介於 0 與 1 之間 // 用於生成半徑\n→ Step 3: 產生隨機數 u2 介於 0 與 1 之間 // 用於生成角度\n→ Step 4: 計算隨機半徑 r = sqrt(u1) * radius // 使點在圓內均勻分佈\n→ Step 5: 計算隨機角度 θ = 2π * u2 // 角度在 0 到 2π 之間\n→ Step 6: 計算座標 x = x_center + r * cos(θ) // 根據極座標轉直角座標\n→ Step 7: 計算座標 y = y_center + r * sin(θ) // 同上\n→ Step 8: 回傳 [x, y] // 取得隨機點\nEnd // 程式執行結束\n\nThat's it. Ensure each line ends with explanation. Use `→` for steps. Provide `Start` and `End`. No Decision needed. Done.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 儲存參數 radius, x_center, y_center // 初始化圓心與半徑\n→ Step 2: 產生隨機數 u1 介於 0 與 1 之間 // 用於生成半徑\n→ Step 3: 產生隨機數 u2 介於 0 與 1 之間 // 用於生成角度\n→ Step 4: 計算隨機半徑 r = sqrt(u1) * radius // 使點在圓內均勻分佈\n→ Step 5: 計算隨機角度 θ = 2π * u2 // 角度在 0 到 2π 之間\n→ Step 6: 計算座標 x = x_center + r * cos(θ) // 根據極座標轉直角座標\n→ Step 7: 計算座標 y = y_center + r * sin(θ) // 同上\n→ Step 8: 回傳 [x, y] // 取得隨機點\nEnd // 程式執行結束"
    },
    {
      "title": "Remove Duplicates from Sorted Array",
      "source_file": "Leetcode/leetcode26.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,1,2]",
          "expected_output": "2, nums = [1,2,_]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2,nums=[1,2,_]'\nGot (Norm):      '2,nums=[1,2]'\n--- (Raw) ---\nRaw Expected: '2, nums = [1,2,_]'\nRaw Got:      '2, nums = [1, 2]'"
        },
        {
          "example_index": 1,
          "input": "nums = [0,0,1,1,1,2,2,3,3,4]",
          "expected_output": "5, nums = [0,1,2,3,4,_,_,_,_,_]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '5,nums=[0,1,2,3,4,_,_,_,_,_]'\nGot (Norm):      '5,nums=[0,1,2,3,4]'\n--- (Raw) ---\nRaw Expected: '5, nums = [0,1,2,3,4,_,_,_,_,_]'\nRaw Got:      '5, nums = [0, 1, 2, 3, 4]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport re\n\ndef removeDuplicates(nums):\n    \"\"\"\n    移除已排序陣列中的重複值，並在原地保留唯一元素。\n    回傳唯一元素的個數 k，且 nums 的前 k 個位置即為這些唯一元素。\n    \"\"\"\n    if not nums:\n        return 0\n\n    slow = 0\n    for fast in range(1, len(nums)):\n        if nums[fast] != nums[slow]:\n            slow += 1\n            nums[slow] = nums[fast]\n    return slow + 1\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取資料，預期格式類似 'nums = [1,1,2]'\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 找出字串中的列表部分\n    match = re.search(r'\\[(.*?)\\]', data)\n    if not match:\n        raise ValueError(\"輸入格式不正確，請提供列表資料。\")\n\n    # 解析列表\n    nums_list_str = f\"[{match.group(1)}]\"\n    nums = ast.literal_eval(nums_list_str)\n\n    # 呼叫解題函式\n    k = removeDuplicates(nums)\n\n    # 輸出結果，僅印前 k 個元素\n    print(f\"{k}, nums = {nums[:k]}\")",
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps with explanations. We need to produce line by line, each line: virtual code + space + comment. Use arrow, Decision, Start, End. Must not output actual code, just pseudocode. Provide for the described problem: removing duplicates in sorted array in-place, returning k. Use typical two-pointer method.\n\nWe need to generate each step as separate line.\n\nWe should start with Start, then Step 1: Input array? Actually it's passed as parameter. So Step: Initialize two pointers: i = 0, j = 1? Actually algorithm: if length 0 return 0. Use i=0; for j from 1 to n-1, if nums[j]!=nums[i], i++, nums[i]=nums[j]; after loop return i+1.\n\nThus pseudocode lines:\n\nStart\n→ Step 1: Check if nums is empty? Decision: If length == 0? Yes → Return 0 // no elements\n→ Decision: If length == 1? Yes → Return 1 // only one element, unique count 1\n→ Initialize pointer i to 0 // i points to last unique element\n→ For pointer j from 1 to length-1 // iterate through array\n    → Decision: If nums[j] != nums[i]? Yes → Increment i; set nums[i] = nums[j] // move unique to position\n    → No → Do nothing // duplicate, skip\n→ Return i + 1 // number of unique elements\nEnd\n\nBut we need to use arrow formatting exactly. Use \"→ Step X: ...\" etc. Ensure each line has comment.\n\nWe need to be careful about formatting: \"→ Step 1:\" etc. After arrow we need step name. For decision lines: \"→ Decision:\" etc. Use indentation: maybe \"    Yes → ...\" etc.\n\nLet's produce final answer.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: 如果 nums 長度為 0? // 檢查是否為空陣列  \n  Yes → Return 0 // 空陣列無唯一元素  \n→ Decision: 如果 nums 長度為 1? // 只有一個元素時直接返回  \n  Yes → Return 1 // 單一元素即為唯一元素  \n→ Step 1: 設定 i = 0 // i 指向最後一個已確定的唯一元素  \n→ Step 2: 對 j 從 1 到 nums.length-1 進行迴圈 // 遍歷剩餘元素  \n  → Decision: 如果 nums[j] ≠ nums[i]? // 判斷是否為新唯一元素  \n    Yes → i = i + 1 // i 前進，指向新位置  \n     → Step 3: 把 nums[j] 複製到 nums[i] // 把唯一元素搬到正確位置  \n    No → Do nothing // 重複值直接跳過  \n→ Step 4: Return i + 1 // i+1 為唯一元素的個數 k  \nEnd // 程式執行結束"
    },
    {
      "title": "Shuffle an Array",
      "source_file": "Leetcode/leetcode384.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"], [[[1, 2, 3]], [], [], []]",
          "expected_output": "[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[3,1,2],[1,2,3],[1,3,2]]'\nGot (Norm):      '[null,[2,1,3],[1,2,3],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]'\nRaw Got:      '[null, [2, 1, 3], [1, 2, 3], [3, 1, 2]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\nimport json\n\nclass Solution:\n    def __init__(self, nums):\n        # 儲存原始陣列的複本以便重置\n        self.original = list(nums)\n\n    def reset(self):\n        # 回傳原始陣列\n        return list(self.original)\n\n    def shuffle(self):\n        # 使用 Fisher–Yates 洗牌算法\n        arr = list(self.original)\n        n = len(arr)\n        for i in range(n):\n            j = random.randint(i, n - 1)\n            arr[i], arr[j] = arr[j], arr[i]\n        return arr\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 將輸入包裝成 tuple 以便使用 ast.literal_eval 解析\n    if not (data.startswith('(') and data.endswith(')')):\n        data = f'({data})'\n\n    try:\n        ops, args = ast.literal_eval(data)\n    except Exception as e:\n        print(f\"Error parsing input: {e}\", file=sys.stderr)\n        sys.exit(1)\n\n    result = []\n    obj = None\n\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            # arg 是一個包含 nums 的列表，例如 [[1,2,3]]\n            obj = Solution(arg[0])\n            result.append(None)  # 建構子不返回值\n        elif op == \"reset\":\n            result.append(obj.reset())\n        elif op == \"shuffle\":\n            result.append(obj.shuffle())\n        else:\n            result.append(None)\n\n    # 使用 json.dumps 以得到符合 LeetCode 輸出格式 (None -> null)\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps describing algorithm for Fisher-Yates shuffle. Each line with arrow and comment. Should show class, constructor, reset, shuffle. Use Start, End. Provide decision etc? Probably not many decisions. Use for loop. Use random. Represent steps. We'll produce in lines: Start, then class definition, initialization, store original copy, reset method returns original copy, shuffle method copies array, loop i from n-1 to 1, generate random j between 0 and i inclusive, swap, end. Use arrows for flow. Provide comments.\n\nEnsure each line: \"虛擬碼步驟 // 解釋\". Use arrow \"→\". Include decision maybe for bounds? Not needed. But can include decision inside shuffle: choose random j.\n\nWe'll output lines accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Class: Solution // 定義 Solution 類別  \n→   Variable: nums // 存放原始陣列  \n→   Variable: original // 存放原始陣列的副本  \n→   Constructor: Solution(int[] nums) // 建構子  \n→     Assign original ← copy(nums) // 複製陣列以保留原始順序  \n→     Assign this.nums ← nums // 參考原始陣列  \n→   Method: int[] reset() // 重置方法  \n→     Return original // 回傳原始陣列  \n→   Method: int[] shuffle() // 洗牌方法  \n→     Copy array ← copy(nums) // 先複製陣列以避免改變原始資料  \n→     Assign n ← length(array) // 取得陣列長度  \n→     For i from n-1 down to 1: // 逐步從尾部往前處理  \n→       Decision: Generate random index j where 0 ≤ j ≤ i // 隨機選取交換位置  \n→         j ← randomInt(0, i) // 產生隨機整數  \n→       Swap array[i] with array[j] // 交換兩個元素  \n→     Return array // 回傳已洗牌的陣列  \nEnd // 程式執行結束"
    },
    {
      "title": "Subsets",
      "source_file": "Leetcode/leetcode78.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nGot (Norm):      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nRaw Got:      '[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def subsets(self, nums):\n        res = []\n\n        def backtrack(start, path):\n            # 把目前的子集加入結果\n            res.append(path[:])\n            for i in range(start, len(nums)):\n                path.append(nums[i])\n                backtrack(i + 1, path)\n                path.pop()\n\n        backtrack(0, [])\n        return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 只處理最後一行輸入，例如 'nums = [1,2,3]'\n    if '=' in data:\n        _, expr = data.split('=', 1)\n    else:\n        expr = data\n    nums = ast.literal_eval(expr.strip())\n    solution = Solution()\n    result = solution.subsets(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for generating all subsets of unique integers array, using backtracking presumably. Provide each line of virtual code with explanation. Must follow format: \"虛擬碼步驟 // 解釋\". Each line with arrow or Start End etc. Use decision branches. Let's craft steps:\n\nStart\n→ Step 1: 初始化 result = []\n→ Step 2: 定義回溯函式 backtrack(start, current)\n→ Step 3: 在 backtrack: 加入 current 到 result\n→ Step 4: 循環 i from start to nums.length-1\n→ Step 5: 將 nums[i] 加到 current\n→ Step 6: backtrack(i+1, current)\n→ Step 7: 移除 current 的最後一個元素（回溯）\n→ End of backtrack\n→ Step 8: 呼叫 backtrack(0, [])\n→ Step 9: 回傳 result\nEnd\n\nBut must also include decisions: e.g., in step 4 we have decision of loop, but we can just represent loop. Might include decision \"如果 i < nums.length?\" but loops implicit.\n\nLet's produce virtual code:\n\nStart\n→ Step 1: 定義 nums // 已給的輸入陣列\n→ Step 2: 初始化 result = [] // 存放所有子集\n→ Step 3: 定義函式 backtrack(start, current) // start 為下一個可選取的索引\n    → Step 3.1: result.add(copy(current)) // 加入目前子集\n    → Step 3.2: Decision: 如果 start < nums.length? // 是否還有剩餘元素可選\n        Yes →\n            → Step 3.2.1: for i from start to nums.length-1\n                → Step 3.2.1.1: current.add(nums[i]) // 包含 nums[i]\n                → Step 3.2.1.2: backtrack(i+1, current) // 進一步選取更後面的元素\n                → Step 3.2.1.3: current.removeLast() // 回溯，移除最後加入的元素\n        No →\n            → Step 3.3: // 無更多元素，回到上一層\n→ Step 4: backtrack(0, []) // 從索引0開始，空子集\n→ Step 5: 返回 result // 完成所有子集\nEnd\n\nBut need to maintain arrow syntax. Use \"→\" lines. Use indentation maybe.\n\nThe requirement: each line: `虛擬碼步驟` + `[space]` + `// 解釋/說明`. Must include arrow `→` for steps, `Decision:` for if. The `Start` and `End` lines are special.\n\nLet's craft final answer. Ensure no real code, just virtual. Provide as code block. Use Chinese comments. Use `Decision:` syntax. For for-loop we might just include a decision or loop representation.\n\nBetter structure:\n\nStart\n→ Step 1: 初始化 nums 為輸入陣列 // 取得給定的整數陣列\n→ Step 2: 初始化 result = [] // 儲存所有子集\n→ Step 3: 定義回溯函式 backtrack(start, current) // start 為可選取的起始索引\n    → Step 3.1: result.add(copy(current)) // 將目前子集加入結果\n    → Step 3.2: Decision: 是否還有元素可選 (start < nums.length)? // 檢查是否可以繼續擴充\n        Yes →\n            → Step 3.2.1: for i from start to nums.length-1 // 遍歷所有可能的下一個元素\n                → Step 3.2.1.1: current.add(nums[i]) // 包含 nums[i]\n                → Step 3.2.1.2: backtrack(i+1, current) // 進一步遞迴選取後續元素\n                → Step 3.2.1.3: current.removeLast() // 回溯，移除最後加入的元素\n        No  →\n            → Step 3.3: // 沒有剩餘元素，結束此分支\n→ Step 4: backtrack(0, []) // 從索引0開始，空子集\n→ Step 5: return result // 回傳所有子集\nEnd\n\nNeed to maintain format: each line with code and // explanation. Ensure no code actual.\n\nLet's output.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 初始化 nums 為輸入陣列 // 取得給定的整數陣列\n→ Step 2: 初始化 result = [] // 儲存所有子集\n→ Step 3: 定義回溯函式 backtrack(start, current) // start 為可選取的起始索引\n    → Step 3.1: result.add(copy(current)) // 將目前子集加入結果\n    → Step 3.2: Decision: 是否還有元素可選 (start < nums.length)? // 檢查是否可以繼續擴充\n        Yes →\n            → Step 3.2.1: for i from start to nums.length-1 // 遍歷所有可能的下一個元素\n                → Step 3.2.1.1: current.add(nums[i]) // 包含 nums[i]\n                → Step 3.2.1.2: backtrack(i+1, current) // 進一步遞迴選取後續元素\n                → Step 3.2.1.3: current.removeLast() // 回溯，移除最後加入的元素\n        No  →\n            → Step 3.3: // 沒有剩餘元素，結束此分支\n→ Step 4: backtrack(0, []) // 從索引0開始，空子集\n→ Step 5: return result // 回傳所有子集\nEnd // 程式執行結束\n```"
    },
    {
      "title": "Reconstruct Original Digits from English",
      "source_file": "Leetcode/leetcode423.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"owoztneoer\"",
          "expected_output": "\"012\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '012'\nGot (Norm):      '0127'\n--- (Raw) ---\nRaw Expected: '\"012\"'\nRaw Got:      '0127'"
        },
        {
          "example_index": 1,
          "input": "s = \"fviefuro\"",
          "expected_output": "\"45\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '45'\nGot (Norm):      '457'\n--- (Raw) ---\nRaw Expected: '\"45\"'\nRaw Got:      '457'"
        }
      ],
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\nclass Solution:\n    def originalDigits(self, s: str) -> str:\n        # Count each letter in the string\n        cnt = Counter(s)\n\n        # Digits with unique identifying letters\n        out = {}\n        out['0'] = cnt['z']\n        out['2'] = cnt['w']\n        out['4'] = cnt['u']\n        out['6'] = cnt['x']\n        out['8'] = cnt['g']\n\n        # Remaining digits, subtracting the counts already taken\n        out['3'] = cnt['h'] - out['8']\n        out['5'] = cnt['f'] - out['4']\n        out['7'] = cnt['s'] - out['6']\n        out['1'] = cnt['o'] - out['0'] - out['2'] - out['4']\n        out['9'] = cnt['i'] - out['5'] - out['6'] - out['8']\n\n        # Build result in ascending order\n        res = []\n        for d in sorted(out.keys()):\n            res.append(d * out[d])\n        return ''.join(res)\n\nif __name__ == \"__main__\":\n    # Read entire input\n    data = sys.stdin.read()\n\n    # Extract only alphabetic characters (the letters of the digit words)\n    letters = re.findall(r'[a-zA-Z]', data)\n    s = ''.join(letters)\n\n    sol = Solution()\n    result = sol.originalDigits(s)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for solving the problem: Given a string s containing letters of English words for digits 0-9 (like \"owoztneoer\" -> \"012\"), out of order, return digits in ascending order. This is LeetCode problem \"Number of Steps to Reduce Number to Zero\"? No, it's \"Digits\" but actually \"Number of steps\" not. The problem: \"Digits\" or \"Spell Number\"? Known as \"Reconstruct Original Digits from English\" problem. Approach: Count letter frequencies, identify unique letters for each digit: zero (z), two (w), four (u), six (x), eight (g), then remaining: one (o), three (h), five (f), seven (s), nine (i). Then produce digits sorted ascending.\n\nWe need to produce pseudo-code steps, each line with explanation. Use arrow structure.\n\nLet's produce algorithm:\n\nStart\n→ Step 1: Count frequency of each letter in s // Build a frequency map\n→ Decision: Determine digit 0 count by freq['z'] // unique letter\n    Yes? (just assign)\n→ Step 2: digit0 = freq['z']\n→ Step 3: Subtract letters of \"zero\" times digit0 from freq // remove counted letters\nContinue for digits: 2 (w), 4 (u), 6 (x), 8 (g), then 1 (o), 3 (h), 5 (f), 7 (s), 9 (i)\n\nAfter all counts, build result string by repeating each digit count times, ascending order.\n\nFinally, End\n\nWe need to produce each line with \"虛擬碼步驟\" + \"// 解釋\". Use arrow \"→\".\n\nWe'll list steps sequentially, maybe grouping similar ones.\n\nWe should keep line count reasonable but still each step explained.\n\nLet's produce pseudo-code:\n\nStart // 程式開始執行\n→ Step 1: freq ← frequency map of letters in s // 取得每個字母出現次數\n→ Step 2: zero_count ← freq['z'] // 'z' 只出現在 \"zero\" 中，得到 0 的數量\n→ Step 3: subtract letters of \"zero\" zero_count times from freq // 移除已計算的字母\n→ Step 4: two_count ← freq['w'] // 'w' 唯一出現在 \"two\"\n→ Step 5: subtract letters of \"two\" two_count times from freq\n→ Step 6: four_count ← freq['u'] // 'u' 唯一出現在 \"four\"\n→ Step 7: subtract letters of \"four\" four_count times from freq\n→ Step 8: six_count ← freq['x'] // 'x' 唯一出現在 \"six\"\n→ Step 9: subtract letters of \"six\" six_count times from freq\n→ Step 10: eight_count ← freq['g'] // 'g' 唯一出現在 \"eight\"\n→ Step 11: subtract letters of \"eight\" eight_count times from freq\n→ Step 12: one_count ← freq['o'] // 之後 'o' 只剩 \"one\" (已去掉 0,2,4)\n→ Step 13: subtract letters of \"one\" one_count times from freq\n→ Step 14: three_count ← freq['h'] // 'h' 剩下只屬於 \"three\"\n→ Step 15: subtract letters of \"three\" three_count times from freq\n→ Step 16: five_count ← freq['f'] // 'f' 剩下只屬於 \"five\"\n→ Step 17: subtract letters of \"five\" five_count times from freq\n→ Step 18: seven_count ← freq['s'] // 's' 剩下只屬於 \"seven\"\n→ Step 19: subtract letters of \"seven\" seven_count times from freq\n→ Step 20: nine_count ← freq['i'] // 'i' 剩下只屬於 \"nine\"\n→ Step 21: result ← empty string\n→ Step 22: for digit from 0 to 9:\n    → Append digit as string repeated count times to result // 依升序組合數字\n→ Step 23: return result // 回傳升序的數字字串\nEnd // 程式執行結束\n\nWe should format each line with arrow. Use \"→ Step X:\" etc.\n\nAlso the first line \"Start // 程式開始執行\" no arrow.\n\nWe also need \"Decision:\" lines? Not necessary since not using if. But we can keep decisions implied.\n\nBut instructions: Use Decision and arrow Yes/No? Not required but can include if needed. However we can keep simple steps.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: freq ← build frequency map of all letters in s // 取得每個字母的出現次數  \n→ Step 2: zero_count ← freq['z'] // 'z' 只出現在 \"zero\" 之中，得到 0 的數量  \n→ Step 3: subtract letters of \"zero\" zero_count times from freq // 移除已計算的字母  \n→ Step 4: two_count ← freq['w'] // 'w' 只出現在 \"two\" 之中，得到 2 的數量  \n→ Step 5: subtract letters of \"two\" two_count times from freq // 移除已計算的字母  \n→ Step 6: four_count ← freq['u'] // 'u' 只出現在 \"four\" 之中，得到 4 的數量  \n→ Step 7: subtract letters of \"four\" four_count times from freq // 移除已計算的字母  \n→ Step 8: six_count ← freq['x'] // 'x' 只出現在 \"six\" 之中，得到 6 的數量  \n→ Step 9: subtract letters of \"six\" six_count times from freq // 移除已計算的字母  \n→ Step 10: eight_count ← freq['g'] // 'g' 只出現在 \"eight\" 之中，得到 8 的數量  \n→ Step 11: subtract letters of \"eight\" eight_count times from freq // 移除已計算的字母  \n→ Step 12: one_count ← freq['o'] // 'o' 之後只剩 \"one\"，得到 1 的數量  \n→ Step 13: subtract letters of \"one\" one_count times from freq // 移除已計算的字母  \n→ Step 14: three_count ← freq['h'] // 'h' 之後只剩 \"three\"，得到 3 的數量  \n→ Step 15: subtract letters of \"three\" three_count times from freq // 移除已計算的字母  \n→ Step 16: five_count ← freq['f'] // 'f' 之後只剩 \"five\"，得到 5 的數量  \n→ Step 17: subtract letters of \"five\" five_count times from freq // 移除已計算的字母  \n→ Step 18: seven_count ← freq['s'] // 's' 之後只剩 \"seven\"，得到 7 的數量  \n→ Step 19: subtract letters of \"seven\" seven_count times from freq // 移除已計算的字母  \n→ Step 20: nine_count ← freq['i'] // 'i' 之後只剩 \"nine\"，得到 9 的數量  \n→ Step 21: result ← empty string // 用於儲存最終的升序數字字串  \n→ Step 22: for digit from 0 to 9:\n    → Append digit as string repeated its count times to result // 依升序組合各個數字  \n→ Step 23: return result // 回傳升序的數字字串  \nEnd // 程式執行結束"
    },
    {
      "title": "Design Twitter",
      "source_file": "Leetcode/leetcode355.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Twitter\", \"postTweet\", \"getNewsFeed\", \"follow\", \"postTweet\", \"getNewsFeed\", \"unfollow\", \"getNewsFeed\"], [[], [1, 5], [1], [1, 2], [2, 6], [1], [1, 2], [1]]",
          "expected_output": "[null, null, [5], null, null, [6, 5], null, [5]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp5q_mt5eg.py\", line 72, in <module>\n    main()\n  File \"/tmp/tmp5q_mt5eg.py\", line 65, in main\n    method = getattr(twitter, op)\n             ^^^^^^^^^^^^^^^^^^^^\nAttributeError: 'Twitter' object has no attribute 'Twitter'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\nimport json\nimport heapq\nfrom collections import defaultdict\n\nclass Twitter:\n    def __init__(self):\n        self.time = 0\n        self.tweets = defaultdict(list)          # userId -> list of (time, tweetId)\n        self.following = defaultdict(set)        # userId -> set of followeeIds (incl. self)\n\n    def postTweet(self, userId: int, tweetId: int) -> None:\n        self.time += 1\n        self.tweets[userId].append((self.time, tweetId))\n        if userId not in self.following[userId]:\n            self.following[userId].add(userId)\n\n    def getNewsFeed(self, userId: int) -> list[int]:\n        if userId not in self.following:\n            return []\n        res = []\n        heap = []\n        for fid in self.following[userId]:\n            tws = self.tweets.get(fid, [])\n            if tws:\n                idx = len(tws) - 1\n                ttime, tid = tws[idx]\n                heapq.heappush(heap, (-ttime, tid, fid, idx))\n        while heap and len(res) < 10:\n            negtime, tid, fid, idx = heapq.heappop(heap)\n            res.append(tid)\n            if idx - 1 >= 0:\n                ttime, tid_prev = self.tweets[fid][idx - 1]\n                heapq.heappush(heap, (-ttime, tid_prev, fid, idx - 1))\n        return res\n\n    def follow(self, followerId: int, followeeId: int) -> None:\n        self.following[followerId].add(followeeId)\n\n    def unfollow(self, followerId: int, followeeId: int) -> None:\n        if followerId == followeeId:\n            return\n        self.following[followerId].discard(followeeId)\n\ndef parse_input(data: str):\n    # Find two lists separated by a comma outside any brackets\n    match = re.search(r'(\\[.*?\\])\\s*,\\s*(\\[.*\\])', data, re.S)\n    if not match:\n        return [], []\n    ops_str, args_str = match.group(1), match.group(2)\n    ops = ast.literal_eval(ops_str)\n    args = ast.literal_eval(args_str)\n    return ops, args\n\ndef main():\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n    ops, args_list = parse_input(raw)\n    twitter = Twitter()\n    results = []\n    for op, args in zip(ops, args_list):\n        method = getattr(twitter, op)\n        ret = method(*args)\n        results.append(ret)\n    # Convert Python None to JSON null automatically\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for design of simplified Twitter. Provide each line as: virtual code step [space] // explanation. Use arrows and Decision etc. It's an algorithm design, not actual code. We should outline initialization, posting tweets, following, unfollowing, retrieving news feed. Use steps like Start, End, Decision. Provide each line. Ensure each line has arrow or Start or End. Each line must have a brief explanation. We should produce a step-by-step algorithm. Use e.g.:\n\nStart // 初始化\n\n→ Step 1: 建立資料結構 // 例如 Map userId → set of followees, list of tweets\n\n...\n\nWe need to be thorough.\n\nLet's design: For each user, maintain a set of following users. Also maintain global list of tweets with timestamp. But to retrieve news feed quickly, we can store per user list of tweet timestamps. For simplification, we can use a global timestamp counter. For getNewsFeed, we need to merge recent tweets from user and followees. Use a min-heap of size 10. Provide pseudo-logic.\n\nLet's produce virtual steps:\n\nStart // 程式開始執行\n\n→ Step 1: 建立全局變數 timestamp = 0 // 用於排序推文\n\n→ Step 2: 建立 Map<userId, Set<followeeId>> followMap // 儲存追蹤關係\n\n→ Step 3: 建立 Map<userId, List<Tweet>> tweetMap // 儲存使用者推文，按時間順序\n\n→ Step 4: 建立 Class Tweet {int id; int time;} // 推文結構\n\nNow operations:\n\n// postTweet\n\n→ Decision: If userId 不存在於 tweetMap? // 檢查是否已有此使用者\n\n    Yes → Step 5: 初始化 tweetMap[userId] = 空列表 // 建立空列表\n\n    No  → No op\n\n→ Step 6: timestamp += 1 // 增加時間戳\n\n→ Step 7: 創建 new Tweet(tweetId, timestamp) // 新推文\n\n→ Step 8: 在 tweetMap[userId] 前插入 new Tweet // 以時間倒序存\n\nSimilarly follow/unfollow:\n\n→ Step 9: If followerId 不在 followMap? 初始化 followMap[followerId] = 空集合\n\n→ Step 10: followMap[followerId].add(followeeId) // 加入追蹤\n\nFor unfollow:\n\n→ Step 11: If followerId 在 followMap? remove followeeId\n\nNow getNewsFeed:\n\n→ Step 12: 建立空的最小堆 heap size <=10 儲存 {tweet, userId, index} // 用於合併\n\n→ Step 13: 定義 list usersToCheck = followMap[userId] 加上 userId 本身\n\n→ For each uid in usersToCheck:\n\n    → Step 14: 取 tweetList = tweetMap[uid] // 取得推文列表\n\n    → Step 15: If tweetList 非空：\n\n        → Step 16: 將 tweetList[0] (最新推文) 以及索引 0 及 uid 放入 heap // 先把每個用戶最新推文進堆\n\n→ Step 17: while heap 非空 且 result.size < 10:\n\n    → Step 18: pop 最小時間（但我們要最大時間，實際上可使用最大堆或取最大） -> Use max-heap; but for explanation we say pop 最高時間\n\n    → Step 19: 添加 tweetId 到 result\n\n    → Step 20: If next tweet exists in same uid list (index+1):\n\n        → Step 21: push next tweet into heap\n\n→ Step 22: 返回 result list\n\nEnd\n\nWe need to use arrows. For loops we can use Indentation with arrows? The example uses nested arrows. We can show Decision lines with Yes → etc. For loops maybe use Step: For each. It's okay.\n\nWe should keep each line separate.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化全局時間戳 timestamp ← 0 // 用於推文排序  \n→ Step 2: 建立 followMap ← Map<userId, Set<followeeId>> // 儲存追蹤關係  \n→ Step 3: 建立 tweetMap ← Map<userId, List<Tweet>> // 儲存使用者推文  \n→ Step 4: 定義類 Tweet {int id; int time;} // 推文結構  \n\n// postTweet(userId, tweetId)  \n→ Decision: 是否存在 tweetMap[userId]? // 檢查使用者是否已初始化  \n Yes → Step 5: 初始化 tweetMap[userId] ← 空列表 // 建立新使用者推文列表  \n No → No op  \n→ Step 6: timestamp ← timestamp + 1 // 更新時間戳  \n→ Step 7: 新建 tweet ← Tweet(tweetId, timestamp) // 創建新推文  \n→ Step 8: 在 tweetMap[userId] 前插入 tweet // 以時間倒序存放  \n\n// follow(followerId, followeeId)  \n→ Decision: 是否存在 followMap[followerId]? // 檢查追蹤者是否已初始化  \n Yes → No op  \n No → Step 9: 初始化 followMap[followerId] ← 空集合 // 建立追蹤集合  \n→ Step 10: followMap[followerId].add(followeeId) // 加入追蹤關係  \n\n// unfollow(followerId, followeeId)  \n→ Decision: 是否存在 followMap[followerId]? // 檢查追蹤者是否已初始化  \n Yes → Step 11: followMap[followerId].remove(followeeId) // 移除追蹤關係  \n No → No op  \n\n// getNewsFeed(userId)  \n→ Step 12: 初始化 result ← 空列表 // 儲存最終推文ID  \n→ Step 13: 初始化 maxHeap ← 空最大堆 // 儲存 {time, tweetId, uid, idx}  \n→ Step 14: users ← followMap[userId] ∪ {userId} // 需要查詢的使用者集合  \n→ For each uid in users:  \n  → Decision: 是否存在 tweetMap[uid]? // 檢查該使用者是否有推文  \n   Yes → Step 15: tweets ← tweetMap[uid] // 取得推文列表  \n    → Decision: 是否為空?  \n     Yes → No op  \n     No → Step 16: maxHeap.push({tweets[0].time, tweets[0].id, uid, 0}) // 加入最新推文  \n   No → No op  \n\n→ While maxHeap not empty AND result.size < 10:  \n  → Step 17: pop ← maxHeap.pop() // 取得最早的推文（時間最大）  \n  → Step 18: result.add(pop.tweetId) // 加入結果  \n  → Step 19: nextIdx ← pop.idx + 1 // 下一條推文索引  \n  → Decision: nextIdx < tweetMap[pop.uid].size? // 是否還有更舊推文  \n   Yes → Step 20: nextTweet ← tweetMap[pop.uid][nextIdx]  \n    → Step 21: maxHeap.push({nextTweet.time, nextTweet.id, pop.uid, nextIdx}) // 加入堆  \n   No → No op  \n\n→ Step 22: 返回 result // 取得 10 條最新推文ID  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick with Weight",
      "source_file": "Leetcode/leetcode528.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"], [[[1,3]],[],[],[],[],[]]",
          "expected_output": "[null,1,1,1,1,0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,1,1,1,1,0]'\nGot (Norm):      '[null,1,1,1,0,0]'\n--- (Raw) ---\nRaw Expected: '[null,1,1,1,1,0]'\nRaw Got:      '[null, 1, 1, 1, 0, 0]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport bisect\n\nclass Solution:\n    def __init__(self, w):\n        # 建立累積重量陣列\n        self.prefix_sum = []\n        total = 0\n        for weight in w:\n            total += weight\n            self.prefix_sum.append(total)\n        self.total = total\n\n    def pickIndex(self):\n        # 產生 [1, total] 之間的隨機整數\n        target = random.randint(1, self.total)\n        # 二分搜尋找出第一個 prefix_sum[i] >= target 的索引\n        return bisect.bisect_left(self.prefix_sum, target)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 將輸入包裝成一個 JSON 陣列，方便解析\n    data = '[' + data + ']'\n    methods, args_list = json.loads(data)\n\n    result = []\n    obj = None\n    for method, args in zip(methods, args_list):\n        if method == \"Solution\":\n            obj = Solution(*args)\n            result.append(None)          # constructor 的回傳值為 null\n        else:\n            out = getattr(obj, method)(*args)\n            result.append(out)\n\n    # 以 JSON 方式輸出，null 將被轉成小寫字母\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to produce virtual code for solution to weighted random picking problem. Provide step-by-step pseudo-code with explanations per line. Must not output real code. Use arrows etc. Should include building prefix sum array in constructor, and pickIndex using random uniform and binary search. We'll produce steps accordingly.\n\nLet's output:\n\nStart\n→ Step 1: Build prefix sums array prefix of w // store cumulative weights\n→ Step 2: total = prefix[-1] // total weight\nEnd of constructor\n\nThen pickIndex method:\n\nStart // pickIndex\n→ Step 1: Generate random integer r in [1, total] // inclusive\n→ Step 2: Binary search prefix to find first index with prefix[i] >= r // weighted random\n→ Decision: 如果找到 index? // always found\n    Yes → Step 3: Return index // chosen index\nEnd\n\nLet's make lines with explanation after space.\n\nUse arrow and indentation. Ensure each line ends with //.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化 prefix[0] = w[0] // 建立累積重量陣列的第一個元素\n→ Decision: 若 w.length > 1? // 判斷是否還有剩餘元素\n    Yes → Step 2: 從 i = 1 到 w.length-1 逐一執行\n        → Step 2.1: prefix[i] = prefix[i-1] + w[i] // 更新累積重量\n        → Step 2.2: 迴圈結束\n    No  → Step 2: 完成累積重量陣列構建\n→ Step 3: total = prefix[w.length-1] // 記錄總重量\nEnd // 建構子執行完畢\n\n// 下面為 pickIndex() 函式的虛擬碼\nStart // pickIndex 執行開始\n→ Step 1: 產生隨機整數 r，範圍為 [1, total] // 確保每個重量都有對應的隨機值區間\n→ Step 2: binarySearch(r, prefix) → index // 進行二分搜尋，找到首個 prefix[i] >= r 的索引\n→ Decision: index 是否為有效索引? // 理論上一定有效\n    Yes → Step 3: 回傳 index // 回傳選中的索引\n    No  → Step 4: 回傳 -1 // 失敗情況（實際上不會發生）\nEnd // pickIndex 執行結束"
    }
  ]
}