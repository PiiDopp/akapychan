{
  "run_index": 48,
  "total_files_found": 391,
  "total_files_processed": 323,
  "files_skipped": 68,
  "files_failed_load": 0,
  "---": "--- (以下基於 *題目* 總數) ---",
  "total_problems_attempted": 334,
  "generation_and_validation_success_count": 300,
  "generation_or_validation_failure_count": 34,
  "failed_cases_details": [
    {
      "title": "統計文字行數",
      "source_file": "900.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "（假設 data.txt 內容如下）\\nHello\\nPython\\nWorld",
          "expected_output": "檔案共有 3 行",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '檔案共有3行'\nGot (Norm):      '檔案共有1行'\n--- (Raw) ---\nRaw Expected: '檔案共有 3 行'\nRaw Got:      '檔案共有 1 行'"
        }
      ],
      "generated_code": "def main():\n    import sys\n    # 讀取 stdin，依規範需處理此輸入，雖在此題目中未實際使用\n    sys.stdin.read()\n\n    try:\n        with open('data.txt', 'r', encoding='utf-8') as f:\n            lines = f.readlines()\n            print(f'檔案共有 {len(lines)} 行')\n    except FileNotFoundError:\n        print('找不到檔案！')\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code with line by line steps. Requirements: start, end, with try except, open file, read lines, count lines, output count, except FileNotFoundError output message. Use with syntax. Each line: \"Step X:\" etc. Must use arrow arrows. Provide explanation after space.\n\nWe produce something like:\n\nStart\n→ Step 1: 嘗試打開名為 data.txt 的檔案以讀取模式 // 開始嘗試\n→ Decision: 檔案成功打開? // 判斷是否成功\n    Yes → Step 2: 讀取所有行至 lines 列表 // 讀取\n    Yes → Step 3: 計算 lines 長度並輸出 // 輸出行數\n    No  → Step 4: 輸出 '找不到檔案！' // 錯誤處理\nEnd\n\nBut need with syntax: Use with statement inside try. So we have try block: Step 1: 嘗試開啟檔案 with open('data.txt', 'r') as f: etc.\n\nBut we need to represent \"with\" as step. Eg: Step 1: 嘗試打開檔案 with open('data.txt', 'r') as f // 開啟檔案並確保關閉\n\nInside try we read lines etc. But we need a Decision: If FileNotFoundError then except block.\n\nSo steps:\n\nStart\n→ Step 1: 嘗試打開檔案 with open('data.txt', 'r') as f // 使用 with 以確保檔案自動關閉\n→ Decision: 是否成功打開? // try / except 檢查\n    Yes → Step 2: 讀取所有行到 lines // 讀取內容\n    Yes → Step 3: 計算行數 len(lines) // 計算\n    Yes → Step 4: 輸出行數 // 顯示\n    No  → Step 5: 輸出 '找不到檔案！' // 例外處理\nEnd\n\nBut we need to show try/except decision. So we can represent as:\n\n→ Decision: try? // 進入 try 區塊\n    Yes → Step 1: with open('data.txt', 'r') as f // 開啟檔案\n    Yes → Step 2: lines = f.readlines() // 讀取\n    Yes → Step 3: print(len(lines)) // 輸出\n    No → Step 4: print('找不到檔案！') // 異常處理\n\nBetter to show:\n\nStart\n→ Decision: 進入 try 區塊? // 決定是否執行 try\n    Yes → Step 1: with open('data.txt', 'r') as f // 使用 with 打開\n    Yes → Step 2: lines = f.readlines() // 讀取行\n    Yes → Step 3: print(len(lines)) // 輸出行數\n    No → Step 4: print('找不到檔案！') // 例外處理\nEnd\n\nBut we also need to express that the \"No\" path is from except. Could use Decision: 是否 FileNotFoundError? But maybe simpler:\n\nStart\n→ Step 1: 嘗試打開檔案 with open('data.txt', 'r') as f // 使用 with 以確保關閉\n→ Decision: 是否成功? // try / except\n    Yes → Step 2: 讀取所有行到 lines\n    Yes → Step 3: 計算行數 len(lines)\n    Yes → Step 4: 輸出行數\n    No  → Step 5: 輸出 '找不到檔案！'\n\nBut we need to show try / except. So we can show:\n\nStart\n→ Decision: 進入 try? // 進入 try 區塊\n    Yes → Step 1: with open('data.txt', 'r') as f // 開啟檔案\n    Yes → Step 2: lines = f.readlines() // 讀取\n    Yes → Step 3: print(len(lines)) // 輸出\n    No  → Step 4: print('找不到檔案！') // 檔案不存在\nEnd\n\nBut we need to clarify that \"No\" is from except. Use Decision: 如果 FileNotFoundError? // if error.\n\nThus:\n\nStart\n→ Decision: 是否有檔案? // 檢查檔案是否存在\n    Yes → Step 1: with open('data.txt', 'r') as f // 開啟檔案\n    Yes → Step 2: lines = f.readlines() // 讀取\n    Yes → Step 3: print(len(lines)) // 輸出行數\n    No  → Step 4: print('找不到檔案！') // 檔案不存在\n\nBut better: Show try block:\n\nStart\n→ Decision: 嘗試打開檔案 with open('data.txt', 'r') as f? // 進入 try\n    Yes → Step 1: lines = f.readlines() // 讀取\n    Yes → Step 2: print(len(lines)) // 輸出\n    No  → Step 3: print('找不到檔案！') // 在 except 處理\nEnd\n\nHowever the problem states: use with syntax and try / except. So the pseudo-code should reflect that.\n\nLet's produce:\n\nStart\n→ Decision: 進入 try 區塊? // 判斷是否進入 try\n    Yes → Step 1: with open('data.txt', 'r') as f // 開啟檔案\n    Yes → Step 2: lines = f.readlines() // 讀取所有行\n    Yes → Step 3: print(len(lines)) // 輸出行數\n    No  → Step 4: print('找不到檔案！') // 檔案不存在\nEnd\n\nBut we didn't show the except block. So we could use:\n\nStart\n→ Decision: 進入 try? // 進入 try 區塊\n    Yes → Step 1: with open('data.txt', 'r') as f // 打開檔案\n    Yes → Step 2: lines = f.readlines() // 讀取\n    Yes → Step 3: print(len(lines)) // 輸出\n    No  → Decision: 是否 FileNotFoundError? // 例外判斷\n        Yes → Step 4: print('找不到檔案！') // 顯示錯誤訊息\nEnd\n\nBut the \"No\" from try is only due to FileNotFoundError, so we can skip second decision.\n\nLet's produce a simple pseudo-code that covers try/except.\n\nMaybe we can do:\n\nStart\n→ Decision: 是否要執行 try? // 進入 try\n    Yes → Step 1: with open('data.txt', 'r') as f // 使用 with 打開檔案\n    Yes → Step 2: lines = f.readlines() // 讀取行\n    Yes → Step 3: print(len(lines)) // 輸出行數\n    No  → Step 4: print('找不到檔案！') // 捕捉 FileNotFoundError\nEnd\n\nBut to better illustrate try/except, we could use:\n\nStart\n→ Decision: 進入 try 區塊? // 判斷是否進入 try\n    Yes → Step 1: with open('data.txt', 'r') as f // 開啟檔案\n    Yes → Step 2: lines = f.readlines() // 讀取\n    Yes → Step 3: print(len(lines)) // 輸出\n    No → Decision: 是否 FileNotFoundError? // 例外處理\n        Yes → Step 4: print('找不到檔案！') // 顯示訊息\nEnd\n\nBut maybe too complicated. Let's just produce the simple pseudo-code with the essential steps. The instruction says \"逐行產生對應的虛擬碼\" and \"每行虛擬碼之後立即提供該行的簡短、直觀的解釋\". Use Start, End, Decision, arrow. They didn't say to include a try/except block explicitly but must use try/except. So we can include \"Decision: 是否 FileNotFoundError?\" but that's not exactly the same as \"try / except\".\n\nWe can include:\n\nStart\n→ Decision: 進入 try? // 進入 try 區塊\n    Yes → Step 1: with open('data.txt', 'r') as f // 使用 with 開啟檔案\n    Yes → Step 2: lines = f.readlines() // 讀取所有行\n    Yes → Step 3: print(len(lines)) // 輸出行數\n    No  → Step 4: print('找不到檔案！') // 檔案不存在時的處理\nEnd\n\nBut maybe include \"Decision: 是否 FileNotFoundError?\" after try. So:\n\nStart\n→ Decision: 進入 try? // 判斷是否進入 try\n    Yes → Step 1: with open('data.txt', 'r') as f // 使用 with 以確保關閉\n    Yes → Step 2: lines = f.readlines() // 讀取所有行\n    Yes → Step 3: print(len(lines)) // 輸出行數\n    No  → Decision: 是否 FileNotFoundError? // 判斷錯誤類型\n        Yes → Step 4: print('找不到檔案！') // 顯示錯誤訊息\nEnd\n\nLet's adopt that. Ensure each line ends with comment. Format:\n\nStart // 程式開始執行\n→ Decision: 進入 try? // 判斷是否進入 try 區塊\n    Yes → Step 1: with open('data.txt', 'r') as f // 使用 with 以確保關閉\n    Yes → Step 2: lines = f.readlines() // 讀取所有行\n    Yes → Step 3: print(len(lines)) // 輸出行數\n    No → Decision: 是否 FileNotFoundError? // 判斷錯誤類型\n        Yes → Step 4: print('找不到檔案！') // 顯示錯誤訊息\nEnd // 程式執行結束\n\nBut the indentation may be off. Use spaces to indent. In example, they used \"Yes →\" and \"No →\". So we should follow that pattern:\n\nStart // 程式開始執行\n→ Decision: 進入 try? // 判斷是否進入 try 區塊\n    Yes → Step 1: with open('data.txt', 'r') as f // 使用 with 以確保關閉\n    Yes → Step 2: lines = f.readlines() // 讀取所有行\n    Yes → Step 3: print(len(lines)) // 輸出行數\n    No  → Decision: 是否 FileNotFoundError? // 判斷錯誤類型\n        Yes → Step 4: print('找不到檔案！') // 顯示錯誤訊息\nEnd // 程式執行結束\n\nLet's produce this as final. Ensure no actual code. Provide virtual steps only. Use Chinese.\n\nLet's final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: 進入 try? // 判斷是否進入 try 區塊  \n Yes → Step 1: with open('data.txt', 'r') as f // 使用 with 以確保關閉  \n Yes → Step 2: lines = f.readlines() // 讀取所有行  \n Yes → Step 3: print(len(lines)) // 輸出行數  \n No  → Decision: 是否 FileNotFoundError? // 判斷錯誤類型  \n  Yes → Step 4: print('找不到檔案！') // 顯示錯誤訊息  \nEnd // 程式執行結束"
    },
    {
      "title": "模擬擲骰子遊戲",
      "source_file": "800.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "print(roll_dice(5))",
          "expected_output": "[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,6,1,4,2]#(結果會隨機，每次可能不同)'\nGot (Norm):      '[2,5,3,1,2]'\n--- (Raw) ---\nRaw Expected: '[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)'\nRaw Got:      '[2, 5, 3, 1, 2]'"
        }
      ],
      "generated_code": "import random\nimport sys\n\ndef roll_dice(n):\n    \"\"\"模擬擲 n 次六面骰，回傳結果列表。\"\"\"\n    results = []\n    for _ in range(n):\n        # random.randint(1, 6) 產生 1~6 的整數\n        results.append(random.randint(1, 6))\n    return results\n\ndef main():\n    # 從標準輸入讀取整段文字\n    code = sys.stdin.read()\n    # 只提供 roll_dice 函式給執行環境\n    namespace = {\"roll_dice\": roll_dice}\n    # 執行使用者輸入的程式碼\n    exec(code, namespace)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce step-by-step virtual code lines with explanations, following the format: each line with virtual code step, a space, then // explanation.\n\nUse arrows and structure: Start, End, Decision, etc. But this is straightforward: start, create function, loop, random, append, return, end. Use random module. No actual code. Just virtual code.\n\nLet's craft. Need each line.\n\nStart // Program starts\n\n→ Step 1: Import random module // Load random functions\n\n→ Step 2: Define function roll_dice(n) // Create function to roll n times\n\n→ Step 3: Initialize results list // Prepare empty list to store outcomes\n\n→ Decision: If n <= 0? // Check if number of rolls is valid\n\n    No → Step 4: Raise ValueError // Throw error for non-positive n\n\n    Yes → Step 5: For i from 1 to n // Loop n times\n\n        → Step 6: Generate random integer between 1 and 6 // Simulate dice roll\n\n        → Step 7: Append roll to results // Store outcome\n\n→ Step 8: Return results // Output list of rolls\n\nEnd // Program ends\n\nBut we need to use arrows \"→\" for flow. Also we need to use Decision block. Provide indentation maybe not necessary but use indent.\n\nWe must ensure each line is separate.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Import random module // 載入 random 函式庫  \n→ Step 2: Define function roll_dice(n) // 建立擲骰函式  \n→ Step 3: Initialize results list // 準備儲存所有擲骰結果的空串列  \n→ Decision: n <= 0? // 檢查擲骰次數是否合法  \n No  → Step 4: Raise ValueError // 非正整數時拋出錯誤  \n Yes → Step 5: For i from 1 to n // 進行 n 次迴圈  \n  → Step 6: Generate random integer between 1 and 6 // 模擬一次六面骰擲骰  \n  → Step 7: Append roll to results // 將擲出的點數加入結果串列  \n→ Step 8: Return results // 回傳完整的擲骰結果串列  \nEnd // 程式執行結束"
    },
    {
      "title": "計算程式執行時間",
      "source_file": "800.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "import time\n\ndef slow_add(a, b):\n    time.sleep(2)\n    return a + b\n\nprint(measure_time(slow_add, 3, 5))",
          "expected_output": "約 2.0 秒 (依電腦執行環境略有差異)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '約2.0秒(依電腦執行環境略有差異)'\nGot (Norm):      '2.0'\n--- (Raw) ---\nRaw Expected: '約 2.0 秒 (依電腦執行環境略有差異)'\nRaw Got:      '2.0'"
        }
      ],
      "generated_code": "import time\nimport sys\n\ndef measure_time(func, *args):\n    start = time.time()\n    func(*args)\n    end = time.time()\n    return round(end - start, 3)\n\ndef main():\n    code = sys.stdin.read()\n    exec(code, globals())\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code line by line, using arrows and Start End, etc. Must not output actual code. Just virtual steps. Provide explanation comment. For the requirement: function measure_time(func, *args) using time module to measure execution time, round to 3 decimal places, return result.\n\nVirtual code structure: Start, Step: import time? Actually import module at top. We'll just have Step: Import time module.\n\nThen define function measure_time. Then Step: record start_time = time.time(); Step: result = func(*args); Step: end_time = time.time(); Step: duration = end_time - start_time; Step: rounded_duration = round(duration, 3); Step: return rounded_duration.\n\nWe can combine steps. Provide explanations.\n\nEnsure each line has virtual code step and comment after //.\n\nUse arrows and structure: Start → Step: Import time module → Step: Define function → Step: Record start time → Step: Call function → Step: Record end time → Step: Calculate duration → Step: Round duration to 3 decimal places → Step: Return rounded duration → End.\n\nBut we also need to include step for returning result? The function returns the rounded duration, not the function result. The requirement says \"測量函數 func 執行所需的秒數，並回傳結果\" – maybe return the time. Ok.\n\nWe need to mention that *args passed to func.\n\nWe must not produce actual code. Just virtual steps.\n\nLet's craft:\n\nStart // 程式開始\n→ Step 1: Import the time module // 引入時間模組\n→ Step 2: Define function measure_time(func, *args) // 建立測量時間的函式\n→ Step 3: Record current time as start_time // 紀錄開始時間\n→ Step 4: Call func with *args and store result // 執行目標函式並儲存返回值（若需要可忽略）\n→ Step 5: Record current time as end_time // 紀錄結束時間\n→ Step 6: Compute duration = end_time - start_time // 計算執行時間差\n→ Step 7: Round duration to 3 decimal places -> rounded_duration // 四捨五入到小數點三位\n→ Step 8: Return rounded_duration // 回傳測量的秒數\nEnd // 程式結束\n\nBut need to use arrows: \"→\" before each step, except Start and End. Also Decision: not needed.\n\nMake sure to format exactly: \"Start // ...\" then each line \"→ Step X: ... // ...\" then End // ...\n\nThus produce output accordingly.\n...done thinking.\n\nStart // 程式開始  \n→ Step 1: Import the time module // 引入時間模組  \n→ Step 2: Define function measure_time(func, *args) // 建立測量時間的函式  \n→ Step 3: Record current time as start_time // 紀錄開始時間  \n→ Step 4: Call func with *args and store result // 執行目標函式並儲存返回值（若不需要結果可忽略）  \n→ Step 5: Record current time as end_time // 紀錄結束時間  \n→ Step 6: Compute duration = end_time - start_time // 計算執行時間差  \n→ Step 7: Round duration to 3 decimal places -> rounded_duration // 四捨五入到小數點三位  \n→ Step 8: Return rounded_duration // 回傳測量的秒數  \nEnd // 程式結束"
    },
    {
      "title": "集合函數練習",
      "source_file": "600.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "{'apple', 'orange', 'grape', 'melon'}",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '{\"apple\",\"orange\",\"grape\",\"melon\"}'\nGot (Norm):      '{\"grape\",\"melon\",\"orange\",\"apple\"}'\n--- (Raw) ---\nRaw Expected: \"{'apple', 'orange', 'grape', 'melon'}\"\nRaw Got:      \"{'grape', 'melon', 'orange', 'apple'}\""
        }
      ],
      "generated_code": "import sys\n\ndef main():\n    # 讀取所有輸入，雖然本題不需要，但符合「從標準輸入讀取」的要求\n    _ = sys.stdin.read()\n\n    # 初始化集合\n    fruits = {'apple', 'banana'}\n\n    # 1. 新增 'orange'\n    fruits.add('orange')\n\n    # 2. 一次新增 'grape' 與 'melon'\n    fruits.update(['grape', 'melon'])\n\n    # 3. 移除 'banana'\n    fruits.remove('banana')\n\n    # 4. 嘗試移除不存在的 'pineapple'，不會拋錯\n    fruits.discard('pineapple')\n\n    # 輸出最終集合\n    print(fruits)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines, each with explanation. Should show start, step lines, decision maybe not needed. It's just straightforward sequence of operations. Include Start and End. Use arrows. Provide line per operation. Provide explanation comments.\n\nLet's craft:\n\nStart\n→ Step 1: fruits ← {'apple', 'banana'} // 初始化集合\n→ Step 2: fruits.add('orange') // 新增單一元素\n→ Step 3: fruits.update({'grape', 'melon'}) // 一次新增多元素\n→ Step 4: fruits.remove('banana') // 移除已存在元素\n→ Step 5: fruits.discard('pineapple') // 嘗試移除不存在的元素，不拋錯誤\n→ Step 6: Output fruits // 輸出集合\nEnd\n\nBut need to maintain format: \"虛擬碼步驟 [space] // 解釋\". Use arrow. Provide the explanation after space.\n\nLet's write each line like:\n\nStart // 程式開始執行\n→ Step 1: fruits ← {'apple', 'banana'} // 初始化集合\n→ Step 2: fruits.add('orange') // 使用 add() 新增 'orange'\n→ Step 3: fruits.update({'grape', 'melon'}) // 使用 update() 新增 'grape' 與 'melon'\n→ Step 4: fruits.remove('banana') // 使用 remove() 移除 'banana'\n→ Step 5: fruits.discard('pineapple') // 使用 discard() 嘗試移除不存在的 'pineapple'，不拋錯誤\n→ Step 6: Output fruits // 輸出最終集合\nEnd // 程式執行結束\n\nThat's fine. Ensure each line ends with comment. Ensure format: \"虛擬碼步驟\" + space + \"// 解釋\". The arrow lines include \"→\". That seems okay.\n\nReturn in markdown block? The format requires code block, but examples show code block. So we should wrap in triple backticks. We'll do that.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: fruits ← {'apple', 'banana'} // 初始化集合\n→ Step 2: fruits.add('orange') // 使用 add() 新增 'orange'\n→ Step 3: fruits.update({'grape', 'melon'}) // 使用 update() 新增 'grape' 與 'melon'\n→ Step 4: fruits.remove('banana') // 使用 remove() 移除 'banana'\n→ Step 5: fruits.discard('pineapple') // 使用 discard() 嘗試移除不存在的 'pineapple'，不拋錯誤\n→ Step 6: Output fruits // 輸出最終集合\nEnd // 程式執行結束\n```"
    },
    {
      "title": "即時匯率查詢小工具",
      "source_file": "1200.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "按下「更新匯率」按鈕",
          "expected_output": "目前美元匯率：約 32.5 TWD",
          "actual_output_or_error": "[Validation Error] Code execution timed out (10s)."
        }
      ],
      "generated_code": "import sys\nimport requests\nimport tkinter as tk\n\ndef fetch_rate():\n    \"\"\"\n    從匯率 API 取得 USD 對 TWD 的匯率。\n    成功時回傳浮點數，失敗時回傳 None。\n    \"\"\"\n    url = \"https://api.exchangerate-api.com/v4/latest/USD\"\n    try:\n        resp = requests.get(url, timeout=10)\n        resp.raise_for_status()\n        data = resp.json()\n        return data[\"rates\"][\"TWD\"]\n    except Exception:\n        return None\n\ndef update_label(label):\n    \"\"\"\n    取得最新匯率並更新 Label 的文字。\n    \"\"\"\n    rate = fetch_rate()\n    if rate is not None:\n        label.config(text=f\"目前美元匯率：約 {rate} TWD\")\n    else:\n        label.config(text=\"更新失敗，請檢查網路連線\")\n\ndef main():\n    \"\"\"\n    1. 讀取標準輸入並處理指令。\n    2. 若收到「更新匯率」相關文字，立即抓取匯率並輸出。\n    3. 接著啟動 tkinter GUI，按鈕可再次更新匯率。\n    \"\"\"\n    # 讀取整個 stdin（可處理多行輸入）\n    user_input = sys.stdin.read().strip()\n\n    # 若輸入包含「更新匯率」關鍵字，直接印出結果\n    if \"更新匯率\" in user_input or \"按下\" in user_input:\n        rate = fetch_rate()\n        if rate is not None:\n            print(f\"目前美元匯率：約 {rate} TWD\")\n        else:\n            print(\"更新失敗，請檢查網路連線\")\n\n    # 建立 tkinter GUI\n    win = tk.Tk()\n    win.title(\"匯率查詢\")\n\n    label = tk.Label(win, text=\"請按下按鈕更新匯率\", font=(\"Arial\", 12))\n    label.pack(pady=10)\n\n    btn = tk.Button(win, text=\"更新匯率\",\n                    command=lambda: update_label(label))\n    btn.pack(pady=5)\n\n    # 初次更新一次以顯示目前匯率\n    update_label(label)\n\n    win.mainloop()\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines, each line includes code step and explanation. Need to use virtual arrows, Start, End, Decision. The user wants to fetch API via requests, display in Tkinter window, button updates rate. We produce pseudo-code steps line by line.\n\nWe need to keep each line: \"虛擬碼步驟 [space] // 解釋\". Use arrows like \"→\". Use decision blocks. Provide line by line steps.\n\nLet's produce.\n\nWe might include initialization of Tkinter root, label, button, function to fetch rate, update label, mainloop. Also decision on request success.\n\nLet's produce as per format.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Import requests, tkinter, json // 匯入必要模組  \n→ Step 2: Create Tkinter root window with title \"USD/TWD 匯率查詢\" // 初始化視窗  \n→ Step 3: Create Label widget to顯示匯率，初始文字為 \"匯率尚未取得\" // 顯示區域  \n→ Step 4: Create Button widget，標題 \"更新匯率\"，點擊時觸發 fetch_rate 函式 // 按鈕  \n→ Step 5: Pack Label 與 Button 進入 root 視窗 // 排版  \n→ Step 6: Define Function fetch_rate() // 定義取得匯率的流程  \n  → Step 6.1: Set url = \"https://api.exchangerate-api.com/v4/latest/USD\" // API 端點  \n  → Step 6.2: Try:  \n    → Step 6.2.1: response = requests.get(url) // 發送 GET 請求  \n    → Decision: response.status_code == 200? // 檢查回應成功  \n      Yes → Step 6.2.2: data = response.json() // 解析 JSON  \n       → Step 6.2.3: twd_rate = data[\"rates\"][\"TWD\"] // 取得台幣匯率  \n       → Step 6.2.4: Update Label text to f\"USD ≈ {twd_rate} TWD\" // 顯示結果  \n       → Step 6.2.5: End // 完成成功流程  \n      No → Step 6.2.6: Update Label text to \"取得匯率失敗，請稍後重試\" // 顯示錯誤  \n       → Step 6.2.7: End // 完成失敗流程  \n    Catch Exception as e:  \n     → Step 6.2.8: Update Label text to f\"錯誤: {e}\" // 顯示例外訊息  \n     → Step 6.2.9: End // 捕捉異常  \n→ Step 7: Assign fetch_rate function to Button command // 連結事件  \n→ Step 8: Call fetch_rate() 一次以顯示初始匯率 // 初始更新  \n→ Step 9: root.mainloop() // 啟動事件迴圈，等待使用者操作  \nEnd // 程式執行結束"
    },
    {
      "title": "Top K Frequent Elements",
      "source_file": "Leetcode/leetcode347.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,1,1,2,2,3], k = 2",
          "expected_output": "[1,2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpmlg1n8t8.py\", line 28, in <module>\n    main()\n  File \"/tmp/tmpmlg1n8t8.py\", line 18, in main\n    exec(data, {}, local_vars)\n  File \"<string>\", line 1\n    nums = [1,1,1,2,2,3], k = 2\n    ^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "nums = [1], k = 1",
          "expected_output": "[1]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp63ukz0lw.py\", line 28, in <module>\n    main()\n  File \"/tmp/tmp63ukz0lw.py\", line 18, in main\n    exec(data, {}, local_vars)\n  File \"<string>\", line 1\n    nums = [1], k = 1\n    ^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 2,
          "input": "nums = [1,2,1,2,1,2,3,1,3,2], k = 2",
          "expected_output": "[1,2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmptcj82tnr.py\", line 28, in <module>\n    main()\n  File \"/tmp/tmptcj82tnr.py\", line 18, in main\n    exec(data, {}, local_vars)\n  File \"<string>\", line 1\n    nums = [1,2,1,2,1,2,3,1,3,2], k = 2\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "import sys\nfrom collections import Counter\nimport heapq\n\nclass Solution:\n    def topKFrequent(self, nums, k):\n        # 計算每個數字出現的頻率\n        freq = Counter(nums)\n        # 取頻率最高的 k 個元素，返回其值\n        return [item for item, _ in heapq.nlargest(k, freq.items(), key=lambda x: x[1])]\n\ndef main():\n    # 讀取整個輸入，並利用 exec 將其解譯成變量\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    local_vars = {}\n    exec(data, {}, local_vars)\n\n    nums = local_vars['nums']\n    k = local_vars['k']\n\n    solution = Solution()\n    result = solution.topKFrequent(nums, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm: Given array nums and k, return k most frequent elements. Use a hash map to count frequencies, then a max heap or min-heap of size k. Or we could sort by frequency. Provide step-by-step virtual code with explanations. Must output in required format: each line: \"虛擬碼步驟 // 解釋/說明\". Use Start, End, Decision: etc. Must not output actual code. Just structure steps. Let's produce algorithm: Start, input nums, k. Build frequency map. Build min-heap of size k (or use array). Iterate entries: if heap size < k, push. Else if current freq > heap root freq, replace root. After loop, extract heap elements as result. End.\n\nWe need to use arrow notation: \"→ Step X:\" etc.\n\nWe'll produce something like:\n\nStart // 程式開始執行\n→ Step 1: 初始化頻率字典 freqMap // 建立空哈希表以儲存每個數字的出現次數\n→ Step 2: 對 nums 中每個數字 num: // 遍歷輸入陣列\n    → Step 2a: 更新 freqMap[num] += 1 // 記錄數字的出現次數\n→ Step 3: 建立最小堆 minHeap，容量為 k // 用於存儲頻率最高的 k 個數字\n→ Step 4: 對 freqMap 中每個 (num, count)：\n    → Decision: minHeap 大小 < k? // 檢查堆是否已滿\n        Yes → Step 4a: 插入 (count, num) 到 minHeap // 堆未滿，直接加入\n        No  → Decision: count > minHeap.根 // 需要比較新數字的頻率\n            Yes → Step 4b: 替換堆頂元素，插入 (count, num) // 用更高頻率的數字替換\n            No  → Step 4c: 跳過 // 新數字頻率不高於堆中最小頻率，忽略\n→ Step 5: 從 minHeap 中提取所有元素，將 num 存入結果陣列 result // 收集 k 個最頻繁數字\n→ Step 6: 返回 result // 輸出結果\nEnd // 程式結束\n\nBut need to match format: \"虛擬碼步驟\" + space + \"// 解釋/說明\". For arrows: use \"→\" preceding step lines.\n\nWe also need \"Start\" and \"End\" lines.\n\nWe should format each line as:\n\nStart // 程式開始執行\n→ Step 1: 初始化頻率字典 freqMap // 建立空哈希表以儲存每個數字的出現次數\n→ Step 2: 對 nums 中每個數字 num: // 遍歷輸入陣列\n    → Step 2a: 更新 freqMap[num] += 1 // 記錄數字的出現次數\n→ Step 3: 建立最小堆 minHeap，容量為 k // 用於存儲頻率最高的 k 個數字\n→ Step 4: 對 freqMap 中每個 (num, count)：\n    → Decision: minHeap 大小 < k? // 檢查堆是否已滿\n        Yes → Step 4a: 插入 (count, num) 到 minHeap // 堆未滿，直接加入\n        No  → Decision: count > minHeap.根 // 需要比較新數字的頻率\n            Yes → Step 4b: 替換堆頂元素，插入 (count, num) // 用更高頻率的數字替換\n            No  → Step 4c: 跳過 // 新數字頻率不高於堆中最小頻率，忽略\n→ Step 5: 從 minHeap 中提取所有元素，將 num 存入結果陣列 result // 收集 k 個最頻繁數字\n→ Step 6: 返回 result // 輸出結果\nEnd // 程式結束\n\nHowever each line must not have nested indentation? We can still show indentation lines but it's okay. But the format demands each line be a single line. For nested decision, we can indent lines with spaces or tabs. The example shows indentation with spaces for nested lines. We'll replicate.\n\nThus final answer should be this block.\n\nLet's ensure each line has \"虛擬碼步驟\" followed by space then comment. Eg \"Start // 程式開始執行\". Ok.\n\nWe need to use \"Decision:\" lines. Good.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化頻率字典 freqMap // 建立空哈希表以儲存每個數字的出現次數  \n→ Step 2: 對 nums 中每個數字 num: // 遍歷輸入陣列  \n  → Step 2a: 更新 freqMap[num] += 1 // 記錄數字的出現次數  \n→ Step 3: 建立最小堆 minHeap，容量為 k // 用於存儲頻率最高的 k 個數字  \n→ Step 4: 對 freqMap 中每個 (num, count)： // 遍歷頻率字典  \n  → Decision: minHeap 大小 < k? // 檢查堆是否已滿  \n   Yes → Step 4a: 插入 (count, num) 到 minHeap // 堆未滿，直接加入  \n   No  → Decision: count > minHeap.根 // 比較新數字頻率與堆中最小頻率  \n    Yes → Step 4b: 替換堆頂元素，插入 (count, num) // 用更高頻率的數字替換  \n    No  → Step 4c: 跳過 // 新數字頻率不高於堆中最小頻率，忽略  \n→ Step 5: 從 minHeap 中提取所有元素，將 num 存入結果陣列 result // 收集 k 個最頻繁數字  \n→ Step 6: 返回 result // 輸出結果  \nEnd // 程式結束"
    },
    {
      "title": "Random Flip Matrix",
      "source_file": "Leetcode/leetcode519.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"flip\", \"flip\", \"flip\", \"reset\", \"flip\"], [[3, 1], [], [], [], [], []]",
          "expected_output": "[null, [1,0], [2,0], [0,0], null, [2,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[1,0],[2,0],[0,0],null,[2,0]]'\nGot (Norm):      '[null,[2,0],[0,0],[1,0],null,[0,0]]'\n--- (Raw) ---\nRaw Expected: '[null, [1,0], [2,0], [0,0], null, [2,0]]'\nRaw Got:      '[null, [2, 0], [0, 0], [1, 0], null, [0, 0]]'"
        }
      ],
      "generated_code": "import sys\nimport random\nimport json\n\nclass Solution:\n    def __init__(self, m: int, n: int):\n        self.m = m\n        self.n = n\n        self.total = m * n          # 總格數\n        self.remaining = self.total # 還未被翻轉的格子數\n        self.indices = list(range(self.total))  # 可選格子索引\n\n    def flip(self):\n        if self.remaining == 0:\n            raise Exception(\"No zeros left\")\n        # 隨機挑選剩餘格子中的一個位置\n        r = random.randint(0, self.remaining - 1)\n        idx = self.indices[r]              # 實際的全域索引\n        # 把選中的索引移到列表末端，以免再次選到\n        self.indices[r], self.indices[self.remaining - 1] = \\\n            self.indices[self.remaining - 1], self.indices[r]\n        self.remaining -= 1\n        # 將全域索引轉換為 (i, j)\n        return [idx // self.n, idx % self.n]\n\n    def reset(self):\n        self.remaining = self.total\n        self.indices = list(range(self.total))\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # 讀取輸入，格式為兩個列表: [\"Solution\",\"flip\", ...], [[3,1], [], ...]\n    commands, arguments = eval(data)\n    outputs = []\n    instance = None\n    for cmd, arg in zip(commands, arguments):\n        if cmd == \"Solution\":\n            instance = Solution(*arg)\n            outputs.append(None)\n        elif cmd == \"flip\":\n            outputs.append(instance.flip())\n        elif cmd == \"reset\":\n            instance.reset()\n            outputs.append(None)\n    print(json.dumps(outputs))",
      "virtual_code": "Thinking...\nWe need to generate step-by-step virtual code for algorithm. Use minimal random calls. Standard solution: maintain list of available indices 0..m*n-1. Each flip: pick random r from 0..len-1, choose index r, map to (i,j) via divmod, then swap selected with last in list and decrement len. For reset, rebuild list.\n\nWe need to output as virtual code lines with comments. Provide Start, End, Decision blocks. Provide steps for initialization, flip, reset. Also mention data structures: array or vector of ints. Let's produce.\n\nWe need to be careful to include comments after space. Format: each line \"Step: ... // comment\".\n\nLet's design:\n\nStart\n→ Step 1: Set total = m * n // total cells\n→ Step 2: Create list L = [0,1,...,total-1] // mapping of cell indices\n→ Step 3: Set remaining = total // number of unflipped cells\nEnd // initialization complete\n\nThen for flip():\nStart\n→ Step 1: r = random_int(0, remaining-1) // pick random position among remaining cells\n→ Decision: If remaining == 0? // all flipped\n    Yes → Throw exception // no available cell\n    No  → Continue\n→ Step 2: idx = L[r] // index of chosen cell\n→ Step 3: Swap L[r] and L[remaining-1] // move used index to end\n→ Step 4: remaining -= 1 // one less available cell\n→ Step 5: i = idx // m // compute row\n→ Step 6: j = idx % n // compute column\n→ Step 7: return [i, j] // output coordinates\nEnd\n\nreset():\nStart\n→ Step 1: Rebuild L = [0,...,total-1] // reset mapping\n→ Step 2: remaining = total // reset count\nEnd\n\nWe also need to mention that list L can be an array of ints; swap O(1). No extra memory per cell.\n\nOk produce virtual code. Use \"Decision:\" for check remaining==0.\n\nNeed to ensure arrow syntax: \"→\" each step. Use \"Yes →\" etc. For example:\n\n→ Decision: remaining == 0? // no available cells\n    Yes → Throw Error // nothing to flip\n    No  → Proceed\n\nAlso mention that random_int returns integer inclusive.\n\nWe must not output actual code. Just pseudo steps.\n\nLet's format lines exactly as requested: each line \"虛擬碼步驟 [space] // 解釋\". Use Start, End.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: total = m * n // 計算矩陣總格數\n→ Step 2: L = [0, 1, …, total-1] // 建立可選格索引列表\n→ Step 3: remaining = total // 記錄還未翻轉的格子數\nEnd // 初始化完成\n\n// ----------------------------\n// flip() 函式\nStart // flip() 開始\n→ Decision: remaining == 0? // 是否所有格子已被翻轉？\n    Yes → Throw Error // 沒有可選格子，直接錯誤回報\n    No  → Proceed // 有可選格子，繼續執行\n→ Step 1: r = random_int(0, remaining-1) // 隨機選取剩餘格子中的索引位置\n→ Step 2: idx = L[r] // 取得對應的全域索引 (0 ~ total-1)\n→ Step 3: Swap L[r] and L[remaining-1] // 將選取的索引移到列表末端，保留其位置\n→ Step 4: remaining -= 1 // 更新剩餘未翻轉格子數\n→ Step 5: i = idx // m // 計算行號\n→ Step 6: j = idx % n // 計算列號\n→ Step 7: return [i, j] // 回傳該格子座標\nEnd // flip() 執行結束\n\n// ----------------------------\n// reset() 函式\nStart // reset() 開始\n→ Step 1: L = [0, 1, …, total-1] // 重新填充所有格子索引\n→ Step 2: remaining = total // 重新設定剩餘格子數\nEnd // reset() 執行結束\nEnd // 程式執行結束"
    },
    {
      "title": "IPO",
      "source_file": "Leetcode/leetcode502.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]",
          "expected_output": "4",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpgyc98hlx.py\", line 46, in <module>\n    params = parse_input(raw_input)\n             ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpgyc98hlx.py\", line 37, in parse_input\n    data[key] = ast.literal_eval(val)\n                ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "k = 3, w = 0, profits = [1,2,3], capital = [0,1,2]",
          "expected_output": "6",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpndh3edlk.py\", line 46, in <module>\n    params = parse_input(raw_input)\n             ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpndh3edlk.py\", line 37, in parse_input\n    data[key] = ast.literal_eval(val)\n                ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport re\nimport heapq\nimport ast\n\nclass Solution:\n    def findMaximizedCapital(self, k, W, Profits, Capital):\n        # 將專案依資本需求升序排列\n        projects = sorted(zip(Capital, Profits))\n        max_heap = []            # 儲存可負擔專案的利潤（最大堆）\n        i = 0                    # 專案指標\n        n = len(Profits)\n\n        for _ in range(k):\n            # 把所有目前能負擔的專案放入最大堆\n            while i < n and projects[i][0] <= W:\n                heapq.heappush(max_heap, -projects[i][1])\n                i += 1\n            if not max_heap:\n                break              # 沒有可執行的專案，結束\n            # 選取利潤最高的專案並完成\n            W += -heapq.heappop(max_heap)\n        return W\n\ndef parse_input(text: str):\n    \"\"\"\n    解析類似 'k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]'\n    的輸入字串，返回相應的變數。\n    \"\"\"\n    pattern = r'(\\w+)\\s*=\\s*([^\\n,]+)'\n    matches = re.findall(pattern, text)\n    data = {}\n    for key, val in matches:\n        val = val.strip()\n        if val.startswith('['):\n            # 使用 ast.literal_eval 解析列表\n            data[key] = ast.literal_eval(val)\n        else:\n            data[key] = int(val)\n    return data\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n    params = parse_input(raw_input)\n\n    k = params.get('k')\n    w = params.get('w')\n    profits = params.get('profits')\n    capital = params.get('capital')\n\n    sol = Solution()\n    result = sol.findMaximizedCapital(k, w, profits, capital)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for solving this problem: maximize capital after at most k projects. Classic LeetCode problem \"IPO\". Approach: use max-heap for profits of projects whose capital <= current capital, and a min-heap for projects sorted by capital. Steps: sort projects by capital ascending; use a min-heap to store all projects sorted by capital; use max-heap for profits of eligible projects; iterate k times: pop from min-heap all projects with capital <= current capital and push profit into max-heap; if max-heap empty break; pop max profit, add to capital. End. Return capital.\n\nWe produce pseudo steps line by line with explanation. Use virtual code arrows. Ensure each line: \"虛擬碼步驟 // 解釋\". Format similar to example.\n\nWe should start with Start. Need to mention input: n, profits, capital, k, w. Provide steps: sort projects by capital ascending, store pair(capital, profit). Use min-heap for projects sorted by capital. Use max-heap for profits of affordable projects.\n\nProceed loop from i=0 to k-1: while min-heap not empty and min-capital <= w: pop from min-heap push profit into max-heap. Then Decision: max-heap empty? Yes → End loop? Actually if empty break. If not empty: pop max profit, add to w. After loop End // Return w.\n\nLet's craft each step.\n\nWe might also include initialisation of heaps.\n\nNeed to keep format: \"Start // 程式開始執行\" etc.\n\nLet's output lines. Provide explanations in Chinese.\n\nEnsure use arrows: \"→\" preceding step. Indentation maybe.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得輸入 n, profits[], capital[], k, w // 取得問題的參數  \n→ Step 2: 建立 projects list 以 (capital[i], profits[i]) 為元組並排序升序 // 方便按資本需求檢索  \n→ Step 3: 初始化 minCapitalHeap ← projects（按 capital 最小） // 儲存所有尚未考慮的專案  \n→ Step 4: 初始化 maxProfitHeap ← 空 // 儲存目前可負擔專案的利潤  \n→ Step 5: 從 1 到 k 重複以下步驟 // 最高可執行 k 個專案  \n  → Decision: 目前 w 是否足以啟動至少一個專案？ // 判斷是否有可執行專案  \n    Yes → While minCapitalHeap 非空 且 minCapitalHeap.top.capital ≤ w  \n      → Step 6: 將 minCapitalHeap.top.pop() 的利潤加入 maxProfitHeap // 將可負擔專案的利潤放入最大堆  \n      End While  \n      Decision: maxProfitHeap 是否為空？ // 若沒有可取利潤的專案  \n       Yes → Break 循環 // 無法再執行任何專案  \n       No  → Step 7: 取 maxProfitHeap.top() 的最大利潤並 pop // 選取最優利潤  \n        → Step 8: w ← w + 取出的利潤 // 更新總資本  \n       End Decision  \n      End Decision  \n  End For  \n→ Step 9: 返回 w // 最終最大資本  \nEnd // 程式執行結束"
    },
    {
      "title": "Min Stack",
      "source_file": "Leetcode/leetcode155.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"],[[],[-2],[0],[-3],[],[],[],[]]",
          "expected_output": "[null,null,null,null,-3,null,0,-2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp6rw06u80.py\", line 38, in <module>\n    ops, args = json.loads(data)\n                ^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 64 (char 63)"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass MinStack:\n    \"\"\"實作常數時間取最小值的堆疊\"\"\"\n    def __init__(self):\n        self.stack = []        # 主堆疊\n        self.min_stack = []    # 儲存目前最小值的堆疊\n\n    def push(self, val: int) -> None:\n        self.stack.append(val)\n        # 若 min_stack 為空或新值小於等於目前最小值，則更新 min_stack\n        if not self.min_stack or val <= self.min_stack[-1]:\n            self.min_stack.append(val)\n\n    def pop(self) -> None:\n        if not self.stack:\n            return\n        val = self.stack.pop()\n        # 同時更新 min_stack\n        if self.min_stack and val == self.min_stack[-1]:\n            self.min_stack.pop()\n\n    def top(self) -> int:\n        return self.stack[-1] if self.stack else None\n\n    def getMin(self) -> int:\n        return self.min_stack[-1] if self.min_stack else None\n\nif __name__ == \"__main__\":\n    # 讀取完整輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 輸入格式為兩個 JSON 陣列，例如:\n    # [\"MinStack\",\"push\",\"push\"],[[],[-2],[3]]\n    ops, args = json.loads(data)\n\n    results = []\n    stack = None\n\n    for op, arg in zip(ops, args):\n        if op == \"MinStack\":\n            stack = MinStack()\n            results.append(None)            # 代表 null\n        elif op == \"push\":\n            stack.push(arg[0])\n            results.append(None)\n        elif op == \"pop\":\n            stack.pop()\n            results.append(None)\n        elif op == \"top\":\n            results.append(stack.top())\n        elif op == \"getMin\":\n            results.append(stack.getMin())\n        else:\n            # 若遇到未知操作，直接忽略\n            results.append(None)\n\n    # 輸出結果，None 會轉成 JSON 的 null\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line with comments. For a MinStack with O(1). Usually use two stacks: main stack and min stack. Let's produce steps: Start, define class, constructor: initialize two stacks. Then push: push to main stack; if min stack empty or val <= minStack.top, push to min stack. pop: pop main stack; if popped equals minStack.top, pop min stack. top: return main stack.top. getMin: return minStack.top.\n\nWe need virtual code steps; each line: e.g., \"Start // 程式開始\". Then maybe \"→ Step 1: Define class MinStack // 定義 MinStack 類別\". But we need to reflect operations.\n\nWe'll produce flow: \"Start\" -> \"→ Step 1: Initialize two stacks S and M // 主堆疊及最小堆疊\". Then decision for push: maybe \"→ Step 2: push(val) // 將 val 推入主堆疊\". \"→ Decision: 是否 val <= M.top? // 判斷是否需要更新最小堆疊\". \"Yes → Step 3: push(val) to M // 更新最小堆疊\". Then \"No → Step 4: 只更新主堆疊\". Then \"→ End push\". Similar for pop. We'll output each line of virtual code, not actual code.\n\nMake sure to include \"Decision:\" lines. Provide simple explanation.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始\n→ Step 1: 定義 MinStack 類別 // 建立一個 MinStack 物件\n→ Step 2: 初始化兩個堆疊 S 與 M // S 用於儲存所有元素，M 用於儲存當前最小值\n→ Step 3: MinStack() // 建構子，建立空堆疊 S 與 M\n→ Step 4: End MinStack() // 結束建構子\n\n→ Step 5: push(val) // 將值 val 推入主堆疊\n→ Decision: 是否 M 為空 或 val <= M.top? // 判斷是否需要更新最小堆疊\n    Yes → Step 6: M.push(val) // 把 val 推入最小堆疊\n    No  → Step 7: 只更新主堆疊\n→ Step 8: End push // push 完成\n\n→ Step 9: pop() // 移除主堆疊頂端元素\n→ Step 10: temp ← S.pop() // 先彈出主堆疊頂端值\n→ Decision: temp == M.top? // 判斷彈出的值是否為目前最小值\n    Yes → Step 11: M.pop() // 同時從最小堆疊彈出\n    No  → Step 12: 不做任何操作\n→ Step 13: End pop // pop 完成\n\n→ Step 14: top() // 取得主堆疊頂端元素\n→ Step 15: Return S.top() // 回傳主堆疊頂端值\n→ Step 16: End top // top 完成\n\n→ Step 17: getMin() // 取得最小值\n→ Step 18: Return M.top() // 回傳最小堆疊頂端值\n→ Step 19: End getMin // getMin 完成\n\nEnd // 程式執行結束"
    },
    {
      "title": "Subsets II",
      "source_file": "Leetcode/leetcode90.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,2]",
          "expected_output": "[[],[1],[1,2],[1,2,2],[2],[2,2]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[1,2],[1,2,2],[2],[2,2]]'\nGot (Norm):      '[[],[1],[2],[1,2],[2,2],[1,2,2]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[1,2],[1,2,2],[2],[2,2]]'\nRaw Got:      '[[], [1], [2], [1, 2], [2, 2], [1, 2, 2]]'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def subsetsWithDup(self, nums):\n        nums.sort()\n        result = [[]]\n        for num in nums:\n            new_subsets = []\n            for subset in result:\n                new_subsets.append(subset + [num])\n            result += new_subsets\n        unique_res = []\n        seen = set()\n        for subset in result:\n            t = tuple(subset)\n            if t not in seen:\n                seen.add(t)\n                unique_res.append(subset)\n        return unique_res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        nums = []\n    else:\n        # Extract the list part from input like 'nums = [1,2,2]'\n        match = re.search(r'\\[.*\\]', data)\n        if match:\n            nums = ast.literal_eval(match.group(0))\n        else:\n            nums = []\n\n    solution = Solution()\n    result = solution.subsetsWithDup(nums)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code lines with arrows, decisions etc. Need to output for requirement: given integer array possibly duplicates, return all subsets without duplicates. Standard algorithm: sort array, backtrack with skip duplicates.\n\nWe need step-by-step pseudo-code.\n\nWe should produce Start, then maybe Step: sort array, then Step: define result list, Step: define backtrack function, etc.\n\nUse \"→\" for each line. Decision lines indent.\n\nWe must include brief explanation comment after \"//\".\n\nThe requirement: Use virtual code lines only, no actual code.\n\nWe produce something like:\n\nStart // 程式開始\n→ Step 1: Sort nums ascending // 為了便於跳過重複值\n→ Step 2: Initialize result = [] // 用於儲存所有子集\n→ Step 3: Define Backtrack(start, current) // 回溯函式\n    → Step 4: Append copy of current to result // 保存當前子集\n    → Decision: start < len(nums) // 是否還有元素可加入\n        Yes → Step 5: For i from start to len(nums)-1\n            → Decision: i > start AND nums[i] == nums[i-1] // 重複檢查\n                Yes → Step 6: Continue // 跳過重複元素\n                No → Step 7: Append nums[i] to current // 選取元素\n                → Step 8: Call Backtrack(i+1, current) // 深入下一層\n                → Step 9: Remove last element from current // 回溯\n        No → Step 10: Return // 無更多元素\n→ Step 11: Call Backtrack(0, []) // 開始回溯\n→ Step 12: Return result // 回傳所有子集\nEnd // 程式執行結束\n\nBut must follow format: \"虛擬碼步驟 [space] // 解釋\". Use arrows. Indent decisions with tab.\n\nEnsure each line has \"→\" or \"Decision:\" etc. Use indentation for nested.\n\nAlso include \"Start\" line. Use \"End\". Use \"Decision:\" with \"Yes →\" and \"No →\". Use proper indentation.\n\nAlso maybe need to include \"Return result\" as a step.\n\nLet's craft final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort nums ascending // 先排序，方便後續跳過重複元素  \n→ Step 2: Initialize result = [] // 用於儲存所有子集  \n→ Step 3: Define Backtrack(start, current) // 回溯函式，start 為可選元素索引  \n → Step 4: Append copy of current to result // 將目前子集加入結果  \n → Decision: start < len(nums) // 是否還有可選元素？  \n  Yes → Step 5: For i from start to len(nums)-1 // 遍歷剩餘元素  \n     Decision: i > start AND nums[i] == nums[i-1] // 同階層重複？  \n      Yes → Step 6: Continue // 跳過重複元素  \n      No  → Step 7: Append nums[i] to current // 選取元素  \n       → Step 8: Call Backtrack(i+1, current) // 進一步遞迴  \n       → Step 9: Remove last element from current // 回溯到上一層  \n  No  → Step 10: Return // 無可選元素，回到上一層  \n→ Step 11: Call Backtrack(0, []) // 從首位開始回溯  \n→ Step 12: Return result // 回傳所有子集  \nEnd // 程式執行結束"
    },
    {
      "title": "Add Strings",
      "source_file": "Leetcode/leetcode415.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "num1 = \"11\", num2 = \"123\"",
          "expected_output": "\"134\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '134'\nGot (Norm):      '12'\n--- (Raw) ---\nRaw Expected: '\"134\"'\nRaw Got:      '\"12\"'"
        },
        {
          "example_index": 1,
          "input": "num1 = \"456\", num2 = \"77\"",
          "expected_output": "\"533\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '533'\nGot (Norm):      '457'\n--- (Raw) ---\nRaw Expected: '\"533\"'\nRaw Got:      '\"457\"'"
        },
        {
          "example_index": 2,
          "input": "num1 = \"0\", num2 = \"0\"",
          "expected_output": "\"0\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '0'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: '\"0\"'\nRaw Got:      '\"1\"'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def addStrings(self, num1: str, num2: str) -> str:\n        i, j = len(num1) - 1, len(num2) - 1\n        carry = 0\n        res = []\n\n        while i >= 0 or j >= 0 or carry:\n            x = int(num1[i]) if i >= 0 else 0\n            y = int(num2[j]) if j >= 0 else 0\n            total = x + y + carry\n            res.append(str(total % 10))\n            carry = total // 10\n            i -= 1\n            j -= 1\n\n        return ''.join(reversed(res))\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    # 從輸入中擷取所有數字字串（可包含變數名稱、等號等）\n    nums = re.findall(r'\\d+', data)\n    if len(nums) >= 2:\n        num1, num2 = nums[0], nums[1]\n        solution = Solution()\n        # 依題目示例，輸出帶雙引號的結果\n        print(f'\"{solution.addStrings(num1, num2)}\"')",
      "virtual_code": "Thinking...\nWe need to produce virtual code for adding two non-negative integers represented as strings, without using big integer libraries or converting directly to integer. So we need to simulate addition with digit arrays or string manipulation. Steps: reverse strings or iterate from end, carry, build result, reverse at end. Use loops, decision.\n\nWe produce line-by-line virtual code: Start, Step 1: initialise i, j, carry, result string builder, etc. Then loop while i>=0 or j>=0 or carry>0, extract digit char to int, sum, push digit to result, decrement i, j. After loop, reverse result. Return result. End.\n\nWe must output each line with arrow '→', and use Decision: etc.\n\nAlso we must not output actual code but virtual steps.\n\nWe need to keep to the format: each line is a virtual code step followed by space and comment.\n\nLet's craft:\n\nStart\n→ Step 1: Initialize i = length(num1)-1, j = length(num2)-1, carry = 0, result = empty list // set up indices and carry\n→ Decision: If i >= 0 or j >= 0 or carry > 0? // loop condition\n    Yes → Step 2: digit1 = (i >= 0) ? (num1[i] - '0') : 0 // get current digit or 0\n    → Step 3: digit2 = (j >= 0) ? (num2[j] - '0') : 0 // same for second number\n    → Step 4: sum = digit1 + digit2 + carry // compute sum\n    → Step 5: carry = sum / 10 // compute new carry\n    → Step 6: result.append(sum % 10) // append digit to result\n    → Step 7: i = i - 1 // move to next digit\n    → Step 8: j = j - 1 // move to next digit\n    → Decision: loop again? // go back to Decision\n    No → Step 9: reverse(result) // final reverse to get correct order\n    → Step 10: return result as string // output\nEnd\n\nBut we need to ensure we follow \"虛擬碼步驟\" then comment. Use arrow '→' for steps. Use Decision: for decision.\n\nWe must not output actual code like `digit1 = (i >= 0) ? (num1[i] - '0') : 0`, but the virtual code. However they might expect something like \"Step 2: 取 num1 的第 i 位數字，若 i < 0 則為 0\" etc. So we can produce something simpler: \"Step 2: 取得 num1[i] 的整數值，若 i < 0 則設為 0\" etc. Avoid actual syntax.\n\nBut it's virtual, we can keep as pseudo. Use maybe \"digit1 ← (i ≥ 0 ? num1[i] : '0')\" etc.\n\nLet's produce.\n\nMake sure each line uses `→` or `Start`, `End`. Provide decision block properly indented with spaces maybe.\n\nAlso ensure we don't produce any actual code snippet like \"digit1 = ...\". But maybe pseudo assignments acceptable. The prompt says \"請勿輸出實際程式碼，只輸出結構化的步驟.\" So we should not produce code but the structure. So we need to avoid real syntax like \"=\" or \"/\". Instead use descriptive actions. For example: \"取得 num1 的第 i 位數字\" etc. So we produce textual steps.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 設定指標 i 指向 num1 的最後一位，j 指向 num2 的最後一位，carry 設為 0，結果暫存區 result 置空 // 初始化指標與暫存區\n→ Decision: i ≥ 0 或 j ≥ 0 或 carry > 0? // 判斷是否還有位數或進位需要處理\n    Yes → Step 2: 若 i ≥ 0，將 num1[i] 轉為整數 digit1；否則 digit1 為 0 // 取得 num1 的當前位\n    → Step 3: 若 j ≥ 0，將 num2[j] 轉為整數 digit2；否則 digit2 為 0 // 取得 num2 的當前位\n    → Step 4: 計算 sum = digit1 + digit2 + carry // 兩位數字與進位相加\n    → Step 5: 更新 carry 為 sum 的十位數（sum 除以 10） // 取得新的進位\n    → Step 6: 將 sum 的個位數（sum 模 10）加入 result 的末尾 // 暫存本次相加的位數\n    → Step 7: i 減 1 // 移動到上一位\n    → Step 8: j 減 1 // 移動到上一位\n    → Decision: 再次進入迴圈判斷？ // 轉回 Decision\n    No → Step 9: 將 result 反轉順序 // 使結果由高位到低位\n    → Step 10: 將 result 轉為字串並回傳 // 回傳最終加總\nEnd // 程式結束執行\n\nCheck indent: The decision block has nested steps, we can indent with spaces or using arrows. The format example shows indentation but using tabs? They used \"Yes →\", \"No →\" with indentation. We'll replicate.\n\nLet's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 設定指標 i 指向 num1 的最後一位，j 指向 num2 的最後一位，carry 設為 0，結果暫存區 result 置空 // 初始化指標與暫存區\n→ Decision: i ≥ 0 或 j ≥ 0 或 carry > 0? // 判斷是否還有位數或進位需要處理\n    Yes → Step 2: 若 i ≥ 0，將 num1[i] 轉為整數 digit1；否則 digit1 為 0 // 取得 num1 的當前位\n    → Step 3: 若 j ≥ 0，將 num2[j] 轉為整數 digit2；否則 digit2 為 0 // 取得 num2 的當前位\n    → Step 4: 計算 sum = digit1 + digit2 + carry // 兩位數字與進位相加\n    → Step 5: 更新 carry 為 sum 的十位數（sum 除以 10） // 取得新的進位\n    → Step 6: 將 sum 的個位數（sum 模 10）加入 result 的末尾 // 暫存本次相加的位數\n    → Step 7: i 減 1 // 移動到上一位\n    → Step 8: j 減 1 // 移動到上一位\n    → Decision: 再次進入迴圈判斷？ // 轉回 Decision\n    No → Step 9: 將 result 反轉順序 // 使結果由高位到低位\n    → Step 10: 將 result 轉為字串並回傳 // 回傳最終加總\nEnd // 程式結束執行"
    },
    {
      "title": "Random Pick Index",
      "source_file": "Leetcode/leetcode398.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\"], [[[1, 2, 3, 3, 3]], [3], [1], [3]]",
          "expected_output": "[null, 4, 0, 2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,4,0,2]'\nGot (Norm):      '[null,4,0,3]'\n--- (Raw) ---\nRaw Expected: '[null, 4, 0, 2]'\nRaw Got:      '[null, 4, 0, 3]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nfrom collections import defaultdict\n\nclass Solution:\n    def __init__(self, nums):\n        self.indices = defaultdict(list)\n        for i, num in enumerate(nums):\n            self.indices[num].append(i)\n\n    def pick(self, target):\n        return random.choice(self.indices[target])\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 先嘗試將輸入分成兩行；若只有一行，則按「],」分割\n    lines = data.splitlines()\n    if len(lines) == 1:\n        s = lines[0].strip()\n        split_idx = s.find('],')\n        if split_idx != -1:\n            cmd_part = s[:split_idx + 1]\n            args_part = s[split_idx + 2:].strip()\n        else:\n            cmd_part = s\n            args_part = ''\n    else:\n        cmd_part, args_part = lines[0].strip(), lines[1].strip()\n\n    commands = json.loads(cmd_part)\n    arguments = json.loads(args_part)\n\n    results = []\n    obj = None\n    for cmd, arg in zip(commands, arguments):\n        if cmd == \"Solution\":\n            obj = Solution(arg[0])\n            results.append(None)\n        elif cmd == \"pick\":\n            results.append(obj.pick(arg[0]))\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code lines with explanation comments. It's a typical solution: store mapping from number to list of indices; pick method picks random index from list. Virtual code should use arrows and decision structure. Provide per line. Let's design steps:\n\nStart: initialize mapping.\n\nConstructor: iterate over nums, add index to mapping.\n\nPick: get list, generate random int between 0 and size-1, return list.get(randIndex).\n\nSince we need virtual code, use \"Step\", \"Decision\", \"Start\", \"End\".\n\nLet's produce:\n\nStart\n\n→ Step 1: 建立空字典 map<number, list<int>> // 用於存儲每個數字對應的索引列表\n\n→ Step 2: 迭代 nums 並填充 map // 將每個數字及其索引加入對應列表\n\n→ Decision: target 是否存在於 map? // 確認目標數字已在初始化時被存儲\n\n    Yes → Step 3: 取得 target 的索引列表 // list = map[target]\n\n    No → Step 4: 抛出錯誤 // 但題目說必有存在\n\n→ Step 5: 生成隨機數 r 在 [0, list.size-1] // 隨機選擇索引\n\n→ Step 6: 回傳 list[r] // 等機率返回索引\n\nEnd\n\nBut we need to structure with arrows. Provide each step as a line.\n\nNeed to include \"Solution(int[] nums)\" and \"pick(int target)\" functions separately maybe.\n\nWe can structure:\n\nStart\n\n→ Function: Solution(int[] nums) // 建構子\n\n    ... steps\n\n→ Function: int pick(int target) // 隨機選索引\n\n    ... steps\n\nEnd\n\nBut maybe better to combine.\n\nLet's produce per line.\n\nWe must include \"→ Step X:\" etc.\n\nOk.\n\nLet's output:\n\nStart // 程式開始執行\n→ Function: Solution(int[] nums) // 建構子\n    → Step 1: 建立空字典 map<number, list<int>> // 用於存儲每個數字對應的索引列表\n    → Step 2: 對於每個索引 i 與值 v 在 nums 中執行\n        → Step 3: 若 map 不包含 v，則 map[v] ← 空列表\n        → Step 4: 將 i 加入 map[v] 的列表\n→ Function: int pick(int target) // 隨機選擇目標索引\n    → Step 5: 取得 target 的索引列表 list ← map[target] // 已保證存在\n    → Step 6: 生成隨機整數 r 在 [0, list.size - 1] // 等概率選擇\n    → Step 7: 回傳 list[r] // 返回隨機索引\nEnd // 程式執行結束\n\nBut maybe need decision for existence.\n\nAdd decision: If target not in map then error, but not needed.\n\nAdd decision maybe.\n\nLet's adjust.\n\nUse Decision: 如果 target 在 map? // 保障存在\n\n    Yes -> ... else -> throw.\n\nLet's incorporate.\n\nOk final output.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Function: Solution(int[] nums) // 建構子  \n    → Step 1: 建立空字典 map<number, list<int>> // 用於存儲每個數字對應的索引列表  \n    → Step 2: 對於每個索引 i 與值 v 在 nums 中執行  \n        → Decision: 如果 map 不包含 v? // 檢查是否已存在該數字的鍵  \n            Yes → Step 3: map[v] ← 空列表 // 初始化該鍵對應的列表  \n            No  → // 什麼也不做，已存在  \n        → Step 4: 將 i 加入 map[v] 的列表 // 將當前索引加入對應數字的索引列表  \n→ Function: int pick(int target) // 隨機選擇目標索引  \n    → Decision: target 是否存在於 map? // 確保目標已被初始化  \n        Yes → Step 5: list ← map[target] // 取得所有對應索引  \n        No  → Step 6: throw IllegalArgumentException // 目標不存在，題目假設一定存在  \n    → Step 7: 生成隨機整數 r 在 [0, list.size - 1] // 等機率選擇索引位置  \n    → Step 8: 回傳 list[r] // 返回隨機索引  \nEnd // 程式執行結束"
    },
    {
      "title": "Palindrome Pairs",
      "source_file": "Leetcode/leetcode336.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "words = [\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]",
          "expected_output": "[[0,1],[1,0],[3,2],[2,4]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0],[3,2],[2,4]]'\nGot (Norm):      '[[0,1],[1,0],[2,4],[3,2],[4,2],[4,3]]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0],[3,2],[2,4]]'\nRaw Got:      '[[0, 1], [1, 0], [2, 4], [3, 2], [4, 2], [4, 3]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.word_index = -1          # index of word ending here, -1 if none\n        self.palindrome_indices = []  # indices of words whose suffix from this node is palindrome\n\ndef is_palindrome(s, left, right):\n    \"\"\"Check if s[left:right+1] is a palindrome.\"\"\"\n    while left < right:\n        if s[left] != s[right]:\n            return False\n        left += 1\n        right -= 1\n    return True\n\ndef build_trie(words):\n    root = TrieNode()\n    for idx, word in enumerate(words):\n        node = root\n        # Insert reversed word\n        for j, ch in enumerate(reversed(word)):\n            # The remaining part of the original word (before this char)\n            # is word[0:len(word)-j-1]\n            if is_palindrome(word, 0, len(word)-j-1):\n                node.palindrome_indices.append(idx)\n            if ch not in node.children:\n                node.children[ch] = TrieNode()\n            node = node.children[ch]\n        node.word_index = idx\n        # After inserting whole word, the empty suffix is also palindrome\n        if is_palindrome(word, 0, len(word)-1):\n            node.palindrome_indices.append(idx)\n    return root\n\ndef palindrome_pairs(words):\n    root = build_trie(words)\n    result = []\n\n    for i, word in enumerate(words):\n        node = root\n        j = 0\n        while True:\n            # If we have a word ending at this node, check if the remaining suffix is palindrome\n            if node.word_index != -1 and node.word_index != i and is_palindrome(word, j, len(word)-1):\n                result.append([i, node.word_index])\n            if j == len(word):\n                break\n            ch = word[j]\n            if ch not in node.children:\n                break\n            node = node.children[ch]\n            j += 1\n\n        # All words whose suffix from this node forms a palindrome can pair with word[i]\n        for idx in node.palindrome_indices:\n            if idx != i:\n                result.append([i, idx])\n\n    # Optional: sort to match example ordering (not required by problem)\n    result.sort()\n    return result\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        print([])\n        return\n    # Extract the list representation between the first '[' and the last ']'\n    start = data.find('[')\n    end = data.rfind(']') + 1\n    list_str = data[start:end]\n    words = ast.literal_eval(list_str)\n\n    pairs = palindrome_pairs(words)\n    print(pairs)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode step by step for algorithm that finds all palindrome pairs in O(total length) time. Typical solution uses Trie of reversed words, and for each word, traverse its reversed version, checking prefixes that are palindrome etc.\n\nBut we need to produce steps with arrows etc.\n\nWe need to produce a step-by-step pseudocode (Virtual Code) in Chinese (Traditional). Each line: virtual code + \" // explanation\". Use arrows \"→\", \"Yes →\", \"No →\", and structure \"Start\", \"End\", \"Decision:\".\n\nWe need to produce algorithmic steps, not actual code. Provide enough lines to cover building trie, checking palindrome, etc.\n\nLet's outline steps:\n\nStart\n→ Build Trie with reversed words, each node stores list of word indices whose suffix from root to node is palindrome.\n→ For each word index i:\n   → Traverse Trie using characters of word i from start to end.\n   → At each node:\n      → If node has list of indices j where j != i and node's path string is palindrome, add pair (i,j).\n   → After finishing traversal, for remaining nodes in node's children: check if any remaining words j such that word[i] is palindrome of remaining part etc.\n\nBut we need O(total length) complexity: typical solution uses trie and also for each word we check for splits where prefix is palindrome and suffix reversed exists.\n\nSimplify pseudocode: \n- Build a dictionary mapping words to index.\n- For each word, for each split position k (0..len), check:\n   - If prefix is palindrome and reversed suffix exists: add pair (rev_index, current_index).\n   - If suffix is palindrome and reversed prefix exists: add pair (current_index, rev_index).\nThis runs O(total length^2) worst-case. But typical optimized approach uses Trie.\n\nBut requirement: O(total length). So we need to produce algorithm that uses Trie, ensures O(total length).\n\nSo steps:\n\n1. Build a Trie where each node contains:\n   - children map char->node\n   - list palindromeIndices: indices of words whose remaining suffix from this node to end is palindrome\n   - wordIndex: index if node marks end of reversed word.\n\n2. For each word with index i:\n   - Insert reversed word into Trie, while traversing, if current suffix of original word (from start to current char) is palindrome, add i to node's palindromeIndices.\n   - After insertion, set node's wordIndex = i.\n\n3. After building Trie, for each word with index i:\n   - Traverse Trie with original word characters.\n   - At each node:\n       - If node.wordIndex != -1 and node.wordIndex != i and the remaining suffix of word from current position is palindrome: add pair (i, node.wordIndex).\n   - After traversal ends at node, add all indices in node.palindromeIndices as pairs (i, index) because the suffix is palindrome.\n\nThe steps above are O(total length).\n\nNow produce pseudocode lines accordingly.\n\nMake sure each line includes // explanation. Use arrows.\n\nLet's craft lines:\n\nStart // 開始\n→ Step 1: 建立 Trie 根節點 // 初始化 Trie\n→ Step 2: 建立字典 wordToIndex // 方便查找索引\n\n→ Decision: 需要建立 Trie? Yes → Step 3: 對於每個單字 word 及其索引 i: // 插入倒序字串\n    → Step 3a: 逆序字串 revWord = reverse(word) // 取得倒序\n    → Step 3b: 設 node = root\n    → Step 3c: 對於 revWord 的每個字符 c:\n        → Decision: 前綴是否為 palindrome? Yes → Step 3c.i: node.palindromeIndices add i // 如果前綴是回文，存入\n        → Step 3c.ii: 若 node 沒有子節點 c，則建立新節點\n        → Step 3c.iii: node = node.child[c]\n    → Step 3d: node.wordIndex = i // 標記整個單字\n\n→ Step 4: 建立結果列表 pairs = []\n\n→ Decision: 需要查找對稱對? Yes → Step 5: 對於每個單字 word 及其索引 i:\n    → Step 5a: node = root\n    → Step 5b: For 每個字符 c in word:\n        → Decision: node.wordIndex != -1 且 node.wordIndex != i 且 剩餘字串 is palindrome? Yes → Step 5b.i: pairs add (i, node.wordIndex) // 找到一個合法對\n        → Step 5b.ii: 若 node.child[c] 為空，停止 // 沒有進一步匹配\n        → Step 5b.iii: node = node.child[c]\n    → Step 5c: // 結束遍歷後，處理剩餘 palindromeIndices\n        → Step 5c.i: 對於每個 idx in node.palindromeIndices:\n            → Decision: idx != i? Yes → Step 5c.i.a: pairs add (i, idx) // 產生對\n\n→ End // 完成\n\nBut we need to include explanations after each line. Use arrows appropriately. Also include Decision blocks where we test conditions. But each line should have virtual code plus explanation.\n\nLet's format as:\n\nStart // 程式開始\n→ Step 1: 建立 Trie 根節點 // 初始化 Trie\n→ Step 2: 建立字典 wordToIndex // 儲存每個單字的索引\n\n→ Decision: 是否需要建立 Trie? Yes → Step 3: 針對每個單字 word 及其索引 i 執行以下:\n    → Step 3a: revWord ← reverse(word) // 取得倒序字串\n    → Step 3b: node ← root // 以根節點為起點\n    → Step 3c: 對於 revWord 的每個字符 c:\n        → Decision: 前綴 (word 的尾部) 是否為 palindrome? Yes → Step 3c.i: node.palindromeIndices ← node.palindromeIndices ∪ {i} // 存入能形成回文的索引\n        → Step 3c.ii: 若 node 沒有子節點 c，則建立新節點 // 建立 Trie 結構\n        → Step 3c.iii: node ← node.child[c] // 移動到下一個節點\n    → Step 3d: node.wordIndex ← i // 標記此節點為完整單字的結束\n\n→ Step 4: pairs ← [] // 用於儲存所有 palindrome pair\n\n→ Decision: 是否需要搜尋 palindrome pair? Yes → Step 5: 針對每個單字 word 及其索引 i 執行以下:\n    → Step 5a: node ← root // 重新從根開始\n    → Step 5b: 對於 word 的每個字符 c:\n        → Decision: node.wordIndex ≠ -1 且 node.wordIndex ≠ i 且 剩餘字串是 palindrome? Yes → Step 5b.i: pairs.add((i, node.wordIndex)) // 找到一個合法對\n        → Decision: node.child[c] 是否存在? No → Step 5b.ii: 跳出循環 // 無法繼續匹配\n        → Step 5b.iii: node ← node.child[c] // 繼續向下\n    → Step 5c: // 完成遍歷後處理剩餘 palindromeIndices\n        → Step 5c.i: 對於每個 idx in node.palindromeIndices:\n            → Decision: idx ≠ i? Yes → Step 5c.i.a: pairs.add((i, idx)) // 產生對\n\n→ End // 程式結束\n\nBut we need each line with \"虛擬碼步驟\" plus explanation. Each line may contain arrow. Use \"→\" before each step. Also Decision blocks can be indented with arrows.\n\nWe must ensure each line is separate. So produce each line separately.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始  \n→ Step 1: 建立 Trie 根節點 // 初始化 Trie 結構  \n→ Step 2: 建立字典 wordToIndex // 儲存每個單字對應的索引  \n\n→ Decision: 需要建立 Trie? Yes → Step 3: 針對每個單字 word 及其索引 i 執行以下  \n    → Step 3a: revWord ← reverse(word) // 取得倒序字串  \n    → Step 3b: node ← root // 以根節點為起點  \n    → Step 3c: 對於 revWord 的每個字符 c:  \n        → Decision: 前綴（word 的尾部）是否為 palindrome? Yes → Step 3c.i: node.palindromeIndices ← node.palindromeIndices ∪ {i} // 若前綴是回文，將索引加入節點的 palindromeIndices  \n        → Step 3c.ii: 若 node.child[c] 為空，則建立新節點 // 建立 Trie 的子節點  \n        → Step 3c.iii: node ← node.child[c] // 移動到下一個節點  \n    → Step 3d: node.wordIndex ← i // 標記此節點為完整單字的結束點  \n\n→ Step 4: pairs ← [] // 用於儲存所有 palindrome pair  \n\n→ Decision: 是否需要搜尋 palindrome pair? Yes → Step 5: 針對每個單字 word 及其索引 i 執行以下  \n    → Step 5a: node ← root // 重新從根開始  \n    → Step 5b: 對於 word 的每個字符 c:  \n        → Decision: node.wordIndex ≠ -1 且 node.wordIndex ≠ i 且 剩餘字串為 palindrome? Yes → Step 5b.i: pairs.add((i, node.wordIndex)) // 找到合法對  \n        → Decision: node.child[c] 是否存在? No → Step 5b.ii: 跳出循環 // 無法繼續匹配  \n        → Step 5b.iii: node ← node.child[c] // 繼續向下  \n    → Step 5c: // 完成遍歷後處理剩餘 palindromeIndices  \n        → Step 5c.i: 對於每個 idx in node.palindromeIndices:  \n            → Decision: idx ≠ i? Yes → Step 5c.i.a: pairs.add((i, idx)) // 產生對  \n\nEnd // 程式結束"
    },
    {
      "title": "Longest Uncommon Subsequence II",
      "source_file": "Leetcode/leetcode522.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"aaa\",\"aaa\",\"aa\"]",
          "expected_output": "-1",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '-1'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: '-1'\nRaw Got:      '2'"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass Solution:\n    def findLUSlength(self, strs):\n        \"\"\"\n        找出不常見子序列的最大長度。\n        若沒有任何不常見子序列，則回傳 -1。\n        \"\"\"\n        # 1. 先統計每個字串出現的次數\n        freq = {}\n        for s in strs:\n            freq[s] = freq.get(s, 0) + 1\n\n        # 2. 找出所有唯一字串中的最大長度\n        max_len = -1\n        for s in strs:\n            if freq[s] == 1:          # 只出現一次的字串一定不是任何其他字串的子序列\n                max_len = max(max_len, len(s))\n\n        return max_len\n\ndef main():\n    \"\"\"\n    主程式：從標準輸入讀取字串陣列，計算並輸出結果。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 假設輸入格式為 JSON 形式，例如 [\"aba\",\"cdc\",\"eae\"]\n    strs = json.loads(data)\n\n    sol = Solution()\n    result = sol.findLUSlength(strs)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for solution: find longest uncommon subsequence (LUS) length. Classic problem: If there is any string that is unique (no duplicate), then answer is its length; otherwise -1. Because any string that is unique cannot be a subsequence of any other unless other has same string. But the typical solution: For each string, if it does not appear twice in array, answer max length; else -1.\n\nBut we need to generate virtual code step by step. Let's produce pseudocode:\n\nStart\n→ Build frequency map of strings\n→ Initialize maxLen = -1\n→ For each string s in array:\n    → If freq[s] == 1:\n        → Update maxLen = max(maxLen, len(s))\n→ If maxLen == -1:\n    → Return -1\n    → Else Return maxLen\nEnd\n\nBut need to handle case no unique strings.\n\nBetter: If any string appears only once, return length of longest such string; else -1.\n\nThus pseudocode.\n\nWe should produce each line with explanation. Use virtual code arrows.\n\nLet's write:\n\nStart // 程式開始\n→ Step 1: 建立字串頻率表 freq // 用來統計每個字串出現次數\n→ Step 2: 將 strs 中每個字串 s 加入 freq，累加計數 // 計算出現次數\n→ Step 3: 初始化 maxLen = -1 // 用來記錄最長的不常見子序列長度\n→ Step 4: For each s in strs:\n        → Decision: 若 freq[s] == 1? // 判斷字串是否唯一\n            Yes → Step 5: 更新 maxLen = max(maxLen, len(s)) // 更新最長長度\n            No → Step 6: 繼續處理下一個字串 // 忽略非唯一字串\n→ Step 7: Decision: 若 maxLen == -1? // 判斷是否存在唯一字串\n    Yes → Step 8: Return -1 // 無不常見子序列\n    No  → Step 9: Return maxLen // 回傳最長不常見子序列長度\nEnd // 程式結束\n\nBut ensure arrow structure. Use \"Yes →\" and \"No →\" within Decision block.\n\nWe should format exactly: each line with \"虛擬碼步驟\" and \" // 解釋\". We need to use arrow characters.\n\nLet's produce as per example.\n\nAlso we might incorporate if duplicate strings longer than unique ones? But algorithm covers.\n\nOk produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立頻率表 freq // 用來統計每個字串在陣列中出現的次數  \n→ Step 2: 對於每個字串 s in strs，將 freq[s] 加 1 // 計算每個字串的出現次數  \n→ Step 3: 初始化變數 maxLen 為 -1 // 用來儲存最長的不常見子序列長度  \n→ Step 4: For each s in strs  \n  Decision: s 是否唯一?（freq[s] == 1）  \n   Yes → Step 5: 更新 maxLen 為 max(maxLen, len(s)) // 更新最長長度  \n   No  → Step 6: 繼續處理下一個字串 // 非唯一字串忽略  \n→ Step 7: Decision: 是否存在唯一字串？（maxLen == -1）  \n  Yes → Step 8: Return -1 // 所有字串都有重複，無不常見子序列  \n  No  → Step 9: Return maxLen // 回傳最長的不常見子序列長度  \nEnd // 程式執行結束"
    },
    {
      "title": "Permutations",
      "source_file": "Leetcode/leetcode46.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nGot (Norm):      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nRaw Got:      '[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 2, 1], [3, 1, 2]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def permute(self, nums):\n        \"\"\"\n        返回 nums 的所有排列，使用回溯法與原地交換。\n        \"\"\"\n        res = []\n\n        def backtrack(start):\n            # 當起始位置達到陣列長度，表示已經選擇完所有元素\n            if start == len(nums):\n                res.append(nums[:])  # 複製目前排列加入結果\n                return\n            # 遍歷從 start 到末尾的每一個索引，嘗試交換\n            for i in range(start, len(nums)):\n                nums[start], nums[i] = nums[i], nums[start]   # 交換\n                backtrack(start + 1)                          # 進一步深度優先\n                nums[start], nums[i] = nums[i], nums[start]   # 回朔\n\n        backtrack(0)\n        return res\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入（可能包含換行）\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 解析「nums = [1,2,3]」形式的輸入\n    try:\n        start = data.index('[')\n        end = data.rindex(']')\n        nums_str = data[start:end+1]\n        nums = ast.literal_eval(nums_str)  # 轉成 Python list\n    except (ValueError, SyntaxError):\n        # 若解析失敗，直接終止\n        sys.exit(\"Invalid input format\")\n\n    # 計算排列\n    solution = Solution()\n    permutations = solution.permute(nums)\n\n    # 輸出結果\n    print(permutations)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for generating permutations. Provide step-by-step algorithm: use backtracking. Must output each line with explanation. Follow format: \"虛擬碼步驟 // 解釋\". Use arrows. Include Start, End. Use Decision, etc. Provide each line. Let's craft. Ensure to not output actual code, only pseudo. Use proper indentation with arrow lines. Use \"→\" arrow. Let's create:\n\nStart\n→ Step 1: 定義結果集合 res 為空列表 // 用於儲存所有排列\n→ Step 2: 定義遞迴函式 backtrack(curr, remaining) // curr 為目前排列, remaining 為尚未使用的數字\n→ Step 3: Decision: 如果 remaining 為空? // 判斷是否完成排列\n    Yes → Step 4: 把 curr 複製並加入 res // 完整排列加入結果\n    No → Step 5: 遍歷每個 num 在 remaining // 逐一選擇下一個元素\n        → Step 6: Decision: 若 num 已在 curr? // 實際上 remaining 不含已使用的，故可略\n            Yes → Step 7: 继续循环 // 直接跳過\n            No  → Step 8: Step 9: 新建 newCurr = curr + [num] // 擴充目前排列\n                → Step 10: newRemaining = remaining 去除 num // 去掉已選元素\n                → Step 11: backtrack(newCurr, newRemaining) // 递归继续\n→ Step 12: Call backtrack([], nums) // 初始调用\n→ Step 13: 返回 res // 返回所有排列\nEnd\n\nNeed to align with format. Use arrow for each step. Use Decision: lines with indent. Provide short explanation. Ensure each line includes \" // \". Let's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化結果集合 res 為空列表 // 用於儲存所有排列  \n→ Step 2: 定義遞迴函式 backtrack(curr, remaining) // curr 為目前排列，remaining 為剩餘未使用的數字  \n→ Step 3: Decision: 如果 remaining 為空? // 判斷是否已形成完整排列  \n  Yes → Step 4: 把 curr 複製並加入 res // 完整排列加入結果集合  \n  No  → Step 5: 遍歷每個 num 在 remaining // 逐一選擇下一個元素  \n   → Step 6: 新建 newCurr = curr + [num] // 在目前排列後加入 num  \n   → Step 7: newRemaining = remaining 去除 num // 移除已選元素，形成新的剩餘集合  \n   → Step 8: backtrack(newCurr, newRemaining) // 進行遞迴處理  \n→ Step 9: 呼叫 backtrack([], nums) // 初始遞迴，curr 為空，remaining 為整個輸入陣列  \n→ Step 10: 回傳 res // 回傳所有生成的排列  \nEnd // 程式執行結束"
    },
    {
      "title": "Insert Delete GetRandom O(1) - Duplicates allowed",
      "source_file": "Leetcode/leetcode381.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedCollection\", \"insert\", \"insert\", \"insert\", \"getRandom\", \"remove\", \"getRandom\"], [[], [1], [1], [2], [], [1], []]",
          "expected_output": "[null, true, false, true, 2, true, 1]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpiu62u8f2.py\", line 86, in <module>\n    main()\n  File \"/tmp/tmpiu62u8f2.py\", line 60, in main\n    args = json.loads(args_part)\n           ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 337, in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 353, in raw_decode\n    obj, end = self.scan_once(s, idx)\n               ^^^^^^^^^^^^^^^^^^^^^^\njson.decoder.JSONDecodeError: Expecting ',' delimiter: line 1 column 34 (char 33)"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport collections\n\nclass RandomizedCollection:\n    def __init__(self):\n        # 存儲所有元素的列表\n        self.data = []\n        # 值到其在 data 中所有索引的集合\n        self.idx_map = collections.defaultdict(set)\n\n    def insert(self, val: int) -> bool:\n        \"\"\"插入元素，返回是否首次插入\"\"\"\n        self.data.append(val)\n        idx = len(self.data) - 1\n        self.idx_map[val].add(idx)\n        # 如果這是第一次插入該值，返回 True，否則 False\n        return len(self.idx_map[val]) == 1\n\n    def remove(self, val: int) -> bool:\n        \"\"\"移除一個 val，若存在則返回 True，否則 False\"\"\"\n        if not self.idx_map[val]:\n            return False\n        # 任意取出一個索引\n        remove_idx = self.idx_map[val].pop()\n        last_val = self.data[-1]\n        last_idx = len(self.data) - 1\n\n        # 把最後一個元素移到被移除的位置\n        self.data[remove_idx] = last_val\n        self.idx_map[last_val].add(remove_idx)\n        self.idx_map[last_val].discard(last_idx)\n\n        # 刪除最後一個位置\n        self.data.pop()\n\n        # 若該值已經沒有索引，從映射中移除\n        if not self.idx_map[val]:\n            del self.idx_map[val]\n\n        return True\n\n    def getRandom(self) -> int:\n        \"\"\"隨機返回一個元素\"\"\"\n        return random.choice(self.data)\n\ndef main():\n    # 讀取整個標準輸入\n    content = sys.stdin.read().strip()\n    if not content:\n        return\n\n    # 解析輸入：分成兩部分，操作列表與參數列表\n    ops_part, args_part = content.split('],', 1)\n    ops_part += ']'\n    args_part = '[' + args_part.strip()\n\n    ops = json.loads(ops_part)\n    args = json.loads(args_part)\n\n    obj = None\n    result = []\n\n    for op, arg in zip(ops, args):\n        if op == \"RandomizedCollection\":\n            obj = RandomizedCollection()\n            result.append(None)          # constructor 的返回值為 null\n        elif op == \"insert\":\n            res = obj.insert(arg[0])\n            result.append(res)\n        elif op == \"remove\":\n            res = obj.remove(arg[0])\n            result.append(res)\n        elif op == \"getRandom\":\n            res = obj.getRandom()\n            result.append(res)\n        else:\n            # 若遇到未知操作，直接跳過\n            result.append(None)\n\n    # 輸出結果，使用 json.dumps 以得到 null/true/false 等格式\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines. Each line: step description + // explanation. Use arrows etc. We need to implement class RandomizedCollection with methods. Outline algorithm: maintain vector<int> arr for values, and unordered_map<int, unordered_set<int>> idx mapping value to indices in arr. For insert: add value to arr, record index in map; return true if set size was 0 before. For remove: if value not in map or set empty return false; else pick an index from its set, remove that index: swap with last element in arr, update indices; pop_back; adjust map for swapped element; remove index from val's set; return true. getRandom: random index in arr. Each step should be in virtual code. Provide multiple lines.\n\nWe need to use arrow \"→\", \"Decision:\" etc. We can have Start for class constructor. We'll produce pseudo steps.\n\nLet's output:\n\nStart // Begin RandomizedCollection initialization\n→ Step 1: arr ← empty list // 存儲所有元素\n→ Step 2: idxMap ← empty map // 值到其索引集合的映射\nEnd // 初始化完成\n\nInsert method:\nStart // insert 方法開始\n→ Step 1: Append val to arr // 把新值加入陣列\n→ Step 2: index ← arr.size() - 1 // 取得新值在陣列中的索引\n→ Step 3: Add index to idxMap[val] // 在映射中加入索引\n→ Decision: If idxMap[val] size before addition == 0? // 檢查是否首次插入\n    Yes → Return true // 沒有重複，返回 true\n    No  → Return false // 之前已存在，返回 false\nEnd // insert 方法結束\n\nRemove method:\nStart // remove 方法開始\n→ Decision: If val not in idxMap or idxMap[val] is empty? // 判斷元素是否存在\n    Yes → Return false // 無法移除\n    No  → // 進行移除\n→ Step 1: pick idxToRemove from idxMap[val] // 隨便取一個索引\n→ Step 2: lastIdx ← arr.size() - 1 // 最後一個元素的索引\n→ Step 3: lastVal ← arr[lastIdx] // 最後一個元素的值\n→ Step 4: arr[idxToRemove] ← lastVal // 用最後一個元素覆蓋要刪除的位置\n→ Step 5: Update idxMap[lastVal]: remove lastIdx, add idxToRemove // 更新索引映射\n→ Step 6: Remove idxToRemove from idxMap[val] // 移除被刪元素的索引\n→ Step 7: arr.pop_back() // 刪除最後一個位置\n→ Decision: If idxMap[val] is empty? // 若該值已無任何索引\n    Yes → Remove val from idxMap // 刪除映射\n    No  → // 留下映射\n→ Return true // 成功刪除\nEnd // remove 方法結束\n\ngetRandom method:\nStart // getRandom 方法開始\n→ Step 1: n ← arr.size() // 取得元素數\n→ Step 2: randomIdx ← random integer in [0, n-1] // 隨機選擇索引\n→ Step 3: Return arr[randomIdx] // 返回隨機元素\nEnd // getRandom 方法結束\n\nWe need each line with \"虛擬碼步驟\" plus // explanation.\n\nAlso need to use arrows and Decision. Let's structure lines accordingly. We'll separate blocks. Ensure \"Start\" \"End\" for each method? Probably each block start and end.\n\nLet's craft final.\n...done thinking.\n\nStart // RandomizedCollection 初始化開始  \n→ Step 1: arr ← empty list // 用來存放所有元素  \n→ Step 2: idxMap ← empty map // key: 值, value: 索引集合  \nEnd // 初始化完成  \n\nStart // insert 方法開始  \n→ Step 1: arr.append(val) // 把 val 加入陣列  \n→ Step 2: index ← arr.size() - 1 // 新元素的索引  \n→ Step 3: idxMap[val].add(index) // 將索引記錄在映射  \n→ Decision: If idxMap[val] size before addition == 0? // 判斷是否第一次插入  \n    Yes → Return true // 無重複，返回 true  \n    No  → Return false // 已存在，返回 false  \nEnd // insert 方法結束  \n\nStart // remove 方法開始  \n→ Decision: If val not in idxMap or idxMap[val] is empty? // 判斷元素是否存在  \n    Yes → Return false // 無法移除  \n    No  → // 進行移除  \n→ Step 1: idxToRemove ← any element from idxMap[val] // 取一個索引  \n→ Step 2: lastIdx ← arr.size() - 1 // 最後一個元素索引  \n→ Step 3: lastVal ← arr[lastIdx] // 最後一個元素的值  \n→ Step 4: arr[idxToRemove] ← lastVal // 用最後一個元素覆蓋待刪位置  \n→ Step 5: idxMap[lastVal].remove(lastIdx) // 刪除舊索引  \n→ Step 6: idxMap[lastVal].add(idxToRemove) // 新增新索引  \n→ Step 7: idxMap[val].remove(idxToRemove) // 移除被刪元素的索引  \n→ Step 8: arr.pop_back() // 刪除陣列最後一個元素  \n→ Decision: If idxMap[val] is empty? // 檢查該值是否已無索引  \n    Yes → idxMap.remove(val) // 刪除映射  \n    No  → // 保留映射  \n→ Return true // 成功刪除  \nEnd // remove 方法結束  \n\nStart // getRandom 方法開始  \n→ Step 1: n ← arr.size() // 獲取元素總數  \n→ Step 2: randomIdx ← random integer in [0, n-1] // 隨機選擇索引  \n→ Step 3: Return arr[randomIdx] // 返回隨機元素  \nEnd // getRandom 方法結束"
    },
    {
      "title": "Find Median from Data Stream",
      "source_file": "Leetcode/leetcode295.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"], [[], [1], [2], [], [3], []]",
          "expected_output": "[null, null, null, 1.5, null, 2.0]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp08fmackr.py\", line 62, in <module>\n    main()\n  File \"/tmp/tmp08fmackr.py\", line 43, in main\n    args = ast.literal_eval(second_part)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[[], [1], [2], [], [3], []]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport json\nimport heapq\nimport ast\n\nclass MedianFinder:\n    def __init__(self):\n        self.small = []  # max-heap (store negatives)\n        self.large = []  # min-heap\n\n    def addNum(self, num):\n        heapq.heappush(self.small, -num)\n        # Balance heaps if needed\n        if self.small and self.large and (-self.small[0] > self.large[0]):\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        if len(self.small) > len(self.large) + 1:\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        elif len(self.large) > len(self.small):\n            val = heapq.heappop(self.large)\n            heapq.heappush(self.small, -val)\n\n    def findMedian(self):\n        if len(self.small) > len(self.large):\n            return -self.small[0]\n        else:\n            return (-self.small[0] + self.large[0]) / 2.0\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Split the input into two parts: commands and args\n    split_idx = data.find('],')\n    if split_idx == -1:\n        parts = data.split('],', 1)\n    else:\n        parts = data.split('],', 1)\n    first_part = parts[0] + ']'\n    second_part = '[' + parts[1].strip()\n    commands = ast.literal_eval(first_part)\n    args = ast.literal_eval(second_part)\n\n    obj = None\n    results = []\n    for cmd, arg in zip(commands, args):\n        if cmd == \"MedianFinder\":\n            obj = MedianFinder()\n            results.append(None)\n        elif cmd == \"addNum\":\n            obj.addNum(arg[0])\n            results.append(None)\n        elif cmd == \"findMedian\":\n            results.append(obj.findMedian())\n        else:\n            results.append(None)\n\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for implementing MedianFinder with addNum and findMedian. Use data structures: two heaps, max-heap for lower half, min-heap for upper half. Steps: initialize. addNum: push to maxheap or minheap based on value and balancing sizes. findMedian: if size equal, average; else top of larger. We'll produce line by line.\n\nWe need each line: \"虛擬碼步驟 // 解釋\". Use arrows and decisions. We'll start with Start. Use Start for initialization. Then Step: initialize heaps. Then Step: define addNum. But virtual code should be algorithmic steps. Maybe show as separate functions. Use indentation for decisions. Provide explanation after //.\n\nLet's craft.\n\nStart\n→ Step 1: 初始化兩個堆: maxHeap (大根堆) 用於存放較小的一半, minHeap (小根堆) 用於存放較大的一半 // 建立兩個優先級佇列\n→ Step 2: 定義 addNum(num) // 新增數字的操作\n    → Decision: maxHeap 为空或 num <= maxHeap.top()? // 判斷數字歸屬\n        Yes → Step 3: maxHeap.push(num) // 把數字放進較小的一半堆\n        No  → Step 4: minHeap.push(num) // 把數字放進較大的一半堆\n    → Decision: maxHeap.size() > minHeap.size() + 1? // 檢查左堆是否太多\n        Yes → Step 5: minHeap.push(maxHeap.top()); maxHeap.pop(); // 將最大值移到右堆\n        No  → Decision: minHeap.size() > maxHeap.size() + 1? // 檢查右堆是否太多\n            Yes → Step 6: maxHeap.push(minHeap.top()); minHeap.pop(); // 將最小值移到左堆\n            No  → // 堆大小已平衡，無需操作\n→ Step 7: 定義 findMedian() // 取得目前中位數\n    → Decision: maxHeap.size() == minHeap.size()? // 堆大小相等\n        Yes → Step 8: 返回 (maxHeap.top() + minHeap.top()) / 2.0 // 兩個堆頂取平均\n        No  → Decision: maxHeap.size() > minHeap.size()? // 左堆較大\n            Yes → Step 9: 返回 maxHeap.top() // 左堆頂即中位數\n            No  → Step 10: 返回 minHeap.top() // 右堆頂即中位數\nEnd\n\nMake sure each line has code step and comment. Use arrow for steps. Use decisions. We need to show indentation with indentation? Format uses indentation by indenting Decision lines. Provide each line exactly.\n\nLet's produce.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 初始化兩個堆: maxHeap (大根堆) 用於存放較小的一半, minHeap (小根堆) 用於存放較大的一半 // 建立兩個優先級佇列\n→ Step 2: 定義 addNum(num) // 新增數字的操作\n    → Decision: maxHeap 为空或 num <= maxHeap.top()? // 判斷數字歸屬\n        Yes → Step 3: maxHeap.push(num) // 把數字放進較小的一半堆\n        No  → Step 4: minHeap.push(num) // 把數字放進較大的一半堆\n    → Decision: maxHeap.size() > minHeap.size() + 1? // 檢查左堆是否太多\n        Yes → Step 5: minHeap.push(maxHeap.top()); maxHeap.pop(); // 將最大值移到右堆\n        No  → Decision: minHeap.size() > maxHeap.size() + 1? // 檢查右堆是否太多\n            Yes → Step 6: maxHeap.push(minHeap.top()); minHeap.pop(); // 將最小值移到左堆\n            No  → // 堆大小已平衡，無需操作\n→ Step 7: 定義 findMedian() // 取得目前中位數\n    → Decision: maxHeap.size() == minHeap.size()? // 堆大小相等\n        Yes → Step 8: 返回 (maxHeap.top() + minHeap.top()) / 2.0 // 兩個堆頂取平均\n        No  → Decision: maxHeap.size() > minHeap.size()? // 左堆較大\n            Yes → Step 9: 返回 maxHeap.top() // 左堆頂即中位數\n            No  → Step 10: 返回 minHeap.top() // 右堆頂即中位數\nEnd // 程式執行結束\n```"
    },
    {
      "title": "All O`one Data Structure",
      "source_file": "Leetcode/leetcode432.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "Input\n[\"AllOne\", \"inc\", \"inc\", \"getMaxKey\", \"getMinKey\", \"inc\", \"getMaxKey\", \"getMinKey\"]\n[[], [\"hello\"], [\"hello\"], [], [], [\"leet\"], [], []]",
          "expected_output": "Output\n[null, null, null, \"hello\", \"hello\", null, \"hello\", \"leet\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'Output\\n[null,null,null,\"hello\",\"hello\",null,\"hello\",\"leet\"]'\nGot (Norm):      '[null,null,null,\"hello\",\"hello\",null,\"hello\",\"leet\"]'\n--- (Raw) ---\nRaw Expected: 'Output\\n[null, null, null, \"hello\", \"hello\", null, \"hello\", \"leet\"]'\nRaw Got:      '[null, null, null, \"hello\", \"hello\", null, \"hello\", \"leet\"]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport ast\n\nclass Node:\n    def __init__(self, count=0):\n        self.count = count\n        self.keys = set()\n        self.prev = None\n        self.next = None\n\nclass AllOne:\n    def __init__(self):\n        self.head = Node()          # dummy head (count 0)\n        self.tail = Node()          # dummy tail (count 0)\n        self.head.next = self.tail\n        self.tail.prev = self.head\n        self.key_to_node = {}\n\n    def _insert_after(self, prev_node, count):\n        node = Node(count)\n        node.prev = prev_node\n        node.next = prev_node.next\n        prev_node.next.prev = node\n        prev_node.next = node\n        return node\n\n    def _remove(self, node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\n    def inc(self, key):\n        if key in self.key_to_node:\n            node = self.key_to_node[key]\n            next_count = node.count + 1\n            if node.next == self.tail or node.next.count > next_count:\n                new_node = self._insert_after(node, next_count)\n            else:\n                new_node = node.next\n            new_node.keys.add(key)\n            self.key_to_node[key] = new_node\n            node.keys.remove(key)\n            if not node.keys:\n                self._remove(node)\n        else:\n            if self.head.next == self.tail or self.head.next.count > 1:\n                new_node = self._insert_after(self.head, 1)\n            else:\n                new_node = self.head.next\n            new_node.keys.add(key)\n            self.key_to_node[key] = new_node\n\n    def dec(self, key):\n        node = self.key_to_node[key]\n        prev_count = node.count - 1\n        node.keys.remove(key)\n        if prev_count == 0:\n            del self.key_to_node[key]\n        else:\n            if node.prev == self.head or node.prev.count < prev_count:\n                new_node = self._insert_after(node.prev, prev_count)\n            else:\n                new_node = node.prev\n            new_node.keys.add(key)\n            self.key_to_node[key] = new_node\n        if not node.keys:\n            self._remove(node)\n\n    def getMaxKey(self):\n        if self.tail.prev == self.head:\n            return \"\"\n        return next(iter(self.tail.prev.keys))\n\n    def getMinKey(self):\n        if self.head.next == self.tail:\n            return \"\"\n        return next(iter(self.head.next.keys))\n\ndef parse_input():\n    lines = [line.strip() for line in sys.stdin if line.strip()]\n    # Remove possible \"Input\" or \"Output\" labels\n    lines = [line for line in lines if not line.lower().startswith(\"input\") and not line.lower().startswith(\"output\")]\n    if len(lines) < 2:\n        return [], []\n    commands = ast.literal_eval(lines[0])\n    args = ast.literal_eval(lines[1])\n    return commands, args\n\nif __name__ == \"__main__\":\n    commands, args = parse_input()\n    res = []\n    obj = None\n    for cmd, arg in zip(commands, args):\n        if cmd == \"AllOne\":\n            obj = AllOne()\n            res.append(None)\n        elif cmd == \"inc\":\n            obj.inc(arg[0])\n            res.append(None)\n        elif cmd == \"dec\":\n            obj.dec(arg[0])\n            res.append(None)\n        elif cmd == \"getMaxKey\":\n            res.append(obj.getMaxKey())\n        elif cmd == \"getMinKey\":\n            res.append(obj.getMinKey())\n        else:\n            res.append(None)\n    # Output in JSON format (None -> null)\n    print(json.dumps(res))",
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step for design of data structure AllOne with O(1) operations. Provide virtual code lines and explanations. Use Start, End, Decision, arrows. Probably pseudo steps for initialization, inc, dec, getMaxKey, getMinKey. Provide step-by-step. Let's outline algorithm: Use doubly linked list of count nodes, each node holds count and set of keys. Maintain hashmap key->node. On inc: if key not present, insert into count 1 node, create node if needed. If present, move key to next count node, creating if needed, remove from current node set, delete node if empty. Similarly dec: move key to previous count node, or remove if count goes to 0. getMaxKey: return any key from tail node's set. getMinKey: return any key from head node's set.\n\nWe need to produce virtual code. Each line: \"虛擬碼步驟 // 解釋\". Use arrows. Provide Start, End.\n\nWe should include high-level steps for each method. Should be O(1). We'll produce virtual code for AllOne class with fields: head, tail, map key->node. Node structure: count, set<string> keys, prev, next. Provide initialization, inc, dec, getMaxKey, getMinKey. We'll use pseudo code with steps.\n\nWe need to follow output format: each line with 虛擬碼步驟 + space + // 解釋.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 定義 Node 類別 // 每個 Node 儲存 count、key 集合及 prev/next\n→ Step 2: 定義 AllOne 類別 // 包含 head, tail, key_to_node 映射\n→ Step 3: AllOne() 初始化 head、tail 為 null，key_to_node 為空 // 準備空結構\n→ Step 4: inc(key) // 處理增加操作\n  → Decision: key 是否存在於 key_to_node? // 判斷 key 是否已存在\n      Yes → Step 5a: current = key_to_node[key] // 取得目前節點\n            Step 5b: target_count = current.count + 1 // 計算新計數\n            Step 5c: target = current.next // 可能的目標節點\n            Decision: target 是否存在 且 target.count == target_count? // 檢查是否已有此計數節點\n                Yes → Step 5d: target.keys.add(key) // 將 key 加入目標節點\n                No → Step 5e: new_node = Node(target_count) // 建立新節點\n                    new_node.keys.add(key)\n                    Insert new_node 後於 current 之後\n                    Update pointers\n            Step 5f: current.keys.remove(key) // 從舊節點移除 key\n            Decision: current.keys 是否為空? // 檢查舊節點是否需要刪除\n                Yes → Remove current 節點並更新 head/tail\n            Step 5g: key_to_node[key] = target // 更新映射\n      No → Step 6a: new_node = Node(1) // 新建計數 1 節點\n            new_node.keys.add(key)\n            If head is null then head = tail = new_node\n            Else insert new_node 前於 head\n            key_to_node[key] = new_node // 更新映射\n→ Step 7: dec(key) // 處理減少操作\n  → current = key_to_node[key] // 取得目前節點\n  → target_count = current.count - 1 // 新計數\n  → Decision: target_count == 0? // 是否要移除 key\n      Yes → current.keys.remove(key) // 從節點移除 key\n            If current.keys 為空 → Remove current 節點，更新 head/tail\n            Remove key_to_node[key] // 刪除映射\n      No → target = current.prev\n            Decision: target 是否存在 且 target.count == target_count? // 檢查是否已有此計數節點\n                Yes → target.keys.add(key) // 加入\n                No → new_node = Node(target_count)\n                    new_node.keys.add(key)\n                    Insert new_node 前於 current\n                    Update pointers\n            current.keys.remove(key) // 從舊節點移除\n            Decision: current.keys 是否為空? // 需要刪除節點\n                Yes → Remove current 節點，更新 head/tail\n            key_to_node[key] = target // 更新映射\n→ Step 8: getMaxKey() // 取得最大計數 key\n  → Decision: tail 是否為空? // 是否存在元素\n      Yes → Return \"\" // 無元素\n      No → Return any key from tail.keys // 任一最大計數 key\n→ Step 9: getMinKey() // 取得最小計數 key\n  → Decision: head 是否為空? // 是否存在元素\n      Yes → Return \"\" // 無元素\n      No → Return any key from head.keys // 任一最小計數 key\nEnd // 程式執行結束\n\nNeed to maintain formatting: each line with \"虛擬碼步驟 // 解釋\". Ensure arrows, indent decisions.\n\nLet's produce each line. Provide proper indentation for decisions: maybe use spaces.\n\nWe should not output actual code; just the pseudo steps. Use \"Start\", \"End\".\n\nOk. Let's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 Node 類別 // 每個 Node 儲存 count、key 集合及 prev/next  \n→ Step 2: 定義 AllOne 類別 // 包含 head, tail, key_to_node 映射  \n→ Step 3: AllOne() 初始化 head、tail 為 null，key_to_node 為空 // 準備空結構  \n→ Step 4: inc(key) // 處理增加操作  \n  → Decision: key 是否存在於 key_to_node? // 判斷 key 是否已存在  \n      Yes → Step 5a: current = key_to_node[key] // 取得目前節點  \n            Step 5b: target_count = current.count + 1 // 計算新計數  \n            Step 5c: target = current.next // 可能的目標節點  \n            Decision: target 是否存在 且 target.count == target_count? // 檢查是否已有此計數節點  \n                Yes → Step 5d: target.keys.add(key) // 將 key 加入目標節點  \n                No → Step 5e: new_node = Node(target_count) // 建立新節點  \n                    new_node.keys.add(key)  \n                    Insert new_node 後於 current 之後 // 更新鏈表指標  \n            Step 5f: current.keys.remove(key) // 從舊節點移除 key  \n            Decision: current.keys 是否為空? // 檢查舊節點是否需要刪除  \n                Yes → Remove current 節點並更新 head/tail  \n            Step 5g: key_to_node[key] = target // 更新映射  \n      No → Step 6a: new_node = Node(1) // 新建計數 1 節點  \n            new_node.keys.add(key)  \n            If head is null then head = tail = new_node // 第一個節點  \n            Else insert new_node 前於 head // 新增最小節點  \n            key_to_node[key] = new_node // 更新映射  \n→ Step 7: dec(key) // 處理減少操作  \n  → current = key_to_node[key] // 取得目前節點  \n  → target_count = current.count - 1 // 新計數  \n  → Decision: target_count == 0? // 是否要移除 key  \n      Yes → current.keys.remove(key) // 從節點移除 key  \n            If current.keys 為空 → Remove current 節點，更新 head/tail  \n            Remove key_to_node[key] // 刪除映射  \n      No → target = current.prev  \n            Decision: target 是否存在 且 target.count == target_count? // 檢查是否已有此計數節點  \n                Yes → target.keys.add(key) // 加入  \n                No → new_node = Node(target_count) // 建立新節點  \n                    new_node.keys.add(key)  \n                    Insert new_node 前於 current // 更新鏈表指標  \n            current.keys.remove(key) // 從舊節點移除  \n            Decision: current.keys 是否為空? // 需要刪除節點  \n                Yes → Remove current 節點，更新 head/tail  \n            key_to_node[key] = target // 更新映射  \n→ Step 8: getMaxKey() // 取得最大計數 key  \n  → Decision: tail 是否為空? // 是否存在元素  \n      Yes → Return \"\" // 無元素  \n      No → Return any key from tail.keys // 任一最大計數 key  \n→ Step 9: getMinKey() // 取得最小計數 key  \n  → Decision: head 是否為空? // 是否存在元素  \n      Yes → Return \"\" // 無元素  \n      No → Return any key from head.keys // 任一最小計數 key  \nEnd // 程式執行結束"
    },
    {
      "title": "Substring with Concatenation of All Words",
      "source_file": "Leetcode/leetcode30.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]",
          "expected_output": "[0,9]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[0,9]'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: '[0,9]'\nRaw Got:      ''"
        },
        {
          "example_index": 1,
          "input": "s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]",
          "expected_output": "[]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[]'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: '[]'\nRaw Got:      ''"
        },
        {
          "example_index": 2,
          "input": "s = \"barfoofoobarthefoobarman\", words = [\"bar\",\"foo\",\"the\"]",
          "expected_output": "[6,9,12]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[6,9,12]'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: '[6,9,12]'\nRaw Got:      ''"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import Counter\n\nclass Solution:\n    def findSubstring(self, s: str, words: list[str]) -> list[int]:\n        # 若字串太短，直接回傳空清單\n        if not s or not words:\n            return []\n        word_len = len(words[0])\n        word_count = len(words)\n        total_len = word_len * word_count\n        if len(s) < total_len:\n            return []\n\n        # 統計每個單字的出現頻率\n        target_counter = Counter(words)\n        result = []\n\n        # 檢查每個可能的起點\n        for start in range(0, len(s) - total_len + 1):\n            seen = Counter()\n            valid = True\n            for i in range(word_count):\n                word = s[start + i * word_len : start + (i + 1) * word_len]\n                if word not in target_counter:\n                    valid = False\n                    break\n                seen[word] += 1\n                if seen[word] > target_counter[word]:\n                    valid = False\n                    break\n            if valid:\n                result.append(start)\n        return result\n\ndef main() -> None:\n    # 讀取整個輸入，去除空白並處理多行\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n\n    # 將輸入轉成字典形式以方便解析\n    # 例子：s = \"barfoo\", words = [\"foo\",\"bar\"]\n    raw = raw.replace('=', ':')\n    try:\n        data = ast.literal_eval('{' + raw + '}')\n    except Exception as e:\n        # 若解析失敗，直接結束\n        return\n\n    s = data.get('s', '')\n    words = data.get('words', [])\n\n    solution = Solution()\n    ans = solution.findSubstring(s, words)\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation. We must not output actual code, but pseudocode steps. Use Start, End, Decision, arrow, etc. Steps: compute word length, total length, frequency map of words, iterate start positions 0 to len(s)-totalLen, for each start slide window, split into words, compare counts, if match add index. Provide line-by-line. Ensure we use \"→\" arrow and \"Decision:\" lines. Provide concise explanation in Chinese.\n\nWe need to output lines of virtual code and explanation. Each line ends with // explanation.\n\nMake sure to keep format like example. Use Start, End.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: 計算 wordLen = words[0].length, wordCount = words.length, totalLen = wordLen * wordCount // 先求單字長度、字串數量、總長度\n→ Step 2: 建立 wordsCountMap = {word: count} // 統計每個字串出現次數\n→ Decision: s.length < totalLen? // s 是否足夠長以容納一個完整的排列\n    Yes → End // 不足，直接結束\n    No → // 繼續\n→ Step 3: 迭代 startIndex from 0 to s.length - totalLen\n    // 為每個可能的起始位置檢查\n    → Step 4: 建立 currentCountMap = {} // 用於紀錄此區塊內各字串出現次數\n    → Step 5: 內部迴圈 i = 0 到 wordCount - 1\n        // 把區塊拆成每個 wordLen 長的子字串\n        → Step 6: sub = s.substr(startIndex + i*wordLen, wordLen) // 取出子字串\n        → Step 7: currentCountMap[sub] = (currentCountMap[sub] or 0) + 1 // 記錄出現次數\n    → Step 8: Decision: currentCountMap == wordsCountMap? // 比較兩個頻率表\n        Yes → Step 9: add startIndex to result // 若相同，加入結果\n        No → // 不加入\n→ End // 程式執行結束\n\nBut we need to use arrow for each step, like \"→ Step 1: ...\" Should each line be separate. We need to include indent for nested decisions? Use spaces maybe. Example uses indentation after Decision lines. So we can use indentation for nested lines.\n\nThus produce final. Let's output accordingly.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: wordLen ← words[0].length, wordCount ← words.length, totalLen ← wordLen * wordCount // 先算單字長、字串數、總長度\n→ Step 2: wordsCountMap ← {} // 建立字串頻率表\n→ Step 3: for each word in words do wordsCountMap[word] ← (wordsCountMap[word] or 0) + 1 // 填入字串出現次數\n→ Decision: s.length < totalLen? // s 是否足夠長容納完整排列\n    Yes → End // 不足長度，直接結束\n    No  // 繼續檢查\n→ Step 4: result ← [] // 儲存符合條件的起始索引\n→ Step 5: for startIndex from 0 to s.length - totalLen do // 逐位檢查每個可能的起點\n    → Step 6: currentCountMap ← {} // 用於記錄此區塊內字串出現次數\n    → Step 7: for i from 0 to wordCount - 1 do // 依序取出每個子字串\n        → sub ← s.substr(startIndex + i * wordLen, wordLen) // 取得子字串\n        → currentCountMap[sub] ← (currentCountMap[sub] or 0) + 1 // 更新計數\n    → Decision: currentCountMap == wordsCountMap? // 檢查兩個頻率表是否相同\n        Yes → result.append(startIndex) // 若相同，加入結果\n        No  // 不加入\n→ End // 程式執行結束\n```"
    },
    {
      "title": "LRU Cache",
      "source_file": "Leetcode/leetcode146.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"], [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]",
          "expected_output": "[null, null, null, 1, null, -1, null, -1, 3, 4]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp4i3kbj4n.py\", line 77, in <module>\n    commands, args = json.loads(data)\n                     ^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 76 (char 75)"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass Node:\n    \"\"\"雙向鏈表節點\"\"\"\n    __slots__ = (\"key\", \"val\", \"prev\", \"next\")\n\n    def __init__(self, key: int = None, val: int = None):\n        self.key = key\n        self.val = val\n        self.prev = None\n        self.next = None\n\nclass LRUCache:\n    \"\"\"O(1) 時間複雜度的 LRU Cache\"\"\"\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = {}          # key -> Node\n        self.head = Node()       # dummy head\n        self.tail = Node()       # dummy tail\n        self.head.next = self.tail\n        self.tail.prev = self.head\n        self.size = 0\n\n    def _add_node(self, node: Node):\n        \"\"\"將節點插入到 head 之後\"\"\"\n        node.prev = self.head\n        node.next = self.head.next\n        self.head.next.prev = node\n        self.head.next = node\n        self.size += 1\n\n    def _remove_node(self, node: Node):\n        \"\"\"將節點從鏈表中移除\"\"\"\n        prev_node = node.prev\n        next_node = node.next\n        prev_node.next = next_node\n        next_node.prev = prev_node\n        self.size -= 1\n\n    def _move_to_head(self, node: Node):\n        \"\"\"把節點移到最近使用的位置（head 之後）\"\"\"\n        self._remove_node(node)\n        self._add_node(node)\n\n    def _pop_tail(self) -> Node:\n        \"\"\"移除最舊節點（tail 之前的節點）\"\"\"\n        node = self.tail.prev\n        self._remove_node(node)\n        return node\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        node = self.cache[key]\n        self._move_to_head(node)\n        return node.val\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            node = self.cache[key]\n            node.val = value\n            self._move_to_head(node)\n        else:\n            node = Node(key, value)\n            self.cache[key] = node\n            self._add_node(node)\n            if self.size > self.capacity:\n                tail = self._pop_tail()\n                del self.cache[tail.key]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    # 解析輸入：兩個列表，分別是指令和對應參數\n    commands, args = json.loads(data)\n\n    result = []\n    cache = None\n\n    for cmd, param in zip(commands, args):\n        if cmd == \"LRUCache\":\n            cache = LRUCache(param[0])\n            result.append(None)\n        elif cmd == \"put\":\n            cache.put(param[0], param[1])\n            result.append(None)\n        elif cmd == \"get\":\n            res = cache.get(param[0])\n            result.append(res)\n\n    # 將結果轉成 LeetCode 風格的輸出：None 用 null 表示\n    output_str = \"[\" + \", \".join(\"null\" if x is None else str(x) for x in result) + \"]\"\n    print(output_str)",
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line with explanations. The user wants a design for LRU cache with O(1) get and put. Virtual code: likely using hash map + doubly linked list. Steps: initialization, get, put, eviction.\n\nWe need to output each line: \"虛擬碼步驟 // 解釋/說明\". Use arrows, Start, End, Decision. Ensure each line has virtual code step and comment. Must be in Traditional Chinese. Use \"→\" arrow for flow. Use \"Start\" and \"End\". Use \"Decision:\" for if.\n\nWe need to produce step by step pseudo code, not actual code. Provide algorithm design.\n\nLet's produce: Start, initialize data structures: capacity, hash map key->node, doubly linked list with dummy head and tail. Then define helper functions: moveToHead(node), removeNode(node), addToHead(node), popTail().\n\nThen get(key): Decision if key in map? Yes: retrieve node, move to head, return value. No: return -1.\n\nThen put(key,value): Decision if key in map? Yes: update value, move to head. No: create new node, add to head, add to map, if size > capacity: evict node = popTail, remove from map, decrement size.\n\nAt end.\n\nWe need to include each step line by line. Ensure to include decisions. Use arrows to indicate next step.\n\nLet's craft. We'll put each line with explanation. Use \"虛擬碼步驟\" as the code step.\n\nWe should include \"Start // 程式開始執行\". Then \"→ Step 1: 建立 LRUCache 類別，儲存容量 capacity\" etc. Use Chinese.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義 LRUCache 類別，屬性有 capacity、hashMap、head、tail、size // 建立 LRUCache 的結構與儲存變數\n→ Step 2: 在建構子中初始化 capacity、size 為 0，head 與 tail 為雙向鏈表的哨兵節點，hashMap 為空哈希表 // 準備空白資料結構\n→ Step 3: 建立 helper 函式 moveToHead(node) // 將節點移到鏈表頭部\n→ Step 4: 在 moveToHead 內部調用 removeNode(node) 後，再呼叫 addToHead(node) // 先移除再加回頭部\n→ Step 5: 建立 helper 函式 removeNode(node) // 從鏈表中移除指定節點\n→ Step 6: 在 removeNode 內部調整 node.prev.next 與 node.next.prev 的指標，並減少 size // 更新鏈表連結與計數\n→ Step 7: 建立 helper 函式 addToHead(node) // 把節點加入到頭部\n→ Step 8: 在 addToHead 內部將 node 插入 head 與 head.next 之間，並增加 size // 更新鏈表連結與計數\n→ Step 9: 建立 helper 函式 popTail() → Return tail.prev // 取出並移除最舊節點\n→ Decision: 如果 size > capacity? // 檢查是否需要驅逐\n    Yes → Step 10: evictedNode ← popTail() // 取得最舊節點\n    No  → End // 不需要驅逐，直接結束\n→ Step 11: 在 get(key) 方法中\n→ Decision: key 是否存在於 hashMap? // 判斷鍵是否已經被存儲\n    Yes → Step 12: node ← hashMap[key] // 取得節點\n    → Step 13: moveToHead(node) // 重新定位為最近使用\n    → Step 14: Return node.value // 回傳對應值\n    No  → Step 15: Return -1 // 鍵不存在，回傳 -1\n→ Step 16: 在 put(key, value) 方法中\n→ Decision: key 是否存在於 hashMap? // 判斷是否更新已存在鍵\n    Yes → Step 17: node ← hashMap[key] // 取得節點\n    → Step 18: node.value ← value // 更新值\n    → Step 19: moveToHead(node) // 重新定位為最近使用\n    No  → Step 20: node ← new Node(key, value) // 建立新節點\n    → Step 21: hashMap[key] ← node // 加入哈希表\n    → Step 22: addToHead(node) // 加入鏈表頭部\n    → Step 23: Decision: size > capacity? // 檢查是否需要驅逐\n        Yes → Step 24: evictedNode ← popTail() // 取得並移除最舊節點\n        → Step 25: delete hashMap[evictedNode.key] // 從哈希表移除該鍵\n        No  → End // 不需要驅逐，結束\nEnd // 程式執行結束"
    },
    {
      "title": "K^th Smallest Element in a Sorted Matrix",
      "source_file": "Leetcode/leetcode378.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8",
          "expected_output": "13",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp2nxunwpv.py\", line 58, in <module>\n    matrix, k = parse_input(raw)\n                ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp2nxunwpv.py\", line 49, in parse_input\n    k_part = parts[1].split('=', 1)[1].strip()\n             ~~~~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        }
      ],
      "generated_code": "import sys\nimport ast\n\ndef count_less_equal(matrix, target):\n    \"\"\"\n    Count how many elements in the sorted matrix are <= target.\n    We start from the bottom-left corner and move only up or right.\n    \"\"\"\n    n = len(matrix)\n    count = 0\n    row = n - 1\n    col = 0\n    while row >= 0 and col < n:\n        if matrix[row][col] <= target:\n            # All elements above in this column are <= target\n            count += row + 1\n            col += 1\n        else:\n            row -= 1\n    return count\n\ndef kth_smallest(matrix, k):\n    \"\"\"\n    Find the k-th smallest element in a row/column sorted matrix.\n    Uses binary search on value range; memory O(1).\n    \"\"\"\n    n = len(matrix)\n    low = matrix[0][0]\n    high = matrix[-1][-1]\n    while low < high:\n        mid = low + (high - low) // 2\n        cnt = count_less_equal(matrix, mid)\n        if cnt < k:\n            low = mid + 1\n        else:\n            high = mid\n    return low\n\ndef parse_input(data):\n    \"\"\"\n    Parse input in the format:\n        matrix = [[...]], k = 8\n    Returns the matrix as a list of lists and k as int.\n    \"\"\"\n    parts = data.split(',')\n    if len(parts) < 2:\n        raise ValueError(\"Input format incorrect.\")\n    matrix_part = parts[0].split('=', 1)[1].strip()\n    k_part = parts[1].split('=', 1)[1].strip()\n    matrix = ast.literal_eval(matrix_part)\n    k = int(k_part)\n    return matrix, k\n\nif __name__ == \"__main__\":\n    raw = sys.stdin.read().strip()\n    if not raw:\n        sys.exit(0)\n    matrix, k = parse_input(raw)\n    result = kth_smallest(matrix, k)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to output virtual code lines with explanations, for the problem: find kth smallest in sorted matrix. Classic binary search on value range + count <= k. Or use min-heap O(k log n). Memory better than O(n^2). We'll choose binary search with count method, memory O(1). Steps: Start, read matrix size, set low = matrix[0][0], high = matrix[n-1][n-1], loop while low < high: mid = low + (high-low)/2; count = count <= mid; if count < k low=mid+1 else high=mid; end loop; return low. Provide explanation. Use virtual steps.\n\nLet's produce line by line.\n\nWe need to use \"Start\", \"End\", \"Decision:\" etc. Provide arrow lines.\n\nOk. We'll produce:\n\nStart // 程式開始執行\n→ Step 1: 讀取 n 與 k // 取得矩陣大小與目標順位\n→ Step 2: 設定 low = matrix[0][0], high = matrix[n-1][n-1] // 初始搜尋範圍\n→ Decision: 是否 low < high? // 判斷搜尋是否結束\n    Yes → Step 3: 計算 mid = low + (high - low) / 2 // 取中值\n    → Step 4: 計算 count = CountLessOrEqual(mid) // 計算小於等於 mid 的元素個數\n    → Decision: 是否 count < k? // 判斷是否需要往高端搜尋\n        Yes → Step 5: low = mid + 1 // 低端上移\n        No  → Step 6: high = mid // 高端下降\n    → Decision: 重新判斷 low < high? // 迴圈條件\n        Yes → 回到 Step 3\n        No  → Step 7: 回傳 low // low 即為第 k 小元素\n→ End // 程式結束\n\nBut need to include CountLessOrEqual as a subroutine. Provide step for that.\n\nLet's define subroutine:\n\n→ Step 4: 計算 count = CountLessOrEqual(mid) // 計算小於等於 mid 的個數\n→ Subroutine: CountLessOrEqual(value)\n    → Step 4.1: 設 count = 0, row = n-1, col = 0 // 從左下角開始\n    → Decision: 是否 row >= 0 && col < n? // 迴圈條件\n        Yes → Decision: 是否 matrix[row][col] <= value? // 判斷是否小於等於\n            Yes → Step 4.2: count += row + 1 // 所有上方元素均 <= value\n                    → Step 4.3: col++ // 移到右側\n            No  → Step 4.4: row-- // 移到上一列\n        No  → Step 4.5: 回傳 count // 返回計數\n\nLet's integrate into virtual code.\n\nAlso, we need to indicate arrows like \"→\". We'll use \"→\" before each step line. Use \"Decision:\" lines. Provide explanation after //. Ensure each line has arrow and explanation.\n\nLet's craft.\n\nRemember each line: \"虛擬碼步驟 [空格] // 解釋/說明\". The arrow part included in step.\n\nOk produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取 n 與 k // 取得矩陣大小與目標順位  \n→ Step 2: 設定 low = matrix[0][0]，high = matrix[n-1][n-1] // 初始搜尋範圍  \n→ Decision: low < high? // 判斷搜尋是否結束  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 3: mid = low + (high - low) / 2 // 計算中間值  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 4: count = CountLessOrEqual(mid) // 計算小於等於 mid 的元素數量  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: count < k? // 判斷是否需往高端搜尋  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 5: low = mid + 1 // 低端上移  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 6: high = mid // 高端下降  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: low < high? // 重新判斷迴圈條件  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → 回到 Step 3  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 7: 回傳 low // low 為第 k 小元素  \n→ End // 程式結束  \n\n---  \n**子程序** CountLessOrEqual(value)  \n→ Step 4.1: 設 count = 0，row = n-1，col = 0 // 從左下角開始遍歷  \n→ Decision: row >= 0 && col < n? // 迴圈條件  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → Decision: matrix[row][col] <= value? // 判斷當前元素是否小於等於 value  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 4.2: count += row + 1 // 所有上方元素均 <= value  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 4.3: col++ // 移到右側  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 4.4: row-- // 移到上一列  \n&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 4.5: 回傳 count // 返回計數結果"
    },
    {
      "title": "Implement Rand10() Using Rand7()",
      "source_file": "Leetcode/leetcode470.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 1",
          "expected_output": "[2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2]'\nGot (Norm):      '[8]'\n--- (Raw) ---\nRaw Expected: '[2]'\nRaw Got:      '[8]'"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[2,8]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,8]'\nGot (Norm):      '[4,9]'\n--- (Raw) ---\nRaw Expected: '[2,8]'\nRaw Got:      '[4, 9]'"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "[3,8,10]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,8,10]'\nGot (Norm):      '[6,9,2]'\n--- (Raw) ---\nRaw Expected: '[3,8,10]'\nRaw Got:      '[6, 9, 2]'"
        }
      ],
      "generated_code": "import random\n\ndef rand7() -> int:\n    \"\"\"返回 1~7 的均勻隨機整數。\"\"\"\n    return random.randint(1, 7)\n\nclass Solution:\n    def rand10(self) -> int:\n        \"\"\"\n        使用兩次 rand7 生成 1~49 的均勻分布。\n        若結果 ≤ 40，則將其映射到 1~10；否則重新嘗試。\n        \"\"\"\n        while True:\n            a = rand7()\n            b = rand7()\n            val = (a - 1) * 7 + b  # 1 ~ 49\n            if val <= 40:\n                return 1 + (val - 1) % 10\n\nif __name__ == \"__main__\":\n    import sys\n    import re\n\n    data = sys.stdin.read().strip()\n    match = re.search(r'\\d+', data)\n    n = int(match.group()) if match else 0\n\n    sol = Solution()\n    results = [sol.rand10() for _ in range(n)]\n    print(results)",
      "virtual_code": "Thinking...\nWe need to output a virtual code algorithm for rand10 using rand7. Classic method: generate 2 dice to produce range 1-49, use rejection if >40. Or use 3 dice for 1-343 etc. Standard solution: use rand7() twice to create 49 outcomes: (a-1)*7 + b gives 1-49. If result <= 40, return result mod 10 + 1. Else, map the leftover 9 outcomes (41-49) into new range by treating them as new base: 9 outcomes cannot map to 10. Common trick: use 49-40=9 leftovers; we can re-use them by converting 9 to something: We can use another round: treat each leftover as 1-9 and combine with another rand7 to get 63 values? Alternative: use two 7s to get 49, if >40, discard; but that leads to bias? Rejection sampling ensures uniform.\n\nBut need algorithm steps. Let's produce simple algorithm:\n\nrand10():\n1. Loop:\n  a = rand7()\n  b = rand7()\n  result = (a-1)*7 + b  // 1-49\n  if result <= 40:\n     return (result-1)%10 +1\n  // else need to map 41-49\n  // We can treat the leftover 9 values as new base: convert to 1-9\n  // For leftover, we can again use rand7 to generate 1-49 and if <= 30 we can map 1-30 into 1-10\n  // But we can do easier: Use two more rand7 to get 49 values, if <= 40 return mapping else repeat.\n\nSimplify: After rejection, just go back to loop. So algorithm:\n\nwhile true:\n  a=rand7()\n  b=rand7()\n  val=(a-1)*7+b\n  if val<=40:\n    return (val-1)%10+1\n\nThis is standard. It uses rejection only.\n\nLet's produce virtual code lines. Provide comments.\n\nRemember to use Start, End, Decision.\n\nWe must produce lines like \"Start // 程式開始執行\". Then \"→ Step 1: 從 rand7() 取得 a // ...\". Use decision arrow.\n\nLet's create:\n\nStart\n→ Step 1: 進入迴圈 // 開始重複嘗試\n→ Decision: 是否需要重複? // 迴圈條件\n    Yes → Step 2: a ← rand7() // 取得第一個隨機數\n    → Step 3: b ← rand7() // 取得第二個隨機數\n    → Step 4: val ← (a-1)*7 + b // 產生 1-49 的值\n    → Decision: 如果 val ≤ 40? // 可接受的區間\n        Yes → Step 5: 返回 (val-1) mod 10 + 1 // 轉換到 1-10\n        No  → Step 6: 返回到迴圈開始 // 拒絕，重新嘗試\nEnd\n\nBut must structure properly: Use Decision block: if condition? Then arrow for Yes/No.\n\nLet's craft more detailed:\n\nStart // 程式開始執行\n→ Decision: 是否進入迴圈? // 永遠是 Yes，開始重複嘗試\n    Yes → Step 1: a ← rand7() // 取得第一個亂數\n    → Step 2: b ← rand7() // 取得第二個亂數\n    → Step 3: val ← (a-1)*7 + b // 組合得到 1~49\n    → Decision: 如果 val ≤ 40? // 可用於映射\n        Yes → Step 4: result ← (val-1) mod 10 + 1 // 產生 1~10\n        → Step 5: 返回 result // 結束\n        No  → Step 6: 返回到 Decision: 是否進入迴圈? // 重新嘗試\nEnd\n\nBut we need a proper loop: We can represent as while loop with decision.\n\nAlternatively, use 'Loop' concept.\n\nWe might produce:\n\nStart\n→ Step 1: Loop begin // 開始迴圈\n    → Step 2: a ← rand7() // 取得第一個亂數\n    → Step 3: b ← rand7() // 取得第二個亂數\n    → Step 4: val ← (a-1)*7 + b // 組合成 1~49\n    → Decision: val ≤ 40? // 可接受\n        Yes → Step 5: return (val-1) mod 10 + 1 // 生成 1~10\n        No  → Step 6: 跳回 Step 1 // 重複\nEnd\n\nBut the instructions: Each line must contain 虛擬碼步驟 + ' ' + '// 解釋/說明'.\n\nWe must use arrow and structure: Start, End, Decision.\n\nUse indentation to show nested decisions.\n\nLet's create final answer.\n\nAlso need to mention that we do not call other API.\n\nLet's produce final virtual code.\n\nUse 1-based numbering maybe optional.\n\nLet's output.\n\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 開始迴圈 // 進入無窮迴圈，直到得到合法值\n    → Step 2: a ← rand7() // 取得第一個隨機數 1~7\n    → Step 3: b ← rand7() // 取得第二個隨機數 1~7\n    → Step 4: val ← (a-1)*7 + b // 將兩個亂數組合成 1~49 的值\n    → Decision: val ≤ 40? // 檢查是否落在可接受的 1~40 區間\n        Yes → Step 5: result ← (val-1) mod 10 + 1 // 將 1~40 映射為 1~10\n        → Step 6: 返回 result // 返回最終的 rand10() 結果\n        No  → Step 7: 跳回 Step 1 // 超過 40，丟棄此組合，重新嘗試\nEnd // 程式執行結束"
    },
    {
      "title": "Reverse Integer",
      "source_file": "Leetcode/leetcode7.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "x = -123",
          "expected_output": "-321",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '-321'\nGot (Norm):      '-789'\n--- (Raw) ---\nRaw Expected: '-321'\nRaw Got:      '-789'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nINT_MAX = 2**31 - 1\nINT_MIN = -2**31\n\ndef reverse_integer(x: int) -> int:\n    \"\"\"Reverse the digits of a 32‑bit signed integer with overflow check.\"\"\"\n    sign = -1 if x < 0 else 1\n    result = 0\n\n    while x != 0:\n        # 取得最低位數（正數或負數皆使用絕對值）\n        digit = abs(x % 10)\n        # 向零截斷除法，去掉最低位\n        x = int(x / 10)\n\n        # 檢查是否會溢出\n        if result > INT_MAX // 10 or (\n            result == INT_MAX // 10 and (\n                (sign == 1 and digit > 7) or  # 正數最後一位不能超過 7\n                (sign == -1 and digit > 8)    # 負數最後一位不能超過 8\n            )\n        ):\n            return 0  # 溢出時回傳 0\n\n        # 依序附加數位\n        result = result * 10 + digit\n\n    return sign * result\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    if not data:\n        sys.exit()\n    # 從輸入中擷取第一個整數\n    m = re.search(r'-?\\d+', data)\n    if not m:\n        sys.exit()\n    x = int(m.group())\n    print(reverse_integer(x))",
      "virtual_code": "Thinking...\nThe user wants virtual code for the reverse integer problem with 32-bit range check, no 64-bit integers allowed. Need to produce step-by-step virtual code with explanation per line. Use arrows, Decision: etc. Use Start, End. The steps: handle sign, iterate over digits, build result, check overflow before adding digit. Since no 64-bit, we must check overflow by comparing with INT_MAX / 10 etc. Virtual code lines.\n\nWe need to produce in Traditional Chinese. Each line: virtual code + space + // explanation.\n\nLet's design:\n\nStart\n\n→ Step 1: Set sign = 1 // 初始化符號\n→ Step 2: If x < 0? // 判斷是否負數\n    Yes → sign = -1 // 設定符號為 -1\n    No  → sign = 1 // 正數或零\n\n→ Step 3: x = abs(x) // 取絕對值處理\n\n→ Step 4: result = 0 // 初始化結果\n\n→ Decision: while x > 0? // 迴圈：當 x 有數位時\n    Yes →\n        digit = x mod 10 // 取得最低位數\n        x = x / 10 // 去掉最低位\n        // Overflow check before appending\n        Decision: result > INT_MAX / 10? // 檢查前一位是否已接近上限\n            Yes → result = 0 // overflow，終止\n            No  →\n                Decision: result == INT_MAX / 10 AND digit > 7? // 最後一位是否超過 7（INT_MAX 7）\n                    Yes → result = 0 // overflow\n                    No  →\n                        result = result * 10 + digit // 將 digit 附加\n\n        // If overflow flagged, break loop\n        Decision: result == 0? // 是否因 overflow 設置為 0\n            Yes → break // 跳出迴圈\n            No  → continue // 繼續\n\n    No  → // x==0，結束迴圈\n\n→ Step 5: return sign * result // 返回結果\n\nEnd\n\nBut we need each line as virtual code and comment. Must include decision blocks with indentation maybe.\n\nNeed to reflect no 64-bit usage; we use only 32-bit ints. For negative INT_MIN (-2^31) handling: abs(INT_MIN) overflows, but we handle by using sign and treat value as positive with abs? But cannot store abs(INT_MIN). In typical solution, we handle by using long? But not allowed. Approach: Work with positive representation of INT_MIN? Since we cannot store 64-bit, we must treat separately: Since INT_MIN is -2147483648, its absolute value 2147483648 exceeds INT_MAX. But we can process digits by using negative numbers only? Another approach: Instead of abs, we can keep x as positive by using unsigned? But 32-bit signed cannot hold 2147483648. So we need to handle sign at the end. Many solutions do this: they process absolute value by converting to positive using 64-bit; but here not allowed. Instead, we can reverse using negative number, or we can treat digits by mod 10 of negative numbers which gives negative digits? Actually for negative numbers, x % 10 yields negative remainder in C, but not in Python? In virtual code, we can define using absolute value by converting to string? But not allowed.\n\nSimplest: We can handle sign separately: if x<0, sign=-1; we can use x = -x (makes positive) but if x is INT_MIN, -x overflows. But we can treat x as negative and reverse digits by using positive digits? Let's think: If x is negative, we can reverse digits while maintaining negative sign. For example: x = -123; we can reverse as -321. Approach: Use negative value but still take digit = x % 10? In many languages, -123 % 10 = -3. So we could process digit = -(x % 10) to get positive digit. Then x = x / 10 (towards zero) yields -12. Continue. This way we don't need to store absolute value. So we can avoid overflow for INT_MIN because we never convert to positive. For INT_MIN, -(-2147483648/10) -> -(-214748364) = 214748364? Wait division in negative: -2147483648 / 10 = -214748364 (towards zero). Then digit = -(x % 10) => -( -2147483648 % 10) -> -( -8 )? In C, -2147483648 % 10 = -8. So digit = 8. That works. So we can process digits for negative numbers without overflow. So we don't need abs.\n\nSo we set sign = 1; if x < 0, sign = -1. Then we use while x != 0: digit = abs(x % 10) (or -(x % 10) if x negative). Use x = x / 10 (towards zero). Then same overflow check for result (which will be built as positive integer). At the end, result = result * sign. But for negative sign, we multiply sign at return. Overflow check must consider negative INT_MIN: when sign is -1, result must be <= INT_MAX (since INT_MIN = -2147483648). But we need to check overflow after applying sign. For positive sign, check <= INT_MAX; for negative sign, result <= 2147483648? Actually INT_MIN magnitude is 2147483648. But we only build positive result from digits; if sign is -1, we can allow result up to 2147483648. But since we use 32-bit signed int, cannot store 2147483648; but we can detect overflow when result > 2147483648? Actually 2147483648 cannot be stored in signed 32-bit. But we can detect if result > 2147483648? But we can't store 2147483648. So we need to check overflow before multiplication. Approach: Since result is positive, and sign negative, after loop we will return -result. If result > 2147483648, overflow. But we can't store 2147483648; but we can check if result > INT_MAX / 10 or result == INT_MAX /10 and next digit > 8. Because for negative, last digit can be 8. So we use check: if sign == -1 then allowed last digit up to 8. But our algorithm uses same check for all: result > INT_MAX/10 or (result == INT_MAX/10 and digit > 7) -> overflow. But for negative numbers, we should allow digit 8. So we need to adapt overflow check: if sign == 1: last digit > 7; if sign == -1: last digit > 8. Actually INT_MIN absolute value ends with 8. So we adjust.\n\nThus we need to keep sign separately and at each digit addition, we check overflow depending on sign.\n\nLet's design steps:\n\nStep: sign = 1\nDecision: if x < 0? \nYes -> sign = -1\nNo -> sign = 1\n\nresult = 0\n\nwhile x != 0:\n    digit = abs(x % 10) // get last digit\n    x = x / 10 // towards zero\n\n    // Check overflow before appending digit\n    if result > INT_MAX / 10 or (result == INT_MAX / 10 and \n        (digit > 7 if sign == 1 else digit > 8)):\n        result = 0\n        break\n\n    result = result * 10 + digit\n\nReturn sign * result\n\nBut the overflow check uses sign. So we might need a nested decision.\n\nThus in virtual code:\n\n→ Decision: while x != 0? \nYes ->\n    → Step: digit = abs(x % 10) // 取得最後一位數\n    → Step: x = x / 10 // 去掉最後一位\n    → Decision: result > INT_MAX / 10? // 檢查是否接近上限\n        Yes → result = 0 // overflow\n        No →\n            → Decision: result == INT_MAX / 10? // 檢查是否即將達到上限\n                Yes →\n                    → Decision: sign == 1 AND digit > 7? // 正數最後一位不能超過 7\n                        Yes → result = 0 // overflow\n                        No  →\n                            → Decision: sign == -1 AND digit > 8? // 負數最後一位可以 8\n                                Yes → result = 0 // overflow\n                                No  →\n                                    → Step: result = result * 10 + digit // 附加數位\n                No  → Step: result = result * 10 + digit\n\nAt the end of while loop.\n\nAfter loop: return sign * result\n\nReturn step: result = sign * result\n\nReturn 0 if overflow (result 0 indicates overflow? Actually if overflow, we break with result 0. But if original result could legitimately be 0? No because only when x had digits. But for input 0, result remains 0, but we return 0 which is correct. Overflow case also sets result to 0 and break; but we need to differentiate? The problem says return 0 if overflow. So setting result to 0 and breaking is fine.\n\nBut need to maintain final result: if overflow occurred, result is 0; else result is built.\n\nReturn sign * result // final output\n\nBut careful: If overflow happened, we want to return 0, not sign * result because result=0, sign * 0 = 0. Good.\n\nNow produce virtual code lines accordingly. Must include arrows, decisions, etc. Use '→' for steps. Use indentation? Use indentation to show nested decisions? The format example uses indentation for nested decisions. We can emulate similar.\n\nWe'll produce each line. Use [space] then comment. Use Traditional Chinese.\n\nLet's produce.\n\nWe'll also define INT_MAX constant maybe.\n\nNeed to reference INT_MAX; but it's typical: 2147483647. We'll mention.\n\nStart\n\n→ Step 1: sign = 1 // 初始化符號為正\n→ Decision: x < 0? // 判斷是否為負數\n    Yes → Step 2: sign = -1 // 設為負號\n    No  → Step 2: sign = 1 // 保持正號\n→ Step 3: result = 0 // 初始化結果\n\n→ Decision: x ≠ 0? // 只要還有數位就繼續\n    Yes →\n        → Step 4: digit = abs(x % 10) // 取得最低位數\n        → Step 5: x = x / 10 // 去掉最低位\n        → Decision: result > INT_MAX / 10? // 檢查是否已接近上限\n            Yes →\n                → Step 6: result = 0 // overflow，設為 0\n                → Step 7: break // 跳出迴圈\n            No →\n                → Decision: result == INT_MAX / 10? // 是否即將達到上限\n                    Yes →\n                        → Decision: sign == 1 AND digit > 7? // 正數最後位不能 >7\n                            Yes →\n                                → Step 6: result = 0 // overflow\n                                → Step 7: break\n                            No →\n                                → Decision: sign == -1 AND digit > 8? // 負數最後位不能 >8\n                                    Yes →\n                                        → Step 6: result = 0 // overflow\n                                        → Step 7: break\n                                    No  →\n                                        → Step 8: result = result * 10 + digit // 附加位元\n                    No  →\n                        → Step 8: result = result * 10 + digit // 附加位元\n    No  → // x 為 0，結束迴圈\n\n→ Step 9: return sign * result // 回傳最終結果（若 overflow 仍為 0）\n\nEnd\n\nNeed to ensure each line ends with ' // explanation'.\n\nAlso ensure indentation for nested decisions. Each line preceded by appropriate arrows. Indentation can be achieved by spaces. Example from sample: they used indentation with spaces. We'll replicate.\n\nWe need to use \"→\" for steps, \"Decision:\" lines.\n\nLet's produce lines accordingly.\n\nBe careful that we used Step 6 and Step 7 inside overflow case. But maybe better to use Step 6: result = 0; Step 7: break. We'll keep as separate lines.\n\nNow produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: sign = 1 // 初始化符號為正  \n→ Decision: x < 0? // 判斷是否為負數  \n  Yes → Step 2: sign = -1 // 設為負號  \n  No  → Step 2: sign = 1 // 保持正號  \n→ Step 3: result = 0 // 初始化結果  \n\n→ Decision: x ≠ 0? // 只要還有數位就繼續  \n  Yes →  \n   → Step 4: digit = abs(x % 10) // 取得最低位數  \n   → Step 5: x = x / 10 // 去掉最低位  \n   → Decision: result > INT_MAX / 10? // 檢查是否已接近上限  \n     Yes →  \n      → Step 6: result = 0 // overflow，設為 0  \n      → Step 7: break // 跳出迴圈  \n     No →  \n      → Decision: result == INT_MAX / 10? // 是否即將達到上限  \n        Yes →  \n         → Decision: sign == 1 AND digit > 7? // 正數最後位不能 >7  \n           Yes →  \n            → Step 6: result = 0 // overflow  \n            → Step 7: break  \n           No →  \n            → Decision: sign == -1 AND digit > 8? // 負數最後位不能 >8  \n              Yes →  \n               → Step 6: result = 0 // overflow  \n               → Step 7: break  \n            No  →  \n             → Step 8: result = result * 10 + digit // 附加位元  \n       No  →  \n        → Step 8: result = result * 10 + digit // 附加位元  \n  No → // x 為 0，結束迴圈  \n\n→ Step 9: return sign * result // 回傳最終結果（若 overflow 仍為 0）  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Two Sum II - Input Array Is Sorted",
      "source_file": "Leetcode/leetcode167.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "numbers = [2,7,11,15], target = 9",
          "expected_output": "[1,2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp11f9_nn2.py\", line 45, in <module>\n    numbers, target = parse_input()\n                      ^^^^^^^^^^^^^\n  File \"/tmp/tmp11f9_nn2.py\", line 35, in parse_input\n    raise ValueError(\"輸入格式錯誤，請使用 'numbers = [...], target = ...'\")\nValueError: 輸入格式錯誤，請使用 'numbers = [...], target = ...'"
        },
        {
          "example_index": 1,
          "input": "numbers = [2,3,4], target = 6",
          "expected_output": "[1,3]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp34ka3_hd.py\", line 45, in <module>\n    numbers, target = parse_input()\n                      ^^^^^^^^^^^^^\n  File \"/tmp/tmp34ka3_hd.py\", line 35, in parse_input\n    raise ValueError(\"輸入格式錯誤，請使用 'numbers = [...], target = ...'\")\nValueError: 輸入格式錯誤，請使用 'numbers = [...], target = ...'"
        },
        {
          "example_index": 2,
          "input": "numbers = [-1,0], target = -1",
          "expected_output": "[1,2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp1uxufueo.py\", line 45, in <module>\n    numbers, target = parse_input()\n                      ^^^^^^^^^^^^^\n  File \"/tmp/tmp1uxufueo.py\", line 35, in parse_input\n    raise ValueError(\"輸入格式錯誤，請使用 'numbers = [...], target = ...'\")\nValueError: 輸入格式錯誤，請使用 'numbers = [...], target = ...'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def twoSum(self, numbers, target):\n        \"\"\"使用雙指標法尋找兩個數字之和等於 target。\n        由於數組已排好序，時間複雜度為 O(n)，空間複雜度為 O(1)。\"\"\"\n        left, right = 0, len(numbers) - 1\n        while left < right:\n            s = numbers[left] + numbers[right]\n            if s == target:\n                # 回傳 1 索引的結果\n                return [left + 1, right + 1]\n            elif s < target:\n                left += 1\n            else:\n                right -= 1\n        return []  # 這行不會被執行，題目保證一定有解\n\ndef parse_input():\n    \"\"\"從標準輸入讀取並解析 `numbers = [...] , target = ...` 這樣的字串。\"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return [], 0\n    # 先把逗號分開，並找出 numbers 與 target 的子字串\n    parts = data.split(',')\n    if len(parts) != 2:\n        # 如果輸入格式不同，直接嘗試評估整個字串\n        try:\n            obj = ast.literal_eval(data)\n            if isinstance(obj, dict):\n                return obj.get('numbers', []), obj.get('target', 0)\n        except Exception:\n            pass\n        raise ValueError(\"輸入格式錯誤，請使用 'numbers = [...], target = ...'\")\n    # 解析 numbers\n    numbers_part = parts[0].split('=', 1)[1].strip()\n    numbers = ast.literal_eval(numbers_part)\n    # 解析 target\n    target_part = parts[1].split('=', 1)[1].strip()\n    target = int(target_part)\n    return numbers, target\n\nif __name__ == \"__main__\":\n    numbers, target = parse_input()\n    sol = Solution()\n    result = sol.twoSum(numbers, target)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to output virtual code steps with explanation. The problem: Two Sum in sorted array with constant space. Use two-pointer approach. Steps: Start, initialize left=0, right=n-1, while left<right: sum = numbers[left]+numbers[right]; if sum==target: return [left+1,right+1]; else if sum<target: left++; else right--; End. Provide explanation after each step.\n\nWe need to use arrow syntax: \"→ Step: ... // explanation\". For decisions, \"Decision:\". For loops, perhaps use \"Decision:\" or \"While\". Use \"Decision: While left < right?\" with Yes/No. Provide final output accordingly.\n\nAlso note we must not output actual code, only virtual code. We'll produce lines as:\n\nStart // 程式開始執行\n→ Step 1: 初始化 left = 0, right = numbers.length - 1 // 設定雙指標\n→ Decision: 是否 left < right? // 檢查是否仍有兩個指標可比較\n    Yes → Step 2: 計算 sum = numbers[left] + numbers[right] // 取得兩端數字之和\n    Yes → Decision: sum 等於 target? // 判斷是否找到答案\n        Yes → Step 3: 回傳 [left+1, right+1] // 回傳一基數索引\n        No → Decision: sum 小於 target? // 判斷是否需要移動左指標\n            Yes → Step 4: left = left + 1 // 左指標右移\n            No  → Step 5: right = right - 1 // 右指標左移\n    No → End // 雙指標交叉，結束\nEnd // 程式執行結束\n\nBut we should follow format: each line is either \"Start\", \"→ Step ...\", \"→ Decision:\", with Yes/No branches indenting.\n\nWe also need to include explanation after each line. For decisions and branches, include explanation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 left = 0, right = numbers.length - 1 // 設定兩端指標，左端指向第一個元素，右端指向最後一個元素  \n→ Decision: 是否 left < right? // 檢查指標是否還能形成一對數字  \n    Yes → Step 2: 計算 sum = numbers[left] + numbers[right] // 取得兩端數字之和  \n    Yes → Decision: sum 等於 target? // 判斷是否已找到正確組合  \n        Yes → Step 3: 回傳 [left + 1, right + 1] // 回傳一基索引結果，程式結束  \n        No → Decision: sum 小於 target? // 若和不足目標，需要調整左指標  \n            Yes → Step 4: left = left + 1 // 左指標右移，嘗試更大數字  \n            No → Step 5: right = right - 1 // 右指標左移，嘗試更小數字  \n    No → End // 指標已交叉，符合題目條件已找到唯一解，程式結束  \nEnd // 程式執行結束"
    },
    {
      "title": "Evaluate Division",
      "source_file": "Leetcode/leetcode399.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]",
          "expected_output": "[6.00000,0.50000,-1.00000,1.00000,-1.00000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp4doe3z0c.py\", line 41, in <module>\n    main()\n  File \"/tmp/tmp4doe3z0c.py\", line 34, in main\n    exec(data, globals())\n  File \"<string>\", line 1\n    equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1.5,2.5,5.0], queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]",
          "expected_output": "[3.75000,0.40000,5.00000,0.20000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpy1ocw2vw.py\", line 41, in <module>\n    main()\n  File \"/tmp/tmpy1ocw2vw.py\", line 34, in main\n    exec(data, globals())\n  File \"<string>\", line 1\n    equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1.5,2.5,5.0], queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 2,
          "input": "equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]",
          "expected_output": "[0.50000,2.00000,-1.00000,-1.00000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmps8t_2jy7.py\", line 41, in <module>\n    main()\n  File \"/tmp/tmps8t_2jy7.py\", line 34, in main\n    exec(data, globals())\n  File \"<string>\", line 1\n    equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]\n    ^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "import sys\nfrom collections import defaultdict\n\nclass Solution:\n    def calcEquation(self, equations, values, queries):\n        graph = defaultdict(dict)\n        for (a, b), val in zip(equations, values):\n            graph[a][b] = val\n            graph[b][a] = 1 / val\n\n        def dfs(src, dst, visited):\n            if src not in graph or dst not in graph:\n                return -1.0\n            if src == dst:\n                return 1.0\n            visited.add(src)\n            for neighbor, weight in graph[src].items():\n                if neighbor not in visited:\n                    res = dfs(neighbor, dst, visited)\n                    if res != -1.0:\n                        return weight * res\n            return -1.0\n\n        res = []\n        for u, v in queries:\n            res.append(dfs(u, v, set()))\n        return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Execute the input string to define equations, values, queries\n    exec(data, globals())\n    sol = Solution()\n    results = sol.calcEquation(equations, values, queries)\n    output = '[' + ','.join(f'{x:.5f}' for x in results) + ']'\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce a step-by-step virtual code, line by line, for solving this problem: given equations and values, process queries, return results or -1.0. We should produce algorithm description, e.g., build graph, DFS/BFS to find product ratio, handle disconnected components, return -1.0. Must output each line as virtual code step plus explanation.\n\nWe need to produce code in a pseudocode style with arrows. Should not output actual code, only structure steps. Each line has \"虛擬碼步驟\" + space + \"// 解釋/說明\". Use Start, End, Decision. Include arrow → for next step. Use Yes → No → for decision branches.\n\nWe need to produce lines that explain building graph, adding edges, DFS queries, returning result.\n\nOk. Let's craft steps:\n\nStart\n→ Step 1: 初始化圖 adjacency list // 建立一張哈希表，存 variable → list of (neighbor, weight)\n→ Step 2: 迭代 equations, values // 將每個方程加入圖\n   → Step 2.1: 對於 (Ai, Bi) 和 val\n       → Edge Ai → Bi with weight val // Ai / Bi = val\n       → Edge Bi → Ai with weight 1/val // Bi / Ai = 1/val\n→ Step 3: 定義函數 dfs(current, target, accum, visited) // 計算從 current 到 target 的乘積\n   → Decision: 如果 current == target? // 已到目標\n        Yes → Return accum // 成功，返回累積乘積\n        No  → Decision: 如果 current 不在 visited? // 未訪問\n            Yes → Mark visited\n                → Step 3.1: 針對所有鄰居 (next, weight)\n                     → Step 3.2: 結果 = dfs(next, target, accum * weight, visited)\n                        → Decision: 如果結果 != -1.0? // 找到路徑\n                            Yes → Return 結果\n                            No  → Continue\n                → Return -1.0 // 沒有路徑\n            No  → Return -1.0 // 重複訪問\n→ Step 4: 初始化答案陣列 results\n→ Step 5: 迭代每個 query (Cj, Dj)\n   → Decision: 如果 Cj 或 Dj 不在圖? // 未定義\n        Yes → Append -1.0 to results // 無法計算\n        No  → Step 5.1: 呼叫 dfs(Cj, Dj, 1.0, 空集合)\n            → Append 回傳值 to results\n→ End // 返回結果陣列\n\nNeed to output each line individually. The code lines can contain step numbers? We can just produce lines. Use arrow symbol → for each next line. Use Decision and Yes→ No→.\n\nWe need to ensure each line is separated. Let's craft.\n\nRemember to include explanation after //.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立圖 adjacency list // 初始化一個哈希表，鍵為變數，值為鄰接變數與權重的清單\n→ Step 2: 對每個方程 (Ai, Bi) 及其值 val 進行迭代 // 將方程加入圖\n   → Step 2.1: 加入邊 Ai → Bi，權重為 val // Ai / Bi = val\n   → Step 2.2: 加入邊 Bi → Ai，權重為 1 / val // Bi / Ai = 1 / val\n→ Step 3: 定義遞迴函數 dfs(current, target, accum, visited) // 計算從 current 到 target 的乘積\n   → Decision: current == target? // 是否已到目標節點\n        Yes → Return accum // 成功，回傳累積乘積\n        No  → Decision: current 不在 visited? // 是否未訪問此節點\n            Yes → Mark current 為已訪問\n                → Step 3.1: 遍歷 current 的所有鄰居 (next, weight)\n                    → Step 3.2: 結果 = dfs(next, target, accum * weight, visited)\n                        → Decision: 結果 != -1.0? // 是否已找到路徑\n                            Yes → Return 結果 // 直接回傳\n                            No  → 進行下一個鄰居\n                → Return -1.0 // 所有鄰居都無法到達 target\n            No  → Return -1.0 // 重複訪問，直接失敗\n→ Step 4: 初始化答案列表 results // 用來儲存所有查詢的結果\n→ Step 5: 對每個查詢 (Cj, Dj) 進行迭代 // 處理所有查詢\n   → Decision: Cj 或 Dj 不在圖中? // 變數未定義\n        Yes → Append -1.0 到 results // 無法計算，直接記錄\n        No  → Step 5.1: 呼叫 dfs(Cj, Dj, 1.0, 空集合) // 開始遞迴計算\n            → Append 回傳值到 results // 存入答案\n→ End // 程式執行結束，返回 results\n\nReturn results // 將所有查詢結果輸出。"
    },
    {
      "title": "Implement Stack using Queues",
      "source_file": "Leetcode/leetcode225.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "Input [\"MyStack\", \"push\", \"push\", \"top\", \"pop\", \"empty\"], [[], [1], [2], [], [], []]",
          "expected_output": "[null, null, null, 2, 2, false]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpojzhog92.py\", line 98, in <module>\n    main()\n  File \"/tmp/tmpojzhog92.py\", line 66, in main\n    ops, args = parse_input(data)\n                ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpojzhog92.py\", line 57, in parse_input\n    ops = ast.literal_eval(parts[0])\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 112, in literal_eval\n    return _convert(node_or_string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 111, in _convert\n    return _convert_signed_num(node)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 85, in _convert_signed_num\n    return _convert_num(node)\n           ^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 76, in _convert_num\n    _raise_malformed_node(node)\n  File \"/usr/lib/python3.12/ast.py\", line 73, in _raise_malformed_node\n    raise ValueError(msg + f': {node!r}')\nValueError: malformed node or string on line 1: <ast.Subscript object at 0x78d618ef7b90>"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import deque\n\nclass MyStack:\n    def __init__(self):\n        self.q1 = deque()\n        self.q2 = deque()\n\n    def push(self, x):\n        \"\"\"把元素放入主隊列\"\"\"\n        self.q1.append(x)\n\n    def pop(self):\n        \"\"\"移除並回傳堆疊頂部元素\"\"\"\n        if not self.q1:\n            return None\n        # 把前面所有元素搬到輔助隊列，只留下最後一個\n        while len(self.q1) > 1:\n            self.q2.append(self.q1.popleft())\n        popped = self.q1.popleft()\n        # 交換兩個隊列，恢復為主隊列\n        self.q1, self.q2 = self.q2, self.q1\n        return popped\n\n    def top(self):\n        \"\"\"回傳堆疊頂部元素但不移除\"\"\"\n        if not self.q1:\n            return None\n        while len(self.q1) > 1:\n            self.q2.append(self.q1.popleft())\n        top_val = self.q1.popleft()\n        # 把頂部元素放回輔助隊列\n        self.q2.append(top_val)\n        # 交換兩個隊列，恢復為主隊列\n        self.q1, self.q2 = self.q2, self.q1\n        return top_val\n\n    def empty(self):\n        \"\"\"判斷堆疊是否為空\"\"\"\n        return not self.q1\n\n\ndef parse_input(s: str):\n    \"\"\"解析 LeetCode 樣式的輸入字串\"\"\"\n    s = s.strip()\n    # 如果包含字首 Input，移除之\n    if s.lower().startswith(\"input\"):\n        s = s.split(\":\", 1)[-1].strip()\n    # 找到第一個 '],'\n    split_idx = s.find(\"],\")\n    if split_idx == -1:\n        # 直接使用 literal_eval 兩個列表\n        parts = s.split(\",\", 1)\n    else:\n        parts = [s[:split_idx + 1], s[split_idx + 2:]]\n    ops = ast.literal_eval(parts[0])\n    args = ast.literal_eval(parts[1])\n    return ops, args\n\n\ndef main():\n    data = sys.stdin.read()\n    if not data:\n        return\n    ops, args = parse_input(data)\n\n    stack = MyStack()\n    results = [None]  # 第一個對應 MyStack 初始化\n\n    for op, arg in zip(ops[1:], args[1:]):  # skip first \"MyStack\" constructor\n        if op == \"push\":\n            stack.push(arg[0])\n            results.append(None)\n        elif op == \"pop\":\n            results.append(stack.pop())\n        elif op == \"top\":\n            results.append(stack.top())\n        elif op == \"empty\":\n            results.append(stack.empty())\n        else:\n            # 若有其他方法，直接呼叫\n            results.append(None)\n\n    # 轉換為輸出格式\n    out_vals = []\n    for v in results:\n        if v is None:\n            out_vals.append(\"null\")\n        elif isinstance(v, bool):\n            out_vals.append(\"true\" if v else \"false\")\n        else:\n            out_vals.append(str(v))\n    print(f\"[{', '.join(out_vals)}]\")\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce a virtual code algorithm for implementing a stack using two queues. Provide step-by-step pseudocode lines with explanation. Each line must contain virtual code step + space + // explanation. Use arrows, decision etc.\n\nWe should provide algorithm steps for push, pop, top, empty.\n\nWe need to show how to maintain two queues q1 and q2.\n\nWe need to show initialization: q1 empty, q2 empty.\n\nPush: enqueue to q1.\n\nPop: move all but last element from q1 to q2, then dequeue last from q1 and return, swap q1 and q2.\n\nTop: similar but return last element without removing? But need to peek; we can pop the last element but push it back to q2? For virtual code we can just describe retrieving last.\n\nBut we need to use only queue operations.\n\nOk.\n\nLet's produce algorithm for class MyStack:\n\nStart: initialize q1 and q2 empty\n\npush(x):\n→ Step: q1.enqueue(x) // add element to queue1\n\npop():\n→ Step: while q1.size > 1:\n   → q2.enqueue(q1.dequeue()) // move all but last to queue2\n→ Step: topVal = q1.dequeue() // remove last element\n→ Step: swap q1 and q2 // make q2 back to q1\n→ Step: return topVal\n\ntop():\n→ Step: while q1.size > 1:\n   → q2.enqueue(q1.dequeue())\n→ Step: topVal = q1.dequeue()\n→ Step: q2.enqueue(topVal) // push it back to q2\n→ Step: swap q1 and q2\n→ Step: return topVal\n\nempty():\n→ Decision: if q1.isEmpty() and q2.isEmpty() // but after operations, one queue contains elements. Actually only q1 will contain elements after swap. So we can check q1.isEmpty()\n    Yes → return true\n    No → return false\n\nBut we may just check q1.isEmpty().\n\nLet's produce virtual code lines accordingly.\n\nWe need to include Start and End.\n\nWe can present as a single algorithm with methods.\n\nMaybe we produce a pseudo-method definition lines.\n\nLet's craft:\n\nStart\n→ Step: Declare queue q1 // 初始化主隊列\n→ Step: Declare queue q2 // 初始化輔助隊列\n→ Method push(x):\n    → q1.enqueue(x) // 將新元素放入主隊列\n→ Method pop():\n    → Decision: q1.isEmpty()? // 如果主隊列為空則返回空值\n        Yes → return null\n        No  → \n            → Step: while q1.size > 1:\n                    → q2.enqueue(q1.dequeue()) // 移除元素到輔助隊列\n            → Step: popped = q1.dequeue() // 取出最後一個元素\n            → Step: swap(q1, q2) // 交換兩隊列\n            → Step: return popped\n→ Method top():\n    → Decision: q1.isEmpty()?\n        Yes → return null\n        No  →\n            → Step: while q1.size > 1:\n                    → q2.enqueue(q1.dequeue())\n            → Step: topVal = q1.dequeue()\n            → Step: q2.enqueue(topVal) // 把頂部元素放回輔助隊列\n            → Step: swap(q1, q2)\n            → Step: return topVal\n→ Method empty():\n    → Decision: q1.isEmpty()\n        Yes → return true\n        No  → return false\nEnd\n\nBut each line must be separate.\n\nWe need to ensure each line ends with // explanation. Use arrows for decision.\n\nWe'll use indentation as in example.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: Declare queue q1 // 初始化主隊列，用來暫存所有元素  \n→ Step: Declare queue q2 // 初始化輔助隊列，用於幫助彈出與查看頂部元素  \n\n→ Method push(x): // 推入元素到堆疊  \n    → Step: q1.enqueue(x) // 將元素放入主隊列尾部  \n\n→ Method pop(): // 從堆疊彈出頂部元素並回傳  \n    → Decision: q1.isEmpty() ? // 檢查堆疊是否為空  \n        Yes → Step: return null // 空堆疊，返回 null  \n        No  →  \n            → Step: while q1.size > 1: // 只保留最後一個元素  \n                → q2.enqueue(q1.dequeue()) // 把前面所有元素搬到輔助隊列  \n            → Step: popped = q1.dequeue() // 取出主隊列的唯一元素，即頂部元素  \n            → Step: swap(q1, q2) // 將輔助隊列重新設為主隊列，恢復原始順序  \n            → Step: return popped // 回傳彈出的元素  \n\n→ Method top(): // 查看堆疊頂部元素但不移除  \n    → Decision: q1.isEmpty() ? // 檢查堆疊是否為空  \n        Yes → Step: return null // 空堆疊，返回 null  \n        No  →  \n            → Step: while q1.size > 1: // 只保留最後一個元素  \n                → q2.enqueue(q1.dequeue()) // 把前面所有元素搬到輔助隊列  \n            → Step: topVal = q1.dequeue() // 取出主隊列的唯一元素，即頂部元素  \n            → Step: q2.enqueue(topVal) // 再把頂部元素放回輔助隊列  \n            → Step: swap(q1, q2) // 將輔助隊列重新設為主隊列  \n            → Step: return topVal // 回傳頂部元素  \n\n→ Method empty(): // 判斷堆疊是否為空  \n    → Decision: q1.isEmpty() ? // 只需檢查主隊列是否空  \n        Yes → Step: return true // 堆疊空  \n        No  → Step: return false // 堆疊非空  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Course Schedule II",
      "source_file": "Leetcode/leetcode210.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "numCourses = 2, prerequisites = [[1,0]]",
          "expected_output": "[0,1]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmprm21g5sw.py\", line 41, in <module>\n    prerequisites = eval(prereq_str)\n                    ^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [[1\n     ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]",
          "expected_output": "[0,1,2,3]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpjxne5p7d.py\", line 41, in <module>\n    prerequisites = eval(prereq_str)\n                    ^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [[1\n     ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nfrom collections import deque\n\ndef findOrder(numCourses, prerequisites):\n    # 建立鄰接表與入度表\n    graph = [[] for _ in range(numCourses)]\n    indegree = [0] * numCourses\n    for dest, src in prerequisites:\n        graph[src].append(dest)\n        indegree[dest] += 1\n\n    # 以入度為 0 的節點作為起點\n    queue = deque([i for i in range(numCourses) if indegree[i] == 0])\n    order = []\n\n    # Kahn 的拓樸排序\n    while queue:\n        node = queue.popleft()\n        order.append(node)\n        for neighbor in graph[node]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                queue.append(neighbor)\n\n    # 若結果長度等於課程數，代表沒有循環\n    return order if len(order) == numCourses else []\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    # 解析類似 \"numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]\"\n    data = data.replace(' ', '')  # 去除空白\n    parts = data.split(',')\n    numCourses = 0\n    prerequisites = []\n    for part in parts:\n        if part.startswith('numCourses='):\n            numCourses = int(part[len('numCourses='):])\n        elif part.startswith('prerequisites='):\n            prereq_str = part[len('prerequisites='):]\n            # 使用 eval 解析列表字面量\n            prerequisites = eval(prereq_str)\n\n    result = findOrder(numCourses, prerequisites)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to output virtual code for problem: topological sort given prerequisites. Use Kahn's algorithm. Provide step-by-step virtual code lines with explanations.\n\nNeed to produce lines with \"Start\", \"→\", \"Decision:\" etc.\n\nWe need to ensure each line ends with \"// 解釋/說明\". Provide arrow and indent.\n\nWe should include creation of adjacency list, indegree array, queue, result array.\n\nEdge cases: if cycle, return empty array.\n\nLet's produce virtual pseudocode.\n\nMake sure to include Start // etc.\n\nWe'll structure:\n\nStart // 開始\n\n→ Step 1: 建立 adjacency list adj[0..numCourses-1] as empty lists // 初始化鄰接表\n\n→ Step 2: 建立 indegree[0..numCourses-1] 為 0 // 初始化入度\n\n→ Step 3: 對於每個 pair [a, b] in prerequisites:\n    → Step 3.1: adj[b].append(a) // b 前置於 a\n    → Step 3.2: indegree[a] += 1 // a 入度加 1\n\n→ Step 4: 建立空 queue Q // 用來存入度為 0 的節點\n\n→ Step 5: 對 i 0..numCourses-1:\n    → Decision: 如果 indegree[i] == 0?\n        Yes → Q.enqueue(i) // 入度為 0 的課程加入 queue\n\n→ Step 6: 建立空 list order // 取得課程順序\n\n→ Step 7: While Q 不為空:\n    → Step 7.1: cur = Q.dequeue()\n    → Step 7.2: order.append(cur) // 加入結果\n    → Step 7.3: 對每個 nei in adj[cur]:\n        → Step 7.3.1: indegree[nei] -= 1 // 減少入度\n        → Step 7.3.2: Decision: 如果 indegree[nei] == 0?\n            Yes → Q.enqueue(nei) // 入度為 0 則加入 queue\n\n→ Step 8: Decision: 如果 len(order) == numCourses?\n    Yes → Return order // 成功得到所有課程順序\n    No  → Return empty array // 無法完成所有課程，存在循環\n\nEnd // 程式結束\n\nEnsure each line has arrow or Decision etc. Use \"→\" for steps, \"Decision:\" for condition, indent lines with spaces.\n\nNeed to output each line on its own line.\n\nAlso include \"Start\" at beginning and \"End\".\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 adjacency list adj[0..numCourses-1] 為空清單 // 初始化鄰接表  \n→ Step 2: 建立 indegree[0..numCourses-1] 為 0 // 初始化入度  \n→ Step 3: 對於每個 pair [a, b] 在 prerequisites  \n  → Step 3.1: adj[b].append(a) // 以 b 為前置課程，加入 a 的鄰接  \n  → Step 3.2: indegree[a] += 1 // a 的入度加 1  \n→ Step 4: 建立空 queue Q // 用來儲存入度為 0 的課程  \n→ Step 5: 對 i 0..numCourses-1  \n  → Decision: 如果 indegree[i] == 0? // 檢查入度是否為 0  \n   Yes → Q.enqueue(i) // 入度為 0 的課程加入 queue  \n→ Step 6: 建立空 list order // 儲存課程排序結果  \n→ Step 7: While Q 不為空  \n  → Step 7.1: cur = Q.dequeue() // 取出一個入度為 0 的課程  \n  → Step 7.2: order.append(cur) // 加入結果順序  \n  → Step 7.3: 對每個 nei in adj[cur]  \n    → Step 7.3.1: indegree[nei] -= 1 // 減少鄰接課程的入度  \n    → Decision: 如果 indegree[nei] == 0? // 檢查是否已無前置課程  \n     Yes → Q.enqueue(nei) // 入度為 0 則加入 queue  \n→ Step 8: Decision: 如果 len(order) == numCourses? // 所有課程都已排入  \n  Yes → Return order // 成功得到一個有效課程順序  \n  No  → Return empty array // 依賴關係形成循環，無法完成所有課程  \nEnd // 程式執行結束"
    },
    {
      "title": "Word Ladder II",
      "source_file": "Leetcode/leetcode126.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
          "expected_output": "[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpnuakmcd2.py\", line 63, in <module>\n    main()\n  File \"/tmp/tmpnuakmcd2.py\", line 46, in main\n    node = ast.parse(code, mode='exec')\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\n    ^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]",
          "expected_output": "[]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpxdoqsy1o.py\", line 63, in <module>\n    main()\n  File \"/tmp/tmpxdoqsy1o.py\", line 46, in main\n    node = ast.parse(code, mode='exec')\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\n    ^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict, deque\n\nclass Solution:\n    def findLadders(self, beginWord, endWord, wordList):\n        wordSet = set(wordList)\n        if endWord not in wordSet:\n            return []\n\n        # BFS: record distance (layer) and parents for shortest paths\n        layer = {beginWord: 0}\n        parents = defaultdict(list)\n        queue = deque([beginWord])\n\n        while queue:\n            word = queue.popleft()\n            step = layer[word]\n            for i in range(len(word)):\n                for c in 'abcdefghijklmnopqrstuvwxyz':\n                    new_word = word[:i] + c + word[i+1:]\n                    if new_word in wordSet:\n                        if new_word not in layer:\n                            layer[new_word] = step + 1\n                            queue.append(new_word)\n                            parents[new_word].append(word)\n                        elif layer[new_word] == step + 1:\n                            parents[new_word].append(word)\n\n        res = []\n\n        def dfs(path, word):\n            if word == beginWord:\n                res.append(path[::-1])\n                return\n            for prev in parents[word]:\n                dfs(path + [prev], prev)\n\n        if endWord in parents:\n            dfs([endWord], endWord)\n\n        return res\n\ndef main():\n    code = sys.stdin.read()\n    node = ast.parse(code, mode='exec')\n    vars_dict = {}\n    for stmt in node.body:\n        if isinstance(stmt, ast.Assign):\n            target = stmt.targets[0]\n            if isinstance(target, ast.Name):\n                vars_dict[target.id] = ast.literal_eval(stmt.value)\n\n    beginWord = vars_dict.get('beginWord', '')\n    endWord = vars_dict.get('endWord', '')\n    wordList = vars_dict.get('wordList', [])\n\n    solution = Solution()\n    result = solution.findLadders(beginWord, endWord, wordList)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code, step by step, with explanations, using Start, End, Decision, etc. Should handle BFS to find all shortest transformation sequences. The description: typical Word Ladder II problem. Steps: build adjacency graph by generating patterns, BFS from beginWord to find distances, then DFS/backtrack to collect all shortest paths.\n\nWe'll produce virtual code lines. Must include \"虛擬碼步驟\" + space + \"// 解釋/說明\". Use arrows: →, Yes →, No →.\n\nLet's outline:\n\nStart\n→ Build adjacency list from wordList + beginWord\n→ If endWord not in wordList, return empty\n→ BFS from beginWord to compute distance map and parent adjacency\n→ If endWord not visited, return empty\n→ Backtrack from endWord to beginWord using parents to build all shortest paths\n→ Reverse each path\n→ Return list of paths\nEnd\n\nNeed detailed steps: building patterns, BFS loop, exploring neighbors, building parents map: mapping word -> list of previous words in BFS tree that lead to shortest distance.\n\nThen backtrack recursively.\n\nWe'll produce each step line with explanation. Use arrows.\n\nOk. Let's output.\n...done thinking.\n\nStart // 程式開始執行\n→ BuildAdjacency(wordList, beginWord) // 先將字典及起始字串組成鄰接圖，使用「*」模式生成相鄰關係\n→ Decision: 若 endWord 不在 wordList? // 若終點不存在於字典，無法轉換\n    Yes → Return [] // 回傳空列表表示無合法序列\n    No  →\n→ BFS(beginWord, endWord, adjacency) // 以廣度優先搜尋找出最短距離並建立父子關係映射\n→ Decision: 若 endWord 未被訪問? // 若 BFS 無法到達終點，表示無任何轉換序列\n    Yes → Return [] // 回傳空列表\n    No  →\n→ Backtrack(endWord, beginWord, parents, path, result) // 從終點回溯至起點，組成所有最短路徑\n→ Reverse每條 path in result // 由終點到起點的順序需倒轉回正常方向\n→ Return result // 回傳所有最短轉換序列\nEnd // 程式執行結束\n\n// 以下為輔助函式的虛擬碼\n\nBuildAdjacency(wordList, beginWord) // 建立鄰接圖\n→ WordSet ← wordList ∪ {beginWord} // 包含起始字詞\n→ For each word in WordSet\n    → For i from 0 to len(word)-1\n        → Pattern ← word[:i] + \"*\" + word[i+1:] // 產生通配符模式\n        → PatternMap[Pattern].append(word) // 將單字加入該模式的列表\n→ For each word in WordSet\n    → For i from 0 to len(word)-1\n        → Pattern ← word[:i] + \"*\" + word[i+1:]\n        → For each neighbor in PatternMap[Pattern]\n            → If neighbor != word\n                → adjacency[word].append(neighbor) // 建立雙向鄰接\n\nBFS(beginWord, endWord, adjacency) // 廣度優先搜尋\n→ Queue ← [beginWord]\n→ distance[beginWord] ← 0\n→ parents[beginWord] ← [] // 起始字無父節點\n→ While Queue not empty\n    → Current ← Queue.pop_front()\n    → For each neighbor in adjacency[Current]\n        → If neighbor not in distance\n            → distance[neighbor] ← distance[Current] + 1\n            → parents[neighbor].append(Current) // 記錄上一層節點\n            → Queue.append(neighbor)\n        → Else if distance[neighbor] == distance[Current] + 1\n            → parents[neighbor].append(Current) // 同層的另一條最短路徑\n\nBacktrack(endWord, beginWord, parents, path, result) // 深度優先回溯\n→ path.append(endWord) // 將當前節點加入路徑\n→ If endWord == beginWord\n    → result.append(copy(path)) // 完整路徑，加入結果\n→ Else\n    → For each prev in parents[endWord]\n        → Backtrack(prev, beginWord, parents, path, result) // 追溯上一層\n→ path.pop() // 從路徑中移除當前節點，回到上一層\n\n// 以上即為完整的虛擬碼流程，遵循題目所述的所有要求。"
    },
    {
      "title": "Generate Random Point in a Circle",
      "source_file": "Leetcode/leetcode478.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]",
          "expected_output": "[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[-0.02493,-0.38077],[0.82314,0.38945],[0.36572,0.17248]]'\nGot (Norm):      '[null,[0.4534233821420921,0.26306473048267287],[-0.509865248172133,0.03312109479044017],[-0.2681868377830957,-0.56936079302316]]'\n--- (Raw) ---\nRaw Expected: '[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]'\nRaw Got:      '[null, [0.4534233821420921, 0.26306473048267287], [-0.509865248172133, 0.03312109479044017], [-0.2681868377830957, -0.56936079302316]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport math\n\nclass Solution:\n    def __init__(self, radius, x_center, y_center):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n\n    def randPoint(self):\n        r = self.radius * math.sqrt(random.random())\n        theta = random.uniform(0, 2 * math.pi)\n        x = self.x_center + r * math.cos(theta)\n        y = self.y_center + r * math.sin(theta)\n        return [x, y]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    if not data or len(data) < 2:\n        sys.exit()\n\n    # 解析輸入的函式名與參數\n    commands = json.loads(data[0])\n    arguments = json.loads(data[1])\n\n    output = [None]  # constructor returns None\n    obj = None\n\n    for cmd, args in zip(commands, arguments):\n        if cmd == \"Solution\":\n            obj = Solution(*args)\n        elif cmd == \"randPoint\":\n            output.append(obj.randPoint())\n        else:\n            # 如有其他方法，直接呼叫並存入結果\n            func = getattr(obj, cmd)\n            output.append(func(*args))\n\n    # 輸出結果，符合 LeetCode 格式\n    print(json.dumps(output))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for generating uniform random point inside a circle given radius and center. We should include steps: initialization store radius, center. In randPoint: generate random radius sqrt(random()*R^2) to ensure uniform area. Generate random angle uniform [0,2π). Compute x = center_x + r*cos(angle), y = center_y + r*sin(angle). Return [x,y].\n\nWe need to format as lines: \"Start\" etc. Use virtual arrows. Use Decision? maybe not needed. We'll structure main steps.\n\nWe need to produce each line: \"虛擬碼步驟 // 解釋\" e.g., \"Start // 程式開始執行\".\n\nLet's produce:\n\nStart\n→ Step 1: Store radius, center_x, center_y in object // 初始化屬性\n→ Step 2: In randPoint, generate u = random() // 取得 0~1\n→ Step 3: Calculate r = sqrt(u) * radius // 產生符合面積分布的半徑\n→ Step 4: Generate θ = random() * 2π // 隨機角度\n→ Step 5: Compute x = center_x + r * cos(θ) // 計算 X 座標\n→ Step 6: Compute y = center_y + r * sin(θ) // 計算 Y 座標\n→ Step 7: Return [x, y] // 回傳隨機點\nEnd\n\nBut maybe we need to show that we return within circle inclusive of boundary. Use Decision? not necessary.\n\nMake sure each line includes arrow and explanation. Let's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 Solution 物件時，存入 radius、x_center、y_center // 初始化圓的半徑與中心座標  \n→ Step 2: randPoint() 呼叫時，產生隨機數 u，範圍 0 ~ 1 // 取得隨機比例值  \n→ Step 3: 計算半徑 r = sqrt(u) * radius // 使用 sqrt 以符合面積均勻分布  \n→ Step 4: 產生隨機角度 θ = random() * 2π // 取得 0 ~ 2π 之間的隨機角度  \n→ Step 5: 計算 x = x_center + r * cos(θ) // 根據角度與半徑算出 X 座標  \n→ Step 6: 計算 y = y_center + r * sin(θ) // 根據角度與半徑算出 Y 座標  \n→ Step 7: 回傳 [x, y] // 將計算得到的隨機點作為陣列回傳  \nEnd // 程式執行結束"
    },
    {
      "title": "Shuffle an Array",
      "source_file": "Leetcode/leetcode384.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"], [[[1, 2, 3]], [], [], []]",
          "expected_output": "[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[3,1,2],[1,2,3],[1,3,2]]'\nGot (Norm):      '[null,[1,3,2],[1,2,3],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]'\nRaw Got:      '[null, [1, 3, 2], [1, 2, 3], [3, 1, 2]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\n\nclass Solution:\n    def __init__(self, nums):\n        # 儲存原始陣列\n        self.original = list(nums)\n\n    def reset(self):\n        # 重新回到原始順序\n        return self.original\n\n    def shuffle(self):\n        # Fisher‑Yates 洗牌\n        arr = list(self.original)\n        n = len(arr)\n        for i in range(n):\n            j = random.randint(i, n - 1)\n            arr[i], arr[j] = arr[j], arr[i]\n        return arr\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 解析輸入，得到兩個列表：命令與對應參數\n    commands, args_list = ast.literal_eval('(' + data + ')')\n\n    results = []\n    obj = None\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"Solution\":\n            obj = Solution(args[0])\n            results.append(None)  # 建構子不回傳值\n        elif cmd == \"reset\":\n            results.append(obj.reset())\n        elif cmd == \"shuffle\":\n            results.append(obj.shuffle())\n        else:\n            # 若遇到未知命令，直接輸出 None\n            results.append(None)\n\n    # 將結果輸出，None 轉成 null，其他保持原樣\n    output = '[' + ', '.join('null' if r is None else str(r) for r in results) + ']'\n    print(output)",
      "virtual_code": "Thinking...\nWe need to output pseudo-code lines describing algorithm for this task. Must include virtual code steps and explanations. Should be line-by-line.\n\nWe need to design algorithm: shuffle using Fisher-Yates. reset returns original array.\n\nAlso need to store original and current arrays.\n\nWe need to produce code steps like:\n\nStart\n→ Step 1: Store nums as original array // store original\n→ Step 2: Create copy current as nums // current array\n... methods definitions.\n\nWe need to show method signatures maybe: Start, Step, Decision, etc.\n\nWe need to include arrow notation: → Step: ... // explanation.\n\nWe can show separate methods.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 初始化 Solution(nums)\n    → Substep: 保存原始陣列 original = copy(nums) // 以免修改\n    → Substep: 設定 current = copy(nums) // 目前陣列\n→ Step 2: 定義 reset() 方法\n    → Substep: 將 current 設為 original 的複本 // 恢復原始順序\n    → Substep: 回傳 current // 回傳重置後的陣列\n→ Step 3: 定義 shuffle() 方法\n    → Substep: 對 current 執行 Fisher-Yates 隨機排列\n        → Substep: 依次 i 從 0 到 length-1\n            → Substep: 隨機選取 j 在 [i, n-1] // 隨機索引\n            → Substep: 交換 current[i] 與 current[j] // 交換元素\n    → Substep: 回傳 current // 回傳亂序陣列\nEnd // 程式結束\n\nBut we need to use virtual code formatting:\n\nMaybe include decision: not needed.\n\nWe can format:\n\nStart // 程式開始執行\n→ Step 1: Solution(nums) // 初始化\n    → Step 1.1: original ← copy(nums) // 儲存原始陣列\n    → Step 1.2: current ← copy(nums) // 設定目前陣列\n→ Step 2: reset() // 重置方法\n    → Step 2.1: current ← copy(original) // 恢復原始\n    → Step 2.2: return current // 回傳\n→ Step 3: shuffle() // 隨機排列方法\n    → Step 3.1: n ← length(current)\n    → Step 3.2: for i ← 0 to n-1 do // Fisher-Yates\n        → Step 3.2.1: j ← random(i, n-1) // 隨機選擇索引\n        → Step 3.2.2: swap(current[i], current[j]) // 交換\n    → Step 3.3: return current // 回傳亂序陣列\nEnd // 程式結束\n\nBut we must ensure format: \"虛擬碼步驟 [空格] // 解釋/說明\".\n\nWe need to use arrow \"→\" before each step, and indentation.\n\nAlso use \"Start\" \"End\".\n\nLet's craft accordingly.\n\nMake sure to include decisions? maybe not.\n\nWe can include decision for random generation? but not needed.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Solution(nums) // 初始化，傳入原始陣列  \n    → Step 1.1: original ← copy(nums) // 儲存原始陣列，避免被改動  \n    → Step 1.2: current ← copy(nums) // 設定目前陣列為可變副本  \n\n→ Step 2: reset() // 重置方法  \n    → Step 2.1: current ← copy(original) // 重新把 current 置回原始順序  \n    → Step 2.2: return current // 回傳重置後的陣列  \n\n→ Step 3: shuffle() // 隨機排列方法  \n    → Step 3.1: n ← length(current) // 取得陣列長度  \n    → Step 3.2: for i ← 0 to n-1 do // Fisher‑Yates 逐一處理  \n        → Step 3.2.1: j ← random(i, n-1) // 在 [i, n-1] 中隨機選取索引  \n        → Step 3.2.2: swap(current[i], current[j]) // 交換元素以確保均勻分佈  \n    → Step 3.3: return current // 回傳隨機排列後的陣列  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Subsets",
      "source_file": "Leetcode/leetcode78.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nGot (Norm):      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nRaw Got:      '[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]'"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def subsets(self, nums):\n        res = []\n        def backtrack(start, path):\n            res.append(path[:])\n            for i in range(start, len(nums)):\n                path.append(nums[i])\n                backtrack(i + 1, path)\n                path.pop()\n        backtrack(0, [])\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # 讀取輸入，假設格式為 'nums = [1,2,3]' 或僅為 '[1,2,3]'\n    if \"=\" in data:\n        _, expr = data.split(\"=\", 1)\n        nums = eval(expr.strip())\n    else:\n        nums = eval(data)\n    solution = Solution()\n    result = solution.subsets(nums)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for generating all subsets of unique integer array, typical power set. Use recursion or iterative. Provide step-by-step virtual code lines. Use Start, End, Decision, etc. Provide explanation comments after //.\n\nEnsure each line contains code step + space + comment. Use arrow →. Provide indentation for decisions. Use `Yes →`, `No →` for decisions. Use recursion.\n\nLet's design:\n\nStart\n→ Step 1: 初始化結果 list subsets = [] // 存放所有子集\n→ Step 2: 定義遞歸函數 dfs(index, current) // index: 當前元素位置, current: 當前子集\n→ Decision: 如果 index == len(nums)? // 所有元素已處理\n    Yes → Step 3: 複製 current 到 subsets // 將子集加入結果\n    No  → Step 4: Step 5\nStep 4: Step 5: Step 6: ... Wait we need more detailed.\n\nBetter: In recursion:\n- Add current subset to result.\n- For each i from index to len(nums)-1:\n    - current.add(nums[i])\n    - dfs(i+1, current)\n    - current.remove(nums[i]) // backtrack\n\nSo we can produce:\n\nStart\n→ Step 1: nums = [given array] // 取得輸入\n→ Step 2: subsets = [] // 用來儲存所有子集\n→ Step 3: 定義函數 dfs(idx, curr) // idx: 當前索引, curr: 當前子集\n→ Step 4:    subsets.add(copy(curr)) // 把目前子集加入結果\n→ Step 5:    for i from idx to len(nums)-1:\n→ Step 6:        curr.add(nums[i]) // 加入元素\n→ Step 7:        dfs(i+1, curr) // 進一步探索\n→ Step 8:        curr.remove(nums[i]) // 回溯移除\n→ Step 9:  dfs(0, []) // 從頭開始\n→ Step 10: return subsets // 結果\nEnd\n\nBut we must produce each line with arrow format and explanation.\n\nLet's adopt:\n\nStart // 程式開始執行\n→ Step 1: nums = [輸入的唯一整數陣列] // 取得輸入\n→ Step 2: subsets = [] // 用來儲存所有子集\n→ Step 3: 定義函數 dfs(idx, curr) // idx: 當前處理索引, curr: 目前子集\n→ Step 4:    subsets.add(copy(curr)) // 把目前子集加入結果\n→ Step 5:    for i from idx to len(nums)-1: // 循環選取未處理的元素\n→ Step 6:        curr.add(nums[i]) // 加入選中的元素\n→ Step 7:        dfs(i+1, curr) // 進一步遞歸探索\n→ Step 8:        curr.remove(nums[i]) // 回溯移除元素\n→ Step 9:  dfs(0, []) // 從索引0開始\n→ Step 10: return subsets // 回傳所有子集\nEnd // 程式結束\n\nNeed to ensure each line includes \"→\" maybe for nested lines. Use \"→\" before each step. For loops, use indentation with spaces? The example uses indent with spaces.\n\nBetter: Use the arrow at beginning of each line. For lines inside function, still start with \"→\" but we can indent. Provide proper indentation as shown in example: lines under Decision and loop are indented.\n\nSo for function definition lines we can indent.\n\nThus:\n\nStart // 程式開始執行\n→ Step 1: nums = [輸入的唯一整數陣列] // 取得輸入\n→ Step 2: subsets = [] // 用來儲存所有子集\n→ Step 3: 定義函數 dfs(idx, curr) // idx: 當前索引, curr: 目前子集\n    → Step 4: subsets.add(copy(curr)) // 把目前子集加入結果\n    → Step 5: for i from idx to len(nums)-1: // 循環選取未處理的元素\n        → Step 6: curr.add(nums[i]) // 加入選中的元素\n        → Step 7: dfs(i+1, curr) // 進一步遞歸探索\n        → Step 8: curr.remove(nums[i]) // 回溯移除元素\n→ Step 9: dfs(0, []) // 從索引0開始\n→ Step 10: return subsets // 回傳所有子集\nEnd // 程式結束\n\nMake sure each line has code and comment after //. Yes.\n\nNow produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: nums = [輸入的唯一整數陣列] // 取得輸入  \n→ Step 2: subsets = [] // 用來儲存所有子集  \n→ Step 3: 定義函數 dfs(idx, curr) // idx: 當前索引, curr: 目前子集  \n    → Step 4: subsets.add(copy(curr)) // 把目前子集加入結果  \n    → Step 5: for i from idx to len(nums)-1: // 循環選取未處理的元素  \n        → Step 6: curr.add(nums[i]) // 加入選中的元素  \n        → Step 7: dfs(i+1, curr) // 進一步遞歸探索  \n        → Step 8: curr.remove(nums[i]) // 回溯移除元素  \n→ Step 9: dfs(0, []) // 從索引0開始  \n→ Step 10: return subsets // 回傳所有子集  \nEnd // 程式結束"
    },
    {
      "title": "LFU Cache",
      "source_file": "Leetcode/leetcode460.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"LFUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"get\", \"put\", \"get\", \"get\", \"get\"], [[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]",
          "expected_output": "[null, null, null, 1, null, -1, 3, null, -1, 3, 4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,1,null,-1,3,null,-1,3,4]'\nGot (Norm):      '[None,None,None,1,None,-1,3,None,-1,3,4]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, 1, null, -1, 3, null, -1, 3, 4]'\nRaw Got:      '[None, None, None, 1, None, -1, 3, None, -1, 3, 4]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict, OrderedDict\n\nclass LFUCache:\n\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.min_freq = 0\n        self.key_to_val_freq = {}\n        self.freq_to_keys = defaultdict(OrderedDict)\n\n    def _update(self, key):\n        value, freq = self.key_to_val_freq[key]\n        # 移除舊頻率的鍵\n        del self.freq_to_keys[freq][key]\n        if not self.freq_to_keys[freq]:\n            del self.freq_to_keys[freq]\n            if self.min_freq == freq:\n                self.min_freq += 1\n        # 加入新頻率\n        self.freq_to_keys[freq + 1][key] = None\n        self.key_to_val_freq[key] = (value, freq + 1)\n\n    def get(self, key):\n        if key not in self.key_to_val_freq:\n            return -1\n        self._update(key)\n        return self.key_to_val_freq[key][0]\n\n    def put(self, key, value):\n        if self.capacity == 0:\n            return\n        if key in self.key_to_val_freq:\n            # 更新值，頻率自動升一\n            self.key_to_val_freq[key] = (value, self.key_to_val_freq[key][1])\n            self._update(key)\n            return\n        if len(self.key_to_val_freq) >= self.capacity:\n            # 需要 evict 最小頻率且最舊的鍵\n            evict_key, _ = self.freq_to_keys[self.min_freq].popitem(last=False)\n            del self.key_to_val_freq[evict_key]\n            if not self.freq_to_keys[self.min_freq]:\n                del self.freq_to_keys[self.min_freq]\n        # 新增鍵\n        self.key_to_val_freq[key] = (value, 1)\n        self.freq_to_keys[1][key] = None\n        self.min_freq = 1\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    # 將輸入拆分成兩個列表字串\n    split_index = data.find('],')\n    ops_str = data[:split_index + 1]\n    params_str = data[split_index + 2:]\n    ops = ast.literal_eval(ops_str)\n    params = ast.literal_eval(params_str)\n\n    cache_obj = None\n    results = []\n\n    for op, p in zip(ops, params):\n        if op == \"LFUCache\":\n            cache_obj = LFUCache(p[0])\n            results.append(None)\n        elif op == \"put\":\n            cache_obj.put(p[0], p[1])\n            results.append(None)\n        elif op == \"get\":\n            val = cache_obj.get(p[0])\n            results.append(val)\n        else:\n            raise ValueError(f\"Unsupported operation {op}\")\n\n    print(results)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for designing and implementing LFU cache. Each line with arrow, explanation. We need to describe algorithm, not actual code. Should include data structures: hash map key->node, frequency map freq->doubly linked list of nodes, minFreq variable.\n\nWe need to show initialization, get, put, evict. Provide step-by-step pseudo code. Each line with explanation. Use arrows and decision. Use \"Start\" and \"End\". Use \"Decision:\" for if statements.\n\nLet's outline:\n\nStart\n→ Step 1: Define class Node with key, value, freq, prev, next\n→ Step 2: Define class LFUCache with capacity, minFreq, keyNodeMap, freqListMap\n→ Step 3: Constructor(capacity): set capacity, minFreq=0, init maps\n→ Step 4: Helper function addNode(node): add to freqListMap[node.freq]\n→ Step 5: Helper function removeNode(node): remove from its freq list\n→ Step 6: Helper function updateNode(node): remove and then add to freq+1 list; update minFreq if needed\n→ Step 7: get(key):\n    Decision: key in keyNodeMap?\n        Yes: node = map[key]; increment freq via updateNode; return node.value\n        No: return -1\n→ Step 8: put(key, value):\n    Decision: capacity==0? return\n    Decision: key in keyNodeMap?\n        Yes: node.value = value; updateNode(node)\n        No:\n            Decision: size==capacity? // need evict\n                Yes: evictLeastFreq()\n            // create new node with freq=1\n            node = new Node(key, value, 1)\n            addNode(node); map[key]=node; minFreq=1\n→ Step 9: evictLeastFreq():\n    list = freqListMap[minFreq]\n    nodeToRemove = list.tail.prev (LRU)\n    removeNode(nodeToRemove)\n    delete map[nodeToRemove.key]\n→ End\n\nWe need each line as separate line. Use \"→\" for steps. Use \"Decision:\" lines. Provide explanation after //.\n\nLet's craft. Use indentation? They didn't specify indentation but we can indent under Decision.\n\nMake sure each line contains code description then // explanation. Use \"Start\", \"End\". Use arrow only for steps? Use arrow for all lines except Start and End? Format: \"Start // 程式開始執行\" as example. For steps we use \"→\". For Decision we use \"Decision:\" maybe also arrow? Example in spec: \"Decision: 如果數字大於 0?\" So we replicate that. Use \"Yes →\" and \"No →\".\n\nSo produce:\n\nStart // ...\n→ Step 1: 定義 Node 類，包含 key、value、freq、prev、next // 記錄鍵值及使用頻率\n→ Step 2: 定義 LFUCache 類，內部持有 capacity、minFreq、keyNodeMap、freqListMap // 用於管理節點與頻率\n→ Step 3: Constructor(capacity): 初始化容量、minFreq為0、兩個哈希表 // 準備好空資料結構\n→ Step 4: Helper addNode(node): 把 node 加入 freqListMap[node.freq] 的雙向鏈表尾部 // 方便快速移除\n→ Step 5: Helper removeNode(node): 從 node 所在的頻率鏈表中移除 node，若鏈表空則刪除該頻率表 // 釋放空間\n→ Step 6: Helper updateNode(node): \n    removeNode(node)\n    node.freq += 1\n    addNode(node)\n    // 若原來最小頻率鏈表已空，更新 minFreq\n    Decision: node.freq-1 == minFreq AND freqListMap[minFreq] is empty?\n        Yes → minFreq += 1\n→ Step 7: get(key):\n    Decision: key exists in keyNodeMap?\n        Yes → node = keyNodeMap[key]\n               updateNode(node)\n               return node.value\n        No  → return -1\n→ Step 8: put(key, value):\n    Decision: capacity == 0?\n        Yes → return\n    Decision: key exists in keyNodeMap?\n        Yes → node = keyNodeMap[key]\n              node.value = value\n              updateNode(node)\n        No → \n            Decision: keyNodeMap.size == capacity?\n                Yes → evictLeastFreq()\n            // 新增節點\n            node = new Node(key, value, 1)\n            addNode(node)\n            keyNodeMap[key] = node\n            minFreq = 1\n→ Step 9: evictLeastFreq():\n    list = freqListMap[minFreq]\n    nodeToRemove = list.tail.prev // 最舊的 LRU\n    removeNode(nodeToRemove)\n    delete keyNodeMap[nodeToRemove.key]\n→ End // 程式執行結束\n\nBut we need each line separate, with arrow preceding each. Decision lines have \"Decision:\" etc. For nested decisions, indent lines after decision? Example: \"Decision: 如果數字大於 0?\" then \"Yes → ...\" and \"No → ...\". We need to maintain that style.\n\nLet's produce each line:\n\nStart // 程式開始執行\n→ Step 1: 定義 Node 類，包含 key、value、freq、prev、next // 記錄鍵值及使用頻率\n→ Step 2: 定義 LFUCache 類，內部持有 capacity、minFreq、keyNodeMap、freqListMap // 用於管理節點與頻率\n→ Step 3: Constructor(capacity): 初始化容量、minFreq 為 0、兩個哈希表 // 準備好空資料結構\n→ Step 4: Helper addNode(node): 把 node 加入 freqListMap[node.freq] 的雙向鏈表尾部 // 方便快速移除\n→ Step 5: Helper removeNode(node): 從 node 所在的頻率鏈表中移除 node，若鏈表空則刪除該頻率表 // 釋放空間\n→ Step 6: Helper updateNode(node): \n    removeNode(node)\n    node.freq += 1\n    addNode(node)\n    // 若原來最小頻率鏈表已空，更新 minFreq\n    Decision: node.freq-1 == minFreq AND freqListMap[minFreq] 為空?\n        Yes → minFreq += 1\n→ Step 7: get(key):\n    Decision: key 存在於 keyNodeMap?\n        Yes → node = keyNodeMap[key]\n               updateNode(node)\n               return node.value\n        No  → return -1\n→ Step 8: put(key, value):\n    Decision: capacity == 0?\n        Yes → return\n    Decision: key 存在於 keyNodeMap?\n        Yes → node = keyNodeMap[key]\n              node.value = value\n              updateNode(node)\n        No → \n            Decision: keyNodeMap.size == capacity?\n                Yes → evictLeastFreq()\n            // 新增節點\n            node = new Node(key, value, 1)\n            addNode(node)\n            keyNodeMap[key] = node\n            minFreq = 1\n→ Step 9: evictLeastFreq():\n    list = freqListMap[minFreq]\n    nodeToRemove = list.tail.prev // 最舊的 LRU\n    removeNode(nodeToRemove)\n    delete keyNodeMap[nodeToRemove.key]\nEnd // 程式執行結束\n\nNeed each line separated; the lines with multiple sub-steps maybe need to be separate? But spec says each line must contain: virtual code step + explanation. So each line cannot be multi-line. But decisions have nested lines. Should separate each nested action into separate line with arrow.\n\nWe need to restructure such that each line is separate. For helper functions, we might treat each step as separate line: removeNode(node) etc. But they are part of same function. Could combine? But each line can be separate; we can include comments inside same line for sub-steps. Might be okay.\n\nLet's format each step as a single line: Use \"→\" then description. For Decision: show \"Decision:\" line, then \"Yes →\" line, \"No →\" line. For functions we can show as multiple steps. But we might need to indicate function definitions: Step 6: Helper updateNode(node): ... We'll list the function body as multiple lines.\n\nLet's craft final output:\n\n```\nStart // 程式開始執行\n→ Step 1: 定義 Node 類，包含 key、value、freq、prev、next // 記錄鍵值及使用頻率\n→ Step 2: 定義 LFUCache 類，內部持有 capacity、minFreq、keyNodeMap、freqListMap // 用於管理節點與頻率\n→ Step 3: Constructor(capacity): 初始化容量、minFreq 為 0、兩個哈希表 // 準備好空資料結構\n→ Step 4: Helper addNode(node): 把 node 加入 freqListMap[node.freq] 的雙向鏈表尾部 // 方便快速移除\n→ Step 5: Helper removeNode(node): 從 node 所在的頻率鏈表中移除 node，若鏈表空則刪除該頻率表 // 釋放空間\n→ Step 6: Helper updateNode(node): removeNode(node) // 從舊頻率鏈表移除\n→ Step 6: Helper updateNode(node): node.freq += 1 // 增加頻率\n→ Step 6: Helper updateNode(node): addNode(node) // 加入新頻率鏈表\n→ Step 6: Helper updateNode(node): Decision: node.freq-1 == minFreq AND freqListMap[minFreq] 為空?\n    Yes → minFreq += 1 // 更新最小頻率\n→ Step 7: get(key): Decision: key 存在於 keyNodeMap?\n    Yes → node = keyNodeMap[key] // 取得節點\n        → updateNode(node) // 更新頻率\n        → return node.value // 回傳值\n    No  → return -1 // 未找到\n→ Step 8: put(key, value): Decision: capacity == 0?\n    Yes → return // 容量為 0，直接返回\n    No → Decision: key 存在於 keyNodeMap?\n        Yes → node = keyNodeMap[key] // 取得節點\n            → node.value = value // 更新值\n            → updateNode(node) // 更新頻率\n        No → Decision: keyNodeMap.size == capacity?\n            Yes → evictLeastFreq() // 先移除最少頻率\n            No → // 直接插入\n        → node = new Node(key, value, 1) // 新節點頻率為 1\n        → addNode(node) // 加入鏈表\n        → keyNodeMap[key] = node // 记录映射\n        → minFreq = 1 // 重設最小頻率\n→ Step 9: evictLeastFreq(): list = freqListMap[minFreq] // 找到最小頻率的鏈表\n→ Step 9: evictLeastFreq(): nodeToRemove = list.tail.prev // 最舊的 LRU\n→ Step 9: evictLeastFreq(): removeNode(nodeToRemove) // 移除節點\n→ Step 9: evictLeastFreq(): delete keyNodeMap[nodeToRemove.key] // 刪除映射\nEnd // 程式執行結束\n```\n\nCheck format: each line has code step and // explanation. For nested decisions we included indentation maybe but still each line separate. Need to ensure \"Decision:\" lines have proper format: \"Decision: ...\" then sub-lines with \"Yes →\" and \"No →\". The spec example shows indentation for nested actions. So we can indent with spaces before \"Yes →\" etc. In our lines, we need to use indentation; but we may not include leading spaces? It might be okay.\n\nBut we need each line to be one line. For \"Decision: ...\" lines, we cannot have line breaks. But we can have sub-lines with arrow inside same line? But spec example uses multiple lines: \"Decision: 如果數字大於 0?\" then \"Yes → Step 2: 輸出 '正數'\". So we should match that: one line for Decision, next line for Yes, next line for No. Indentation not required but they show indentation. So we should format like:\n\nDecision: key 存在於 keyNodeMap?\n    Yes → node = keyNodeMap[key]\n    No  → return -1\n\nThus we need multiple lines with indentation. That's fine.\n\nBut in our output we included sublines within same line after \"Yes →\". We can separate them into distinct lines. Let's restructure accordingly.\n\nWe'll produce final output as lines as shown, each separate. Let's rewrite fully with correct formatting.\n\nWe'll present:\n\nStart // ...\n→ Step 1: 定義 Node 類，包含 key、value、freq、prev、next // 記錄鍵值及使用頻率\n→ Step 2: 定義 LFUCache 類，內部持有 capacity、minFreq、keyNodeMap、freqListMap // 用於管理節點與頻率\n→ Step 3: Constructor(capacity): 初始化容量、minFreq 為 0、兩個哈希表 // 準備好空資料結構\n→ Step 4: Helper addNode(node): 把 node 加入 freqListMap[node.freq] 的雙向鏈表尾部 // 方便快速移除\n→ Step 5: Helper removeNode(node): 從 node 所在的頻率鏈表中移除 node，若鏈表空則刪除該頻率表 // 釋放空間\n→ Step 6: Helper updateNode(node): removeNode(node) // 從舊頻率鏈表移除\n→ Step 6: Helper updateNode(node): node.freq += 1 // 增加頻率\n→ Step 6: Helper updateNode(node): addNode(node) // 加入新頻率鏈表\n→ Step 6: Helper updateNode(node): Decision: node.freq-1 == minFreq AND freqListMap[minFreq] 為空?\n    Yes → minFreq += 1 // 更新最小頻率\n→ Step 7: get(key): Decision: key 存在於 keyNodeMap?\n    Yes → node = keyNodeMap[key] // 取得節點\n    Yes → updateNode(node) // 更新頻率\n    Yes → return node.value // 回傳值\n    No  → return -1 // 未找到\n→ Step 8: put(key, value): Decision: capacity == 0?\n    Yes → return // 容量為 0，直接返回\n    No  → Decision: key 存在於 keyNodeMap?\n        Yes → node = keyNodeMap[key] // 取得節點\n        Yes → node.value = value // 更新值\n        Yes → updateNode(node) // 更新頻率\n        No  → Decision: keyNodeMap.size == capacity?\n            Yes → evictLeastFreq() // 先移除最少頻率\n            No  → // 直接插入\n        Yes → node = new Node(key, value, 1) // 新節點頻率為 1\n        Yes → addNode(node) // 加入鏈表\n        Yes → keyNodeMap[key] = node // 记录映射\n        Yes → minFreq = 1 // 重設最小頻率\n→ Step 9: evictLeastFreq(): list = freqListMap[minFreq] // 找到最小頻率的鏈表\n→ Step 9: evictLeastFreq(): nodeToRemove = list.tail.prev // 最舊的 LRU\n→ Step 9: evictLeastFreq(): removeNode(nodeToRemove) // 移除節點\n→ Step 9: evictLeastFreq(): delete keyNodeMap[nodeToRemove.key] // 刪除映射\nEnd // 程式執行結束\n\nHowever we used \"Yes →\" multiple times within same decision block; but spec uses only one action per line. But we can keep them separate; but need to maintain decision context. Perhaps we should use multiple Yes/No lines for each action separately. But we can combine multiple actions under same Yes if they are sequential? Example in spec: \"Yes → Step 2: 輸出 '正數'\". Only one action. But we can use multiple actions: \"Yes → node = keyNodeMap[key]\" then \"Yes → updateNode(node)\" etc. This is fine.\n\nBut indentation: We need to maintain proper indentation. We'll produce lines with 4 spaces before Yes lines.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 Node 類，包含 key、value、freq、prev、next // 記錄鍵值及使用頻率  \n→ Step 2: 定義 LFUCache 類，內部持有 capacity、minFreq、keyNodeMap、freqListMap // 用於管理節點與頻率  \n→ Step 3: Constructor(capacity): 初始化容量、minFreq 為 0、兩個哈希表 // 準備好空資料結構  \n→ Step 4: Helper addNode(node): 把 node 加入 freqListMap[node.freq] 的雙向鏈表尾部 // 方便快速移除  \n→ Step 5: Helper removeNode(node): 從 node 所在的頻率鏈表中移除 node，若鏈表空則刪除該頻率表 // 釋放空間  \n→ Step 6: Helper updateNode(node): removeNode(node) // 從舊頻率鏈表移除  \n→ Step 6: Helper updateNode(node): node.freq += 1 // 增加頻率  \n→ Step 6: Helper updateNode(node): addNode(node) // 加入新頻率鏈表  \n→ Step 6: Helper updateNode(node): Decision: node.freq-1 == minFreq AND freqListMap[minFreq] 為空?  \n    Yes → minFreq += 1 // 更新最小頻率  \n→ Step 7: get(key): Decision: key 存在於 keyNodeMap?  \n    Yes → node = keyNodeMap[key] // 取得節點  \n    Yes → updateNode(node) // 更新頻率  \n    Yes → return node.value // 回傳值  \n    No  → return -1 // 未找到  \n→ Step 8: put(key, value): Decision: capacity == 0?  \n    Yes → return // 容量為 0，直接返回  \n    No  → Decision: key 存在於 keyNodeMap?  \n        Yes → node = keyNodeMap[key] // 取得節點  \n        Yes → node.value = value // 更新值  \n        Yes → updateNode(node) // 更新頻率  \n        No  → Decision: keyNodeMap.size == capacity?  \n            Yes → evictLeastFreq() // 先移除最少頻率  \n            No  → // 直接插入  \n        Yes → node = new Node(key, value, 1) // 新節點頻率為 1  \n        Yes → addNode(node) // 加入鏈表  \n        Yes → keyNodeMap[key] = node // 记录映射  \n        Yes → minFreq = 1 // 重設最小頻率  \n→ Step 9: evictLeastFreq(): list = freqListMap[minFreq] // 找到最小頻率的鏈表  \n→ Step 9: evictLeastFreq(): nodeToRemove = list.tail.prev // 最舊的 LRU  \n→ Step 9: evictLeastFreq(): removeNode(nodeToRemove) // 移除節點  \n→ Step 9: evictLeastFreq(): delete keyNodeMap[nodeToRemove.key] // 刪除映射  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick with Weight",
      "source_file": "Leetcode/leetcode528.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"], [[[1,3]],[],[],[],[],[]]",
          "expected_output": "[null,1,1,1,1,0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,1,1,1,1,0]'\nGot (Norm):      '[null,1,1,1,1,1]'\n--- (Raw) ---\nRaw Expected: '[null,1,1,1,1,0]'\nRaw Got:      '[null, 1, 1, 1, 1, 1]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport bisect\n\nclass Solution:\n    \"\"\"\n    Weighted random picker.\n    1. 先計算所有權重的前綜合和 (prefix sum)，用來快速定位區間。\n    2. 隨機產生一個 1~總權重 的整數 target。\n    3. 用 bisect_left 在前綜合和中找到最小的 index 使得 prefix_sum[index] >= target。\n    \"\"\"\n    def __init__(self, w):\n        self.prefix_sum = []\n        total = 0\n        for weight in w:\n            total += weight\n            self.prefix_sum.append(total)\n        self.total = total\n\n    def pickIndex(self):\n        target = random.randint(1, self.total)\n        return bisect.bisect_left(self.prefix_sum, target)\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n    # 將「A, B」包成「[A, B]」再 JSON 解析\n    data = json.loads('[' + raw_input + ']')\n    methods, args_list = data[0], data[1]\n\n    results = []\n    obj = None\n    for i, method in enumerate(methods):\n        args = args_list[i]\n        if method == \"Solution\":\n            # 建構子：先實例化，結果為 null\n            obj = Solution(*args)\n            results.append(None)\n        else:\n            # 其餘方法：直接呼叫\n            method_func = getattr(obj, method)\n            if args:\n                res = method_func(*args)\n            else:\n                res = method_func()\n            results.append(res)\n\n    # 輸出結果，使用 json.dumps 以得到 null、整數等正確格式\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for implementing the pickIndex function with weighted random selection. Use cumulative sums. Provide steps. Use Start, End, Decision. Include arrows. Provide each line with explanation. No real code. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得 w 數組長度 n // 獲得可選擇的索引數量  \n→ Step 2: 建立空列表 prefix // 用於儲存前綜合權重  \n→ Step 3: 將 cumulative = 0 // 初始化累積權重  \n→ Decision: 迭代 i 從 0 到 n-1? // 準備計算前綜合權重  \n  Yes → Step 4: cumulative = cumulative + w[i] // 加總至當前索引的權重  \n   → Step 5: prefix[i] = cumulative // 儲存此索引的前綜合權重  \n   → Step 6: 回到 Decision 迭代 i 從 0 到 n-1? // 依序處理所有索引  \n  No → Step 7: totalWeight = cumulative // 最後一次累積即總權重  \n→ Step 8: 產生隨機數 r，範圍在 (0, totalWeight] // 生成一個隨機點  \n→ Decision: 找到最小的 index i 使得 prefix[i] ≥ r? // 尋找對應區間  \n  Yes → Step 9: 返回 i // 成功找到符合條件的索引  \n  No → Step 10: 回到 Decision 找 index // 若未找到則重試（理論上不會發生）  \nEnd // 程式執行結束"
    },
    {
      "title": "H-Index II",
      "source_file": "Leetcode/leetcode275.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "citations = [0,1,3,5,6]",
          "expected_output": "3",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '3'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: '3'\nRaw Got:      '1'"
        },
        {
          "example_index": 1,
          "input": "citations = [1,2,100]",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '1'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def hIndex(self, citations):\n        \"\"\"計算 h-index，時間複雜度 O(log n)。\"\"\"\n        n = len(citations)\n        left, right = 0, n - 1\n        while left <= right:\n            mid = (left + right) // 2\n            # 需要至少 (n - mid) 篇論文有至少 (n - mid) 次引用\n            if citations[mid] >= n - mid:\n                # 找到符合條件的索引，嘗試尋找更大的 h\n                left = mid + 1\n                answer = n - mid\n            else:\n                # 符合條件的索引太大，向左縮小搜尋範圍\n                right = mid - 1\n        # 如果沒有符合條件，答案為 0；否則為上一次更新的 answer\n        return answer if 'answer' in locals() else 0\n\ndef parse_citations(input_str: str):\n    \"\"\"從輸入字串中解析 citations 列表。\"\"\"\n    try:\n        # 只保留 '[' 到 ']' 之間的內容，避免 eval 執行多餘指令\n        start = input_str.index('[')\n        end = input_str.rindex(']') + 1\n        list_str = input_str[start:end]\n        return ast.literal_eval(list_str)\n    except (ValueError, SyntaxError):\n        # 若解析失敗，回傳空列表\n        return []\n\nif __name__ == \"__main__\":\n    # 讀取整個 stdin（可能包含換行或空白）\n    raw_input = sys.stdin.read()\n    citations = parse_citations(raw_input)\n    solution = Solution()\n    result = solution.hIndex(citations)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code (pseudocode) line by line with explanations, for the h-index problem sorted array. We need log time algorithm: binary search for h-index. The array sorted ascending. Find largest i such that citations[i] >= n-i (where n=len). Equivalent to find the first index where citations[i] >= n-i, then h = n-i. Or using binary search for condition citations[mid] >= n-mid. Provide pseudocode with steps. We must output each line as `虛擬碼步驟 // 解釋`. Use Start, End, Decision. Provide each step. Probably define n, low, high, answer = 0, then while low <= high. Use decision. Then compute h. After loop output h. Let's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義 n ← 證照陣列長度 // 取得論文總數\n→ Step 2: 初始化 low ← 0, high ← n - 1, answer ← 0 // 設定二分搜尋範圍與預設答案\n→ Decision: low <= high? // 是否仍有搜尋範圍\n    Yes → Step 3: mid ← (low + high) // 2 // 計算中間索引\n    → Step 4: 需要判斷的條件計算: citations[mid] >= n - mid? // 判斷 mid 位置的引用是否足以成為 h\n    → Decision: citations[mid] >= n - mid? // 符合條件則可能為 h\n        Yes → Step 5: answer ← n - mid // 更新答案為目前符合條件的 h\n        → Step 6: high ← mid - 1 // 尋找更大的 h，縮小上界\n        No  → Step 7: low ← mid + 1 // 未符合條件，需向右移動下界\n    → Decision: low <= high? // 重新檢查是否還有搜尋範圍\n        Yes → 回到 Step 3\n        No  → Step 8: 輸出 answer // 輸出最終計算得到的 h-index\nEnd // 程式執行結束"
    }
  ]
}