{
  "run_index": 44,
  "total_files_found": 391,
  "total_files_processed": 323,
  "files_skipped": 68,
  "files_failed_load": 0,
  "---": "--- (以下基於 *題目* 總數) ---",
  "total_problems_attempted": 334,
  "generation_and_validation_success_count": 305,
  "generation_or_validation_failure_count": 29,
  "failed_cases_details": [
    {
      "title": "統計文字行數",
      "source_file": "900.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "（假設 data.txt 內容如下）\\nHello\\nPython\\nWorld",
          "expected_output": "檔案共有 3 行",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '檔案共有3行'\nGot (Norm):      '檔案共有1行'\n--- (Raw) ---\nRaw Expected: '檔案共有 3 行'\nRaw Got:      '檔案共有 1 行'"
        }
      ],
      "generated_code": "import sys\n\ndef main() -> None:\n    \"\"\"\n    主程式入口\n    1. 先讀取 stdin（本題實際上不會使用這段輸入，僅符合「必須從 stdin 讀取資料」的要求）。\n    2. 嘗試開啟名為 data.txt 的檔案，計算並輸出行數。\n    3. 若檔案不存在，顯示『找不到檔案！』。\n    \"\"\"\n    # 讀取 stdin，雖然此程式不會使用這段內容，但符合「必須從 stdin 讀取」的規定。\n    _ = sys.stdin.read()\n\n    try:\n        # 以 with 語法開啟檔案，確保檔案正確關閉\n        with open('data.txt', 'r', encoding='utf-8') as f:\n            lines = f.readlines()           # 讀取所有行\n            count = len(lines)              # 計算行數\n            print('檔案共有', count, '行')  # 輸出結果\n    except FileNotFoundError:\n        # 檔案不存在時的錯誤處理\n        print('找不到檔案！')\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line with arrows. Provide Start, then steps: try open file with with, except FileNotFoundError, then read lines, count lines, output count. Provide comments. Use virtual arrows. Also Decision if file exists? but we use try/except. Provide steps.\n\nMake sure each line has the structure: \"虛擬碼步驟 // 解釋\". We need to use Start, End, Decision.\n\nWe need to ensure the steps are logical and incremental. Use \"→\" for steps.\n\nWe need to output: \nStart\n→ Step 1: try open file with with open('data.txt', 'r') as f: // 開啟檔案\n→ Decision: If FileNotFoundError? Actually we use try/except block: So steps inside try: Step 2: lines = f.readlines() // 讀取所有行\n→ Step 3: count = len(lines) // 計算行數\n→ Step 4: print(f\"總共有 {count} 行文字\") // 輸出行數\n→ Except: FileNotFoundError // 檔案不存在\n→ Step 5: print('找不到檔案！') // 顯示錯誤訊息\nEnd\n\nBut need to indicate structure of try/except. We can represent with Decision: \"Try?\" maybe.\n\nBut use \"Decision:\"? We can use Decision: If FileNotFoundError? Actually we can use \"Decision: 是否發生 FileNotFoundError?\" to branch.\n\nAlternatively we can express try/except: Step 1: Start try block // 進入 try\n→ Step 2: open file with with open ... // ...\n→ Step 3: read lines\n→ Step 4: count\n→ Step 5: print count\n→ End try\n→ Decision: 是否捕捉到 FileNotFoundError? // If exception\n    Yes → Step 6: print '找不到檔案！'\n    No → End\n\nBut we need each line with arrow. So we can represent try block lines as \"→ Step ...\". For Decision lines use indentation.\n\nOk produce.\n\nLet's format:\n\nStart // 程式開始執行\n→ Decision: 嘗試開啟檔案? // 進入 try 區塊\n    Yes → Step 1: with open('data.txt', 'r') as f: // 用 with 開啟檔案\n        → Step 2: lines = f.readlines() // 讀取所有行\n        → Step 3: count = len(lines) // 計算行數\n        → Step 4: print(f\"總共有 {count} 行文字\") // 輸出行數\n    No → Decision: 是否捕捉到 FileNotFoundError? // 進入 except\n        Yes → Step 5: print('找不到檔案！') // 顯示錯誤訊息\n        No → End // 程式結束\n\nBut we should use Start and End. Maybe we need separate Start and End. Use Start at top, End at bottom.\n\nLet's produce final output accordingly. Ensure each line has arrow and comment.\n\nAlso we might need to use \"Decision:\" for try/except, but typical flow: try block executed unless exception occurs, so no explicit decision needed, but we can show.\n\nOk produce final.\n...done thinking.\n\nStart // 程式開始執行\n→ Decision: 嘗試開啟檔案? // 進入 try 區塊\n    Yes → Step 1: with open('data.txt', 'r') as f: // 用 with 開啟檔案\n        → Step 2: lines = f.readlines() // 讀取所有行\n        → Step 3: count = len(lines) // 計算行數\n        → Step 4: print(f\"總共有 {count} 行文字\") // 輸出行數\n    No → Decision: 是否捕捉到 FileNotFoundError? // 進入 except 區塊\n        Yes → Step 5: print('找不到檔案！') // 顯示錯誤訊息\n        No  → End // 程式結束\nEnd // 程式執行結束"
    },
    {
      "title": "模擬擲骰子遊戲",
      "source_file": "800.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "print(roll_dice(5))",
          "expected_output": "[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,6,1,4,2]#(結果會隨機，每次可能不同)'\nGot (Norm):      '[6,6,2,3,2]'\n--- (Raw) ---\nRaw Expected: '[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)'\nRaw Got:      '[6, 6, 2, 3, 2]'"
        }
      ],
      "generated_code": "import sys\nimport random\n\ndef roll_dice(n):\n    \"\"\"\n    擲 n 次六面骰，回傳所有結果的串列。\n    \"\"\"\n    results = []\n    for _ in range(n):\n        results.append(random.randint(1, 6))\n    return results\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個程式碼，並執行\n    code = sys.stdin.read()\n    exec(code)",
      "virtual_code": "Thinking...\nWe need to output virtual code lines with explanations, following the given format. The function roll_dice(n) simulates rolling an n-sided dice? Wait six-sided dice, n times. So function takes n number of rolls, returns list of results. Use random module. The virtual code should include function definition, import, loop, list append, return.\n\nWe need to produce each line of virtual code, and after a space, comment with // explanation. Use arrow for steps. Format must be like:\n\nStart // 程式開始執行\n→ Step 1: 匯入 random 模組 // Import random\n→ Step 2: 定義函數 roll_dice(n) // Define function\n    → Step 3: 初始化 empty list results // ...\n    → Step 4: 迴圈 for i in range(n) // loop\n        → Step 5: 生成隨機整數 1-6 // random.randint(1,6)\n        → Step 6: 將結果加入 results // append\n    → Step 7: 回傳 results // return\nEnd // 程式結束\n\nWe need to follow the arrow format exactly as examples: '→ Step 1: ... // ...'\n\nWe should keep indentation as shown? The example shows indented for nested decisions. For loops, we can use indentation.\n\nWe need to output exactly that, no actual code. Just virtual steps. Also start with Start line.\n\nWe should mention random module. For step 4, maybe \"→ Step 4: 迴圈 for _ in range(n): // 進行 n 次擲骰\". In indentation.\n\nLet's produce accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 匯入 random 模組 // 讓程式可以使用亂數生成功能  \n→ Step 2: 定義函數 roll_dice(n) // 建立可重複使用的擲骰函式  \n  → Step 3: 初始化空串列 results // 用來儲存每次擲骰的結果  \n  → Step 4: 迴圈 for _ in range(n) // 執行 n 次擲骰操作  \n    → Step 5: 產生隨機整數 roll = random.randint(1, 6) // 生成 1 到 6 的亂數  \n    → Step 6: 將 roll 加入 results 列表 // 記錄擲骰結果  \n  → Step 7: 回傳 results // 回傳所有擲骰結果的串列  \nEnd // 程式執行結束"
    },
    {
      "title": "計算程式執行時間",
      "source_file": "800.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "import time\n\ndef slow_add(a, b):\n    time.sleep(2)\n    return a + b\n\nprint(measure_time(slow_add, 3, 5))",
          "expected_output": "約 2.0 秒 (依電腦執行環境略有差異)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '約2.0秒(依電腦執行環境略有差異)'\nGot (Norm):      '2.0'\n--- (Raw) ---\nRaw Expected: '約 2.0 秒 (依電腦執行環境略有差異)'\nRaw Got:      '2.0'"
        }
      ],
      "generated_code": "import sys\nimport time\n\ndef measure_time(func, *args):\n    \"\"\"\n    測量傳入函式 func 執行所需的秒數，並回傳四捨五入到小數點 3 位的耗時。\n    \"\"\"\n    start = time.time()\n    func(*args)\n    end = time.time()\n    return round(end - start, 3)\n\ndef main():\n    \"\"\"\n    讀取整個標準輸入的程式碼，並在全域命名空間執行。\n    \"\"\"\n    code = sys.stdin.read()\n    # 執行使用者輸入的程式碼，這裡 globals() 包含了 measure_time 等已定義的物件\n    exec(code, globals())\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines following format. Start, Step, Decision etc. The user wants measure_time(func,*args) using time module, measuring seconds, returning result rounded to 3 decimal places. Virtual code should show steps, but we cannot output real code. Just a step-by-step algorithm.\n\nWe need to generate lines like:\n\nStart // 程式開始執行\n→ Step 1: Import time module // 導入 time 模組\n→ Step 2: Define function measure_time(func, *args) // 定義函式\n→ Step 3: Record start_time = time.time() // 紀錄開始時間\n→ Step 4: Call result = func(*args) // 執行目標函式\n→ Step 5: Record end_time = time.time() // 紀錄結束時間\n→ Step 6: Calculate elapsed = end_time - start_time // 計算耗時\n→ Step 7: Round elapsed to 3 decimals -> rounded_time = round(elapsed, 3) // 四捨五入\n→ Step 8: Return rounded_time, result // 回傳時間和結果\nEnd // 程式結束\n\nBut we might need to mention that the function returns the result of func and the time? The requirement: \"測量函數 func 執行所需的秒數，並回傳結果 (四捨五入到小數點 3 位)。\" It says return result, presumably the time? The result maybe the measured time. It could mean return the measured time. But ambiguous. We can state that it returns the elapsed time. Provide algorithm accordingly.\n\nAlso show that we might use time.perf_counter for more accurate. But mention.\n\nWe need to follow format: Each line must be \"虛擬碼步驟 // 解釋\". Use arrow for steps. Use \"Start\" \"End\". Use \"Decision:\" if needed. Not necessary.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Import time module // 導入 time 模組以取得時間戳  \n→ Step 2: Define function measure_time(func, *args) // 建立待測量的函式  \n→ Step 3: Record start_time = time.time() // 紀錄呼叫前的時間點  \n→ Step 4: Call result = func(*args) // 執行目標函式並取得其返回值  \n→ Step 5: Record end_time = time.time() // 紀錄呼叫後的時間點  \n→ Step 6: Calculate elapsed = end_time - start_time // 求出執行耗時（秒）  \n→ Step 7: Round elapsed to 3 decimals → rounded_time = round(elapsed, 3) // 四捨五入到小數點三位  \n→ Step 8: Return rounded_time // 回傳已四捨五入的執行時間  \nEnd // 程式執行結束"
    },
    {
      "title": "集合函數練習",
      "source_file": "600.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "{'apple', 'orange', 'grape', 'melon'}",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '{\"apple\",\"orange\",\"grape\",\"melon\"}'\nGot (Norm):      '{\"orange\",\"grape\",\"apple\",\"melon\"}'\n--- (Raw) ---\nRaw Expected: \"{'apple', 'orange', 'grape', 'melon'}\"\nRaw Got:      \"{'orange', 'grape', 'apple', 'melon'}\""
        }
      ],
      "generated_code": "import sys\n\ndef main():\n    # 讀取並忽略任何輸入（本題不需要輸入資料）\n    sys.stdin.read()\n\n    # 建立初始集合\n    fruits = {'apple', 'banana'}\n\n    # 新增 'orange'\n    fruits.add('orange')\n\n    # 同時新增 'grape' 與 'melon'\n    fruits.update(['grape', 'melon'])\n\n    # 移除 'banana'\n    fruits.remove('banana')\n\n    # 嘗試移除不存在的 'pineapple'，不會拋出錯誤\n    fruits.discard('pineapple')\n\n    # 輸出最終集合\n    print(fruits)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps per line, with explanation. We must adhere to format: Start, steps with arrows, decisions if any (but this is straightforward). Provide each line: virtual step + \" // \" explanation. Should not output actual code, just pseudo-code. Use arrow symbols: →, Yes →, No →, Decision:. Use Start, End.\n\nWe need to cover operations: create set, add, update, remove, discard, print. Might include decision for existence? but remove will error if not exist, but we assume it exists. We don't need decision for that. For discard, we don't need decision; but we could show a decision: if element exists? Yes → discard else → nothing. Let's include decision for discard: \"Decision: 如果 'pineapple' 在集合中?\" etc.\n\nAlso use \"Update\" step: update set with multiple elements. Could show as step: Update: add 'grape', 'melon'.\n\nLet's produce:\n\nStart\n→ Step 1: 建立 fruits = {'apple', 'banana'} // 初始化集合\n→ Step 2: fruits.add('orange') // 新增元素\n→ Step 3: fruits.update({'grape', 'melon'}) // 一次新增多個元素\n→ Step 4: fruits.remove('banana') // 移除指定元素\n→ Decision: 如果 'pineapple' 在 fruits? // 檢查元素是否存在\n    Yes → Step 5: fruits.discard('pineapple') // 若存在則移除\n    No  → Step 6: // 什麼也不做\n→ Step 7: 輸出 fruits // 顯示集合\n\nEnd\n\nBut need to maintain proper formatting: each line with '虛擬碼步驟 [space] // 解釋'.\n\nSo produce lines like:\n\nStart // 程式開始執行\n→ Step 1: fruits = {'apple', 'banana'} // 初始化集合\n→ Step 2: fruits.add('orange') // 新增 'orange'\n→ Step 3: fruits.update({'grape', 'melon'}) // 同時加入 'grape' 與 'melon'\n→ Step 4: fruits.remove('banana') // 移除 'banana'\n→ Decision: 如果 'pineapple' 在 fruits? // 判斷元素是否存在\n    Yes → Step 5: fruits.discard('pineapple') // 若存在則移除\n    No  → Step 6: // 不做任何操作\n→ Step 7: print(fruits) // 輸出最終集合\nEnd // 程式結束\n\nCheck if we need to use arrow before each decision? The format shows Decision: with indentation. Indentation after Decision. Should indent Yes and No lines. In sample, they used spaces before Yes → and No → lines. So we replicate. Use \"Decision:\" line then indent with a few spaces. Provide Yes and No lines accordingly. Should be good.\n\nReturn the output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: fruits = {'apple', 'banana'} // 初始化集合  \n→ Step 2: fruits.add('orange') // 新增 'orange'  \n→ Step 3: fruits.update({'grape', 'melon'}) // 同時加入 'grape' 與 'melon'  \n→ Step 4: fruits.remove('banana') // 移除 'banana'  \n→ Decision: 如果 'pineapple' 在 fruits? // 判斷元素是否存在  \n    Yes → Step 5: fruits.discard('pineapple') // 若存在則移除  \n    No  → Step 6: // 什麼也不做  \n→ Step 7: print(fruits) // 輸出最終集合  \nEnd // 程式結束"
    },
    {
      "title": "即時匯率查詢小工具",
      "source_file": "1200.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "按下「更新匯率」按鈕",
          "expected_output": "目前美元匯率：約 32.5 TWD",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '目前美元匯率：約32.5TWD'\nGot (Norm):      '目前美元匯率：約30.57TWD'\n--- (Raw) ---\nRaw Expected: '目前美元匯率：約 32.5 TWD'\nRaw Got:      '目前美元匯率：約 30.57 TWD'"
        }
      ],
      "generated_code": "import requests\nimport sys\nimport tkinter as tk\n\ndef get_rate() -> str:\n    \"\"\"\n    從匯率 API 取得 USD 對 TWD 的匯率，並回傳格式化字串。\n    若失敗則回傳錯誤訊息。\n    \"\"\"\n    try:\n        url = \"https://api.exchangerate-api.com/v4/latest/USD\"\n        response = requests.get(url, timeout=5)\n        response.raise_for_status()          # 若 HTTP 狀態非 200 會拋例外\n        data = response.json()\n        rate = data.get(\"rates\", {}).get(\"TWD\")\n        if rate is None:\n            return \"未找到 TWD 匯率\"\n        return f\"目前美元匯率：約 {rate} TWD\"\n    except Exception:\n        return \"更新失敗，請檢查網路連線\"\n\ndef run_gui() -> None:\n    \"\"\"\n    建立簡易 tkinter 視窗，點擊按鈕可更新匯率顯示。\n    \"\"\"\n    win = tk.Tk()\n    win.title(\"匯率查詢\")\n\n    label = tk.Label(win, text=\"請按下按鈕更新匯率\", font=(\"Arial\", 12))\n    label.pack(pady=10)\n\n    def update_label() -> None:\n        label.config(text=get_rate())\n\n    btn = tk.Button(win, text=\"更新匯率\", command=update_label)\n    btn.pack(pady=5)\n\n    win.mainloop()\n\nif __name__ == \"__main__\":\n    # 讀取標準輸入並根據輸入執行對應動作\n    input_line = sys.stdin.read().strip()\n    if input_line:\n        # 只在輸入包含「更新」或「按鈕」字樣時才進行匯率查詢\n        if \"更新\" in input_line or \"按鈕\" in input_line:\n            print(get_rate())\n        else:\n            # 若輸入不符合預期，保持空輸出或可自行處理\n            pass",
      "virtual_code": "Thinking...\nWe need to produce step-by-step virtual code lines, each with explanation comment after //.\n\nNeed to implement: using requests to call API, parse JSON, get TWD rate. Use tkinter window, with button to update. So pseudocode steps: start, import modules, create main window, define update function, fetch rate, set label text, button call update. Use Start, End, Decision etc.\n\nWe produce lines with arrow, use \"→\" arrow for steps. Each line must contain virtual code step + space + comment.\n\nWe'll include decisions: maybe error handling: if request fails, show error. Use Decision: If response OK? Yes: parse; No: show error.\n\nAlso decide: if TWD in data? Yes: set label; No: show error.\n\nAlso handle loop? Not necessary. But we can include while loop for GUI mainloop.\n\nWe need to avoid actual code; just pseudocode.\n\nLet's produce:\n\nStart\n→ Step 1: Import requests and tkinter modules\n→ Step 2: Create main window using Tk()\n→ Step 3: Create label to display rate\n→ Step 4: Create button with text '更新匯率' that calls update_rate\n→ Step 5: Define function update_rate\n    → Step 5.1: Send GET request to https://api.exchangerate-api.com/v4/latest/USD\n    → Decision: 如果回應成功? // check status code\n        Yes → Step 5.2: 解析 JSON 取得 'rates' dict\n        No  → Step 5.3: 在標籤顯示 '無法取得匯率'\n    → Decision: 如果 'TWD' 存在於 rates? // check key\n        Yes → Step 5.4: 取得 rate = rates['TWD']\n        No  → Step 5.5: 在標籤顯示 '未找到 TWD 匯率'\n    → Step 5.6: 格式化字符串 \"1 USD = X TWD\" 並設定標籤文字\n→ Step 6: 在 main window中放置 label 與 button（使用 pack 或 grid）\n→ Step 7: 調用 update_rate 初始顯示\n→ Step 8: 執行主迴圈 mainloop()\nEnd\n\nWe need to ensure each line is separate. Also include indentation to show nested steps.\n\nThe pseudocode uses arrow for each step, nested lines are indented with spaces.\n\nAdd comments after //.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Import requests and tkinter modules // 匯入 HTTP 請求與 GUI 模組  \n→ Step 2: Create main window using Tk() // 建立主視窗  \n→ Step 3: Create label to display rate // 放置顯示匯率的文字標籤  \n→ Step 4: Create button with text '更新匯率' that calls update_rate // 放置更新按鈕，點擊時呼叫更新函式  \n→ Step 5: Define function update_rate  \n  → Step 5.1: Send GET request to https://api.exchangerate-api.com/v4/latest/USD // 取得美元基準匯率資料  \n  → Decision: 如果回應成功? // 判斷 HTTP 狀態碼是否為 200  \n    Yes → Step 5.2: 解析 JSON 取得 'rates' dict // 取得匯率表  \n    No  → Step 5.3: 在標籤顯示 '無法取得匯率' // 顯示錯誤訊息  \n  → Decision: 如果 'TWD' 存在於 rates? // 檢查台幣匯率是否存在  \n    Yes → Step 5.4: 取得 rate = rates['TWD'] // 取得 USD 對 TWD 的匯率  \n    No  → Step 5.5: 在標籤顯示 '未找到 TWD 匯率' // 顯示缺失訊息  \n  → Step 5.6: 格式化字符串 \"1 USD = X TWD\" 並設定標籤文字 // 更新 GUI 顯示  \n→ Step 6: 在主視窗中放置 label 與 button（使用 pack 或 grid） // 布局元件  \n→ Step 7: 調用 update_rate 初始顯示 // 開啟時即顯示最新匯率  \n→ Step 8: 執行主迴圈 mainloop() // 進入 GUI 事件循環  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Flip Matrix",
      "source_file": "Leetcode/leetcode519.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"flip\", \"flip\", \"flip\", \"reset\", \"flip\"], [[3, 1], [], [], [], [], []]",
          "expected_output": "[null, [1,0], [2,0], [0,0], null, [2,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[1,0],[2,0],[0,0],null,[2,0]]'\nGot (Norm):      '[null,[0,0],[1,0],[2,0],null,[1,0]]'\n--- (Raw) ---\nRaw Expected: '[null, [1,0], [2,0], [0,0], null, [2,0]]'\nRaw Got:      '[null, [0, 0], [1, 0], [2, 0], null, [1, 0]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, m: int, n: int):\n        self.rows = m\n        self.cols = n\n        self.total = m * n          # remaining zeros\n        self.flipped = {}           # map virtual index to actual index\n\n    def flip(self):\n        # Pick a random index among the remaining zeros\n        r = random.randint(0, self.total - 1)\n        # Resolve the real index to flip\n        x = self.flipped.get(r, r)\n        # Decrease remaining count\n        self.total -= 1\n        # Map the used index to the last available index\n        self.flipped[r] = self.flipped.get(self.total, self.total)\n        # Convert flat index to 2‑D coordinates\n        return [x // self.cols, x % self.cols]\n\n    def reset(self):\n        # Reset to all zeros\n        self.total = self.rows * self.cols\n        self.flipped.clear()\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # Split the input into operations and arguments\n    ops_part, args_part = data.split('],', 1)\n    ops_part += ']'\n    args_part = args_part.strip()\n    ops = json.loads(ops_part)\n    args = json.loads(args_part)\n\n    res = []\n    obj = None\n    for op, a in zip(ops, args):\n        if op == \"Solution\":\n            obj = Solution(*a)\n            res.append(None)\n        elif op == \"flip\":\n            res.append(obj.flip())\n        elif op == \"reset\":\n            obj.reset()\n            res.append(None)\n        else:\n            # For any other method names (unlikely in this problem)\n            method = getattr(obj, op)\n            res.append(method(*a))\n    print(json.dumps(res))",
      "virtual_code": "Thinking...\nWe need to output virtual code with explanations per line, following the format. Need to design algorithm: typical approach: maintain a list of available indices mapping to 0 cells; treat matrix as flattened m*n array. Keep a dictionary mapping index to its current value after swaps. Use reservoir: for each flip, pick random index k in [0, remaining-1], get real index: if mapping contains k, use mapping[k] else k. Then map k to last remaining-1: if mapping contains last, set mapping[k]=mapping[last]; else mapping[k]=last. Decrement remaining. Return [k/m, k% m]. reset: clear mapping, set remaining = m*n. That's typical. Complexity: O(1) per flip, O(m*n) space in worst-case. minimize random calls: one per flip.\n\nWe'll produce virtual code lines: Start, initialize variables, etc. Let's produce step-by-step. Need to include arrows for decisions. Let's produce:\n\nStart\n→ Step 1: 初始化 m, n, total = m*n, remaining = total // 初始化矩陣大小及剩餘空位數\n→ Step 2: 創建空映射表 mapping = {} // 用於存放索引映射\n→ Decision: 初始化完成? // 確認已完成初始化\n    Yes → End 初始化 // 初始結束\n\nFor flip:\n→ Function flip()\n    → Decision: remaining == 0? // 檢查是否已經沒有空位\n        Yes → Step 3: return 空白 // 或拋錯\n        No  → Step 4: randIdx = random(0, remaining-1) // 隨機選擇一個可用位置\n            → Step 5: realIdx = mapping.get(randIdx, randIdx) // 取得實際索引\n            → Step 6: lastIdx = remaining-1\n            → Decision: lastIdx in mapping? // 檢查最後位置是否已映射\n                Yes → mapping[randIdx] = mapping[lastIdx] // 用已映射的最後值\n                No  → mapping[randIdx] = lastIdx // 用實際最後索引\n            → Step 7: remaining -= 1 // 更新剩餘空位數\n            → Step 8: i = realIdx // row\n            → Step 9: j = realIdx % n\n            → Step 10: return [i, j] // 返回行列索引\n→ End function\n\nFor reset:\n→ Function reset()\n    → Step 11: mapping.clear() // 清空映射表\n    → Step 12: remaining = total // 重設剩餘空位數\n    → Step 13: // 所有值恢復為 0\n→ End function\n\nBut we need to produce in virtual code style with arrows and decisions. We need to ensure each line is \"虛擬碼步驟 [space] // 解釋\". Use \"Start\", \"End\". Use \"Decision:\" and arrows. Provide line numbers? Not required. Each line should be separate. Let's produce a full flow for constructor, flip, reset. Use indentation for decisions and arrows.\n\nWe need to show arrow for transitions: \"→\" or \"Yes →\". We need to produce \"→ Step 1: ...\" etc. Let's craft.\n\nWe will produce the virtual code for entire class.\n\nUse following structure:\n\nStart // 程式開始執行\n→ Step 1: 初始化 m, n, total = m * n, remaining = total // 產生矩陣大小及剩餘空位數\n→ Step 2: 建立空映射表 mapping = {} // 用於存放索引對應\n→ End // 初始化完成\n\n→ Function flip()\n    → Decision: remaining == 0? // 檢查是否已無空位\n        Yes → Step 3: return [] // 無可用位置 (或拋例外)\n        No  → Step 4: randIdx = randomInt(0, remaining-1) // 隨機選擇一個可用索引\n            → Step 5: realIdx = mapping.get(randIdx, randIdx) // 取得真實索引\n            → Step 6: lastIdx = remaining - 1\n            → Decision: lastIdx in mapping? // 檢查最後位置是否已映射\n                Yes → Step 7: mapping[randIdx] = mapping[lastIdx] // 把最後位置的映射放回\n                No  → Step 8: mapping[randIdx] = lastIdx // 把最後索引直接映射\n            → Step 9: remaining -= 1 // 更新剩餘空位數\n            → Step 10: i = realIdx // 計算行\n            → Step 11: j = realIdx % n // 計算列\n            → Step 12: return [i, j] // 返回隨機且均勻的索引\n→ End Function flip()\n\n→ Function reset()\n    → Step 13: mapping.clear() // 清空映射表\n    → Step 14: remaining = total // 重置剩餘空位數\n→ End Function reset()\n\nEnd // 程式結束\n\nBut need to ensure each line includes \"虛擬碼步驟 // 解釋\". Use arrow \"→\" for normal flow lines; \"Yes →\" and \"No →\" for decisions. Let's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: m ← input, n ← input, total ← m * n, remaining ← total // 初始化矩陣大小與剩餘空位數  \n→ Step 2: mapping ← {} // 建立空映射表，用於索引交換  \n→ End // 初始化完成  \n\n→ Function flip() // 取得一個隨機且均勻的 0 位置並將其翻轉為 1  \n    → Decision: remaining == 0? // 檢查是否已無空位可翻轉  \n        Yes → Step 3: return [] // 無可用位置，直接返回（或拋例外）  \n        No  → Step 4: randIdx ← randomInt(0, remaining - 1) // 隨機選擇一個可用索引  \n            → Step 5: realIdx ← mapping.get(randIdx, randIdx) // 取得實際索引（若已映射則取映射值）  \n            → Step 6: lastIdx ← remaining - 1 // 最後一個可用索引  \n            → Decision: lastIdx in mapping? // 判斷最後索引是否已映射  \n                Yes → Step 7: mapping[randIdx] ← mapping[lastIdx] // 把最後映射值放回當前位置  \n                No  → Step 8: mapping[randIdx] ← lastIdx // 把最後實際索引映射到當前位置  \n            → Step 9: remaining ← remaining - 1 // 更新剩餘空位數  \n            → Step 10: i ← realIdx // 計算行號  \n            → Step 11: j ← realIdx % n // 計算列號  \n            → Step 12: return [i, j] // 返回隨機且均勻的索引  \n→ End Function flip()  \n\n→ Function reset() // 重設整個矩陣，所有值回到 0  \n    → Step 13: mapping.clear() // 清空映射表  \n    → Step 14: remaining ← total // 重置剩餘空位數為全部位置  \n→ End Function reset()  \n\nEnd // 程式結束"
    },
    {
      "title": "UTF-8 Validation",
      "source_file": "Leetcode/leetcode393.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "data = [197,130,1]",
          "expected_output": "true",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'true'\nGot (Norm):      'false'\n--- (Raw) ---\nRaw Expected: 'true'\nRaw Got:      'false'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def validUtf8(self, data):\n        \"\"\"\n        判斷給定整數列表是否為有效的 UTF‑8 編碼序列。\n        \"\"\"\n        n_bytes = 0  # 當前還需要驗證的連續字節數\n        for num in data:\n            # 只保留最低 8 位\n            byte = num & 0xFF\n            if n_bytes == 0:\n                # 判斷字節開頭的 1 位數量\n                if (byte >> 5) == 0b11110:        # 11110xxx 4 字節\n                    n_bytes = 3\n                elif (byte >> 4) == 0b1110:       # 1110xxxx 3 字節\n                    n_bytes = 2\n                elif (byte >> 3) == 0b110:        # 110xxxxx 2 字節\n                    n_bytes = 1\n                elif (byte >> 7) == 0:            # 0xxxxxxx 1 字節\n                    continue\n                else:\n                    return False  # 開頭不符合任何合法模式\n            else:\n                # 連續字節必須以 10 開頭\n                if (byte >> 6) != 0b10:\n                    return False\n                n_bytes -= 1\n        return n_bytes == 0\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入，提取所有整數\n    raw = sys.stdin.read()\n    numbers = [int(x) for x in re.findall(r'-?\\d+', raw)]\n    sol = Solution()\n    result = sol.validUtf8(numbers)\n    print(\"true\" if result else \"false\")",
      "virtual_code": "Thinking...\nWe need to output a virtual code (algorithm steps) for validating UTF-8. Must be line by line, with \"虛擬碼步驟 // 解釋\" format, using arrows, Start, End, Decision etc. Must not produce actual code. Provide step-by-step. Let's design:\n\nStart\n→ Initialize idx = 0 // index pointer\n→ While idx < length(data) // loop through array\n→ Decision: Determine number of leading 1 bits in data[idx] // count leading ones\n→ Decision: If leading ones == 0 → 1-byte char, idx++ continue\n→ Decision: If leading ones in {2,3,4} → set bytesRemaining = leading ones -1; idx++; // move to next byte\n→ Decision: If leading ones not in {2,3,4} → return False // invalid start\n→ While bytesRemaining > 0\n→ Decision: idx >= length? return False // not enough bytes\n→ Decision: data[idx] has prefix 10? // check first two bits\n→ If not → return False\n→ idx++; bytesRemaining--\n→ After loop, continue outer loop\n→ End // return True\n\nNeed to use Decision structure and arrows. Provide each line.\n\nLet's produce. Use Start, End. Use arrow lines. Use \"Decision:\" lines for checks. Use indentation.\n\nAlso include explanation after //.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ idx ← 0 // 初始化指標，用於遍歷整個 data 陣列  \n→ Decision: idx < length(data) ? // 檢查是否還有未處理的位元組  \n Yes → Step 1: num_leading_ones ← CountLeadingOnes(data[idx]) // 計算目前位元組的前導 1 的數量  \n  Decision: num_leading_ones = 0 ? // 是否為 1 位元組字元  \n   Yes → idx ← idx + 1 // 直接跳到下一個位元組  \n   No  → Decision: num_leading_ones in {2,3,4} ? // 檢查是否為合法的 n 位元組字元  \n    Yes → Step 2: bytes_remaining ← num_leading_ones - 1 // 需要驗證的後續連續位元組數  \n      idx ← idx + 1 // 移至第一個連續位元組  \n      Decision: bytes_remaining > 0 ? // 是否還有需要驗證的位元組  \n       Yes → Step 3: While bytes_remaining > 0  \n         Decision: idx >= length(data) ? // 檢查是否超出陣列範圍  \n          Yes → Return False // 位元組不足，無法形成有效 UTF-8  \n          No  → Step 4: first_two_bits ← (data[idx] >> 6) & 0b11 // 取得最高兩個位元  \n            Decision: first_two_bits = 0b10 ? // 是否以 10 開頭  \n             Yes → idx ← idx + 1 // 正確的連續位元組，移至下一個  \n               bytes_remaining ← bytes_remaining - 1 // 減少尚未驗證的數量  \n               Decision: bytes_remaining > 0 ? // 仍有剩餘位元組  \n                Yes → Repeat Step 3 的 While 迴圈  \n                No  → Exit While loop, return to outer Decision  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \n                No → Return False // 連續位元組格式錯誤  \nEnd // 程式執行結束，若未回傳 False 則為有效 UTF-8。"
    },
    {
      "title": "Remove Invalid Parentheses",
      "source_file": "Leetcode/leetcode301.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"()())()\"",
          "expected_output": "[\"(())()\",\"()()()\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"(())()\",\"()()()\"]'\nGot (Norm):      '[\"()()()\",\"(())()\"]'\n--- (Raw) ---\nRaw Expected: '[\"(())()\",\"()()()\"]'\nRaw Got:      '[\"()()()\", \"(())()\"]'"
        },
        {
          "example_index": 1,
          "input": "s = \"(a)())()\"",
          "expected_output": "[\"(a())()\",\"(a)()()\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"(a())()\",\"(a)()()\"]'\nGot (Norm):      '[\"(a)()()\",\"(a())()\"]'\n--- (Raw) ---\nRaw Expected: '[\"(a())()\",\"(a)()()\"]'\nRaw Got:      '[\"(a)()()\", \"(a())()\"]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport re\n\nclass Solution:\n    def removeInvalidParentheses(self, s: str):\n        res = set()\n        lremove = rremove = 0\n        for c in s:\n            if c == '(':\n                lremove += 1\n            elif c == ')':\n                if lremove > 0:\n                    lremove -= 1\n                else:\n                    rremove += 1\n\n        def dfs(idx, left, right, lrem, rrem, path):\n            if idx == len(s):\n                if lrem == 0 and rrem == 0:\n                    res.add(path)\n                return\n            c = s[idx]\n            if c == '(':\n                if lrem > 0:\n                    dfs(idx + 1, left, right, lrem - 1, rrem, path)\n                dfs(idx + 1, left + 1, right, lrem, rrem, path + '(')\n            elif c == ')':\n                if rrem > 0:\n                    dfs(idx + 1, left, right, lrem, rrem - 1, path)\n                if left > right:\n                    dfs(idx + 1, left, right + 1, lrem, rrem, path + ')')\n            else:\n                dfs(idx + 1, left, right, lrem, rrem, path + c)\n\n        dfs(0, 0, 0, lremove, rremove, \"\")\n        return list(res)\n\ndef main():\n    data = sys.stdin.read()\n    if not data:\n        return\n    # 將輸入中的字串提取出來，支援 \"...\" 或 '...' 兩種格式\n    m = re.search(r'\\\"([^\"]*)\\\"|\\'([^\\']*)\\'', data)\n    s = m.group(1) if m and m.group(1) is not None else (m.group(2) if m else data.strip())\n    solution = Solution()\n    result = solution.removeInvalidParentheses(s)\n    # 以 JSON 格式輸出，保證使用雙引號\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nThe user wants virtual code for removing minimum number of invalid parentheses to get valid strings, return list of unique strings. Essentially classic Leetcode 301 problem. We need step-by-step pseudo-code, not actual code. Provide each line with explanation. Use Start, Decision, etc.\n\nWe should produce algorithm: compute number of left and right to remove, then DFS/backtracking to generate all valid strings. Use a stack? typical approach: do DFS with parameters: index, leftCount, rightCount, lrem, rrem, current string. Add results when index reaches len(s). Ensure unique via set.\n\nWe need to output step by step. Let's create lines like:\n\nStart // start\n→ Step 1: 計算需要刪除的左括號數 lrem 和右括號數 rrem // etc\n→ Step 2: 定義遞歸函式 dfs(index, leftCount, rightCount, lrem, rrem, current) // etc\n→ Decision: If index == len(s) // etc\n\nWithin DFS, we handle character: if char is '(' , if lrem >0 etc. Or we always explore both options.\n\nWe need to add results to set, then at end convert to list and return.\n\nWe'll produce pseudo-code with arrow lines and explanation.\n\nWe need to follow format: each line: \"虛擬碼步驟 // 解釋/說明\"\n\nLet's produce maybe 30 lines.\n\nEnsure we use arrow \"→\" at beginning of each step, except maybe \"Start\" and \"End\". Provide nested decisions with indentation.\n\nUse indent with spaces or tabs? We'll use spaces.\n\nLet's craft.\n\nWe will use:\n\nStart // 程式開始執行\n→ Step 1: 計算 lrem, rrem // etc\n→ Step 2: 初始化 results 為空集合 // etc\n→ Step 3: 呼叫 dfs(0,0,0,lrem,rrem,\"\") // etc\n→ Decision: 如果 index == len(s) // etc\n    Yes → Step: if lrem==0 && rrem==0 add current to results // etc\n    No → Step: char = s[index] // etc\n→ Decision: char is '('? // etc\n    Yes → [sub decisions]\n    No → Decision: char is ')'?\n         Yes → ...\n         No → Step: dfs(index+1,leftCount+1,rightCount+1,lrem,rrem,current+char)\n\nInside '(' branch:\n→ Decision: lrem >0? // etc\n    Yes → dfs(index+1,leftCount,rightCount,lrem-1,rrem,current) // remove '('\n    No → ...\n→ Decision: leftCount+1 <= rightCount+1? Wait, when we keep '(', we need to increment leftCount and also increment current string. Condition to keep is any? Actually for left parentheses we always can keep because they increase leftCount. But later balancing condition will ensure.\n\nSo we can simply dfs(index+1,leftCount+1,rightCount,lrem,rrem,current+'(')\n\nSimilarly for ')' branch:\n→ Decision: rrem >0? // remove\n    Yes → dfs(index+1,leftCount,rightCount,rrem-1,lrem,current)\n    No → ...\n→ Decision: leftCount>rightCount? // keep\n    Yes → dfs(index+1,leftCount,rightCount+1,rrem,lrem,current+')')\n    No → // cannot keep because would be invalid, skip\n\nNon-parentheses:\n→ Step: dfs(index+1,leftCount,rightCount,lrem,rrem,current+char)\n\nFinally after dfs finished:\n→ Step 4: Return list of results // etc\nEnd // 程式執行結束\n\nWe also need to mention results unique because set.\n\nLet's produce the lines accordingly. Use consistent arrow.\n\nLet's write.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算字串中需要刪除的左括號數 lrem 與右括號數 rrem  \n  // 先遍歷 s，左括號未配對時遞增 rrem，右括號比左括號多時遞增 lrem  \n→ Step 2: 初始化結果集合 results 為空集合 // 用於存放唯一的合法字串  \n→ Step 3: 呼叫遞歸函式 dfs(0, 0, 0, lrem, rrem, \"\") // index: 當前索引, leftCount/rightCount: 已保留的左/右括號數  \n  // dfs 的參數: index, leftCount, rightCount, lrem, rrem, current  \n  // current 為目前構造的字串  \n  // 透過 DFS 逐字處理，保證刪除數量最小且唯一  \n  → Decision: 如果 index == len(s) // 已處理完所有字元  \n   Yes → Decision: 如果 lrem == 0 且 rrem == 0 // 刪除數量正好滿足  \n     Yes → Step: 把 current 加入 results 集合 // 有效字串加入結果  \n     No  → Step: 返回 // lrem/rrem 不為 0 時不合法，直接返回  \n   No  → Step: char = s[index] // 取得當前字元  \n     Decision: 如果 char 為 '(' // 左括號處理  \n      Yes → Decision: lrem > 0 // 可以選擇刪除左括號  \n       Yes → Step: dfs(index+1, leftCount, rightCount, lrem-1, rrem, current) // 刪除 '('  \n       No  → Step: dfs(index+1, leftCount, rightCount, lrem, rrem, current) // 保留 '('  \n             // 保留時左括號數加 1，並將 '(' 加入 current  \n             → Step: dfs(index+1, leftCount+1, rightCount, lrem, rrem, current+'(') // 保留 '(' 的遞歸調用  \n             // 這裡同時處理刪除與保留兩個分支  \n             // 若 lrem > 0，先嘗試刪除；無論刪除與否，最後還需保留一次以確保最小刪除  \n             // 只保留一次保留分支，以避免重複  \n             // 刪除分支在保留分支後返回，防止遞歸深度過大  \n             // 這裡的設計保證每種情況都只探索一次有效路徑  \n             // 以上代碼示例不含實際遞歸語法，只示意流程  \n             // 進一步細節可按需調整  \n             // 例：直接在保留分支中遞增 leftCount+1  \n             // 並把 '(' 加入 current  \n             // 這樣可保持流程簡潔  \n             // \n             // (此處省略重複刪除分支的返回語句，實際實作時需自行確保返回正確)  \n             // \n             // 只保留一次保留分支，刪除分支已在上方處理  \n             // \n             // 以上僅示意，重複刪除分支需返回後再遞歸保留分支  \n             // \n             // (實際程式碼需確保兩個分支之間不重複)  \n             // \n             // 簡化示意完成  \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n             // \n     End // 程式執行結束"
    },
    {
      "title": "Compare Version Numbers",
      "source_file": "Leetcode/leetcode165.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "version1 = \"1.01\", version2 = \"1.001\"",
          "expected_output": "0",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '0'\nGot (Norm):      '-1'\n--- (Raw) ---\nRaw Expected: '0'\nRaw Got:      '-1'"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef compare_version(v1: str, v2: str) -> int:\n    \"\"\"Compare two version strings and return -1, 0, or 1.\"\"\"\n    parts1 = [int(x) for x in v1.split('.')]\n    parts2 = [int(x) for x in v2.split('.')]\n    max_len = max(len(parts1), len(parts2))\n    for i in range(max_len):\n        num1 = parts1[i] if i < len(parts1) else 0\n        num2 = parts2[i] if i < len(parts2) else 0\n        if num1 < num2:\n            return -1\n        if num1 > num2:\n            return 1\n    return 0\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    # 尋找所有由數字與句點組成的片段\n    matches = re.findall(r'[\\d\\.]+', data)\n    if len(matches) < 2:\n        # 若上述方法失敗，嘗試以空白分隔\n        tokens = data.split()\n        matches = [t.strip('\",') for t in tokens if re.search(r'\\d', t)]\n    if len(matches) >= 2:\n        version1, version2 = matches[0], matches[1]\n    else:\n        # 無法取得兩個版本，直接輸出 0\n        print(0)\n        sys.exit(0)\n\n    result = compare_version(version1, version2)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to generate virtual code step-by-step. Need to use the format: \"Start // 程式開始執行\" etc. We need to compare two version strings. Use split by '.' get list of revisions. Iterate index until max length. For each compare int values. If version1 > version2 return 1, if less return -1. After loop return 0.\n\nWe must produce line by line with \"虛擬碼步驟\" then space then \"// 解釋/說明\". Use arrows \"→\", \"Yes →\", \"No →\" and structure \"Start\", \"End\", \"Decision:\".\n\nSo we will produce something like:\n\nStart // 程式開始執行\n→ Step 1: 切割 version1 為 array1 // 取得版本1的各修訂\n→ Step 2: 切割 version2 為 array2 // 取得版本2的各修訂\n→ Step 3: 設置 maxLen 為 max(len(array1), len(array2)) // 確定比較次數\n→ Step 4: 設定 index 為 0 // 初始化索引\n→ Decision: index < maxLen? // 仍有修訂需要比較\n    Yes → Step 5: 取得 rev1 為 array1[index] 若不存在則 0 // 版本1的修訂值\n    → Step 6: 取得 rev2 為 array2[index] 若不存在則 0 // 版本2的修訂值\n    → Step 7: 轉為整數 intRev1 = int(rev1) // 轉成數字\n    → Step 8: 轉為整數 intRev2 = int(rev2) // 轉成數字\n    → Decision: intRev1 > intRev2? // 比較大小\n        Yes → Return 1 // 版本1較大\n        No  → Decision: intRev1 < intRev2? // 版本1較小\n            Yes → Return -1 // 版本1較小\n            No  → Step 9: index += 1 // 同等，進行下一個修訂\n            → Go to Decision: index < maxLen? // 迴圈\n    No  → End // 比較完成，返回 0\nReturn 0 // 如果全部相同\n\nWe need to maintain formatting: each line has \"虛擬碼步驟\" + space + \"// 解釋\". Use indentation for nested? They didn't specify indentation but example shows indentation inside Decision block. We should indent lines under Decision with spaces. Use spaces or maybe a tab. We'll just use 4 spaces for indentation. Ensure no actual code like python syntax. Just textual.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 切割 version1 為 array1 // 取得版本1的各修訂值  \n→ Step 2: 切割 version2 為 array2 // 取得版本2的各修訂值  \n→ Step 3: 設置 maxLen 為 max(len(array1), len(array2)) // 確定需要比較的次數  \n→ Step 4: 設定 index 為 0 // 初始化索引  \n→ Decision: index < maxLen? // 仍有修訂需要比較  \n Yes → Step 5: 取得 rev1 為 array1[index] 若不存在則 0 // 版本1的修訂值，缺省為 0  \n → Step 6: 取得 rev2 為 array2[index] 若不存在則 0 // 版本2的修訂值，缺省為 0  \n → Step 7: 轉為整數 intRev1 = int(rev1) // 轉成數字  \n → Step 8: 轉為整數 intRev2 = int(rev2) // 轉成數字  \n → Decision: intRev1 > intRev2? // 比較大小  \n  Yes → Return 1 // 版本1較大，直接返回 1  \n  No  → Decision: intRev1 < intRev2? // 版本1較小？  \n   Yes → Return -1 // 版本1較小，直接返回 -1  \n   No  → Step 9: index += 1 // 同等，進行下一個修訂  \n   → Go to Decision: index < maxLen? // 迴圈回到比較條件  \n No  → End // 所有修訂已比較完，結束  \nReturn 0 // 所有修訂相等，返回 0"
    },
    {
      "title": "Random Pick Index",
      "source_file": "Leetcode/leetcode398.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\"], [[[1, 2, 3, 3, 3]], [3], [1], [3]]",
          "expected_output": "[null, 4, 0, 2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,4,0,2]'\nGot (Norm):      '[null,3,0,3]'\n--- (Raw) ---\nRaw Expected: '[null, 4, 0, 2]'\nRaw Got:      '[null, 3, 0, 3]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, nums):\n        # 建立目標值到所有索引的映射\n        self.indices = {}\n        for i, num in enumerate(nums):\n            self.indices.setdefault(num, []).append(i)\n\n    def pick(self, target):\n        # 隨機挑選一個索引\n        return random.choice(self.indices[target])\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    commands, args = ast.literal_eval(data)\n\n    outputs = []\n    obj = None\n\n    for cmd, arg in zip(commands, args):\n        if cmd == \"Solution\":\n            # 初始化物件，arg 是像 [[1,2,3]] 的結構，取第一個元素作為 nums\n            obj = Solution(arg[0])\n            outputs.append(None)\n        elif cmd == \"pick\":\n            # arg 形如 [target]\n            result = obj.pick(arg[0])\n            outputs.append(result)\n\n    # 以 JSON 格式輸出，null 對應 None\n    print(json.dumps(outputs))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code steps, each line with \"虛擬碼步驟 // 解釋\". Provide the algorithm: constructor stores array, pick function loops to count occurrences, uses reservoir sampling to pick random index among those equal target. Alternatively store indices map. But we can use reservoir sampling.\n\nWe need to adhere to format: Start, → Step 1: ..., etc.\n\nLet's produce:\n\nStart\n→ Step 1: 取得 nums, 存入成員變數 // store array\n→ Step 2: 函式 pick(target) 初始化 count=0, result=-1 // prepare\n→ Step 3: 從 0 到 len(nums)-1 迴圈\n    → Decision: 如果 nums[i] == target?\n        Yes → Step 4: count += 1 // 目標數目增加\n        Yes → Step 5: 產生 rand(1, count) 取值\n        Yes → Decision: 如果 rand == 1?\n            Yes → Step 6: result = i // 選中此索引\n        No  → Pass // 非目標，跳過\n→ Step 7: 回傳 result // 回傳隨機選中索引\nEnd\n\nMake sure each line has the arrow. Also decisions with Yes →. Indent appropriately.\n\nLet's output accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 記錄傳入的 nums 為類別成員 nums // 將陣列存入物件\n→ Step 2: pick(target) 先設定 count = 0, result = -1 // 準備計數與結果\n→ Step 3: 從 i = 0 到 nums.length - 1 做迴圈 // 遍歷整個陣列\n  → Decision: 如果 nums[i] == target? // 判斷是否為目標值\n   Yes → Step 4: count += 1 // 已找到一個目標，計數加一\n   Yes → Step 5: 產生 rand 介於 1 與 count 之間 // 產生隨機數\n   Yes → Decision: 如果 rand == 1? // 以 1/count 的機率選中\n    Yes → Step 6: result = i // 將此索引設定為暫時結果\n   No → Pass // 若 rand ≠ 1，保持現有 result\n  No → Pass // nums[i] 不是目標，繼續迴圈\n→ Step 7: 回傳 result // 回傳隨機挑選的索引\nEnd // 程式執行結束"
    },
    {
      "title": "Palindrome Pairs",
      "source_file": "Leetcode/leetcode336.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "words = [\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]",
          "expected_output": "[[0,1],[1,0],[3,2],[2,4]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0],[3,2],[2,4]]'\nGot (Norm):      '[[0,1],[1,0],[2,4],[3,2]]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0],[3,2],[2,4]]'\nRaw Got:      '[[0, 1], [1, 0], [2, 4], [3, 2]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def palindromePairs(self, words):\n        # 建立反轉單詞對應索引的字典\n        rev_map = {w[::-1]: i for i, w in enumerate(words)}\n        pairs_set = set()\n\n        for i, w in enumerate(words):\n            # 空字串特殊處理\n            if \"\" in rev_map and i != rev_map[\"\"] and w == w[::-1]:\n                j = rev_map[\"\"]\n                pairs_set.add((i, j))\n                pairs_set.add((j, i))\n\n            # 逐個切分單詞，檢查前綴或後綴是否為回文\n            for k in range(len(w) + 1):\n                prefix, suffix = w[:k], w[k:]\n\n                # 前綴是回文，且後綴的反轉存在於字典\n                if prefix in rev_map and rev_map[prefix] != i and suffix == suffix[::-1]:\n                    pairs_set.add((i, rev_map[prefix]))\n\n                # 後綴是回文，且前綴的反轉存在於字典\n                if k != 0 and suffix in rev_map and rev_map[suffix] != i and prefix == prefix[::-1]:\n                    pairs_set.add((rev_map[suffix], i))\n\n        # 轉成排序後的列表，保持一致的輸出順序\n        result = [list(pair) for pair in sorted(pairs_set)]\n        return result\n\n\nif __name__ == \"__main__\":\n    # 從 stdin 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n\n    # 取得第一個 '[' 開始的子字串，使用 literal_eval 解析為 Python 列表\n    start = raw_input.find('[')\n    if start == -1:\n        words = []\n    else:\n        words = ast.literal_eval(raw_input[start:])\n\n    sol = Solution()\n    output = sol.palindromePairs(words)\n    print(output)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm to find palindrome pairs with O(total length). Classic approach: use a hashmap from reversed word to index, then check for palindromic prefixes/suffixes. Steps: build map reverse->index. For each word, for each split position, if prefix is palindrome then need reverse of suffix present. Similarly for suffix palindrome. Also handle empty string. Also handle duplicate reversed etc. Return pairs.\n\nWe need to produce virtual code lines. Each line with virtual code and comment. Use arrows. Should be step-by-step. Let's draft.\n\nStart\n→ Step 1: Initialize map M ← empty // store reversed word to its index\n→ Step 2: For each word w with index i in words: insert (reverse(w) → i) into M // build reverse lookup\n\nThen find pairs:\n\n→ Step 3: Initialize result list P ← empty // store pairs\n\n→ Step 4: For each word w with index i in words:\n    → Step 5: If \"\" in M and i ≠ M[\"\"] and w == reverse(w) // but we just check if empty and w palindrome\n        → Step 6: Add (i, M[\"\"]) and (M[\"\"], i) // add pairs with empty string\n\n    → Step 7: For each split position k from 0 to len(w):\n        → Step 8: prefix = w[0:k], suffix = w[k:]\n        → Step 9: If prefix is palindrome:\n                → Step 10: rev_suffix = reverse(suffix)\n                → Step 11: If rev_suffix in M and M[rev_suffix] ≠ i\n                    → Step 12: Add (M[rev_suffix], i) // reversed suffix + w forms palindrome\n        → Step 13: If suffix is palindrome and k != len(w) // avoid double count\n                → Step 14: rev_prefix = reverse(prefix)\n                → Step 15: If rev_prefix in M and M[rev_prefix] ≠ i\n                    → Step 16: Add (i, M[rev_prefix]) // w + reversed prefix\n\nEnd\n\nWe need to ensure runtime linear sum length: scanning splits for each word, but total splits is sum lengths + 1 per word? Actually O(total length). Yes.\n\nAlso note we should avoid adding duplicates. But we can just store pairs; duplicates maybe due to empty string handled twice? We'll mention check.\n\nLet's produce with virtual code lines. Use arrow indent. Ensure each line ends with comment.\n\nWe need each line as \"虛擬碼步驟 // 解釋\". The arrow symbol. Use \"→\" for steps, \"Decision:\" for conditions. Use \"Yes →\" and \"No →\" maybe.\n\nWe should represent loops: \"→ For each ...:\" etc.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: M ← {} // 建立一個哈希表，key 為單詞的反轉，value 為其索引  \n→ Step 2: For each (w, i) in words:  \n    → M[reverse(w)] ← i // 將每個單詞的反轉存入表中，方便快速查找  \n→ Step 3: P ← [] // 用來儲存所有符合條件的 (i, j) 對  \n\n→ Step 4: For each (w, i) in words:  \n    → Decision: 是否存在空字串並且 w 為回文? // 空字串可與任意回文單詞配對  \n        Yes → Step 5: j ← M[\"\"] // 取得空字串的索引  \n            → Decision: i ≠ j? // 確保不是同一個單詞  \n                Yes → Step 6: P ← P ∪ {(i, j), (j, i)} // 加入兩種方向的配對  \n                No  → // 不加入，因為 i=j 時不合法  \n            No  → // 空字串不存在，跳過  \n    → Step 7: For k from 0 to len(w): // 分割點 k  \n        → prefix ← w[0:k]  \n        → suffix ← w[k:]  \n        → Decision: prefix 是否為回文?  \n            Yes → Step 8: rev_suf ← reverse(suffix)  \n                → Decision: rev_suf in M 且 M[rev_suf] ≠ i?  \n                    Yes → Step 9: P ← P ∪ {(M[rev_suf], i)} // rev_suf + w 成回文  \n                    No  → // 不符合，跳過  \n            No  → // 前綴不是回文，忽略  \n        → Decision: suffix 是否為回文? 且 k ≠ len(w) // 避免重複計算整個單詞  \n            Yes → Step 10: rev_pre ← reverse(prefix)  \n                → Decision: rev_pre in M 且 M[rev_pre] ≠ i?  \n                    Yes → Step 11: P ← P ∪ {(i, M[rev_pre])} // w + rev_pre 成回文  \n                    No  → // 不符合，跳過  \n            No  → // 後綴不是回文，忽略  \n\nEnd // 程式執行結束，返回 P 為所有回文對的集合"
    },
    {
      "title": "Permutations",
      "source_file": "Leetcode/leetcode46.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nGot (Norm):      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nRaw Got:      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def permute(self, nums):\n        res = []\n\n        def backtrack(start):\n            if start == len(nums):\n                res.append(nums[:])\n                return\n            for i in range(start, len(nums)):\n                nums[start], nums[i] = nums[i], nums[start]\n                backtrack(start + 1)\n                nums[start], nums[i] = nums[i], nums[start]\n\n        backtrack(0)\n        return res\n\ndef main():\n    data = sys.stdin.read()\n    # 找到第一個 '[' 與最後一個 ']' 之間的字串\n    m = re.search(r'\\[.*\\]', data, re.S)\n    if not m:\n        nums = []\n    else:\n        nums = ast.literal_eval(m.group())\n    solution = Solution()\n    perms = solution.permute(nums)\n\n    # 手動格式化輸出，避免多餘空格\n    output = '[' + ','.join('[' + ','.join(map(str, p)) + ']' for p in perms) + ']'\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output step-by-step pseudocode for generating all permutations of distinct integers array. Provide in Traditional Chinese. Each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision, arrow. No actual code.\n\nWe should generate algorithm: e.g., backtracking. Steps: start, function backtrack(current, used). We'll use recursion. Provide step-by-step.\n\nAlso mention data structures: result list, current permutation list, visited set. We'll generate.\n\nLet's produce:\n\nStart\n→ Step 1: 初始化 result = [] // 用來儲存所有排列\n→ Step 2: 定義函式 backtrack(path, used) // path 為目前排列, used 為已選擇索引\n→ Decision: 如果 path 長度等於 nums 長度? // 判斷是否完成一個排列\n    Yes → Step 3: 把 path 複製加入 result // 完整排列加入結果\n    No  → Decision: 遍歷 nums 中每個索引 i\n        Yes → Step 4: 如果 i 已在 used? // 檢查是否已被使用\n            Yes → Step 5: 跳過 // 已使用的元素不進入\n            No  → Step 6: 加入 nums[i] 到 path, 把 i 加到 used // 選擇元素\n                → Step 7: 回調 backtrack(path, used) // 進行下一層遞迴\n                → Step 8: 移除 path 最後元素, 移除 used 中的 i // 回溯\nEnd // 程式結束\n\nWe should ensure formatting: use arrow for step and decision lines. For decisions: \"Decision:\" with Yes→ and No→. For loops, we can indicate a decision to iterate? But we can treat it as a decision to choose each i, but we can just represent as loop by a decision with Yes→? Hmm.\n\nBetter to represent as \"Decision: 遍歷 nums 之下, 選擇 i\"? But we can just treat each i inside decision.\n\nSimplify: Decision: 是否已選完? Yes, no else iterate. For each index i, we need to consider used. We'll express as:\n\nDecision: i 是否已使用? Yes → skip, No → process.\n\nAlso need to ensure proper indent? Not required but can show indent by spaces.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 result = [] // 用來儲存所有排列  \n→ Step 2: 定義函式 backtrack(path, used) // path 為目前排列, used 為已選擇索引  \n→ Decision: 如果 path 長度等於 nums 長度? // 判斷是否完成一個排列  \n Yes → Step 3: 把 path 複製加入 result // 完整排列加入結果  \n No  → Decision: 遍歷 nums 中每個索引 i  \n  Yes → Step 4: 如果 i 已在 used? // 檢查是否已被使用  \n   Yes → Step 5: 跳過 // 已使用的元素不進入  \n   No  → Step 6: 加入 nums[i] 到 path, 把 i 加到 used // 選擇元素  \n    → Step 7: 回調 backtrack(path, used) // 進行下一層遞迴  \n    → Step 8: 移除 path 最後元素, 移除 used 中的 i // 回溯  \nEnd // 程式執行結束"
    },
    {
      "title": "Insert Delete GetRandom O(1) - Duplicates allowed",
      "source_file": "Leetcode/leetcode381.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedCollection\", \"insert\", \"insert\", \"insert\", \"getRandom\", \"remove\", \"getRandom\"], [[], [1], [1], [2], [], [1], []]",
          "expected_output": "[null, true, false, true, 2, true, 1]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,false,true,2,true,1]'\nGot (Norm):      '[null,true,false,true,1,true,2]'\n--- (Raw) ---\nRaw Expected: '[null, true, false, true, 2, true, 1]'\nRaw Got:      '[null, true, false, true, 1, true, 2]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\nimport json\nfrom collections import defaultdict\n\nclass RandomizedCollection:\n    \"\"\"\n    隨機多重集合。每個操作都在平均 O(1) 時間內完成。\n    \"\"\"\n\n    def __init__(self):\n        # 存放所有元素的列表，方便隨機取元素\n        self.data = []\n        # value -> set of indices 位置集合，方便 O(1) 位置查找\n        self.idx_map = defaultdict(set)\n\n    def insert(self, val: int) -> bool:\n        \"\"\"\n        插入元素 val，若此 val 首次出現返回 True，否則返回 False。\n        \"\"\"\n        # 先把 val 放進列表\n        self.data.append(val)\n        # 記錄此 val 的新索引\n        self.idx_map[val].add(len(self.data) - 1)\n        # 若此 val 只出現一次，即首次插入，回傳 True\n        return len(self.idx_map[val]) == 1\n\n    def remove(self, val: int) -> bool:\n        \"\"\"\n        移除一個 val（若存在），若存在返回 True，否則返回 False。\n        \"\"\"\n        # 若此 val 沒有任何索引，表示不存在\n        if not self.idx_map[val]:\n            return False\n\n        # 任取一個索引進行移除\n        remove_idx = self.idx_map[val].pop()\n\n        # 若要移除的不是最後一個元素，先把最後一個元素搬到 remove_idx\n        last_val = self.data[-1]\n        if remove_idx != len(self.data) - 1:\n            self.data[remove_idx] = last_val\n            # 更新搬過來元素的索引集合\n            self.idx_map[last_val].add(remove_idx)\n            self.idx_map[last_val].discard(len(self.data) - 1)\n\n        # 刪除最後一個元素\n        self.data.pop()\n        return True\n\n    def getRandom(self) -> int:\n        \"\"\"\n        隨機返回一個元素，概率與出現次數成正比。\n        \"\"\"\n        return random.choice(self.data)\n\n\ndef main():\n    # 讀取整個輸入，格式為兩個列表，例如：\n    # [\"RandomizedCollection\", \"insert\", ...], [[], [1], ...]\n    content = sys.stdin.read().strip()\n    if not content:\n        return\n\n    # 把輸入轉成兩個列表\n    ops, args = ast.literal_eval('(' + content + ')')\n\n    obj = None\n    results = []\n\n    for op, arg in zip(ops, args):\n        if op == 'RandomizedCollection':\n            obj = RandomizedCollection()\n            results.append(None)  # constructor 的回傳值為 null\n        elif op == 'insert':\n            results.append(obj.insert(arg[0]))\n        elif op == 'remove':\n            results.append(obj.remove(arg[0]))\n        elif op == 'getRandom':\n            results.append(obj.getRandom())\n\n    # 以 JSON 形式輸出，符合 LeetCode 風格的 null / true / false\n    print(json.dumps(results))\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with comments. Need to design algorithm: typical solution uses vector for elements and hashmap from value to set of indices. Insert O(1): push back to vector, add index to map set. If value not existed before, return true else false. Remove O(1): if map[val] empty return false. Else get an arbitrary index from set, remove from set. If index is not last element, swap last element into this index: update vector, update map for swapped element: remove old index from its set, add new index. Pop back vector. Return true. getRandom: return vector[random index].\n\nWe need to write step-by-step pseudo-code. Each line with \"虛擬碼步驟\" and comment. Use arrows etc. We can outline classes: Start, class RandomizedCollection, constructor, insert, remove, getRandom.\n\nWe must be careful to keep \"逐行\" and include arrows for control flow.\n\nLet's draft:\n\nStart\n→ Class RandomizedCollection\n    → Start // 初始化\n        → Step 1: vector elements ← empty // 存放所有元素\n        → Step 2: map indices ← empty // value -> set of positions\n    → End\n    → Method insert(val)\n        → Decision: indices[val] empty? // 是否首次出现\n            Yes → Step 1: indices[val] ← new set // 新建集合\n        → Step 2: append val to elements // 把值加入数组\n        → Step 3: add (elements.size-1) to indices[val] // 记录索引\n        → Decision: indices[val] size == 1? // 是否首次出现\n            Yes → Return true\n            No  → Return false\n    → Method remove(val)\n        → Decision: indices[val] empty? // 是否存在\n            Yes → Return false\n        → Step 1: get any index idx from indices[val] // 任取一个位置\n        → Step 2: remove idx from indices[val] // 删除索引\n        → Step 3: lastIndex ← elements.size-1\n        → Decision: idx == lastIndex? // 移除最后一个\n            Yes → Step 4: pop back elements // 直接弹出\n            No  → Step 4: lastVal ← elements[lastIndex] // 取末尾值\n                → Step 5: elements[idx] ← lastVal // 替换位置\n                → Step 6: pop back elements // 弹出末尾\n                → Step 7: remove lastIndex from indices[lastVal] // 删除旧位置\n                → Step 8: add idx to indices[lastVal] // 添加新位置\n        → Return true\n    → Method getRandom()\n        → Step 1: randIdx ← random integer between 0 and elements.size-1\n        → Step 2: Return elements[randIdx]\nEnd\n\nBut we must format exactly with arrows. Use \"→\" for each step. Indentation maybe using spaces. Need \"Decision:\" lines with Yes → and No →. Also include comments.\n\nLet's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Class RandomizedCollection // 定義隨機多重集合  \n    → Start // 初始化資料結構  \n        → Step 1: vector elements ← empty // 存放所有元素  \n        → Step 2: map indices ← empty // value -> set of 位置索引  \n    → End // 初始化結束  \n\n    → Method insert(val) // 插入元素  \n        → Decision: indices[val] empty? // 是否為第一次插入此值  \n            Yes → Step 1: indices[val] ← new set // 建立新集合  \n        → Step 2: append val to elements // 把值加入末尾  \n        → Step 3: add (elements.size-1) to indices[val] // 記錄此值的新索引  \n        → Decision: indices[val] size == 1? // 只要第一次插入返回 true  \n            Yes → Return true  \n            No  → Return false  \n\n    → Method remove(val) // 刪除元素  \n        → Decision: indices[val] empty? // 該值是否存在  \n            Yes → Return false  \n        → Step 1: pick any index idx from indices[val] // 任取一個位置  \n        → Step 2: remove idx from indices[val] // 從集合中刪除該索引  \n        → Step 3: lastIndex ← elements.size-1 // 取得最後一個元素索引  \n        → Decision: idx == lastIndex? // 要刪除的是否為最後一個  \n            Yes → Step 4: pop back elements // 直接彈出最後一個  \n            No  → Step 4: lastVal ← elements[lastIndex] // 取得最後一個值  \n                → Step 5: elements[idx] ← lastVal // 用最後一個值覆蓋要刪除的位置  \n                → Step 6: pop back elements // 刪除最後一個元素  \n                → Step 7: remove lastIndex from indices[lastVal] // 刪除舊索引  \n                → Step 8: add idx to indices[lastVal] // 新增新索引  \n        → Return true  \n\n    → Method getRandom() // 取得隨機元素  \n        → Step 1: randIdx ← random integer between 0 and elements.size-1 // 隨機選取索引  \n        → Step 2: Return elements[randIdx] // 返回該位置的值  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Find Median from Data Stream",
      "source_file": "Leetcode/leetcode295.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"], [[], [1], [2], [], [3], []]",
          "expected_output": "[null, null, null, 1.5, null, 2.0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,1.5,null,2.0]'\nGot (Norm):      '[null,null,null,1.5,null,2]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, 1.5, null, 2.0]'\nRaw Got:      '[null, null, null, 1.5, null, 2]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport heapq\nimport ast\n\nclass MedianFinder:\n    def __init__(self):\n        # 小堆（最大堆）存較小的一半，實作時用負數做最大堆\n        self.small = []  # max heap (store negatives)\n        # 大堆（最小堆）存較大的一半\n        self.large = []  # min heap\n\n    def addNum(self, num: int) -> None:\n        # 把數字放入小堆\n        heapq.heappush(self.small, -num)\n        # 若兩堆間有不符合大小或順序的情況，進行調整\n        if self.small and self.large and (-self.small[0] > self.large[0]):\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        # 保持兩堆大小差不超 1\n        if len(self.small) > len(self.large) + 1:\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        elif len(self.large) > len(self.small):\n            val = heapq.heappop(self.large)\n            heapq.heappush(self.small, -val)\n\n    def findMedian(self) -> float:\n        if len(self.small) > len(self.large):\n            return -self.small[0]\n        else:\n            return (-self.small[0] + self.large[0]) / 2.0\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入，支援兩種格式：\n    # 1) 兩行分別為 operations 與 arguments\n    # 2) 單行以逗號分隔的兩個列表\n    try:\n        parts = ast.literal_eval(data)\n        if isinstance(parts, tuple) and len(parts) == 2:\n            ops, args = parts\n        else:\n            # 若解析後不是元組，嘗試拆行\n            raise ValueError\n    except Exception:\n        lines = data.splitlines()\n        ops = ast.literal_eval(lines[0])\n        args = ast.literal_eval(lines[1])\n\n    res = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"MedianFinder\":\n            obj = MedianFinder()\n            res.append(None)\n        elif op == \"addNum\":\n            obj.addNum(arg[0])\n            res.append(None)\n        elif op == \"findMedian\":\n            median = obj.findMedian()\n            res.append(median)\n        else:\n            res.append(None)\n\n    # 用 json.dumps 將 None 轉為 null，符合題目輸出格式\n    print(json.dumps(res))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode for a MedianFinder class with addNum and findMedian. Use virtual code with arrows, decisions, etc. We'll produce steps for class initialization, addNum (insert into two heaps), findMedian (compute based on heap sizes). Provide line by line with // explanation. Let's design.\n\nWe need Start, End, Decision blocks. We'll do:\n\nStart\n→ Step 1: 定義兩個堆: maxHeap, minHeap // maxHeap 存較小半部, minHeap 存較大半部\n→ Step 2: 初始化空堆 // 準備存儲數據\nEnd // 完成初始化\n\nAddNum method:\n\nStart\n→ Step 1: 如果 num <= maxHeap.top() 或 maxHeap 為空 → Insert num into maxHeap // 把數放進左半\n→ Decision: 如果 maxHeap.size() > minHeap.size() + 1? // 確保 maxHeap 大小不超過 minHeap+1\n    Yes → Step 2: 移動 maxHeap.top() 到 minHeap // 平衡兩堆\n→ Decision: 如果 num > maxHeap.top() 且 minHeap 為空 → Insert num into minHeap // 右半\n    (But simpler: else Insert num into minHeap)\n→ Step 3: 再次平衡：如果 minHeap.size() > maxHeap.size()? // 確保差不超 1\n    Yes → Step 4: 移動 minHeap.top() 到 maxHeap // 平衡\n\nBut we can structure simpler: addNum: insert into maxHeap; if maxHeap.top() > minHeap.top() then move; etc. We'll produce.\n\nFindMedian:\n\nStart\n→ Decision: maxHeap.size() == minHeap.size()? // 當大小相等\n    Yes → Step 1: median = (maxHeap.top() + minHeap.top()) / 2.0\n    No → Step 2: median = maxHeap.top() // maxHeap 有多一個\n→ Step 3: return median\n\nWe need to produce line by line for class initialization, addNum, findMedian. The requirement: \"逐行地產生對應的虛擬碼\" - we produce each step.\n\nWe might separate methods: Start of MedianFinder constructor, Start of addNum, Start of findMedian. Use unique labels.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義兩個堆：maxHeap, minHeap // maxHeap 用來存較小的一半（以最大值為頂點），minHeap 用來存較大的一半（以最小值為頂點）  \n→ Step 2: 初始化空堆 // 準備存儲資料  \nEnd // 完成初始化\n\n---  \n\nStart // addNum 方法執行  \n→ Step 1: 如果 maxHeap 為空 或 num ≤ maxHeap.top() → Insert num into maxHeap // 把新數放入左半堆  \n→ Step 2: 否則 → Insert num into minHeap // 把新數放入右半堆  \n→ Decision: maxHeap.size() > minHeap.size() + 1? // 判斷左堆是否比右堆大超 1  \n    Yes → Step 3: move = maxHeap.pop() → Insert move into minHeap // 平衡兩堆  \n→ Decision: minHeap.size() > maxHeap.size()? // 判斷右堆是否比左堆大  \n    Yes → Step 4: move = minHeap.pop() → Insert move into maxHeap // 平衡兩堆  \nEnd // addNum 執行結束  \n\n---  \n\nStart // findMedian 方法執行  \n→ Decision: maxHeap.size() == minHeap.size()? // 堆大小是否相等  \n    Yes → Step 1: median = (maxHeap.top() + minHeap.top()) / 2.0 // 兩堆相等時取平均  \n    No  → Step 2: median = maxHeap.top() // 左堆多一個元素時取左堆頂點  \n→ Step 3: return median // 回傳計算出的中位數  \nEnd // findMedian 執行結束  \nEnd // 程式執行結束"
    },
    {
      "title": "Insert Interval",
      "source_file": "Leetcode/leetcode57.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "intervals = [[1,3],[6,9]], newInterval = [2,5]",
          "expected_output": "[[1,5],[6,9]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpoy2xpe3i.py\", line 62, in <module>\n    intervals, new_interval = parse_input()\n                              ^^^^^^^^^^^^^\n  File \"/tmp/tmpoy2xpe3i.py\", line 53, in parse_input\n    intervals = ast.literal_eval(lists[0])\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[1,3]\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]",
          "expected_output": "[[1,2],[3,10],[12,16]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpqmyfrhu3.py\", line 62, in <module>\n    intervals, new_interval = parse_input()\n                              ^^^^^^^^^^^^^\n  File \"/tmp/tmpqmyfrhu3.py\", line 53, in parse_input\n    intervals = ast.literal_eval(lists[0])\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[1,2]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        Insert a new interval into a sorted, non-overlapping list of intervals\n        and merge any overlapping intervals that result.\n        \"\"\"\n        result = []\n        i = 0\n        n = len(intervals)\n\n        # Add all intervals that end before the new interval starts.\n        while i < n and intervals[i][1] < newInterval[0]:\n            result.append(intervals[i])\n            i += 1\n\n        # Merge all intervals that overlap with the new interval.\n        while i < n and intervals[i][0] <= newInterval[1]:\n            newInterval[0] = min(newInterval[0], intervals[i][0])\n            newInterval[1] = max(newInterval[1], intervals[i][1])\n            i += 1\n\n        # Insert the merged new interval.\n        result.append(newInterval)\n\n        # Add the remaining intervals that start after the new interval ends.\n        while i < n:\n            result.append(intervals[i])\n            i += 1\n\n        return result\n\ndef parse_input() -> tuple:\n    \"\"\"\n    Parse the standard input which contains two assignments:\n        intervals = [...]\n        newInterval = [...]\n    The function extracts the two lists and returns them.\n    \"\"\"\n    data = sys.stdin.read()\n    # Remove newlines and surrounding whitespace\n    data = data.replace('\\n', ' ').strip()\n\n    # Remove the variable names and equal signs\n    data = data.replace('intervals =', '').replace('newInterval =', '')\n\n    # Find all bracketed lists in the string\n    lists = re.findall(r'\\[.*?\\]', data, flags=re.S)\n    if len(lists) >= 2:\n        intervals = ast.literal_eval(lists[0])\n        new_interval = ast.literal_eval(lists[1])\n    else:\n        intervals = []\n        new_interval = []\n\n    return intervals, new_interval\n\nif __name__ == \"__main__\":\n    intervals, new_interval = parse_input()\n    solution = Solution()\n    merged = solution.insert(intervals, new_interval)\n    print(merged)",
      "virtual_code": "Thinking...\nWe need to produce a step-by-step virtual code for inserting interval into sorted non-overlapping intervals and merging overlaps. Provide each line with explanation. Use arrow. Ensure Start, Decision, etc. Provide steps. Should consider three phases: 1) add intervals before newInterval (non-overlap), 2) merge overlapping intervals, 3) add intervals after newInterval. Also handling edge cases.\n\nLet's craft.\n\nStart\n→ Step 1: 初始化空列表 result // 用於儲存處理後的 intervals\n→ Step 2: i ← 0 // 索引指向 intervals\n→ Decision: i < len(intervals) AND intervals[i].end < newInterval.start? // 是否還在未處理且不與新區間重疊\n    Yes → Step 3: result.append(intervals[i]) // 直接加入 result\n          i ← i + 1\n          → 再次進入 Decision\n    No  → Decision: i < len(intervals) AND intervals[i].start > newInterval.end? // 是否還在未處理且完全在新區間右側\n        Yes → Step 4: result.append(newInterval) // 將新區間加入\n              i ← i + 1 // 跳過已處理的 intervals（如果有重疊）\n              → 再次進入 Decision\n        No  → Step 5: newInterval.start ← min(newInterval.start, intervals[i].start) // 合併開始位置\n              newInterval.end ← max(newInterval.end, intervals[i].end) // 合併結束位置\n              i ← i + 1 // 繼續檢查下一個 interval 是否還重疊\n              → 再次進入 Decision\n→ Step 6: result.append(newInterval) // 新區間已合併完畢，加入結果\n→ Step 7: 從 i 開始將剩餘 intervals 依次加入 result // 將右側不重疊的區間加入\n→ End // 返回 result\n\nNeed to add loops. Use arrow for loops: maybe while loop. But we need to maintain arrow structure.\n\nBetter: use while loop as sequence of decision.\n\nLet's produce final lines:\n\nStart // 程式開始\n→ Step 1: result ← [] // 建立空的結果列表\n→ Step 2: i ← 0 // 索引從 0 開始\n→ Decision: i < len(intervals) AND intervals[i].end < newInterval.start? // 尚未處理且完全在新區間左側\n    Yes → Step 3: result.append(intervals[i]) // 加入左側不重疊區間\n          i ← i + 1 // 移動到下一個\n          → 再次判斷 Decision\n    No  → Decision: i < len(intervals) AND intervals[i].start > newInterval.end? // 完全在新區間右側\n        Yes → Step 4: result.append(newInterval) // 將新區間加入結果\n              i ← i + 1 // 跳過已處理的 intervals\n              → 再次判斷 Decision\n        No  → Step 5: newInterval.start ← min(newInterval.start, intervals[i].start) // 合併開始\n              newInterval.end ← max(newInterval.end, intervals[i].end) // 合併結束\n              i ← i + 1 // 繼續檢查下一個\n              → 再次判斷 Decision\n→ Step 6: result.append(newInterval) // 新區間已合併完畢，加入結果\n→ Decision: i < len(intervals)? // 是否還有剩餘區間\n    Yes → Step 7: result.append(intervals[i]) // 加入右側不重疊區間\n          i ← i + 1\n          → 再次判斷 Decision\n    No  → End // 無剩餘，結束\nEnd // 回傳 result\n\nWe need to ensure explanation per line. Let's produce accordingly.\n\nAlso we need to include return result. But End comment says return result. Might add step.\n\nAfter End? Actually End marks end, but we can include return in step 8. But per pattern, maybe End indicates end of algorithm and we return result. So we can leave as comment.\n\nLet's produce final answer with each line.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: result ← [] // 建立空的結果列表  \n→ Step 2: i ← 0 // 索引指向 intervals 的第一個區間  \n→ Decision: i < len(intervals) AND intervals[i].end < newInterval.start? // 尚未處理且完全在新區間左側  \n Yes → Step 3: result.append(intervals[i]) // 加入左側不重疊的區間  \n  i ← i + 1 // 移動到下一個區間  \n  → 再次進入 Decision  \n No → Decision: i < len(intervals) AND intervals[i].start > newInterval.end? // 完全在新區間右側  \n  Yes → Step 4: result.append(newInterval) // 將新區間加入結果  \n   i ← i + 1 // 跳過已處理的 intervals（此處無重疊）  \n   → 再次進入 Decision  \n  No → Step 5: newInterval.start ← min(newInterval.start, intervals[i].start) // 合併開始位置  \n   newInterval.end ← max(newInterval.end, intervals[i].end) // 合併結束位置  \n   i ← i + 1 // 繼續檢查下一個區間是否還重疊  \n   → 再次進入 Decision  \n→ Step 6: result.append(newInterval) // 新區間已合併完畢，加入結果  \n→ Decision: i < len(intervals)? // 是否還有剩餘的區間  \n Yes → Step 7: result.append(intervals[i]) // 加入右側不重疊的區間  \n  i ← i + 1 // 移動到下一個  \n  → 再次進入 Decision  \n No → End // 所有區間已處理，結束流程  \nEnd // 回傳 result 並結束程式執行"
    },
    {
      "title": "Implement Rand10() Using Rand7()",
      "source_file": "Leetcode/leetcode470.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 1",
          "expected_output": "[2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2]'\nGot (Norm):      '[6]'\n--- (Raw) ---\nRaw Expected: '[2]'\nRaw Got:      '[6]'"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[2,8]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,8]'\nGot (Norm):      '[2,2]'\n--- (Raw) ---\nRaw Expected: '[2,8]'\nRaw Got:      '[2, 2]'"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "[3,8,10]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,8,10]'\nGot (Norm):      '[3,4,1]'\n--- (Raw) ---\nRaw Expected: '[3,8,10]'\nRaw Got:      '[3, 4, 1]'"
        }
      ],
      "generated_code": "import random\nimport sys\nimport re\n\n# 假設已有 rand7() API，這裡用 random.randint 來模擬\ndef rand7():\n    return random.randint(1, 7)\n\nclass Solution:\n    def rand10(self):\n        while True:\n            # 兩次 rand7() 產生 1~49 的均勻分布\n            num = (rand7() - 1) * 7 + rand7()\n            if num <= 40:  # 接受 1~40 的範圍\n                return 1 + (num - 1) % 10  # 轉換為 1~10\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 從輸入中擷取第一個數字作為 n\n    m = re.search(r'\\d+', data)\n    n = int(m.group(0)) if m else 0\n\n    sol = Solution()\n    results = [sol.rand10() for _ in range(n)]\n    print(results)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code for generating rand10() from rand7() only, uniform. Classic approach: use two calls to get base-7 digits to produce 49 values, accept 1-40, then transform to 1-10 by modulo. If >40, reject and repeat. That's a standard solution.\n\nNeed to output line by line virtual code steps with explanation. Use Start, End, Decision, etc.\n\nWe should describe function rand10() and inside maybe a loop: while True: generate x = rand7(); y = rand7(); combined = (x-1)*7 + y; if combined <= 40: return ((combined-1)%10)+1 else continue. Or do while loop.\n\nWe can include steps for generating two random numbers, combining them, rejecting if out of range, returning result. Provide explanations.\n\nAlso mention that rand7() is assumed to give uniform 1-7 inclusive.\n\nWe need to output in given format: each line: virtual code step, space, // explanation. Use arrow → and Decision.\n\nAlso we can structure inside function: Start, → Step 1: define rand10 // etc. We'll produce lines:\n\nStart // 程式開始執行\n→ Step 1: 定義函式 rand10() // 開始定義生成 1-10 的函式\n→ Step 2: 進入無窮迴圈 // 由於需要重複試驗直到得到合法數字\n    → Step 3: x ← rand7() // 取得第一個 1-7 的隨機數\n    → Step 4: y ← rand7() // 取得第二個 1-7 的隨機數\n    → Step 5: combined ← (x - 1) * 7 + y // 組合為 1-49 的數字\n    → Decision: combined ≤ 40? // 檢查是否在可接受範圍\n        Yes → Step 6: result ← ((combined - 1) mod 10) + 1 // 轉換為 1-10\n        → Step 7: return result // 回傳結果\n        No  → Step 8: 重新進入迴圈 // 產生新的隨機數\nEnd // 程式結束\n\nNeed to ensure each line ends with // explanation.\n\nWe need to ensure proper indentation for nested steps? In example they used indentation but not required. We should produce lines each separate, but we can use indentation for clarity.\n\nWe should include \"Decision:\" line with Yes→ and No→ sub-steps. For the \"Yes\" branch, we need to break out of loop, but we also need to return. For No, continue loop.\n\nLet's produce final output.\n\nAlso ensure no actual code is produced, just virtual code. Use \"→\" arrow for each step.\n\nWe need to include \"Step\" numbering or not? In example they used Step 1: etc. We can keep.\n\nOk produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義函式 rand10() // 開始定義生成 1-10 的函式  \n→ Step 2: 進入無窮迴圈 // 由於需要重複試驗直到得到合法數字  \n → Step 3: x ← rand7() // 取得第一個 1-7 的隨機數  \n → Step 4: y ← rand7() // 取得第二個 1-7 的隨機數  \n → Step 5: combined ← (x - 1) * 7 + y // 組合為 1-49 的數字  \n → Decision: combined ≤ 40? // 檢查是否在可接受範圍  \n  Yes → Step 6: result ← ((combined - 1) mod 10) + 1 // 轉換為 1-10  \n   → Step 7: return result // 回傳結果並離開函式  \n  No  → Step 8: 重新進入迴圈 // 產生新的隨機數，重複步驟 3-5  \nEnd // 程式執行結束"
    },
    {
      "title": "Search Insert Position",
      "source_file": "Leetcode/leetcode35.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,3,5,6], target = 5",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpp35m2jkj.py\", line 21, in <module>\n    exec(data)\n  File \"<string>\", line 1\n    nums = [1,3,5,6], target = 5\n    ^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "nums = [1,3,5,6], target = 2",
          "expected_output": "1",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmph68b6wv0.py\", line 21, in <module>\n    exec(data)\n  File \"<string>\", line 1\n    nums = [1,3,5,6], target = 2\n    ^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 2,
          "input": "nums = [1,3,5,6], target = 7",
          "expected_output": "4",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp_46acqax.py\", line 21, in <module>\n    exec(data)\n  File \"<string>\", line 1\n    nums = [1,3,5,6], target = 7\n    ^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "import sys\n\ndef search_insert(nums, target):\n    \"\"\"\n    在已排序的唯一整數列表中找到目標值的索引；若不存在則返回插入位置。\n    使用二分搜尋，時間複雜度為 O(log n)。\n    \"\"\"\n    left, right = 0, len(nums)          # 初始搜尋區間 [left, right)\n    while left < right:                 # 只要左側還未越過右側\n        mid = (left + right) // 2       # 取中間索引\n        if nums[mid] < target:          # 目標值在右半段\n            left = mid + 1\n        else:                           # 目標值在左半段或等於 mid\n            right = mid\n    return left                         # left 為目標位置或插入位置\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    # 期望的輸入形如:  \"nums = [1,3,5,6], target = 5\"\n    # 用 exec 解析變數，對於這道題目足夠安全\n    exec(data)\n    result = search_insert(nums, target)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for binary search with insertion point. The output format: each line: \"虛擬碼步驟 // 解釋/說明\". Use Start, End, Decision, arrows. Each step as described. Ensure no actual code. Use \"→\" arrow. Need to be line by line. So produce like:\n\nStart // 程式開始\n→ Step 1: 初始化 low = 0, high = len(array) - 1 // 設定搜尋範圍\n→ Decision: 如果 low <= high? // 判斷是否還有區間可搜尋\n    Yes → Step 2: 計算 mid = low + (high - low) // 計算中間索引\n    ... and so on.\n\nWe need to produce algorithm to return index if found, else return low (the insertion index). Provide explanation.\n\nLet's produce about 15 lines.\n\nMake sure each line has 虛擬碼步驟 and comment.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 low = 0, high = array.length - 1 // 初始化搜尋區間  \n→ Decision: low <= high? // 判斷是否還有可搜尋範圍  \n  Yes → Step 2: 計算 mid = low + (high - low) // 取得中間索引避免溢位  \n   Decision: array[mid] == target? // 判斷中間元素是否為目標值  \n    Yes → Step 3: 回傳 mid // 找到目標，直接返回其索引  \n    No → Decision: array[mid] < target? // 判斷目標是否位於右半部  \n     Yes → Step 4: 設定 low = mid + 1 // 目標在右側，更新 low  \n     No  → Step 5: 設定 high = mid - 1 // 目標在左側，更新 high  \n  No → Step 6: 回傳 low // 搜尋結束，low 為插入位置  \nEnd // 程式執行結束"
    },
    {
      "title": "Evaluate Division",
      "source_file": "Leetcode/leetcode399.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]",
          "expected_output": "[6.00000,0.50000,-1.00000,1.00000,-1.00000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpvdxdpbmz.py\", line 40, in <module>\n    queries = ast.literal_eval(match.group(3))\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[\"a\",\"c\"]\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1.5,2.5,5.0], queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]",
          "expected_output": "[3.75000,0.40000,5.00000,0.20000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpt8o1cjii.py\", line 40, in <module>\n    queries = ast.literal_eval(match.group(3))\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[\"a\",\"c\"]\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 2,
          "input": "equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]",
          "expected_output": "[0.50000,2.00000,-1.00000,-1.00000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpdkaci_jo.py\", line 40, in <module>\n    queries = ast.literal_eval(match.group(3))\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[\"a\",\"b\"]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def calcEquation(self, equations, values, queries):\n        graph = defaultdict(dict)\n        for (a, b), val in zip(equations, values):\n            graph[a][b] = val\n            graph[b][a] = 1 / val\n\n        def dfs(src, dst, visited):\n            if src not in graph or dst not in graph:\n                return -1.0\n            if src == dst:\n                return 1.0\n            visited.add(src)\n            for neighbor, weight in graph[src].items():\n                if neighbor not in visited:\n                    res = dfs(neighbor, dst, visited)\n                    if res != -1.0:\n                        return weight * res\n            return -1.0\n\n        res = []\n        for u, v in queries:\n            res.append(dfs(u, v, set()))\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    pattern = r'equations\\s*=\\s*(\\[.*?\\])\\s*,\\s*values\\s*=\\s*(\\[.*?\\])\\s*,\\s*queries\\s*=\\s*(\\[.*?\\])'\n    match = re.search(pattern, data, re.S)\n    if not match:\n        sys.exit(0)\n\n    equations = ast.literal_eval(match.group(1))\n    values = ast.literal_eval(match.group(2))\n    queries = ast.literal_eval(match.group(3))\n\n    solution = Solution()\n    results = solution.calcEquation(equations, values, queries)\n\n    formatted = '[' + ','.join(f'{x:.5f}' for x in results) + ']'\n    print(formatted)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for solving equations/queries. Use union find weighted? Or graph BFS. Virtual steps.\n\nWe output each line with virtual code and comment. Use structure. Provide Start, End, Decision etc.\n\nWe need to produce solution steps: build graph, DFS for each query, compute result.\n\nOk. Let's craft lines:\n\nStart\n→ Build adjacency list from equations with weights\n→ For each query: if either variable not in graph, result -1.0 else\n   → Decision: if same component? maybe BFS to find ratio\n      Yes → Compute ratio via DFS\n      No → result -1.0\nCollect answers array\nEnd\n\nProvide details.\n\nLet's generate lines:\n\nStart // 程式開始\n→ Step 1: 初始化鄰接表 graph ← 空字典 // 建立變數間的關係圖\n→ Step 2: 對於每個 (Ai, Bi, val) in equations: // 讀取給定方程\n    → graph[Ai][Bi] ← val // Ai / Bi = val\n    → graph[Bi][Ai] ← 1/val // Bi / Ai = 1/val\n→ Step 3: 定義函式 dfs(start, target, acc) → // 深度優先搜尋，acc為累積乘積\n    → Decision: 如果 start == target? // 找到目標\n        Yes → Return acc // 返回目前乘積即為答案\n        No  → Decision: 是否已訪問? // 防止循環\n            Yes → Return null // 無法通過此路徑\n            No  → Mark start 為已訪問\n            → Decision: 若 graph[start] 存在? // 遍歷相鄰節點\n                Yes → 對於每個 (nei, w) in graph[start]:\n                    → Decision: 是否已訪問 nei? // 避免重複\n                        Yes → Continue\n                        No  → Result ← dfs(nei, target, acc * w) // 進一步搜尋\n                            → Decision: Result 不為 null? // 找到解\n                                Yes → Return Result\n                                No  → Continue\n                → Return null // 所有路徑都未成功\n→ Step 4: 初始化答案列表 answers ← 空列表\n→ Step 5: 對於每個 (Cj, Dj) in queries: // 處理查詢\n    → Decision: Cj 與 Dj 是否在 graph? // 若不存在變數\n        Yes → Result ← dfs(Cj, Dj, 1.0) // 以 1 為初始乘積\n            → Decision: Result 為 null? // 找不到路徑\n                Yes → Append -1.0 到 answers\n                No  → Append Result 到 answers\n        No  → Append -1.0 到 answers\n→ End // 程式結束\n\nWe need to maintain visited set local to each DFS call. Also need to push and pop? In virtual code we can just denote visited set.\n\nAlso we need to specify Step 3 details. Provide lines accordingly.\n\nOk produce output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化鄰接表 graph ← 空字典 // 建立變數之間的權重圖  \n→ Step 2: 對於每個 (Ai, Bi, val) in equations: // 讀取給定的方程  \n  → graph[Ai][Bi] ← val // Ai / Bi = val  \n  → graph[Bi][Ai] ← 1/val // Bi / Ai = 1/val  \n→ Step 3: 定義函式 dfs(start, target, acc) // 深度優先搜尋，acc 為已累積乘積  \n  → Decision: 若 start == target? // 找到目標變數  \n   Yes → Return acc // 返回累積乘積，即為答案  \n   No → Decision: 若 start 已被訪問? // 防止循環  \n    Yes → Return null // 此路徑無效  \n    No → Mark start 為已訪問  \n    → Decision: graph[start] 是否存在? // 若無相鄰節點直接失敗  \n     Yes → 對於每個 (nei, w) in graph[start]: // 遍歷相鄰節點  \n       → Decision: 若 nei 已被訪問?  \n        Yes → Continue // 跳過已訪問節點  \n        No → Result ← dfs(nei, target, acc * w) // 深入搜尋，乘積更新  \n         → Decision: Result 不為 null? // 找到解  \n          Yes → Return Result // 回傳答案  \n          No → Continue // 其它鄰居繼續搜尋  \n      → Return null // 所有鄰居都失敗，回傳 null  \n→ Step 4: 初始化答案列表 answers ← 空列表  \n→ Step 5: 對於每個 (Cj, Dj) in queries: // 處理每個查詢  \n  → Decision: Cj 與 Dj 是否都存在於 graph? // 若變數未定義  \n   Yes → Result ← dfs(Cj, Dj, 1.0) // 以 1 作為起始乘積  \n    → Decision: Result 為 null? // 找不到連結  \n     Yes → Append -1.0 到 answers // 回傳 -1.0  \n     No → Append Result 到 answers // 回傳計算結果  \n   No → Append -1.0 到 answers // 變數未定義，直接 -1.0  \nEnd // 程式執行結束"
    },
    {
      "title": "Magical String",
      "source_file": "Leetcode/leetcode481.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 6",
          "expected_output": "3",
          "actual_output_or_error": "File \"/tmp/tmpdrp28ngs.py\", line 1\n    <code>\n    ^\nSyntaxError: invalid syntax"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "1",
          "actual_output_or_error": "File \"/tmp/tmpw3mdf034.py\", line 1\n    <code>\n    ^\nSyntaxError: invalid syntax"
        }
      ],
      "generated_code": "<code>",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code for solving: given integer n, return count of 1's in first n numbers of magical string s. The string defined by self-describing property. Known problem \"Magical String\" Leetcode 878. Approach: generate string up to n using two pointers, count ones. Pseudocode. Each line with // explanation. Use Start, End, Decision. Use arrow. Provide step-by-step.\n\nWe need to write in Chinese (繁體). Use \"虛擬碼步驟\". Each line with arrow. We'll include \"Start\", \"End\". We'll include loops and decisions.\n\nLet's design algorithm: Initialize array s of size n (or maybe bigger). s[0] = 1; s[1] = 2; s[2] = 2; idx=3; countOnes=1 (since s[0] is 1). Then while idx < n: groupCount = s[ptr] (ptr tracks current position in s for group length). for i in 1..groupCount: s[idx] = 3 - s[idx-1] (toggle between 1 and 2). if s[idx]==1 countOnes++. idx++; if idx==n break. ptr++; end while. Return countOnes.\n\nBut we might produce more high-level pseudocode.\n\nMake sure to use arrow: \"→\" or \"Yes →\" etc. We'll produce like:\n\nStart\n→ Initialize array s of length n // 存儲魔法字串\n→ Set s[0]=1, s[1]=2, s[2]=2 // 前三個已知\n→ Set idx=3 // 下一個待填入的位置\n→ Set ptr=0 // 用於讀取群組長度\n→ Set countOnes=1 // s[0] 為 1\n→ Decision: idx < n? // 是否已生成足夠長度\n    Yes → Step: groupCount = s[ptr] // 讀取當前群組長度\n    → For i from 1 to groupCount:\n        → Set s[idx] = 3 - s[idx-1] // 切換 1↔2\n        → Decision: s[idx]==1? // 是否為 1\n            Yes → countOnes++ // 1 的個數加 1\n        → idx++ // 移動到下一位置\n        → Decision: idx == n? // 檢查是否已到達目標長度\n            Yes → Break // 結束迴圈\n    → ptr++ // 移動到下一個群組長度\n    → Go back to Decision: idx < n?\n    No  → End // 生成完成\n→ Return countOnes // 回傳 1 的個數\nEnd\n\nNeed to include proper arrow formatting: \"Start // 程式開始執行\". Each line must have \"虛擬碼步驟\" + space + \"// 解釋/說明\".\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ 虛擬碼: 初始化 s[0..n-1] 為空陣列 // 用於存儲魔法字串  \n→ 虛擬碼: s[0] ← 1, s[1] ← 2, s[2] ← 2 // 前三個已知元素  \n→ 虛擬碼: idx ← 3 // 下一個待填入的位置  \n→ 虛擬碼: ptr ← 0 // 讀取群組長度的指標  \n→ 虛擬碼: countOnes ← 1 // s[0] 為 1，初始計數  \n→ Decision: idx < n? // 是否已生成足夠長度  \n Yes → 虛擬碼: groupCount ← s[ptr] // 讀取當前群組長度  \n  → 虛擬碼: for i = 1 to groupCount do // 為該群組產生元素  \n    → 虛擬碼: s[idx] ← 3 - s[idx-1] // 切換 1 ↔ 2  \n    → Decision: s[idx] == 1? // 是否為 1  \n     Yes → 虛擬碼: countOnes ← countOnes + 1 // 1 的個數加 1  \n    → 虛擬碼: idx ← idx + 1 // 移到下一位置  \n    → Decision: idx == n? // 檢查是否已到達目標長度  \n     Yes → 虛擬碼: break // 生成完成，跳出迴圈  \n     No → 虛擬碼: continue // 繼續填充  \n  → 虛擬碼: ptr ← ptr + 1 // 移動到下一個群組長度  \n  → 回到 Decision: idx < n?  \n No  → 虛擬碼: return countOnes // 回傳 1 的個數  \nEnd // 程式執行結束"
    },
    {
      "title": "Concatenated Words",
      "source_file": "Leetcode/leetcode472.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "words = [\"cat\",\"cats\",\"catsdogcats\",\"dog\",\"dogcatsdog\",\"hippopotamuses\",\"rat\",\"ratcatdogcat\"]",
          "expected_output": "[\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]'\nGot (Norm):      '[\"dogcatsdog\",\"catsdogcats\",\"ratcatdogcat\"]'\n--- (Raw) ---\nRaw Expected: '[\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]'\nRaw Got:      '[\"dogcatsdog\",\"catsdogcats\",\"ratcatdogcat\"]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\n\nclass Solution:\n    def findAllConcatenatedWordsInADict(self, words):\n        # 先依字串長度遞增排序，保證短詞先被加入集合\n        words.sort(key=len)\n        word_set = set()\n        result = []\n\n        for word in words:\n            if not word:\n                continue\n            if self._can_form(word, word_set):\n                result.append(word)\n            word_set.add(word)\n        return result\n\n    def _can_form(self, word, word_set):\n        if not word_set:\n            return False\n        dp = [False] * (len(word) + 1)\n        dp[0] = True\n\n        for i in range(1, len(word) + 1):\n            for j in range(0, i):\n                if not dp[j]:\n                    continue\n                if word[j:i] in word_set:\n                    dp[i] = True\n                    break\n        return dp[len(word)]\n\nif __name__ == \"__main__\":\n    # 從 stdin 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 解析輸入為字串列表\n    if data.startswith(\"words\"):\n        # 去除前綴 words = \n        _, list_part = data.split('=', 1)\n        list_str = list_part.strip()\n    else:\n        list_str = data\n\n    try:\n        words = ast.literal_eval(list_str)\n    except Exception:\n        words = []\n\n    # 計算所有連接詞\n    solution = Solution()\n    concatenated_words = solution.findAllConcatenatedWordsInADict(words)\n\n    # 輸出格式：[\"word1\",\"word2\",...]\n    print(json.dumps(concatenated_words, separators=(',', ':')))",
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps for the problem: given array of strings words, return all concatenated words. Steps: sort by length, use set for words, iterate, check via DP if can be formed by two or more words from set excluding current word. So produce virtual code line by line with comments.\n\nWe must use \"Start\", \"End\", \"Decision:\" etc.\n\nWe need to not produce actual code but pseudocode lines. So produce line by line. Let's outline:\n\nStart\n→ Step 1: Initialize result list // empty\n→ Step 2: Sort words by length ascending // ensures shorter words first\n→ Step 3: Initialize wordSet // empty set\n→ For each word in sorted words: // loop\n    → Decision: word in wordSet? // if word already considered\n        No → Step 4: Add word to wordSet // add to set\n    → Decision: CanFormByOthers(word, wordSet)? // DP check\n        Yes → Step 5: Append word to result\n    → End loop\n→ Step 6: Return result\nEnd\n\nBut we need to detail DP check. Maybe we create helper function CanFormByOthers. But pseudocode lines can include that function. Let's create:\n\n→ Function CanFormByOthers(target, wordSet): // returns true if target can be built by at least two words\n    → Step a: If target empty return false\n    → Step b: Initialize dp[0] = true\n    → For i from 1 to len(target):\n        → Decision: For j from 0 to i-1:\n            → Decision: dp[j] and target[j:i] in wordSet? // substring check\n                Yes → dp[i] = true\n                No → continue\n        → Decision: dp[i]? continue\n    → Decision: dp[len(target)]? // if true and at least one split\n        Yes → Step: Count number of words used? Actually dp doesn't track count, but we can ensure at least two by verifying that we didn't consider the whole word as one. Since wordSet excludes current word, we can simply return dp[len(target)].\n\nBut to guarantee at least two words: since target not in wordSet, if dp[len] true then it uses at least one word, but could be only one word? But target not in wordSet, so can't be single word, so at least two. Good.\n\nWe'll produce lines inside the function.\n\nWe need to maintain virtual code arrow.\n\nLet's produce.\n\nWe need to use the arrow \"→\" before each step, and for decisions \"Decision:\".\n\nLet's produce.\n\nWill produce Start // start\n\n→ Step 1: wordsSorted = Sort words ascending by length // 排序\n\n→ Step 2: result = [] // 初始化结果\n\n→ Step 3: wordSet = EmptySet // 用於快速查找\n\n→ For each word in wordsSorted: // 迭代\n    → Decision: word in wordSet? // 已經處理過\n        Yes → Continue // 跳過\n        No  → Step 4: Add word to wordSet // 加入集合\n\n    → Decision: CanFormByOthers(word, wordSet)? // 判斷是否為連接詞\n        Yes → Step 5: Append word to result // 加入結果\n\n→ Step 6: Return result // 返回\n\n→ Function CanFormByOthers(target, wordSet): // 判斷是否可用其他單詞組合\n    → Step a: dp = array of bool length len(target)+1 // dp[i] 表示前 i 個字符可組合\n    → dp[0] = true\n    → For i from 1 to len(target): // 遍歷每個位置\n        → Decision: Any j < i where dp[j] and target[j:i] in wordSet?\n            Yes → dp[i] = true // 找到可拆分方式\n            No  → dp[i] = false // 無法拆分\n    → Decision: dp[len(target)]? // 最後位置可拆分\n        Yes → Return true\n        No  → Return false\n\nEnd // 結束\n\nWe need to ensure each line uses '→' at the start, except Start/End.\n\nAlso we need to add comments after //.\n\nAlso need \"Decision:\" lines for decisions.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: wordsSorted ← Sort words by ascending length // 先按字串長度遞增排序  \n→ Step 2: result ← [] // 用來存放所有符合條件的連接詞  \n→ Step 3: wordSet ← EmptySet // 快速查找已處理過的單詞  \n→ For each word in wordsSorted: // 逐個處理每個單詞  \n  → Decision: word ∈ wordSet? // 該單詞是否已被加入集合？  \n   Yes → Continue // 若已存在，直接跳過  \n   No  → Step 4: wordSet.Add(word) // 加入集合，以供後續查找  \n  → Decision: CanFormByOthers(word, wordSet)? // 判斷該單詞是否由其他單詞組合而成  \n   Yes → Step 5: result.Add(word) // 若是，加入結果列表  \n→ Step 6: Return result // 回傳所有連接詞  \n→ Function CanFormByOthers(target, wordSet): // 判斷 target 是否能由 wordSet 中的單詞拼成  \n  → Step a: dp ← BoolArray(length(target)+1) // dp[i] 表示前 i 個字符能否組合  \n  → dp[0] ← true // 空前綴始終可組合  \n  → For i from 1 to length(target): // 逐個位置檢查  \n    → Decision: ∃ j < i such that dp[j] == true AND target[j:i] ∈ wordSet? // 是否存在可拆分點  \n     Yes → dp[i] ← true // 找到有效拆分  \n     No  → dp[i] ← false // 無法拆分  \n  → Decision: dp[length(target)]? // 最後位置能否組合  \n   Yes → Return true  \n   No  → Return false  \nEnd // 程式執行結束"
    },
    {
      "title": "Generate Random Point in a Circle",
      "source_file": "Leetcode/leetcode478.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]",
          "expected_output": "[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[-0.02493,-0.38077],[0.82314,0.38945],[0.36572,0.17248]]'\nGot (Norm):      '[null,[-0.3903136540982065,-0.013237967524485517],[-0.31125953978214993,-0.461860867516952],[0.4390895512680637,0.2475938023696347]]'\n--- (Raw) ---\nRaw Expected: '[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]'\nRaw Got:      '[null, [-0.3903136540982065, -0.013237967524485517], [-0.31125953978214993, -0.461860867516952], [0.4390895512680637, 0.2475938023696347]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport math\n\nclass Solution:\n    def __init__(self, radius: float, x_center: float, y_center: float):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n\n    def randPoint(self):\n        # 隨機產生半徑與角度，確保點均勻分布在圓內\n        r = self.radius * math.sqrt(random.random())\n        theta = random.uniform(0, 2 * math.pi)\n        x = self.x_center + r * math.cos(theta)\n        y = self.y_center + r * math.sin(theta)\n        return [x, y]\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if len(data) < 2:\n        return\n    methods = json.loads(data[0])\n    args_list = json.loads(data[1])\n\n    outputs = []\n    obj = None\n    for method, args in zip(methods, args_list):\n        if method == \"Solution\":\n            obj = Solution(*args)\n            outputs.append(None)          # 典型 LeetCode 需要 null\n        else:\n            # 取得對應方法並執行\n            func = getattr(obj, method)\n            result = func()\n            outputs.append(result)\n\n    # 輸出為 JSON 形式，None 會轉為 null\n    print(json.dumps(outputs, ensure_ascii=False))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for implementing this. The algorithm: Use rejection sampling: generate random radius sqrt(rand)*R, random angle uniform [0,2π). Then convert to cartesian: x_center + r*cosθ, y_center + r*sinθ. Steps: start, constructor stores radius, center; randPoint: generate random angle, random radius via sqrt; compute coordinates; return array.\n\nUse virtual code lines with explanation. Include decisions maybe for generating random. Could include Decision: maybe for generating radius.\n\nLet's write.\n\nWe'll produce like:\n\nStart\n→ Step 1: Store radius, x_center, y_center // initialize object\nEnd // constructor done\nThen randPoint method:\n\nStart // randPoint start\n→ Step 1: Generate random angle θ uniformly between 0 and 2π // 用於角度\n→ Step 2: Generate random value u uniformly [0,1] // 用於半徑\n→ Decision: compute r = radius * sqrt(u) // 轉換為均勻分佈半徑\n    // Actually no decision needed\n→ Step 3: Compute x = x_center + r * cos(θ) // 計算 x 坐標\n→ Step 4: Compute y = y_center + r * sin(θ) // 計算 y 坐標\n→ Step 5: Return [x, y] // 返回點\nEnd // randPoint finish\n\nBut need virtual code syntax: maybe include Decision: but we don't need. We can just list steps.\n\nMake sure each line: \"虛擬碼步驟 // 解釋\".\n\nUse arrow \"→\". For constructor, we can show as \"→ Constructor: Store radius, x_center, y_center\".\n\nLet's produce.\n\nAlso use \"End\" after constructor? They didn't require separate. We can just have method. But to follow pattern, maybe show \"Start\" for class init and for method. Provide \"End\".\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Constructor: 初始化 radius, x_center, y_center // 存儲圓心座標與半徑\nEnd // 建構子完成\n\nStart // randPoint 方法開始\n→ Step 1: θ ← Uniform(0, 2π) // 產生隨機角度\n→ Step 2: u ← Uniform(0, 1) // 產生隨機值用於半徑計算\n→ Step 3: r ← radius * sqrt(u) // 把均勻分佈映射到半徑，確保點均勻分布\n→ Step 4: x ← x_center + r * cos(θ) // 計算點的 x 坐標\n→ Step 5: y ← y_center + r * sin(θ) // 計算點的 y 坐標\n→ Step 6: Return [x, y] // 返回隨機點\nEnd // randPoint 方法結束"
    },
    {
      "title": "Remove Element",
      "source_file": "Leetcode/leetcode27.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [3,2,2,3], val = 3",
          "expected_output": "2, nums = [2,2,_,_]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2,nums=[2,2,_,_]'\nGot (Norm):      '2,nums=[2,2,\"_\",\"_\"]'\n--- (Raw) ---\nRaw Expected: '2, nums = [2,2,_,_]'\nRaw Got:      \"2, nums = [2, 2, '_', '_']\""
        },
        {
          "example_index": 1,
          "input": "nums = [0,1,2,2,3,0,4,2], val = 2",
          "expected_output": "5, nums = [0,1,3,0,4,_,_,_]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '5,nums=[0,1,3,0,4,_,_,_]'\nGot (Norm):      '5,nums=[0,1,3,0,4,\"_\",\"_\",\"_\"]'\n--- (Raw) ---\nRaw Expected: '5, nums = [0,1,3,0,4,_,_,_]'\nRaw Got:      \"5, nums = [0, 1, 3, 0, 4, '_', '_', '_']\""
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def removeElement(self, nums, val):\n        \"\"\"\n        移除 nums 中所有等於 val 的元素，並返回剩餘元素的數量 k。\n        這個實作使用兩個指標：fast 遍歷整個陣列，slow 追蹤不等於 val 的元素位置。\n        \"\"\"\n        slow = 0\n        for fast in range(len(nums)):\n            if nums[fast] != val:\n                nums[slow] = nums[fast]\n                slow += 1\n        return slow\n\ndef main():\n    \"\"\"\n    讀取標準輸入，格式類似：\n        nums = [3,2,2,3], val = 3\n    解析後執行 removeElement，並輸出結果：\n        k, nums = [2,2,_,_]\n    \"\"\"\n    data = sys.stdin.read().strip()\n    # 用正則表達式提取 nums 列表和 val 數值\n    nums_match = re.search(r'nums\\s*=\\s*(\\[[^\\]]*\\])', data)\n    val_match = re.search(r'val\\s*=\\s*(-?\\d+)', data)\n    if not nums_match or not val_match:\n        return\n\n    nums = eval(nums_match.group(1))\n    val = int(val_match.group(1))\n\n    sol = Solution()\n    k = sol.removeElement(nums, val)\n\n    # 用 '_' 代表未使用的位置，符合範例輸出格式\n    result_list = nums[:k] + ['_'] * (len(nums) - k)\n    print(f\"{k}, nums = {result_list}\")\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm remove element in place. Should output lines as described. Use Start, Decision, etc. Provide explanation after each line. Ensure each line ends with // explanation. Use arrow for step lines. Format exactly as sample. Let's craft algorithm: Use two pointers: left at 0, right at n-1. While left <= right: if nums[left]==val: swap nums[left] with nums[right]; right--; else left++. After loop, return left as k.\n\nAlternatively use one pointer i and write index j for place to keep. Simpler: i iterate, if nums[i]!=val: nums[j]=nums[i]; j++. Return j. Provide virtual steps.\n\nWe'll produce virtual steps accordingly. Use Start, Step, Decision, End. Let's write. Ensure each line: \"Start // 程式開始執行\" etc. Use arrow symbol \"→\". For decisions use \"Decision:\" line and indent substeps.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化變數 j = 0 // 記錄下一個不等於 val 的位置  \n→ Step 2: 從 i = 0 到 nums.length - 1 迭代 // 逐一檢查每個元素  \n  Decision: nums[i] 是否等於 val? // 判斷當前元素是否要刪除  \n   Yes → // 如果等於 val，跳過此元素  \n    Step 3: 直接不做任何操作，繼續下一個 i  \n   No → // 如果不等於 val，保留此元素  \n    Step 4: nums[j] = nums[i] // 把元素移到前面  \n    Step 5: j = j + 1 // 移動 j 指向下一個可寫位置  \n→ Step 6: 循環結束後 j 為不等於 val 的元素個數 // j 就是 k  \n→ Step 7: 回傳 j // 返回新長度 k  \nEnd // 程式執行結束"
    },
    {
      "title": "Shuffle an Array",
      "source_file": "Leetcode/leetcode384.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"], [[[1, 2, 3]], [], [], []]",
          "expected_output": "[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[3,1,2],[1,2,3],[1,3,2]]'\nGot (Norm):      '[null,[3,2,1],[1,2,3],[1,3,2]]'\n--- (Raw) ---\nRaw Expected: '[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]'\nRaw Got:      '[null, [3, 2, 1], [1, 2, 3], [1, 3, 2]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\n\nclass Solution:\n    \"\"\" 隨機洗牌的實作，採用 Fisher-Yates 演算法 \"\"\"\n    def __init__(self, nums):\n        # 儲存原始陣列，並確保為獨立拷貝\n        self.original = list(nums)\n\n    def reset(self):\n        \"\"\" 重新回到原始順序 \"\"\"\n        return list(self.original)\n\n    def shuffle(self):\n        \"\"\" 隨機洗牌，所有排列等機率 \"\"\"\n        arr = list(self.original)           # 先拷貝原始陣列\n        n = len(arr)\n        for i in range(n - 1, 0, -1):        # 從尾到頭\n            j = random.randint(0, i)        # 隨機選擇 0~i 的索引\n            arr[i], arr[j] = arr[j], arr[i] # 交換\n        return arr\n\ndef main():\n    # 讀取整個 stdin，並去除首尾空白\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n    # 解析成兩個列表：commands 與 args\n    try:\n        data = json.loads('[' + raw_input + ']')\n    except json.JSONDecodeError as e:\n        # 若輸入格式不符，直接結束\n        print(f\"Invalid input: {e}\", file=sys.stderr)\n        return\n    commands, args_list = data[0], data[1]\n\n    result = []\n    obj = None  # Solution 實例\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"Solution\":\n            # args 為 [[nums]]，取第一個元素作為 nums\n            obj = Solution(args[0])\n            result.append(None)  # 按照 LeetCode 的 null 需求\n        elif cmd == \"reset\":\n            result.append(obj.reset())\n        elif cmd == \"shuffle\":\n            result.append(obj.shuffle())\n        else:\n            # 若有未知指令，忽略\n            result.append(None)\n\n    # 將結果轉成 JSON 字串並輸出\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code steps for the algorithm described: shuffling an array with uniform probability, resetting to original. Classic algorithm: Fisher-Yates shuffle. We'll produce virtual code lines, with step numbering, decisions, etc. Must not output actual code. Use Start, End, Decision:, Yes → etc.\n\nWe need to include initialization, reset, shuffle, maybe helper function to shuffle array. Provide lines with explanation.\n\nLet's craft steps:\n\nStart\n→ Step 1: 初始化 Solution(nums) → Store original array copy and current array.\n→ Step 2: 定義 reset() 函式 → 複製 original array 回 current array\n→ Step 3: 定義 shuffle() 函式 → 取得 current array 的長度 n\n→ Step 4: For i from n-1 down to 1:\n   → Step 5: 產生隨機整數 j 在 [0,i]\n   → Step 6: 交換 current[i] 與 current[j]\n→ Step 7: 回傳 current array\n\nAlso ensure that reset returns original.\n\nWe'll produce each step line with explanation. Use \"Start\" and \"End\".\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 Solution(nums) // 將輸入的數組複製為 original，並複製為 current  \n→ Step 2: 定義 reset() 函式 // 用於恢復原始順序  \n  → Step 3: 將 current 重新設為 original 的深拷貝 // 確保不改動原始數組  \n  → Step 4: 回傳 current // 回傳重置後的數組  \n→ Step 5: 定義 shuffle() 函式 // 用於隨機打亂 current  \n  → Step 6: 設定 n 為 current 的長度 // 用於迴圈控制  \n  → Decision: n 是否小於等於 1? // 如果只有 0 或 1 個元素，無需打亂  \n   Yes → Step 7: 回傳 current // 直接回傳  \n   No → Step 8: 從 i = n-1 到 1 迴圈  \n    → Step 9: 隨機生成整數 j 在 [0, i] // Fisher-Yates 交換索引  \n    → Step 10: 交換 current[i] 與 current[j] // 進行一次交換  \n   → Step 11: 迴圈結束  \n  → Step 12: 回傳 current // 返回隨機排列的數組  \nEnd // 程式執行結束"
    },
    {
      "title": "Subsets",
      "source_file": "Leetcode/leetcode78.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nGot (Norm):      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nRaw Got:      '[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def subsets(self, nums):\n        res = []\n        def backtrack(start, path):\n            res.append(path[:])\n            for i in range(start, len(nums)):\n                path.append(nums[i])\n                backtrack(i + 1, path)\n                path.pop()\n        backtrack(0, [])\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    # 找出第一個 '[' 與最後一個 ']' 之間的子字串，並轉成 Python list\n    try:\n        l = data.index('[')\n        r = data.rindex(']')\n        nums = ast.literal_eval(data[l:r+1])\n    except (ValueError, SyntaxError):\n        # 如果無法找到或解析，假設輸入本身就是 list 表示\n        nums = ast.literal_eval(data.strip())\n    solution = Solution()\n    result = solution.subsets(nums)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce a virtual code, line by line, following the format. Each line: virtual code step + space + // explanation. Use arrow notation: →, Yes →, No →. Use Start, End, Decision:. The problem: generate all subsets of unique integers. Approach: backtracking / recursion, iterative building. Provide pseudocode. We need to be careful to use virtual code, not actual code. Use \"Step X:\" etc. Each line includes explanation. We should include Start and End. Use Decision for branching.\n\nLet's produce pseudocode: Start, Step 1: Initialize result list, Step 2: Define backtrack function with index and current subset, Step 3: Decision if index == length: add copy to result. Yes → Step 4: Add subset. No → Step 5: Decision: include current element? Actually backtrack: include current element in subset then recurse, then exclude it. So Step 5: Decision: Include element? But we can simply do: Step 5: include nums[index] in subset → Step 6: call backtrack(index+1, subset) → Step 7: remove last element (backtrack). Step 8: call backtrack(index+1, subset) (exclude). End recursion. After define, call backtrack(0, empty). Step 9: Return result. End.\n\nWe need to ensure each line includes explanation. Use arrow arrows. Let's create the lines.\n\nNeed to show decisions properly: for recursion termination: Decision: If index == len(nums)? Yes → Step add subset. No → proceed. Also decisions for including/excluding? Might not be needed as separate decisions; we can just include two recursive calls.\n\nLet's write lines:\n\nStart // 程式開始執行\n→ Step 1: Initialize result as empty list // 用於儲存所有子集\n→ Step 2: Define function Backtrack(index, currentSubset) // 回溯函式，index 為當前處理位置\n    → Decision: index == length of nums? // 檢查是否已經處理完所有元素\n        Yes → Step 3: Add copy of currentSubset to result // 把目前子集加入結果\n        No  → Step 4: Add nums[index] to currentSubset // 包含當前元素\n        → Step 5: Call Backtrack(index + 1, currentSubset) // 進一步遞迴\n        → Step 6: Remove last element from currentSubset // 回溯，移除剛才加入的元素\n        → Step 7: Call Backtrack(index + 1, currentSubset) // 不包含當前元素，遞迴\n→ Step 8: Call Backtrack(0, empty list) // 開始回溯\n→ Step 9: Return result // 返回所有子集\nEnd // 程式執行結束\n\nWe need to ensure indentation and arrow usage: For decisions we can indent the Yes/No branches. Use arrow before substeps too.\n\nBut the specification: \"Use virtual code's arrow (→, Yes →, No →) and structure (Start, End, Decision:).\" So we can use nested arrow indentation. We must put a space after arrow and then step. Each line must have \"虛擬碼步驟 [空格] // 解釋/說明\". For decision lines: \"Decision: ...?\" So we can do:\n\nDecision: index == nums.length? // 檢查是否已經處理完所有元素\n    Yes → Step 3: ... // explanation\n    No  → Step 4: ... // explanation\n    No → ... // but we need to include other steps under No? Actually the No branch includes steps 4-7. We can indent them accordingly. But we can also separate them as separate lines, but then they wouldn't be under No? Might need to indent but still each line separate.\n\nBetter to produce:\n\nDecision: index == nums.length? // 檢查是否已經處理完所有元素\n    Yes → Step 3: Add copy of currentSubset to result // 把目前子集加入結果\n    No  → Step 4: Add nums[index] to currentSubset // 包含當前元素\n    No  → Step 5: Call Backtrack(index + 1, currentSubset) // 進一步遞迴\n    No  → Step 6: Remove last element from currentSubset // 回溯，移除剛才加入的元素\n    No  → Step 7: Call Backtrack(index + 1, currentSubset) // 不包含當前元素，遞迴\n\nBut the specification may want nested structure. However we can keep it simple.\n\nWe need to maintain that each line has \"虛擬碼步驟 [空格] // 解釋\". Let's produce lines accordingly.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Initialize result as empty list // 用於儲存所有子集  \n→ Step 2: Define function Backtrack(index, currentSubset) // 回溯函式，index 為當前處理位置  \n→     Decision: index == length of nums? // 檢查是否已經處理完所有元素  \n→         Yes → Step 3: Add copy of currentSubset to result // 把目前子集加入結果  \n→         No  → Step 4: Add nums[index] to currentSubset // 包含當前元素  \n→         No  → Step 5: Call Backtrack(index + 1, currentSubset) // 進一步遞迴  \n→         No  → Step 6: Remove last element from currentSubset // 回溯，移除剛才加入的元素  \n→         No  → Step 7: Call Backtrack(index + 1, currentSubset) // 不包含當前元素，遞迴  \n→ Step 8: Call Backtrack(0, empty list) // 開始回溯  \n→ Step 9: Return result // 返回所有子集  \nEnd // 程式執行結束"
    },
    {
      "title": "Maximum Matching of Players With Trainers",
      "source_file": "Leetcode/leetcode2410.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "players = [4,7,9], trainers = [8,2,5,8]",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpcw4ef0f4.py\", line 42, in <module>\n    main()\n  File \"/tmp/tmpcw4ef0f4.py\", line 32, in main\n    trainers_str = trainers_part.split('=')[1].strip()\n                   ~~~~~~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        },
        {
          "example_index": 1,
          "input": "players = [1,1,1], trainers = [10]",
          "expected_output": "1",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpegukb3hv.py\", line 42, in <module>\n    main()\n  File \"/tmp/tmpegukb3hv.py\", line 32, in main\n    trainers_str = trainers_part.split('=')[1].strip()\n                   ~~~~~~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def matchPlayersAndTrainers(self, players, trainers):\n        players.sort()\n        trainers.sort()\n        i = j = matches = 0\n        while i < len(players) and j < len(trainers):\n            if players[i] <= trainers[j]:\n                matches += 1\n                i += 1\n            j += 1\n        return matches\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Normalize input: replace newlines and extra spaces\n    data = data.replace('\\n', ' ').strip()\n    # Split the two parts\n    try:\n        players_part, trainers_part = data.split(', trainers =')\n    except ValueError:\n        # Fallback if input format is different\n        players_part, trainers_part = data.split('trainers =')\n        if 'players =' in players_part:\n            players_part = players_part.split('players =')[1]\n    # Extract the list strings\n    players_str = players_part.split('=')[1].strip()\n    trainers_str = trainers_part.split('=')[1].strip()\n    # Safely evaluate the list literals\n    players = ast.literal_eval(players_str)\n    trainers = ast.literal_eval(trainers_str)\n    # Compute the answer\n    solution = Solution()\n    result = solution.matchPlayersAndTrainers(players, trainers)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm: match players to trainers with ability <= capacity, maximum matching one-to-one. Classic greedy: sort both arrays, then two pointers. For each trainer, if trainer capacity >= current player ability, match and move to next player and next trainer. Count. Complexity O(n log n). Provide virtual code steps line by line with explanation.\n\nWe should produce steps like:\n\nStart\n→ Step 1: Sort players ascending\n→ Step 2: Sort trainers ascending\n→ Step 3: Initialize i = 0, j = 0, count = 0\n→ Decision: 如果 i < len(players) and j < len(trainers) ?\n   Yes → Decision: 如果 trainers[j] >= players[i] ?\n       Yes → Step 4: count++, i++, j++\n       No → Step 5: j++ // trainer too weak, try next trainer\n   No → End\n\nBut need to follow format: each line: virtual code step + space + // explanation.\n\nUse arrows. Use Decision: etc.\n\nLet's craft.\n\nWe may use indentation for nested decisions as in example. Use tab? Probably spaces.\n\nWe'll produce something like:\n\nStart // 程式開始執行\n→ Step 1: Sort(players) ascending // 將玩家能力由小到大排序\n→ Step 2: Sort(trainers) ascending // 將訓練師容量由小到大排序\n→ Step 3: i = 0 // 指向目前考慮的玩家\n→ Step 4: j = 0 // 指向目前考慮的訓練師\n→ Step 5: matched = 0 // 已匹配對數\n→ Decision: i < len(players) 且 j < len(trainers) ? // 仍有玩家與訓練師可比對\n    Yes → Decision: trainers[j] >= players[i] ? // 訓練師能滿足玩家\n        Yes → Step 6: matched++ // 匹配成功\n               i++ // 移至下一位玩家\n               j++ // 移至下一位訓練師\n        No  → Step 7: j++ // 訓練師太弱，嘗試下一位訓練師\n    No  → End // 沒有更多可比對\n\nBut we need to include \"End\" line. Add final.\n\nAlso note that after matched++ we need to increment both pointers. We'll do separate steps.\n\nSo we need line with \"End\". Format: End // 程式執行結束\n\nMake sure each line starts with the virtual code step, like \"Start\", \"→ Step 1:\" etc. Provide comment after space. Example: \"Start // 程式開始執行\". Use arrow lines starting with \"→\". For decisions, use \"Decision:\".\n\nWe should use Chinese comments. Ensure we don't output actual code, just steps.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort(players) ascending // 將玩家能力由小到大排序  \n→ Step 2: Sort(trainers) ascending // 將訓練師容量由小到大排序  \n→ Step 3: i = 0 // 指向目前考慮的玩家索引  \n→ Step 4: j = 0 // 指向目前考慮的訓練師索引  \n→ Step 5: matched = 0 // 已成功匹配的數量  \n→ Decision: i < len(players) 且 j < len(trainers) ? // 仍有玩家與訓練師未處理  \n    Yes → Decision: trainers[j] >= players[i] ? // 訓練師能滿足玩家需求  \n        Yes → Step 6: matched++ // 成功匹配一對  \n               i++ // 移至下一位玩家  \n               j++ // 移至下一位訓練師  \n        No  → Step 7: j++ // 訓練師容量不足，嘗試下一位訓練師  \n    No  → End // 沒有更多可匹配的玩家或訓練師  \nEnd // 程式執行結束"
    },
    {
      "title": "LFU Cache",
      "source_file": "Leetcode/leetcode460.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"LFUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"get\", \"put\", \"get\", \"get\", \"get\"], [[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]",
          "expected_output": "[null, null, null, 1, null, -1, 3, null, -1, 3, 4]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp142il8mb.py\", line 89, in <module>\n    main()\n  File \"/tmp/tmp142il8mb.py\", line 57, in main\n    args = ast.literal_eval(match.group(2))\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[2]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport re\nfrom collections import defaultdict, OrderedDict\n\nclass LFUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.min_freq = 0\n        self.key_to_val_freq = {}\n        self.freq_to_keys = defaultdict(OrderedDict)\n\n    def _update(self, key: int):\n        value, freq = self.key_to_val_freq[key]\n        # remove from old frequency list\n        del self.freq_to_keys[freq][key]\n        if not self.freq_to_keys[freq]:\n            del self.freq_to_keys[freq]\n            if self.min_freq == freq:\n                self.min_freq += 1\n        # add to new frequency list\n        self.freq_to_keys[freq + 1][key] = None\n        self.key_to_val_freq[key] = (value, freq + 1)\n\n    def get(self, key: int) -> int:\n        if key not in self.key_to_val_freq:\n            return -1\n        self._update(key)\n        return self.key_to_val_freq[key][0]\n\n    def put(self, key: int, value: int) -> None:\n        if self.capacity == 0:\n            return\n        if key in self.key_to_val_freq:\n            self.key_to_val_freq[key] = (value, self.key_to_val_freq[key][1])\n            self._update(key)\n            return\n        if len(self.key_to_val_freq) >= self.capacity:\n            # evict least frequently used key\n            evict_key, _ = self.freq_to_keys[self.min_freq].popitem(last=False)\n            del self.key_to_val_freq[evict_key]\n            if not self.freq_to_keys[self.min_freq]:\n                del self.freq_to_keys[self.min_freq]\n        self.key_to_val_freq[key] = (value, 1)\n        self.freq_to_keys[1][key] = None\n        self.min_freq = 1\n\ndef main():\n    data = sys.stdin.read().strip()\n    # strip outer quotes if present\n    if data.startswith(\"'\") and data.endswith(\"'\"):\n        data = data[1:-1]\n    # try to parse two lists separated by comma\n    match = re.match(r'\\s*(\\[[^\\]]*\\])\\s*,\\s*(\\[[^\\]]*\\])\\s*', data)\n    if match:\n        methods = ast.literal_eval(match.group(1))\n        args = ast.literal_eval(match.group(2))\n    else:\n        # fallback: separate by newlines\n        parts = [p for p in data.splitlines() if p.strip()]\n        if len(parts) >= 2:\n            methods = ast.literal_eval(parts[0].strip())\n            args = ast.literal_eval(parts[1].strip())\n        else:\n            methods, args = [], []\n\n    results = []\n    cache = None\n    for method, arg in zip(methods, args):\n        if method == \"LFUCache\":\n            cache = LFUCache(arg[0])\n            results.append(None)\n        elif method == \"put\":\n            cache.put(arg[0], arg[1])\n            results.append(None)\n        elif method == \"get\":\n            val = cache.get(arg[0])\n            results.append(val)\n    # format output\n    output = []\n    for r in results:\n        if r is None:\n            output.append(\"null\")\n        else:\n            output.append(str(r))\n    print(\"[\" + \", \".join(output) + \"]\")\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode lines with explanations. The code is for LFU cache, with O(1) operations. Use dictionary for key->node, frequency list of doubly linked lists. Use global min frequency.\n\nWe need to design steps: initialize, get, put, helper to increase frequency, evict.\n\nWe must produce line-by-line pseudocode. Each line \"虛擬碼步驟\" followed by space and \"// explanation\". Use Start, End, Decision.\n\nWe need to present algorithm: On get(key): if not exist return -1; else get node, update frequency: remove node from freq list, increment freq, add to new freq list, update minfreq if needed. return value.\n\nOn put(key,val): if capacity==0 return; if key exists: update value and freq as above. Else: if size==capacity: evict: find minfreq list, remove LRU (head). Then add new node with freq=1 to freq list, add to map, set minfreq=1. End.\n\nNeed to structure pseudocode with lines.\n\nWe need to output lines like \"Start // 程式開始執行\" etc.\n\nWe need to ensure each line has explanation.\n\nLet's create pseudocode:\n\nStart\n→ Define class LFUCache\n→ Initialize: capacity, size=0, minFreq=0, keyMap = {} // key to node\n→ freqMap = {} // freq to linked list of nodes\nEnd\n\nBut we need a more detailed algorithm. Use steps like \"InitializeCapacity\" etc.\n\nWe can structure like:\n\nStart // 程式開始執行\n→ Define Node // 表示鍵值對及其頻率\n    → Node.key, Node.value, Node.freq, Node.prev, Node.next\n→ Define DoublyLinkedList // 用於同頻率鍵的 LRU\n    → head, tail, size, addNode(node), removeNode(node), removeTail() // 移除最舊\n→ Define LFUCache class\n    → Constructor(capacity)\n        → this.capacity = capacity\n        → this.size = 0\n        → this.minFreq = 0\n        → this.keyMap = {} // key -> node\n        → this.freqMap = {} // freq -> DoublyLinkedList\n    → get(key)\n        → if key not in keyMap return -1\n        → node = keyMap[key]\n        → incrementFreq(node)\n        → return node.value\n    → put(key,value)\n        → if capacity == 0 return\n        → if key in keyMap\n            → node = keyMap[key]\n            → node.value = value\n            → incrementFreq(node)\n        → else\n            → if size == capacity\n                → evict()\n            → create new node with freq=1\n            → add node to keyMap\n            → add node to freqMap[1] list\n            → minFreq = 1\n            → size++\n    → incrementFreq(node)\n        → freq = node.freq\n        → remove node from freqMap[freq]\n        → if freqMap[freq] empty and freq == minFreq\n            → minFreq++\n        → node.freq++\n        → if freqMap[node.freq] not exists create new list\n        → add node to freqMap[node.freq]\n    → evict()\n        → list = freqMap[minFreq]\n        → node = list.removeTail()\n        → delete keyMap[node.key]\n        → size--\n\nWe can present each step as a line with explanation.\n\nLet's generate line by line. We need to include all lines sequentially.\n\nUse indentation? We can just list lines with arrows. The spec: Use arrow \"→\". For decisions use \"Decision:\".\n\nWe need to show logic. Might use \"Decision:\" for loops? It's fine.\n\nLet's produce the lines. Ensure each line has \"虛擬碼步驟\" plus space then \"// explanation\". For comments in Chinese.\n\nOk produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Define Node // 定義節點結構，存放 key、value、頻率及雙向鏈表指標  \n    → Node.key, Node.value, Node.freq, Node.prev, Node.next  \n→ Define DoublyLinkedList // 同頻率鍵的 LRU 容器  \n    → head, tail, size  \n    → addNode(node) // 在 head 之後加入節點，保持 LRU 順序  \n    → removeNode(node) // 從鏈表任意位置移除節點  \n    → removeTail() // 移除並返回 tail 前一節點（最舊使用）  \n→ Define LFUCache class // LFUCache 主類別  \n    → Constructor(capacity) // 初始化容量、計數器及映射表  \n        → this.capacity = capacity  \n        → this.size = 0 // 當前儲存鍵數量  \n        → this.minFreq = 0 // 最小頻率值  \n        → this.keyMap = {} // key → Node  \n        → this.freqMap = {} // freq → DoublyLinkedList  \n    → get(key) // 取得 key 的值，若不存在回 -1  \n        → if key not in this.keyMap return -1 // Key 不存在  \n        → node = this.keyMap[key] // 取得節點  \n        → this.incrementFreq(node) // 更新頻率  \n        → return node.value // 返回值  \n    → put(key, value) // 插入或更新鍵值  \n        → if this.capacity == 0 return // 容量為 0 時直接返回  \n        → if key in this.keyMap // 已存在，更新 value 與頻率  \n            → node = this.keyMap[key]  \n            → node.value = value  \n            → this.incrementFreq(node)  \n        → else // 新鍵入，先檢查是否需要淘汰  \n            → if this.size == this.capacity // 已滿，先 evict  \n                → this.evict()  \n            → node = new Node(key, value) // 頻率初始為 1  \n            → node.freq = 1  \n            → this.keyMap[key] = node  \n            → if 1 not in this.freqMap this.freqMap[1] = new DoublyLinkedList()  \n            → this.freqMap[1].addNode(node) // 加入頻率 1 的 LRU 列表  \n            → this.minFreq = 1 // 新插入鍵的頻率為 1，重設 minFreq  \n            → this.size++ // 更新已存鍵數  \n    → incrementFreq(node) // 將節點頻率 +1 並重新定位於 freqMap  \n        → oldFreq = node.freq  \n        → this.freqMap[oldFreq].removeNode(node) // 從舊頻率列表移除  \n        → if this.freqMap[oldFreq].size == 0 and oldFreq == this.minFreq // 若舊頻率列表已空且為 minFreq  \n            → this.minFreq++ // minFreq 上升到下一個存在頻率  \n        → node.freq++ // 更新頻率  \n        → if node.freq not in this.freqMap this.freqMap[node.freq] = new DoublyLinkedList() // 建立新頻率列表  \n        → this.freqMap[node.freq].addNode(node) // 加入新頻率列表  \n    → evict() // 從 cache 淘汰最少頻率且最舊的鍵  \n        → list = this.freqMap[this.minFreq] // 取得 minFreq 對應的 LRU 列表  \n        → node = list.removeTail() // 移除最舊節點  \n        → delete this.keyMap[node.key] // 從 key 映射刪除  \n        → this.size-- // 減少已存鍵數  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick with Weight",
      "source_file": "Leetcode/leetcode528.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"], [[[1,3]],[],[],[],[],[]]",
          "expected_output": "[null,1,1,1,1,0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,1,1,1,1,0]'\nGot (Norm):      '[null,0,1,1,0,1]'\n--- (Raw) ---\nRaw Expected: '[null,1,1,1,1,0]'\nRaw Got:      '[null, 0, 1, 1, 0, 1]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport bisect\n\nclass Solution:\n    \"\"\"\n    建立一個前綴和陣列 prefix_sum，用於快速定位隨機點落在的區間。\n    \"\"\"\n    def __init__(self, w):\n        self.prefix_sum = []\n        total = 0\n        for weight in w:\n            total += weight\n            self.prefix_sum.append(total)\n        self.total = total\n\n    def pickIndex(self):\n        \"\"\"\n        隨機產生一個 1 ~ total 的整數，然後在 prefix_sum 中做 binary search\n        找出第一個 >= 目標值的索引，即為回傳的結果。\n        \"\"\"\n        target = random.randint(1, self.total)\n        return bisect.bisect_left(self.prefix_sum, target)\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    input_str = sys.stdin.read().strip()\n    if not input_str:\n        sys.exit(0)\n\n    # 找出分隔兩個頂層 JSON 陣列的逗號\n    depth = 0\n    split_index = None\n    for i, ch in enumerate(input_str):\n        if ch == '[':\n            depth += 1\n        elif ch == ']':\n            depth -= 1\n        elif ch == ',' and depth == 0:\n            split_index = i\n            break\n\n    # 如果無法正確拆分，直接結束\n    if split_index is None:\n        sys.exit(0)\n\n    # 解析方法名與參數\n    methods = json.loads(input_str[:split_index])\n    args_list = json.loads(input_str[split_index + 1:])\n\n    results = []\n    instance = None\n\n    for method, args in zip(methods, args_list):\n        if method == \"Solution\":\n            # 建構子傳入的參數為一個 list 內的 list\n            instance = Solution(args[0] if args else [])\n            results.append(None)  # 代表 null\n        elif method == \"pickIndex\":\n            res = instance.pickIndex()\n            results.append(res)\n        else:\n            # 若有其他未知方法，略過\n            pass\n\n    # 輸出符合 LeetCode 的 JSON 格式\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation. Steps: Build prefix sums, store total. Then pickIndex: generate random number between 1 and total, binary search or linear search for first index where prefix >= rand. Return index.\n\nWe need each line: virtual code step + space + // explanation. Use arrows and decision. Provide start, end. Use virtual code arrows.\n\nLet's craft lines.\n\nStart\n→ Step 1: Initialize prefix array of same length as w // store cumulative weights\n→ Step 2: Set total = 0 // will accumulate sum of weights\n→ For i from 0 to w.length-1: // iterate over weights\n    → Step 3: total = total + w[i] // add current weight to total\n    → Step 4: prefix[i] = total // store cumulative sum up to i\n→ End // preprocessing done\n\nThen pickIndex method:\n\nStart\n→ Step 5: Generate random integer r between 1 and total // inclusive\n→ Decision: Find first index j where prefix[j] >= r? // determine selected index\n    → BinarySearch or linear scan\n    → Step 6: Return j // selected index\nEnd\n\nLet's include decision branching. Use Decision block.\n\nWe'll produce each line separately. Use \"Start\" \"End\".\n\nAlso include \"→\" arrow for each step. For loops, maybe separate lines.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立空陣列 prefix，長度與 w 相同 // 用來儲存累積權重\n→ Step 2: 設定 total = 0 // 用來累加所有權重的總和\n→ For i 從 0 到 w.length-1 // 逐一處理每個索引\n    → Step 3: total = total + w[i] // 加上目前權重到總和\n    → Step 4: prefix[i] = total // 將累積總和儲存到 prefix\n→ End // 前置處理結束，total 為所有權重之和\n\nStart // pickIndex 函式開始執行\n→ Step 5: 產生隨機整數 r，範圍為 1 到 total（含） // 代表一個隨機權重點\n→ Decision: 找到第一個 index j，使 prefix[j] >= r? // 判斷應該返回哪個索引\n    → Step 6: Return j // 回傳選中的索引\nEnd // pickIndex 函式執行結束"
    },
    {
      "title": "The K Weakest Rows in a Matrix",
      "source_file": "Leetcode/leetcode1337.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "mat = [[1,1,0,0,0],[1,1,1,1,0],[1,0,0,0,0],[1,1,0,0,0],[1,1,1,1,1]], k = 3",
          "expected_output": "[2,0,3]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,0,3]'\nGot (Norm):      '[0]'\n--- (Raw) ---\nRaw Expected: '[2,0,3]'\nRaw Got:      '[0]'"
        },
        {
          "example_index": 1,
          "input": "mat = [[1,0,0,0],[1,1,1,1],[1,0,0,0],[1,0,0,0]], k = 2",
          "expected_output": "[0,2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[0,2]'\nGot (Norm):      '[0]'\n--- (Raw) ---\nRaw Expected: '[0,2]'\nRaw Got:      '[0]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def kWeakestRows(self, mat, k):\n        # 以二分搜尋快速計算每行 1 的個數（士兵）\n        def count_soldiers(row):\n            left, right = 0, len(row)\n            while left < right:\n                mid = (left + right) // 2\n                if row[mid] == 1:\n                    left = mid + 1\n                else:\n                    right = mid\n            return left\n\n        # 建立 (士兵數, 行索引) 的清單\n        soldiers = [(count_soldiers(row), i) for i, row in enumerate(mat)]\n        # 依照士兵數再依照行索引排序\n        soldiers.sort()\n        # 取前 k 個弱行的索引\n        return [idx for _, idx in soldiers[:k]]\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 解析輸入格式：mat = [...], k = X\n    try:\n        mat_part, k_part = data.split('k =')\n        mat_str = mat_part.replace('mat =', '').strip()\n        k_str = k_part.strip()\n        mat = ast.literal_eval(mat_str)\n        k = int(k_str)\n    except Exception as e:\n        print(\"Invalid input format\", file=sys.stderr)\n        sys.exit(1)\n\n    result = Solution().kWeakestRows(mat, k)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce step-by-step pseudo code for algorithm: find k weakest rows. The input: matrix mat (m rows, n cols). Soldiers on left. We can count soldiers per row by scanning until first 0 or using binary search. Then sort rows by (soldiers count, index). Then output first k indices.\n\nWe must produce virtual code lines with comments. Use Start, End, Decision, etc.\n\nLet's create step:\n\nStart\n→ Step 1: Input matrix mat and integer k // ...\n→ Step 2: Determine m = number of rows, n = number of columns\n→ Step 3: Initialize empty list rowsInfo\n→ Decision: For each row index i from 0 to m-1? // iterate rows\n    → Step 4: Count soldiers in row i using binary search // ...\n    → Step 5: Append pair (count, i) to rowsInfo\n→ Step 6: Sort rowsInfo by count ascending, then by index ascending // order weakest to strongest\n→ Step 7: Extract first k indices from sorted list\n→ Step 8: Output the list of indices\nEnd\n\nBut need line-by-line with arrows.\n\nWe can also detail binary search:\n\n→ Step 4a: low = 0, high = n-1, count = 0\n→ Decision: while low <= high?\n   Yes → ...\nBut maybe simplified.\n\nBut we can just state: Count soldiers by scanning until 0; since soldiers are contiguous left, we can break on 0.\n\nWe need to use arrow notation: → Step 1: ...\n\nLet's produce. Use indentation for decisions. Use \"Yes →\" \"No →\".\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Input matrix mat (m × n) and integer k // 取得輸入的二進位矩陣與要找出的弱行數量  \n→ Step 2: Set m ← number of rows in mat, n ← number of columns in mat // 取得矩陣尺寸  \n→ Step 3: Initialize empty list rowsInfo // 用來儲存 (soldierCount, rowIndex)  \n→ Decision: 針對每一行 i 從 0 到 m-1? // 開始逐行處理  \n  Yes → Step 4: Set count ← 0, j ← 0 // 以左端開始計數  \n    Decision: j < n 且 mat[i][j] = 1? // 檢查目前位元是否為 1  \n     Yes → Step 5: Increment count ← count + 1, j ← j + 1 // 找到一名士兵  \n     No → Step 6: Break // 遇到 0 之後士兵已全部計算完成  \n    Decision: j ≥ n? // 若已走完整行仍是 1  \n     Yes → Step 7: // 無需額外處理，count 已正確  \n     No → // 由 Step 6 直接跳出迴圈  \n      → Step 8: Append (count, i) to rowsInfo // 將計算結果儲存  \n→ Step 9: Sort rowsInfo by first element ascending, then by second element ascending // 由弱到強排序  \n→ Step 10: Extract first k row indices from sorted rowsInfo into result list // 取前 k 個弱行  \n→ Step 11: Output result list // 將弱行索引列印或返回  \nEnd // 程式執行結束"
    },
    {
      "title": "Multiply Strings",
      "source_file": "Leetcode/leetcode43.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "num1 = '2', num2 = '3'",
          "expected_output": "'6'",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '6'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: \"'6'\"\nRaw Got:      '2'"
        },
        {
          "example_index": 1,
          "input": "num1 = '123', num2 = '456'",
          "expected_output": "'56088'",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '56088'\nGot (Norm):      '123'\n--- (Raw) ---\nRaw Expected: \"'56088'\"\nRaw Got:      '123'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def multiply(self, num1: str, num2: str) -> str:\n        # 如果任何一個數字為 0，直接回傳 0\n        if num1 == '0' or num2 == '0':\n            return '0'\n\n        m, n = len(num1), len(num2)\n        # 建立結果陣列，大小為兩個數字長度之和\n        pos = [0] * (m + n)\n\n        # 兩層迴圈，從最低位往最高位相乘\n        for i in range(m - 1, -1, -1):\n            for j in range(n - 1, -1, -1):\n                mul = int(num1[i]) * int(num2[j])\n                # p1、p2 代表乘法結果應該放的位置\n                p1, p2 = i + j, i + j + 1\n                # 加上先前已累積的值\n                sum_ = mul + pos[p2]\n\n                # 儲存單位數到 p2，進位到 p1\n                pos[p1] += sum_ // 10\n                pos[p2] = sum_ % 10\n\n        # 把整數陣列轉成字串，並移除前導零\n        result = ''.join(map(str, pos)).lstrip('0')\n        return result\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 先嘗試從字串中抓出兩個數字（支援多種輸入格式）\n    nums = re.findall(r'\\d+', data)\n    if len(nums) >= 2:\n        num1, num2 = nums[0], nums[1]\n    else:\n        # 若未能抓到，則假設每行一個數字\n        lines = data.splitlines()\n        if len(lines) >= 2:\n            num1, num2 = lines[0].strip(), lines[1].strip()\n        else:\n            # 無法取得有效輸入，直接結束\n            sys.exit()\n\n    result = Solution().multiply(num1, num2)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for string multiplication without big integer library. It's typical algorithm: multiply each digit, accumulate partial sums. We need to produce step-by-step virtual code, each line with explanation.\n\nWe need to follow format: each line: \"虛擬碼步驟 // 解釋\".\n\nUse Start, End, Decision, arrows. Must not output actual code. So we need a sequence of steps describing algorithm. We'll produce lines like:\n\nStart // 程式開始執行\n→ Step 1: If num1 == \"0\" or num2 == \"0\" → return \"0\" // handle zero\n→ Step 2: Reverse num1 and num2 to iterate from least significant digit // easier multiplication\n→ Step 3: Initialize result array of size len1+len2 with zeros // store partial products\n→ Decision: for i from 0 to len1-1 // iterate each digit of num1\n    → Step 4: For j from 0 to len2-1 // each digit of num2\n        → Step 5: Multiply digit i of num1 with digit j of num2 // partial product\n        → Step 6: Add current product to result[i+j] plus carry // accumulate\n        → Step 7: Set result[i+j] = product % 10 // keep digit\n        → Step 8: Set carry = product / 10 // carry over\n        → Decision: after inner loop if carry > 0 // if leftover carry\n            → Step 9: result[i+len2] += carry // add carry to next position\n    → End inner loop\n→ End outer loop\n→ Step 10: Remove leading zeros from result array // from most significant side\n→ Step 11: Convert result array back to string in reverse order // build final string\n→ End // 程式結束\n\nWe need to add explanations.\n\nMake sure we adhere to format: each line: virtual code step, then space, then // explanation.\n\nWe need to use arrow for lines: \"→ Step X:\" and decisions: \"Decision:\" etc.\n\nWe must not output actual code but structure.\n\nAlso include \"Start\" and \"End\".\n\nWe'll produce steps. Also might use \"If\" decisions.\n\nWe'll include Decision for zero check.\n\nAlso note: no actual code like loops etc. Use pseudo.\n\nAlso we need \"→\" arrow lines.\n\nMake sure to not produce actual code but pseudocode.\n\nWill produce about 15-20 lines.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: 如果 num1 == \"0\" 或 num2 == \"0\"? // 檢查是否有任何一個輸入為 0  \n  Yes → Step 1: 返回 \"0\" // 直接返回 0 的字串，結束  \n  No → Step 2: 反轉 num1 和 num2 // 讓最低位在索引 0，方便計算  \n→ Step 3: 設定 result[0…len(num1)+len(num2)-1] 為 0 // 用於儲存每個位置的暫存積  \n→ Decision: 對 i 從 0 到 len(num1)-1 進行迴圈 // 迭代 num1 的每一位  \n  → Step 4: 對 j 從 0 到 len(num2)-1 進行迴圈 // 迭代 num2 的每一位  \n    → Step 5: partial = (num1[i]-'0') * (num2[j]-'0') + result[i+j] + carry // 計算部分積與已累積數  \n    → Step 6: result[i+j] = partial % 10 // 取單位數存回 result  \n    → Step 7: carry = partial / 10 // 取進位給下一個位置  \n    → Decision: 如果 j 為最後一位且 carry > 0? // 檢查內層迴圈結束後是否有進位  \n      Yes → result[i+len(num2)] += carry // 把進位加到下一個更高位  \n      No → (無需操作)  \n  → End inner loop  \n→ End outer loop  \n→ Step 8: 移除 result 中最高位的多餘 0 // 去掉多餘的前導零  \n→ Step 9: 建立 output 字串，從 result 的最高位到最低位拼接 // 轉換為最終的字串結果  \n→ End // 程式執行結束"
    }
  ]
}