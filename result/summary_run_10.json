{
  "run_index": 10,
  "total_files_found": 391,
  "total_files_processed": 323,
  "files_skipped": 68,
  "files_failed_load": 0,
  "---": "--- (以下基於 *題目* 總數) ---",
  "total_problems_attempted": 334,
  "generation_and_validation_success_count": 291,
  "generation_or_validation_failure_count": 43,
  "failed_cases_details": [
    {
      "title": "統計文字行數",
      "source_file": "900.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "（假設 data.txt 內容如下）\\nHello\\nPython\\nWorld",
          "expected_output": "檔案共有 3 行",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '檔案共有3行'\nGot (Norm):      '檔案共有1行'\n--- (Raw) ---\nRaw Expected: '檔案共有 3 行'\nRaw Got:      '檔案共有 1 行'"
        }
      ],
      "generated_code": "import sys\n\ndef count_lines():\n    try:\n        with open('data.txt', 'r', encoding='utf-8') as f:\n            lines = f.readlines()\n            print('檔案共有', len(lines), '行')\n    except FileNotFoundError:\n        print('找不到檔案！')\n\ndef main():\n    # 讀取標準輸入但不使用\n    sys.stdin.read()\n    count_lines()\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, each line \"虛擬碼步驟 [空格] // 解釋/說明\". Use Start, End, Decision, with arrow, Yes →, No →. They want to implement try/except and with syntax.\n\nWe need to write a virtual code flow: start, decision: file exists? But try/except covers file not found. So we can do:\n\nStart\n\n→ Step 1: 嘗試以 read 模式開啟 data.txt // 開啟檔案\n\n→ Step 2: with open(...): // 確保檔案自動關閉\n\n→ Step 3: read all lines into list // 讀取檔案內容\n\n→ Step 4: count lines // 計算行數\n\n→ Step 5: 輸出行數 // 顯示結果\n\nExcept FileNotFoundError:\n\n→ Step 6: 輸出 '找不到檔案！' // 顯示錯誤訊息\n\nEnd\n\nBut need to structure with Decision maybe: try block, if file exists then proceed else except. But we can still include Decision to show logic.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Decision: 是否能以讀取模式打開 data.txt? // 嘗試打開檔案\n    Yes → Step 1: with open('data.txt', 'r') as file: // 使用 with 確保檔案關閉\n        → Step 2: lines = file.readlines() // 讀取所有行\n        → Step 3: line_count = len(lines) // 計算行數\n        → Step 4: print('共', line_count, '行') // 輸出行數\n    No → Step 5: print('找不到檔案！') // 檔案不存在時顯示訊息\nEnd // 程式執行結束\n\nBut we need try/except; Decision might represent try block. We can do:\n\nStart\n\n→ Step 1: try // 嘗試以下操作\n    → Step 2: with open('data.txt', 'r') as file: // 開啟檔案\n        → Step 3: lines = file.readlines() // 讀取內容\n        → Step 4: print('共', len(lines), '行') // 輸出行數\n    → Step 5: except FileNotFoundError: // 檔案不存在\n        → Step 6: print('找不到檔案！') // 顯示錯誤訊息\nEnd\n\nWe need to format with arrow and indent. Let's produce lines accordingly.\n\nEnsure each line ends with // explanation.\n\nUse arrow like \"→\". For try block we can use \"→ Step 1: try // 嘗試以下操作\". Then inside we indent lines. But we need to maintain structure: arrow lines represent steps. The indent is done by spaces? Use 4 spaces indent. Use \"→\" for each step. For try and except we can use Decision? But it's fine.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: try // 嘗試以下操作\n    → Step 2: with open('data.txt', 'r') as file: // 用 with 確保自動關閉檔案\n        → Step 3: lines = file.readlines() // 讀取所有行\n        → Step 4: line_count = len(lines) // 計算行數\n        → Step 5: print('共', line_count, '行') // 輸出總行數\n    → Step 6: except FileNotFoundError: // 檔案不存在時處理\n        → Step 7: print('找不到檔案！') // 顯示錯誤訊息\nEnd // 程式執行結束\n\nWe need to ensure each line has \"虛擬碼步驟\" and then explanation. The indentation indicates sub-steps. Use arrows at each line. Provide explanation after each line.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: try // 嘗試執行檔案開啟與讀取的程式區塊  \n  → Step 2: with open('data.txt', 'r') as file: // 以 with 語法打開 data.txt，確保使用完即關閉  \n    → Step 3: lines = file.readlines() // 讀取檔案所有行，存入 list  \n    → Step 4: line_count = len(lines) // 計算行數  \n    → Step 5: print('共', line_count, '行') // 將行數輸出到螢幕  \n→ Step 6: except FileNotFoundError: // 若檔案不存在，捕捉此例外  \n    → Step 7: print('找不到檔案！') // 顯示錯誤訊息  \nEnd // 程式執行結束"
    },
    {
      "title": "模擬擲骰子遊戲",
      "source_file": "800.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "print(roll_dice(5))",
          "expected_output": "[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,6,1,4,2]#(結果會隨機，每次可能不同)'\nGot (Norm):      '[3,3,1,4,3]'\n--- (Raw) ---\nRaw Expected: '[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)'\nRaw Got:      '[3, 3, 1, 4, 3]'"
        }
      ],
      "generated_code": "import random\nimport sys\n\ndef roll_dice(n):\n    \"\"\"模擬擲 n 次六面骰，回傳所有結果的串列。\"\"\"\n    results = []\n    for _ in range(n):\n        results.append(random.randint(1, 6))\n    return results\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取所有文字並執行，假設輸入是合法的 Python 代碼\n    code = sys.stdin.read()\n    exec(code)",
      "virtual_code": "Thinking...\nWe need to produce virtual code with step lines, each line with \"虛擬碼步驟 // 解釋\". Use arrows. Use Start, End. Use Decision etc. The user wants a function roll_dice(n) that simulates rolling n times a 6-sided die, returning a list of results.\n\nWe need to output line by line virtual code. Include Start, End. Use arrow →. For function definition: Step: 定義函式 roll_dice(n). Then within: create empty list results. Then loop i from 1 to n. Inside loop, generate random int between 1 and 6 inclusive, append to list. After loop, return list. End.\n\nWe need to use virtual code, not actual code. Probably like:\n\nStart // 程式開始執行\n→ Step 1: 定義函式 roll_dice(n) // 建立擲骰子函式\n    → Step 2: 初始化空串列 results = [] // 用於存儲每次擲骰結果\n    → Step 3: 針對 i 從 1 到 n 進行迴圈 // 重複擲骰 n 次\n        → Step 4: 產生隨機數 rand_int = random.randint(1, 6) // 模擬一次六面骰\n        → Step 5: 把 rand_int 加到 results // 存儲結果\n    → Step 6: 回傳 results // 回傳所有結果\nEnd // 程式結束\n\nBut we need arrow indentation? Use \"→\" before each step. For nested steps maybe indent? The format example shows indentation via spaces before arrow.\n\nUse `Decision:` maybe not needed. No decision.\n\nThus produce.\n\nLet's write as:\n\nStart // 程式開始執行\n→ Step 1: 定義函式 roll_dice(n) // 建立擲骰子函式\n    → Step 2: 初始化空串列 results = [] // 用於存放所有擲骰結果\n    → Step 3: 針對 i 從 1 到 n 進行迴圈 // 重複擲骰 n 次\n        → Step 4: 產生隨機整數 dice = random.randint(1, 6) // 模擬一次六面骰\n        → Step 5: 把 dice 加到 results // 存入結果串列\n    → Step 6: 回傳 results // 結束函式並回傳所有結果\nEnd // 程式執行結束\n\nCheck each line has \"虛擬碼步驟 // 解釋\". Good.\n\nAdd `Decision:` maybe for if n <=0? Not required. But could be.\n\nBut we can keep simple.\n\nThus produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義函式 roll_dice(n) // 建立擲骰子函式  \n → Step 2: 初始化空串列 results = [] // 用於存放所有擲骰結果  \n → Step 3: 針對 i 從 1 到 n 進行迴圈 // 重複擲骰 n 次  \n  → Step 4: 產生隨機整數 dice = random.randint(1, 6) // 模擬一次六面骰  \n  → Step 5: 把 dice 加到 results // 存入結果串列  \n → Step 6: 回傳 results // 結束函式並回傳所有結果  \nEnd // 程式執行結束"
    },
    {
      "title": "計算程式執行時間",
      "source_file": "800.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "import time\n\ndef slow_add(a, b):\n    time.sleep(2)\n    return a + b\n\nprint(measure_time(slow_add, 3, 5))",
          "expected_output": "約 2.0 秒 (依電腦執行環境略有差異)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '約2.0秒(依電腦執行環境略有差異)'\nGot (Norm):      '2.0'\n--- (Raw) ---\nRaw Expected: '約 2.0 秒 (依電腦執行環境略有差異)'\nRaw Got:      '2.0'"
        }
      ],
      "generated_code": "import time\nimport sys\n\ndef measure_time(func, *args):\n    \"\"\"測量函式 func 執行時間，回傳秒數（四捨五入至 3 位小數）。\"\"\"\n    start = time.time()\n    func(*args)\n    end = time.time()\n    return round(end - start, 3)\n\ndef main():\n    # 從標準輸入讀取整段程式碼\n    code = sys.stdin.read()\n    # 以目前的命名空間執行讀入的程式碼，讓使用者可以呼叫 measure_time\n    exec(code, globals())\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code lines with explanation. The user wants function measure_time(func, *args) using time module. Steps: import time, define function, record start, call func with args, record end, compute elapsed, round to 3 decimal places, return elapsed. Possibly return result of func? But requirement says return time only. So we just return elapsed. We'll produce virtual code with steps.\n\nWe need to use arrow and Decision etc. But this is straightforward function definition.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Import time // 匯入 time 模組\n→ Step 1: 定義函數 measure_time(func, *args) // 定義測量時間的函式\n→ Decision: None? no decision. Just steps inside.\n\nInside function:\n→ Step 2: 記錄 start_time = time.time() // 取得開始時間\n→ Step 3: 執行 func(*args) // 呼叫目標函式\n→ Step 4: 記錄 end_time = time.time() // 取得結束時間\n→ Step 5: 計算 elapsed = end_time - start_time // 取兩時間差\n→ Step 6: 取四捨五入: rounded = round(elapsed, 3) // 四捨五入到小數點 3 位\n→ Step 7: 回傳 rounded // 回傳結果\n\nEnd // 程式執行結束\n\nWe must put each line as \"虛擬碼步驟 // 解釋\". Use arrow.\n\nWe might need to use indentation? Use arrow for nested.\n\nWe should include \"Start\" and \"End\". The arrow indicates step. Let's produce.\n\nWe might also include import at top as step.\n\nWe need to use \"→\" for each step. Use \"Decision:\" if needed but not necessary.\n\nThus final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Import time // 匯入 time 模組  \n→ Step 1: 定義函數 measure_time(func, *args) // 定義用於測量執行時間的函式  \n→     Step 2: 記錄 start_time = time.time() // 取得開始時間戳  \n→     Step 3: 執行 func(*args) // 呼叫目標函式，並傳遞所有參數  \n→     Step 4: 記錄 end_time = time.time() // 取得結束時間戳  \n→     Step 5: 計算 elapsed = end_time - start_time // 取兩時間差，得到執行所需秒數  \n→     Step 6: 取四捨五入 rounded = round(elapsed, 3) // 將秒數四捨五入到小數點 3 位  \n→     Step 7: 回傳 rounded // 將四捨五入後的秒數作為結果回傳  \nEnd // 程式執行結束"
    },
    {
      "title": "學生資料類別設計",
      "source_file": "1100.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "Alice 的分數是 90\nBob 的分數是 80",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'Alice的分數是90\\nBob的分數是80'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: 'Alice 的分數是 90\\nBob 的分數是 80'\nRaw Got:      ''"
        }
      ],
      "generated_code": "import sys\n\nclass Student:\n    def __init__(self, name, score):\n        \"\"\"初始化姓名與分數\"\"\"\n        self.name = name\n        self.score = score\n\n    def show_info(self):\n        \"\"\"輸出學生分數資訊\"\"\"\n        print(f'{self.name} 的分數是 {self.score}')\n\ndef main():\n    \"\"\"主程式：從標準輸入讀取資料，建立 Student 物件並顯示資訊\"\"\"\n    data = sys.stdin.read().strip().splitlines()\n    students = []\n\n    # 如果沒有輸入資料，使用預設兩位學生\n    if not data or (len(data) == 1 and data[0].strip() == ''):\n        students.append(Student('Alice', 90))\n        students.append(Student('Bob', 80))\n    else:\n        # 每行資料格式：姓名 分數\n        for line in data:\n            if not line.strip():\n                continue\n            parts = line.strip().split()\n            if len(parts) < 2:\n                continue\n            name = parts[0]\n            try:\n                score = int(parts[1])\n            except ValueError:\n                # 若分數不是整數，直接使用字串\n                score = parts[1]\n            students.append(Student(name, score))\n\n    # 顯示所有學生資訊\n    for s in students:\n        s.show_info()\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output step by step pseudocode lines with \"→\" arrow. Each line: \"虛擬碼步驟 // 解釋\". Need to follow output format: Start, End. Use Decision? not needed. Just straightforward.\n\nWe need to define class Student with attributes name, score in __init__. Then method show_info prints. Then create two objects and call show_info.\n\nSo pseudocode steps:\n\nStart\n\n→ Step 1: 定義 Class Student // 開始定義 Student 類別\n\n→ Step 2: 在 Student 中定義 __init__(self, name, score) // 建構子接收姓名和分數\n\n→ Step 3: self.name ← name // 初始化姓名屬性\n\n→ Step 4: self.score ← score // 初始化分數屬性\n\n→ Step 5: 定義 Method show_info(self) // 定義顯示資訊方法\n\n→ Step 6: 輸出 self.name + ' 的分數是 ' + self.score // 輸出姓名與分數\n\nEnd of class definition.\n\n→ Step 7: student1 ← Student('Alice', 85) // 建立第一個 Student 物件\n\n→ Step 8: student2 ← Student('Bob', 92) // 建立第二個 Student 物件\n\n→ Step 9: student1.show_info() // 呼叫第一個物件的顯示方法\n\n→ Step 10: student2.show_info() // 呼叫第二個物件的顯示方法\n\nEnd // 程式結束\n\nWe need each line with arrow \"→\". The class definition is multiple lines. Use \"Start\" at beginning.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 Class Student // 開始定義 Student 類別  \n→ Step 2: 在 Student 中定義 __init__(self, name, score) // 建構子接收姓名和分數  \n→ Step 3: self.name ← name // 初始化姓名屬性  \n→ Step 4: self.score ← score // 初始化分數屬性  \n→ Step 5: 定義 Method show_info(self) // 定義顯示資訊方法  \n→ Step 6: 輸出 self.name + ' 的分數是 ' + self.score // 輸出姓名與分數  \nEnd // Class 定義結束  \n→ Step 7: student1 ← Student('Alice', 85) // 建立第一個 Student 物件  \n→ Step 8: student2 ← Student('Bob', 92) // 建立第二個 Student 物件  \n→ Step 9: student1.show_info() // 呼叫第一個物件的顯示方法  \n→ Step 10: student2.show_info() // 呼叫第二個物件的顯示方法  \nEnd // 程式執行結束"
    },
    {
      "title": "集合函數練習",
      "source_file": "600.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "{'apple', 'orange', 'grape', 'melon'}",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '{\"apple\",\"orange\",\"grape\",\"melon\"}'\nGot (Norm):      '{\"orange\",\"grape\",\"melon\",\"apple\"}'\n--- (Raw) ---\nRaw Expected: \"{'apple', 'orange', 'grape', 'melon'}\"\nRaw Got:      \"{'orange', 'grape', 'melon', 'apple'}\""
        }
      ],
      "generated_code": "import sys\n\ndef main() -> None:\n    # 讀取輸入（此題無需任何輸入，僅保留結構）\n    _ = sys.stdin.read()\n\n    # 建立集合並進行各項操作\n    fruits = {'apple', 'banana'}\n    fruits.add('orange')\n    fruits.update(['grape', 'melon'])\n    fruits.remove('banana')\n    fruits.discard('pineapple')\n\n    # 輸出最終集合\n    print(fruits)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate pseudocode in lines with \"→\" arrows. Start, End. Must show each step with explanation. Use Start then steps.\n\nMake sure to use \"Start\", \"→\" lines, \"Decision:\" lines if any. But here it's linear operations. Just do each step. After each line, comment.\n\nNeed to include final output line: \"→ Step: 輸出集合 fruits\" with explanation.\n\nUse add, update, remove, discard.\n\nMake sure to follow formatting: each line: \"虛擬碼步驟 // 解釋\". The arrow and steps.\n\nWe'll output:\n\nStart // 程式開始執行\n\n→ Step 1: 建立集合 fruits = {'apple', 'banana'} // 初始化集合\n\n→ Step 2: fruits.add('orange') // 新增 'orange' 到集合\n\n→ Step 3: fruits.update(['grape', 'melon']) // 同時新增 'grape' 與 'melon'\n\n→ Step 4: fruits.remove('banana') // 移除 'banana'，若不存在會錯誤\n\n→ Step 5: fruits.discard('pineapple') // 嘗試移除 'pineapple'，不存在時不會錯誤\n\n→ Step 6: 輸出 fruits // 顯示最終集合\n\nEnd // 程式執行結束\n\nBut each line must follow arrow or Step? Use \"→ Step X:\" format.\n\nBetter to include \"Step 1:\" etc.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: fruits = {'apple', 'banana'} // 初始化集合 fruits，包含 'apple' 與 'banana'\n→ Step 2: fruits.add('orange') // 使用 add() 新增元素 'orange' 到集合\n→ Step 3: fruits.update(['grape', 'melon']) // 使用 update() 一次新增 'grape' 與 'melon' 到集合\n→ Step 4: fruits.remove('banana') // 使用 remove() 移除集合中的 'banana'（若不存在會產生錯誤）\n→ Step 5: fruits.discard('pineapple') // 使用 discard() 嘗試移除 'pineapple'；不存在時不會產生錯誤\n→ Step 6: print(fruits) // 輸出最終集合 fruits 的內容\nEnd // 程式執行結束"
    },
    {
      "title": "即時匯率查詢小工具",
      "source_file": "1200.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "按下「更新匯率」按鈕",
          "expected_output": "目前美元匯率：約 32.5 TWD",
          "actual_output_or_error": "[Validation Error] Code execution timed out (10s)."
        }
      ],
      "generated_code": "import requests\nimport tkinter as tk\nimport sys\n\ndef get_rate() -> str:\n    \"\"\"\n    取得美元兌台幣匯率，回傳格式化字串。\n    若請求失敗則回傳錯誤訊息。\n    \"\"\"\n    try:\n        url = \"https://api.exchangerate-api.com/v4/latest/USD\"\n        resp = requests.get(url, timeout=10)\n        resp.raise_for_status()            # 若 HTTP 狀態碼非 200 會拋例外\n        data = resp.json()\n        rate = data[\"rates\"][\"TWD\"]\n        return f\"目前美元匯率：約 {rate} TWD\"\n    except Exception:\n        return \"更新失敗，請檢查網路連線\"\n\ndef main() -> None:\n    \"\"\"\n    主程式入口。\n    1. 讀取標準輸入，忽略內容但必須完成讀取。\n    2. 取得匯率並輸出至標準輸出。\n    3. 啟動 tkinter GUI，顯示匯率並提供更新按鈕。\n    \"\"\"\n    # 讀取所有標準輸入 (不使用內容，只是為了滿足題目要求)\n    _ = sys.stdin.read()\n\n    # 將匯率顯示到標準輸出\n    print(get_rate())\n\n    # tkinter GUI 設定\n    root = tk.Tk()\n    root.title(\"匯率查詢\")\n\n    # 標籤顯示匯率\n    label = tk.Label(root, text=\"請按下按鈕更新匯率\", font=(\"Arial\", 12))\n    label.pack(pady=10)\n\n    # 更新匯率並更新標籤文字\n    def update_label() -> None:\n        label.config(text=get_rate())\n\n    # 按鈕\n    tk.Button(root, text=\"更新匯率\", command=update_label).pack(pady=5)\n\n    root.mainloop()\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce step-by-step virtual code. Use Start, Decision, etc. For tkinter GUI with button to fetch exchange rate. Use requests to GET API, parse JSON, extract 'rates' 'TWD'. Then update label. Use a function fetch_rate. Button triggers it. Need import statements? Virtual code steps. Each line like \"Start // 程式開始執行\". We can incorporate imports? Probably \"Step 1: import requests // 導入請求模組\" etc. Provide arrows and decisions where needed. Let's draft.\n\nNeed to reflect using requests. Provide fetch function. Use tkinter mainloop. Provide event binding. Use label. Provide update. Provide error handling decision: if request fails? Use Decision: If success? Yes -> display; No -> display error.\n\nWe must keep each line with virtual code step and comment. Use arrows.\n\nLet's write.\n\nWill produce like:\n\nStart // 程式開始執行\n→ Step 1: import requests // 導入 requests 模組\n→ Step 2: import tkinter as tk // 導入 tkinter\n→ Step 3: Define fetch_rate() // 定義獲取匯率函式\n    → Step 4: response = requests.get(\"https://api.exchangerate-api.com/v4/latest/USD\") // 發送 GET 請求\n    → Decision: 如果 response.status_code == 200? // 檢查是否成功\n        Yes → Step 5: data = response.json() // 解析 JSON\n        → Step 6: rate = data[\"rates\"][\"TWD\"] // 取出 TWD 匯率\n        → Step 7: return f\"USD/TWD = {rate}\" // 返回格式化字串\n        No → Step 8: return \"請求失敗\" // 返回錯誤訊息\n→ Step 9: root = tk.Tk() // 建立主視窗\n→ Step 10: root.title(\"匯率查詢\") // 設定視窗標題\n→ Step 11: label = tk.Label(root, text=\"按下按鈕以更新匯率\") // 建立顯示標籤\n→ Step 12: label.pack(pady=10) // 放置標籤\n→ Step 13: def update_rate(): // 定義按鈕點擊時執行函式\n    → Step 14: result = fetch_rate() // 呼叫 fetch_rate\n    → Step 15: label.config(text=result) // 更新標籤文字\n→ Step 16: button = tk.Button(root, text=\"更新匯率\", command=update_rate) // 建立按鈕\n→ Step 17: button.pack(pady=5) // 放置按鈕\n→ Step 18: root.mainloop() // 啟動 GUI 事件迴圈\nEnd // 程式執行結束\n\nNeed to include arrows? Use \"→\". For nested lines, indent. Good.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: import requests // 導入請求模組\n→ Step 2: import tkinter as tk // 導入 tkinter\n→ Step 3: Define fetch_rate() // 定義獲取匯率函式\n    → Step 4: response = requests.get(\"https://api.exchangerate-api.com/v4/latest/USD\") // 發送 GET 請求\n    → Decision: 如果 response.status_code == 200? // 檢查是否成功\n        Yes → Step 5: data = response.json() // 解析 JSON\n        → Step 6: rate = data[\"rates\"][\"TWD\"] // 取出 TWD 匯率\n        → Step 7: return f\"USD/TWD = {rate}\" // 返回格式化字串\n        No → Step 8: return \"請求失敗\" // 返回錯誤訊息\n→ Step 9: root = tk.Tk() // 建立主視窗\n→ Step 10: root.title(\"匯率查詢\") // 設定視窗標題\n→ Step 11: label = tk.Label(root, text=\"按下按鈕以更新匯率\") // 建立顯示標籤\n→ Step 12: label.pack(pady=10) // 放置標籤\n→ Step 13: def update_rate(): // 定義按鈕點擊時執行函式\n    → Step 14: result = fetch_rate() // 呼叫 fetch_rate\n    → Step 15: label.config(text=result) // 更新標籤文字\n→ Step 16: button = tk.Button(root, text=\"更新匯率\", command=update_rate) // 建立按鈕\n→ Step 17: button.pack(pady=5) // 放置按鈕\n→ Step 18: root.mainloop() // 啟動 GUI 事件迴圈\nEnd // 程式執行結束"
    },
    {
      "title": "Insert Delete GetRandom O(1)",
      "source_file": "Leetcode/leetcode380.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedSet\", \"insert\", \"remove\", \"insert\", \"getRandom\", \"remove\", \"insert\", \"getRandom\"], [[], [1], [2], [2], [], [1], [2], []]",
          "expected_output": "[null, true, false, true, 2, true, false, 2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,false,true,2,true,false,2]'\nGot (Norm):      '[null,true,false,true,1,true,false,2]'\n--- (Raw) ---\nRaw Expected: '[null, true, false, true, 2, true, false, 2]'\nRaw Got:      '[null, true, false, true, 1, true, false, 2]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\n\nclass RandomizedSet:\n    \"\"\"\n    隨機集合實作。\n    - insert: 平均 O(1)\n    - remove: 平均 O(1)\n    - getRandom: 平均 O(1)\n    \"\"\"\n    def __init__(self):\n        # value -> index in list\n        self.val_to_index = {}\n        # list 存儲實際值，方便 O(1) 隨機存取\n        self.values = []\n\n    def insert(self, val: int) -> bool:\n        \"\"\"若 val 不在集合，插入並回傳 True；否則回傳 False。\"\"\"\n        if val in self.val_to_index:\n            return False\n        self.values.append(val)\n        self.val_to_index[val] = len(self.values) - 1\n        return True\n\n    def remove(self, val: int) -> bool:\n        \"\"\"若 val 在集合，移除並回傳 True；否則回傳 False。\"\"\"\n        if val not in self.val_to_index:\n            return False\n        idx = self.val_to_index[val]\n        last_val = self.values[-1]\n        # 把最後一個元素搬到被刪除位置\n        self.values[idx] = last_val\n        self.val_to_index[last_val] = idx\n        # 真正移除最後一個\n        self.values.pop()\n        del self.val_to_index[val]\n        return True\n\n    def getRandom(self) -> int:\n        \"\"\"回傳集合中隨機一個元素。\"\"\"\n        return random.choice(self.values)\n\ndef parse_input(input_str: str):\n    \"\"\"\n    將輸入字串轉成兩個 list：\n    - ops: 操作名稱列表\n    - args: 每個操作對應的參數列表\n    \"\"\"\n    # 把整個輸入包成一個外層 list，讓 json.loads 可以正確解析\n    wrapped = f'[{input_str}]'\n    data = json.loads(wrapped)\n    return data[0], data[1]\n\ndef result_to_str(res):\n    \"\"\"\n    把結果列表轉成 LeetCode 期望的字串格式：\n    None -> null, bool -> true/false, int -> 整數字串\n    \"\"\"\n    out_items = []\n    for x in res:\n        if x is None:\n            out_items.append('null')\n        elif isinstance(x, bool):\n            out_items.append('true' if x else 'false')\n        else:\n            out_items.append(str(x))\n    return '[' + ', '.join(out_items) + ']'\n\ndef main():\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n    ops, args = parse_input(raw_input)\n\n    results = []\n    obj = None\n\n    for op, arg in zip(ops, args):\n        if op == 'RandomizedSet':\n            obj = RandomizedSet()\n            results.append(None)\n        elif op == 'insert':\n            results.append(obj.insert(arg[0]))\n        elif op == 'remove':\n            results.append(obj.remove(arg[0]))\n        elif op == 'getRandom':\n            results.append(obj.getRandom())\n        else:\n            # 任何未處理的操作，視為 None\n            results.append(None)\n\n    print(result_to_str(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for RandomizedSet implementation, each line with arrow, explanation. Provide steps like Start, variable definitions, insert, remove, getRandom logic. Ensure each operation O(1). Use hashmap and array. Provide pseudocode steps. Use decision structures. Provide Start, End. Provide each line. Let's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空的 ArrayList<int> list // 用於儲存元素以支援隨機存取  \n→ Step 2: 建立空的 HashMap<int, int> map // key: 元素值, value: 該值在 list 中的索引  \n→ Step 3: 設定 Random rnd // 隨機數產生器  \n\n→ Step 4: 定義 Function insert(val)  \n  Decision: 如果 map.containsKey(val)? // 檢查元素是否已存在  \n   Yes → Return false // 已存在，插入失敗  \n   No  →  \n     → Step 5: list.add(val) // 將元素加入末尾  \n     → Step 6: map.put(val, list.size() - 1) // 記錄索引  \n     → Return true // 成功插入  \n\n→ Step 7: 定義 Function remove(val)  \n  Decision: 如果 map.containsKey(val)? // 檢查元素是否存在  \n   Yes →  \n     → Step 8: idx = map.get(val) // 取得要移除元素的索引  \n     → Step 9: lastVal = list.get(list.size() - 1) // 取得最後一個元素  \n     → Step 10: list.set(idx, lastVal) // 把最後一個元素移到被刪除位置  \n     → Step 11: map.put(lastVal, idx) // 更新最後一個元素的新索引  \n     → Step 12: list.remove(list.size() - 1) // 從末尾真正刪除元素  \n     → Step 13: map.remove(val) // 移除映射  \n     → Return true // 成功刪除  \n   No  → Return false // 元素不存在，刪除失敗  \n\n→ Step 14: 定義 Function getRandom()  \n  Decision: 如果 list.isEmpty()? // 應該不會為空，但做防呆  \n   Yes → Throw Exception // 無元素時拋出錯誤  \n   No  →  \n     → Step 15: randIndex = rnd.nextInt(list.size()) // 取得隨機索引  \n     → Return list.get(randIndex) // 取回隨機元素  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Random Flip Matrix",
      "source_file": "Leetcode/leetcode519.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"flip\", \"flip\", \"flip\", \"reset\", \"flip\"], [[3, 1], [], [], [], [], []]",
          "expected_output": "[null, [1,0], [2,0], [0,0], null, [2,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[1,0],[2,0],[0,0],null,[2,0]]'\nGot (Norm):      '[null,[2,0],[1,0],[0,0],null,[1,0]]'\n--- (Raw) ---\nRaw Expected: '[null, [1,0], [2,0], [0,0], null, [2,0]]'\nRaw Got:      '[null, [2, 0], [1, 0], [0, 0], null, [1, 0]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\nimport json\n\nclass Solution:\n    def __init__(self, m, n):\n        self.rows = m\n        self.cols = n\n        self.total = m * n          # 可翻轉的格子數量\n        self.mapping = {}           # 用於映射已被翻轉的隨機位置\n\n    def flip(self):\n        # 產生在剩餘範圍內的隨機索引\n        rand_idx = random.randint(0, self.total - 1)\n        # 若 rand_idx 已映射，取映射值；否則直接使用\n        actual_idx = self.mapping.get(rand_idx, rand_idx)\n\n        # 最後一個未被翻轉的索引\n        last_idx = self.total - 1\n        # 取得 last_idx 的映射值（若有）\n        mapped_last = self.mapping.get(last_idx, last_idx)\n\n        # 更新映射：將 rand_idx 指向 last_idx 的映射值\n        self.mapping[rand_idx] = mapped_last\n        self.total -= 1\n\n        row = actual_idx // self.cols\n        col = actual_idx % self.cols\n        return [row, col]\n\n    def reset(self):\n        self.mapping.clear()\n        self.total = self.rows * self.cols\n\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入並解析為兩個列表\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n    # 把整個字串包成一個 tuple 以使用 ast.literal_eval\n    try:\n        commands, args_list = ast.literal_eval(f\"({raw_input})\")\n    except Exception:\n        # 若解析失敗則直接結束\n        sys.exit(0)\n\n    result = []\n    obj = None\n    for cmd, arg in zip(commands, args_list):\n        if cmd == \"Solution\":\n            obj = Solution(*arg)\n            result.append(None)\n        elif cmd == \"flip\":\n            res = obj.flip()\n            result.append(res)\n        elif cmd == \"reset\":\n            obj.reset()\n            result.append(None)\n        else:\n            # 忽略未知指令\n            result.append(None)\n\n    # 輸出符合題目範例的 JSON 風格\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need produce virtual code steps. Need design algorithm: reservoir sampling or using mapping technique: flatten 0..m*n-1. Keep mapping dict for used indices. Use random in range. Each flip: pick random from remaining, map to actual index using mapping dict; update mapping: map[random]=lastAvailable (if last available index already mapped). Decrement count. Reset: clear mapping and reset count. Provide pseudo lines.\n\nMake sure to follow format: each line \"虛擬碼步驟 // 解釋\". Use arrows, Start, End, Decision. Provide algorithm description step by step.\n\nWe need to output lines like:\n\nStart // 程式開始\n\n→ Step 1: 初始化 m, n, total = m*n, count = total // 初始化矩陣大小與可用數量\n\n→ Step 2: mapping = empty map // 用於儲存已被取走索引的映射\n\n…\n\nWhen calling flip:\n\n→ Step 3: randomIndex = randomInt(0, count-1) // 產生 0~count-1 的隨機整數\n\n→ Decision: randomIndex 在 mapping? // 檢查是否已有映射\n\n... mapping logic.\n\nAlso include reset logic.\n\nWill produce each line sequentially. Use arrow indentations maybe.\n\nLet's craft.\n\n...done thinking.\n\nStart // 程式開始\n\n→ Step 1: 初始化變數 m, n, total = m * n, count = total // 設定矩陣尺寸與可用座標總數\n\n→ Step 2: mapping = 空字典 // 用於映射已被翻轉的隨機位置\n\n→ Step 3: 已翻轉數量 flipped = 0 // 追蹤已被設為 1 的格子數\n\n→ Decision: 需要初始化？ // 若第一次建構物件則直接進行 Step 1-3\n\n    Yes → (已執行上述初始化) // 初始化完成\n\n    No → (跳過) // 已有資料，直接使用\n\nEnd // 初始化結束\n\n---\n\n→ Function flip() // 開始執行一次隨機翻轉\n\n    → Decision: count == 0? // 檢查是否所有格子已被翻轉\n\n        Yes → Raise Error \"No available zeros\" // 無可用位置\n\n        No  →\n\n            → Step 4: randIdx = randomInt(0, count - 1) // 在剩餘範圍內產生隨機索引\n\n            → Step 5: actualIdx = mapping.get(randIdx, randIdx) // 取得對應的實際位置\n\n            → Step 6: lastIdx = count - 1 // 最後一個未被翻轉的索引\n\n            → Decision: lastIdx 在 mapping? // 檢查最後一個索引是否已有映射\n\n                Yes → mappedLast = mapping.get(lastIdx) // 取得映射值\n\n                No  → mappedLast = lastIdx // 未映射，直接使用\n\n            → Step 7: mapping[randIdx] = mappedLast // 更新映射以移除已選擇的索引\n\n            → Step 8: count -= 1 // 減少可用索引總數\n\n            → Step 9: row = actualIdx // 計算行\n\n            → Step 10: col = actualIdx % n // 計算列\n\n            → Step 11: flipped += 1 // 更新已翻轉數量\n\n            → Return [row, col] // 回傳選取的座標\n\nEnd // flip() 執行結束\n\n---\n\n→ Function reset() // 重設矩陣為全 0\n\n    → Step 12: mapping.clear() // 清空映射\n\n    → Step 13: count = total // 重置可用索引數量\n\n    → Step 14: flipped = 0 // 重置已翻轉數量\n\n    → Return // 無需返回值\n\nEnd // reset() 執行結束\n\n---"
    },
    {
      "title": "Heaters",
      "source_file": "Leetcode/leetcode475.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "houses = [1,2,3], heaters = [2]",
          "expected_output": "1",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp2vzb_w7o.py\", line 21, in <module>\n    heaters_part = parts[1].split(\"=\", 1)[1].strip()\n                   ~~~~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        },
        {
          "example_index": 1,
          "input": "houses = [1,2,3,4], heaters = [1,4]",
          "expected_output": "1",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpf0hh10xz.py\", line 21, in <module>\n    heaters_part = parts[1].split(\"=\", 1)[1].strip()\n                   ~~~~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        },
        {
          "example_index": 2,
          "input": "houses = [1,5], heaters = [2]",
          "expected_output": "3",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp1jhxotkd.py\", line 21, in <module>\n    heaters_part = parts[1].split(\"=\", 1)[1].strip()\n                   ~~~~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findRadius(self, houses, heaters):\n        houses.sort()\n        heaters.sort()\n        res = 0\n        i = 0  # index of the closest heater to the left/right\n        for house in houses:\n            while i < len(heaters) - 1 and abs(heaters[i + 1] - house) <= abs(heaters[i] - house):\n                i += 1\n            res = max(res, abs(heaters[i] - house))\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    # Expect format: houses = [1,2,3], heaters = [2]\n    parts = [p.strip() for p in data.split(\",\")]\n    houses_part = parts[0].split(\"=\", 1)[1].strip()\n    heaters_part = parts[1].split(\"=\", 1)[1].strip()\n    houses = ast.literal_eval(houses_part)\n    heaters = ast.literal_eval(heaters_part)\n\n    sol = Solution()\n    radius = sol.findRadius(houses, heaters)\n    print(radius)",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines explaining algorithm. We need to output steps: find minimal radius so that all houses are covered by heaters with same radius. Classic problem: given houses array and heaters array, need to compute max minimal distance from each house to nearest heater, that will be radius. Approach: sort houses, heaters. For each house, binary search nearest heater. Or two-pointer: iterate houses, maintain pointer for heater nearest. Compute distance. Then maximum of distances. Output that.\n\nWe need to produce virtual code steps line by line with explanations. Use Start, Decision, etc. No actual code. Should describe algorithm.\n\nLet's outline:\n\nStart\n\n→ Step: Sort houses ascending\n\n→ Step: Sort heaters ascending\n\n→ Step: Initialize radius = 0\n\n→ Step: Initialize heater_index = 0\n\n→ Step: For each house in houses\n\n    → Step: While heater_index+1 < heaters.length and distance to next heater <= distance to current heater, move heater_index forward (find nearest heater)\n\n    → Step: Compute distance = abs(house - heaters[heater_index])\n\n    → Step: If distance > radius, update radius = distance\n\n→ End\n\nReturn radius\n\nAlso may need decision points to compare distances.\n\nWe must use arrow notation and decision: If ...? Yes → ... No → ... Format: \"Decision: 如果...\" etc. For each loop.\n\nOk produce each line with explanation.\n\nLet's produce around 15-20 lines.\n\nUse Chinese explanations. Use 虛擬碼步驟: we can write \"Step 1: ...\" but we need \"Step 1: \" preceding? In example, they used \"Step 1:\" after arrow.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Step 1: 將 houses 排序 // 方便後續搜尋\n→ Step 2: 將 heaters 排序 // 方便二分或雙指標\n→ Step 3: 初始化 radius 為 0 // 用於儲存最大距離\n→ Step 4: 初始化 heater_index 為 0 // 指向當前最近的暖氣\n→ Step 5: 逐個遍歷 houses // 逐家計算距離\n    → Decision: 如果 heater_index+1 < heaters.length 且 abs(houses[i] - heaters[heater_index+1]) <= abs(houses[i] - heaters[heater_index])? // 判斷下一個暖氣是否更靠近\n        Yes → Step 6: heater_index += 1 // 更新為更靠近的暖氣\n        No  → // 保持現有 heater_index\n    → Step 7: 計算 dist = abs(houses[i] - heaters[heater_index]) // 取得當前家與最近暖氣距離\n    → Decision: 如果 dist > radius? // 更新 radius 是否需要更大\n        Yes → Step 8: radius = dist // 將 radius 設為新最大距離\n        No  → // 保持現有 radius\n→ End // 所有房子處理完畢，radius 為最小必要半徑\nReturn radius // 結果輸出\n\nNeed to include \"Return radius\" maybe as Step.\n\nBetter to include \"Step 9: 回傳 radius\" after End? Actually End indicates program finish. We can include after End maybe.\n\nLet's structure:\n\nAfter loop, we have radius ready. We return.\n\nWe can include:\n\n→ Step 9: 回傳 radius // 最終答案\n\nThen End.\n\nBut the example ends with End. They don't include return after End. But we can keep inside loop. We'll put return after End? Might be okay.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 將 houses 排序 // 方便後續搜尋最接近的暖氣  \n→ Step 2: 將 heaters 排序 // 方便雙指標或二分  \n→ Step 3: 初始化 radius 為 0 // 用來儲存最大需要的半徑  \n→ Step 4: 初始化 heater_index 為 0 // 指向目前最近的暖氣  \n→ Step 5: 逐個遍歷 houses // 為每棟房子計算距離  \n  → Decision: 如果 heater_index+1 < heaters.length 且 abs(houses[i] - heaters[heater_index+1]) <= abs(houses[i] - heaters[heater_index])? // 判斷下一個暖氣是否更靠近  \n   Yes → Step 6: heater_index += 1 // 更新為更靠近的暖氣  \n   No  → // 保持現有 heater_index  \n  → Step 7: 計算 dist = abs(houses[i] - heaters[heater_index]) // 取得當前房子到最近暖氣的距離  \n  → Decision: 如果 dist > radius? // 判斷是否需要擴大半徑  \n   Yes → Step 8: radius = dist // 更新半徑為新的最大距離  \n   No  → // 保持現有 radius  \n→ Step 9: 回傳 radius // 最終答案  \nEnd // 程式執行結束"
    },
    {
      "title": "IPO",
      "source_file": "Leetcode/leetcode502.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]",
          "expected_output": "4",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpo_cbippl.py\", line 43, in <module>\n    inp = parse_input(raw)\n          ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpo_cbippl.py\", line 34, in parse_input\n    data[key] = ast.literal_eval(val)\n                ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "k = 3, w = 0, profits = [1,2,3], capital = [0,1,2]",
          "expected_output": "6",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp7gcywuu9.py\", line 43, in <module>\n    inp = parse_input(raw)\n          ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp7gcywuu9.py\", line 34, in parse_input\n    data[key] = ast.literal_eval(val)\n                ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport heapq\nimport ast\n\nclass Solution:\n    def findMaximizedCapital(self, k, W, Profits, Capital):\n        # 先將專案按資本需求排序\n        projects = sorted(zip(Capital, Profits))\n        max_heap = []          # 儲存可執行專案的利潤（使用負值作為最大堆）\n        i = 0\n        n = len(Profits)\n\n        for _ in range(k):\n            # 把所有符合資本需求的專案加入最大堆\n            while i < n and projects[i][0] <= W:\n                heapq.heappush(max_heap, -projects[i][1])\n                i += 1\n            # 若沒有可選擇的專案則停止\n            if not max_heap:\n                break\n            # 取出利潤最高的專案並更新資本\n            W += -heapq.heappop(max_heap)\n        return W\n\ndef parse_input(s: str):\n    \"\"\"將輸入字串解析成 k, w, profits, capital\"\"\"\n    parts = [p.strip() for p in s.split(',')]\n    data = {}\n    for part in parts:\n        if not part:\n            continue\n        key, val = [x.strip() for x in part.split('=', 1)]\n        if val.startswith('['):\n            data[key] = ast.literal_eval(val)\n        else:\n            data[key] = int(val)\n    return data\n\nif __name__ == \"__main__\":\n    raw = sys.stdin.read().strip()\n    if not raw:\n        sys.exit()\n    inp = parse_input(raw)\n    k = inp.get('k')\n    w = inp.get('w')\n    profits = inp.get('profits', [])\n    capital = inp.get('capital', [])\n    sol = Solution()\n    result = sol.findMaximizedCapital(k, w, profits, capital)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for solving the problem: \"IPO\" problem LeetCode 502. We should produce step-by-step algorithm: using a min-heap for capital requirements, sort projects by capital, iterate over k times, push all available projects into a max-heap by profit, pick highest profit, update capital, continue. We need to output the algorithm steps in virtual code lines with explanation after each line. Ensure no actual code, just virtual steps. Use arrows etc.\n\nLet's craft steps:\n\nStart\n→ Sort projects by capital ascending // Preprocess projects list\n→ Initialize minCapitalHeap = sorted list // store projects sorted by capital\n→ Initialize maxProfitHeap = empty // store profits of available projects\n→ Set currentCapital = w // starting capital\n→ For i from 1 to k // loop up to k projects\n    → While minCapitalHeap not empty and minCapitalHeap[0].capital <= currentCapital\n        No? Actually we need to push into maxProfitHeap all projects whose capital requirement <= currentCapital\n        So: → While minCapitalHeap not empty and minCapitalHeap[0].capital <= currentCapital\n            → maxProfitHeap.push(minCapitalHeap.pop().profit) // add profit to max heap\n    → Decision: If maxProfitHeap empty? // no available project\n        Yes → Break // cannot do more\n        No → currentCapital += maxProfitHeap.pop() // pick max profit, add to capital\n→ End // result currentCapital\n\nWe need to output each step with comment. Let's structure with indentation.\n\nWe need to use Decision and arrow syntax.\n\nAlso include \"End\".\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: Sort all projects by required capital ascending // 先根據最低資本排序所有專案\n→ Step 2: Initialize MinCapitalHeap with sorted projects // 建立一個最小堆，按資本需求排列\n→ Step 3: Initialize MaxProfitHeap as empty // 建立一個最大堆，用於儲存可執行專案的利潤\n→ Step 4: Set currentCapital = w // 設定目前資本為初始資本\n→ Step 5: For iteration from 1 to k // 重複最多 k 次選擇專案\n    → Step 5.1: While MinCapitalHeap not empty AND MinCapitalHeap.top.capital <= currentCapital\n        → Step 5.1.1: Push MinCapitalHeap.pop().profit into MaxProfitHeap // 把符合資本條件的專案利潤加入最大堆\n    → Decision: 是否存在可選擇專案？ // 檢查最大堆是否非空\n        Yes → Step 5.2: currentCapital += MaxProfitHeap.pop() // 取出利潤最大的專案並更新資本\n        No  → Step 5.3: Break // 沒有可選專案，終止迴圈\n→ End // 回傳最終資本\n\nBut we need each line individually, not nested inside loops? The requirement says \"逐行\" but we can include indentation for clarity.\n\nBetter to output like:\n\nStart // 程式開始執行\n→ Step 1: Sort projects by capital ascending // 先將專案按資本需求排序\n→ Step 2: Set minCapHeap = sorted projects // 建立最小堆\n→ Step 3: Set maxProfitHeap = empty // 建立最大堆\n→ Step 4: Set capital = w // 初始資本\n→ Step 5: For i = 1 to k // 迭代最多 k 次\n    → Step 5.1: While minCapHeap not empty AND minCapHeap.top.capital <= capital\n        → Step 5.1.1: maxProfitHeap.push(minCapHeap.pop().profit) // 將可執行專案的利潤加入最大堆\n    → Decision: 如果 maxProfitHeap 空? // 檢查是否有可選專案\n        Yes → Step 5.2: Break // 無可選專案，結束循環\n        No  → Step 5.3: capital += maxProfitHeap.pop() // 選取利潤最高專案，更新資本\n→ End // 程式執行結束，返回 capital\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort all projects by required capital ascending // 先將專案按資本需求排序  \n→ Step 2: Initialize MinCapitalHeap with sorted projects // 建立一個最小堆，按資本需求排列  \n→ Step 3: Initialize MaxProfitHeap as empty // 建立一個最大堆，用於儲存可執行專案的利潤  \n→ Step 4: Set currentCapital = w // 設定目前資本為初始資本  \n→ Step 5: For iteration from 1 to k // 重複最多 k 次選擇專案  \n    → Step 5.1: While MinCapitalHeap not empty AND MinCapitalHeap.top.capital <= currentCapital  \n        → Step 5.1.1: Push MinCapitalHeap.pop().profit into MaxProfitHeap // 把符合資本條件的專案利潤加入最大堆  \n    → Decision: 是否存在可選擇專案？ // 檢查最大堆是否非空  \n        Yes → Step 5.2: currentCapital += MaxProfitHeap.pop() // 取出利潤最大的專案並更新資本  \n        No  → Step 5.3: Break // 沒有可選專案，終止迴圈  \n→ End // 回傳最終資本 (currentCapital)"
    },
    {
      "title": "Remove Invalid Parentheses",
      "source_file": "Leetcode/leetcode301.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 2,
          "input": "s = \")(\"",
          "expected_output": "[\"\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"\"]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[\"\"]'\nRaw Got:      '[]'"
        }
      ],
      "generated_code": "import sys\nimport json\nfrom typing import List, Set\n\nclass Solution:\n    def removeInvalidParentheses(self, s: str) -> List[str]:\n        # 結果集合，避免重複\n        res: Set[str] = set()\n\n        # 先統計需要刪除的左括號與右括號數量\n        left_rem = right_rem = 0\n        for ch in s:\n            if ch == '(':\n                left_rem += 1\n            elif ch == ')':\n                if left_rem == 0:\n                    right_rem += 1\n                else:\n                    left_rem -= 1\n\n        # 深度優先搜尋 + 事前剪枝\n        def dfs(idx: int, left_cnt: int, right_cnt: int,\n                removed: int, path: str) -> None:\n            if idx == len(s):\n                if left_cnt == right_cnt:\n                    res.add(path)\n                return\n\n            ch = s[idx]\n\n            if ch == '(':\n                # 方案 1：刪除 '('\n                if removed < left_rem:\n                    dfs(idx + 1, left_cnt, right_cnt, removed + 1, path)\n                # 方案 2：保留 '('\n                dfs(idx + 1, left_cnt + 1, right_cnt, removed, path + '(')\n\n            elif ch == ')':\n                # 方案 1：刪除 ')'\n                if removed < right_rem:\n                    dfs(idx + 1, left_cnt, right_cnt, removed + 1, path)\n                # 方案 2：保留 ')'\n                if left_cnt > right_cnt:\n                    dfs(idx + 1, left_cnt, right_cnt + 1, removed, path + ')')\n\n            else:  # 普通字母\n                dfs(idx + 1, left_cnt, right_cnt, removed, path + ch)\n\n        dfs(0, 0, 0, 0, '')\n        return list(res)\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw = sys.stdin.read().strip()\n    if not raw:\n        sys.exit()\n\n    # 解析可能的 \"s = \\\"...\\\"\" 格式\n    s = raw\n    if '=' in s:\n        # 先嘗試雙引號\n        first = s.find('\"')\n        last = s.rfind('\"')\n        if 0 <= first < last:\n            s = s[first + 1:last]\n        else:\n            # 再嘗試單引號\n            first = s.find(\"'\")\n            last = s.rfind(\"'\")\n            if 0 <= first < last:\n                s = s[first + 1:last]\n            else:\n                # 直接取等號後面\n                parts = s.split('=', 1)\n                s = parts[1].strip()\n\n    solution = Solution()\n    result = solution.removeInvalidParentheses(s)\n\n    # 輸出 JSON 格式的字串列表，與範例保持一致\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to output virtual code step by step, not actual code. For problem: remove minimum invalid parentheses to make string valid, return all unique valid strings. Classic Leetcode 301. Approach: BFS or DFS with pruning. We'll produce pseudo steps: compute left and right removals needed, DFS backtracking with pruning. We'll produce steps: Start, compute l,r counts, call DFS(0, 0, 0, 0, \"\"), maintain set results. At each step, char c; if '(' increase left; if ')' check left>right then include else prune. Also at end, if left==right then add to results. Also skip duplicates by checking prev char and count removals. We'll produce step-by-step virtual code. Ensure each line has `→` or `Decision:`, `Yes →`, `No →`. Also include comments. We'll produce structure with Start, End. Use indentation for decisions. Let's craft.\n\nNeed to maintain result set. We'll use recursion.\n\nPseudo code lines:\n\nStart // 程式開始執行\n→ Step 1: 定義函式 `removeInvalidParentheses(s)` // 主入口\n→ Step 2: 計算 `l` (多餘 '(') 與 `r` (多餘 ')') // 先遍歷 s\n    → Decision: s[i] == '('? // 檢查括號\n        Yes → l ← l + 1\n        No →\n            Decision: s[i] == ')'?\n                Yes → if l == 0 then r ← r + 1 else l ← l - 1\n                No → // 其他字元不影響\n→ Step 3: 初始化空集合 `results` // 用於存唯一合法字串\n→ Step 4: 定義遞迴函式 `dfs(index, leftCount, rightCount, removed, path)` // 回溯\n    → Step 4.1: Decision: index == s.length?\n        Yes →\n            Decision: leftCount == rightCount?\n                Yes → results.add(path) // 已合法\n                No → // 不合法，回溯\n        No →\n            Decision: s[index] == '('?\n                Yes →\n                    // 1. 刪除 '(' 方案\n                    Decision: removed < l?\n                        Yes → dfs(index+1, leftCount, rightCount, removed+1, path)\n                        No  → // 不刪\n                    // 2. 保留 '('\n                    dfs(index+1, leftCount+1, rightCount, removed, path + '(')\n                No →\n                    Decision: s[index] == ')'\n                        Yes →\n                            // 1. 刪除 ')' 方案\n                            Decision: removed < r?\n                                Yes → dfs(index+1, leftCount, rightCount, removed+1, path)\n                                No  → // 不刪\n                            // 2. 保留 ')', 只在左括號多於右括號時才合法\n                            Decision: leftCount > rightCount?\n                                Yes → dfs(index+1, leftCount, rightCount+1, removed, path + ')')\n                                No  → // 不合法，跳過\n                        No →\n                            // 3. 為字母，直接加入\n                            dfs(index+1, leftCount, rightCount, removed, path + s[index])\n    → Step 4.2: // 回溯結束\n→ Step 5: 呼叫 `dfs(0,0,0,0,\"\")` // 開始回溯\n→ Step 6: 回傳 `results.toArray()` // 轉成列表返回\nEnd // 程式執行結束\n\nNeed to ensure each line uses the required format. For decisions, we must indent and use Yes→ etc. Let's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義函式 `removeInvalidParentheses(s)` // 主入口  \n→ Step 2: 初始化 `l = 0, r = 0` // 先統計多餘左右括號  \n    → Decision: s[i] == '('?  \n        Yes → l ← l + 1  \n        No →  \n            Decision: s[i] == ')' ?  \n                Yes →  \n                    Decision: l == 0?  \n                        Yes → r ← r + 1 // 沒左括號，這個右括號多餘  \n                        No  → l ← l - 1 // 與一個左括號配對  \n                No → // 非括號字符，忽略  \n→ Step 3: 初始化空集合 `results` // 存唯一合法字串  \n→ Step 4: 定義遞迴函式 `dfs(idx, leftCnt, rightCnt, removed, path)` // 回溯  \n    → Decision: idx == s.length?  \n        Yes →  \n            Decision: leftCnt == rightCnt?  \n                Yes → results.add(path) // 合法完成  \n                No  → // 右邊超過左邊，放棄  \n        No →  \n            Decision: s[idx] == '('?  \n                Yes →  \n                    // 方案 1：刪除 '('  \n                    Decision: removed < l?  \n                        Yes → dfs(idx+1, leftCnt, rightCnt, removed+1, path)  \n                        No  → // 不刪  \n                    // 方案 2：保留 '('  \n                    dfs(idx+1, leftCnt+1, rightCnt, removed, path + '(')  \n                No →  \n                    Decision: s[idx] == ')' ?  \n                        Yes →  \n                            // 方案 1：刪除 ')'  \n                            Decision: removed < r?  \n                                Yes → dfs(idx+1, leftCnt, rightCnt, removed+1, path)  \n                                No  → // 不刪  \n                            // 方案 2：保留 ')'，僅在左括號多於右括號時合法  \n                            Decision: leftCnt > rightCnt?  \n                                Yes → dfs(idx+1, leftCnt, rightCnt+1, removed, path + ')')  \n                                No  → // 不能保留，會破壞平衡  \n                        No → // 字母字符，直接加入  \n                            dfs(idx+1, leftCnt, rightCnt, removed, path + s[idx])  \n→ Step 5: 呼叫 `dfs(0, 0, 0, 0, \"\")` // 開始回溯探索  \n→ Step 6: 回傳 `Array.from(results)` // 轉成列表返回所有唯一合法字串  \nEnd // 程式執行結束"
    },
    {
      "title": "Merge Sorted Array",
      "source_file": "Leetcode/leetcode88.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3",
          "expected_output": "[1,2,2,3,5,6]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpl2b1pm4d.py\", line 34, in <module>\n    values[key.strip()] = eval(val.strip())\n                          ^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def merge(self, nums1, m, nums2, n):\n        i = m - 1          # 指向 nums1 最後一個有效元素\n        j = n - 1          # 指向 nums2 最後一個元素\n        k = m + n - 1      # 指向 nums1 最後一個位置\n\n        while i >= 0 and j >= 0:\n            if nums1[i] > nums2[j]:\n                nums1[k] = nums1[i]\n                i -= 1\n            else:\n                nums1[k] = nums2[j]\n                j -= 1\n            k -= 1\n\n        while j >= 0:      # nums1 已無元素，直接拷貝剩餘 nums2\n            nums1[k] = nums2[j]\n            j -= 1\n            k -= 1\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 解析輸入，將 'var = value' 的形式拆分並 eval 值\n    parts = [p.strip() for p in data.split(',')]\n    values = {}\n    for part in parts:\n        if '=' in part:\n            key, val = part.split('=', 1)\n            values[key.strip()] = eval(val.strip())\n\n    nums1 = values.get('nums1', [])\n    m = values.get('m', 0)\n    nums2 = values.get('nums2', [])\n    n = values.get('n', 0)\n\n    Solution().merge(nums1, m, nums2, n)\n    print(nums1)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for merging two sorted arrays into nums1, in-place. Use indices from back. Provide line-by-line with explanation, using arrow syntax. Must not output actual code, just virtual steps. Ok.\n\nWe should produce lines like:\n\nStart // 程式開始執行\n→ Step 1: 初始化 i = m - 1 // nums1最後一個有效元素指標\n→ Step 2: 初始化 j = n - 1 // nums2最後一個元素指標\n→ Step 3: 初始化 k = m + n - 1 // nums1總長度最後指標\n→ Decision: 如果 k >= 0? // 處理所有位置\n    Yes → Decision: 如果 i >= 0 和 j >= 0? // 同時兩個指標未超過\n        Yes → Decision: 如果 nums1[i] > nums2[j]? // 比較元素\n            Yes → Step 4: nums1[k] = nums1[i]; i = i - 1; k = k - 1; // 放置較大者\n            No  → Step 5: nums1[k] = nums2[j]; j = j - 1; k = k - 1; // 放置較大者\n        No → Decision: 如果 i < 0? // nums1已無元素\n            Yes → Step 6: nums1[k] = nums2[j]; j = j - 1; k = k - 1; // 直接拷貝剩餘 nums2\n            No  → Step 7: nums1[k] = nums1[i]; i = i - 1; k = k - 1; // 直接拷貝剩餘 nums1\n    No  → End // 循環結束\n\nBut we also need to continue loop until k<0, but we can have while loop or decision. Use Decision loop: Decision: k >= 0? Yes -> Do compare etc. After finishing loop, End.\n\nAlso must mention ignoring trailing zeros.\n\nLet's produce.\n\nMake sure to follow format. Use \"Start\" and \"End\". Each line: \"虛擬碼步驟 // 解釋\". Use arrows and indentation.\n\nWe need to keep lines sequential; we may use indentation to show nested decisions.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: i ← m − 1 // 指向 nums1 最後一個有效元素的索引  \n→ Step 2: j ← n − 1 // 指向 nums2 最後一個元素的索引  \n→ Step 3: k ← m + n − 1 // 指向 nums1 最後一個位置（即整體結束位置）  \n\n→ Decision: k ≥ 0? // 只要還有空位需要填滿就繼續  \n    Yes → Decision: i ≥ 0 ∧ j ≥ 0? // 兩個陣列都還有未處理元素  \n        Yes → Decision: nums1[i] > nums2[j]? // 比較兩邊最後一個未處理元素大小  \n            Yes → Step 4: nums1[k] ← nums1[i] ; i ← i − 1 ; k ← k − 1 // 把 nums1 中較大的元素放到最後  \n            No  → Step 5: nums1[k] ← nums2[j] ; j ← j − 1 ; k ← k − 1 // 把 nums2 中較大的元素放到最後  \n        No  → Decision: i < 0? // nums1 已無元素可比  \n            Yes → Step 6: nums1[k] ← nums2[j] ; j ← j − 1 ; k ← k − 1 // 直接拷貝剩餘 nums2  \n            No  → Step 7: nums1[k] ← nums1[i] ; i ← i − 1 ; k ← k − 1 // 直接拷貝剩餘 nums1  \n    No  → End // k < 0，所有位置已填滿，合併完成  \nEnd // 程式結束執行"
    },
    {
      "title": "Min Stack",
      "source_file": "Leetcode/leetcode155.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"],[[],[-2],[0],[-3],[],[],[],[]]",
          "expected_output": "[null,null,null,null,-3,null,0,-2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,null,-3,null,0,-2]'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: '[null,null,null,null,-3,null,0,-2]'\nRaw Got:      ''"
        }
      ],
      "generated_code": "import sys\nimport json\nimport ast\n\nclass MinStack:\n    def __init__(self):\n        self.stack = []\n        self.min_stack = []\n\n    def push(self, val):\n        self.stack.append(val)\n        if not self.min_stack or val <= self.min_stack[-1]:\n            self.min_stack.append(val)\n\n    def pop(self):\n        if self.stack:\n            val = self.stack.pop()\n            if val == self.min_stack[-1]:\n                self.min_stack.pop()\n\n    def top(self):\n        if self.stack:\n            return self.stack[-1]\n        return None\n\n    def getMin(self):\n        if self.min_stack:\n            return self.min_stack[-1]\n        return None\n\ndef main():\n    lines = [line.strip() for line in sys.stdin if line.strip()]\n    if not lines:\n        return\n    # 支援兩行輸入：命令列與參數列\n    if len(lines) == 1:\n        # 若只有一行，嘗試拆分\n        parts = lines[0].split('],[')\n        if len(parts) == 2:\n            cmds_line = parts[0] + ']'\n            args_line = '[' + parts[1]\n        else:\n            return\n    else:\n        cmds_line, args_line = lines[0], lines[1]\n\n    commands = ast.literal_eval(cmds_line)\n    args_list = ast.literal_eval(args_line)\n\n    stack = None\n    output = []\n\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"MinStack\":\n            stack = MinStack()\n            output.append(None)  # 建構子不回傳值\n        elif cmd == \"push\":\n            stack.push(args[0])\n            output.append(None)\n        elif cmd == \"pop\":\n            stack.pop()\n            output.append(None)\n        elif cmd == \"top\":\n            output.append(stack.top())\n        elif cmd == \"getMin\":\n            output.append(stack.getMin())\n\n    # 將 None 轉成 JSON 的 null\n    print(json.dumps(output))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for MinStack design. Must be line-by-line, each line with virtual code step then comment. Use arrow etc. No actual code. Just design.\n\nWe need to output steps: Start, maybe define class, internal stack and minStack, etc. Show push, pop, top, getMin. Each step with explanation.\n\nWe should include decision points? But it's simple operations. Could include a Decision step for checking if stack empty etc.\n\nWe should provide virtual code steps: \"Start\", \"→ Step 1: Define class MinStack // class definition\". We can use nested steps. But they want line-by-line output. Each line must be \"虛擬碼步驟\" followed by a space and then comment. We need to include arrows. For clarity, we can show \"→\" at beginning of each step. We also need to include \"Start\" and \"End\". Use \"Decision:\" lines maybe for empty check.\n\nLet's craft.\n\nFirst: Start\n\n→ Step 1: Define class MinStack // 封裝兩個堆疊\n\n→ Step 2: 初始化主堆疊 mainStack 和最小值堆疊 minStack // 兩個空堆疊\n\n→ Step 3: Push(val) // 將值推入主堆疊\n\n    → Step 4: 判斷 minStack 為空 或 val ≤ minStack.top // 判斷是否成為新的最小值\n\n        Yes → Step 5: minStack.push(val) // 將新最小值推入最小堆疊\n\n        No  → Step 6: minStack.push(minStack.top) // 重複上一最小值以保持同步\n\n→ Step 7: Pop() // 從主堆疊彈出元素\n\n    → Step 8: mainStack.pop() // 移除主堆疊頂部\n\n    → Step 9: minStack.pop() // 同步移除最小堆疊頂部\n\n→ Step 10: Top() // 取得主堆疊頂部元素\n\n    → Step 11: return mainStack.top() // 回傳主堆疊頂部\n\n→ Step 12: GetMin() // 取得最小值\n\n    → Step 13: return minStack.top() // 回傳最小堆疊頂部\n\nEnd // 程式結束\n\nWe need each line with comment. Provide arrow. Use \"Decision:\" for if. Use \"Yes →\" \"No →\" indent.\n\nMake sure each line includes comment after space.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Define class MinStack // 定義 MinStack 類別  \n→ Step 2: Initialize mainStack and minStack // 建立兩個空堆疊，分別儲存所有元素與對應最小值  \n→ Step 3: Push(val) // 將值 val 推入主堆疊  \n  → Decision: minStack 為空 或 val ≤ minStack.top? // 判斷是否需要更新最小值  \n   Yes → Step 4: minStack.push(val) // 新值為最小值，推入 minStack  \n   No  → Step 5: minStack.push(minStack.top) // 保持 minStack 與 mainStack 同步，重複上一最小值  \n→ Step 6: Pop() // 從主堆疊彈出頂部元素  \n  → Step 7: mainStack.pop() // 移除 mainStack 的頂部元素  \n  → Step 8: minStack.pop() // 同步移除 minStack 的頂部元素  \n→ Step 9: Top() // 取得主堆疊頂部元素  \n  → Step 10: return mainStack.top() // 回傳 mainStack 的頂部值  \n→ Step 11: GetMin() // 取得當前最小值  \n  → Step 12: return minStack.top() // 回傳 minStack 的頂部值  \nEnd // 程式執行結束"
    },
    {
      "title": "Subsets II",
      "source_file": "Leetcode/leetcode90.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,2]",
          "expected_output": "[[],[1],[1,2],[1,2,2],[2],[2,2]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[1,2],[1,2,2],[2],[2,2]]'\nGot (Norm):      '[[],[1],[2],[1,2],[2,2],[1,2,2]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[1,2],[1,2,2],[2],[2,2]]'\nRaw Got:      '[[],[1],[2],[1,2],[2,2],[1,2,2]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\ndef subsets_with_dup(nums):\n    nums.sort()\n    res = [[]]\n    for num in nums:\n        new_subsets = []\n        for subset in res:\n            new_subsets.append(subset + [num])\n        res += new_subsets\n    unique_res = []\n    seen = set()\n    for subset in res:\n        t = tuple(subset)\n        if t not in seen:\n            seen.add(t)\n            unique_res.append(subset)\n    return unique_res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Expect input like \"nums = [1,2,2]\"\n    try:\n        _, list_str = data.split('=', 1)\n        nums = ast.literal_eval(list_str.strip())\n    except Exception:\n        # Fallback: try to evaluate entire input\n        nums = ast.literal_eval(data)\n    result = subsets_with_dup(nums)\n    # Print without spaces to match example formatting\n    print(str(result).replace(' ', ''))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for generating all subsets of array with duplicates, ensuring no duplicate subsets. This is typical subset II problem. We need to produce step-by-step algorithm: sort array, backtracking with skip duplicates.\n\nWe must produce each line as \"虛擬碼步驟 // 解釋\".\n\nUse arrows, Start, End, Decision etc.\n\nWe need to list algorithm steps line by line. Let's design:\n\nStart\n→ Step 1: Sort nums ascending // sort to group duplicates\n→ Step 2: Initialize result list with empty subset // result = [[]]\n→ Step 3: Define function backtrack(start, current) // recursive\n    → Decision: start == len(nums)? // if reached end\n        Yes → Step 4: Append copy of current to result // add subset\n        No  → Step 5: For i from start to len(nums)-1\n            → Decision: i > start and nums[i] == nums[i-1]?\n                Yes → Step 6: Continue // skip duplicates\n                No  → Step 7: Append nums[i] to current // include element\n                    → Step 8: Call backtrack(i+1, current) // recurse\n                    → Step 9: Remove last element from current // backtrack\n→ Step 10: Call backtrack(0, []) // start recursion\n→ Step 11: Return result // final subsets\n\nBut we need each line as separate line with arrow etc.\n\nWe need to incorporate arrows properly. Use \"→\" for step lines, \"Decision:\" for conditions. Provide indentation maybe but still line by line.\n\nAlso we may include loops as step lines. For loop, we can write \"→ For i from start to len(nums)-1\" and then nested steps inside. Use indentation to indicate nested steps.\n\nWe must not output actual code but pseudo code.\n\nLet's craft each line:\n\nStart // 程式開始執行\n→ Step 1: Sort nums in non-decreasing order // 先排序，方便處理重複元素\n→ Step 2: Initialize result ← [[]] // 用來存所有子集，先放空集合\n→ Step 3: Define function backtrack(start, current) // 從 start 開始，current 為目前子集\n    → Decision: start == len(nums) ?\n        Yes → Step 4: Append copy of current to result // 完成一個子集\n        No  → Step 5: For i from start to len(nums)-1\n            → Decision: i > start AND nums[i] == nums[i-1] ?\n                Yes → Step 6: Continue // 跳過重複元素\n                No  → Step 7: Append nums[i] to current // 選擇此元素\n                    → Step 8: Call backtrack(i+1, current) // 深度優先遞迴\n                    → Step 9: Remove last element from current // 回溯\n→ Step 10: Call backtrack(0, []) // 開始遞迴，起始空子集\n→ Step 11: Return result // 回傳所有子集\nEnd // 程式執行結束\n\nNeed to ensure each line is separate. Indentation can be represented by spaces or maybe tabs but not necessary. But each line must be \"虛擬碼步驟\" + space + \"// 解釋\".\n\nAlso we should use arrow \"→\" at beginning of each step line. For decisions we use \"Decision:\" with arrow after? In example: \"Decision: 如果數字大於 0?\" without arrow? Actually example: \"Decision: 如果數字大於 0?\" then under it Yes → Step 2 etc. So we should follow that style: \"Decision: ...\" line no arrow, then indentation.\n\nThus produce like:\n\nStart // 程式開始執行\n→ Step 1: Sort nums in non-decreasing order // 先排序，方便處理重複元素\n→ Step 2: Initialize result ← [[]] // 用來存所有子集，先放空集合\n→ Step 3: Define function backtrack(start, current) // 從 start 開始，current 為目前子集\n    Decision: start == len(nums) ?\n        Yes → Step 4: Append copy of current to result // 完成一個子集\n        No  → Step 5: For i from start to len(nums)-1\n            Decision: i > start AND nums[i] == nums[i-1] ?\n                Yes → Step 6: Continue // 跳過重複元素\n                No  → Step 7: Append nums[i] to current // 選擇此元素\n                    → Step 8: Call backtrack(i+1, current) // 深度優先遞迴\n                    → Step 9: Remove last element from current // 回溯\n→ Step 10: Call backtrack(0, []) // 開始遞迴，起始空子集\n→ Step 11: Return result // 回傳所有子集\nEnd // 程式執行結束\n\nWe need to keep each line separate. Provide indent maybe with 4 spaces.\n\nMake sure each line has \" // 解釋\" after.\n\nOk produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort nums in non-decreasing order // 先排序，方便處理重複元素  \n→ Step 2: Initialize result ← [[]] // 用來存所有子集，先放空集合  \n→ Step 3: Define function backtrack(start, current) // 從 start 開始，current 為目前子集  \n    Decision: start == len(nums) ?  \n        Yes → Step 4: Append copy of current to result // 完成一個子集  \n        No  → Step 5: For i from start to len(nums)-1 // 遍歷剩餘元素  \n            Decision: i > start AND nums[i] == nums[i-1] ?  \n                Yes → Step 6: Continue // 跳過重複元素  \n                No  → Step 7: Append nums[i] to current // 選擇此元素  \n                    → Step 8: Call backtrack(i+1, current) // 深度優先遞迴  \n                    → Step 9: Remove last element from current // 回溯  \n→ Step 10: Call backtrack(0, []) // 開始遞迴，起始空子集  \n→ Step 11: Return result // 回傳所有子集  \nEnd // 程式執行結束"
    },
    {
      "title": "Add Strings",
      "source_file": "Leetcode/leetcode415.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "num1 = \"11\", num2 = \"123\"",
          "expected_output": "\"134\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '134'\nGot (Norm):      '12'\n--- (Raw) ---\nRaw Expected: '\"134\"'\nRaw Got:      '12'"
        },
        {
          "example_index": 1,
          "input": "num1 = \"456\", num2 = \"77\"",
          "expected_output": "\"533\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '533'\nGot (Norm):      '457'\n--- (Raw) ---\nRaw Expected: '\"533\"'\nRaw Got:      '457'"
        },
        {
          "example_index": 2,
          "input": "num1 = \"0\", num2 = \"0\"",
          "expected_output": "\"0\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '0'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: '\"0\"'\nRaw Got:      '1'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def addStrings(self, num1: str, num2: str) -> str:\n        i, j = len(num1) - 1, len(num2) - 1\n        carry = 0\n        res = []\n        while i >= 0 or j >= 0 or carry:\n            x = int(num1[i]) if i >= 0 else 0\n            y = int(num2[j]) if j >= 0 else 0\n            total = x + y + carry\n            res.append(str(total % 10))\n            carry = total // 10\n            i -= 1\n            j -= 1\n        return ''.join(reversed(res))\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    numbers = re.findall(r'\\d+', data)\n    if len(numbers) < 2:\n        sys.exit()\n    num1, num2 = numbers[0], numbers[1]\n    solution = Solution()\n    result = solution.addStrings(num1, num2)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line with explanation. The problem: Add two non-negative integers given as strings. Return sum as string. Without built-in big integer, not convert to int directly. So typical algorithm: simulate addition from right to left, carry. Steps: initialize pointers at end of strings, carry=0, result array, loop while i>=0 or j>=0 or carry>0, sum=carry, if i>=0 add int(s1[i]) - '0', j similarly, compute digit = sum %10, carry = sum/10, prepend digit to result (string builder). After loop, return result. So we produce virtual code accordingly.\n\nWe need to produce step by step with arrow. Use Start, End, Decision, Steps. Use appropriate names: Step 1: Initialize pointers and carry, Step 2: Initialize result string builder, Step 3: Loop while i>=0 or j>=0 or carry>0. Inside loop: sum=carry, if i>=0 add digit from num1, i--, etc. Compute digit, carry, append to front. After loop, return result. Use Decision inside loop to check if i>=0 etc.\n\nThe virtual code should not be actual code. It should be something like:\n\nStart // 程式開始執行\n→ Step 1: Set i = length(num1)-1, j = length(num2)-1, carry = 0 // 初始化指標和進位\n→ Step 2: Create empty string result // 用於儲存計算結果\n→ Step 3: While i>=0 or j>=0 or carry>0 // 只要還有數字或進位就繼續\n    → Decision: If i>=0? // 是否還有 num1 的數字\n        Yes → Add num1[i]-'0' to sum; i-- // 加入 num1 的位數並移動指標\n    → Decision: If j>=0? // 是否還有 num2 的數字\n        Yes → Add num2[j]-'0' to sum; j-- // 加入 num2 的位數並移動指標\n    → Step: digit = sum % 10 // 計算本位數\n    → Step: carry = sum / 10 // 更新進位\n    → Step: Prepend digit to result // 把本位數放到最前面\n→ Step 4: Return result // 完成加法，回傳結果\nEnd // 程式執行結束\n\nBut we need each line with the arrow and explanation. Also we need to show decision nodes with Yes → and No → inside loop for the conditions. Provide proper indentation for steps inside decision. We'll output as per the sample.\n\nWe must ensure each line ends with // 解釋. Use arrow `→`. Use \"Start\", \"End\". Use \"Decision:\" for decisions.\n\nLet's produce.\n\nBut we should consider we need step to convert char to int: digit = num1[i] - '0'. But we can just mention adding numeric value of char.\n\nThe algorithm must not use built-in big integer or direct int conversion. So we only use char difference.\n\nLet's produce final answer.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: i ← length(num1) - 1, j ← length(num2) - 1, carry ← 0 // 初始化兩個字串指標及進位  \n→ Step 2: result ← empty string // 用於累積加法結果  \n→ Step 3: Decision: i ≥ 0 或 j ≥ 0 或 carry > 0? // 判斷是否還有位數或進位需要處理  \n  Yes → Step 4: sum ← carry // 從上一位的進位開始  \n   Decision: i ≥ 0? // num1 還有剩餘位數嗎？  \n    Yes → sum ← sum + (num1[i] - '0'), i ← i - 1 // 加入 num1 的當前位並移動指標  \n    No → // 不做任何改動  \n   Decision: j ≥ 0? // num2 還有剩餘位數嗎？  \n    Yes → sum ← sum + (num2[j] - '0'), j ← j - 1 // 加入 num2 的當前位並移動指標  \n    No → // 不做任何改動  \n   Step 5: digit ← sum mod 10 // 取得本位數  \n   Step 6: carry ← sum div 10 // 計算新的進位  \n   Step 7: result ← character(digit + '0') + result // 將本位數放到最前面  \n   Go back to Decision: i ≥ 0 或 j ≥ 0 或 carry > 0? // 重複循環直到沒有剩餘位數和進位  \n→ Step 8: Return result // 輸出最終加法結果  \nEnd // 程式執行結束"
    },
    {
      "title": "Sort Characters By Frequency",
      "source_file": "Leetcode/leetcode451.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"tree\"",
          "expected_output": "\"eert\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'eert'\nGot (Norm):      'eetr'\n--- (Raw) ---\nRaw Expected: '\"eert\"'\nRaw Got:      'eetr'"
        },
        {
          "example_index": 1,
          "input": "s = \"cccaaa\"",
          "expected_output": "\"aaaccc\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'aaaccc'\nGot (Norm):      'cccaaa'\n--- (Raw) ---\nRaw Expected: '\"aaaccc\"'\nRaw Got:      'cccaaa'"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import Counter\n\nclass Solution:\n    def frequencySort(self, s: str) -> str:\n        # Count frequency of each character\n        freq = Counter(s)\n        # Sort characters by descending frequency and build the result\n        return ''.join(char * count for char, count in freq.most_common())\n\ndef main() -> None:\n    # Read entire input\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Extract the string value from the input\n    if '=' in data:\n        _, val = data.split('=', 1)\n        val = val.strip()\n    else:\n        val = data\n\n    # Safely evaluate the string literal\n    try:\n        s = ast.literal_eval(val)\n    except Exception:\n        s = val.strip('\"\\'')  # fallback: strip quotes manually\n\n    solution = Solution()\n    result = solution.frequencySort(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step for the problem: Given string s, sort characters by decreasing frequency. Output sorted string. Steps: count frequencies, sort by freq desc, build string. Use virtual code with arrow.\n\nWe produce lines starting with Start, End, Step, Decision. Provide explanation after //.\n\nWe need to output as per format, each line contains virtual code step and explanation.\n\nLet's produce:\n\nStart\n→ Step 1: Initialize empty frequency map // 記錄每個字元出現次數\n→ Step 2: Iterate over each character c in s\n    → Step 3: Increment frequency of c in map // 統計出現次數\n→ Step 4: Convert map entries to list of (char, freq) pairs // 準備排序\n→ Step 5: Sort list by freq in descending order // 根據頻率降序排列\n→ Step 6: Initialize empty result string builder // 準備組裝結果\n→ Step 7: For each (char, freq) in sorted list\n    → Step 8: Append char repeated freq times to result // 添加相同字元\n→ Step 9: Convert builder to string and return // 返回最終排序字串\nEnd\n\nWe need arrow lines indentation. For decisions: none needed.\n\nWe need to include arrows for step numbering. We'll use →. Provide explanation after //.\n\nLet's format accordingly. Ensure each line ends with // explanation.\n\nOk produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化一個空的頻率字典 freqMap // 用來紀錄每個字元的出現次數  \n→ Step 2: 逐一遍歷字串 s 中的每個字元 c  \n  → Step 3: 若 c 不在 freqMap，加入並設為 1，否則將 freqMap[c] 加 1 // 統計字元頻率  \n→ Step 4: 將 freqMap 轉成字元-頻率對 (char, count) 的列表 pairs // 為排序做準備  \n→ Step 5: 按照 count 降序排列 pairs // 讓頻率高的字元排在前面  \n→ Step 6: 初始化一個空字串 builder // 用來組裝結果  \n→ Step 7: 遍歷排序後的 pairs  \n  → Step 8: 將 char 重複 count 次後連接到 builder // 追加同一字元多次  \n→ Step 9: 將 builder 轉成字串並回傳 // 最終返回已按頻率降序排列的字串  \nEnd // 程式執行結束"
    },
    {
      "title": "Longest Uncommon Subsequence II",
      "source_file": "Leetcode/leetcode522.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"aaa\",\"aaa\",\"aa\"]",
          "expected_output": "-1",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '-1'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: '-1'\nRaw Got:      '2'"
        }
      ],
      "generated_code": "import sys\nimport json\n\ndef find_lus_length(strs):\n    \"\"\"\n    計算最長不常見子序列的長度。\n    只要字串在陣列中唯一，整個字串就一定不是其他字串的子序列，\n    因此可以直接以其長度作為答案。\n    \"\"\"\n    freq = {}\n    for s in strs:\n        freq[s] = freq.get(s, 0) + 1\n\n    res = -1\n    for s in strs:\n        if freq[s] == 1:\n            res = max(res, len(s))\n    return res\n\ndef main():\n    \"\"\"\n    從標準輸入讀取字串列表，計算並輸出結果。\n    輸入示例：[\"aba\",\"cdc\",\"eae\"]  → 輸出 3\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    strs = json.loads(data)\n    ans = find_lus_length(strs)\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line, following format. Provide algorithm: For each string, check if it's unique in array. If yes, answer length of that string. Else -1. Use typical solution. Need to output steps. Let's produce steps: Start, Step 1: Get array length. Step 2: For each string i: check if any other string equal? Use nested loop or frequency map. Simplify: build frequency map of strings. Then iterate over strings: if freq==1 return length of that string. If none, return -1. That is simple. Provide virtual code steps. Use arrows. Provide explanation. Use Chinese. Let's produce about 10 lines. Let's follow format. Use virtual code. Ok.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立字串頻率表 map // 將每個字串出現次數紀錄  \n→ Decision: 如果陣列長度為 0? // 空陣列直接回傳 -1  \n    Yes → Step 2: 回傳 -1 // 沒有字串可做異常子序列  \n    No  → Step 3: 為每個字串 s 於 map 中計數 // 計算每個字串的出現次數  \n→ Step 4: 為每個字串 s 循環檢查 map[s]  \n    → Decision: 如果 map[s] == 1? // 這個字串只出現一次  \n        Yes → Step 5: 回傳 length(s) // 其長度即為最長異常子序列長度  \n        No  → Step 6: 繼續檢查下一個字串 // 不是唯一，需再檢查其他字串  \n→ End // 所有字串皆重複，無法產生異常子序列，程式結束  \n→ Step 7: 回傳 -1 // 若未找到唯一字串，回傳 -1"
    },
    {
      "title": "Repeated DNA Sequences",
      "source_file": "Leetcode/leetcode187.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = 'AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT'",
          "expected_output": "[\"AAAAACCCCC\",\"CCCCCAAAAA\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"AAAAACCCCC\",\"CCCCCAAAAA\"]'\nGot (Norm):      '[\"CCCCCAAAAA\",\"AAAAACCCCC\"]'\n--- (Raw) ---\nRaw Expected: '[\"AAAAACCCCC\",\"CCCCCAAAAA\"]'\nRaw Got:      '[\"CCCCCAAAAA\", \"AAAAACCCCC\"]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport re\n\ndef find_repeated_dna_sequences(s: str):\n    \"\"\"找出 DNA 序列中重複出現的 10 字母子序列。\"\"\"\n    seen = set()      # 已看到的子序列\n    repeated = set()  # 重複出現的子序列\n\n    # 只要序列長度足夠，從左到右滑動窗口\n    for i in range(len(s) - 9):\n        seq = s[i:i + 10]          # 取長度為 10 的子序列\n        if seq in seen:\n            repeated.add(seq)      # 再次出現，加入結果\n        else:\n            seen.add(seq)          # 第一次見到，加入已看到集合\n\n    return list(repeated)\n\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取全部資料\n    raw_input = sys.stdin.read()\n\n    # 可能會得到類似 \"s = 'AAAAACC...'\" 的輸入\n    # 用正則表達式取出單引號之間的內容\n    match = re.search(r\"'([^']*)'\", raw_input)\n    dna_sequence = match.group(1) if match else raw_input.strip()\n\n    # 計算結果\n    result = find_repeated_dna_sequences(dna_sequence)\n\n    # 以 JSON 格式輸出（使用雙引號，符合範例要求）\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines. We need algorithm: sliding window of length 10, record frequencies using hash map, collect those with count>1. Complexity O(n). Provide pseudocode with Start, End, Decision, etc. Use arrow \"→\". Provide each line with // explanation. Should not output actual code. So just step-by-step virtual pseudocode.\n\nLet's create:\n\nStart\n→ Step 1: Let seq = input DNA string // 获取 DNA 序列\n→ Step 2: If length(seq) < 10 then Return empty list // 过短直接返回\n→ Step 3: Initialize empty map count // 记录子串出现次数\n→ Step 4: For i from 0 to length(seq)-10 do // 逐个窗口\n    → Step 5: sub = substring(seq, i, i+10) // 取 10 长度子串\n    → Step 6: Increment count[sub] // 计数\n→ Step 7: Initialize empty list result // 保存重复子串\n→ Step 8: For each key, val in count do\n    → Decision: If val > 1?\n        Yes → Step 9: Append key to result // 计数>1添加\n        No → Skip // 计数为1不加入\n→ Step 10: Return result // 输出重复子串列表\nEnd\n\nBut we need to use arrow for decision lines: \"Decision: If val > 1?\" etc. Use Yes →, No →.\n\nAlso we may use indentation or not. Provide each line with arrow or step names.\n\nWe should include \"Start // 程式開始執行\" etc. Use \"End // 程式執行結束\".\n\nLet's produce. Use \"→ Step 1:\" etc. Provide explanation after //. Use Chinese.\n\nMake sure each line is unique and includes arrow and explanation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取輸入字串 s // 取得 DNA 序列  \n→ Decision: 如果 s 的長度 < 10? // 是否足夠長以形成 10 字母子序列  \n    Yes → Step 2: 回傳空列表 [] // 直接返回，沒有任何子序列可重複  \n    No  → Step 3: 初始化空字典 count // 用來記錄每個 10 字母子序列的出現次數  \n→ Step 4: 從 i = 0 到 i = length(s) - 10 逐一迭代 // 對每個可能的起始位置進行滑動窗口  \n    → Step 5: sub = 子字串(s, i, i+10) // 取得以 i 為起始點的 10 字母子序列  \n    → Step 6: count[sub] = count.get(sub, 0) + 1 // 在字典中遞增該子序列的計數  \n→ Step 7: 初始化空列表 result // 用來儲存重複出現的 10 字母子序列  \n→ Step 8: 對 count 中的每一個 (key, val) 進行迭代 // 遍歷所有子序列及其計數  \n    → Decision: 如果 val > 1? // 判斷是否重複出現  \n        Yes → Step 9: 將 key 加入 result // val 大於 1 時加入結果列表  \n        No  → Step 10: 繼續 // val 為 1 時不做任何操作  \n→ Step 11: 回傳 result // 輸出所有重複的 10 字母子序列  \nEnd // 程式執行結束"
    },
    {
      "title": "Permutations",
      "source_file": "Leetcode/leetcode46.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nGot (Norm):      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nRaw Got:      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\n\nclass Solution:\n    def permute(self, nums):\n        \"\"\"\n        Generate all permutations of the distinct integers in nums.\n        Uses backtracking with in-place swapping.\n        \"\"\"\n        res = []\n\n        def backtrack(start):\n            # If the current position reaches the end, a full permutation is formed\n            if start == len(nums):\n                res.append(nums[:])  # append a copy of the current arrangement\n                return\n            # Try each candidate for the current position\n            for i in range(start, len(nums)):\n                # Swap to place nums[i] at the current position\n                nums[start], nums[i] = nums[i], nums[start]\n                backtrack(start + 1)\n                # Backtrack: restore original order\n                nums[start], nums[i] = nums[i], nums[start]\n\n        backtrack(0)\n        return res\n\nif __name__ == \"__main__\":\n    # Read the entire input\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n\n    # Expected format: \"nums = [1,2,3]\"\n    try:\n        # Split on the first '=' and parse the right side\n        _, list_part = raw_input.split('=', 1)\n        nums = ast.literal_eval(list_part.strip())\n    except Exception as e:\n        raise ValueError(f\"Invalid input format: {raw_input}\") from e\n\n    # Ensure nums is a list of distinct integers\n    if not isinstance(nums, list) or len(nums) != len(set(nums)):\n        raise ValueError(\"Input must be a list of distinct integers\")\n\n    solution = Solution()\n    permutations = solution.permute(nums)\n\n    # Output in compact JSON-like format without spaces\n    print(json.dumps(permutations, separators=(',', ':')))",
      "virtual_code": "Thinking...\nWe need to produce a virtual code for generating all permutations of a distinct integer array. Use recursion/backtracking. Provide each line of pseudocode with explanation.\n\nWe need to follow format: start with Start, End, Decision, etc. Each line: `虛擬碼步驟 // 解釋/說明`. Use arrow → and Yes/No.\n\nWe must not output actual code. Just virtual steps.\n\nLet's craft step-by-step:\n\nStart\n\n→ Initialize result list\n\n→ Define backtrack function with parameters current permutation and used array or remaining\n\nWe can either maintain a current list and a visited flag array, or use swapping method. Let's use visited boolean.\n\n→ backtrack(current, used) // recursively build permutations\n\n→ Decision: current length == nums length? // if permutation complete\n\n    Yes → Step: Add copy of current to result\n\n    No → Loop over i in range len(nums)\n\n        Decision: used[i] == false? // if not used\n\n            Yes → Step: Mark used[i] = true\n\n            → Step: Append nums[i] to current\n\n            → Step: backtrack(current, used)\n\n            → Step: Remove last from current\n\n            → Step: Mark used[i] = false\n\n→ After defining backtrack, call backtrack([], [false]*len(nums))\n\n→ End // return result\n\nAdd comments accordingly.\n\nEnsure each line follows \"→ Step: ...\" or \"Decision:\". Use arrows.\n\nAlso include indentation? Not necessary but can show.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: result ← [] // 用來存放所有排列結果  \n→ Step 2: numsLen ← length(nums) // 獲取輸入陣列長度  \n→ Step 3: visited ← array of boolean size numsLen, all false // 標記每個元素是否已被使用  \n\n→ Step 4: Define backtrack(current, visited) // 递归构建排列  \n→ Decision: length(current) == numsLen? // 当前排列是否已完整  \n  Yes → Step 5: Append copy of current to result // 把完整排列加入结果  \n  No → Step 6: For i from 0 to numsLen-1 // 遍历所有元素  \n   Decision: visited[i] == false? // 元素是否未被使用  \n    Yes → Step 7: visited[i] ← true // 标记为已使用  \n     → Step 8: Append nums[i] to current // 将元素加入当前排列  \n     → Step 9: backtrack(current, visited) // 继续递归  \n     → Step 10: Remove last element from current // 回溯，撤销选择  \n     → Step 11: visited[i] ← false // 标记为未使用  \n→ Step 12: backtrack([], visited) // 开始递归，初始为空排列  \n\nEnd // 程式執行結束，返回 result"
    },
    {
      "title": "Find the Duplicate Number",
      "source_file": "Leetcode/leetcode287.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "nums = [3,1,3,4,2]",
          "expected_output": "O3",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'O3'\nGot (Norm):      '3'\n--- (Raw) ---\nRaw Expected: 'O3'\nRaw Got:      '3'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findDuplicate(self, nums):\n        \"\"\"\n        Find the duplicate number in an array using Floyd's Tortoise and Hare algorithm.\n        The array contains n+1 integers with values ranging from 1 to n inclusive,\n        and there is exactly one duplicated value.\n        \"\"\"\n        # Phase 1: Find the intersection point of the two runners.\n        slow = fast = nums[0]\n        while True:\n            slow = nums[slow]            # move slow pointer by 1 step\n            fast = nums[nums[fast]]      # move fast pointer by 2 steps\n            if slow == fast:\n                break\n\n        # Phase 2: Find the entrance to the cycle, which is the duplicate number.\n        slow = nums[0]\n        while slow != fast:\n            slow = nums[slow]\n            fast = nums[fast]\n\n        return slow\n\nif __name__ == \"__main__\":\n    # Read entire input; expected format like: nums = [1,3,4,2,2]\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n\n    # Extract the list part after '=' and evaluate safely\n    try:\n        _, list_part = raw_input.split('=', 1)\n        nums = ast.literal_eval(list_part.strip())\n    except Exception:\n        # If input is just a plain list string, try to eval it directly\n        nums = ast.literal_eval(raw_input)\n\n    result = Solution().findDuplicate(nums)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for Floyd's Tortoise and Hare algorithm. The problem: find duplicate number. Must not modify array, constant space. We'll produce virtual code steps:\n\nStart, initialize two pointers, slow and fast. Both start at first element. Then loop until they meet. After cycle detection, find entry point by resetting one pointer to start, then move both at same speed until they meet again. Return meeting value.\n\nWe must output line by line with explanation. Use arrow for each step. Use Decision and End. Provide steps.\n\nLet's produce: \nStart\n→ Step 1: 初始化 slow ← nums[0], fast ← nums[0] // 兩個指針開始於陣列第一個位置\n→ Step 2: 循環: slow ← nums[slow], fast ← nums[nums[fast]] // 快慢指針進行遍歷\n    Decision: 如果 slow == fast? // 檢查是否相遇\n        Yes → 跳出循環 // 找到迴圈內相遇點\n        No → 继续 Step 2 // 继续循环\n→ Step 3: 重置 slow ← nums[0] // 将 slow 指向起始位置\n→ Step 4: 再次循環: slow ← nums[slow], fast ← nums[fast] // 兩指針同速前進\n    Decision: 如果 slow == fast? // 找到入口點\n        Yes → Step 5: 返回 slow // 该值即为重复数\n        No → 继续 Step 4 // 继续前进\nEnd\n\nBut need to maintain the same format: each line starts with virtual code step then comment.\n\nLet's produce:\n\n```\nStart // 程式開始執行\n→ Step 1: slow ← nums[0] // 初始化慢指針為陣列第一個元素\n→ Step 2: fast ← nums[0] // 初始化快指針為陣列第一個元素\n→ Step 3: While True: // 進入偵測迴圈\n    → slow ← nums[slow] // 慢指針前進一步\n    → fast ← nums[nums[fast]] // 快指針前進兩步\n    → Decision: slow == fast? // 檢查是否相遇\n        Yes → Break // 迴圈結束，已找到相遇點\n        No → Continue // 繼續偵測\n→ Step 4: slow ← nums[0] // 將慢指針重置為起始位置\n→ Step 5: While True: // 進入尋找入口\n    → slow ← nums[slow] // 慢指針每次前進一步\n    → fast ← nums[fast] // 快指針每次前進一步\n    → Decision: slow == fast? // 檢查是否相遇\n        Yes → Return slow // 相遇即為重複數\n        No → Continue // 繼續尋找\nEnd // 程式執行結束\n```\n\nBut we need each line with \"虛擬碼步驟\" and comment. The lines with while loops should be considered steps too.\n\nMaybe break each line:\n\n- Start\n- → Step 1: ...\n- → Step 2: ...\n- → Step 3: While True: // Start cycle detection\n- → Step 3.1: slow ← nums[slow]\n- → Step 3.2: fast ← nums[nums[fast]]\n- → Step 3.3: Decision: slow == fast?\n  Yes → Step 3.4: Break\n  No → Step 3.5: Continue\n- → Step 4: slow ← nums[0]\n- → Step 5: While True: // Find entrance\n- → Step 5.1: slow ← nums[slow]\n- → Step 5.2: fast ← nums[fast]\n- → Step 5.3: Decision: slow == fast?\n  Yes → Step 5.4: Return slow\n  No → Step 5.5: Continue\n- End\n\nWe should ensure \"→\" at start of each step line, and \"Decision:\" lines accordingly.\n\nMake sure we keep each line with space after virtual code and comment.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: slow ← nums[0] // 初始化慢指針為陣列第一個元素  \n→ Step 2: fast ← nums[0] // 初始化快指針為陣列第一個元素  \n→ Step 3: While True: // 進入偵測迴圈，尋找相遇點  \n  → Step 3.1: slow ← nums[slow] // 慢指針每次前進一步  \n  → Step 3.2: fast ← nums[nums[fast]] // 快指針每次前進兩步  \n  → Decision: slow == fast? // 檢查兩指針是否相遇  \n   Yes → Step 3.3: Break // 相遇，結束偵測迴圈  \n   No → Step 3.4: Continue // 未相遇，繼續偵測  \n→ Step 4: slow ← nums[0] // 將慢指針重置回陣列起始位置  \n→ Step 5: While True: // 進入尋找入口，兩指針同速前進  \n  → Step 5.1: slow ← nums[slow] // 慢指針每次前進一步  \n  → Step 5.2: fast ← nums[fast] // 快指針每次前進一步  \n  → Decision: slow == fast? // 檢查兩指針是否相遇  \n   Yes → Step 5.3: Return slow // 相遇即為重複數，返回結果  \n   No → Step 5.4: Continue // 未相遇，繼續尋找  \nEnd // 程式執行結束"
    },
    {
      "title": "Insert Delete GetRandom O(1) - Duplicates allowed",
      "source_file": "Leetcode/leetcode381.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedCollection\", \"insert\", \"insert\", \"insert\", \"getRandom\", \"remove\", \"getRandom\"], [[], [1], [1], [2], [], [1], []]",
          "expected_output": "[null, true, false, true, 2, true, 1]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,false,true,2,true,1]'\nGot (Norm):      '[null,true,false,true,2,true,2]'\n--- (Raw) ---\nRaw Expected: '[null, true, false, true, 2, true, 1]'\nRaw Got:      '[null, true, false, true, 2, true, 2]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\nimport collections\n\nclass RandomizedCollection:\n    \"\"\"隨機集合，允許重複元素，支持 O(1) 插入、刪除與隨機抽取\"\"\"\n\n    def __init__(self):\n        # 1. values 存放所有元素，重複允許\n        self.values = []\n        # 2. idx_map: value -> set of indices 在 values 中的位置\n        self.idx_map = collections.defaultdict(set)\n\n    def insert(self, val: int) -> bool:\n        \"\"\"插入元素，返回此元素是否首次出現\"\"\"\n        self.values.append(val)\n        self.idx_map[val].add(len(self.values) - 1)\n        # 若此值剛插入，set 的長度為 1，表示第一次插入\n        return len(self.idx_map[val]) == 1\n\n    def remove(self, val: int) -> bool:\n        \"\"\"刪除一次元素，若不存在則返回 False\"\"\"\n        if not self.idx_map[val]:\n            return False\n\n        # 取出要刪除位置的任一索引\n        remove_idx = self.idx_map[val].pop()\n        last_idx = len(self.values) - 1\n        last_val = self.values[last_idx]\n\n        if remove_idx != last_idx:\n            # 把最後一個元素移到 remove_idx 位置\n            self.values[remove_idx] = last_val\n            self.idx_map[last_val].add(remove_idx)\n            self.idx_map[last_val].discard(last_idx)\n\n        # 刪除最後一個元素\n        self.values.pop()\n\n        # 如果此值不再存在，從 idx_map 刪除\n        if not self.idx_map[val]:\n            del self.idx_map[val]\n        return True\n\n    def getRandom(self) -> int:\n        \"\"\"隨機返回一個元素，機率與其重複數成正比\"\"\"\n        return random.choice(self.values)\n\n\ndef main():\n    # 讀取整個輸入，通常為\n    # [\"RandomizedCollection\", \"insert\", \"insert\", ...], [[], [1], [1], ...]\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 用括號包住，使其成為合法的 tuple 表達式\n    commands, args = ast.literal_eval(f'({data})')\n\n    obj = None\n    results = []\n\n    for cmd, arg in zip(commands, args):\n        if cmd == 'RandomizedCollection':\n            obj = RandomizedCollection()\n            results.append(None)\n        elif cmd == 'insert':\n            results.append(obj.insert(arg[0]))\n        elif cmd == 'remove':\n            results.append(obj.remove(arg[0]))\n        elif cmd == 'getRandom':\n            results.append(obj.getRandom())\n        else:\n            # 不會出現未知指令\n            results.append(None)\n\n    # 將結果轉換成 LeetCode 風格的輸出\n    def to_json_like(val):\n        if val is None:\n            return 'null'\n        if val is True:\n            return 'true'\n        if val is False:\n            return 'false'\n        return str(val)\n\n    output = '[' + ', '.join(to_json_like(v) for v in results) + ']'\n    print(output)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need produce virtual code lines. For RandomizedCollection class design: use vector for values, unordered_map<int, unordered_set<int>> for indices. Provide insert, remove, getRandom. Each operation O(1). Provide pseudocode.\n\nLet's produce steps.\n\nWe need start, steps for constructor, insert, remove, getRandom. Use Decision. Also explain each.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 RandomizedCollection 類別 // 建立主類別  \n→ Decision: 初始化資料結構 // 準備儲存資料  \n    Yes → Step 2: 建立 vector<int> values // 存放所有元素，允許重複  \n    Yes → Step 3: 建立 unordered_map<int, unordered_set<int>> idxMap // 每個值對應其在 values 中的索引集合  \n→ End // 建構完成  \n\nStart // insert 方法開始  \n→ Step 4: 接收輸入 val // 要插入的值  \n→ Decision: 是否已存在 val? // 判斷 val 是否已在 idxMap 中  \n    Yes → Step 5: 在 values 尾端 push_back(val) // 加入新值  \n    Yes → Step 6: 在 idxMap[val] 新增 values 末尾索引 // 更新索引集合  \n    Yes → Step 7: 如果 val 原先不存在則返回 true，否則 false // 返回插入成功與否  \n→ End // insert 完成  \n\nStart // remove 方法開始  \n→ Step 8: 接收輸入 val // 要移除的值  \n→ Decision: idxMap[val] 是否非空？ // 判斷 val 是否存在  \n    Yes → Step 9: 取出 idxMap[val] 的任一索引 removeIdx // 取一個待刪除的位置  \n    Yes → Step 10: 取 values 最後一個元素 lastVal // 準備移動到 removeIdx  \n    Yes → Step 11: 把 lastVal 放到 values[removeIdx] // 覆蓋要刪除的位置  \n    Yes → Step 12: 更新 idxMap[lastVal]：移除原 lastVal 索引，加入 removeIdx // 調整索引集合  \n    Yes → Step 13: 從 idxMap[val] 移除 removeIdx // 刪除已移除元素的索引  \n    Yes → Step 14: values.pop_back() // 刪除最後一個元素  \n    Yes → Step 15: 若 idxMap[val] 變空，刪除 idxMap[val] // 清理空集合  \n    Yes → Step 16: 返回 true // 表示成功移除  \n    No  → Step 17: 返回 false // val 不存在，無法移除  \n→ End // remove 完成  \n\nStart // getRandom 方法開始  \n→ Step 18: 產生隨機索引 randIdx 介於 0 和 values.size()-1 // 隨機位置  \n→ Step 19: 回傳 values[randIdx] // 取得隨機元素  \n→ End // getRandom 完成  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Find Median from Data Stream",
      "source_file": "Leetcode/leetcode295.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"], [[], [1], [2], [], [3], []]",
          "expected_output": "[null, null, null, 1.5, null, 2.0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,1.5,null,2.0]'\nGot (Norm):      '[null,null,null,1.5,null,2]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, 1.5, null, 2.0]'\nRaw Got:      '[null, null, null, 1.5, null, 2]'"
        }
      ],
      "generated_code": "import sys\nimport heapq\nimport ast\nimport json\n\nclass MedianFinder:\n    def __init__(self):\n        self.small = []  # max-heap (invert sign)\n        self.large = []  # min-heap\n\n    def addNum(self, num: int) -> None:\n        heapq.heappush(self.small, -num)\n        if self.large and -self.small[0] > self.large[0]:\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        if len(self.small) > len(self.large) + 1:\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        elif len(self.large) > len(self.small):\n            val = heapq.heappop(self.large)\n            heapq.heappush(self.small, -val)\n\n    def findMedian(self) -> float:\n        if len(self.small) > len(self.large):\n            return -self.small[0]\n        return (-self.small[0] + self.large[0]) / 2.0\n\ndef parse_input(data: str):\n    data = data.strip()\n    if not data:\n        return [], []\n    lines = data.splitlines()\n    if len(lines) == 2:\n        ops = ast.literal_eval(lines[0].strip())\n        args = ast.literal_eval(lines[1].strip())\n    else:\n        # single line containing two lists separated by a comma\n        parts = data.split('],', 1)\n        if len(parts) != 2:\n            raise ValueError(\"Input format is incorrect.\")\n        ops = ast.literal_eval(parts[0] + ']')\n        args = ast.literal_eval(parts[1].strip())\n    return ops, args\n\ndef main():\n    data = sys.stdin.read()\n    ops, args = parse_input(data)\n\n    result = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"MedianFinder\":\n            obj = MedianFinder()\n            result.append(None)\n        elif op == \"addNum\":\n            obj.addNum(arg[0])\n            result.append(None)\n        elif op == \"findMedian\":\n            median = obj.findMedian()\n            result.append(median)\n        else:\n            result.append(None)\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code, step by step, for implementing MedianFinder with addNum and findMedian. Use structure with Start, End, Decision. Provide per line explanation. Must not output real code, just virtual steps.\n\nLet's outline algorithm: Use two heaps: max-heap for lower half, min-heap for upper half. When adding number: if lower heap empty or num <= max of lower, push into lower; else push into upper. Rebalance sizes so that difference <=1. findMedian: if sizes equal, median = (max_lower + min_upper)/2. else median = top of larger heap.\n\nWe'll write virtual steps accordingly. Each line includes virtual code step, then comment. Use arrow for transitions. Use indentation for nested decisions.\n\nLet's craft.\n\nStart // program start\n→ Step 1: 定義類 MedianFinder，內部有兩個堆：maxHeap (大頂堆)，minHeap (小頂堆) // 建立資料結構\n→ Step 2: 構造函數 MedianFinder() // 初始化堆\n    → Step 2.1: maxHeap = 空堆 // 大頂堆\n    → Step 2.2: minHeap = 空堆 // 小頂堆\n→ Step 3: 方法 addNum(num: int) // 新增數字\n    → Decision: maxHeap 为空 或 num ≤ maxHeap.peek()? // 判斷數字應放於下半堆\n        Yes → Step 3.1: maxHeap.push(num) // 加入下半堆\n        No  → Step 3.2: minHeap.push(num) // 加入上半堆\n    → Step 3.3: Decision: maxHeap.size() > minHeap.size() + 1? // 重新平衡：左多一\n        Yes → Step 3.3.1: minHeap.push(maxHeap.pop()) // 把最大移到上半堆\n        No  → Decision: minHeap.size() > maxHeap.size() + 1? // 右多一\n            Yes → Step 3.3.2: maxHeap.push(minHeap.pop()) // 把最小移到下半堆\n            No  → Step 3.3.3: // 已平衡，無需操作\n→ Step 4: 方法 findMedian() → double // 取得中位數\n    → Decision: maxHeap.size() == minHeap.size()? // 數量相等\n        Yes → Step 4.1: return (maxHeap.peek() + minHeap.peek()) / 2.0 // 兩者平均\n        No  → Decision: maxHeap.size() > minHeap.size()? // 下半多\n            Yes → Step 4.2: return maxHeap.peek() // 下半堆頂\n            No  → Step 4.3: return minHeap.peek() // 上半堆頂\nEnd // 程式結束\n\nNeed to ensure each line has arrow. For steps with indentation, maybe use indentation to show nested. We'll format accordingly.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類 MedianFinder，內部有兩個堆：maxHeap（大頂堆），minHeap（小頂堆） // 建立資料結構  \n→ Step 2: 構造函數 MedianFinder() // 初始化堆  \n  → Step 2.1: maxHeap = 空堆 // 大頂堆  \n  → Step 2.2: minHeap = 空堆 // 小頂堆  \n→ Step 3: 方法 addNum(num: int) // 新增數字  \n  → Decision: maxHeap 为空 或 num ≤ maxHeap.peek()? // 判斷數字應放於下半堆  \n    Yes → Step 3.1: maxHeap.push(num) // 加入下半堆  \n    No  → Step 3.2: minHeap.push(num) // 加入上半堆  \n  → Step 3.3: Decision: maxHeap.size() > minHeap.size() + 1? // 重新平衡：左多一  \n    Yes → Step 3.3.1: minHeap.push(maxHeap.pop()) // 把最大移到上半堆  \n    No  → Decision: minHeap.size() > maxHeap.size() + 1? // 右多一  \n      Yes → Step 3.3.2: maxHeap.push(minHeap.pop()) // 把最小移到下半堆  \n      No  → Step 3.3.3: // 已平衡，無需操作  \n→ Step 4: 方法 findMedian() → double // 取得中位數  \n  → Decision: maxHeap.size() == minHeap.size()? // 數量相等  \n    Yes → Step 4.1: return (maxHeap.peek() + minHeap.peek()) / 2.0 // 兩者平均  \n    No  → Decision: maxHeap.size() > minHeap.size()? // 下半多  \n      Yes → Step 4.2: return maxHeap.peek() // 下半堆頂  \n      No  → Step 4.3: return minHeap.peek() // 上半堆頂  \nEnd // 程式結束執行"
    },
    {
      "title": "Insert Interval",
      "source_file": "Leetcode/leetcode57.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "intervals = [[1,3],[6,9]], newInterval = [2,5]",
          "expected_output": "[[1,5],[6,9]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpf135rgbd.py\", line 55, in <module>\n    main()\n  File \"/tmp/tmpf135rgbd.py\", line 44, in main\n    intervals = ast.literal_eval(list_strings[0])\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[1,3]\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]",
          "expected_output": "[[1,2],[3,10],[12,16]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpiev_iaq5.py\", line 55, in <module>\n    main()\n  File \"/tmp/tmpiev_iaq5.py\", line 44, in main\n    intervals = ast.literal_eval(list_strings[0])\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[1,2]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def insert(self, intervals, newInterval):\n        result = []\n        i = 0\n        n = len(intervals)\n\n        # Add all intervals that end before the new interval starts\n        while i < n and intervals[i][1] < newInterval[0]:\n            result.append(intervals[i])\n            i += 1\n\n        # Merge all overlapping intervals with newInterval\n        while i < n and intervals[i][0] <= newInterval[1]:\n            newInterval[0] = min(newInterval[0], intervals[i][0])\n            newInterval[1] = max(newInterval[1], intervals[i][1])\n            i += 1\n\n        # Insert the merged interval\n        result.append(newInterval)\n\n        # Add the remaining intervals\n        while i < n:\n            result.append(intervals[i])\n            i += 1\n\n        return result\n\ndef main():\n    # Read entire input\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Find all bracketed lists in the input\n    list_strings = re.findall(r'\\[[^\\]]*\\]', data)\n    if len(list_strings) < 2:\n        raise ValueError(\"Input must contain two lists: intervals and newInterval\")\n\n    # Convert the string representations to actual Python lists\n    intervals = ast.literal_eval(list_strings[0])\n    new_interval = ast.literal_eval(list_strings[1])\n\n    # Solve\n    solution = Solution()\n    merged = solution.insert(intervals, new_interval)\n\n    # Output result\n    print(merged)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the problem of inserting an interval into sorted non-overlapping intervals. Provide steps with explanations. Use arrow style. Ensure every line has \"虛擬碼步驟 // 解釋\". No real code. Let's craft step by step: Start, create result list, iterate, decisions for before, overlapping, after. Then append. End. Also handle merging. Provide decisions with Yes/No. Provide steps like: iterate i from 0 to n-1. For each interval, if current end < new start: before. If current start > new end: after. Else overlapping. Also need to merge overlapping intervals: update new start = min(new start, current start), new end = max(new end, current end). After loop, append new interval. That yields final list. So produce virtual steps.\n\nNeed to use \"Decision:\" lines with Yes→ etc. Provide arrow formatting. Use Start, End. Provide comments. Let's produce.\n\nLet's produce a list:\n\nStart\n→ Initialize result list // 用於存放最終合併後的 intervals\n→ Initialize i = 0 // 用於遍歷原始 intervals\n→ Decision: i < intervals.length? // 是否還有 intervals 可處理\n    Yes → Decision: intervals[i].end < newInterval.start? // 當前 interval 完全在新 interval 之前\n        Yes → Step: Add intervals[i] to result // 直接加入 result\n        No  → Decision: intervals[i].start > newInterval.end? // 當前 interval 完全在新 interval 之後\n            Yes → Step: Add newInterval to result // 加入新 interval\n            No  → Step: Merge intervals[i] with newInterval // 合併兩個區間\n    No  → Step: No more intervals, break loop // 退出迴圈\n→ After loop: Decision: newInterval 尚未加入? // 檢查是否已加入\n    Yes → Step: Add newInterval to result // 加入剩餘新 interval\n    No  → // 已加入，無需再添加\nEnd\n\nBut we need to handle the loop structure properly. Use arrows and indentation maybe. Provide each step as a line.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 result 為空清單 // 用來儲存最終的 intervals  \n→ Step 2: 初始化 i = 0 // 用來遍歷原始 intervals  \n\n→ Decision: i < intervals.length? // 是否還有未處理的 interval  \n    Yes → Decision: intervals[i].end < newInterval.start? // 當前 interval 完全在新 interval 前面  \n        Yes → Step 3: 將 intervals[i] 加入 result // 直接加入結果清單  \n        No  → Decision: intervals[i].start > newInterval.end? // 當前 interval 完全在新 interval 後面  \n            Yes → Step 4: 將 newInterval 加入 result // 新 interval 放進結果清單  \n            No  → Step 5: 合併 intervals[i] 與 newInterval  \n                // 更新 newInterval 為兩者的最小起點與最大終點  \n                → newInterval.start = min(newInterval.start, intervals[i].start)  \n                → newInterval.end   = max(newInterval.end,   intervals[i].end)  \n    No  → Step 6: i 已達結束，結束迴圈  \n\n→ Step 7: i++ // 前進到下一個 interval  \n→ 跳回 Decision: i < intervals.length? // 重複處理所有 interval  \n\n→ Decision: newInterval 尚未加入 result? // 檢查是否已經被加入  \n    Yes → Step 8: 將 newInterval 加入 result // 把剩餘的新 interval 加入清單  \n    No  → // 已加入，不再重複  \n\nEnd // 程式執行結束，返回 result"
    },
    {
      "title": "Group Anagrams",
      "source_file": "Leetcode/leetcode49.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]",
          "expected_output": "[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]'\nGot (Norm):      '[[\"eat\",\"tea\",\"ate\"],[\"tan\",\"nat\"],[\"bat\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]'\nRaw Got:      \"[['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]\""
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def groupAnagrams(self, strs):\n        anagrams = defaultdict(list)\n        for s in strs:\n            key = tuple(sorted(s))   # 將字串排序後作為鍵\n            anagrams[key].append(s)\n        return list(anagrams.values())\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    # 解析輸入：支持 \"strs = [...]\" 或直接寫為 [...]\n    if '=' in raw_input:\n        _, expr = raw_input.split('=', 1)\n        expr = expr.strip()\n    else:\n        expr = raw_input\n\n    try:\n        strs = ast.literal_eval(expr)\n    except Exception:\n        # 如果 literal_eval 失敗，嘗試使用 eval（安全環境）\n        strs = eval(expr, {\"__builtins__\": None}, {})\n\n    solution = Solution()\n    result = solution.groupAnagrams(strs)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to output virtual code steps line by line, with explanation. For grouping anagrams. The virtual code should use Start, End, Decision etc. Let's design.\n\nWe need to iterate over array, create a dictionary keyed by sorted string, store lists. Steps: Start, Step1: initialize empty map. Step2: For each string s in strs: compute sorted_s = sort(s). Then if sorted_s not in map, create new list. Append s to map[sorted_s]. End loop. Step3: Convert map values to list of lists. Output result. End.\n\nInclude Decision: If sorted_s exists in map? Yes/No. Also maybe step for converting sorted string into key.\n\nAlso maybe mention that sorting string yields sorted_s.\n\nWe must provide line by line. Use arrows.\n\nLet's produce:\n\nStart\n→ Step 1: Initialize an empty hash map M // 用於存放根據排序字串對應的單詞列表\n→ Step 2: 遍歷陣列 strs 中的每個字串 s // 逐一處理每個字串\n    → Step 2.1: 計算 s 的排序字串 key = sorted(s) // 以字母順序排列得到分組鍵\n    → Decision: key 是否已存在於 M？ // 判斷此鍵是否已有列表\n        Yes → Step 2.2: M[key].append(s) // 已存在，將字串加入對應列表\n        No  → Step 2.3: M[key] = [s] // 不存在，建立新列表並加入字串\n→ Step 3: 將 M 的所有值收集為結果列表 result = list(M.values()) // 取出所有分組\n→ Step 4: 輸出 result // 回傳分組後的結果\nEnd\n\nMake sure each line has // explanation. Use appropriate arrow syntax. Include indentation for nested steps.\n\nLet's format exactly.\n\nUse arrow symbol '→', and Decision: with Yes →, No →.\n\nLet's write.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化一個空的雜湊表 M // 用來存放以排序字串為鍵、對應字串列表為值  \n→ Step 2: 遍歷陣列 strs 中的每個字串 s // 逐一處理每個字串  \n → Step 2.1: 計算字串 s 的排序鍵 key = sorted(s) // 將字串中的字母重新排列，得到分組鍵  \n → Decision: key 是否已存在於 M？ // 判斷此鍵是否已有對應的列表  \n  Yes → Step 2.2: M[key].append(s) // 已存在，將字串加入該列表  \n  No  → Step 2.3: M[key] = [s] // 不存在，建立新列表並加入字串  \n→ Step 3: 取得雜湊表 M 的所有值，並轉成結果列表 result = list(M.values()) // 收集所有分組  \n→ Step 4: 輸出 result // 回傳分組後的字串列表  \nEnd // 程式執行結束"
    },
    {
      "title": "Roman to Integer",
      "source_file": "Leetcode/leetcode13.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 2,
          "input": "Input: s = \"MCMXCIV\"",
          "expected_output": "Output: 1994",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'Output:1994'\nGot (Norm):      '1994'\n--- (Raw) ---\nRaw Expected: 'Output: 1994'\nRaw Got:      '1994'"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef roman_to_int(s: str) -> int:\n    \"\"\"將羅馬數字字串轉成整數。\"\"\"\n    roman_map = {\n        'I': 1, 'V': 5, 'X': 10, 'L': 50,\n        'C': 100, 'D': 500, 'M': 1000\n    }\n    total = 0\n    prev = 0\n    # 由右往左遍歷，若當前值小於前一個值則減法，否則加法\n    for ch in reversed(s):\n        val = roman_map[ch]\n        if val < prev:\n            total -= val\n        else:\n            total += val\n        prev = val\n    return total\n\ndef main() -> None:\n    \"\"\"讀取輸入，解析羅馬數字，輸出對應整數。\"\"\"\n    data = sys.stdin.read()\n\n    # 從字串中提取雙引號內的內容（如 \"MCMXCIV\"）\n    match = re.search(r'\"([^\"]+)\"', data)\n    if match:\n        s = match.group(1)\n    else:\n        # 若沒有雙引號，嘗試單引號\n        match = re.search(r\"'([^']+)'\", data)\n        if match:\n            s = match.group(1)\n        else:\n            # 最後嘗試直接篩選羅馬數字字符\n            s = ''.join(c for c in data if c in \"IVXLCDM\")\n\n    result = roman_to_int(s.strip())\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line with explanations. Input: Roman numeral string, output integer. Need algorithm: mapping symbols to values; iterate over string from left to right; if current symbol value < next symbol value then subtract else add. Return total.\n\nWe'll produce steps: Start, input string, initialize map, total=0, iterate index, get current value, check next if exists else 0, decide subtract or add, update total, increment index appropriately. End.\n\nWe need to use decision arrows: Decision: if current value < next value? Yes → subtract else add. Also loop until index < length.\n\nLet's structure:\n\nStart\n→ Step 1: 接收羅馬數字字串 // 取得輸入\n→ Step 2: 建立符號對應值表 // mapping\n→ Step 3: total ← 0 // 初始化總和\n→ Step 4: index ← 0 // 設定指標\n→ Decision: index < length? // 判斷是否還有字元\n    Yes → Step 5: currVal ← value of char at index // 取得目前符號值\n    → Step 6: nextVal ← value of char at index+1 if exists else 0 // 取得下一符號值\n    → Decision: currVal < nextVal? // 判斷是否要減法\n        Yes → Step 7: total ← total - currVal // 減去\n        No  → Step 8: total ← total + currVal // 加上\n    → Step 9: index ← index + 1 // 前進\n    → Back to Decision: index < length?\n    No → End // 完成\nEnd\n\nBut need arrow formatting: Use \"→\" before steps. Decision with \"Decision:\" lines. Use \"Yes →\" and \"No →\". For back to decision, we can show loop.\n\nLet's craft.\n\nRemember to include // explanations after each line.\n\nAlso need to note \"Start\" and \"End\".\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 接收羅馬數字字串 // 取得輸入的字串\n→ Step 2: 建立符號對應值表 // 定義 I→1, V→5, X→10, L→50, C→100, D→500, M→1000\n→ Step 3: total ← 0 // 初始化總和為 0\n→ Step 4: index ← 0 // 初始化指標為 0\n→ Decision: index < length? // 判斷是否還有字元要處理\n    Yes → Step 5: currVal ← value of char at index // 取得目前符號的數值\n    → Step 6: nextVal ← value of char at index+1 if exists else 0 // 取得下一符號的數值，若不存在則為 0\n    → Decision: currVal < nextVal? // 判斷是否應該使用減法規則\n        Yes → Step 7: total ← total - currVal // 進行減法\n        No  → Step 8: total ← total + currVal // 進行加法\n    → Step 9: index ← index + 1 // 移動到下一個符號\n    → Decision: index < length? // 重新判斷是否還有未處理的字元\n        Yes → 回到上面\n        No  → End // 所有字元已處理，結束循環\nEnd // 程式執行結束，total 為最終的整數結果"
    },
    {
      "title": "K^th Smallest Element in a Sorted Matrix",
      "source_file": "Leetcode/leetcode378.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8",
          "expected_output": "13",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '13'\nGot (Norm):      '[1,5,9]'\n--- (Raw) ---\nRaw Expected: '13'\nRaw Got:      '[1, 5, 9]'"
        },
        {
          "example_index": 1,
          "input": "matrix = [[-5]], k = 1",
          "expected_output": "-5",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '-5'\nGot (Norm):      '[-5]'\n--- (Raw) ---\nRaw Expected: '-5'\nRaw Got:      '[-5]'"
        }
      ],
      "generated_code": "import sys\n\ndef kth_smallest(matrix, k):\n    n = len(matrix)\n    low = matrix[0][0]\n    high = matrix[n - 1][n - 1]\n\n    while low < high:\n        mid = (low + high) // 2\n        count = 0\n        i, j = n - 1, 0  # start from left‑bottom\n        while i >= 0 and j < n:\n            if matrix[i][j] <= mid:\n                count += n - i  # all elements above this in the same column are <= mid\n                j += 1\n            else:\n                i -= 1\n        if count >= k:\n            high = mid\n        else:\n            low = mid + 1\n    return low\n\ndef parse_input(data: str):\n    # extract the matrix and k from the input string\n    data = data.strip()\n    matrix_start = data.find('matrix')\n    k_start = data.find('k')\n    if matrix_start == -1 or k_start == -1:\n        raise ValueError(\"Input must contain 'matrix' and 'k'\")\n    matrix_part = data[matrix_start + len('matrix'):k_start].strip()\n    k_part = data[k_start + len('k'):].strip()\n\n    # remove possible equals sign\n    if '=' in matrix_part:\n        matrix_part = matrix_part.split('=', 1)[-1].strip()\n    if '=' in k_part:\n        k_part = k_part.split('=', 1)[-1].strip()\n\n    matrix = eval(matrix_part)\n    k = int(k_part)\n    return matrix, k\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read()\n    matrix, k = parse_input(input_data)\n    result = kth_smallest(matrix, k)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps in Chinese, line by line, with // explanation. Use arrow, Decision etc.\n\nWe need algorithm: matrix sorted rows and columns. Find k-th smallest. Classic approach: binary search over value range, counting <= mid by scanning from bottom-left or top-right. Or use min-heap. Memory O(n). Use binary search: low=matrix[0][0], high=matrix[n-1][n-1], while low<high: mid=(low+high)/2, count elements <= mid. If count>=k, high=mid else low=mid+1. Return low.\n\nCounting: start from bottom-left corner, move up or right.\n\nAlso need to maintain memory less than O(n^2). O(n) memory.\n\nSo virtual code: start, input n, matrix, k, define low, high, while loop. inside count function.\n\nWe need to output each step line by line, with explanation after space and //.\n\nUse arrow: → for steps. Decision: etc.\n\nWe need to be careful to include proper indentation? Use arrow to show flow. Example in spec.\n\nOk.\n\nLet's produce steps:\n\nStart\n\n→ Step 1: 讀取矩陣大小 n 和參數 k // 取得輸入\n\n→ Step 2: 設定 low = matrix[0][0] // 最小值\n\n→ Step 3: 設定 high = matrix[n-1][n-1] // 最大值\n\n→ Decision: low < high? // 是否還有範圍待搜索\n\n    Yes →\n\n        → Step 4: 計算 mid = (low + high) / 2 // 中位數候選\n\n        → Step 5: 初始化 count = 0 // 記錄 <= mid 的個數\n\n        → Step 6: 設定 i = n-1, j = 0 // 從左下角開始\n\n        → Decision: i >= 0 且 j < n? // 是否還在矩陣內\n\n            Yes →\n\n                → Step 7: 如果 matrix[i][j] <= mid?\n\n                    Yes →\n\n                        → Step 8: count += n - i // 這列以上所有元素都 <= mid\n\n                        → Step 9: j += 1 // 移到右方\n\n                    No →\n\n                        → Step 10: i -= 1 // 向上移動\n\n                → Step 11: 返回 Decision: i >= 0 且 j < n? // 迴圈\n\n            No →\n\n                → Step 12: 结束计数\n\n        → Step 13: Decision: count >= k? // 判断是否已到 k\n\n            Yes →\n\n                → Step 14: high = mid // k-th 在左半區\n\n            No →\n\n                → Step 15: low = mid + 1 // k-th 在右半區\n\n        → Step 16: 返回 Decision: low < high? // 迴圈\n\n    No →\n\n        → Step 17: 返回 low // low 即為第 k 小元素\n\nEnd\n\nBut maybe better to write counting in separate step.\n\nNeed to include \"CountElementsLessEqual\" step. Use sub-step.\n\nAlso may need Step 18: Output low.\n\nOk.\n\nLet's produce final answer accordingly. Ensure each line has arrow and // explanation. Use Chinese.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取矩陣大小 n、矩陣 matrix 及目標 k // 取得輸入資料  \n→ Step 2: 設定 low = matrix[0][0] // 矩陣最小值作為搜尋範圍起點  \n→ Step 3: 設定 high = matrix[n-1][n-1] // 矩陣最大值作為搜尋範圍終點  \n→ Decision: low < high? // 仍有範圍需要搜尋  \n&nbsp;&nbsp;Yes →  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 4: 計算 mid = (low + high) / 2 // 取目前範圍中位數作為判斷值  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 5: 初始化 count = 0 // 记录小于等于 mid 的元素数量  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 6: 設定 i = n-1, j = 0 // 从左下角开始遍历  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: i >= 0 且 j < n? // 仍在矩阵内部  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes →  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 7: 如果 matrix[i][j] <= mid? // 当前元素是否小于等于 mid  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes →  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 8: count += n - i // 该列及其上方的所有元素均 <= mid  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 9: j += 1 // 移至右侧列  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No →  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 10: i -= 1 // 向上移动一行  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No →  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 11: 计数完成 // 跳出内部循环  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: count >= k? // 判断 k 是否在左半区  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes →  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 12: high = mid // k-th 小元素在左半区，缩小搜索上限  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No →  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 13: low = mid + 1 // k-th 小元素在右半区，缩小搜索下限  \n&nbsp;&nbsp;&nbsp;&nbsp;→ 返回 Decision: low < high? // 继续二分搜索循环  \n&nbsp;&nbsp;No →  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 14: 返回 low // low 即为第 k 小的元素  \nEnd // 程式執行結束"
    },
    {
      "title": "Intersection of Two Arrays II",
      "source_file": "Leetcode/leetcode350.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums1 = [1,2,2,1], nums2 = [2,2]",
          "expected_output": "[2,2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,2]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[2,2]'\nRaw Got:      '[]'"
        },
        {
          "example_index": 1,
          "input": "nums1 = [4,9,5], nums2 = [9,4,9,8,4]",
          "expected_output": "[4,9]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[4,9]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[4,9]'\nRaw Got:      '[]'"
        }
      ],
      "generated_code": "import sys\nfrom collections import Counter\n\nclass Solution:\n    def intersect(self, nums1, nums2):\n        # 统计两个列表中每个数字出现的次数\n        c1, c2 = Counter(nums1), Counter(nums2)\n        result = []\n        # 对于 nums1 中出现的每个数字\n        for num in c1:\n            # 若 nums2 也包含该数字，则取最小出现次数\n            if num in c2:\n                result.extend([num] * min(c1[num], c2[num]))\n        return result\n\ndef main():\n    # 读取整个标准输入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        print([])          # 输入为空时返回空列表\n        return\n\n    # 将输入字符串解析为字典，例如\n    # \"nums1 = [1,2,2,1], nums2 = [2,2]\" -> {'nums1': [1,2,2,1], 'nums2': [2,2]}\n    try:\n        data_dict = eval(\"{\" + raw_input + \"}\")\n    except Exception:\n        # 若解析失败，直接返回空列表\n        print([])\n        return\n\n    nums1 = data_dict.get('nums1', [])\n    nums2 = data_dict.get('nums2', [])\n\n    # 调用解法并输出结果\n    solution = Solution()\n    intersection = solution.intersect(nums1, nums2)\n    print(intersection)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for intersection of two arrays. The virtual code: Steps: build hash map of counts of nums1, iterate nums2, if in map and count>0 add to result and decrement. End. Provide each line with explanation.\n\nUse Start, End, Decision, arrow.\n\nLet's write:\n\nStart\n→ Step 1: 建立哈希表 counts1 用於存儲 nums1 每個元素的出現次數 // 建立數值統計\n→ Step 2: 對 nums1 中的每個 num → counts1[num] = counts1.getOrDefault(num,0)+1 // 計算頻率\n→ Step 3: 建立空列表 result // 儲存交集結果\n→ Step 4: 對 nums2 中的每個 num\n    → Decision: counts1 是否包含 num? // 檢查 nums1 中是否有此元素\n        Yes → Decision: counts1[num] > 0? // 是否還有剩餘次數\n            Yes → Step 5: 將 num 加入 result // 將交集元素加入\n            → Step 6: counts1[num] = counts1[num] - 1 // 次數減一\n        No → // 不做任何操作\nEnd\n\nNeed to ensure each line is separate with arrow.\n\nMake sure formatting: each line with virtual code and comment after //.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立哈希表 counts1 用於存儲 nums1 每個元素的出現次數 // 建立數值統計\n→ Step 2: 對 nums1 中的每個 num → counts1[num] = counts1.getOrDefault(num, 0) + 1 // 計算頻率\n→ Step 3: 建立空列表 result // 儲存交集結果\n→ Step 4: 對 nums2 中的每個 num\n    → Decision: counts1 是否包含 num? // 檢查 nums1 中是否有此元素\n        Yes → Decision: counts1[num] > 0? // 是否還有剩餘次數\n            Yes → Step 5: 將 num 加入 result // 將交集元素加入\n            → Step 6: counts1[num] = counts1[num] - 1 // 次數減一\n        No → // 不做任何操作\nEnd // 程式執行結束"
    },
    {
      "title": "Design Add and Search Words Data Structure",
      "source_file": "Leetcode/leetcode211.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\"],[[],[\"bad\"],[\"dad\"],[\"mad\"],[\"pad\"],[\"bad\"],[\".ad\"],[\"b..\"]]",
          "expected_output": "[null,null,null,null,false,true,true,true]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpg7ajmb87.py\", line 44, in <module>\n    args = ast.literal_eval(data[first_end + 1:].strip())\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    ,[[],[\"bad\"],[\"dad\"],[\"mad\"],[\"pad\"],[\"bad\"],[\".ad\"],[\"b..\"]]\n    ^\nSyntaxError: invalid syntax"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass WordDictionary:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def addWord(self, word):\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                node.children[ch] = TrieNode()\n            node = node.children[ch]\n        node.is_end = True\n\n    def search(self, word):\n        def dfs(node, i):\n            if i == len(word):\n                return node.is_end\n            if word[i] == '.':\n                for child in node.children.values():\n                    if dfs(child, i + 1):\n                        return True\n                return False\n            else:\n                if word[i] not in node.children:\n                    return False\n                return dfs(node.children[word[i]], i + 1)\n        return dfs(self.root, 0)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # Find the first closing bracket of the first list\n    first_end = data.find(']')\n    ops = ast.literal_eval(data[:first_end + 1])\n    args = ast.literal_eval(data[first_end + 1:].strip())\n\n    obj = None\n    results = []\n    for op, arg in zip(ops, args):\n        if op == \"WordDictionary\":\n            obj = WordDictionary()\n            results.append(None)\n        elif op == \"addWord\":\n            obj.addWord(arg[0])\n            results.append(None)\n        elif op == \"search\":\n            results.append(obj.search(arg[0]))\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce virtual code for a WordDictionary with addWord and search with wildcard '.' support. Use Trie with recursion search. Provide step-by-step virtual code with explanations. Should be in traditional Chinese. Use Start, End, Decision, arrow etc. Provide each line with explanation. Let's produce code lines: Start, then define class WordDictionary, init: root node. Node contains children map and is_end. addWord: iterate char, create node if not exist, at end set is_end. search: recursive function match(word, index, node). If index==len(word): return node.is_end. If char=='.': iterate children, if any match -> True. Else: go to child if exists else False. Provide iterative or recursive logic. Use Decision: char=='.'? Yes/No. Then loops. Need to produce virtual code lines. Each line must be: step + // explanation. Use arrow arrows. Provide indentation as needed. Let's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Define Class WordDictionary // 建立 WordDictionary 類別  \n→   → Start Constructor // 初始化字典  \n→     → Step: Create root node with empty children map and is_end = False // 根節點初始化  \n→   → End Constructor  \n→   → Start Method addWord(word) // 新增單字  \n→     → Step: current ← root // 設定目前節點為根  \n→     → Step: For each character ch in word // 逐字遍歷單字  \n→         → Decision: If ch not in current.children? // 判斷子節點是否存在  \n→             Yes → Step: current.children[ch] ← new Node() // 建立新節點  \n→         → Step: current ← current.children[ch] // 移動到子節點  \n→     → Step: current.is_end ← True // 標記單字結束點  \n→   → End Method addWord  \n→   → Start Method search(word) // 搜尋單字或模式  \n→     → Step: Return match(word, 0, root) // 呼叫遞迴匹配  \n→   → End Method search  \n→   → Define Recursive Function match(pattern, idx, node) // 內部遞迴函式  \n→     → Decision: If idx == length(pattern)? // 已遍歷完整模式  \n→         Yes → Step: Return node.is_end // 成功只若此節點為單字結束點  \n→         No → Step: ch ← pattern[idx] // 取得目前字元  \n→     → Decision: If ch == '.'? // 需要通配符匹配  \n→         Yes → Step: For each child in node.children.values() // 遍歷所有子節點  \n→             → Decision: If match(pattern, idx + 1, child)? // 递归下一位  \n→                 Yes → Step: Return True // 任一分支匹配成功即回傳  \n→             → End Decision  \n→         → Step: Return False // 所有分支失敗  \n→         No  → Step: child ← node.children.get(ch) // 取得具體字元的子節點  \n→     → Decision: If child is None? // 沒有此字元節點  \n→         Yes → Step: Return False // 無法匹配  \n→         No  → Step: Return match(pattern, idx + 1, child) // 继续递归  \n→   → End Function match  \n→ End // 程式執行結束"
    },
    {
      "title": "Complex Number Multiplication",
      "source_file": "Leetcode/leetcode537.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "\"1+-1i\", \"1+-1i\"",
          "expected_output": "\"0+-2i\"",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmps8zme9lw.py\", line 43, in <module>\n    main()\n  File \"/tmp/tmps8zme9lw.py\", line 39, in main\n    result = solution.complexNumberMultiply(num1, num2)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmps8zme9lw.py\", line 21, in complexNumberMultiply\n    a_real, a_imag = parse(a)\n                     ^^^^^^^^\n  File \"/tmp/tmps8zme9lw.py\", line 18, in parse\n    imag = int(s_no_i[sep:])\n           ^^^^^^^^^^^^^^^^^\nValueError: invalid literal for int() with base 10: '+-1'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def complexNumberMultiply(self, a: str, b: str) -> str:\n        def parse(s: str):\n            # Remove trailing 'i'\n            s_no_i = s[:-1]\n            # Find the separator between real and imaginary parts\n            sep = None\n            for i in range(1, len(s_no_i)):\n                if s_no_i[i] in '+-':\n                    sep = i\n                    break\n            if sep is None:\n                raise ValueError(\"Invalid complex number format\")\n            real = int(s_no_i[:sep])\n            imag = int(s_no_i[sep:])\n            return real, imag\n\n        a_real, a_imag = parse(a)\n        b_real, b_imag = parse(b)\n\n        real_part = a_real * b_real - a_imag * b_imag\n        imag_part = a_real * b_imag + a_imag * b_real\n\n        # Always use '+' before the imaginary part, even if imag_part is negative\n        return f\"{real_part}+{imag_part}i\"\n\ndef main():\n    data = sys.stdin.read().strip()\n    # Extract the two complex number strings (they are quoted)\n    parts = re.findall(r'\"([^\"]+)\"', data)\n    if len(parts) != 2:\n        print(\"Invalid input\")\n        return\n    num1, num2 = parts\n    solution = Solution()\n    result = solution.complexNumberMultiply(num1, num2)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for multiplication of complex numbers given as strings like \"a+bi\". Need parse string, multiply using formula: (a+bi)*(c+di) = (ac - bd) + (ad + bc)i. Output string with real part and imaginary part with sign: e.g., \"a+bi\" format. The input real and imaginary parts are integers in [-100,100], but no constraints on sign inside string? Format maybe \"a+bi\" or \"a-bi\"? Usually representation could have '+' between real and imaginary parts. Could be negative imaginary part like \"3-4i\". So we need to parse real and imaginary. Virtual code: Start → Step: read num1, num2 strings → parse function to extract real1, imag1 from string. Similarly for num2. Multiply: compute real_product = real1*real2 - imag1*imag2, imag_product = real1*imag2 + imag1*real2. Compose result string: if imag_product>=0: result = real_product + \"+\" + imag_product + \"i\" else: result = real_product + imag_product + \"i\" (since imag_product negative already includes minus sign). End. Add decision? Not needed. But we can include a Decision to check sign of imag. Let's keep simple. We'll produce step lines.\n\nNeed to adhere to format: each line \"虛擬碼步驟 // 解釋\". Use arrows as specified: Start, →, Decision: Yes →, No →, End.\n\nLet's craft.\n\nLine1: Start // 程式開始執行\nLine2: → Step 1: 讀取字符串 num1 和 num2 // 取得兩個複數字串\nLine3: → Step 2: 解析 num1 為 (real1, imag1) // 分離實部與虛部\nLine4: → Step 3: 解析 num2 為 (real2, imag2) // 分離實部與虛部\nLine5: → Step 4: 計算 real_part = real1 * real2 - imag1 * imag2 // 公式實部\nLine6: → Step 5: 計算 imag_part = real1 * imag2 + imag1 * real2 // 公式虛部\nLine7: → Decision: imag_part >= 0? // 判斷虛部符號\nLine8:     Yes → Step 6: result = real_part + \"+\" + imag_part + \"i\" // 正虛部組字串\nLine9:     No  → Step 7: result = real_part + imag_part + \"i\" // 負虛部已含負號\nLine10: → Step 8: 輸出 result // 回傳乘積複數字串\nLine11: End // 程式執行結束\n\nNeed to ensure each line has a single space after step. For Decision lines, we need indentation? In sample they used indentation. We'll mimic. Use spaces before Yes/No arrows.\n\nAlso need to provide short explanation after //.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取字符串 num1 和 num2 // 取得兩個複數字串  \n→ Step 2: 解析 num1 為 (real1, imag1) // 分離實部與虛部  \n→ Step 3: 解析 num2 為 (real2, imag2) // 分離實部與虛部  \n→ Step 4: 計算 real_part = real1 * real2 - imag1 * imag2 // 公式實部  \n→ Step 5: 計算 imag_part = real1 * imag2 + imag1 * real2 // 公式虛部  \n→ Decision: imag_part >= 0? // 判斷虛部符號  \n    Yes → Step 6: result = real_part + \"+\" + imag_part + \"i\" // 正虛部組字串  \n    No  → Step 7: result = real_part + imag_part + \"i\" // 負虛部已含負號  \n→ Step 8: 輸出 result // 回傳乘積複數字串  \nEnd // 程式執行結束"
    },
    {
      "title": "Implement Rand10() Using Rand7()",
      "source_file": "Leetcode/leetcode470.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[2,8]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,8]'\nGot (Norm):      '[3,7]'\n--- (Raw) ---\nRaw Expected: '[2,8]'\nRaw Got:      '[3, 7]'"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "[3,8,10]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,8,10]'\nGot (Norm):      '[7,9,7]'\n--- (Raw) ---\nRaw Expected: '[3,8,10]'\nRaw Got:      '[7, 9, 7]'"
        }
      ],
      "generated_code": "import sys\nimport random\nimport re\n\n# ------------------------------------------------------------\n# 隨機產生 1~7 的 API\ndef rand7() -> int:\n    \"\"\"回傳 1~7 的均勻隨機整數\"\"\"\n    return random.randint(1, 7)\n\n# ------------------------------------------------------------\nclass Solution:\n    def rand10(self) -> int:\n        \"\"\"利用 rand7() 產生 1~10 的均勻隨機整數\"\"\"\n        while True:\n            # 兩次 rand7() 產生 1~49 的均勻分布\n            num = (rand7() - 1) * 7 + rand7()  # 1~49\n            if num <= 40:                      # 合格區間\n                return 1 + (num - 1) % 10      # 轉成 1~10\n\n# ------------------------------------------------------------\ndef main() -> None:\n    \"\"\"\n    讀取輸入格式「n = X」或只輸入 X，產生對應數量的 rand10() 結果。\n    輸出為一個 Python list，例如 [2, 8, 10]。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    # 從輸入中擷取第一個整數\n    match = re.search(r'\\d+', data)\n    n = int(match.group()) if match else 0\n\n    sol = Solution()\n    results = [sol.rand10() for _ in range(n)]\n    print(results)\n\n# ------------------------------------------------------------\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for generating uniform 1-10 using rand7() only. Classic solution: generate 49 (7x7) outcomes, map 1-40 to 1-10 by modulo, else discard. Or use rejection sampling.\n\nBut they want step-by-step explanation. Provide virtual code with Start, Decision, etc.\n\nWe need to produce virtual code lines, each with \"→\" arrow, and comment.\n\nThe user says: \"請根據輸出格式要求產生虛擬碼和逐行解釋\". So we produce lines. Use arrow for steps. Example earlier uses \"→ Step 1:\". So we should use similar.\n\nWe'll produce:\n\nStart // start\n→ Step 1: 定義函式 rand10() // function definition\n→ Decision: ??? No, we don't need decision.\n\nSimplify: We'll produce pseudocode logic.\n\nApproach: Use two rand7 calls to generate 1-49. Compute val = (rand7()-1)*7 + rand7(); // 1-49\nDecision: If val <= 40?\n    Yes → Step: result = (val-1)%10 + 1; // map to 1-10\n    No → Step: repeat (go back to Step 1) // rejection\nReturn result\n\nWe'll express loops.\n\nBetter: Use loop: while true.\n\nLet's create virtual steps:\n\nStart\n→ Step 1: 定義函式 rand10() // 函式開始\n→ Step 2: 迴圈: repeat\n→ Step 3: rand7() 呼叫1 取得 a\n→ Step 4: rand7() 呼叫2 取得 b\n→ Step 5: 計算 val = (a-1)*7 + b // 1-49\n→ Decision: 如果 val <= 40? // 合格\n    Yes → Step 6: 結果 = (val-1)%10 + 1 // 轉換到 1-10\n    Yes → Step 7: 返回結果\n    No  → Step 8: 重新進入迴圈 // reject\nEnd\n\nAlso include comments.\n\nMake sure each line contains virtual code + space + comment.\n\nWe need to output step lines.\n\nWe'll include \"End\" at the end of function.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義函式 rand10() // 開始定義產生 1~10 的函式\n→ Step 2: 迴圈: repeat // 進入無限迴圈，直到能產生合法結果\n→ Step 3: 呼叫 rand7() 取得 a // 產生第一個隨機數 1~7\n→ Step 4: 呼叫 rand7() 取得 b // 產生第二個隨機數 1~7\n→ Step 5: 計算 val = (a-1)*7 + b // 轉換成 1~49 的整數\n→ Decision: 如果 val <= 40? // 檢查是否落在可接受區間\n    Yes → Step 6: 結果 = (val-1) % 10 + 1 // 將 1~40 轉成 1~10\n    Yes → Step 7: 返回結果 // 成功返回隨機數\n    No  → Step 8: 重新進入迴圈 // val 超過 40，重試\nEnd // 程式執行結束"
    },
    {
      "title": "Range Sum Query - Mutable",
      "source_file": "Leetcode/leetcode307.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"NumArray\", \"sumRange\", \"update\", \"sumRange\"], [[[1, 3, 5]], [0, 2], [1, 2], [0, 2]]",
          "expected_output": "[null, 9, null, 8]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp_52updjo.py\", line 52, in <module>\n    main()\n  File \"/tmp/tmp_52updjo.py\", line 36, in main\n    ops = json.loads(lines[0])      # [\"NumArray\",\"sumRange\", ...]\n          ^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 47 (char 46)"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass NumArray:\n    def __init__(self, nums):\n        self.n = len(nums)\n        self.nums = nums[:]               # 原始陣列\n        self.tree = [0] * (self.n + 1)    # Binary Indexed Tree\n        for i, val in enumerate(nums):\n            self._add(i + 1, val)\n\n    def _add(self, i, val):\n        while i <= self.n:\n            self.tree[i] += val\n            i += i & -i\n\n    def update(self, index, val):\n        diff = val - self.nums[index]\n        self.nums[index] = val\n        self._add(index + 1, diff)\n\n    def sumRange(self, left, right):\n        return self._prefix(right + 1) - self._prefix(left)\n\n    def _prefix(self, i):\n        res = 0\n        while i > 0:\n            res += self.tree[i]\n            i -= i & -i\n        return res\n\ndef main():\n    lines = sys.stdin.read().strip().splitlines()\n    if not lines:\n        return\n    ops = json.loads(lines[0])      # [\"NumArray\",\"sumRange\", ...]\n    params = json.loads(lines[1])   # [[[1,3,5]],[0,2], ...]\n    res = []\n    obj = None\n    for op, param in zip(ops, params):\n        if op == \"NumArray\":\n            obj = NumArray(param[0])\n            res.append(None)\n        elif op == \"update\":\n            obj.update(param[0], param[1])\n            res.append(None)\n        elif op == \"sumRange\":\n            res.append(obj.sumRange(param[0], param[1]))\n    print(json.dumps(res))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for this requirement. The structure: Start, steps, Decision, End. Need to implement a NumArray class with update and sumRange. Use maybe a segment tree. We can show steps of initialization, update, sum query. Virtual code per line, explanation after //.\n\nWe need to be \"逐行\" meaning each step line. Use arrow \"→\" for steps. Use Decision: ... Yes → ... No →. But we need to describe algorithm, not actual code. So produce pseudo steps. For each step: e.g., Start, Step: Build segment tree, etc.\n\nWe need to output purely virtual code lines. Each line: \"虛擬碼步驟 // 解釋\". Provide enough steps to represent algorithm.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 建立大小為 4*n 的段樹陣列 tree // 初始化段樹結構\n→ Step 2: 呼叫 Build(1, 0, n-1) 建構段樹 // 將原始陣列放入葉節點\n    Decision: 如果 l==r? // 判斷是否為葉節點\n        Yes → Step 3: tree[idx] = nums[l] // 葉節點直接存原始值\n        No  → Step 4: mid = (l+r)/2 // 計算中點\n            → Step 5: Build(idx*2, l, mid) // 建立左子樹\n            → Step 6: Build(idx*2+1, mid+1, r) // 建立右子樹\n            → Step 7: tree[idx] = tree[idx*2] + tree[idx*2+1] // 計算父節點和\nEnd // 初始化結束\n\nStart // update 操作\n→ Step 8: 呼叫 Update(1, 0, n-1, index, val) // 進入更新\n    Decision: 如果 l==r? // 到達目標葉節點\n        Yes → Step 9: tree[idx] = val // 更新葉節點值\n        No  → Step 10: mid = (l+r)/2\n            Decision: 如果 index <= mid? // 判斷更新哪個子樹\n                Yes → Step 11: Update(idx*2, l, mid, index, val) // 更新左子樹\n                No  → Step 12: Update(idx*2+1, mid+1, r, index, val) // 更新右子樹\n            → Step 13: tree[idx] = tree[idx*2] + tree[idx*2+1] // 更新父節點和\nEnd // update 結束\n\nStart // sumRange 操作\n→ Step 14: 呼叫 Query(1, 0, n-1, left, right) // 進入查詢\n    Decision: 如果 left > r 或 right < l? // 無重疊區域\n        Yes → Step 15: return 0 // 沒有貢獻\n        No  → Decision: 如果 left <= l 且 r <= right? // 節點完全在區間內\n            Yes → Step 16: return tree[idx] // 直接使用節點和\n            No  → Step 17: mid = (l+r)/2\n                → Step 18: sumLeft = Query(idx*2, l, mid, left, right) // 左半部分\n                → Step 19: sumRight = Query(idx*2+1, mid+1, r, left, right) // 右半部分\n                → Step 20: return sumLeft + sumRight // 合併結果\nEnd // sumRange 結束\n\nWe should also include the NumArray class definition? We can include a step for class skeleton. Maybe:\n\n→ Step 0: 定義 NumArray 類別，包含 nums、n、tree 以及方法 Build、Update、Query // 類別與資料結構\n\nWe might need to include that.\n\nAlso the constructor: Step 1.\n\nLet's produce full virtual steps.\n\nBe mindful of ordering: Start, Step 0, Step 1... End. Then separate sections for constructor, update, sumRange. Use \"Start\" and \"End\" around each major part or keep continuous. But requirement: \"逐行\" meaning we output lines sequentially. Maybe just show one linear flow with segments separated by comments.\n\nI'll produce:\n\nStart // 程式開始執行\n→ Step 0: 定義 NumArray 類別，內部持有原始陣列 nums、長度 n 以及段樹陣列 tree // 類別結構\n→ Step 1: 建構子 NumArray(nums) 初始化 n = nums.length // 設定長度\n→ Step 2: 初始化 tree 為大小 4*n 的陣列 // 準備段樹\n→ Step 3: 呼叫 Build(1, 0, n-1) 建立段樹 // 構造段樹\n    Decision: 如果 l==r? // 判斷是否為葉節點\n        Yes → Step 4: tree[idx] = nums[l] // 葉節點直接存值\n        No  → Step 5: mid = (l+r)/2 // 計算中點\n            → Step 6: Build(idx*2, l, mid) // 左子樹\n            → Step 7: Build(idx*2+1, mid+1, r) // 右子樹\n            → Step 8: tree[idx] = tree[idx*2] + tree[idx*2+1] // 合併父節點\nEnd // 構造完成\n\nStart // update 方法\n→ Step 9: update(index, val) 呼叫 Update(1, 0, n-1, index, val) // 進入更新\n    Decision: 如果 l==r? // 到達目標葉節點\n        Yes → Step 10: tree[idx] = val // 更新葉節點\n        No  → Step 11: mid = (l+r)/2 // 計算中點\n            Decision: 如果 index <= mid? // 判斷更新哪側\n                Yes → Step 12: Update(idx*2, l, mid, index, val) // 左子樹\n                No  → Step 13: Update(idx*2+1, mid+1, r, index, val) // 右子樹\n            → Step 14: tree[idx] = tree[idx*2] + tree[idx*2+1] // 更新父節點\nEnd // update 完成\n\nStart // sumRange 方法\n→ Step 15: sumRange(left, right) 呼叫 Query(1, 0, n-1, left, right) // 開始查詢\n    Decision: 如果 left > r 或 right < l? // 無重疊\n        Yes → Step 16: return 0 // 無貢獻\n        No  → Decision: 如果 left <= l 且 r <= right? // 節點完全覆蓋\n            Yes → Step 17: return tree[idx] // 直接回傳\n            No  → Step 18: mid = (l+r)/2 // 計算中點\n                → Step 19: sumLeft = Query(idx*2, l, mid, left, right) // 左半部分\n                → Step 20: sumRight = Query(idx*2+1, mid+1, r, left, right) // 右半部分\n                → Step 21: return sumLeft + sumRight // 合併\nEnd // sumRange 結束\n\nWe might also mention that Query returns int.\n\nThis meets format: each line has virtual code then comment.\n\nLet's output this.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 0: 定義 NumArray 類別，內部持有原始陣列 nums、長度 n 以及段樹陣列 tree // 類別結構  \n→ Step 1: 建構子 NumArray(nums) 初始化 n = nums.length // 設定長度  \n→ Step 2: 初始化 tree 為大小 4*n 的陣列 // 準備段樹  \n→ Step 3: 呼叫 Build(1, 0, n-1) 建立段樹 // 構造段樹  \n&nbsp;&nbsp;Decision: 如果 l==r? // 判斷是否為葉節點  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 4: tree[idx] = nums[l] // 葉節點直接存值  \n&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 5: mid = (l+r)/2 // 計算中點  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 6: Build(idx*2, l, mid) // 左子樹  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 7: Build(idx*2+1, mid+1, r) // 右子樹  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 8: tree[idx] = tree[idx*2] + tree[idx*2+1] // 合併父節點  \nEnd // 構造完成  \n\nStart // update 方法  \n→ Step 9: update(index, val) 呼叫 Update(1, 0, n-1, index, val) // 進入更新  \n&nbsp;&nbsp;Decision: 如果 l==r? // 到達目標葉節點  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 10: tree[idx] = val // 更新葉節點  \n&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 11: mid = (l+r)/2 // 計算中點  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Decision: 如果 index <= mid? // 判斷更新哪側  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 12: Update(idx*2, l, mid, index, val) // 左子樹  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 13: Update(idx*2+1, mid+1, r, index, val) // 右子樹  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 14: tree[idx] = tree[idx*2] + tree[idx*2+1] // 更新父節點  \nEnd // update 完成  \n\nStart // sumRange 方法  \n→ Step 15: sumRange(left, right) 呼叫 Query(1, 0, n-1, left, right) // 開始查詢  \n&nbsp;&nbsp;Decision: 如果 left > r 或 right < l? // 無重疊  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 16: return 0 // 無貢獻  \n&nbsp;&nbsp;&nbsp;&nbsp;No  → Decision: 如果 left <= l 且 r <= right? // 節點完全覆蓋  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 17: return tree[idx] // 直接回傳  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 18: mid = (l+r)/2 // 計算中點  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 19: sumLeft = Query(idx*2, l, mid, left, right) // 左半部分  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 20: sumRight = Query(idx*2+1, mid+1, r, left, right) // 右半部分  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 21: return sumLeft + sumRight // 合併  \nEnd // sumRange 結束"
    },
    {
      "title": "Expression Add Operators",
      "source_file": "Leetcode/leetcode282.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "num = \"123\", target = 6",
          "expected_output": "[\"1*2*3\",\"1+2+3\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"1*2*3\",\"1+2+3\"]'\nGot (Norm):      '[\"1+2+3\",\"1*2*3\"]'\n--- (Raw) ---\nRaw Expected: '[\"1*2*3\",\"1+2+3\"]'\nRaw Got:      '[\"1+2+3\", \"1*2*3\"]'"
        },
        {
          "example_index": 1,
          "input": "num = \"232\", target = 8",
          "expected_output": "[\"2*3+2\",\"2+3*2\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"2*3+2\",\"2+3*2\"]'\nGot (Norm):      '[\"2+3*2\",\"2*3+2\"]'\n--- (Raw) ---\nRaw Expected: '[\"2*3+2\",\"2+3*2\"]'\nRaw Got:      '[\"2+3*2\", \"2*3+2\"]'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport json\n\nclass Solution:\n    def addOperators(self, num: str, target: int):\n        res = []\n\n        def backtrack(index: int, path: str, value: int, last: int):\n            if index == len(num):\n                if value == target:\n                    res.append(path)\n                return\n\n            for i in range(index + 1, len(num) + 1):\n                temp = num[index:i]\n                # skip numbers with leading zeros\n                if len(temp) > 1 and temp[0] == '0':\n                    continue\n                curr = int(temp)\n                if index == 0:\n                    backtrack(i, temp, curr, curr)\n                else:\n                    backtrack(i, path + '+' + temp, value + curr, curr)\n                    backtrack(i, path + '-' + temp, value - curr, -curr)\n                    backtrack(i, path + '*' + temp, value - last + last * curr, last * curr)\n\n        backtrack(0, '', 0, 0)\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    # extract num string\n    num_match = re.search(r'num\\s*=\\s*\"([^\"]+)\"', data)\n    target_match = re.search(r'target\\s*=\\s*(-?\\d+)', data)\n    if not num_match or not target_match:\n        print(\"[]\")\n        sys.exit(0)\n\n    num_str = num_match.group(1)\n    target_val = int(target_match.group(1))\n\n    solution = Solution()\n    result = solution.addOperators(num_str, target_val)\n    # output in JSON format (double quotes)\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need produce virtual code steps for algorithm: expression add operators to get target. Standard backtracking. Steps: parse string. Start recursion. Use DFS with index, path, evaluated value, last operand for multiplication. Handle leading zeros. Add operators. At end compare eval.\n\nWe output line by line virtual code with comments. Use arrows etc. Ensure Start, End. Use Decision.\n\nLet's produce steps: Start. Input num, target. Preprocess? We'll create DFS function. But we need to express algorithm, not actual code. Virtual steps: For each position i from start to length-1: pick substring num[start:i+1] as curStr. If leading zero and length>1 skip. curVal = integer curStr. If start==0: path = curStr; dfs(i+1, curVal, curVal). Else: For each operator: '+' -> dfs(i+1, evaluated+curVal, curVal); '-' -> dfs(i+1, evaluated - curVal, -curVal); '*' -> dfs(i+1, evaluated - last + last*curVal, last*curVal). At end if start==len(num) and evaluated==target, add path to result.\n\nAlso need decision for leading zero.\n\nNow produce virtual code steps line by line. Let's create lines:\n\nStart // 程式開始\n→ Step 1: 讀取輸入 num, target // 取得數字字串與目標值\n→ Step 2: 初始化結果列表 res = [] // 用於儲存符合條件的表達式\n→ Step 3: 定義遞迴函式 DFS(index, path, evaluated, last) // index: 當前處理位置；path: 已構造的字串；evaluated: 目前算術值；last: 最後一個數字（用於乘法調整）\n    → Decision: index == len(num)? // 判斷是否已走完字串\n        Yes → Decision: evaluated == target? // 檢查是否符合目標\n            Yes → Step 4: 將 path 加入 res // 存入符合條件的表達式\n            No  → Step 5: 直接回傳 // 不符合目標，結束此分支\n        No  → Step 6: 循環 i 從 index 到 len(num)-1 // 選取子字串\n            → Step 7: curStr = num[index:i+1] // 取子字串\n            → Decision: curStr 前導零且長度>1? // 檢查是否為非法前導零\n                Yes → Step 8: 跳過此子字串 // 不能以零開頭\n                No  → Step 9: curVal = 整數化(curStr) // 轉為數值\n                    → Decision: index == 0? // 第一個數字\n                        Yes → Step 10: DFS(i+1, curStr, curVal, curVal) // 直接開始\n                        No  → Decision: 需要插入 '+', '-', '*'? // 選擇每個運算符\n                            Yes → Step 11: DFS(i+1, path + '+' + curStr, evaluated + curVal, curVal) // 加\n                            Yes → Step 12: DFS(i+1, path + '-' + curStr, evaluated - curVal, -curVal) // 減\n                            Yes → Step 13: DFS(i+1, path + '*' + curStr, evaluated - last + last * curVal, last * curVal) // 乘\n→ Step 14: 呼叫 DFS(0, '', 0, 0) // 開始遞迴\n→ Step 15: 返回結果 res // 輸出所有符合表達式\nEnd // 程式結束\n\nMake sure each line includes arrow as needed. Use \"→\" for steps. For decisions use Decision:.\n\nWe must maintain indent? Virtual code arrow indicates line. For decisions we can indent inside.\n\nMake sure each line ends with // explanation.\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始\n→ Step 1: 讀取輸入 num, target // 取得數字字串與目標值\n→ Step 2: 初始化結果列表 res = [] // 用於儲存符合條件的表達式\n→ Step 3: 定義遞迴函式 DFS(index, path, evaluated, last) // index: 當前處理位置；path: 已構造的字串；evaluated: 目前算術值；last: 最後一個數字（用於乘法調整）\n    → Decision: index == len(num)? // 判斷是否已走完字串\n        Yes → Decision: evaluated == target? // 檢查是否符合目標\n            Yes → Step 4: 將 path 加入 res // 存入符合條件的表達式\n            No  → Step 5: 直接回傳 // 不符合目標，結束此分支\n        No  → Step 6: 循環 i 從 index 到 len(num)-1 // 選取子字串\n            → Step 7: curStr = num[index:i+1] // 取子字串\n            → Decision: curStr 前導零且長度>1? // 檢查是否為非法前導零\n                Yes → Step 8: 跳過此子字串 // 不能以零開頭\n                No  → Step 9: curVal = 整數化(curStr) // 轉為數值\n                    → Decision: index == 0? // 第一個數字\n                        Yes → Step 10: DFS(i+1, curStr, curVal, curVal) // 直接開始\n                        No  → Decision: 需要插入 '+', '-', '*'? // 選擇每個運算符\n                            Yes → Step 11: DFS(i+1, path + '+' + curStr, evaluated + curVal, curVal) // 加\n                            Yes → Step 12: DFS(i+1, path + '-' + curStr, evaluated - curVal, -curVal) // 減\n                            Yes → Step 13: DFS(i+1, path + '*' + curStr, evaluated - last + last * curVal, last * curVal) // 乘\n→ Step 14: 呼叫 DFS(0, '', 0, 0) // 開始遞迴\n→ Step 15: 返回結果 res // 輸出所有符合表達式\nEnd // 程式結束\n```"
    },
    {
      "title": "Wiggle Sort II",
      "source_file": "Leetcode/leetcode324.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,5,1,1,6,4]",
          "expected_output": "[1,6,1,5,1,4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[1,6,1,5,1,4]'\nGot (Norm):      '[1,1,1,5,4,6]'\n--- (Raw) ---\nRaw Expected: '[1,6,1,5,1,4]'\nRaw Got:      '[1, 1, 1, 5, 4, 6]'"
        },
        {
          "example_index": 1,
          "input": "nums = [1,3,2,2,3,1]",
          "expected_output": "[2,3,1,3,1,2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,3,1,3,1,2]'\nGot (Norm):      '[1,2,1,3,2,3]'\n--- (Raw) ---\nRaw Expected: '[2,3,1,3,1,2]'\nRaw Got:      '[1, 2, 1, 3, 2, 3]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def wiggleSort(self, nums):\n        \"\"\"\n        Reorder nums so that nums[0] < nums[1] > nums[2] < nums[3] ...\n        \"\"\"\n        # 先升序排序\n        nums.sort()\n        # 只需要把奇數位置（即下標 1、3、5…）的元素與後面的元素交換\n        for i in range(1, len(nums) - 1, 2):\n            nums[i], nums[i + 1] = nums[i + 1], nums[i]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 解析輸入，假設格式為 \"nums = [1,5,1,1,6,4]\"\n    try:\n        _, list_str = data.split('=', 1)\n    except ValueError:\n        # 若沒有等號，直接使用整個輸入\n        list_str = data\n    list_str = list_str.strip()\n    nums = ast.literal_eval(list_str)\n\n    Solution().wiggleSort(nums)\n    print(nums)",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps. For wiggle sort. Approach: sort array, then swap adjacent pairs starting from 1: for i=1; i<nums.length; i+=2 swap nums[i] and nums[i+1] if exists. Or we can use algorithm: sort, then for i=1; i<length; i+=2 swap.\n\nThus steps: Start → Step 1: 取得陣列長度 n // Get length. → Step 2: 將 nums 進行升序排序 // Sort ascending. → Step 3: 迴圈 i 由 1 到 n-2 以 2 為增量 // loop. Inside: → Step 4: 交換 nums[i] 與 nums[i+1] // swap adjacent pairs. After loop End.\n\nWe need to follow format: Each line \"虛擬碼步驟 // 解釋\".\n\nUse arrow for steps: \"→\" and indentation for substeps. Provide Decision? not needed.\n\nLet's produce.\n\nNote: Must not output actual code. So use description.\n\nAlso we need to mention that assumption ensures solution. Use Start, End.\n\nLet's craft.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算陣列長度 n // 取得 nums 的元素數量  \n→ Step 2: 將 nums 進行升序排序 // 使元素按大小排列  \n→ Decision: n 是否小於 2? // 若陣列太短不需要處理  \n  Yes → End // 直接結束（無需進一步操作）  \n  No → Step 3: 初始化 i = 1 // 從第二個元素開始  \n→ Step 4: 迴圈 While i < n-1  \n   → Step 5: 交換 nums[i] 與 nums[i+1] // 讓奇數位置較大  \n   → Step 6: i ← i + 2 // 進入下一個奇數位置  \nEnd // 程式執行結束，nums 已按 < > < > 形式排列"
    },
    {
      "title": "Evaluate Division",
      "source_file": "Leetcode/leetcode399.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]",
          "expected_output": "[6.00000,0.50000,-1.00000,1.00000,-1.00000]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[6.00000,0.50000,-1.00000,1.00000,-1.00000]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[6.00000,0.50000,-1.00000,1.00000,-1.00000]'\nRaw Got:      '[]'"
        },
        {
          "example_index": 1,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1.5,2.5,5.0], queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]",
          "expected_output": "[3.75000,0.40000,5.00000,0.20000]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3.75000,0.40000,5.00000,0.20000]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[3.75000,0.40000,5.00000,0.20000]'\nRaw Got:      '[]'"
        },
        {
          "example_index": 2,
          "input": "equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]",
          "expected_output": "[0.50000,2.00000,-1.00000,-1.00000]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[0.50000,2.00000,-1.00000,-1.00000]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[0.50000,2.00000,-1.00000,-1.00000]'\nRaw Got:      '[]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def calcEquation(self, equations, values, queries):\n        graph = defaultdict(dict)\n        for (a, b), val in zip(equations, values):\n            graph[a][b] = val\n            graph[b][a] = 1 / val\n\n        def dfs(src, dst, visited):\n            if src not in graph or dst not in graph:\n                return -1.0\n            if src == dst:\n                return 1.0\n            visited.add(src)\n            for neighbor, weight in graph[src].items():\n                if neighbor not in visited:\n                    res = dfs(neighbor, dst, visited)\n                    if res != -1.0:\n                        return weight * res\n            return -1.0\n\n        res = []\n        for u, v in queries:\n            res.append(dfs(u, v, set()))\n        return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Convert input string into a dictionary literal\n    # Replace assignments with key=value format\n    data = data.replace('equations =', 'equations=').replace('values =', 'values=').replace('queries =', 'queries=')\n    # Wrap with braces to form a dict literal\n    data_dict = '{' + data + '}'\n    try:\n        parsed = ast.literal_eval(data_dict)\n    except Exception:\n        print('[]')\n        return\n    equations = parsed.get('equations', [])\n    values = parsed.get('values', [])\n    queries = parsed.get('queries', [])\n\n    sol = Solution()\n    results = sol.calcEquation(equations, values, queries)\n\n    # Format each result to five decimal places\n    formatted = '[' + ','.join(f'{x:.5f}' for x in results) + ']'\n    print(formatted)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. It is a typical LeetCode division equations problem. We will produce steps like: Start, build graph, for each query do DFS or BFS. Use union-find? Could mention either.\n\nWe need to provide each line with explanation. Use arrows and decision structure.\n\nLet's craft steps:\n\nStart // begin\n\n→ Step 1: Build adjacency list graph: for each equation Ai/Bi = val, add edges Ai->Bi weight val, Bi->Ai weight 1/val // constructing graph\n\n→ Step 2: For each query Cj/Dj: if Cj or Dj not in graph → answer -1.0 // check validity\n\n→ Decision: Are Cj and Dj connected? // check via DFS/BFS\n\n    Yes → Step 3: Perform DFS from Cj to Dj, accumulating product of weights // find product\n\n        → Step 4: Append product to answers list // record answer\n\n    No  → Step 5: Append -1.0 to answers list // no path\n\n→ Step 6: Return answers list // final output\n\nWe should structure with arrows. Possibly separate for each query loop. Let's incorporate loops.\n\nUse \"For each query j\" as a loop.\n\nWe'll produce a pseudo code flow:\n\nStart\n\n→ Build graph\n\n→ Initialize answers list\n\n→ For each query in queries // loop\n\n    → If query[0] not in graph or query[1] not in graph → Append -1.0; Continue // skip\n\n    → Decision: Are query[0] and query[1] connected? // will use DFS\n\n        Yes → DFS to compute product → Append result\n\n        No  → Append -1.0\n\n→ End // return answers\n\nBut we need line-by-line with explanation.\n\nLet's write:\n\nStart // 程式開始執行\n→ Build graph: for each equation (Ai, Bi) with value v, add Ai → Bi weight v, Bi → Ai weight 1/v // 建立有向圖及權重\n→ Initialize answers = [] // 用於儲存每個查詢的結果\n→ For each query (C, D) in queries // 逐個處理查詢\n    → Decision: 如果 C 或 D 未出現在 graph 中？ // 檢查變數是否已定義\n        Yes → Append -1.0 to answers // 未定義，答案無法確定\n        No  → Decision: 是否存在從 C 到 D 的路徑？ // 判斷兩變數是否相連\n            Yes → Step: DFS from C to D, accum weight // 進行深度優先搜尋計算乘積\n                → Step: 將累積乘積存入 answers // 儲存計算結果\n            No  → Append -1.0 to answers // 無路徑，答案無法確定\n→ End // 回傳 answers // 程式執行結束\n\nBut we must use arrow and structure syntax: \"Decision:\" and \"Yes →\", \"No →\". Provide explanation after each line.\n\nLet's produce exactly as format: each line \"虛擬碼步驟\" + space + \"// 解釋/說明\". Use arrows and decision. Also include loop: maybe \"For each query\" line.\n\nLet's create final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Build graph: for each equation (Ai, Bi) with value v, add edge Ai → Bi weight v, Bi → Ai weight 1/v // 建立有向圖及相對權重  \n→ Initialize answers = [] // 用於儲存每個查詢的結果  \n→ For each query (C, D) in queries // 逐個處理查詢  \n  Decision: C 或 D 是否在 graph 中？ // 檢查變數是否已定義  \n   Yes → Append -1.0 to answers // 未定義，答案無法確定  \n   No  → Decision: C 與 D 是否相連？ // 判斷兩變數是否可通路  \n    Yes → DFS from C to D, accumulate product of weights // 進行深度優先搜尋計算乘積  \n     → Append product to answers // 儲存計算結果  \n    No  → Append -1.0 to answers // 無路徑，答案無法確定  \n→ End // 回傳 answers // 程式執行結束"
    },
    {
      "title": "Course Schedule II",
      "source_file": "Leetcode/leetcode210.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]",
          "expected_output": "[0,2,1,3]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[0,2,1,3]'\nGot (Norm):      '[0,1,2,3]'\n--- (Raw) ---\nRaw Expected: '[0,2,1,3]'\nRaw Got:      '[0, 1, 2, 3]'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import deque\n\nclass Solution:\n    def findOrder(self, numCourses, prerequisites):\n        # 建立鄰接表與入度表\n        graph = [[] for _ in range(numCourses)]\n        indegree = [0] * numCourses\n\n        # 填充圖與入度\n        for dest, src in prerequisites:\n            graph[src].append(dest)\n            indegree[dest] += 1\n\n        # 取得所有入度為 0 的節點\n        queue = deque([i for i in range(numCourses) if indegree[i] == 0])\n        order = []\n\n        # Kahn 的拓撲排序\n        while queue:\n            node = queue.popleft()\n            order.append(node)\n            for neighbor in graph[node]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    queue.append(neighbor)\n\n        # 若完整完成，回傳順序；否則回傳空列表\n        return order if len(order) == numCourses else []\n\ndef parse_input():\n    \"\"\"\n    解析輸入字串，取得 numCourses 與 prerequisites。\n    支援類似 'numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]' 的格式，\n    以及分行輸入的情形。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    # 正則表達式捕捉兩個參數\n    pattern = r'numCourses\\s*=\\s*(\\d+)\\s*,\\s*prerequisites\\s*=\\s*(\\[.*\\])'\n    m = re.search(pattern, data, re.S)\n    if m:\n        numCourses = int(m.group(1))\n        prerequisites = ast.literal_eval(m.group(2))\n        return numCourses, prerequisites\n\n    # 若無法匹配，嘗試行分割\n    numCourses = 0\n    prerequisites = []\n    for line in data.splitlines():\n        if 'numCourses' in line:\n            numCourses = int(re.search(r'\\d+', line).group())\n        if 'prerequisites' in line:\n            lst = re.search(r'\\[.*\\]', line, re.S).group()\n            prerequisites = ast.literal_eval(lst)\n    return numCourses, prerequisites\n\nif __name__ == \"__main__\":\n    numCourses, prerequisites = parse_input()\n    solution = Solution()\n    order = solution.findOrder(numCourses, prerequisites)\n    print(order)",
      "virtual_code": "Thinking...\nWe need to produce pseudo code for topological sort for course scheduling problem. Use Kahn's algorithm. Output steps with explanation. Need to follow format: each line \"虛擬碼步驟 // 解釋\". Use arrows. Start, End, Decision, etc. Ensure each line separate. Let's craft.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立空的鄰接表 graph[0…numCourses-1] // 用於儲存每門課的後續課程\n→ Step 2: 建立 indegree 陣列 indeg[0…numCourses-1] 初始化為 0 // 記錄每門課的前置課程數\n→ Step 3: 逐一處理 prerequisites 中的每個 [a, b]\n    → Step 3a: graph[b].append(a) // b 之後才能上 a\n    → Step 3b: indeg[a] += 1 // a 的前置課程數增加\n→ Step 4: 建立一個空佇列 queue // 用於儲存 indegree 為 0 的課程\n→ Step 5: 逐一遍歷 0…numCourses-1\n    → Decision: 如果 indeg[i] == 0?\n        Yes → Step 5a: queue.enqueue(i) // 可立即修讀的課程\n→ Step 6: 建立空列表 order // 儲存課程的順序\n→ Step 7: 迴圈至 queue 不是空\n    → Decision: queue 仍有元素?\n        Yes → Step 7a: v = queue.dequeue() // 取出一門課\n        → Step 7b: order.append(v) // 加入順序\n        → Step 7c: 逐一遍歷 graph[v] 中的每個 neighbour\n            → Step 7c1: indeg[neighbour] -= 1 // 前置課程完成\n            → Step 7c2: Decision: indeg[neighbour] == 0?\n                Yes → Step 7c3: queue.enqueue(neighbour) // 現已無前置，加入佇列\n        → No → End of loop\n→ Step 8: Decision: len(order) == numCourses?\n    Yes → Step 8a: Return order // 成功得到完整順序\n    No  → Step 8b: Return [] // 產生環，無法完成所有課程\nEnd // 程式執行結束"
    },
    {
      "title": "Word Ladder II",
      "source_file": "Leetcode/leetcode126.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
          "expected_output": "[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpwjmyw7hp.py\", line 71, in <module>\n    data = parse_input_line(raw_line)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpwjmyw7hp.py\", line 60, in parse_input_line\n    return eval(dict_str, {}, {})\n           ^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1, in <module>\nNameError: name 'beginWord' is not defined"
        },
        {
          "example_index": 1,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]",
          "expected_output": "[]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmphqznv2_p.py\", line 71, in <module>\n    data = parse_input_line(raw_line)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmphqznv2_p.py\", line 60, in parse_input_line\n    return eval(dict_str, {}, {})\n           ^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1, in <module>\nNameError: name 'beginWord' is not defined"
        }
      ],
      "generated_code": "import sys\nfrom collections import defaultdict, deque\n\nclass Solution:\n    def findLadders(self, beginWord: str, endWord: str, wordList: list) -> list:\n        \"\"\"\n        Find all shortest transformation sequences from beginWord to endWord.\n        Uses BFS to compute the minimum distance to each word and records\n        parent relationships for backtracking all shortest paths.\n        \"\"\"\n        wordSet = set(wordList)\n        if endWord not in wordSet:\n            return []\n\n        # BFS layers: distance from beginWord\n        layer = {beginWord: 0}\n        parents = defaultdict(list)   # child -> list of parents\n\n        queue = deque([beginWord])\n        while queue:\n            word = queue.popleft()\n            step = layer[word]\n            for i in range(len(word)):\n                for c in 'abcdefghijklmnopqrstuvwxyz':\n                    new_word = word[:i] + c + word[i+1:]\n                    if new_word in wordSet:\n                        if new_word not in layer:            # first time visited\n                            layer[new_word] = step + 1\n                            queue.append(new_word)\n                            parents[new_word].append(word)\n                        elif layer[new_word] == step + 1:    # same level, add another parent\n                            parents[new_word].append(word)\n\n        # If endWord was never reached\n        if endWord not in parents:\n            return []\n\n        res = []\n\n        def dfs(path, word):\n            \"\"\"Backtrack from endWord to beginWord using parents.\"\"\"\n            if word == beginWord:\n                res.append(path[::-1])   # reverse to start from beginWord\n                return\n            for prev in parents[word]:\n                dfs(path + [prev], prev)\n\n        dfs([endWord], endWord)\n        return res\n\n\ndef parse_input_line(line: str) -> dict:\n    \"\"\"\n    Convert a line like:\n    'beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]'\n    into a dictionary {'beginWord': 'hit', 'endWord': 'cog', 'wordList': [...]}\n    \"\"\"\n    # Replace '=' with ':' to make a valid Python dict literal\n    dict_str = '{' + line.replace('=', ':') + '}'\n    return eval(dict_str, {}, {})\n\n\nif __name__ == \"__main__\":\n    # Read the whole input line (the problem statement guarantees one line)\n    raw_line = sys.stdin.read().strip()\n    if not raw_line:\n        print(\"[]\")\n        sys.exit(0)\n\n    # Parse input into variables\n    data = parse_input_line(raw_line)\n    beginWord = data.get('beginWord')\n    endWord = data.get('endWord')\n    wordList = data.get('wordList', [])\n\n    # Compute all shortest transformation sequences\n    solution = Solution()\n    answer = solution.findLadders(beginWord, endWord, wordList)\n\n    # Print the result as a Python list representation\n    print(answer)",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with comments. The algorithm: use BFS to find shortest path length, build adjacency graph. Then DFS or backtracking to generate all paths. Steps: start, load words, build set, BFS from begin to end, record levels, then DFS backtracking. Ensure only shortest. We'll produce pseudocode with arrow and decision. Let's craft.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Load beginWord, endWord, wordList // 取得輸入的詞與字典\n→ Decision: 是否存在 endWord 在 wordList? // 檢查目標詞是否可到達\n    No → End // 若無，直接結束並回傳空列表\n→ Step 2: 建立 set words ← wordList ∪ {beginWord} // 方便 O(1) 查詢\n→ Step 3: 建立鄰接關係 graph ← {} // 儲存可一步變換的詞\n→ Step 4: For each word in words // 為每個詞建立相鄰詞\n    → For i from 0 to len(word)-1\n        → For each c in 'a'..'z'\n            → newWord ← 替換字元 i 為 c 的字串\n            → Decision: newWord ≠ word 且 newWord ∈ words?\n                Yes → Add newWord 到 graph[word]\n→ Step 5: 建立字典 level ← {} // 記錄每個詞到 beginWord 的最短距離\n→ Step 6: Queue q ← [beginWord] // BFS 起始\n→ Step 7: level[beginWord] ← 0\n→ Step 8: While q 不為空\n    → current ← q.pop_front()\n    → For each neighbor in graph[current]\n        → Decision: neighbor 未在 level?\n            Yes → level[neighbor] ← level[current] + 1\n                     q.push_back(neighbor)\n→ Decision: endWord 在 level? // 判斷是否能到達\n    No → End // 若無，回傳空列表\n→ Step 9: 目標距離 dist ← level[endWord] // 最短距離\n→ Step 10: 建立結果列表 results ← []\n→ Step 11: DFS(current, path)\n    → 決定: current == endWord ?\n        Yes → 若 len(path)-1 == dist → results.add(copy of path) // 完整路徑\n        No → 退出\n    → For each neighbor in graph[current]\n        → Decision: level[neighbor] == level[current] + 1? // 只走最短層\n            Yes → path.append(neighbor)\n                     DFS(neighbor, path)\n                     path.pop_back()\n→ Step 12: 呼叫 DFS(beginWord, [beginWord]) // 開始回溯\n→ End // 程式執行結束，results 為所有最短轉換序列"
    },
    {
      "title": "Generate Random Point in a Circle",
      "source_file": "Leetcode/leetcode478.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]",
          "expected_output": "[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[-0.02493,-0.38077],[0.82314,0.38945],[0.36572,0.17248]]'\nGot (Norm):      '[null,[-0.6141462302295027,0.4461391302417719],[-0.34026647375347713,-0.7461547811273537],[0.7559737539174186,0.20586758084989137]]'\n--- (Raw) ---\nRaw Expected: '[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]'\nRaw Got:      '[null, [-0.6141462302295027, 0.4461391302417719], [-0.34026647375347713, -0.7461547811273537], [0.7559737539174186, 0.20586758084989137]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport math\nimport random\n\nclass Solution:\n    def __init__(self, radius, x_center, y_center):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n\n    def randPoint(self):\n        # 生成均勻分佈的隨機點\n        r = self.radius * math.sqrt(random.random())  # 保證半徑分佈均勻\n        theta = random.uniform(0, 2 * math.pi)        # 隨機角度\n        x = self.x_center + r * math.cos(theta)\n        y = self.y_center + r * math.sin(theta)\n        return [x, y]\n\nif __name__ == \"__main__\":\n    # 讀取標準輸入\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        sys.exit()\n    calls = json.loads(data[0])\n    args_list = json.loads(data[1])\n\n    results = []\n    obj = None\n    for call, args in zip(calls, args_list):\n        if call == \"Solution\":\n            obj = Solution(*args)\n            results.append(None)\n        else:\n            method = getattr(obj, call)\n            results.append(method(*args))\n\n    # 輸出結果\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce step-by-step virtual code for the described task: a class that initializes with circle radius and center, and has randPoint method that returns uniformly random point inside circle. We must produce each line with virtual code and comment. Must not output real code. Use Start, End, Decision, etc. Provide algorithm steps: for generating random point uniformly inside circle: generate random radius r via sqrt(random()) * radius, random angle theta via random()*2π. Then x = x_center + r*cos(theta), y = y_center + r*sin(theta). Implementation details: Use pseudo functions: Random() generates uniform [0,1). We need to show steps: create class Solution, constructor, storing radius and center; method randPoint: generate u1 random, u2 random; compute r = radius * sqrt(u1); theta = 2π * u2; x = x_center + r*cos(theta); y = y_center + r*sin(theta); return [x, y].\n\nWe need to use virtual code format. Each line: \"虛擬碼步驟 // 解釋\". Use arrows. Use Start and End.\n\nLet's design:\n\nStart\n→ Step 1: Define Class Solution // 定義 Solution 類別\n→ Step 2: Constructor(radius, x_center, y_center) // 建構子，初始化參數\n    → Step 2a: Store radius in this.radius // 保存半徑\n    → Step 2b: Store x_center in this.xc // 保存中心 x 坐標\n    → Step 2c: Store y_center in this.yc // 保存中心 y 坐標\n→ Step 3: Method randPoint() // 定義生成隨機點的方法\n    → Step 3a: u1 = Random() // 取得 [0,1) 的隨機數\n    → Step 3b: u2 = Random() // 取得另一隨機數\n    → Step 3c: r = this.radius * sqrt(u1) // 依照半徑分佈調整半徑\n    → Step 3d: theta = 2π * u2 // 隨機角度\n    → Step 3e: x = this.xc + r * cos(theta) // 計算 x 座標\n    → Step 3f: y = this.yc + r * sin(theta) // 計算 y 座標\n    → Step 3g: return [x, y] // 返回點座標\nEnd\n\nBut we must format each line with arrow and comment. Use \"→\" at start for each step? In example they used \"→ Step 1: ...\". For sub-steps maybe use indentation but still \"→\". But the example uses \"→ Decision:\" and nested with spaces. So we should follow: Start, arrow, steps. For nested steps we can indent with spaces but keep arrow? They used \"    Yes →\". So we can indent sub-steps by spaces.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 定義類別 Solution // 建立 Solution 類別\n→ Step 2: 建構子(radius, x_center, y_center) // 初始化圓半徑與中心座標\n    → Step 2a: this.radius = radius // 保存半徑\n    → Step 2b: this.xc = x_center // 保存中心 x\n    → Step 2c: this.yc = y_center // 保存中心 y\n→ Step 3: 定義方法 randPoint() // 生成隨機點\n    → Step 3a: u1 = Random() // 產生 [0,1) 隨機數 1\n    → Step 3b: u2 = Random() // 產生 [0,1) 隨機數 2\n    → Step 3c: r = this.radius * sqrt(u1) // 根據均勻分佈調整半徑\n    → Step 3d: theta = 2π * u2 // 生成隨機角度\n    → Step 3e: x = this.xc + r * cos(theta) // 計算 x 坐標\n    → Step 3f: y = this.yc + r * sin(theta) // 計算 y 坐標\n    → Step 3g: return [x, y] // 回傳隨機點\nEnd // 程式結束\n\nNeed to ensure each line has the format: \"虛擬碼步驟 // 解釋\". For nested steps we still keep the arrow? In example nested lines start with spaces then arrow. So our lines can be like \"    → Step 2a: ...\" So each line still contains arrow.\n\nAlso we need to indicate that Step 3 is a method, but we might use \"→ Function randPoint()\" but keep \"Step\".\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義類別 Solution // 建立 Solution 類別\n→ Step 2: 建構子(radius, x_center, y_center) // 初始化圓半徑與中心座標\n    → Step 2a: this.radius = radius // 保存半徑\n    → Step 2b: this.xc = x_center // 保存中心 x 坐標\n    → Step 2c: this.yc = y_center // 保存中心 y 坐標\n→ Step 3: 定義方法 randPoint() // 生成均勻隨機點\n    → Step 3a: u1 = Random() // 產生 [0,1) 的隨機數 1\n    → Step 3b: u2 = Random() // 產生 [0,1) 的隨機數 2\n    → Step 3c: r = this.radius * sqrt(u1) // 根據均勻分佈調整半徑\n    → Step 3d: theta = 2π * u2 // 隨機角度\n    → Step 3e: x = this.xc + r * cos(theta) // 計算 x 座標\n    → Step 3f: y = this.yc + r * sin(theta) // 計算 y 座標\n    → Step 3g: return [x, y] // 回傳點座標\nEnd // 程式結束"
    },
    {
      "title": "Remove Element",
      "source_file": "Leetcode/leetcode27.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "nums = [0,1,2,2,3,0,4,2], val = 2",
          "expected_output": "5, nums = [0,1,4,0,3,_,_,_]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '5,nums=[0,1,4,0,3,_,_,_]'\nGot (Norm):      '5,nums=[0,1,3,0,4,_,_,_]'\n--- (Raw) ---\nRaw Expected: '5, nums = [0,1,4,0,3,_,_,_]'\nRaw Got:      '5, nums = [0,1,3,0,4,_,_,_]'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\n\ndef remove_element(nums, val):\n    \"\"\"移除所有等於 val 的元素，返回保留元素的個數 k。\"\"\"\n    write_idx = 0\n    for i in range(len(nums)):\n        if nums[i] != val:\n            nums[write_idx] = nums[i]\n            write_idx += 1\n    return write_idx\n\ndef main():\n    data = sys.stdin.read().replace('\\n', ' ')\n    # 取得 nums 列表\n    nums_match = re.search(r'nums\\s*=\\s*(\\[[^\\]]*\\])', data)\n    if not nums_match:\n        raise ValueError(\"輸入中缺少 'nums' 列表。\")\n    nums = ast.literal_eval(nums_match.group(1))\n    # 取得 val 整數\n    val_match = re.search(r'val\\s*=\\s*(-?\\d+)', data)\n    if not val_match:\n        raise ValueError(\"輸入中缺少 'val' 整數。\")\n    val = int(val_match.group(1))\n\n    k = remove_element(nums, val)\n\n    # 將剩餘位置用 '_' 標示\n    if len(nums) > k:\n        tail = ',_' * (len(nums) - k)\n        array_repr = '[' + ','.join(map(str, nums[:k])) + tail + ']'\n    else:\n        array_repr = '[' + ','.join(map(str, nums[:k])) + ']'\n\n    print(f\"{k}, nums = {array_repr}\")\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm: two-pointer technique: iterate through array, keep write index. At end return write index. Provide step-by-step virtual code lines. Use arrows and structure. Ensure each line has virtual code step + comment. Use Start, End, Decision.\n\nLet's craft:\n\nStart\n→ Step 1: 初始化 writeIndex = 0 // 指向下一個可寫入的位置\n→ For i from 0 to length-1:\n    → Decision: nums[i] ≠ val? // 判断当前元素是否为目标值\n        Yes → Step 2: nums[writeIndex] = nums[i] // 将非目标值写入当前位置\n               → Step 3: writeIndex = writeIndex + 1 // 更新写入索引\n        No → Step 4: 跳过 // 若为目标值则不写入，直接继续循环\n→ End loop\n→ Return writeIndex // writeIndex即为k\n\nNeed each line separate. Use arrows indent. Provide explanation. Use [空格] after step then comment. Format like example. Use \"→\" preceding each. Also need Decision block indent. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 writeIndex = 0 // writeIndex 指向下一個可寫入的位置  \n→ For i from 0 to nums.length-1: // 遍歷整個陣列  \n  → Decision: 如果 nums[i] ≠ val? // 判斷當前元素是否為要移除的值  \n   Yes → Step 2: nums[writeIndex] = nums[i] // 把非目標值寫入 writeIndex 所在位置  \n    → Step 3: writeIndex = writeIndex + 1 // writeIndex 前進，準備寫入下一個非目標值  \n   No → Step 4: 跳過 // 若為目標值則不寫入，直接繼續下一輪迴圈  \n→ End For // 完成所有元素的檢查與寫入  \n→ Return writeIndex // writeIndex 即為 k，代表前 k 個元素均不等於 val  \nEnd // 程式執行結束"
    },
    {
      "title": "Ones and Zeroes",
      "source_file": "Leetcode/leetcode474.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "strs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m = 5, n = 3",
          "expected_output": "4",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp7kfhi6zm.py\", line 40, in <module>\n    strs, m, n = parse_input(raw_input)\n                 ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp7kfhi6zm.py\", line 28, in parse_input\n    strs = ast.literal_eval(val.strip())\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [\"10\"\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "strs = [\"10\",\"0\",\"1\"], m = 1, n = 1",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpr5fa6tsc.py\", line 40, in <module>\n    strs, m, n = parse_input(raw_input)\n                 ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpr5fa6tsc.py\", line 28, in parse_input\n    strs = ast.literal_eval(val.strip())\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [\"10\"\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findMaxForm(self, strs, m, n):\n        # dp[i][j] 表示使用 i 個 0 和 j 個 1 能形成的最大字串數\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for s in strs:\n            zeros = s.count('0')\n            ones = s.count('1')\n            # 逆序遍歷，避免重複使用同一個字串\n            for i in range(m, zeros - 1, -1):\n                for j in range(n, ones - 1, -1):\n                    dp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1)\n        return dp[m][n]\n\ndef parse_input(input_text: str):\n    \"\"\"\n    解析類似 'strs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m = 5, n = 3' 的輸入格式。\n    \"\"\"\n    parts = [p.strip() for p in input_text.split(',')]\n    strs = None\n    m = None\n    n = None\n    for part in parts:\n        if part.startswith('strs'):\n            _, val = part.split('=', 1)\n            strs = ast.literal_eval(val.strip())\n        elif part.startswith('m'):\n            _, val = part.split('=', 1)\n            m = int(val.strip())\n        elif part.startswith('n'):\n            _, val = part.split('=', 1)\n            n = int(val.strip())\n    return strs, m, n\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取全部資料\n    raw_input = sys.stdin.read()\n    strs, m, n = parse_input(raw_input)\n    # 呼叫解法並輸出結果\n    sol = Solution()\n    result = sol.findMaxForm(strs, m, n)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to output virtual code steps for problem: Given array of binary strings, two integers m, n, find largest subset size such that subset has at most m zeros and n ones. This is classic 0/1 knap problem. We'll produce algorithm: dynamic programming 2D DP: dp[i][j] = max number of strings using i zeros and j ones. Iterate strings, count zeros, ones, update dp descending loops. Finally dp[m][n] answer. Provide steps. We'll need to output each line: virtual step with arrow, etc. Use Start, End. Provide decision steps. Provide loops and conditions. Since we can't produce code, but pseudo. Provide explanation. So format lines like:\n\nStart // 程式開始執行\n→ Step 1: 初始化 2D 陣列 dp[0..m][0..n] 為 0 // 建立動態規劃表\n...\n\nUse Decision, loops. Ensure each line has \"虛擬碼步驟\" + space + \"// 解釋\". We'll need to use arrow \"→\" each step.\n\nLet's craft.\n\nWe'll need to include loops:\n\n→ Step 2: 對每個字串 str in strs 做:\n    Count zeros z, ones o\n    → Decision: 是否 z>m 或 o>n? // 若超過限制，跳過此字串\n        Yes → Step 3: Continue // 跳過\n        No → 逐行更新 dp 由 i=m downto z, j=n downto o:\n            → Step 4: dp[i][j] = max(dp[i][j], dp[i-z][j-o] + 1) // 更新 DP\n\nAfter loop: → Step 5: 回傳 dp[m][n] // 最大子集大小\n\nFinally End.\n\nWe need to maintain indentation? Not required but we can indent within decisions. Provide clear. Use \"Yes →\" \"No →\" lines.\n\nOk produce.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 2 維陣列 dp[0..m][0..n] 並將所有值設為 0 // 初始化動態規劃表  \n→ Step 2: 從 strs 逐一取出字串 str  \n    → Decision: 判斷 str 的 0 個數 z 與 1 個數 o 是否都小於等於 m、n?  \n        Yes → Step 3: 進行 DP 更新  \n            → Step 4: 對 i 從 m 降至 z  \n                → Step 5: 對 j 從 n 降至 o  \n                    → Step 6: dp[i][j] ← max(dp[i][j], dp[i‑z][j‑o] + 1) // 加入此字串後的最大子集數量  \n        No  → Step 7: Skip // 若此字串超過限制，直接跳過  \n→ Step 8: 回傳 dp[m][n] // 取得能用至多 m 個 0 與 n 個 1 的最大子集大小  \nEnd // 程式執行結束"
    },
    {
      "title": "Shuffle an Array",
      "source_file": "Leetcode/leetcode384.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"], [[[1, 2, 3]], [], [], []]",
          "expected_output": "[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[3,1,2],[1,2,3],[1,3,2]]'\nGot (Norm):      '[null,[3,1,2],[1,2,3],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]'\nRaw Got:      '[null,[3,1,2],[1,2,3],[3,1,2]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, nums):\n        # 儲存原始陣列，使用 list() 防止外部修改影響\n        self.nums = list(nums)\n\n    def reset(self):\n        # 回傳原始陣列的複本\n        return list(self.nums)\n\n    def shuffle(self):\n        # 先複製原始陣列，避免改動 self.nums\n        shuffled = list(self.nums)\n        n = len(shuffled)\n        # Fisher‑Yates 洗牌\n        for i in range(n):\n            j = random.randint(i, n - 1)\n            shuffled[i], shuffled[j] = shuffled[j], shuffled[i]\n        return shuffled\n\ndef main():\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 分離操作序列與對應參數\n    # 例子: '[\"Solution\",\"shuffle\",\"reset\",\"shuffle\"], [[[1,2,3]], [], [], []]'\n    parts = data.split('],', 1)\n    ops_str = parts[0] + ']'\n    args_str = parts[1].strip()\n\n    ops = json.loads(ops_str)\n    args = json.loads(args_str)\n\n    res = []\n    obj = None\n\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            obj = Solution(arg[0])\n            res.append(None)          # 代表 null\n        elif op == \"reset\":\n            res.append(obj.reset())\n        elif op == \"shuffle\":\n            res.append(obj.shuffle())\n        else:\n            # 若有未知操作，可忽略或 raise\n            res.append(None)\n\n    # 輸出結果，使用 json.dumps 以得到 null 而不是 None\n    print(json.dumps(res, separators=(',', ':')))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for designing this algorithm. It's essentially a typical shuffle using Fisher-Yates. We need to include initialization storing original array and working copy. Provide reset to return original, shuffle to random. We must provide line-by-line virtual code with explanation. Must use arrows and structure.\n\nWe need to produce a step-by-step algorithm: Start, initialize class fields, etc.\n\nWe need to produce explanation for each line. Let's produce steps:\n\nStart // Start of program\n→ Step 1: Define class Solution // Define the Solution class\n→ Step 2: Declare member variable originalArray // Store original array\n→ Step 3: Declare member variable currentArray // Working copy for shuffling\n→ Step 4: Define constructor Solution(nums) // Constructor\n    → Step 4.1: Set originalArray = copy of nums // Store original\n    → Step 4.2: Set currentArray = copy of nums // Initialize working copy\n→ Step 5: Define method reset() // Reset method\n    → Step 5.1: Set currentArray = copy of originalArray // Restore original\n    → Step 5.2: Return currentArray // Return restored array\n→ Step 6: Define method shuffle() // Shuffle method\n    → Step 6.1: For i from 0 to length-1 // Iterate each position\n        → Step 6.1.1: Generate random index j between i and length-1 // Random pivot\n        → Step 6.1.2: Swap currentArray[i] and currentArray[j] // Swap to shuffle\n    → Step 6.2: Return currentArray // Return shuffled array\nEnd // Program end\n\nWe should use proper arrow formatting. Use indentation for nested steps. Use Decision? maybe not necessary. But we could use Decision: maybe for random index. But it's a loop. So it's fine.\n\nEnsure each line is \"虛擬碼步驟 // 解釋\". Use arrow \"→\". Indent with spaces.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Define class Solution // 定義 Solution 類別\n→ Step 2: Declare member variable originalArray // 用來保存原始陣列\n→ Step 3: Declare member variable currentArray // 用來存放可變的陣列\n→ Step 4: Define constructor Solution(nums) // 建構子，接收初始陣列\n    → Step 4.1: Set originalArray = copy of nums // 複製 nums 作為原始配置\n    → Step 4.2: Set currentArray = copy of nums // 初始時工作陣列與原始相同\n→ Step 5: Define method reset() // 重置方法\n    → Step 5.1: Set currentArray = copy of originalArray // 恢復為原始順序\n    → Step 5.2: Return currentArray // 回傳重置後的陣列\n→ Step 6: Define method shuffle() // 隨機打亂方法\n    → Step 6.1: For i from 0 to length(currentArray)-1 // 逐個位置處理\n        → Step 6.1.1: Generate random index j between i and length-1 // 隨機選取交換位置\n        → Step 6.1.2: Swap currentArray[i] and currentArray[j] // 交換元素實現洗牌\n    → Step 6.2: Return currentArray // 回傳已打亂的陣列\nEnd // 程式執行結束"
    },
    {
      "title": "Subsets",
      "source_file": "Leetcode/leetcode78.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nGot (Norm):      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nRaw Got:      '[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def subsets(self, nums):\n        res = []\n\n        def backtrack(start, path):\n            # 把目前子集加入結果\n            res.append(path[:])\n            # 從 start 開始嘗試加入每個元素\n            for i in range(start, len(nums)):\n                path.append(nums[i])\n                backtrack(i + 1, path)\n                path.pop()  # 回溯\n\n        backtrack(0, [])\n        return res\n\nif __name__ == \"__main__\":\n    # 讀取所有輸入\n    data = \"\".join(sys.stdin.readlines()).strip()\n    if not data:\n        nums = []\n    else:\n        # 去除前綴 \"nums =\"，取得列表字串\n        if data.startswith(\"nums\"):\n            parts = data.split(\"=\", 1)\n            nums_str = parts[1].strip()\n        else:\n            nums_str = data\n        # 使用 ast.literal_eval 安全解析列表\n        nums = ast.literal_eval(nums_str)\n\n    solution = Solution()\n    result = solution.subsets(nums)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code that returns all subsets of an array of unique integers. Use typical recursion/backtracking.\n\nWe must output line by line, each line has \"虛擬碼步驟 // 解釋/說明\". Use arrow (→) and Start, End, Decision: etc.\n\nWe need to start with Start, then Step: define function, etc.\n\nWe can produce: Start, → Step 1: Sort? Not necessary because unique. But we can include sorting for order. But not necessary.\n\nWe need to define function generateSubsets(nums) which returns list of subsets.\n\nWe can use backtracking function backtrack(start, current):\n\n- Add current to result.\n\n- For i from start to len(nums)-1:\n\n   current.append(nums[i])\n\n   backtrack(i+1, current)\n\n   current.pop()\n\nReturn result.\n\nWe also need to ensure no duplicates because nums unique.\n\nSo lines:\n\nStart // 程式開始執行\n→ Step 1: 定義函式 GenerateSubsets(nums) // 初始化主函式\n→ Step 2: result ← 空列表 // 用於儲存所有子集\n→ Step 3: backtrack(0, 空列表) // 從索引 0 開始遞歸\n→ Step 4: Return result // 回傳全部子集\n\nDefine backtrack:\n\n→ Step 5: 函式 backtrack(index, current) // index 指示從哪個位置開始選取\n\n→ Step 6: result. append(copy_of_current) // 將目前子集加入結果\n\n→ Step 7: Decision: index < len(nums)? // 是否還有元素可以加入\n     Yes → For i from index to len(nums)-1:\n              current.append(nums[i]) // 加入當前元素\n              backtrack(i+1, current) // 遞歸選擇下一個元素\n              current.pop() // 回溯移除\n     No → // 不做任何事\n\nReturn.\n\nBut we need each line as one line; we can use indentation using tab? but just write lines with arrow.\n\nWe can embed loops as lines: \"→ For i from index to len(nums)-1:\" then inside indent lines with arrow.\n\nWe can use nested indentation by using spaces before arrow? In example they used indent by 4 spaces maybe.\n\nBetter to follow example: Indentation using 4 spaces before arrow for nested lines.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: Define GenerateSubsets(nums) // 建立主函式\n→ Step 2: result ← [] // 用於存放所有子集\n→ Step 3: backtrack(0, []) // 從索引 0 開始回溯\n→ Step 4: Return result // 回傳結果\n\n→ Function backtrack(index, current): // 回溯輔助函式\n    → Step 5: result.append(copy_of(current)) // 把目前子集加入結果\n    → Decision: index < len(nums) ?\n        Yes → For i = index to len(nums)-1:\n              → Step 6: current.append(nums[i]) // 加入元素\n              → Step 7: backtrack(i+1, current) // 遞歸\n              → Step 8: current.pop() // 回溯\n        No  → // 沒有更多元素\n\nEnd // 程式結束\n\nBut we also need to indicate arrow for function call? For function definition we can use \"→ Function backtrack(index, current)\". Use arrow to show step.\n\nAlso we may need to indicate that we need to copy current before appending. Use copy_of(current).\n\nLet's ensure each line ends with \" // 解釋\".\n\nAlso we need \"Decision:\" lines: \"Decision: index < len(nums)?\" with Yes → ... No → ... So we follow the pattern.\n\nNeed to ensure no actual code; use pseudo steps.\n\nLet's craft final answer.\n\nWe'll start with Start line, then step lines.\n\nAlso we should include that nums are unique so no duplicates.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 GenerateSubsets(nums) // 建立主函式  \n→ Step 2: result ← [] // 用於存放所有子集  \n→ Step 3: backtrack(0, []) // 從索引 0 開始回溯  \n→ Step 4: Return result // 回傳所有子集  \n\n→ Function backtrack(index, current) // 回溯輔助函式  \n    → Step 5: result.append(copy_of(current)) // 把目前子集加入結果  \n    → Decision: index < len(nums) ? // 是否還有元素可以加入  \n        Yes → For i = index to len(nums)-1: // 循環從目前索引開始選取  \n            → Step 6: current.append(nums[i]) // 加入元素  \n            → Step 7: backtrack(i+1, current) // 遞歸處理下一個位置  \n            → Step 8: current.pop() // 回溯，移除剛加入的元素  \n        No  → // 無更多元素，直接返回  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Reconstruct Original Digits from English",
      "source_file": "Leetcode/leetcode423.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"owoztneoer\"",
          "expected_output": "\"012\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '012'\nGot (Norm):      '0127'\n--- (Raw) ---\nRaw Expected: '\"012\"'\nRaw Got:      '0127'"
        },
        {
          "example_index": 1,
          "input": "s = \"fviefuro\"",
          "expected_output": "\"45\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '45'\nGot (Norm):      '457'\n--- (Raw) ---\nRaw Expected: '\"45\"'\nRaw Got:      '457'"
        }
      ],
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\ndef originalDigits(s: str) -> str:\n    count = Counter(s)\n    out = {}\n    out['0'] = count['z']\n    out['2'] = count['w']\n    out['4'] = count['u']\n    out['6'] = count['x']\n    out['8'] = count['g']\n    out['3'] = count['h'] - out['8']\n    out['5'] = count['f'] - out['4']\n    out['7'] = count['s'] - out['6']\n    out['1'] = count['o'] - out['0'] - out['2'] - out['4']\n    out['9'] = count['i'] - out['5'] - out['6'] - out['8']\n    res = [k * out[k] for k in sorted(out.keys())]\n    return ''.join(res)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    s = ''.join(re.findall('[a-zA-Z]', data))\n    result = originalDigits(s)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to solve the problem: \"Given a string s containing an out-of-order English representation of digits 0-9, return the digits in ascending order.\" Classic LeetCode problem \"Reconstruct Digits from English\". Approach: count letters, determine digits based on unique letters: 0 'z', 2 'w', 4 'u', 6 'x', 8 'g', then 3 'h', 5 'f', 7 's', 1 'o', 9 'i'. Then output digits ascending order. So produce pseudo code lines.\n\nWe need to use \"虛擬碼步驟\" lines, with arrow. Provide explanation comments after each line. Must not output actual code, just steps.\n\nLet's produce lines like:\n\nStart // Start program\n\n→ Step 1: Count frequency of each letter in s // Build letter count\n\n→ Step 2: Initialize result list // Prepare output\n\n→ Decision: 是否已處理完所有 10 個數字? // loop condition\n\nBut typical algorithm: we compute counts of digits sequentially. Could produce loops over list of (digit, unique letter). We'll produce steps.\n\nAlso show how to append digits to result string ascending order.\n\nWe need to output ascending order: we can just collect counts of digits, then output 0-9 in ascending order repeated count times.\n\nSo steps: after counting digits, produce result string.\n\nAlso produce End.\n\nLet's design steps:\n\nStart\n→ Step 1: Count letters in s → letterCount // Build frequency table\n→ Step 2: Initialize digitCount array of size 10 with zeros // Store counts of each digit\n→ Step 3: For each (digit, uniqueLetter) in [ (0,'z'),(2,'w'),(4,'u'),(6,'x'),(8,'g'),(3,'h'),(5,'f'),(7,'s'),(1,'o'),(9,'i') ] // order matters\n    → Step 4: Set count = letterCount[uniqueLetter] // Number of this digit\n    → Step 5: Set digitCount[digit] = count // Record count\n    → Step 6: For each letter in digit's English word\n        → Step 7: Subtract count from letterCount[letter] // Remove used letters\n→ Step 8: Initialize output string result = \"\" // Result string\n→ Step 9: For digit from 0 to 9\n    → Step 10: Append digit digitCount[digit] times to result // Build ascending order\n→ Step 11: Return result // Return the string\nEnd\n\nBut we need to show Decision blocks? Not necessary but can include Decision: maybe \"For each digit in order\" but we can treat as loop. The format guidelines: use arrow lines, Decision with Yes/No. But not mandatory to have Decision. However, example shows Decision. We'll keep loops as steps; we could incorporate a Decision: \"是否已計算完所有字母?\" but maybe not needed.\n\nBetter to show:\n\n→ Decision: letterCount empty? but we will just produce steps.\n\nLet's produce lines with comments after //.\n\nWe should ensure each line has \"虛擬碼步驟\" + space + \"// 解釋\". Provide in Chinese.\n\nAlso include arrow '→'. For loops we can indent with 4 spaces? Example uses indentation with spaces but we can replicate. The spec: Use virtual code arrow and structure. Use \"→ Step 1: ...\" etc.\n\nSo produce:\n\nStart // 程式開始執行\n→ Step 1: Count frequency of each letter in s // 建立字母出現次數表\n→ Step 2: 初始化 digitCount[0..9] 為 0 // 用於記錄每個數字的個數\n→ Step 3: 定義順序列表 digits = [(0,'z'),(2,'w'),(4,'u'),(6,'x'),(8,'g'),(3,'h'),(5,'f'),(7,'s'),(1,'o'),(9,'i')] // 依據唯一字母決定先後\n    → Decision: 迴圈遍歷 digits 列表? // 為了依序計算每個數字\n        Yes → Step 4: 取當前 (digit, unique) // 取得目前要處理的數字與唯一字母\n        Yes → Step 5: count = letterCount[unique] // 這個字母的頻率即該數字的個數\n        Yes → Step 6: digitCount[digit] = count // 記錄數字個數\n        Yes → Step 7: 對於單詞 words[digit] 中的每個字母 l\n            → Step 8: letterCount[l] -= count // 把已用的字母從計數表扣除\n→ Step 9: 初始化結果字串 result = \"\" // 用於儲存升序輸出\n→ Step 10: 從 0 到 9 遍歷 digit\n    → Step 11: 將 digit 重複 digitCount[digit] 次追加到 result // 形成升序字串\n→ Step 12: 回傳 result // 返回最終答案\nEnd // 程式執行結束\n\nWe must ensure each line has format: `虛擬碼步驟` + space + `// 解釋`. So each line's code part plus comment.\n\nCheck formatting: Should not have extra indentation maybe.\n\nBut we can indent nested lines using spaces. The example uses indentation with 4 spaces before lines inside Decision. We'll do same.\n\nSo produce final output with lines.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Count frequency of each letter in s // 建立字母出現次數表\n→ Step 2: Initialize digitCount[0..9] 為 0 // 用於記錄每個數字的個數\n→ Step 3: 定義順序列表 digits = [(0,'z'),(2,'w'),(4,'u'),(6,'x'),(8,'g'),(3,'h'),(5,'f'),(7,'s'),(1,'o'),(9,'i')] // 依據唯一字母決定先後\n    → Decision: 迴圈遍歷 digits 列表? // 依序計算每個數字\n        Yes → Step 4: 取當前 (digit, unique) // 取得目前要處理的數字與唯一字母\n        Yes → Step 5: count = letterCount[unique] // 這個字母的頻率即該數字的個數\n        Yes → Step 6: digitCount[digit] = count // 記錄數字個數\n        Yes → Step 7: 對於單詞 words[digit] 中的每個字母 l\n            → Step 8: letterCount[l] -= count // 把已用的字母從計數表扣除\n→ Step 9: 初始化結果字串 result = \"\" // 用於儲存升序輸出\n→ Step 10: 從 0 到 9 遍歷 digit\n    → Step 11: 將 digit 重複 digitCount[digit] 次追加到 result // 形成升序字串\n→ Step 12: 回傳 result // 返回最終答案\nEnd // 程式執行結束"
    },
    {
      "title": "Different Ways to Add Parentheses",
      "source_file": "Leetcode/leetcode241.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "expression = \"2-1-1\"",
          "expected_output": "[0,2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[0,2]'\nGot (Norm):      '[2,0]'\n--- (Raw) ---\nRaw Expected: '[0,2]'\nRaw Got:      '[2, 0]'"
        },
        {
          "example_index": 1,
          "input": "expression = \"2*3-4*5\"",
          "expected_output": "[-34,-14,-10,-10,10]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[-34,-14,-10,-10,10]'\nGot (Norm):      '[-34,-10,-14,-10,10]'\n--- (Raw) ---\nRaw Expected: '[-34,-14,-10,-10,10]'\nRaw Got:      '[-34, -10, -14, -10, 10]'"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def diffWaysToCompute(self, expression: str):\n        \"\"\"\n        以遞迴 + memoization 的方式計算所有可能的運算結果。\n        \"\"\"\n        memo = {}\n\n        def compute(expr: str):\n            if expr in memo:\n                return memo[expr]\n\n            results = []\n            for idx, ch in enumerate(expr):\n                if ch in '+-*':                     # 找到一個運算符\n                    left = compute(expr[:idx])     # 左子表達式的所有結果\n                    right = compute(expr[idx + 1:])  # 右子表達式的所有結果\n                    for l in left:\n                        for r in right:\n                            if ch == '+':\n                                results.append(l + r)\n                            elif ch == '-':\n                                results.append(l - r)\n                            else:  # '*'\n                                results.append(l * r)\n\n            if not results:                         # 如果沒找到運算符，表示是單一數字\n                results.append(int(expr))\n\n            memo[expr] = results\n            return results\n\n        return compute(expression)\n\n\ndef main():\n    \"\"\"\n    主程式：從標準輸入讀取一行，格式類似\n        expression = \"2-1-1\"\n    解析出引號中的字串，呼叫解法，並將結果列印至標準輸出。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    # 取出第一個和最後一個雙引號之間的字串\n    start = data.find('\"')\n    end = data.rfind('\"')\n    if start != -1 and end != -1 and end > start:\n        expression = data[start + 1:end]\n    else:\n        # 若沒有雙引號，直接使用整行內容\n        expression = data\n\n    solution = Solution()\n    result = solution.diffWaysToCompute(expression)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with comments. This is a typical \"different ways to add parentheses\" problem. We can describe algorithm: parse string, recursively compute results by splitting at operators, use memoization.\n\nWe need to output step-by-step with Start, End, Decision, etc.\n\nWe must not output actual code; only virtual code with explanations.\n\nWe'll create steps like:\n\nStart\n→ Step 1: Parse expression into tokens (numbers & operators)\n→ Step 2: Define recursive function compute(l, r) to compute all results for subexpression from l to r index\n→ Decision: If l == r? // single number\n    Yes → Return [value] // only one result\n    No → compute results by iterating over operators between l and r\n        → Step 3: For each operator position k between l and r\n            → Step 4: leftResults = compute(l, k-1)\n            → Step 5: rightResults = compute(k+1, r)\n            → Step 6: For each left in leftResults\n                → Step 7: For each right in rightResults\n                    → Step 8: Compute result = apply operator tokens[k] to left, right\n                    → Step 9: Add result to results list\n        → Decision: Memoize results for (l,r) // store in cache\n        → Return results\n\n→ Step 10: Call compute(0, n-1) on entire tokens\n→ Step 11: Return list of results\nEnd\n\nAlso we may discuss complexity: number of subexpressions O(n^2) etc.\n\nWe need to ensure each line has \"虛擬碼步驟 [space] // 解釋/說明\". Use arrows and decisions.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 將輸入字串拆分成數字及運算符的序列 tokens // 方便後續索引處理  \n→ Step 2: 建立遞迴函式 compute(l, r) 計算子表達式 tokens[l…r] 的所有可能結果 // l, r 為下標  \n→ Decision: 若 l == r? // 子表達式僅為一個數字  \n  Yes → Return [tokens[l]] // 只有一個結果，直接回傳  \n  No → // 需要進行分割並遞迴  \n   → Step 3: 初始化空結果清單 results  \n   → Step 4: 迭代 k 從 l+1 到 r-1，步長為 2（只選擇運算符位置）  \n    → Step 5: operator = tokens[k]  \n    → Step 6: leftResults = compute(l, k-1) // 左子表達式所有結果  \n    → Step 7: rightResults = compute(k+1, r) // 右子表達式所有結果  \n    → Step 8: 迭代 left 在 leftResults  \n     → Step 9: 迭代 right 在 rightResults  \n      → Step 10: result = apply(operator, left, right) // 執行運算  \n       → Step 11: Append result 到 results  \n    → Decision: 目前已處理所有 k?  \n     Yes → // 完成此子表達式的所有結果  \n      → Step 12: memo[(l, r)] = results // 儲存以供重用  \n      → Return results  \n→ Step 13: 呼叫 compute(0, len(tokens)-1) 計算整個表達式的所有結果 // 最終輸出  \n→ Step 14: 回傳 compute 的結果清單 // 程式結束  \nEnd // 程式執行結束"
    }
  ]
}