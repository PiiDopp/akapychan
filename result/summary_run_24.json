{
  "run_index": 24,
  "total_files_found": 391,
  "total_files_processed": 323,
  "files_skipped": 68,
  "files_failed_load": 0,
  "---": "--- (以下基於 *題目* 總數) ---",
  "total_problems_attempted": 334,
  "generation_and_validation_success_count": 286,
  "generation_or_validation_failure_count": 48,
  "failed_cases_details": [
    {
      "title": "統計文字行數",
      "source_file": "900.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "（假設 data.txt 內容如下）\\nHello\\nPython\\nWorld",
          "expected_output": "檔案共有 3 行",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '檔案共有3行'\nGot (Norm):      '檔案共有1行'\n--- (Raw) ---\nRaw Expected: '檔案共有 3 行'\nRaw Got:      '檔案共有 1 行'"
        }
      ],
      "generated_code": "import sys\n\ndef count_lines_in_file(filename: str) -> None:\n    try:\n        with open(filename, 'r', encoding='utf-8') as f:\n            lines = f.readlines()\n            print('檔案共有', len(lines), '行')\n    except FileNotFoundError:\n        print('找不到檔案！')\n\ndef main():\n    # No input required for this task; simply perform the operation\n    count_lines_in_file('data.txt')\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code lines each with \"→\" arrow, then explanation comments. Format: Each line: \"虛擬碼步驟 // 解釋\". Start/End. Use Decision. The program: open file, count lines, print count. If file not found: print \"找不到檔案！\". Use with and try/except. Provide step-by-step virtual code. Let's produce:\n\nStart\n→ Step 1: 定義檔名為 'data.txt' // 指定檔案名稱\n→ Step 2: try // 嘗試打開檔案\n    → Step 3: with open(檔名, 'r') as file: // 使用 with 開啟檔案\n        → Step 4: 計算行數 = len(file.readlines()) // 讀取所有行並計算\n        → Step 5: print('總行數:', 行數) // 輸出行數\n    → Decision: try 成功? // 判斷是否成功進入 try\n        Yes → Step 6: End // 完成\n    No  → Step 7: except FileNotFoundError: // 檔案不存在例外\n        → Step 8: print('找不到檔案！') // 顯示錯誤訊息\n        → Step 9: End // 結束\n\nBut need to structure with decision for try? Actually typical: try block with code; except block. We can represent as decision after try? We'll produce a decision: \"Decision: try 失敗?\" but we can keep simple: we can show the structure: try ... except ... End.\n\nBetter:\n\nStart\n→ Step 1: 準備檔名 'data.txt' // 定義檔名\n→ Decision: 進入 try 區塊? // 進入 try\n    Yes → Step 2: with open(檔名, 'r') as file: // 開啟檔案\n        → Step 3: 行數 = len(file.readlines()) // 讀取並計算\n        → Step 4: print('總行數:', 行數) // 輸出\n    No  → Step 5: except FileNotFoundError: // 檔案不存在\n        → Step 6: print('找不到檔案！') // 顯示訊息\nEnd\n\nBut decision arrow not exactly. The instruction says: use Decision: \"Decision: 如果數字大於 0?\" etc. For our try/except, we might show:\n\n→ Decision: 嘗試打開檔案成功? // 判斷是否成功打開\n\n    Yes → Step 2: with open(檔名, 'r') as file: // 打開\n        → Step 3: 行數 = len(file.readlines())\n        → Step 4: print('總行數:', 行數)\n\n    No  → Step 5: except FileNotFoundError: // 失敗\n        → Step 6: print('找不到檔案！')\n\nBut we don't need except after? Let's produce as:\n\nStart\n→ Step 1: 準備檔名 'data.txt' // 指定檔案名稱\n→ Decision: 嘗試打開檔案? // 進入 try\n    Yes → Step 2: with open(檔名, 'r') as file: // 開啟檔案\n        → Step 3: 行數 = len(file.readlines()) // 讀取行數\n        → Step 4: print('總行數:', 行數) // 顯示行數\n    No  → Step 5: except FileNotFoundError: // 檔案不存在\n        → Step 6: print('找不到檔案！') // 顯示錯誤訊息\nEnd\n\nBut \"Decision: 嘗試打開檔案?\" is ambiguous. Should be \"Decision: 嘗試打開檔案成功?\" maybe.\n\nSimplify: Use try/except block representation: \"Decision: 嘗試打開檔案成功?\" Yes: do with. No: except block.\n\nOk.\n\nLet's output accordingly. Ensure each line has arrow arrow? The example uses \"→ Step 1: ...\". For decision we use \"Decision: ...\".\n\nThus:\n\nStart // 程式開始執行\n→ Step 1: 準備檔名 'data.txt' // 指定檔案名稱\n→ Decision: 嘗試打開檔案成功? // 判斷是否能成功打開\n    Yes → Step 2: with open(檔名, 'r') as file: // 開啟檔案\n        → Step 3: 行數 = len(file.readlines()) // 讀取所有行並計算\n        → Step 4: print('總行數:', 行數) // 輸出總行數\n    No  → Step 5: except FileNotFoundError: // 檔案不存在時進入\n        → Step 6: print('找不到檔案！') // 顯示錯誤訊息\nEnd // 程式執行結束\n\nLet's ensure the indentation of arrows as per example: For nested steps, they used spaces before arrows. We'll replicate.\n\nWe'll output each line as separate line.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 準備檔名 'data.txt' // 指定檔案名稱  \n→ Decision: 嘗試打開檔案成功? // 判斷是否能成功打開  \n    Yes → Step 2: with open(檔名, 'r') as file: // 開啟檔案  \n        → Step 3: 行數 = len(file.readlines()) // 讀取所有行並計算  \n        → Step 4: print('總行數:', 行數) // 輸出總行數  \n    No  → Step 5: except FileNotFoundError: // 檔案不存在時進入  \n        → Step 6: print('找不到檔案！') // 顯示錯誤訊息  \nEnd // 程式執行結束"
    },
    {
      "title": "模擬擲骰子遊戲",
      "source_file": "800.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "print(roll_dice(5))",
          "expected_output": "[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,6,1,4,2]#(結果會隨機，每次可能不同)'\nGot (Norm):      '[4,2,4,4,6]'\n--- (Raw) ---\nRaw Expected: '[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)'\nRaw Got:      '[4, 2, 4, 4, 6]'"
        }
      ],
      "generated_code": "import random\nimport sys\n\ndef roll_dice(n):\n    \"\"\"模擬擲 n 次六面骰，回傳所有結果的串列。\"\"\"\n    results = []\n    for _ in range(n):\n        results.append(random.randint(1, 6))\n    return results\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取使用者輸入的程式碼\n    code = sys.stdin.read()\n    # 執行讀取到的程式碼（包含對 roll_dice 的呼叫）\n    exec(code)",
      "virtual_code": "Thinking...\nWe need to produce a virtual code step-by-step. Each line: \"虛擬碼步驟 // 解釋\". Use arrows: Start, End, Decision, etc. Should describe a function roll_dice(n) that uses random module, simulates n dice rolls, returns list of results. We need no actual code, just steps.\n\nWe need to include import random, function definition, create list, loop, generate random 1-6, append, return list, etc.\n\nLet's produce lines: Start, import random, define function, initialize list, loop, inside loop generate random int, append, after loop return list, End. Use arrows to indicate flow.\n\nUse Chinese comments.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 載入 random 模組 // 引入 random 模組以便產生隨機數\n→ Step 2: 定義函式 roll_dice(n) // 建立一個接受參數 n 的函式\n→ Decision: 參數 n 是否為正整數? // 確保擲骰次數有效\n    Yes → Step 3: 初始化空列表 results = [] // 用於存放每一次擲骰結果\n    No  → Step 4: 回傳空列表 [] // 若 n 無效，直接回傳空結果\n→ Step 5: 循環執行 n 次 // 為每一次擲骰做一次迴圈\n    → Step 6: 產生隨機數 die = random.randint(1, 6) // 模擬擲六面骰，產生 1~6 的數字\n    → Step 7: 將 die 加入 results // 把擲到的點數放進列表\n→ Step 8: 回傳 results // 完成 n 次擲骰後回傳結果列表\nEnd // 程式執行結束\n\nMake sure each line ends with //.\n\nCheck formatting: Each line has \"虛擬碼步驟 // 解釋\". Use arrow with \"→\" etc. Provide decision branches. Use indentation with spaces for clarity.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 載入 random 模組 // 引入 random 模組以便產生隨機數  \n→ Step 2: 定義函式 roll_dice(n) // 建立一個接受參數 n 的函式  \n→ Decision: 參數 n 是否為正整數? // 確保擲骰次數有效  \n  Yes → Step 3: 初始化空列表 results = [] // 用於存放每一次擲骰結果  \n  No  → Step 4: 回傳空列表 [] // 若 n 無效，直接回傳空結果  \n→ Step 5: 循環執行 n 次 // 為每一次擲骰做一次迴圈  \n  → Step 6: 產生隨機數 die = random.randint(1, 6) // 模擬擲六面骰，產生 1~6 的數字  \n  → Step 7: 將 die 加入 results // 把擲到的點數放進列表  \n→ Step 8: 回傳 results // 完成 n 次擲骰後回傳結果列表  \nEnd // 程式執行結束"
    },
    {
      "title": "計算程式執行時間",
      "source_file": "800.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "import time\n\ndef slow_add(a, b):\n    time.sleep(2)\n    return a + b\n\nprint(measure_time(slow_add, 3, 5))",
          "expected_output": "約 2.0 秒 (依電腦執行環境略有差異)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '約2.0秒(依電腦執行環境略有差異)'\nGot (Norm):      '2.0'\n--- (Raw) ---\nRaw Expected: '約 2.0 秒 (依電腦執行環境略有差異)'\nRaw Got:      '2.0'"
        }
      ],
      "generated_code": "import sys\nimport time\n\ndef measure_time(func, *args):\n    \"\"\"測量 func 執行時間，並回傳秒數（四捨五入到小數點 3 位）。\"\"\"\n    start = time.time()\n    func(*args)\n    end = time.time()\n    return round(end - start, 3)\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取所有程式碼\n    code = sys.stdin.read()\n    # 以本模組的命名空間執行讀取到的程式碼\n    exec(code, globals())",
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line with arrow arrows and explanation. No actual code, just pseudo. Steps: import time, define function measure_time, start time, call func, end time, compute duration, round to 3 decimals, return duration. Use arrow. We need to use the structure: Start, End, Decision maybe none. Provide comments in Chinese. Provide each line. Use arrow '→' after the label? Format: \"虛擬碼步驟 [space] // 解釋\". They use arrow at start of each step. Eg: \"→ Step 1: 輸入使用者數字 //\". We'll follow that style.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: Import time 模組 // 引入時間相關函式\n→ Step 2: 定義函數 measure_time(func, *args) // 接收待測函式與參數\n→ Decision: 函數已定義? // 檢查函式已存在\n    Yes → Step 3: 記錄開始時間 start_time ← time.time() // 取得執行起始時間\n    No  → Step 4: 回傳錯誤訊息 // 但此情境不需要\n→ Step 5: 執行目標函式 result ← func(*args) // 呼叫並傳入參數\n→ Step 6: 記錄結束時間 end_time ← time.time() // 取得執行結束時間\n→ Step 7: 計算耗時 duration ← end_time - start_time // 取得秒數\n→ Step 8: 四捨五入 duration ← round(duration, 3) // 保留三位小數\n→ Step 9: 回傳結果 duration // 傳回測量結果\nEnd // 程式執行結束\n\nBut they want \"四捨五入到小數點 3 位\" maybe round. Should also maybe return result? The function returns duration only, not the result of func? The requirement: measure_time(func, *args) 用來測量函數 func 執行所需的秒數，並回傳結果 (四捨五入到小數點 3 位)。 Could mean return duration. Could also return result and duration? It says \"並回傳結果\" meaning return result? ambiguous. I think they want return duration. We'll produce accordingly.\n\nBut we need to include return of result maybe? We can show that we store result but not used. Provide explanation accordingly.\n\nLet's produce final answer with lines. Use arrow for each step. Provide Decision only for demonstration? It's optional. But they said Use arrow and structure. Use Decision maybe for some branching but not necessary. But we can include Decision just for demonstration. We can use Decision: if we want to check if function is callable? maybe skip.\n\nBut we should adhere to output format. Each line includes \"虛擬碼步驟\" and \" // 解釋\". So we need to produce lines like \"Start // 程式開始執行\". Use \"→\" to indicate step. Use \"Decision:\" where necessary. Use indentation for nested. Provide no actual code. Good.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Import time 模組 // 引入時間計算所需的標準模組  \n→ Step 2: 定義函式 measure_time(func, *args) // 接收待測函式與可變參數  \n→ Decision: 函式已定義? // 確認函式宣告是否正確  \n  Yes → Step 3: 記錄開始時間 start_time ← time.time() // 取得執行前的時間戳  \n  No  → Step 4: 回傳錯誤訊息 // 若函式未定義則返回錯誤  \n→ Step 5: 執行目標函式 result ← func(*args) // 呼叫 func 並傳遞參數  \n→ Step 6: 記錄結束時間 end_time ← time.time() // 取得執行後的時間戳  \n→ Step 7: 計算耗時 duration ← end_time - start_time // 取得兩個時間戳差值，即執行時間  \n→ Step 8: 四捨五入 duration ← round(duration, 3) // 將耗時四捨五入到小數點第三位  \n→ Step 9: 回傳結果 duration // 返回測量得到的秒數  \nEnd // 程式執行結束"
    },
    {
      "title": "學生資料類別設計",
      "source_file": "1100.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "Alice 的分數是 90\nBob 的分數是 80",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'Alice的分數是90\\nBob的分數是80'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: 'Alice 的分數是 90\\nBob 的分數是 80'\nRaw Got:      ''"
        }
      ],
      "generated_code": "import sys\n\nclass Student:\n    \"\"\"\n    Student 類別：儲存姓名與分數，並能輸出個人資訊。\n    \"\"\"\n    def __init__(self, name: str, score: int):\n        \"\"\"\n        建構子：初始化 name 與 score 屬性。\n        \"\"\"\n        self.name = name\n        self.score = score\n\n    def show_info(self):\n        \"\"\"\n        輸出「姓名 的分數是 分數」的字串。\n        \"\"\"\n        print(f'{self.name} 的分數是 {self.score}')\n\ndef main():\n    \"\"\"\n    主程式：從標準輸入讀取資料，若無輸入則使用預設的兩個學生。\n    \"\"\"\n    # 讀取所有非空行\n    lines = [line.strip() for line in sys.stdin if line.strip()]\n\n    students = []\n\n    if not lines:\n        # 若沒有輸入，使用預設學生\n        students.append(Student('Alice', 90))\n        students.append(Student('Bob', 80))\n    else:\n        # 每行假設格式為「姓名 分數」，例如：Alice 90\n        for line in lines:\n            parts = line.split()\n            if len(parts) < 2:\n                continue\n            name = parts[0]\n            try:\n                score = int(parts[1])\n            except ValueError:\n                continue\n            students.append(Student(name, score))\n\n    # 顯示所有學生資訊\n    for student in students:\n        student.show_info()\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line with explanations. Use arrows, Start, End, Decision maybe not needed. We just produce steps.\n\nWe need to define Student class with __init__, show_info, create two objects, call methods.\n\nWe must produce each line as: \"虛擬碼步驟 // 解釋\"\n\nWe'll structure:\n\nStart // 程式開始執行\n→ Step 1: 定義類別 Student // 定義 Student 類\n→ Step 2: 內部定義 __init__(self, name, score) // 建構子\n→ Step 3: self.name = name // 初始化 name\n→ Step 4: self.score = score // 初始化 score\n→ Step 5: 定義 show_info(self) // 方法\n→ Step 6: 輸出 f'{self.name} 的分數是 {self.score}' // 顯示資訊\n→ Step 7: 建立 student1 = Student('Alice', 90) // 第一個實例\n→ Step 8: 建立 student2 = Student('Bob', 85) // 第二個實例\n→ Step 9: 呼叫 student1.show_info() // 顯示第一個\n→ Step 10: 呼叫 student2.show_info() // 顯示第二個\nEnd // 程式執行結束\n\nWe need arrow \"→\" each step. Use comments in Chinese.\n\nLet's output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類別 Student // 建立 Student 類別  \n→ Step 2: 內部定義 __init__(self, name, score) // 建構子接受姓名與分數  \n→ Step 3: self.name = name // 初始化姓名屬性  \n→ Step 4: self.score = score // 初始化分數屬性  \n→ Step 5: 定義 show_info(self) // 定義顯示資訊的方法  \n→ Step 6: 輸出 f'{self.name} 的分數是 {self.score}' // 顯示「姓名 的分數是 分數」  \n→ Step 7: 建立 student1 = Student('Alice', 90) // 創建第一個 Student 物件  \n→ Step 8: 建立 student2 = Student('Bob', 85) // 創建第二個 Student 物件  \n→ Step 9: 呼叫 student1.show_info() // 顯示第一個物件的資訊  \n→ Step 10: 呼叫 student2.show_info() // 顯示第二個物件的資訊  \nEnd // 程式執行結束"
    },
    {
      "title": "集合函數練習",
      "source_file": "600.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "{'apple', 'orange', 'grape', 'melon'}",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '{\"apple\",\"orange\",\"grape\",\"melon\"}'\nGot (Norm):      '{\"melon\",\"orange\",\"apple\",\"grape\"}'\n--- (Raw) ---\nRaw Expected: \"{'apple', 'orange', 'grape', 'melon'}\"\nRaw Got:      \"{'melon', 'orange', 'apple', 'grape'}\""
        }
      ],
      "generated_code": "import sys\n\ndef main():\n    # Consume any input from stdin (there is none needed for this task)\n    sys.stdin.read()\n\n    # 建立初始集合\n    fruits = {'apple', 'banana'}\n\n    # 1. 使用 add() 新增 'orange'\n    fruits.add('orange')\n\n    # 2. 使用 update() 一次新增 'grape' 與 'melon'\n    fruits.update(['grape', 'melon'])\n\n    # 3. 使用 remove() 移除 'banana'\n    fruits.remove('banana')\n\n    # 4. 使用 discard() 嘗試移除 'pineapple'（不存在的元素，無錯誤）\n    fruits.discard('pineapple')\n\n    # 輸出最終集合\n    print(fruits)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line with comments. Use Start, End, etc. Each line: \"虛擬碼步驟 // 解釋\". Use arrow arrows. Let's craft steps:\n\nStart\n→ Step 1: 定義 fruits = {'apple', 'banana'} // 建立集合\n→ Step 2: 呼叫 fruits.add('orange') // 新增 'orange'\n→ Step 3: 呼叫 fruits.update({'grape', 'melon'}) // 一次新增兩個\n→ Step 4: 呼叫 fruits.remove('banana') // 移除 'banana'\n→ Step 5: 呼叫 fruits.discard('pineapple') // 嘗試移除不存在元素\n→ Step 6: 輸出 fruits // 顯示結果\nEnd\n\nEnsure formatting exactly. Use arrow. Provide explanations. Use each line. No actual code. Ok.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: fruits = {'apple', 'banana'} // 建立初始集合 fruits  \n→ Step 2: fruits.add('orange') // 使用 add() 新增 'orange'  \n→ Step 3: fruits.update({'grape', 'melon'}) // 使用 update() 一次新增 'grape' 與 'melon'  \n→ Step 4: fruits.remove('banana') // 使用 remove() 移除 'banana'  \n→ Step 5: fruits.discard('pineapple') // 使用 discard() 嘗試移除不存在的 'pineapple'（不會拋錯）  \n→ Step 6: print(fruits) // 輸出最終集合  \nEnd // 程式執行結束"
    },
    {
      "title": "即時匯率查詢小工具",
      "source_file": "1200.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "按下「更新匯率」按鈕",
          "expected_output": "目前美元匯率：約 32.5 TWD",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '目前美元匯率：約32.5TWD'\nGot (Norm):      '目前美元匯率：約30.66TWD'\n--- (Raw) ---\nRaw Expected: '目前美元匯率：約 32.5 TWD'\nRaw Got:      '目前美元匯率：約 30.66 TWD'"
        }
      ],
      "generated_code": "import sys\nimport requests\nimport tkinter as tk\nfrom tkinter import messagebox\n\ndef fetch_rate() -> float:\n    \"\"\"向匯率 API 發送請求並回傳美元對台幣的匯率。\"\"\"\n    try:\n        url = \"https://api.exchangerate-api.com/v4/latest/USD\"\n        resp = requests.get(url, timeout=10)\n        resp.raise_for_status()\n        data = resp.json()\n        return data[\"rates\"][\"TWD\"]\n    except Exception as e:\n        # 若發生任何錯誤，回傳 None 以供呼叫者判斷\n        return None\n\ndef start_gui() -> None:\n    \"\"\"建立並啟動 tkinter GUI。\"\"\"\n    root = tk.Tk()\n    root.title(\"美元兌台幣匯率\")\n\n    # 標籤用於顯示匯率資訊\n    label = tk.Label(root, text=\"請按下「更新」取得匯率\", font=(\"Arial\", 14))\n    label.pack(padx=20, pady=20)\n\n    def update_rate() -> None:\n        rate = fetch_rate()\n        if rate is not None:\n            label.config(text=f\"目前美元匯率：約 {rate:.2f} TWD\")\n        else:\n            messagebox.showerror(\"錯誤\", \"更新失敗，請檢查網路連線\")\n\n    # 按鈕用於觸發匯率更新\n    btn = tk.Button(root, text=\"更新\", command=update_rate, font=(\"Arial\", 12))\n    btn.pack(pady=10)\n\n    root.mainloop()\n\ndef main() -> None:\n    \"\"\"主程式入口，依據 stdin 內容決定執行 GUI 或輸出匯率。\"\"\"\n    input_data = sys.stdin.read().strip()\n\n    # 若輸入中包含「按下」或「更新」關鍵字，直接取得並列印匯率\n    if \"按下\" in input_data or \"更新\" in input_data:\n        rate = fetch_rate()\n        if rate is not None:\n            print(f\"目前美元匯率：約 {rate:.2f} TWD\")\n        else:\n            print(\"更新失敗，請檢查網路連線\")\n        return\n\n    # 其餘情況啟動 GUI\n    start_gui()\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code, step-by-step, with comments. The steps: import requests, tkinter, set up root window, define function to fetch rate, update label, button triggers fetch. Use Start, End, Decision, etc. We need each line: \"虛擬碼步驟 // 解釋\". Use arrows. For function definition maybe \"→ Step: 定義 fetch_rate()\". For making request: \"requests.get(...)\" etc. We'll produce. Let's produce about 20 lines.\n\nBe careful: use \"Decision:\" only if needed. Maybe not needed. But can include simple decision for error status.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: 匯入 requests、tkinter、tkinter.messagebox // 導入需要的模組  \n→ Step: 定義 fetch_rate() // 定義用於抓取匯率的函式  \n→ Step: response ← requests.get('https://api.exchangerate-api.com/v4/latest/USD') // 發送 GET 請求取得美元基礎匯率資料  \n→ Decision: response.status_code 等於 200? // 檢查請求是否成功  \n    Yes → Step: data ← response.json() // 解析 JSON 內容  \n    Yes → Step: rate ← data['rates']['TWD'] // 從資料中擷取 TWD 匯率  \n    Yes → Step: return f'USD → TWD: {rate:.4f}' // 回傳格式化匯率字串  \n    No  → Step: return '匯率取得失敗' // 回傳錯誤訊息  \n→ Step: root ← tk.Tk() // 建立主視窗  \n→ Step: root.title('美元兌台幣匯率') // 設定視窗標題  \n→ Step: label ← tk.Label(root, text='請點擊「更新」取得匯率', font=('Arial', 14)) // 建立顯示匯率的標籤  \n→ Step: label.pack(padx=20, pady=20) // 放置標籤於視窗中央  \n→ Step: def update_label(): // 定義更新標籤文字的函式  \n→ Step: result ← fetch_rate() // 呼叫 fetch_rate 取得最新匯率  \n→ Step: label.config(text=result) // 更新標籤文字  \n→ Step: button ← tk.Button(root, text='更新', command=update_label, font=('Arial', 12)) // 建立更新按鈕  \n→ Step: button.pack(pady=10) // 放置按鈕  \n→ Step: root.mainloop() // 啟動 tkinter 事件迴圈  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Flip Matrix",
      "source_file": "Leetcode/leetcode519.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"flip\", \"flip\", \"flip\", \"reset\", \"flip\"], [[3, 1], [], [], [], [], []]",
          "expected_output": "[null, [1,0], [2,0], [0,0], null, [2,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[1,0],[2,0],[0,0],null,[2,0]]'\nGot (Norm):      '[null,[2,0],[1,0],[0,0],null,[0,0]]'\n--- (Raw) ---\nRaw Expected: '[null, [1,0], [2,0], [0,0], null, [2,0]]'\nRaw Got:      '[null, [2, 0], [1, 0], [0, 0], null, [0, 0]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport ast\n\nclass Solution:\n    def __init__(self, m, n):\n        self.m = m\n        self.n = n\n        self.total = m * n          # remaining 0 cells\n        self.map = {}               # index mapping\n\n    def flip(self):\n        r = random.randint(0, self.total - 1)      # pick random index in remaining\n        x = self.map.get(r, r)                     # real index of the cell\n        self.total -= 1                            # one less available\n        self.map[r] = self.map.get(self.total, self.total)  # map r to last available\n        return [x // self.n, x % self.n]           # convert to 2D coordinates\n\n    def reset(self):\n        self.total = self.m * self.n\n        self.map.clear()\n\ndef split_top_level(s):\n    depth = 0\n    for i, ch in enumerate(s):\n        if ch == '[':\n            depth += 1\n        elif ch == ']':\n            depth -= 1\n        elif ch == ',' and depth == 0:\n            return s[:i].strip(), s[i+1:].strip()\n    return s, ''\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    part1, part2 = split_top_level(data)\n    ops = ast.literal_eval(part1)\n    args = ast.literal_eval(part2)\n\n    res = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            obj = Solution(arg[0], arg[1])\n            res.append(None)\n        elif op == \"flip\":\n            res.append(obj.flip())\n        elif op == \"reset\":\n            obj.reset()\n            res.append(None)\n    print(json.dumps(res))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code for the algorithm that meets requirements: randomly pick zero cell, flip to one, equal probability among zeros. Minimize calls to random, optimize time/space.\n\nClassic solution: treat matrix flattened into array of size m*n. Maintain mapping from index to value using dictionary to simulate \"reservoir\" of available indices. Keep variable remaining = m*n. On flip: pick random k in [0, remaining-1]. Map k to actual index: if mapping contains k, use mapping[k] else k. Then reduce remaining, map selected index to mapping[remaining-1] if exists else remaining-1. Then decrement remaining. This uses O(1) time per flip, O(1) random calls per flip, O(m*n) space worst-case but can use dict sized up to number of flips.\n\nreset: clear mapping and set remaining = m*n.\n\nNow produce virtual code line by line with explanations. Use arrow, decision, etc.\n\nWe need to incorporate algorithm steps. Let's design high-level steps:\n\n- Start\n- Initialize m, n, total = m*n, remaining = total, map = empty\n- flip(): if remaining == 0 error else\n  - k = random integer in [0, remaining-1]\n  - index = map.get(k, k)\n  - remaining -= 1\n  - last = map.get(remaining, remaining)\n  - map[k] = last\n  - row = index / n\n  - col = index % n\n  - return [row, col]\n- reset(): map.clear(); remaining = total\n\nWe need to produce pseudocode with arrows and decisions? Not many decisions. But we can show steps.\n\nWe must use \"虛擬碼步驟\" lines, each followed by // explanation.\n\nLet's output:\n\nStart // 程式開始執行\n→ Step 1: Initialize total ← m × n // 計算矩陣總個數\n→ Step 2: Set remaining ← total // 仍可被選中的零位數\n→ Step 3: Create empty map // 用於儲存映射關係\nEnd // 初始化結束\n\nThen flip method:\n\nStart // flip 方法開始\n→ Decision: 是否還有可選的零? // 檢查是否有剩餘可翻轉的位\n    Yes → Step 4: randIndex ← Random(0, remaining - 1) // 產生 0~remaining-1 的隨機整數\n    → Step 5: actualIndex ← map.get(randIndex, randIndex) // 取得實際矩陣索引\n    → Step 6: remaining ← remaining - 1 // 減少剩餘可選數\n    → Step 7: lastIndex ← map.get(remaining, remaining) // 取得最後可用索引\n    → Step 8: map[randIndex] ← lastIndex // 將已選索引映射到最後索引\n    → Step 9: row ← actualIndex ÷ n // 計算列\n    → Step 10: col ← actualIndex mod n // 計算行\n    → Step 11: Return [row, col] // 返回並已將此位設為 1\n    No  → Step 12: Return error // 無可選位時報錯\nEnd // flip 方法結束\n\nreset method:\n\nStart // reset 方法開始\n→ Step 13: Clear map // 清空映射表\n→ Step 14: remaining ← total // 重設剩餘可選數\nEnd // reset 方法結束\n\nBut need to output each line as \"虛擬碼步驟\" followed by // explanation. They want arrow lines and decisions.\n\nLet's craft lines like:\n\nStart // 程式開始執行\n\n→ Step 1: m ← inputM, n ← inputN // 取得矩陣尺寸\n→ Step 2: total ← m × n // 計算總格數\n→ Step 3: remaining ← total // 初始化剩餘零格數\n→ Step 4: map ← empty dict // 初始化映射表\nEnd // 初始化結束\n\nNow for flip:\n\nStart // flip 方法開始\n\n→ Decision: remaining > 0? // 是否還有可翻轉的格子\n    Yes →\n        → Step 5: r ← RandomInt(0, remaining - 1) // 隨機選擇一個位置\n        → Step 6: idx ← map.get(r, r) // 取得實際矩陣索引\n        → Step 7: remaining ← remaining - 1 // 讓剩餘數減一\n        → Step 8: last ← map.get(remaining, remaining) // 取得最後一個可選索引\n        → Step 9: map[r] ← last // 用最後索引覆蓋已選索引\n        → Step 10: row ← idx ÷ n // 轉換為行\n        → Step 11: col ← idx mod n // 轉換為列\n        → Step 12: Return [row, col] // 回傳並已把此格設為 1\n    No →\n        → Step 13: Return error // 無可選格子\nEnd // flip 方法結束\n\nreset:\n\nStart // reset 方法開始\n\n→ Step 14: map.clear() // 清空映射表\n→ Step 15: remaining ← total // 重設剩餘格數\nEnd // reset 方法結束\n\nThis meets requirements.\n\nBut maybe include function signature lines? Not necessary.\n\nWe need to ensure each line ends with // explanation.\n\nAlso arrow and decisions indentation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: m ← inputM, n ← inputN // 取得矩陣尺寸  \n→ Step 2: total ← m × n // 計算總格數  \n→ Step 3: remaining ← total // 初始化剩餘可選的零格數  \n→ Step 4: map ← empty dict // 初始化映射表，記錄已選格子對應的新索引  \nEnd // 初始化結束  \n\nStart // flip 方法開始  \n→ Decision: remaining > 0? // 檢查是否還有可翻轉的格子  \n Yes →  \n  → Step 5: r ← RandomInt(0, remaining - 1) // 隨機產生 0~remaining-1 的整數  \n  → Step 6: idx ← map.get(r, r) // 取得實際矩陣索引，若映射表中存在則使用映射值  \n  → Step 7: remaining ← remaining - 1 // 將剩餘可選格數減一  \n  → Step 8: last ← map.get(remaining, remaining) // 取得最後一個可選索引，若映射表中存在則使用映射值  \n  → Step 9: map[r] ← last // 把已選的索引映射到最後一個可選索引，確保未來不會再選到此格  \n  → Step 10: row ← idx ÷ n // 將一次性索引轉換為行座標  \n  → Step 11: col ← idx mod n // 將一次性索引轉換為列座標  \n  → Step 12: Return [row, col] // 回傳該格座標，並已將此格設為 1  \n No →  \n  → Step 13: Return error // 若沒有剩餘零格，返回錯誤或特定訊息  \nEnd // flip 方法結束  \n\nStart // reset 方法開始  \n→ Step 14: map.clear() // 清空映射表，所有格子恢復為 0  \n→ Step 15: remaining ← total // 重設剩餘可選格數為總格數  \nEnd // reset 方法結束"
    },
    {
      "title": "Min Stack",
      "source_file": "Leetcode/leetcode155.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"],[[],[-2],[0],[-3],[],[],[],[]]",
          "expected_output": "[null,null,null,null,-3,null,0,-2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpyfs4dryc.py\", line 37, in <module>\n    ops, args = json.loads(data)\n                ^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 64 (char 63)"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass MinStack:\n    def __init__(self):\n        self.stack = []\n        self.min_stack = []\n\n    def push(self, val):\n        self.stack.append(val)\n        if not self.min_stack or val <= self.min_stack[-1]:\n            self.min_stack.append(val)\n\n    def pop(self):\n        if not self.stack:\n            return\n        val = self.stack.pop()\n        if val == self.min_stack[-1]:\n            self.min_stack.pop()\n\n    def top(self):\n        if not self.stack:\n            return None\n        return self.stack[-1]\n\n    def getMin(self):\n        if not self.min_stack:\n            return None\n        return self.min_stack[-1]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 解析輸入，格式為 [operations], [arguments]\n    ops, args = json.loads(data)\n\n    result = []\n    stack_obj = None\n\n    for op, arg in zip(ops, args):\n        if op == \"MinStack\":\n            stack_obj = MinStack()\n            result.append(None)\n        elif op == \"push\":\n            stack_obj.push(arg[0])\n            result.append(None)\n        elif op == \"pop\":\n            stack_obj.pop()\n            result.append(None)\n        elif op == \"top\":\n            result.append(stack_obj.top())\n        elif op == \"getMin\":\n            result.append(stack_obj.getMin())\n\n    # 輸出結果，使用 json.dumps 讓 None 轉成 null\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to output virtual code with line-by-line steps, no real code. Need to show structure for MinStack operations. Use arrows, decisions, etc. Each line: \"虛擬碼步驟 [space] // 解釋/說明\". Use \"Start\", \"End\". Should produce algorithmic steps for initializing, push, pop, top, getMin, with O(1). We'll need to describe data structure: stack of pairs or two stacks. Use two stacks: main stack and min stack. Steps for each method. So produce pseudocode lines.\n\nLet's output:\n\nStart\n→ Step: Initialize mainStack empty // main data stack\n→ Step: Initialize minStack empty // stack keeping current mins\nEnd\n\nThen for push:\nStart push\n→ Step: Push val onto mainStack // store element\n→ Decision: If minStack empty? // no min yet\n    Yes → Step: Push val onto minStack // first element is min\n    No  → Step: Retrieve currentMin = top of minStack // current min\n           Decision: If val <= currentMin? // new min?\n                Yes → Step: Push val onto minStack // update min\n                No  → Step: Push currentMin onto minStack // keep previous min\n\nBut we can simpler: push onto minStack the min of val and top of minStack. Use decision.\n\npop:\nStart pop\n→ Step: Pop from mainStack // remove top\n→ Step: Pop from minStack // corresponding min removed\n\ntop:\nStart top\n→ Step: Return top of mainStack // top element\n\ngetMin:\nStart getMin\n→ Step: Return top of minStack // current min\n\nEnd.\n\nLet's output each line accordingly.\n\nNeed to include \"End\" after each function? maybe after each function block, but not necessary. We'll just include End at the end of overall class.\n\nWe'll produce the virtual code for each method sequentially. Use Start at class initialization. Then each method. End at the end of class.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n\n→ Step: 建立空主堆疊 mainStack // 用於儲存所有元素\n→ Step: 建立空最小堆疊 minStack   // 用於同步儲存目前最小值\n\n// ------------------- Push 操作 -------------------\nStart push // 開始執行 push 方法\n→ Step: 將 val 推進 mainStack // 把新值放入主堆疊\n→ Decision: minStack 是否為空? // 判斷是否已存在最小值\n    Yes → Step: 將 val 推進 minStack // 首個元素本身即為最小值\n    No  → Step: 取得 currentMin = minStack.top() // 取得目前最小值\n          → Decision: val <= currentMin? // 新值是否小於等於目前最小\n                Yes → Step: 將 val 推進 minStack // 新值成為新的最小值\n                No  → Step: 將 currentMin 推進 minStack // 保留舊的最小值\n\nEnd // push 方法結束\n\n// ------------------- Pop 操作 -------------------\nStart pop // 開始執行 pop 方法\n→ Step: 從 mainStack 彈出 top 元素 // 移除主堆疊頂端\n→ Step: 從 minStack 彈出 top 元素   // 同步移除最小堆疊頂端\nEnd // pop 方法結束\n\n// ------------------- Top 操作 -------------------\nStart top // 開始執行 top 方法\n→ Step: 回傳 mainStack.top() // 取得主堆疊頂端元素\nEnd // top 方法結束\n\n// ------------------- GetMin 操作 -------------------\nStart getMin // 開始執行 getMin 方法\n→ Step: 回傳 minStack.top() // 取得目前最小值\nEnd // getMin 方法結束\n\nEnd // 程式執行結束"
    },
    {
      "title": "Combination Sum II",
      "source_file": "Leetcode/leetcode40.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "candidates = [10,1,2,7,6,1,5], target = 8",
          "expected_output": "[[1,1,6],[1,2,5],[1,7],[2,6]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp0bcnsi6m.py\", line 34, in <module>\n    target_part = parts[1].split('=')[1].strip()\n                  ~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        },
        {
          "example_index": 1,
          "input": "candidates = [2,5,2,1,2], target = 5",
          "expected_output": "[[1,2,2],[5]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpgq0a79im.py\", line 34, in <module>\n    target_part = parts[1].split('=')[1].strip()\n                  ~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\n\nclass Solution:\n    def combinationSum2(self, candidates, target):\n        candidates.sort()\n        res = []\n\n        def backtrack(start, path, total):\n            if total == target:\n                res.append(list(path))\n                return\n            if total > target:\n                return\n            prev = -1\n            for i in range(start, len(candidates)):\n                if candidates[i] == prev:\n                    continue\n                path.append(candidates[i])\n                backtrack(i + 1, path, total + candidates[i])\n                path.pop()\n                prev = candidates[i]\n\n        backtrack(0, [], 0)\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    parts = data.split(',')\n    candidates_part = parts[0].split('=')[1].strip()\n    target_part = parts[1].split('=')[1].strip()\n    candidates = ast.literal_eval(candidates_part)\n    target = int(target_part)\n    solution = Solution()\n    result = solution.combinationSum2(candidates, target)\n    print(json.dumps(result, separators=(',', ':')))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line, with arrow syntax, start, decision, etc. The problem: \"Combination Sum II\" typical backtracking. We must produce virtual code, no real code, just pseudo steps.\n\nWe need to follow output format: each line: \"虛擬碼步驟 [space] // 解釋\". Use arrows \"→\" and \"Yes →\" \"No →\". Use Start and End.\n\nNeed to incorporate sorting to avoid duplicates. Use backtracking recursion. Need decision points: whether to include candidate, skip duplicates.\n\nWe'll produce steps like:\n\nStart // program start\n→ Step 1: Sort candidates ascending // to handle duplicates\n→ Step 2: Define backtrack(startIndex, remaining, path) // recursive function\n→ Decision: If remaining == 0? // found combination\n    Yes → Step 3: Add copy of path to result // store combination\n    No  → Decision: If startIndex == len(candidates)? // no more candidates\n        Yes → Step 4: Return // end recursion\n        No  → Step 5: For i from startIndex to len(candidates)-1\n            → Decision: If i > startIndex and candidates[i] == candidates[i-1]? // skip duplicate\n                Yes → Continue // skip to next i\n                No  → Decision: If candidates[i] > remaining? // early break\n                    Yes → Step 6: Break // no need to proceed further\n                    No  → Step 7: Append candidates[i] to path // include current\n                    → Step 8: Call backtrack(i+1, remaining - candidates[i], path) // recursion\n                    → Step 9: Remove last from path // backtrack\n→ Step 10: Call backtrack(0, target, []) // start\n→ Step 11: Return result // final combinations\n\nNeed to format each line with arrow and explanation.\n\nWe must use \"→\" preceding each step. \"Yes →\" or \"No →\" for decisions. Start and End lines. Also each line must have \"虛擬碼步驟\" like \"Start\", \"→ Step 1: ...\", etc.\n\nAlso note that the lines should have space after the virtual code before comment.\n\nWe must be careful with indentation? They didn't specify indentation but we can use indent for sub-steps like Decision: if. But each line is separate.\n\nWe can show nested structure by using indentation or simply include \"Decision:\" lines, then Yes/No arrows on next line? In the example, they used indentation for sub-steps. Let's replicate: For each Decision, we indent sub-steps under it. Use spaces maybe. Let's follow example: Indentation of 4 spaces? Example used 4 spaces before sub-lines. They used `→ Decision: ...` then indent with 4 spaces then `Yes → ...` etc. So we should follow same.\n\nThus we produce lines:\n\nStart // 程式開始執行\n→ Step 1: Sort candidates ascending // 對候選數字進行排序以便後續跳過重複項\n→ Step 2: 定義 backtrack(startIndex, remaining, path) // 進行遞迴回溯\n→ Decision: remaining == 0? // 是否已找到一組符合目標的組合\n    Yes → Step 3: 把 path 的複本加入結果集 // 存儲合法組合\n    No  → Decision: startIndex == len(candidates)? // 是否已到達候選數字末尾\n        Yes → Step 4: Return // 結束此遞迴分支\n        No  → Step 5: 對 i 從 startIndex 到 len(candidates)-1 進行迭代 // 遍歷候選數字\n            → Decision: i > startIndex 且 candidates[i] == candidates[i-1]? // 跳過重複的候選數字\n                Yes → Continue // 跳過此 i\n                No  → Decision: candidates[i] > remaining? // 超過剩餘值可提前停止\n                    Yes → Step 6: Break // 結束循環\n                    No  → Step 7: Append candidates[i] to path // 包含此候選數字\n                    → Step 8: backtrack(i+1, remaining - candidates[i], path) // 進行下一層遞迴\n                    → Step 9: Remove last from path // 回溯，移除已加入的候選數字\n→ Step 10: backtrack(0, target, []) // 開始回溯\n→ Step 11: Return result // 回傳所有符合條件的組合\nEnd // 程式執行結束\n\nNeed to ensure each line ends with comment. And each step must start with \"→\" except Start and End. Use arrow for decision lines as \"→ Decision:\" and for Yes/No lines: \"    Yes →\". Use 4 spaces indent. Provide comments in Chinese. Ensure no real code; just pseudo steps.\n\nAlso ensure each line has one space after the code before comment. For decisions: \"Decision:\" line has arrow then space then comment. For sub-steps, we indent with spaces then Yes/No arrow then space then comment. Provide proper explanation. Let's craft final output accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Sort candidates ascending // 對候選數字進行排序以便後續跳過重複項\n→ Step 2: Define backtrack(startIndex, remaining, path) // 進行遞迴回溯\n→ Decision: remaining == 0? // 是否已找到一組符合目標的組合\n    Yes → Step 3: Add copy of path to result // 存儲合法組合\n    No  → Decision: startIndex == len(candidates)? // 是否已到達候選數字末尾\n        Yes → Step 4: Return // 結束此遞迴分支\n        No  → Step 5: For i from startIndex to len(candidates)-1 // 遍歷候選數字\n            → Decision: i > startIndex 且 candidates[i] == candidates[i-1]? // 跳過重複的候選數字\n                Yes → Continue // 跳過此 i\n                No  → Decision: candidates[i] > remaining? // 超過剩餘值可提前停止\n                    Yes → Step 6: Break // 結束循環\n                    No  → Step 7: Append candidates[i] to path // 包含此候選數字\n                    → Step 8: backtrack(i+1, remaining - candidates[i], path) // 進行下一層遞迴\n                    → Step 9: Remove last from path // 回溯，移除已加入的候選數字\n→ Step 10: backtrack(0, target, []) // 開始回溯\n→ Step 11: Return result // 回傳所有符合條件的組合\nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick Index",
      "source_file": "Leetcode/leetcode398.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\"], [[[1, 2, 3, 3, 3]], [3], [1], [3]]",
          "expected_output": "[null, 4, 0, 2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,4,0,2]'\nGot (Norm):      '[None,4,0,3]'\n--- (Raw) ---\nRaw Expected: '[null, 4, 0, 2]'\nRaw Got:      '[None, 4, 0, 3]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\nfrom collections import defaultdict\n\nclass Solution:\n    def __init__(self, nums):\n        # 建立從目標值到所有索引的映射\n        self.num_indices = defaultdict(list)\n        for i, num in enumerate(nums):\n            self.num_indices[num].append(i)\n\n    def pick(self, target):\n        # 隨機選擇 target 對應索引列表中的一個\n        return random.choice(self.num_indices[target])\n\nif __name__ == \"__main__\":\n    # 從 stdin 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n\n    # 將輸入格式轉換為可解析的 Python 物件\n    # 原始輸入形如 '[\"Solution\", \"pick\", ...], [[[1,2]], ...]'\n    # 在兩個列表之間加上圓括號，讓 ast.literal_eval 解析為元組\n    data = f'({raw_input})'\n    commands, args = ast.literal_eval(data)\n\n    # 執行命令並收集結果\n    result = []\n    sol = None\n    for cmd, arg in zip(commands, args):\n        if cmd == \"Solution\":\n            sol = Solution(arg[0])  # arg 為 [[1,2,3,...]]\n            result.append(None)     # 建構子返回 null\n        elif cmd == \"pick\":\n            res = sol.pick(arg[0])  # arg 為 [target]\n            result.append(res)\n        else:\n            # 若有其他未知命令，可忽略或拋出錯誤\n            result.append(None)\n\n    # 輸出結果列表\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code, line by line, with explanation. For a typical algorithm: preprocess mapping from target to list of indices. Then pick random index from list.\n\nSo steps: Start, initialize Solution: store nums, build map. For pick: get list, random index. We'll produce virtual pseudocode with arrows.\n\nLet's write:\n\nStart // 程式開始\n\n→ Step 1: 在建構子中接收陣列 nums // store original\n\n→ Step 2: 建立字典 target_to_indices // map each value to list of indices\n\n→ Decision: 遍歷 nums 逐個索引 i // for each element\n\n    → Step 3: target_to_indices[nums[i]] 加入 i // append index\n\nEnd // 建構完成\n\nThen pick method:\n\nStart // pick 方法開始\n\n→ Step 1: 取得 target 對應的索引清單 indices = target_to_indices[target] // 找到所有索引\n\n→ Step 2: 隨機選擇 0 到 indices.size()-1 之間的隨機數 rand_index // 隨機位置\n\n→ Step 3: 回傳 indices[rand_index] // 返回選定索引\n\nEnd // pick 方法結束\n\nWe should format lines with arrow arrows.\n\nAlso maybe include function definition lines.\n\nLet's structure:\n\nStart // 程式開始\n→ Function: Solution(nums) // 建構子\n    → Step 1: this.nums = nums\n    → Step 2: this.map = new Map()\n    → Decision: For i = 0 to nums.length-1\n        → Step 3: val = nums[i]\n        → Decision: map contains val?\n            Yes → map.get(val).append(i)\n            No  → map.set(val, [i])\n→ End // 建構子結束\n\n→ Function: pick(target) // 選取隨機索引\n    → Step 1: indices = map.get(target)\n    → Step 2: randomIdx = randomInt(0, indices.length-1)\n    → Step 3: return indices[randomIdx]\n→ End // pick 方法結束\n\nEnd // 程式結束\n\nBut they want Start and End tokens at beginning and end of algorithm, not per function. But can have sub-block. Let's keep simple.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始\n\n→ Function: Solution(nums) // 建構子，接受陣列\n    → Step 1: this.nums = nums // 保存原始陣列\n    → Step 2: this.map = new Map() // 建立值到索引列表的映射\n    → Decision: 遍歷陣列索引 i 從 0 到 nums.length-1\n        → Step 3: val = nums[i] // 取得當前元素\n        → Decision: map 內是否已存在 val?\n            Yes → map.get(val).append(i) // 若存在，將索引追加到列表\n            No  → map.set(val, [i]) // 若不存在，建立新列表並加入索引\n\n→ End // 建構子結束\n\n→ Function: pick(target) // 隨機選取目標值的索引\n    → Step 1: indices = this.map.get(target) // 取得所有符合的索引列表\n    → Step 2: randomIdx = randomInt(0, indices.length-1) // 隨機選取列表位置\n    → Step 3: return indices[randomIdx] // 返回選定的索引\n\n→ End // pick 方法結束\n\nEnd // 程式結束"
    },
    {
      "title": "Sort Characters By Frequency",
      "source_file": "Leetcode/leetcode451.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"tree\"",
          "expected_output": "\"eert\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'eert'\nGot (Norm):      'eetr'\n--- (Raw) ---\nRaw Expected: '\"eert\"'\nRaw Got:      'eetr'"
        },
        {
          "example_index": 1,
          "input": "s = \"cccaaa\"",
          "expected_output": "\"aaaccc\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'aaaccc'\nGot (Norm):      'cccaaa'\n--- (Raw) ---\nRaw Expected: '\"aaaccc\"'\nRaw Got:      'cccaaa'"
        }
      ],
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\nclass Solution:\n    def frequencySort(self, s: str) -> str:\n        \"\"\"\n        Sort characters in `s` by decreasing frequency.\n        \"\"\"\n        # Count frequency of each character\n        freq = Counter(s)\n        # most_common() returns list of (char, count) sorted by count desc\n        return ''.join(char * count for char, count in freq.most_common())\n\nif __name__ == \"__main__\":\n    # Read entire input from stdin\n    raw_input = sys.stdin.read()\n\n    # Extract the string inside double quotes following \"s = \"\n    match = re.search(r's\\s*=\\s*\"(.*)\"', raw_input)\n    if match:\n        s = match.group(1)\n    else:\n        # Fallback: strip spaces and quotes if the whole input is the string\n        s = raw_input.strip()\n        if s.startswith('\"') and s.endswith('\"'):\n            s = s[1:-1]\n\n    sol = Solution()\n    result = sol.frequencySort(s)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code, line by line, with explanation, using virtual arrows. The problem: sort string by decreasing frequency. Implementation steps: Count frequencies using map; create array of char-freq pairs; sort by freq descending; build result string by repeating char freq times. Provide pseudo-code.\n\nWe need to follow format: each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision: etc.\n\nWe need to produce lines like:\n\nStart // 程式開始執行\n→ Step 1: 初始化頻率字典 freqMap = empty // 用於存儲字符頻率\n→ Step 2: 遍歷字符串 s，對每個字符 c 增加 freqMap[c] // 統計頻率\n→ Decision: 是否完成遍歷？ // 確保已統計所有字符\n    Yes → Step 3: 將 freqMap 轉換為列表 freqList = [(c, count) ...] // 方便排序\n→ Step 4: 使用排序算法對 freqList 按 count 降序排列 // 根據頻率降序\n→ Step 5: 建立結果字符串 result = \"\" // 用於累積輸出\n→ Step 6: 遍歷 freqList，對於每個 (c, count) 重複追加 c count 次到 result // 按頻率重建字符串\n→ Step 7: 回傳 result // 最終結果\nEnd // 程式結束\n\nBut we must include arrows: Start, End, Decision. Should we use \"Decision:\" lines with Yes →? Yes.\n\nAlso note that we should use \"Step X:\" labels, maybe \"Step 1:\" etc. Or maybe \"Step 1:\"? The format example shows \"Step 1: 輸入使用者數字\". So follow that.\n\nWe need to produce \"Start // 程式開始執行\".\n\nLet's produce full.\n\nAlso might need to mention \"→\" arrow before each step. Example: \"→ Step 1: ...\" After Decision, \"Yes → Step 2: ...\" etc.\n\nSo final answer: each line of virtual code.\n\nWe can optionally add more detail: like \"Initialize empty hash map\". Provide explanation.\n\nLet's write.\n\nAlso mention \"End // 程式執行結束\".\n\nWe should keep each line short but clear.\n\nNow produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: freqMap ← empty dictionary // 用於記錄每個字符的頻率  \n→ Step 2: for each char c in s  \n  freqMap[c] ← freqMap[c] + 1 // 對每個字符進行統計  \n→ Decision: 是否已遍歷完 s？ // 確認所有字符已被計數  \n Yes → Step 3: freqList ← list of (char, count) pairs from freqMap // 方便後續排序  \n→ Step 4: sort freqList by count in descending order // 依頻率降序排列  \n→ Step 5: result ← empty string // 準備拼接結果  \n→ Step 6: for each (c, count) in freqList  \n  result ← result + repeat(c, count) // 依頻率重複添加字符  \n→ Step 7: return result // 回傳排序後的字串  \nEnd // 程式執行結束"
    },
    {
      "title": "Palindrome Pairs",
      "source_file": "Leetcode/leetcode336.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "words = [\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]",
          "expected_output": "[[0,1],[1,0],[3,2],[2,4]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0],[3,2],[2,4]]'\nGot (Norm):      '[[3,2]]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0],[3,2],[2,4]]'\nRaw Got:      '[[3, 2]]'"
        },
        {
          "example_index": 1,
          "input": "words = [\"bat\",\"tab\",\"cat\"]",
          "expected_output": "[[0,1],[1,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0]]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0]]'\nRaw Got:      '[]'"
        },
        {
          "example_index": 2,
          "input": "words = [\"a\",\"\"]",
          "expected_output": "[[0,1],[1,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0]]'\nGot (Norm):      '[[0,1]]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0]]'\nRaw Got:      '[[0, 1]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\ndef is_palindrome(s: str) -> bool:\n    \"\"\"Check if a string is a palindrome.\"\"\"\n    return s == s[::-1]\n\nclass Solution:\n    def palindromePairs(self, words):\n        \"\"\"\n        Find all palindrome pairs in the list of unique words.\n        \"\"\"\n        # Map each word to its index for O(1) lookup\n        word_to_index = {word: i for i, word in enumerate(words)}\n        result = []\n\n        # For each word, try every split position\n        for i, word in enumerate(words):\n            n = len(word)\n            for j in range(n + 1):\n                prefix, suffix = word[:j], word[j:]\n\n                # If prefix is a word and suffix is a palindrome\n                if prefix in word_to_index:\n                    k = word_to_index[prefix]\n                    if k != i and is_palindrome(suffix):\n                        result.append([i, k])\n\n                # If suffix is a word and prefix is a palindrome\n                # Avoid double counting when j == n (empty suffix)\n                if j != n and suffix in word_to_index:\n                    k = word_to_index[suffix]\n                    if k != i and is_palindrome(prefix):\n                        result.append([k, i])\n\n        return result\n\ndef parse_input(input_str: str):\n    \"\"\"\n    Parse the input string which is expected to be like:\n    words = [\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]\n    \"\"\"\n    input_str = input_str.strip()\n    if not input_str:\n        return []\n    # Find the first '=' and evaluate the expression after it\n    if '=' in input_str:\n        _, expr = input_str.split('=', 1)\n    else:\n        expr = input_str\n    return ast.literal_eval(expr.strip())\n\nif __name__ == \"__main__\":\n    # Read all input from stdin\n    raw_input = sys.stdin.read()\n    words = parse_input(raw_input)\n\n    sol = Solution()\n    pairs = sol.palindromePairs(words)\n\n    # Print the result in the required format\n    print(pairs)",
      "virtual_code": "Thinking...\nWe need to produce pseudocode for solving the palindrome pairs problem with O(total length) runtime. Use typical algorithm: use Trie, reverse words, check prefixes, suffixes. Outline steps: build trie of reversed words, then for each word, check splits, use dictionary of word->index.\n\nWe need to output line-by-line pseudocode with explanation.\n\nLet's produce pseudocode:\n\nStart\n→ Build a map indexMap: word → index\n→ Build a Trie of reversed words\n    For each word with index i:\n        Insert reversed word into Trie, storing index i at end node\n→ Initialize result list\n→ For each word with index i:\n    For split position from 0 to len(word):\n        prefix = word[0:split]\n        suffix = word[split:]\n        // If prefix is palindrome:\n        if isPalindrome(prefix):\n            // find index j such that reversed suffix exists in map\n            j = indexMap.get(suffix)\n            if j != null and j != i:\n                add (j, i) to result\n        // If split not at end and suffix is palindrome:\n        if split != len(word) and isPalindrome(suffix):\n            j = indexMap.get(prefix)\n            if j != null and j != i:\n                add (i, j) to result\n→ End\n\nBut runtime must be O(total length). The loops: For each word length L, we iterate splits L+1, checking palindrome which can be done O(L) naive, leading to O(L^2). We need efficient palindrome checks: precompute palindrome prefixes for each word? Standard solution: while iterating splits, we can check palindrome by comparing characters incrementally. But the typical algorithm still O(n^2). However given unique words, the O(total length) is possible via Trie search: For each word, search prefixes via trie and check palindrome during traversal.\n\nSimplify: Use Trie and for each word, traverse trie, checking if current node has index, and if remaining suffix is palindrome. And also check if word is palindrome and there's an empty string.\n\nWe'll produce pseudocode accordingly.\n\nLet's outline:\n\nStart\n→ Build map word→index\n→ Build Trie of reversed words (each node has child dict, endIndex)\n→ For each word index i:\n    // 1. Find pairs where suffix is palindrome\n    node = root\n    for pos in 0..len(word)-1:\n        // If node has endIndex != -1 and endIndex != i and remaining part of word (from pos) is palindrome\n        if node.endIndex != -1 and node.endIndex != i and isPalindrome(word[pos:]):\n            add (i, node.endIndex)\n        node = node.child[word[pos]]\n        if node == null: break\n    // 2. After full traversal, if node has endIndex != -1 and endIndex != i:\n        add (i, node.endIndex)\n    // 3. Find pairs where prefix is palindrome via reverse traversal\n    node = root\n    rev = reverse(word)\n    for pos in 0..len(rev)-1:\n        if node.endIndex != -1 and node.endIndex != i and isPalindrome(rev[pos:]):\n            add (node.endIndex, i)\n        node = node.child[rev[pos]]\n        if node == null: break\n→ End\n\nBut we also need to check empty string case.\n\nWill produce pseudocode accordingly.\n\nLet's write line-by-line.\n\nWe'll use Decision nodes, etc.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行\n\n→ Decision: 建立字典 wordToIndex 及 Trie? // 準備資料結構\n    Yes → Step 1: 建立 map wordToIndex: word → index // 方便快速查找索引\n    Yes → Step 2: 建立 Trie 樹 (root) 並為每個字元建立子節點 // 用於倒序搜尋\n\n→ Decision: 對每個 word (index i) 插入 Trie? // 構造 Trie\n    Yes → For each word w, index i:\n        → Step 3: node ← root\n        → Step 4: 迴圈 j 從 0 到 len(w)-1:\n            → Step 5: char ← w[len(w)-1-j] // 取倒序字元\n            → Step 6: If node.child[char] 不存在, 創建新節點\n            → Step 7: node ← node.child[char] // 移動到子節點\n        → Decision: node.endIndex 是否已設定? // 防止重複\n            Yes → Step 8: 如果 node.endIndex 為 -1, 設為 i\n            No  → Step 8: 設為 i // 記錄此倒序字串的終點索引\n\n→ Step 9: 初始化結果列表 result = []\n\n→ Decision: 對每個 word (index i) 搜尋可能的對? // 主要搜尋過程\n    Yes → For each word w, index i:\n        // 1️⃣ 搜尋「後綴為回文」的對\n        → Step 10: node ← root\n        → Step 11: For pos 從 0 到 len(w)-1:\n            → Decision: node.endIndex != -1 且 node.endIndex != i 且 w[pos:] 為回文? // 檢查剩餘子串是否回文\n                Yes → Step 12: 加入 (i, node.endIndex) 到 result // w + words[node.endIndex] 為回文\n                No  →\n            → Step 13: char ← w[pos]\n            → Decision: node.child[char] 存在? \n                Yes → node ← node.child[char]\n                No  → Break  // 無法繼續\n        → Decision: node.endIndex != -1 且 node.endIndex != i? // 完全匹配後還能成立\n            Yes → Step 14: 加入 (i, node.endIndex) 到 result\n            No  →\n\n        // 2️⃣ 搜尋「前綴為回文」的對 (使用倒序 Trie)\n        → Step 15: node ← root\n        → Step 16: rev ← reverse(w)\n        → Step 17: For pos 從 0 到 len(rev)-1:\n            → Decision: node.endIndex != -1 且 node.endIndex != i 且 rev[pos:] 為回文? // 檢查剩餘子串是否回文\n                Yes → Step 18: 加入 (node.endIndex, i) 到 result // words[node.endIndex] + w 為回文\n                No  →\n            → Step 19: char ← rev[pos]\n            → Decision: node.child[char] 存在? \n                Yes → node ← node.child[char]\n                No  → Break\n\n→ End // 程式執行結束，返回 result\n\n// 補充說明：isPalindrome(sub) 可在 O(sub.length) 內逐字檢查，且每個子串僅被檢查一次，整體時間為 O(∑|words[i]|)。"
    },
    {
      "title": "Lexicographical Numbers",
      "source_file": "Leetcode/leetcode386.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 13",
          "expected_output": "[1,10,11,12,13,2,3,4,5,6,7,8,9]",
          "actual_output_or_error": "[Validation Error] Code execution timed out (10s)."
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[1,2]",
          "actual_output_or_error": "[Validation Error] Code execution timed out (10s)."
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef lexical_order(n: int):\n    \"\"\"Return numbers from 1 to n in lexicographical order.\"\"\"\n    result = []\n    cur = 1\n    while cur <= n:\n        result.append(cur)\n        if cur * 10 <= n:           # go deeper to the next child\n            cur *= 10\n        else:                       # no child, need to backtrack\n            while cur % 10 == 9 or cur >= n:\n                cur //= 10           # move up to parent\n            cur += 1                 # move to next sibling\n    return result\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    match = re.search(r\"\\d+\", data)\n    if not match:\n        sys.exit(\"No integer found in input.\")\n    n = int(match.group())\n    ans = lexical_order(n)\n    print(ans)",
      "virtual_code": "Thinking...\nWe need to output virtual code steps for generating lexicographic order numbers from 1 to n in O(n) time and O(1) space. Classic problem: DFS traversal on a virtual tree. Steps: Start, iterate cur=1 to n; produce cur, then attempt cur*10; else while cur%10==9 or cur>=n, cur/=10; cur++.\n\nWe must output each line with virtual code and comment. Use Start, End, Decision etc. Provide O(1) space. The algorithm: for i in 1..n produce lex order. Use while cur <= n loop. Steps: Start. → Step 1: cur = 1 // initialize. → Loop: Decision: cur <= n? Yes → Step 2: output cur. → Decision: cur*10 <= n? Yes → Step 3: cur = cur*10 // go deeper. No → Decision: cur%10 == 9 or cur >= n? Yes → Step 4: cur = cur/10 // backtrack. → Step 5: cur = cur + 1 // next sibling. Then loop again. End.\n\nBut need each step with comment. Provide arrow and indentation. Also maybe include nested decisions. Provide O(1) space: only cur variable. Let's produce lines:\n\nStart // 程式開始執行\n→ Step 1: cur = 1 // 初始化目前指向的數字\n→ Decision: cur <= n? // 是否還在 1~n 範圍內\n    Yes → Step 2: output cur // 輸出目前數字\n    Yes → Decision: cur*10 <= n? // 嘗試往子節點深度優先\n        Yes → Step 3: cur = cur*10 // 進入下層第一個子節點\n        No → Decision: cur % 10 == 9 OR cur >= n? // 若無子節點，需回溯\n            Yes → Step 4: cur = cur / 10 // 回溯到上一層\n            No  → Step 5: cur = cur + 1 // 移動到同層下一個兄弟節點\n        No → Step 5: cur = cur + 1 // 移動到同層下一個兄弟節點\n    No → End // 超出範圍，結束\nEnd // 程式結束\n\nBut need to ensure each line unique. Maybe flatten. Provide explicit indentation. Use arrow lines. Let's produce.\n\nMake sure to use '→' before each step, 'Decision:' for condition. Provide spaces after arrow.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: cur = 1 // 初始化目前指向的數字  \n→ Decision: cur <= n? // 檢查是否仍在 1~n 範圍內  \n    Yes → Step 2: output cur // 輸出目前數字  \n    Yes → Decision: cur * 10 <= n? // 嘗試進入下一層的第一個子節點  \n        Yes → Step 3: cur = cur * 10 // 進入子節點，深度優先  \n        No  → Decision: cur % 10 == 9 OR cur >= n? // 若無子節點或已到尾，須回溯  \n            Yes → Step 4: cur = cur / 10 // 回到上一層節點  \n            No  → Step 5: cur = cur + 1 // 前往同層下一個兄弟節點  \n        No  → Step 5: cur = cur + 1 // 若直接沒有子節點，前往兄弟節點  \n    No → End // 超過 n，結束輸出  \nEnd // 程式執行結束"
    },
    {
      "title": "Coin Change II",
      "source_file": "Leetcode/leetcode518.json",
      "problem_index_in_file": 0,
      "generation_error": "Failed to extract code from model response.",
      "failed_validation_details": [
        {
          "example_index": -1,
          "input": null,
          "expected_output": null,
          "actual_output_or_error": "Thinking...\nWe need to produce a Python code with main block reading from stdin. Input format: It says '5, [1,2,5]'. That looks like a string: \"5, [1,2,5]\". That is not typical; but we can parse it. We need to read entire stdin and split on comma? Might contain newline? Let's design robust: read all input, strip. Input maybe like \"5, [1,2,5]\". We can parse by splitting at first comma: amount_str, coins_str = data.split(',', 1). Then convert amount to int, and coins_str to list via ast.literal_eval. Or we can parse manually. Use import ast"
        }
      ],
      "generated_code": null,
      "virtual_code": "Thinking...\nWe need to produce virtual code for coin change combinations, dynamic programming. Use 1D DP: dp[0]=1, for each coin, for amount from coin to target: dp[amount] += dp[amount-coin]. Output dp[amount].\n\nWe need to output line by line with \"虛擬碼步驟 // 解釋\". Use Start, End, Decision if needed.\n\nLet's produce:\n\nStart // 開始\n→ Step 1: 輸入 coins, amount // 取得硬幣面額及目標金額\n→ Step 2: 建立 dp 陣列長度 amount+1 且全 0 // 用來儲存組合數\n→ Step 3: 設定 dp[0] = 1 // 零金額只有一種組合：不使用硬幣\n→ Decision: 迴圈遍歷每個 coin? // 準備依硬幣逐一處理\n    → Step 4: For each coin in coins:\n        → Decision: 迴圈遍歷 j 從 coin 到 amount? // 更新 dp\n            → Step 5: For j = coin to amount:\n                → Step 6: dp[j] += dp[j - coin] // 加入使用該硬幣的組合\nEnd // 完成\n→ Step 7: 回傳 dp[amount] // 結果\n\nBut we need arrow syntax: \"→ Step 1: ...\" etc.\n\nLet's format:\n\nStart // 程式開始\n→ Step 1: 取得 coins 及 amount // 讀取輸入\n→ Step 2: 建立 dp 陣列長度 amount+1 並初始化為 0 // 用於存儲組合數\n→ Step 3: dp[0] = 1 // 零金額只有一種組合\n→ Decision: 迭代每個 coin? // 開始處理硬幣\n    Yes → Step 4: for coin in coins:\n        → Decision: 迭代 j 從 coin 到 amount? // 更新 dp\n            Yes → Step 5: for j = coin to amount:\n                → Step 6: dp[j] = dp[j] + dp[j - coin] // 加上使用該硬幣的組合數\n    No → // 無硬幣\nEnd // 完成\n→ Step 7: 回傳 dp[amount] // 結果\n\nBut we need to use arrow \"→\" and indentation maybe. Use spaces? We can mimic example.\n\nWe also need to include [空格] between step and explanation. So each line: \"→ Step 1: ... // ...\".\n\nUse \"Decision:\" lines with Yes → and No → indent.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始\n→ Step 1: 取得 coins 及 amount // 讀取輸入\n→ Step 2: 建立 dp 陣列長度 amount+1 並初始化為 0 // 用於存儲組合數\n→ Step 3: dp[0] = 1 // 零金額只有一種組合\n→ Decision: 迭代每個 coin? // 開始處理硬幣\n    Yes → Step 4: for coin in coins:\n        → Decision: 迭代 j 從 coin 到 amount? // 更新 dp\n            Yes → Step 5: for j = coin to amount:\n                → Step 6: dp[j] = dp[j] + dp[j - coin] // 加上使用該硬幣的組合數\n    No → // 無硬幣可用\nEnd // 完成\n→ Step 7: 回傳 dp[amount] // 輸出最終組合數"
    },
    {
      "title": "Longest Uncommon Subsequence II",
      "source_file": "Leetcode/leetcode522.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"aaa\",\"aaa\",\"aa\"]",
          "expected_output": "-1",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '-1'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: '-1'\nRaw Got:      '2'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\ndef find_lus_length(strs):\n    \"\"\"Return length of the longest uncommon subsequence.\"\"\"\n    freq = {}\n    for s in strs:\n        freq[s] = freq.get(s, 0) + 1\n    for s in strs:\n        if freq[s] == 1:\n            return len(s)\n    return -1\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    try:\n        strs = ast.literal_eval(data)\n    except Exception:\n        strs = data.split()\n    print(find_lus_length(strs))",
      "virtual_code": "Thinking...\nWe need to produce virtual code for problem: longest uncommon subsequence. The known solution: If any string is unique, answer is its length. Else -1. Approach: Count frequency of each string. For each string, if freq==1 return length. else -1. Because if no unique string, no uncommon subsequence exists.\n\nWe need to produce virtual code step by step, using arrow syntax.\n\nWe should include Start, Step 1: input array, Step 2: build frequency map, Step 3: iterate, Decision: if freq==1? Yes -> return len, No -> continue. After loop, return -1. End.\n\nWe need to include explanation after each line.\n\nMake sure to follow format: each line: virtual step + space + // explanation. Use arrows as specified. Use 'Start' and 'End'. Use 'Decision:' lines.\n\nLet's craft.\n\nExample lines:\n\nStart // 程式開始執行\n→ Step 1: 接收輸入陣列 strs // 取得使用者提供的字串陣列\n→ Step 2: 建立字典 freq 為空 // 用於計算每個字串出現次數\n→ Step 3: 對每個字串 s in strs 做\n    → Decision: s 是否已在 freq? // 判斷字串是否已統計\n        Yes → freq[s] = freq[s] + 1 // 已存在則次數加一\n        No  → freq[s] = 1 // 新字串則初始化為 1\n→ Step 4: 對每個字串 s in strs 做\n    → Decision: freq[s] == 1? // 檢查字串是否唯一\n        Yes → Return len(s) // 若唯一則其長度即為最大不常見子序列長度\n        No  → Continue // 否則檢查下一個字串\n→ Step 5: Return -1 // 所有字串均不唯一，無不常見子序列\nEnd // 程式執行結束\n\nWe need to keep arrow formatting. For loops, we may use Step 3: For each s in strs // Build freq. But we cannot use code, just virtual steps. We can incorporate loops inside.\n\nBetter:\n\nStep 3: 對每個字串 s in strs 迴圈 // 建立頻率表\n    → Decision: freq 中是否已包含 s? // 判斷字串是否已出現\n        Yes → freq[s] = freq[s] + 1 // 次數加一\n        No  → freq[s] = 1 // 新字串初始化\n\nStep 4: 對每個字串 s in strs 迴圈 // 搜尋唯一字串\n    → Decision: freq[s] == 1? // 是否唯一\n        Yes → Return len(s) // 找到最大長度\n        No  → Continue\n\nStep 5: Return -1 // 沒有唯一字串\n\nOk.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 接收輸入陣列 strs // 取得使用者提供的字串陣列  \n→ Step 2: 建立字典 freq 為空 // 用於計算每個字串出現次數  \n\n→ Step 3: 對每個字串 s in strs 迴圈 // 建立頻率表  \n  → Decision: freq 中是否已包含 s? // 判斷字串是否已出現  \n   Yes → freq[s] = freq[s] + 1 // 次數加一  \n   No  → freq[s] = 1 // 新字串初始化  \n\n→ Step 4: 對每個字串 s in strs 迴圈 // 搜尋唯一字串  \n  → Decision: freq[s] == 1? // 是否唯一  \n   Yes → Return len(s) // 找到最大長度  \n   No  → Continue // 檢查下一個字串  \n\n→ Step 5: Return -1 // 沒有唯一字串  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Repeated DNA Sequences",
      "source_file": "Leetcode/leetcode187.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = 'AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT'",
          "expected_output": "[\"AAAAACCCCC\",\"CCCCCAAAAA\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"AAAAACCCCC\",\"CCCCCAAAAA\"]'\nGot (Norm):      '[\"CCCCCAAAAA\",\"AAAAACCCCC\"]'\n--- (Raw) ---\nRaw Expected: '[\"AAAAACCCCC\",\"CCCCCAAAAA\"]'\nRaw Got:      '[\"CCCCCAAAAA\", \"AAAAACCCCC\"]'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport json\n\nclass Solution:\n    def findRepeatedDnaSequences(self, s: str):\n        \"\"\"Return all 10-letter-long substrings that appear more than once.\"\"\"\n        seen = set()\n        repeated = set()\n        n = len(s)\n        for i in range(n - 9):  # 10 characters long\n            seq = s[i:i+10]\n            if seq in seen:\n                repeated.add(seq)\n            else:\n                seen.add(seq)\n        return list(repeated)\n\ndef main():\n    # Read all input from stdin\n    data = sys.stdin.read()\n    # Try to extract a string literal enclosed in single quotes\n    match = re.search(r\"'([^']*)'\", data)\n    if match:\n        dna = match.group(1)\n    else:\n        dna = data.strip()  # Fallback: assume entire input is the DNA string\n\n    solution = Solution()\n    result = solution.findRepeatedDnaSequences(dna)\n\n    # Output as a JSON list to match the expected format\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the described problem: find all 10-letter-long sequences in a DNA string that occur more than once. So algorithm: Use sliding window length 10, map counts. When count >1, add to result set.\n\nWe need to output in required format: each line with \"虛擬碼步驟 // 解釋\".\n\nUse Start, End, Decision, etc.\n\nLet's produce steps:\n\nStart\n→ Step 1: 接收輸入字串 s // DNA sequence\n→ Decision: 如果 s 的長度 < 10? // 無法形成 10 字元子串\n    Yes → Step 2: 回傳空集合 // 結果空\n    No  → Step 3: 初始化 count_map = {} // 用於計數\n           Step 4: 初始化 result_set = {} // 儲存重複序列\n           Step 5: for i from 0 to len(s)-10: // 逐個滑動窗口\n              → Step 6: sub = s.substring(i, i+10) // 取 10 字元子串\n              → Step 7: count_map[sub] = count_map.get(sub,0)+1 // 更新計數\n              → Decision: 如果 count_map[sub] == 2? // 第一次重複\n                  Yes → Step 8: result_set.add(sub) // 加入結果\n                  No  → Step 9: // 無需處理\n           Step 10: 回傳 result_set // 轉為 list\nEnd\n\nWe must ensure each line has \"虛擬碼步驟 // 解釋\". Use \"→\" before each step after Start? Format from example: \"→ Step 1: ...\" So we need to output each step line with \"→\". But Start and End lines not prefixed by arrow? In example, Start and End have no arrow. So we should do:\n\nStart // 程式開始執行\n→ Step 1: 接收輸入字串 s // DNA sequence\n→ Decision: ... etc.\n\nLet's produce each line accordingly. Use Step numbers accordingly. Include comments.\n\nEdge: Use for loop; Step 5. Use Step 6. etc.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 接收輸入字串 s // DNA 序列  \n→ Decision: s 的長度 < 10? // 無法產生 10 字元子序列  \n Yes → Step 2: 回傳空集合 // 結果為空  \n No → Step 3: 初始化 count_map = {} // 用於計數每個 10 字元子序列  \n  Step 4: 初始化 result_set = {} // 儲存重複出現的子序列  \n  Step 5: 迴圈 i 從 0 到 len(s) - 10 逐步滑動  \n   → Step 6: sub = s.substring(i, i+10) // 取第 i 個起始位置的 10 字元子序列  \n   → Step 7: count_map[sub] = count_map.get(sub, 0) + 1 // 更新子序列計數  \n   → Decision: count_map[sub] == 2? // 只在第一次重複時加入結果  \n    Yes → Step 8: result_set.add(sub) // 將重複子序列加入結果集  \n    No → Step 9: // 無需其他處理  \n  Step 10: 回傳 result_set // 將集合轉為清單並回傳  \nEnd // 程式執行結束"
    },
    {
      "title": "Permutations",
      "source_file": "Leetcode/leetcode46.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nGot (Norm):      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nRaw Got:      '[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 2, 1], [3, 1, 2]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def permute(self, nums):\n        \"\"\"Return all permutations of the distinct integer list nums.\"\"\"\n        res = []\n\n        def backtrack(start):\n            if start == len(nums):\n                res.append(nums[:])          # Copy current permutation\n                return\n            for i in range(start, len(nums)):\n                nums[start], nums[i] = nums[i], nums[start]   # Swap to fix element at position start\n                backtrack(start + 1)\n                nums[start], nums[i] = nums[i], nums[start]   # Swap back to restore original order\n\n        backtrack(0)\n        return res\n\ndef main():\n    \"\"\"Read input, compute permutations, and print the result.\"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Accept input in form \"nums = [1,2,3]\" or just \"[1,2,3]\"\n    if data.startswith('nums'):\n        eq_pos = data.find('=')\n        if eq_pos != -1:\n            data = data[eq_pos + 1:].strip()\n\n    try:\n        nums = ast.literal_eval(data)\n    except Exception:\n        nums = []\n\n    solution = Solution()\n    result = solution.permute(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code lines with explanation. Use Start, End, Decision, etc. Provide steps to generate permutations of distinct integers. Use backtracking. Each line as \"虛擬碼步驟 // 解釋\". Use arrow symbol. Let's produce.\n\nWe need to consider that the array distinct, so permutations unique. Virtual code:\n\nStart // program begins\n→ Step 1: 定義輸入陣列 nums // obtain the array\n→ Step 2: 定義結果 list res // 存放所有排列\n→ Step 3: 定義 helper function backtrack(curr, used) // 回溯\n    → Decision: 如果 curr 長度等於 nums 長度? // 檢查是否已完成一個排列\n        Yes → Step 4: 把 curr 複製到 res // 添加完整排列\n        No  → Step 5: 對於每個 num in nums // 遍歷所有數字\n            → Decision: num 是否已被 used? // 判斷是否已選取\n                Yes → Step 6: 跳過 // 不重複使用\n                No  → Step 7: Mark num 為 used // 標記為已使用\n                → Step 8: Append num 到 curr // 加入當前排列\n                → Step 9: Recursively call backtrack(curr, used) // 深入遞歸\n                → Step 10: Remove last element from curr // 回溯移除\n                → Step 11: Unmark num 為 used // 解除使用\n→ Step 12: 呼叫 backtrack([], set()) // 開始回溯\n→ Step 13: 回傳 res // 返回所有排列\nEnd // 程式結束\n\nWe need to ensure each line as \"虛擬碼步驟 // 解釋\" with arrow as \"→\". Should indent decisions accordingly. Use \"Decision:\".\n\nLet's craft final output accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義輸入陣列 nums // 取得使用者給定的整數陣列\n→ Step 2: 定義結果列表 res // 用來儲存所有產生的排列\n→ Step 3: 定義 helper 函式 backtrack(curr, used) // 回溯法的核心函式\n    → Decision: 如果 curr 的長度等於 nums 的長度? // 檢查是否已形成完整排列\n        Yes → Step 4: 把 curr 的複本加入 res // 完整排列加入結果\n        No  → Step 5: 對於每個 num 在 nums 之中 // 遍歷所有可能的下一個元素\n            → Decision: num 是否已被 used? // 判斷此數字是否已在目前排列中\n                Yes → Step 6: 跳過 // 不重複使用同一個數字\n                No  → Step 7: 把 num 加入 used // 標記此數字已使用\n                → Step 8: 將 num 加入 curr // 將此數字加到目前排列\n                → Step 9: 重新呼叫 backtrack(curr, used) // 深入下一層遞歸\n                → Step 10: 從 curr 移除最後一個元素 // 回溯，移除剛加入的數字\n                → Step 11: 從 used 移除 num // 解除使用標記，允許再次使用\n→ Step 12: 呼叫 backtrack([], set()) // 以空排列與空集合開始回溯\n→ Step 13: 回傳 res // 輸出所有排列結果\nEnd // 程式執行結束"
    },
    {
      "title": "Find the Duplicate Number",
      "source_file": "Leetcode/leetcode287.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "nums = [3,1,3,4,2]",
          "expected_output": "O3",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'O3'\nGot (Norm):      '3'\n--- (Raw) ---\nRaw Expected: 'O3'\nRaw Got:      '3'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findDuplicate(self, nums):\n        # Floyd's Tortoise and Hare (Cycle Detection)\n        slow = fast = nums[0]\n\n        # 第一階段：尋找相遇點\n        while True:\n            slow = nums[slow]\n            fast = nums[nums[fast]]\n            if slow == fast:\n                break\n\n        # 第二階段：尋找入環點（重複數字）\n        slow = nums[0]\n        while slow != fast:\n            slow = nums[slow]\n            fast = nums[fast]\n\n        return slow\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 從輸入字串中擷取陣列內容\n    l = data.find('[')\n    r = data.rfind(']')\n    if l == -1 or r == -1 or l > r:\n        nums = []\n    else:\n        nums = ast.literal_eval(data[l:r+1])\n\n    solution = Solution()\n    duplicate = solution.findDuplicate(nums)\n    print(duplicate)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need produce virtual code steps for problem: find duplicate number in array of n+1 numbers from 1..n, one duplicate, no modification, constant extra space. Classic Floyd cycle detection or binary search on count.\n\nWe produce virtual code using Floyd. Steps: set slow=nums[0], fast=nums[nums[0]]; loop until equal. Then find entry. Then return value.\n\nWe'll produce in lines with explanation. Use arrow syntax. Use Decision structure.\n\nLet's craft:\n\nStart\n→ Step 1: Set slow = nums[0] // 初始慢指針\n→ Step 2: Set fast = nums[ nums[0] ] // 初始快指針\n→ Decision: 循環開始？ // 檢查是否已相遇\n    Yes → Step 3: slow = nums[slow] // 移動慢指針一步\n    Yes → Step 4: fast = nums[ nums[fast] ] // 移動快指針兩步\n    Yes → Decision: slow == fast? // 判斷是否相遇\n        Yes → ... continue loop until yes\n        No  → continue loop\n\nAfter loop, find entry:\n\n→ Step 5: Set ptr1 = nums[0] // 指向頭\n→ Step 6: Set ptr2 = slow // 從相遇點開始\n→ Decision: ptr1 == ptr2? // 判斷是否相等\n    Yes → Step 7: Return ptr1 // 重複數字\n    No  → Step 8: ptr1 = nums[ptr1] // 移動一個\n    No  → Step 9: ptr2 = nums[ptr2] // 移動一個\n    No  → Decision: ptr1 == ptr2? // 重複判斷\n\nEnd\n\nBut we need structured step-by-step. Provide explanation after each line.\n\nLet's produce with proper arrow. Use Start, End.\n\nWe should include comments. Use minimal but clear.\n\nWe can also provide while loop as decision: Use Decision: slow != fast? etc.\n\nSimplify: Show while loop as Decision.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: slow ← nums[0] // 初始化慢指針  \n→ Step 2: fast ← nums[ nums[0] ] // 初始化快指針  \n→ Decision: slow ≠ fast? // 進入尋找相遇點的迴圈  \n    Yes → Step 3: slow ← nums[slow] // 慢指針前進一個  \n    Yes → Step 4: fast ← nums[ nums[fast] ] // 快指針前進兩個  \n    Yes → Decision: slow ≠ fast? // 仍未相遇，繼續迴圈  \n        Yes → 回到 Step 3  \n        No  → // 已相遇，跳出迴圈  \n→ Step 5: ptr1 ← nums[0] // 將 ptr1 指向陣列開頭  \n→ Step 6: ptr2 ← slow // ptr2 從相遇點開始  \n→ Decision: ptr1 ≠ ptr2? // 找到重複數字入口  \n    Yes → Step 7: ptr1 ← nums[ptr1] // ptr1 前進一個  \n    Yes → Step 8: ptr2 ← nums[ptr2] // ptr2 前進一個  \n    Yes → Decision: ptr1 ≠ ptr2? // 檢查是否相等，若否則重複步驟  \n        Yes → 回到 Step 7  \n        No  → // ptr1 == ptr2，重複數字已定位  \n→ Step 9: return ptr1 // 返回重複的數字  \nEnd // 程式執行結束"
    },
    {
      "title": "Insert Delete GetRandom O(1) - Duplicates allowed",
      "source_file": "Leetcode/leetcode381.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedCollection\", \"insert\", \"insert\", \"insert\", \"getRandom\", \"remove\", \"getRandom\"], [[], [1], [1], [2], [], [1], []]",
          "expected_output": "[null, true, false, true, 2, true, 1]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,false,true,2,true,1]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[null, true, false, true, 2, true, 1]'\nRaw Got:      '[]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\nimport json\nimport collections\n\nclass RandomizedCollection:\n    def __init__(self):\n        self.data = []\n        self.idx_map = collections.defaultdict(set)\n\n    def insert(self, val: int) -> bool:\n        self.data.append(val)\n        self.idx_map[val].add(len(self.data) - 1)\n        return len(self.idx_map[val]) == 1\n\n    def remove(self, val: int) -> bool:\n        if not self.idx_map[val]:\n            return False\n        remove_idx = self.idx_map[val].pop()\n        last_val = self.data[-1]\n        self.data[remove_idx] = last_val\n        self.idx_map[last_val].add(remove_idx)\n        self.idx_map[last_val].discard(len(self.data) - 1)\n        self.data.pop()\n        return True\n\n    def getRandom(self) -> int:\n        return random.choice(self.data)\n\ndef main() -> None:\n    input_lines = sys.stdin.read().strip().splitlines()\n    if not input_lines:\n        return\n    ops = ast.literal_eval(input_lines[0])\n    args = ast.literal_eval(input_lines[1]) if len(input_lines) > 1 else []\n\n    random.seed(0)  # deterministic randomness for testing\n    obj = None\n    result = []\n\n    for op, arg in zip(ops, args):\n        if op == \"RandomizedCollection\":\n            obj = RandomizedCollection()\n            result.append(None)\n        elif op == \"insert\":\n            result.append(obj.insert(arg[0]))\n        elif op == \"remove\":\n            result.append(obj.remove(arg[0]))\n        elif op == \"getRandom\":\n            result.append(obj.getRandom())\n\n    # Convert Python None/True/False to JSON null/true/false\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for implementing RandomizedCollection with described operations. Provide each line with arrow and comment. Need to follow format: \"Start\" then steps.\n\nWe need to think about data structures: list to hold values; hash map from value to set of indices positions in list. Insert: push to list, add index to map set, return true if value was not previously present. Remove: if val not present return false; else get an index from set, remove that index from set, swap last element into that index, update map sets accordingly, pop last from list, return true. getRandom: random index from list and return element.\n\nWe produce pseudocode in steps: initialization, insert, remove, getRandom.\n\nWe need to produce each step line. Use arrow notation.\n\nWe should show Start, End.\n\nWe might break down into functions.\n\nExample:\n\nStart\n→ Step: Initialize data structures // Set up list and map\n    → List := empty list // to store elements\n    → Map := empty map from int to set of int // indices\n→ Step: Insert(val) // function to insert\n    → If val not in Map:\n            → Map[val] := empty set // create entry\n            → IsNew := true\n        Else\n            → IsNew := false\n    → Index := length of List\n    → Append val to List\n    → Add Index to Map[val]\n    → Return IsNew\n...\n\nSimilarly for remove.\n\nOk produce.\n\nUse \"Decision:\" for conditional.\n\nMake sure each line ends with // comment.\n\nLet's generate.\n\n...done thinking.\n\nStart // 程式開始執行\n\n→ Step: 初始化資料結構 // 準備儲存值和索引\n    → List ← 空列表 // 存放所有元素，允許重複\n    → Map ← 空映射（int → 集合） // 儲存每個值對應的索引集合\n\n→ Step: insert(val) // 插入元素\n    → Decision: 如果 Map 中不存在 val? // 檢查是否為全新值\n        Yes → Map[val] ← 空集合 // 新增映射條目\n        No  → // 直接跳至下一步\n    → Index ← List 長度 // 新元素的索引\n    → List.append(val) // 加入列表\n    → Map[val].add(Index) // 記錄索引\n    → Return (Map[val].size == 1) // 若首次插入返回 true，否則 false\n\n→ Step: remove(val) // 移除一個元素\n    → Decision: 如果 Map 中不存在 val? // 若元素不在集合中\n        Yes → Return False // 無法移除\n        No  → // 進行移除\n    → IndexToRemove ← Map[val].任意元素 // 任取一個索引\n    → Map[val].remove(IndexToRemove) // 刪除該索引\n    → LastIndex ← List 長度 - 1 // 最後元素索引\n    → LastVal ← List[LastIndex] // 最後元素值\n    → List[IndexToRemove] ← LastVal // 將最後元素移到被刪除位置\n    → List.pop() // 刪除最後元素\n    → Decision: 如果 LastVal == val? // 移動元素與被刪除值相同\n        Yes → // 只需更新索引集合\n            → // 已在 Map[val] 刪除，無需再改動\n        No  → // 更新被移動元素的索引集合\n            → Map[LastVal].remove(LastIndex) // 刪除舊索引\n            → Map[LastVal].add(IndexToRemove) // 加入新索引\n    → Decision: 如果 Map[val] 為空? // 是否還有同值剩餘\n        Yes → Map.remove(val) // 移除空集合\n        No  → // 保持不變\n    → Return True // 成功移除\n\n→ Step: getRandom() // 取得隨機元素\n    → Index ← 隨機整數 [0, List長度-1] // 隨機索引\n    → Return List[Index] // 返回對應值\n\nEnd // 程式執行結束"
    },
    {
      "title": "Find Median from Data Stream",
      "source_file": "Leetcode/leetcode295.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"], [[], [1], [2], [], [3], []]",
          "expected_output": "[null, null, null, 1.5, null, 2.0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,1.5,null,2.0]'\nGot (Norm):      '[null,null,null,1.5,null,2]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, 1.5, null, 2.0]'\nRaw Got:      '[null, null, null, 1.5, null, 2]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport heapq\n\nclass MedianFinder:\n    def __init__(self):\n        # 小根堆（最大堆的負值）存放較小的一半數字\n        self.small = []\n        # 大根堆（最小堆）存放較大的一半數字\n        self.large = []\n\n    def addNum(self, num: int) -> None:\n        # 將新數加入小根堆\n        heapq.heappush(self.small, -num)\n        # 保證小根堆最大值不大於大根堆最小值\n        if self.small and self.large and (-self.small[0] > self.large[0]):\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        # 平衡兩堆大小：小根堆可比大根堆多 1 個\n        if len(self.small) > len(self.large) + 1:\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        elif len(self.large) > len(self.small):\n            val = heapq.heappop(self.large)\n            heapq.heappush(self.small, -val)\n\n    def findMedian(self) -> float:\n        if len(self.small) > len(self.large):\n            return -self.small[0]\n        else:\n            return (-self.small[0] + self.large[0]) / 2.0\n\n\nif __name__ == \"__main__\":\n    # 讀取所有輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    # 解析為兩個列表：操作序列與對應參數\n    # 把輸入包裝成一個外層列表再用 json.loads 解析\n    try:\n        data = json.loads(f'[{raw_input}]')\n    except json.JSONDecodeError:\n        # 如果輸入格式不符合預期，直接結束\n        sys.exit(0)\n\n    ops = data[0]\n    args = data[1]\n\n    results = []\n    obj = None\n\n    for op, arg in zip(ops, args):\n        if op == \"MedianFinder\":\n            obj = MedianFinder()\n            results.append(None)\n        elif op == \"addNum\":\n            obj.addNum(arg[0])\n            results.append(None)\n        elif op == \"findMedian\":\n            median = obj.findMedian()\n            results.append(median)\n        else:\n            # 若遇到未知操作，加入 None\n            results.append(None)\n\n    # 輸出結果，使用 json.dumps 以得到 null 的表示\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps for the MedianFinder class with methods: constructor, addNum, findMedian. Use heaps: max-heap for lower half, min-heap for upper half. Balance sizes. findMedian: if sizes equal, average; else top of larger heap. Provide each line with arrow. Ensure each line includes // explanation. Use Start, End, Decision. We'll produce stepwise pseudocode.\n\nWe'll start with Start, then create class, then constructor: initialize two heaps. Then addNum: decide where to put, balance. Use Decision to choose which heap. After insertion, balance sizes. findMedian: Decision sizes equal? Then average, else top of larger.\n\nLet's produce lines.\n\nWe need to output only pseudocode lines, not code. Should use arrow.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 MedianFinder 類別 // 定義主要資料結構  \n→ Step 2: 宣告 maxHeap ← 空（負號堆） // 存儲較小的一半數字  \n→ Step 3: 宣告 minHeap ← 空（正號堆） // 存儲較大的一半數字  \n→ Step 4: 定義構造函式 MedianFinder()  \n    → Step 5: 初始化 maxHeap 為最大堆 // 用於取最大值  \n    → Step 6: 初始化 minHeap 為最小堆 // 用於取最小值  \n→ End // 構造函式結束  \n\n→ Step 7: 定義方法 addNum(num: int)  \n    → Decision: 若 maxHeap 为空 或 num ≤ maxHeap.peek()? // 判斷 num 應放於較小的一半  \n        Yes → Step 8: maxHeap.push(num) // 把 num 插入 maxHeap  \n        No  → Step 9: minHeap.push(num) // 把 num 插入 minHeap  \n    → Decision: 若 maxHeap.size > minHeap.size + 1? // 檢查是否需要平衡  \n        Yes → Step 10: minHeap.push(maxHeap.pop()) // 把 maxHeap 最高值移至 minHeap  \n        No  → Decision: 若 minHeap.size > maxHeap.size? // 另一種平衡情況  \n            Yes → Step 11: maxHeap.push(minHeap.pop()) // 把 minHeap 最小值移至 maxHeap  \n            No  → // 已平衡，無需操作  \n→ End // addNum 方法結束  \n\n→ Step 12: 定義方法 findMedian() → double  \n    → Decision: 若 maxHeap.size == minHeap.size? // 數量相等時  \n        Yes → Step 13: median ← (maxHeap.peek() + minHeap.peek()) / 2.0 // 取兩堆頂平均  \n        No  → Step 14: median ← maxHeap.peek() // maxHeap 更大，取其頂作中位數  \n    → Step 15: return median // 回傳計算結果  \n→ End // findMedian 方法結束  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Minimum Number of Arrows to Burst Balloons",
      "source_file": "Leetcode/leetcode452.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "points = [[10,16],[2,8],[1,6],[7,12]]",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '1'"
        },
        {
          "example_index": 2,
          "input": "points = [[1,2],[2,3],[3,4],[4,5]]",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '1'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\ndef find_min_arrows(points):\n    \"\"\"計算最少箭數以打爆所有氣球（區間）\"\"\"\n    if not points:\n        return 0\n\n    # 以區間右端點升冪排序\n    points.sort(key=lambda x: x[1])\n    arrows = 1\n    current_end = points[0][1]\n\n    for start, end in points[1:]:\n        # 若現有箭無法觸及此區間，需新箭\n        if start > current_end:\n            arrows += 1\n            current_end = end\n        else:\n            # 已有箭能觸及，更新右端點為更右側的區間\n            current_end = end\n    return arrows\n\ndef parse_input(data):\n    \"\"\"從輸入字串取得 points 列表\"\"\"\n    data = data.strip()\n    # 若格式為 'points = ...'，取等號右側\n    if '=' in data:\n        _, expr = data.split('=', 1)\n        data = expr.strip()\n    # 解析為 Python 物件\n    try:\n        points = ast.literal_eval(data)\n    except Exception:\n        # 若解析失敗，回傳空列表\n        points = []\n    return points\n\nif __name__ == \"__main__\":\n    # 讀取所有輸入\n    raw = sys.stdin.read()\n    points = parse_input(raw)\n    result = find_min_arrows(points)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. Problem: Minimum number of arrows to cover intervals. Standard greedy: sort by end ascending, iterate, keep current arrow at end of first interval, count arrows when encountering interval with start > current arrow end. Implementation steps: sort, initialize arrows=0, currentEnd=None, iterate. Provide steps with comments. Must be line by line. Use Start, End, Decision. Provide explanation after each line. Let's produce. Ensure format: `虛擬碼步驟 // 解釋/說明`.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 將 points 依 x_end 升冪排序 // 先把所有氣球按右端點排好，方便後續處理  \n→ Step 2: 設定 arrows = 0 // 代表目前已射出的箭數  \n→ Step 3: 設定 currentEnd = 無值 // 代表目前射出的箭最後一個撞擊點（右端）  \n→ Decision: 迴圈開始遍歷每個氣球 (x_start, x_end) in 排好序的 points  \n    → Decision: 若 currentEnd 為無值 或 x_start > currentEnd? // 判斷是否需要新箭  \n        Yes → Step 4: arrows += 1 // 需要新箭，箭數加一  \n        Yes → Step 5: currentEnd = x_end // 把新箭的位置設在該氣球右端  \n        No  → Step 6: currentEnd = x_end // 既有箭已能撞到該氣球，更新右端為更靠右的氣球右端，保持能撞到後續氣球  \nEnd // 程式執行結束，arrows 為最小箭數答案。"
    },
    {
      "title": "Insert Interval",
      "source_file": "Leetcode/leetcode57.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "intervals = [[1,3],[6,9]], newInterval = [2,5]",
          "expected_output": "[[1,5],[6,9]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpllqhyrab.py\", line 54, in <module>\n    intervals, new_interval = parse_input(raw_data)\n                              ^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpllqhyrab.py\", line 44, in parse_input\n    raise ValueError(\"Input format is incorrect.\")\nValueError: Input format is incorrect."
        },
        {
          "example_index": 1,
          "input": "intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]",
          "expected_output": "[[1,2],[3,10],[12,16]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpticd113t.py\", line 54, in <module>\n    intervals, new_interval = parse_input(raw_data)\n                              ^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpticd113t.py\", line 44, in parse_input\n    raise ValueError(\"Input format is incorrect.\")\nValueError: Input format is incorrect."
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        Insert a new interval into a sorted list of non-overlapping intervals\n        and merge if necessary.\n        \"\"\"\n        result = []\n        i = 0\n        n = len(intervals)\n\n        # Add all intervals ending before the new interval starts\n        while i < n and intervals[i][1] < newInterval[0]:\n            result.append(intervals[i])\n            i += 1\n\n        # Merge all overlapping intervals with the new interval\n        while i < n and intervals[i][0] <= newInterval[1]:\n            newInterval[0] = min(newInterval[0], intervals[i][0])\n            newInterval[1] = max(newInterval[1], intervals[i][1])\n            i += 1\n\n        # Add the merged (or unchanged) new interval\n        result.append(newInterval)\n\n        # Add the remaining intervals\n        while i < n:\n            result.append(intervals[i])\n            i += 1\n\n        return result\n\ndef parse_input(data: str):\n    \"\"\"\n    Parse the input string of the form:\n    'intervals = [[1,3],[6,9]], newInterval = [2,5]'\n    into a list of intervals and a new interval.\n    \"\"\"\n    pattern = r'intervals\\s*=\\s*(\\[[^\\]]*\\])\\s*,\\s*newInterval\\s*=\\s*(\\[[^\\]]*\\])'\n    match = re.search(pattern, data)\n    if not match:\n        raise ValueError(\"Input format is incorrect.\")\n    intervals_str, new_interval_str = match.groups()\n    intervals = eval(intervals_str)        # safe for simple numeric lists\n    new_interval = eval(new_interval_str)  # safe for simple numeric lists\n    return intervals, new_interval\n\nif __name__ == \"__main__\":\n    # Read all data from standard input\n    raw_data = sys.stdin.read()\n    # Parse intervals and newInterval\n    intervals, new_interval = parse_input(raw_data)\n    # Compute the result\n    sol = Solution()\n    merged = sol.insert(intervals, new_interval)\n    # Output the result\n    print(merged)",
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line with comments in Chinese (繁體). Should be a plan of algorithm: Insert new interval into sorted non-overlapping intervals, merging if necessary. We output virtual steps.\n\nWe should adhere to format: each line: 虛擬碼步驟 [space] // 解釋. Use arrows. Eg: Start // 程式開始執行\n\nSo we produce lines:\n\nStart // 程式開始\n→ Step 1: 初始化 result list // 建立結果陣列\n→ Step 2: 取 intervals 的長度 n // 方便迴圈\n→ Step 3: 取 newInterval start, end // 方便比較\n→ Decision: 是否有 intervals? // 若空陣列直接返回 newInterval\n\nLoop over i from 0 to n-1 maybe separate steps.\n\nBetter to express algorithm:\n\nWe can have pointer i = 0.\n\nWhile i < n and intervals[i].end < newInterval.start:\n  add intervals[i] to result\n  i++\n\nThen while i < n and intervals[i].start <= newInterval.end:\n  merge: newInterval.start = min(newInterval.start, intervals[i].start)\n  newInterval.end = max(newInterval.end, intervals[i].end)\n  i++\n\nThen add newInterval to result\n\nThen while i < n:\n  add intervals[i] to result\n\nReturn result\n\nWe need to express as virtual steps.\n\nUse Decision blocks.\n\nWe should include arrow lines.\n\nLet's write.\n\nNeed to use arrow \"→\". Use \"Decision:\" for conditions. \"Yes →\" \"No →\".\n\nWe'll need to refer to array indices. Represent intervals[i].start, etc.\n\nLet's produce.\n\nStart // 程式開始執行\n→ Step 1: 創建空列表 result // 用來儲存最終區間\n→ Step 2: 取得 intervals 長度 n // 方便迴圈\n→ Step 3: 取得 newInterval 開始點 s, 結束點 e // 方便比較\n→ Decision: 是否有 intervals? // 判斷是否為空陣列\n    Yes → Step 4: result 加入 [s, e] // 空陣列直接返回新區間\n    No  → Step 5: 初始化指標 i = 0 // 從第一個區間開始\n\n→ Decision: i < n 且 intervals[i].end < s? // 先把不重疊且在新區間左側的區間加入結果\n    Yes → Step 6: result 加入 intervals[i] // 將當前區間加入\n         → Step 7: i = i + 1 // 移動到下一個\n         → 再回到上一個 Decision // 重新檢查條件\n    No  → // 進入合併階段\n\n→ Decision: i < n 且 intervals[i].start <= e? // 這些區間與新區間重疊，需要合併\n    Yes → Step 8: s = min(s, intervals[i].start) // 更新合併後的開始\n         → Step 9: e = max(e, intervals[i].end) // 更新合併後的結束\n         → Step 10: i = i + 1 // 移動到下一個\n         → 再回到上一個 Decision // 重新檢查條件\n    No  → // 完成合併，將新區間加入結果\n\n→ Step 11: result 加入 [s, e] // 將合併後的新區間加入結果\n\n→ Decision: i < n? // 將剩餘的區間加入結果\n    Yes → Step 12: result 加入 intervals[i] // 加入當前區間\n         → Step 13: i = i + 1 // 移動\n         → 再回到上一個 Decision // 重新檢查條件\n    No  → // 所有區間已加入\n\nEnd // 程式結束，返回 result\n\nBut ensure each line ends with // 解釋. Also use \"→\" arrow. For decision we need \"Decision:\" then indent lines.\n\nMake sure indentation is preserved: Use spaces or tabs? We'll just use spaces.\n\nAlso we must maintain the structure of arrows. Use \"→\" at beginning of each step. For Decision blocks, we write \"Decision:\" then indented lines with \"Yes →\" etc. Let's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空列表 result // 用來儲存最終的區間  \n→ Step 2: 取得 intervals 長度 n // 方便迴圈  \n→ Step 3: 取得 newInterval 的起點 s 與終點 e // 方便比較  \n→ Decision: intervals 是否為空? // 判斷是否有原始區間  \n Yes → Step 4: result 加入 [s, e] // 空陣列直接返回新區間  \n No  → Step 5: 初始化指標 i = 0 // 從第一個區間開始  \n\n→ Decision: i < n 且 intervals[i].end < s? // 把所有在新區間左側且不重疊的區間加入結果  \n Yes → Step 6: result 加入 intervals[i] // 將當前區間加入  \n  → Step 7: i = i + 1 // 移動到下一個區間  \n  → 再回到上一個 Decision // 重新檢查條件  \n No  → // 進入合併階段  \n\n→ Decision: i < n 且 intervals[i].start <= e? // 把與新區間重疊的區間合併  \n Yes → Step 8: s = min(s, intervals[i].start) // 更新合併後的起點  \n  → Step 9: e = max(e, intervals[i].end) // 更新合併後的終點  \n  → Step 10: i = i + 1 // 移動到下一個區間  \n  → 再回到上一個 Decision // 重新檢查條件  \n No  → // 合併完成，將新區間加入結果  \n\n→ Step 11: result 加入 [s, e] // 將合併後的新區間加入結果  \n\n→ Decision: i < n? // 把剩餘的區間（全在新區間右側）加入結果  \n Yes → Step 12: result 加入 intervals[i] // 加入當前區間  \n  → Step 13: i = i + 1 // 移動到下一個  \n  → 再回到上一個 Decision // 重新檢查條件  \n No  → // 所有區間已加入  \n\nEnd // 程式結束，返回 result"
    },
    {
      "title": "Substring with Concatenation of All Words",
      "source_file": "Leetcode/leetcode30.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]",
          "expected_output": "[0,9]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp5ustlck8.py\", line 67, in <module>\n    main()\n  File \"/tmp/tmp5ustlck8.py\", line 62, in main\n    s, words = parse_input(raw_input)\n               ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp5ustlck8.py\", line 55, in parse_input\n    data = ast.literal_eval(formatted)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    {'s': \"barfoothefoobarman\", word's': [\"foo\",\"bar\"]}\n                                   ^\nSyntaxError: ':' expected after dictionary key"
        },
        {
          "example_index": 1,
          "input": "s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]",
          "expected_output": "[]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpfd7vn8hk.py\", line 67, in <module>\n    main()\n  File \"/tmp/tmpfd7vn8hk.py\", line 62, in main\n    s, words = parse_input(raw_input)\n               ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpfd7vn8hk.py\", line 55, in parse_input\n    data = ast.literal_eval(formatted)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    {'s': \"wordgoodgoodgoodbestword\", word's': [\"word\",\"good\",\"best\",\"word\"]}\n                                         ^\nSyntaxError: ':' expected after dictionary key"
        },
        {
          "example_index": 2,
          "input": "s = \"barfoofoobarthefoobarman\", words = [\"bar\",\"foo\",\"the\"]",
          "expected_output": "[6,9,12]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp0zudw5fq.py\", line 67, in <module>\n    main()\n  File \"/tmp/tmp0zudw5fq.py\", line 62, in main\n    s, words = parse_input(raw_input)\n               ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp0zudw5fq.py\", line 55, in parse_input\n    data = ast.literal_eval(formatted)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    {'s': \"barfoofoobarthefoobarman\", word's': [\"bar\",\"foo\",\"the\"]}\n                                         ^\nSyntaxError: ':' expected after dictionary key"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import Counter\n\ndef find_substring(s: str, words: list[str]) -> list[int]:\n    \"\"\"\n    Return all starting indices of substrings in s that are concatenations\n    of each word in words exactly once and without any intervening characters.\n    \"\"\"\n    if not words or not s:\n        return []\n\n    word_len = len(words[0])\n    word_count = len(words)\n    total_len = word_len * word_count\n\n    # If the concatenated length exceeds s, no answer exists\n    if len(s) < total_len:\n        return []\n\n    # Frequency map of required words\n    target = Counter(words)\n\n    result = []\n    # Iterate over possible starting positions\n    for i in range(len(s) - total_len + 1):\n        # Frequency map of words seen in the current window\n        seen = Counter()\n        # Check each word-sized chunk in the window\n        for j in range(word_count):\n            start = i + j * word_len\n            word = s[start:start + word_len]\n            if word not in target:\n                break  # invalid word, stop early\n            seen[word] += 1\n            if seen[word] > target[word]:\n                break  # word occurs too many times\n        else:\n            # All words matched the required counts\n            result.append(i)\n    return result\n\ndef parse_input(input_str: str) -> tuple[str, list[str]]:\n    \"\"\"\n    Parse input of the form:\n        s = \"some string\", words = [\"w1\",\"w2\",...]\n    \"\"\"\n    # Replace variable assignments with dictionary keys\n    formatted = input_str.strip()\n    formatted = formatted.replace('s =', \"'s':\")\n    formatted = formatted.replace('words =', \"'words':\")\n    formatted = '{' + formatted + '}'\n    # Safely evaluate the dictionary\n    data = ast.literal_eval(formatted)\n    return data['s'], data['words']\n\ndef main() -> None:\n    raw_input = sys.stdin.read()\n    if not raw_input.strip():\n        return\n    s, words = parse_input(raw_input)\n    ans = find_substring(s, words)\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines explaining algorithm. The task: given string s and array words same length. Find starting indices where substring of s equals concatenation of all words in any order. Classic sliding window. Steps: compute word count map, window size = wordLen * wordsCount. Iterate over s with sliding window of size windowSize. Use hashmap currentCount. For each position, adjust window: add new word at right, remove left. Check if currentCount equals wordCount then record index.\n\nWe need to output virtual code with arrows and decision. Ensure each line includes virtual code and comment. Use \"Start\" \"End\". Use Decision, Yes, No. The code is not actual but pseudo steps.\n\nLet's produce step-by-step. Might include initialization, loops. Provide each line. Use arrow.\n\nWe must use Chinese explanation.\n\nLet's craft.\n\nExample:\n\nStart // 程式開始執行\n→ Step 1: 取得 s, words, 計算 wordLen, wordCount, windowSize // 初始化參數\n\nThen Step 2: 建立 hashMap targetCount，計算每個單字出現次數 // 準備目標計數\n\nThen Step 3: 初始化空 hashMap currentCount，開始滑動視窗 // 準備動態窗口\n\nThen Step 4: 迴圈 i 從 0 到 s.length - windowSize // 遍歷所有可能起始位置\n\nInside loop: compute word = s.substring(i, i+wordLen) etc.\n\nWe need Decision when word in targetCount etc. Then after sliding, check if currentCount == targetCount -> record index.\n\nOk. Let's produce line by line.\n\nUse indent arrow for nested decisions.\n\nAlso, we might show removal of left word when window moves; but in simple implementation we just maintain counts as we iterate.\n\nAlternatively we can use outer loop shift by 1 each step; update counts.\n\nWe'll create steps accordingly.\n\nNeed to adhere to format: \"虛擬碼步驟 [space] // 解釋/說明\".\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得 s, words, 計算 wordLen = words[0].length, wordCount = words.length, windowSize = wordLen * wordCount // 初始化基本參數  \n\n→ Step 2: 建立 hashMap targetCount，對 words 中每個字串計算出現次數 // 目標字串頻率表  \n\n→ Step 3: 建立空 hashMap currentCount，並初始化起始指標 left = 0, right = 0 // 滑動窗口的兩端  \n\n→ Step 4: 迴圈 while right + wordLen <= s.length // 遍歷 s 的所有可形成窗口的位置  \n\n  → Step 4.1: 取出右側新字串 word = s.substring(right, right + wordLen) // 從 s 取下一個長度為 wordLen 的子字串  \n\n  → Decision: word 是否存在於 targetCount? // 判斷新字串是否為有效字串  \n\n   Yes → Step 4.2: currentCount[word] += 1 // 若是有效字串，更新滑動窗口的頻率表  \n\n   No  → Step 4.3: currentCount.clear() // 若不是有效字串，清空頻率表並重置左端  \n\n  → Step 4.4: right += wordLen // 移動右端到下一個字串位置  \n\n  → Decision: right - left == windowSize? // 判斷滑動窗口是否已達到完整長度  \n\n   Yes → Step 4.5: Decision: currentCount == targetCount? // 檢查窗口內字串集合是否與目標相同  \n\n    Yes → Step 4.6: add left to resultList // 若相同，記錄起始索引  \n\n    No  → Step 4.7: // 不相同，什麼也不做"
    },
    {
      "title": "Group Anagrams",
      "source_file": "Leetcode/leetcode49.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]",
          "expected_output": "[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]'\nGot (Norm):      '[[\"eat\",\"tea\",\"ate\"],[\"tan\",\"nat\"],[\"bat\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]'\nRaw Got:      \"[['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]\""
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def groupAnagrams(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        anagrams = defaultdict(list)\n        for s in strs:\n            key = tuple(sorted(s))  # 將字串排序後作為 key\n            anagrams[key].append(s)\n        return list(anagrams.values())\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        print([])\n        return\n\n    # 只取出等號後方的列表字串\n    idx = data.find('[')\n    if idx == -1:\n        strs = []\n    else:\n        list_str = data[idx:]\n        try:\n            strs = ast.literal_eval(list_str)\n        except Exception:\n            strs = []\n\n    result = Solution().groupAnagrams(strs)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps with explanation. It's for grouping anagrams. We produce steps like: Start, read array, iterate, sort string to key, use dictionary, etc. Provide each line with virtual code arrow and explanation.\n\nWe must follow format: Each line: \"虛擬碼步驟 // 解釋\". Use arrow \"→\". Use Decision etc. Let's create steps:\n\nStart\n→ Step 1: 初始化空字典 groups // 用於存放排序後鍵對應的字串列表\n→ Step 2: 遍歷陣列 strs 中每個字串 s // 逐一處理\n    → Step 3: 取得 s 的字元並排序得到 key // 排序後的字串作為鍵\n    → Decision: 如果 key 在 groups 中? // 檢查鍵是否已存在\n        Yes → Step 4: 將 s 加入 groups[key] // 追加到現有分組\n        No  → Step 5: 建立新分組 groups[key] = [s] // 創建新的分組\n→ Step 6: 收集 groups 的值為最終結果 // 取所有分組\nEnd\n\nWe also need to use \"Start\", \"End\" and \"Decision:\" lines as per format. Provide each line with explanation.\n\nWe should not output actual code, just virtual code steps. Also must use [空格] after virtual code step. Use \"Start\" and \"End\". Provide arrow \"→\". For decisions we include indentation? In example, indentation with tab or spaces. We'll mimic with tab indentation but not necessary. Provide lines with proper indentation.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: 初始化空字典 groups // 用於存放排序後鍵對應的字串列表\n→ Step 2: 遍歷陣列 strs 中每個字串 s // 逐一處理\n  → Step 3: 取得 s 的字元並排序得到 key // 排序後的字串作為鍵\n  → Decision: 如果 key 在 groups 中? // 檢查鍵是否已存在\n   Yes → Step 4: 將 s 加入 groups[key] // 追加到現有分組\n   No  → Step 5: 建立新分組 groups[key] = [s] // 創建新的分組\n→ Step 6: 將 groups 的值收集為結果 list // 取所有分組\nEnd // 程式執行結束\n\nEnsure indentation consistent. Use tab or spaces? Use spaces. Provide \"Decision:\" line with nested lines.\n\nAlso need to maintain \"虛擬碼步驟\" each line. Use \"Start\" and \"End\" without arrow.\n\nLet's output accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化空字典 groups // 用於存放排序後鍵對應的字串列表\n→ Step 2: 遍歷陣列 strs 中每個字串 s // 逐一處理\n  → Step 3: 取得 s 的字元並排序得到 key // 排序後的字串作為鍵\n  → Decision: 如果 key 在 groups 中? // 檢查鍵是否已存在\n   Yes → Step 4: 將 s 加入 groups[key] // 追加到現有分組\n   No  → Step 5: 建立新分組 groups[key] = [s] // 創建新的分組\n→ Step 6: 將 groups 的值收集為結果 list // 取所有分組\nEnd // 程式執行結束"
    },
    {
      "title": "LRU Cache",
      "source_file": "Leetcode/leetcode146.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"], [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]",
          "expected_output": "[null, null, null, 1, null, -1, null, -1, 3, 4]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmppaj1d32x.py\", line 35, in <module>\n    args = ast.literal_eval(args_part)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [, [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\n     ^\nSyntaxError: invalid syntax"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = OrderedDict()\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        value = self.cache.pop(key)\n        self.cache[key] = value  # move to end (most recent)\n        return value\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            self.cache.pop(key)\n        self.cache[key] = value\n        if len(self.cache) > self.capacity:\n            self.cache.popitem(last=False)  # remove least recently used\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # Split the two top‑level lists\n    split_index = data.find('],')\n    ops_part = data[:split_index + 1]\n    args_part = '[' + data[split_index + 1:].strip()\n    ops = ast.literal_eval(ops_part)\n    args = ast.literal_eval(args_part)\n\n    result = []\n    obj = None\n    for method, arg in zip(ops, args):\n        if method == \"LRUCache\":\n            obj = LRUCache(*arg)\n            result.append(None)\n        elif method == \"put\":\n            obj.put(*arg)\n            result.append(None)\n        elif method == \"get\":\n            result.append(obj.get(*arg))\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to produce a step-by-step virtual code in Chinese (Traditional). Must not output actual code, only virtual steps. Provide arrow and decision. For LRU cache design. Likely steps: Start, initialize capacity, create hash map key->node, create doubly linked list with head tail sentinel, functions get/put. We should describe the algorithm. Each line with virtual code and comment.\n\nWe should produce a sequence that explains building LRUCache class. Steps include initialization, get, put. For get: check if key exists in map. If not return -1. If exists, move node to front (most recently used). Return value. For put: if key exists, update value, move to front. Else create node, add to front, add to map. If size > capacity, evict tail's prev (least recent), remove from map and list. End.\n\nLet's produce a series of virtual code lines. Use Start, Decision, Yes/No. Ensure each line has \"虛擬碼步驟\" plus comment. Let's produce something like:\n\nStart\n→ Initialize capacity, create map, create head/tail sentinel nodes, set size 0\n→ Class: LRUCache\n    → Constructor: capacity\n        → Set capacity\n        → Create hash map\n        → Create head/tail nodes, link them\n        → Set size 0\n    → Function get(key)\n        → Decision: key in map?\n            Yes → Step: node = map[key]\n                → Move node to front\n                → Return node.value\n            No  → Return -1\n    → Function put(key, value)\n        → Decision: key in map?\n            Yes → Step: node = map[key]\n                → Update node.value\n                → Move node to front\n            No  → Step: create node(key, value)\n                → Add node to front\n                → map[key] = node\n                → size++\n                → Decision: size > capacity?\n                    Yes → Step: lru = tail.prev\n                        → Remove lru from list\n                        → Delete map[lru.key]\n                        → size--\n                    No → Nothing\nEnd\n\nBut we need each line separately. Let's produce each line with arrow, no nested indent maybe use indentation for readability. Use 虛擬碼 step. Provide comment after //.\n\nWe must maintain \"逐行輸出\" meaning each line separate. Provide no extraneous output.\n\nLet's craft.\n\nWe'll need to label each step clearly: Start, → etc. Provide decision blocks. Use \"Decision:\" lines.\n\nOk. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 LRUCache，設置容量 capacity、空的哈希表 map 以及雙向鏈表的 head 與 tail 虛擬節點 // 準備資料結構  \n→ Decision: 需要初始化 LRUCache?  \n    Yes → Step 2: 建立 head 與 tail，將 head.next 指向 tail，tail.prev 指向 head，size 設為 0 // 設定雙向鏈表頭尾  \n    No  → End // 不需要初始化結束  \n→ Class: LRUCache // 定義 LRUCache 類別  \n    → Function: get(key) // 定義 get 方法  \n        → Decision: key 是否存在於 map?  \n            Yes → Step 3: node ← map[key] // 取得對應節點  \n                → Step 4: 移除 node 從其原位置 // 把節點從原位移除  \n                → Step 5: 插入 node 到 head 後面 // 把節點移到最前面（最近使用）  \n                → Step 6: 回傳 node.value // 返回對應值  \n            No  → Step 7: 回傳 -1 // key 不存在時回傳 -1  \n    → Function: put(key, value) // 定義 put 方法  \n        → Decision: key 是否存在於 map?  \n            Yes → Step 8: node ← map[key] // 取得節點  \n                → Step 9: 更新 node.value 為 value // 更新值  \n                → Step 10: 移除 node 從其原位置  \n                → Step 11: 插入 node 到 head 後面 // 重新設為最近使用  \n            No  → Step 12: 建立新節點 newNode(key, value) // 新增節點  \n                → Step 13: 插入 newNode 到 head 後面 // 新節點放在最前面  \n                → Step 14: map[key] ← newNode // 把節點加入哈希表  \n                → Step 15: size++ // 增加元素計數  \n                → Decision: size 是否超過 capacity?  \n                    Yes → Step 16: lruNode ← tail.prev // 取得最舊節點  \n                        → Step 17: 移除 lruNode 從鏈表  \n                        → Step 18: 刪除 map[lruNode.key] // 從哈希表移除  \n                        → Step 19: size-- // 減少元素計數  \n                    No → No op // 未超過容量，無需淘汰  \nEnd // 程式執行結束"
    },
    {
      "title": "Roman to Integer",
      "source_file": "Leetcode/leetcode13.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 2,
          "input": "Input: s = \"MCMXCIV\"",
          "expected_output": "Output: 1994",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'Output:1994'\nGot (Norm):      '1994'\n--- (Raw) ---\nRaw Expected: 'Output: 1994'\nRaw Got:      '1994'"
        }
      ],
      "generated_code": "import sys\n\ndef roman_to_int(s: str) -> int:\n    \"\"\"將羅馬數字轉為整數。\"\"\"\n    roman_map = {\n        'I': 1, 'V': 5, 'X': 10, 'L': 50,\n        'C': 100, 'D': 500, 'M': 1000\n    }\n    total = 0\n    prev_value = 0\n    for ch in reversed(s):\n        value = roman_map[ch]\n        if value < prev_value:\n            total -= value\n        else:\n            total += value\n        prev_value = value\n    return total\n\ndef main() -> None:\n    \"\"\"讀取 stdin，解析羅馬數字，輸出其整數值。\"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 若輸入包含雙引號，取其內部文字作為羅馬數字\n    first_quote = data.find('\"')\n    if first_quote != -1:\n        second_quote = data.find('\"', first_quote + 1)\n        if second_quote != -1:\n            roman_str = data[first_quote + 1:second_quote]\n        else:\n            roman_str = data[first_quote + 1:]\n    else:\n        roman_str = data  # 若沒有引號，直接使用整個輸入\n\n    roman_str = roman_str.strip()\n    result = roman_to_int(roman_str)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for converting Roman numeral to integer. Provide step-by-step pseudocode with arrows, decisions, etc. Each line with \"虛擬碼步驟 // 解釋\". Should follow format. Use Start, End, Decision, etc. Provide simple algorithm: iterate from right to left, add value if >= previous, else subtract. Or left to right with lookahead. I'll choose right-to-left.\n\nSo steps:\n\nStart\n→ Define mapping of symbols to values\n→ Initialize total = 0\n→ Initialize prev = 0\n→ For each character c in input string, from rightmost to leftmost\n    → current = value(c)\n    → If current < prev\n          → total = total - current\n      Else\n          → total = total + current\n      → prev = current\n→ Return total\nEnd\n\nBut need to format each line with arrow etc. Let's produce.\n\nWe need to include indentation for decision: Yes/No. For loops: maybe \"Loop: i from len-1 downto 0\".\n\nLet's produce lines like:\n\nStart // 程式開始執行\n→ Step 1: 定義符號與數值對應表 // 建立符號到數值的映射\n→ Step 2: 初始化 total = 0 // 記錄累積整數\n→ Step 3: 初始化 prev = 0 // 先前符號的數值\n→ Step 4: 迴圈 i 從 len-1 迭代至 0 // 從右向左遍歷字串\n    → Step 5: current = value(roman[i]) // 取得當前符號對應的數值\n    → Decision: current < prev? // 判斷是否要減法\n        Yes → Step 6: total = total - current // 進行減法\n        No  → Step 7: total = total + current // 進行加法\n    → Step 8: prev = current // 更新先前數值\n→ Step 9: return total // 輸出結果\nEnd // 程式結束\n\nWe need to use \"→\" before each step. For the decision, indent further. Use Yes →, No →.\n\nMake sure each line ends with comment. Also include // in comment. Provide no actual code.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義符號與數值對應表 // 建立符號到數值的映射\n→ Step 2: 初始化 total = 0 // 記錄累積整數\n→ Step 3: 初始化 prev = 0 // 先前符號的數值\n→ Step 4: 迴圈 i 從 len-1 迭代至 0 // 從右向左遍歷字串\n    → Step 5: current = value(roman[i]) // 取得當前符號對應的數值\n    → Decision: current < prev? // 判斷是否要減法\n        Yes → Step 6: total = total - current // 進行減法\n        No  → Step 7: total = total + current // 進行加法\n    → Step 8: prev = current // 更新先前數值\n→ Step 9: return total // 輸出結果\nEnd // 程式結束"
    },
    {
      "title": "Kth Largest Element in a Stream",
      "source_file": "Leetcode/leetcode703.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"KthLargest\", \"add\", \"add\", \"add\", \"add\", \"add\"], [[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]",
          "expected_output": "[null, 4, 5, 5, 8, 8]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp7jutdatb.py\", line 34, in <module>\n    args = json.loads(args_part)\n           ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 337, in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 353, in raw_decode\n    obj, end = self.scan_once(s, idx)\n               ^^^^^^^^^^^^^^^^^^^^^^\njson.decoder.JSONDecodeError: Expecting ',' delimiter: line 1 column 47 (char 46)"
        },
        {
          "example_index": 1,
          "input": "[\"KthLargest\", \"add\", \"add\", \"add\", \"add\"], [[4, [7, 7, 7, 7, 8, 3]], [2], [10], [9], [9]]",
          "expected_output": "[null, 7, 7, 7, 8]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmprwqb4rua.py\", line 34, in <module>\n    args = json.loads(args_part)\n           ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 337, in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 353, in raw_decode\n    obj, end = self.scan_once(s, idx)\n               ^^^^^^^^^^^^^^^^^^^^^^\njson.decoder.JSONDecodeError: Expecting ',' delimiter: line 1 column 48 (char 47)"
        }
      ],
      "generated_code": "import json\nimport heapq\nimport sys\n\nclass KthLargest:\n    \"\"\"\n    維持一個最小堆，堆的大小不超過 k。\n    堆的最小元素即為目前所有數值中的第 k 大。\n    \"\"\"\n    def __init__(self, k, nums):\n        self.k = k\n        self.min_heap = []\n        for num in nums:\n            self.add(num)\n\n    def add(self, val):\n        heapq.heappush(self.min_heap, val)\n        if len(self.min_heap) > self.k:\n            heapq.heappop(self.min_heap)\n        return self.min_heap[0]\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個字串\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 分割成兩個 JSON 陣列\n    parts = data.split('],', 1)\n    ops_part = parts[0] + ']'          # 完整的操作名稱列表\n    args_part = '[' + parts[1].lstrip()  # 完整的參數列表\n\n    ops = json.loads(ops_part)\n    args = json.loads(args_part)\n\n    results = []\n    kth = None\n\n    for i, op in enumerate(ops):\n        if op == \"KthLargest\":\n            k, nums = args[i]\n            kth = KthLargest(k, nums)\n            results.append(None)        # 建構子對應 null\n        else:\n            val = args[i][0]             # add 的參數\n            results.append(getattr(kth, op)(val))\n\n    # 輸出為 JSON 格式\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for KthLargest class. Steps: Start, constructor, add, using min-heap of size k. Virtual code lines. Include decisions. Provide explanations.\n\nWe should output line by line. Each line: 虛擬碼步驟 + space + // 解釋. Use arrow syntax. Use Start, End, Decision:. Provide for class methods.\n\nLet's produce something like:\n\nStart\n→ Class KthLargest\n    → Variable: minHeap // 儲存前k大值\n    → Variable: k\n→ Constructor: KthLargest(k, nums) // 初始化\n    → Set this.k = k\n    → For each score in nums\n        → If minHeap.size < k\n            → Add score to minHeap\n        → Else if score > minHeap.peek\n            → Remove peek\n            → Add score\n→ Method: add(val) // 新增分數\n    → If minHeap.size < k\n        → Add val\n    → Else if val > minHeap.peek\n        → Remove peek\n        → Add val\n    → Return minHeap.peek // k-th largest\nEnd\n\nNeed to use arrow: → Step etc. Use Decision: lines. Also need to handle decision points.\n\nLet's craft.\n\nAlso we need to show decision for minHeap size < k or val > peek. Provide nested decisions.\n\nUse Start and End.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Class KthLargest // 定義 KthLargest 類別  \n    → Variable k // 儲存 k 的值  \n    → Variable minHeap // 儲存前 k 大值的最小堆  \n\n→ Constructor: KthLargest(k, nums) // 初始化物件  \n    → Assign: this.k = k // 設定 k  \n    → For each score in nums // 循環處理初始分數  \n        → Decision: 如果 minHeap.size < k? // 堆尚未滿 k 個  \n            Yes → Action: Add score to minHeap // 直接加入堆  \n            No → Decision: 如果 score > minHeap.peek? // 分數比最小值大  \n                Yes → Action: Remove minHeap.peek()  \n                      → Add score to minHeap // 替換最小值  \n                No → Action: 跳過 // 不加入堆  \n\n→ Method: add(val) // 新增分數並返回第 k 大值  \n    → Decision: 如果 minHeap.size < k? // 堆未滿 k  \n        Yes → Action: Add val to minHeap // 直接加入  \n        No → Decision: 如果 val > minHeap.peek? // 新分數比最小值大  \n            Yes → Action: Remove minHeap.peek()  \n                  → Add val to minHeap // 替換最小值  \n            No → Action: 跳過 // 不加入堆  \n    → Return minHeap.peek() // 目前的第 k 大值  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Implement Rand10() Using Rand7()",
      "source_file": "Leetcode/leetcode470.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 1",
          "expected_output": "[2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2]'\nGot (Norm):      '[9]'\n--- (Raw) ---\nRaw Expected: '[2]'\nRaw Got:      '[9]'"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[2,8]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,8]'\nGot (Norm):      '[5,1]'\n--- (Raw) ---\nRaw Expected: '[2,8]'\nRaw Got:      '[5, 1]'"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "[3,8,10]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,8,10]'\nGot (Norm):      '[5,5,6]'\n--- (Raw) ---\nRaw Expected: '[3,8,10]'\nRaw Got:      '[5, 5, 6]'"
        }
      ],
      "generated_code": "import sys\nimport random\nimport re\n\ndef rand7() -> int:\n    \"\"\"返回 1~7 的均勻隨機整數。\"\"\"\n    return random.randint(1, 7)\n\ndef rand10() -> int:\n    \"\"\"\n    生成 1~10 的均勻隨機整數。\n    先產生 1~49 的均勻分佈，再只接受前 40 個數字，\n    其餘的則重試。\n    \"\"\"\n    while True:\n        # 兩次 rand7 生成 1~49\n        num = (rand7() - 1) * 7 + rand7()\n        if num <= 40:  # 只接受 1~40\n            return 1 + (num - 1) % 10\n\ndef main() -> None:\n    \"\"\"讀取輸入、調用 rand10() 並輸出結果。\"\"\"\n    # 讀取整個輸入並提取第一個數字（n）\n    raw_input = sys.stdin.read().strip()\n    match = re.search(r'\\d+', raw_input)\n    n = int(match.group()) if match else 0\n\n    # 產生 n 個 rand10() 的結果\n    results = [rand10() for _ in range(n)]\n\n    # 將結果以列表形式輸出\n    print(results)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for solving the problem: given rand7() generate uniform random integer 1-7, produce rand10() uniform 1-10. Classic solution: generate two 7's to create 1-49 by (rand7() -1)*7 + rand7(); accept numbers 1-40, map to 1-10 via modulo 10; otherwise repeat. So we produce steps. They want each line virtual code with explanation. We'll use arrows, decisions, loops.\n\nWe need to show pseudo code steps like:\n\nStart\n→ Step 1: Repeat\n→ Decision: 如果 rand7() generates a value? etc.\n\nBetter to outline:\n\nStart\n→ Step 1: Generate a 7-sided random number a ← rand7()\n→ Step 2: Generate a 7-sided random number b ← rand7()\n→ Step 3: Compute combined value: c ← (a-1)*7 + b   // range 1-49\n→ Decision: 如果 c ≤ 40? // Acceptable range\n   Yes → Step 4: 返回 (c-1) mod 10 + 1   // 1-10 uniform\n   No → Step 5: 重複 Step 1-4   // reject and restart\n\nBut we need to show loop structure: Maybe use while true. Also handle rejections. Use Decision for c <= 40.\n\nAlso we need to explain that because 49-40=9 values are rejected. Probability of rejection < 0.2. So expected iterations ~1.25.\n\nAlso we might implement a helper function to generate 2-digit numbers using rand7().\n\nLet's produce virtual code lines with arrows and explanations.\n\nMake sure each line ends with // explanation. Use arrow \"→\".\n\nAlso include Start, End.\n\nUse indentation for nested decisions: maybe show \"Decision:\" then indent for Yes/No.\n\nOk produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: a ← rand7() // 產生第一個 1~7 的隨機數  \n→ Step 2: b ← rand7() // 產生第二個 1~7 的隨機數  \n→ Step 3: c ← (a-1) * 7 + b // 組合成 1~49 的隨機數  \n→ Decision: c ≤ 40? // 只接受前 40 個數字（能均勻映射到 1~10）  \n Yes → Step 4: return (c-1) mod 10 + 1 // 轉換為 1~10 的均勻隨機數  \n No  → Step 5: 重新執行 Step 1-4 // 把 c > 40 的情況拋棄並重試  \nEnd // 程式執行結束"
    },
    {
      "title": "Count of Range Sum",
      "source_file": "Leetcode/leetcode327.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [-2,5,-1], lower = -2, upper = 2",
          "expected_output": "3",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpumqdrifp.py\", line 49, in <module>\n    main()\n  File \"/tmp/tmpumqdrifp.py\", line 44, in main\n    nums, lower, upper = parse_input(content)\n                         ^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpumqdrifp.py\", line 35, in parse_input\n    nums = ast.literal_eval(part.split('=', 1)[1].strip())\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [-2\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def countRangeSum(self, nums, lower, upper):\n        prefix = [0]\n        for num in nums:\n            prefix.append(prefix[-1] + num)\n\n        def sort_and_count(lo, hi):\n            if hi - lo <= 1:\n                return 0\n            mid = (lo + hi) // 2\n            count = sort_and_count(lo, mid) + sort_and_count(mid, hi)\n            i = j = mid\n            for left in prefix[lo:mid]:\n                while i < hi and prefix[i] - left < lower:\n                    i += 1\n                while j < hi and prefix[j] - left <= upper:\n                    j += 1\n                count += j - i\n            prefix[lo:hi] = sorted(prefix[lo:hi])\n            return count\n\n        return sort_and_count(0, len(prefix))\n\ndef parse_input(content: str):\n    \"\"\"解析輸入，支援 'nums = [...], lower = ..., upper = ...' 以及分行格式。\"\"\"\n    nums = []\n    lower = upper = 0\n    # 把換行都視為逗號分隔，方便統一處理\n    parts = [p.strip() for p in content.replace('\\n', ',').split(',') if p.strip()]\n    for part in parts:\n        if part.lower().startswith('nums'):\n            nums = ast.literal_eval(part.split('=', 1)[1].strip())\n        elif part.lower().startswith('lower'):\n            lower = int(part.split('=', 1)[1].strip())\n        elif part.lower().startswith('upper'):\n            upper = int(part.split('=', 1)[1].strip())\n    return nums, lower, upper\n\ndef main():\n    content = sys.stdin.read()\n    nums, lower, upper = parse_input(content)\n    result = Solution().countRangeSum(nums, lower, upper)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for the problem: count range sums within [lower, upper] inclusive, given integer array nums. We need to produce algorithm steps line by line, using virtual code with arrows, Decision etc.\n\nWe need to produce step-by-step algorithm, likely using prefix sums and divide and conquer / merge sort approach, or BIT. Provide explanation. We should not produce actual code. We need to output each line: \"虛擬碼步驟 // 解釋\". Use arrows and structure.\n\nWe need to include Start, End, Decision etc.\n\nLet's outline algorithm:\n\nStart\n→ Step 1: Compute prefix sums array pre of length n+1 with pre[0]=0, pre[i+1]=pre[i]+nums[i].\n→ Step 2: Define recursive function countRange(pre, left, right) that returns count and also sorts pre[left:right].\n→ Decision: if left+1 == right (single element)\n    Yes → Step 3: Return 0 // no subarray within single element? Actually count pairs? Might handle base case.\nBut maybe better to handle merging.\n\nThe merge sort approach: Count while merging two sorted halves.\n\nPseudo:\n\nFunction merge_sort_and_count(pre, left, right):\n    if left >= right: return 0\n    mid = (left+right)//2\n    count = merge_sort_and_count(pre, left, mid)\n    count += merge_sort_and_count(pre, mid+1, right)\n    # count cross sums\n    j=mid+1\n    k=mid+1\n    for i from left to mid:\n        while j <= right and pre[j] - pre[i] < lower: j+=1\n        while k <= right and pre[k] - pre[i] <= upper: k+=1\n        count += k - j\n    # merge two halves\n    temp = []\n    p1=left; p2=mid+1\n    while p1<=mid and p2<=right:\n        if pre[p1] <= pre[p2]: temp.append(pre[p1]); p1+=1\n        else: temp.append(pre[p2]); p2+=1\n    append remaining\n    copy temp back to pre[left:right]\n    return count\n\nFinally, call merge_sort_and_count(pre,0,len(pre)-1) and return count.\n\nLet's produce step by step in virtual code.\n\nWe need each line to have the arrow and explanation. Use Start, End, Decision. Provide each step sequentially.\n\nProbably need to break into high-level steps: Compute prefix sums; Call recursive count; Implementation of recursive function; Count cross; Merge; Return.\n\nWe can use indent to show nested structure.\n\nLet's generate.\n\nWe must not output actual code, just virtual steps.\n\nLet's craft lines:\n\nStart // 開始\n→ Step 1: 產生前綴和數組 pre，長度為 n+1 且 pre[0] = 0 // 建立前綴和\n→ Step 2: 定義遞迴函數 Count(pre, left, right) 以回傳跨段範圍和數量 // 設定遞迴\n→ Decision: 如果 left >= right? // 檢查是否單一元素\n    Yes → Step 3: 回傳 0 // 基礎情況，無子區間\n    No → Step 4: 計算 mid = (left+right)//2 // 切半\n        → Step 5: 左側計數 = Count(pre, left, mid) // 先遞迴左半\n        → Step 6: 右側計數 = Count(pre, mid+1, right) // 右半\n        → Step 7: 設定 crossCount = 0 // 初始跨段計數\n        → Step 8: 初始化指標 j = mid+1, k = mid+1 // 為兩個搜尋\n        → Step 9: 循環 i 從 left 到 mid\n            → Decision: 是否 j <= right 且 pre[j] - pre[i] < lower?\n                Yes → j += 1 // 找到首個使差值 >= lower\n                No  → ...\n            → Decision: 是否 k <= right 且 pre[k] - pre[i] <= upper?\n                Yes → k += 1 // 找到首個使差值 > upper\n                No  → ...\n            → Step 10: crossCount += k - j // 加入符合區間的數量\n        → Step 11: 合併兩個已排序的區間到 temp // 維持排序\n        → Step 12: 把 temp 拷貝回 pre[left:right] // 更新\n        → Step 13: 回傳 左側計數 + 右側計數 + crossCount // 返回總計\n→ Step 14: 執行 count = Count(pre, 0, len(pre)-1) // 呼叫遞迴\n→ Step 15: 回傳 count // 結果\nEnd // 結束\n\nWe need to maintain arrow formatting. Provide explanation for each line.\n\nMake sure to use arrow '→' after each line.\n\nAlso need to use indenting with spaces maybe 4 spaces for nested steps. Keep consistent.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 產生前綴和數組 pre，長度為 n+1 且 pre[0] = 0 // 建立前綴和，方便計算子陣列之和  \n→ Step 2: 定義遞迴函數 Count(pre, left, right) 以回傳跨段範圍和數量 // 設定遞迴邏輯  \n→ Decision: left >= right? // 檢查是否為單一元素區間  \n  Yes → Step 3: 回傳 0 // 基礎情況，無可組成子區間  \n  No → Step 4: 計算 mid = (left+right)//2 // 將區間分成兩半  \n   → Step 5: 左側計數 = Count(pre, left, mid) // 先遞迴處理左半段  \n   → Step 6: 右側計數 = Count(pre, mid+1, right) // 再處理右半段  \n   → Step 7: 設定 crossCount = 0 // 初始化跨段計數  \n   → Step 8: 初始化指標 j = mid+1, k = mid+1 // 用於搜尋符合條件的右半段索引  \n   → Step 9: 循環 i 從 left 到 mid  \n     → Decision: j <= right 且 pre[j] - pre[i] < lower?  \n       Yes → j += 1 // 找到第一個差值 ≥ lower 的右指標  \n       No → …  \n     → Decision: k <= right 且 pre[k] - pre[i] <= upper?  \n       Yes → k += 1 // 找到第一個差值 > upper 的右指標  \n       No → …  \n     → Step 10: crossCount += k - j // 累加所有符合 [lower, upper] 的區間數量  \n   → Step 11: 合併兩個已排序的區間到 temp // 保持 pre 的子區間排序  \n   → Step 12: 把 temp 拷貝回 pre[left:right] // 更新原前綴和陣列  \n   → Step 13: 回傳 左側計數 + 右側計數 + crossCount // 返回本層總計數  \n→ Step 14: 執行 count = Count(pre, 0, len(pre)-1) // 呼叫遞迴以獲得最終答案  \n→ Step 15: 回傳 count // 程式輸出結果  \nEnd // 程式執行結束"
    },
    {
      "title": "Expression Add Operators",
      "source_file": "Leetcode/leetcode282.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "num = \"123\", target = 6",
          "expected_output": "[\"1*2*3\",\"1+2+3\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"1*2*3\",\"1+2+3\"]'\nGot (Norm):      '[\"1+2+3\",\"1*2*3\"]'\n--- (Raw) ---\nRaw Expected: '[\"1*2*3\",\"1+2+3\"]'\nRaw Got:      \"['1+2+3', '1*2*3']\""
        },
        {
          "example_index": 1,
          "input": "num = \"232\", target = 8",
          "expected_output": "[\"2*3+2\",\"2+3*2\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"2*3+2\",\"2+3*2\"]'\nGot (Norm):      '[\"2+3*2\",\"2*3+2\"]'\n--- (Raw) ---\nRaw Expected: '[\"2*3+2\",\"2+3*2\"]'\nRaw Got:      \"['2+3*2', '2*3+2']\""
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def addOperators(self, num: str, target: int):\n        res = []\n\n        def backtrack(index: int, path: str, value: int, last: int):\n            if index == len(num):\n                if value == target:\n                    res.append(path)\n                return\n            for i in range(index + 1, len(num) + 1):\n                temp = num[index:i]\n                if len(temp) > 1 and temp[0] == '0':  # skip leading zeros\n                    continue\n                curr = int(temp)\n                if index == 0:\n                    backtrack(i, temp, curr, curr)\n                else:\n                    backtrack(i, path + '+' + temp, value + curr, curr)\n                    backtrack(i, path + '-' + temp, value - curr, -curr)\n                    backtrack(i, path + '*' + temp, value - last + last * curr, last * curr)\n\n        backtrack(0, '', 0, 0)\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    num_match = re.search(r'num\\s*=\\s*\"([^\"]+)\"', data)\n    target_match = re.search(r'target\\s*=\\s*(-?\\d+)', data)\n\n    if not num_match or not target_match:\n        sys.exit()\n\n    num_str = num_match.group(1)\n    target_val = int(target_match.group(1))\n\n    solution = Solution()\n    result = solution.addOperators(num_str, target_val)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for algorithm that finds all expressions inserting +,-,* between digits to evaluate to target. We must output in the format specified: each line \"虛擬碼步驟 // 解釋\". Use Start, End, Decision: etc. We should outline recursion/backtracking. Provide step-by-step lines. Should not output actual code. Provide explanations in Chinese. Include arrow. Use \"→\" for steps. Use \"Decision:\" for if statements. We should incorporate concept: DFS with parameters (pos, expr, value, prev). Provide logic. The virtual code lines might include loops, recursion call.\n\nWe need to produce \"逐行\" steps. We need to include Start, End, etc. Let's produce:\n\nStart // 程式開始執行\n→ Step 1: 定義回溯函式 dfs(position, expression, current_value, previous_operand) // 初始化回溯參數\n→ Step 2: 如果 position == len(num) // 所有位數已處理\n    → Decision: 如果 current_value == target? // 檢查結果是否符合目標\n        Yes → Step 3: 將 expression 加入結果列表 // 找到一個合法表達式\n        No  → Step 4: 返回 // 不符合目標，結束此路徑\n→ Step 5: 循環 i 從 position 到 len(num)-1 // 嘗試不同長度的數字子串\n    → Step 6: 取 substring num[position:i+1] 作為 next_num_str\n    → Decision: 如果 next_num_str 有前導零且長度>1? // 避免前導零\n        Yes → Step 7: 繼續 // 跳過此子串\n    → Step 8: 轉換 next_num_str 為長整數 next_num\n    → Decision: 如果 position == 0? // 第一個數字，不需要操作符\n        Yes → Step 9: dfs(i+1, next_num_str, next_num, next_num) // 初始表達式\n        No  → Step 10: Decision: 若加號? // 加號操作\n            Yes → Step 11: dfs(i+1, expression+\"+\"+next_num_str, current_value + next_num, next_num)\n            No  → Step 12: Decision: 若減號? // 減號操作\n                Yes → Step 13: dfs(i+1, expression+\"-\"+next_num_str, current_value - next_num, -next_num)\n                No  → Step 14: Decision: 若乘號? // 乘號操作\n                    Yes → Step 15: new_value = current_value - previous_operand + (previous_operand * next_num)\n                    → Step 16: dfs(i+1, expression+\"*\"+next_num_str, new_value, previous_operand * next_num)\n→ End // 程式執行結束\n\nBut we need to ensure each line includes arrow etc. Use \"→\" for steps. Use \"Decision:\" lines. Provide explanation. Each line must have \"虛擬碼步驟 // 解釋\". Use \"Start\" etc. Let's format accordingly. Also include initialization of results list and call dfs(0,\"\",0,0). Provide that as a step.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化結果列表 result = [] // 用於儲存所有符合目標的表達式  \n→ Step 2: 呼叫回溯函式 dfs(0, \"\", 0, 0) // 從字串開始位置啟動遞迴  \n\n→ Step 3: 定義回溯函式 dfs(position, expr, current, prev) // position: 目前處理的位置；expr: 已構造的表達式；current: 整體計算值；prev: 上一次運算的數字（用於乘法）  \n\n→ Decision: 如果 position == len(num) // 所有位數已處理  \n    Yes → Decision: 如果 current == target? // 檢查累積值是否符合目標  \n        Yes → Step 4: 將 expr 加入 result // 找到一個合法表達式，加入結果  \n        No  → Step 5: 返回 // 不符合目標，結束此路徑  \n    No  → Step 6: 循環 i 從 position 到 len(num)-1 // 嘗試不同長度的數字子串  \n\n→ Step 7: next_str = num[position:i+1] // 取得下一段數字  \n→ Decision: 如果 next_str 以 '0' 開頭且長度 > 1? // 防止前導零  \n    Yes → Step 8: 繼續 // 跳過此子串，進行下一次迭代  \n    No  → Step 9: next_val = 整數化(next_str) // 將子串轉為整數  \n\n→ Decision: 如果 position == 0? // 第一個數字，直接作為起始表達式  \n    Yes → Step 10: dfs(i+1, next_str, next_val, next_val) // 初始表達式，prev 設為該數字  \n    No  → Step 11: Decision: 若加號  \n        Yes → Step 12: dfs(i+1, expr + \"+\" + next_str, current + next_val, next_val) // 加法  \n        No  → Step 13: Decision: 若減號  \n            Yes → Step 14: dfs(i+1, expr + \"-\" + next_str, current - next_val, -next_val) // 減法  \n            No  → Step 15: Decision: 若乘號  \n                Yes → Step 16: new_current = current - prev + (prev * next_val) // 乘法需回溯 prev  \n                → Step 17: dfs(i+1, expr + \"*\" + next_str, new_current, prev * next_val) // 乘法  \n\nEnd // 程式執行結束，result 為所有符合目標的表達式集合"
    },
    {
      "title": "Time Based Key-Value Store",
      "source_file": "Leetcode/leetcode981.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"TimeMap\", \"set\", \"get\", \"get\", \"set\", \"get\", \"get\"], [[], [\"foo\", \"bar\", 1], [\"foo\", 1], [\"foo\", 3], [\"foo\", \"bar2\", 4], [\"foo\", 4], [\"foo\", 5]]",
          "expected_output": "[null, null, \"bar\", \"bar\", null, \"bar2\", \"bar2\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,\"bar\",\"bar\",null,\"bar2\",\"bar2\"]'\nGot (Norm):      '[null]'\n--- (Raw) ---\nRaw Expected: '[null, null, \"bar\", \"bar\", null, \"bar2\", \"bar2\"]'\nRaw Got:      '[null]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport bisect\nimport json\nfrom collections import defaultdict\n\nclass TimeMap:\n    def __init__(self):\n        # 每個 key 對應一個時間戳-值對的有序列表\n        self.store = defaultdict(list)\n\n    def set(self, key: str, value: str, timestamp: int):\n        # 直接把 (timestamp, value) 加到對應 key 的列表末尾\n        self.store[key].append((timestamp, value))\n\n    def get(self, key: str, timestamp: int) -> str:\n        # 若 key 不存在直接回傳空字串\n        if key not in self.store:\n            return \"\"\n        arr = self.store[key]\n        # bisect_right 找到第一個 > timestamp 的位置\n        i = bisect.bisect_right(arr, (timestamp, chr(127)))\n        if i == 0:          # 所有時間戳都大於目標時間\n            return \"\"\n        return arr[i-1][1]  # 回傳最近一次 <= timestamp 的值\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 解析輸入為兩個列表：ops 與 args\n    split_index = data.find('], [')\n    if split_index == -1:\n        # 如果輸入格式不符直接退出\n        sys.exit(0)\n    ops_str = data[:split_index + 2]\n    args_str = data[split_index + 3:]\n\n    ops = ast.literal_eval(ops_str)\n    args = ast.literal_eval(args_str)\n\n    res = []\n    obj = None\n\n    for op, arg in zip(ops, args):\n        if op == \"TimeMap\":\n            obj = TimeMap()\n            res.append(None)\n        elif op == \"set\":\n            obj.set(*arg)\n            res.append(None)\n        elif op == \"get\":\n            res.append(obj.get(*arg))\n        else:\n            # 若有未知操作，視為 None\n            res.append(None)\n\n    # 將結果轉成 JSON 格式輸出，None 會變成 null\n    print(json.dumps(res))",
      "virtual_code": "Thinking...\nWe need to output virtual code step by step explaining a time-based key-value store with set and get. Must use structure with Start, End, Decision, arrows. Provide explanation comments. Each line: \"虛擬碼步驟 // 解釋/說明\". No actual code. Use Start, End, Decision.\n\nWe'll produce steps: Initialize data structure: a map key -> list of (timestamp, value). For set: append to list. For get: binary search on timestamps <= target. Need to find largest timestamp <= target. If none, return empty. We'll express that.\n\nWe must ensure each line has \"→\" arrow or \"Yes →\" etc. Provide structure. Use indentation? Probably we use lines with appropriate indentation? Use tab? But it's fine.\n\nLet's produce: Start, → Step 1: Initialize empty map // etc. Use Decision: for get, find list exists? Yes -> binary search; No -> return \"\". Also Decision: if found? Yes -> return value else \"\". We'll show binary search logic. Provide explanation per line.\n\nOk produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空的哈希表 key_to_list // 用於儲存每個 key 對應的時間戳與值的序列  \n→ Step 2: 定義 class TimeMap // 建立時間鍵值資料結構的類別  \n    → Constructor: TimeMap() // 初始化物件時執行 Step 1  \n    → Method: set(String key, String value, int timestamp) // 存儲資料  \n        → Decision: key 是否已在 key_to_list? // 判斷 key 是否存在  \n            Yes → Step 3: 取得該 key 對應的 list // 取出已存在的時間戳序列  \n            No  → Step 4: 在 key_to_list 新增 key 並設為空 list // 新增 key  \n        → Step 5: 將 (timestamp, value) 附加到 list // 保持遞增時間順序  \n    → Method: get(String key, int timestamp) // 取回資料  \n        → Decision: key 是否存在於 key_to_list? // 找不到直接返回空字串  \n            Yes → Step 6: 取出該 key 的 list // 進行查詢  \n            No  → Step 7: 回傳 \"\" // 沒有此 key 的資料  \n        → Step 8: 在 list 中進行二分搜尋，尋找最大的 timestamp_prev ≤ timestamp  \n            → Decision: 是否找到合法的 timestamp_prev? // 若沒有則回傳空字串  \n                Yes → Step 9: 回傳對應的 value // 找到的最新值  \n                No  → Step 10: 回傳 \"\" // 以上時間之前無任何值  \nEnd // 程式執行結束"
    },
    {
      "title": "Wiggle Sort II",
      "source_file": "Leetcode/leetcode324.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,5,1,1,6,4]",
          "expected_output": "[1,6,1,5,1,4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[1,6,1,5,1,4]'\nGot (Norm):      '[1,1,1,5,4,6]'\n--- (Raw) ---\nRaw Expected: '[1,6,1,5,1,4]'\nRaw Got:      '[1,1,1,5,4,6]'"
        },
        {
          "example_index": 1,
          "input": "nums = [1,3,2,2,3,1]",
          "expected_output": "[2,3,1,3,1,2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,3,1,3,1,2]'\nGot (Norm):      '[1,2,1,3,2,3]'\n--- (Raw) ---\nRaw Expected: '[2,3,1,3,1,2]'\nRaw Got:      '[1,2,1,3,2,3]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def wiggleSort(self, nums):\n        \"\"\"Reorder nums into the pattern nums[0] < nums[1] > nums[2] < nums[3] ...\"\"\"\n        nums.sort()                          # 先升序排序\n        n = len(nums)\n        # 只需要交換每一對奇偶索引的相鄰元素\n        for i in range(1, n - 1, 2):\n            nums[i], nums[i + 1] = nums[i + 1], nums[i]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入: 可能是 \"nums = [1,5,1,1,6,4]\" 或僅是 \"[1,5,1,1,6,4]\"\n    if '=' in data:\n        _, rhs = data.split('=', 1)\n        nums = ast.literal_eval(rhs.strip())\n    else:\n        nums = ast.literal_eval(data)\n\n    Solution().wiggleSort(nums)\n\n    # 按題目示例格式輸出，無空格\n    print('[' + ','.join(map(str, nums)) + ']')\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for reorder array to wiggle pattern. We need to use Start, End, Decision, arrows. Each line: \"虛擬碼步驟 // 解釋\". Provide step-by-step algorithm, likely using sorting or two-pointer swap. Approach: sort array, then swap adjacent pairs from index 1 stepping 2. That yields wiggle. So virtual code: Start, Step: sort array, Step: for i from 1 to n-1 step 2, swap(nums[i], nums[i+1]) if i+1 < n. End. Also need decisions? We could include decision to check if i+1 < n. Use Decision. Provide clear explanation. Use arrows.\n\nLet's craft:\n\nStart\n→ Step 1: Sort nums ascending // 排序以確保元素有序\n→ Step 2: 將 i 設為 1 // 從第二個位置開始\n→ Decision: i < nums.length? // 迴圈條件\n    Yes → Step 3: 若 i+1 < nums.length? // 確保有下一個元素可交換\n        Yes → Step 4: Swap nums[i] 與 nums[i+1] // 交換相鄰兩個元素\n        No → Step 5: // 若沒有下一個元素，跳過交換\n    No → End // 迴圈結束\n→ Step 6: i = i + 2 // 移動到下一個奇數索引\n→ Decision: i < nums.length? // 回到決策點\n    Yes → 回到 Step 3\n    No → End\n\nBut we need to avoid loops structure with arrows? Use \"Loop\" or \"Decision\" repeated. Provide minimal. We'll produce a simpler pseudo.\n\nLet's produce:\n\nStart\n→ Step 1: Sort(nums) // 排序數組\n→ Step 2: i ← 1 // 初始化索引為第一個奇數位置\n→ Decision: i < nums.length? // 循環條件\n    Yes → Decision: i + 1 < nums.length? // 是否有可交換的下個元素\n        Yes → Step 3: Swap(nums[i], nums[i+1]) // 交換相鄰元素\n        No → // 無需交換\n    No → // 迴圈結束\n→ Step 4: i ← i + 2 // 移動到下一個奇數位置\n→ Decision: i < nums.length? // 回到循環起點\n    Yes → 回到 Step 3\n    No → End\n\nBut need each line step: maybe need \"→\" before each. Provide explanation after //.\n\nMake sure each line has \"虛擬碼步驟 // 解釋\". Provide arrow at beginning of step lines after Start. Use \"Decision:\" lines.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Sort(nums) // 先將陣列升序排列，方便後續交換\n→ Step 2: i ← 1 // 從第二個位置（索引1）開始，因為我們要交換相鄰的偶奇位置\n→ Decision: i < nums.length? // 迴圈判斷：若還有未處理的索引就繼續\n    Yes → Decision: i + 1 < nums.length? // 檢查是否存在可與之交換的下一個元素\n        Yes → Step 3: Swap(nums[i], nums[i+1]) // 交換相鄰兩個元素，形成 < > 模式\n        No → // 若已是最後一個元素，無需交換\n    No → // 迴圈結束\n→ Step 4: i ← i + 2 // 移動到下一個奇數索引，因為偶數索引已被交換過\n→ Decision: i < nums.length? // 回到循環起點\n    Yes → 回到 Step 3\n    No → End // 程式執行結束"
    },
    {
      "title": "Course Schedule II",
      "source_file": "Leetcode/leetcode210.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]",
          "expected_output": "[0,2,1,3]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[0,2,1,3]'\nGot (Norm):      '[0,1,2,3]'\n--- (Raw) ---\nRaw Expected: '[0,2,1,3]'\nRaw Got:      '[0, 1, 2, 3]'"
        }
      ],
      "generated_code": "import sys\nfrom collections import deque\n\nclass Solution:\n    def findOrder(self, numCourses, prerequisites):\n        # 建立鄰接清單與入度陣列\n        graph = [[] for _ in range(numCourses)]\n        indegree = [0] * numCourses\n\n        # 依據 prerequisites 建立圖\n        for dest, src in prerequisites:\n            graph[src].append(dest)\n            indegree[dest] += 1\n\n        # 以入度為 0 的課程作為起點\n        queue = deque([i for i in range(numCourses) if indegree[i] == 0])\n        order = []\n\n        # Kahn 的拓樸排序\n        while queue:\n            node = queue.popleft()\n            order.append(node)\n            for neighbor in graph[node]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    queue.append(neighbor)\n\n        # 若所有課程都能完成則回傳順序，否則回傳空列表\n        return order if len(order) == numCourses else []\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n\n    # 移除空白符號，方便解析\n    raw_input = raw_input.replace(\" \", \"\")\n\n    # 解析 numCourses 與 prerequisites\n    if raw_input:\n        parts = raw_input.split(\",prerequisites=\")\n        num_part = parts[0]\n        prereq_part = parts[1] if len(parts) > 1 else \"[]\"\n\n        # 去除前綴 'numCourses='\n        numCourses = int(num_part.replace(\"numCourses=\", \"\"))\n        # 轉換成 Python 物件\n        prerequisites = eval(prereq_part)\n\n        # 取得課程順序\n        result = Solution().findOrder(numCourses, prerequisites)\n        # 輸出結果\n        print(result)",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code for topological sorting to find order. Use BFS (Kahn's algorithm). Steps: build graph, indegree array, queue. While queue not empty, pop, add to order, decrement indegree of neighbors, if becomes 0 push. After loop if order size == numCourses return order else empty. Provide each line with explanation, using arrow etc.\n\nLet's produce virtual code lines. Use \"Start\" \"End\". Use arrows. Use Decision lines.\n\nWe need to output each line as:\n\nStart // ...\n→ Step 1: Initialize adjacency list and indegree array // ...\n→ Step 2: For each prerequisite pair (a,b) add edge b->a and indegree[a]++ // ...\n→ Step 3: Initialize queue with courses having indegree 0 // ...\n→ Step 4: While queue not empty // ...\n    → Step 5: Dequeue course cur // ...\n    → Step 6: Append cur to order // ...\n    → Step 7: For each neighbor next of cur // ...\n        → Step 8: Decrement indegree[next] // ...\n        → Decision: If indegree[next] == 0? // ...\n            Yes → Step 9: Enqueue next // ...\n        No → // nothing\n→ Decision: If order length == numCourses? // ...\n    Yes → Step 10: Return order // ...\n    No  → Step 11: Return empty array // ...\nEnd // end\n\nMake sure each line has arrow and explanation. For loops, we can use indentation. Use arrow symbol \"→\" for each step. For decision: \"Decision:\".\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立圖的鄰接清單 adj 及入度陣列 indegree，長度為 numCourses，並初始化為空列表與 0 // 準備儲存課程關係與入度  \n→ Step 2: 對於 prerequisites 中的每一對 [a, b]  \n  → Step 3: 在 adj[b] 加入 a，表示 b 必須先修再修 a  \n  → Step 4: indegree[a]++，更新 a 的入度  \n→ Step 5: 建立一個 FIFO 佇列 queue，將所有 indegree 為 0 的課程加入 // 這些課程無前置依賴  \n→ Step 6: 建立空列表 order 用來儲存可行的修課順序  \n→ Decision: queue 是否為空？  \n  Yes → End // 若無課程可立即修，直接結束  \n  No  → Step 7: 進入循環  \n    → Step 7: 從 queue 取出一門課 cur  \n    → Step 8: 將 cur 加入 order  \n    → Step 9: 對於 adj[cur] 中的每一門課 next  \n      → Step 10: indegree[next]--，因 cur 已完成  \n      → Decision: indegree[next] 是否為 0？  \n       Yes → Step 11: 將 next 加入 queue // 這門課已無剩餘前置課程  \n       No  → // 仍有其他前置課程未完成，暫不加入 queue  \n    → Step 12: 回到 Decision: queue 是否為空？  \n      Yes → // 佇列已清空，離開循環  \n      No  → Step 7 // 繼續處理下一門課  \n→ Decision: order.length 是否等於 numCourses？  \n  Yes → Step 13: 回傳 order // 找到一個有效的修課順序  \n  No  → Step 14: 回傳空陣列 [] // 依賴循環，無法完成所有課程  \nEnd // 程式執行結束"
    },
    {
      "title": "Generate Random Point in a Circle",
      "source_file": "Leetcode/leetcode478.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]",
          "expected_output": "[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[-0.02493,-0.38077],[0.82314,0.38945],[0.36572,0.17248]]'\nGot (Norm):      '[null,[0.45157,0.08785],[-0.66474,0.52476],[0.68687,0.27270]]'\n--- (Raw) ---\nRaw Expected: '[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]'\nRaw Got:      '[null, [0.45157, 0.08785], [-0.66474, 0.52476], [0.68687, 0.27270]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport math\n\nclass Solution:\n    def __init__(self, radius, x_center, y_center):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n\n    def randPoint(self):\n        # 使用極座標隨機生成點\n        r = self.radius * math.sqrt(random.random())  # sqrt 保證均勻分布\n        theta = random.uniform(0, 2 * math.pi)\n        x = self.x_center + r * math.cos(theta)\n        y = self.y_center + r * math.sin(theta)\n        return [x, y]\n\ndef main():\n    data = sys.stdin.read().splitlines()\n    if not data:\n        return\n    ops = json.loads(data[0])\n    args_list = json.loads(data[1])\n\n    instance = None\n    results = []\n\n    for op, args in zip(ops, args_list):\n        if op == \"Solution\":\n            instance = Solution(*args)\n            results.append(None)\n        elif op == \"randPoint\":\n            point = instance.randPoint()\n            results.append(point)\n        else:\n            # 若有其他操作，直接忽略或可自行擴充\n            results.append(None)\n\n    # 將結果轉成符合題目要求的輸出格式\n    def format_value(v):\n        if v is None:\n            return \"null\"\n        return \"[\" + \", \".join(f\"{x:.5f}\" for x in v) + \"]\"\n\n    output_str = \"[\" + \", \".join(format_value(r) for r in results) + \"]\"\n    print(output_str)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code. The requirement: implement class Solution with constructor and method randPoint that returns random point inside circle uniformly. Must produce step-by-step virtual code with arrows and explanations. No actual code, only pseudo steps. We need to describe steps: Start, constructor initialization, randPoint method: generate random radius using sqrt(random)*radius to ensure uniform distribution over area, generate random angle uniform [0, 2π), compute x, y offset, add center. Return [x, y]. End. Ensure each line with virtual code arrow and explanation. Use \"Start\" at top, \"End\" at bottom. For decisions we may not need decisions except maybe verifying conditions. But we can include Decision to handle maybe if random generation? Not needed.\n\nWe should output:\n\nStart // start\n→ Step 1: 定義 Solution 類別 // class definition\n→ Step 2: 定義建構子 Solution(radius, x_center, y_center) // initialize variables\n    → Assign radius to this.radius\n    → Assign x_center to this.x_center\n    → Assign y_center to this.y_center\n→ Step 3: 定義 randPoint() 方法 // method definition\n    → Decision: 若需要隨機數? // generate random\n        Yes → Step 4: 生成隨機數 r1 in [0,1) // uniform\n        Yes → Step 5: 計算半徑 r = sqrt(r1) * this.radius // uniform area\n        Yes → Step 6: 生成隨機數 r2 in [0,1) // uniform\n        Yes → Step 7: 計算角度 theta = r2 * 2π // uniform angle\n        Yes → Step 8: 計算點 x_offset = r * cos(theta) // offset\n        Yes → Step 9: 計算點 y_offset = r * sin(theta) // offset\n        Yes → Step 10: 計算實際 x = this.x_center + x_offset // add center\n        Yes → Step 11: 計算實際 y = this.y_center + y_offset // add center\n        Yes → Step 12: 返回 [x, y] // return result\nEnd // 程式結束\n\nWe need to use the format: each line \"虛擬碼步驟 [空格] // 解釋\". Use arrows '→' for steps. Use 'Decision:' with indent. Indentation maybe not required but can be shown.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 Solution 類別 // 宣告類別  \n→ Step 2: 定義建構子 Solution(radius, x_center, y_center) // 初始化參數  \n  → Step 2.1: this.radius ← radius // 儲存半徑  \n  → Step 2.2: this.x_center ← x_center // 儲存中心 X 坐標  \n  → Step 2.3: this.y_center ← y_center // 儲存中心 Y 坐標  \n→ Step 3: 定義 randPoint() 方法 // 產生隨機點  \n  → Decision: 是否產生隨機數? // 必須產生兩個隨機數  \n    Yes → Step 4: r1 ← UniformRandom(0,1) // 第一個隨機數（0~1）  \n    Yes → Step 5: r ← sqrt(r1) * this.radius // 轉換成均勻分布半徑  \n    Yes → Step 6: r2 ← UniformRandom(0,1) // 第二個隨機數（0~1）  \n    Yes → Step 7: theta ← r2 * 2π // 隨機角度（0~2π）  \n    Yes → Step 8: x_offset ← r * cos(theta) // X 偏移量  \n    Yes → Step 9: y_offset ← r * sin(theta) // Y 偏移量  \n    Yes → Step 10: x ← this.x_center + x_offset // 加上中心坐標  \n    Yes → Step 11: y ← this.y_center + y_offset // 加上中心坐標  \n    Yes → Step 12: return [x, y] // 回傳隨機點  \nEnd // 程式執行結束"
    },
    {
      "title": "Remove Element",
      "source_file": "Leetcode/leetcode27.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "nums = [0,1,2,2,3,0,4,2], val = 2",
          "expected_output": "5, nums = [0,1,4,0,3,_,_,_]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '5,nums=[0,1,4,0,3,_,_,_]'\nGot (Norm):      '5,nums=[0,1,3,0,4,_,_,_]'\n--- (Raw) ---\nRaw Expected: '5, nums = [0,1,4,0,3,_,_,_]'\nRaw Got:      '5, nums = [0,1,3,0,4,_,_,_]'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def removeElement(self, nums, val):\n        \"\"\"\n        移除 nums 中所有等於 val 的元素，並返回剩餘元素的數量 k。\n        \"\"\"\n        slow = 0\n        for fast in range(len(nums)):\n            if nums[fast] != val:\n                nums[slow] = nums[fast]\n                slow += 1\n        return slow\n\ndef parse_input(input_str):\n    \"\"\"\n    從類似 'nums = [3,2,2,3], val = 3' 的字串中提取 nums 與 val。\n    \"\"\"\n    pattern = r'nums\\s*=\\s*(\\[[^\\]]*\\])\\s*,?\\s*val\\s*=\\s*(-?\\d+)'\n    match = re.search(pattern, input_str, re.IGNORECASE)\n    if not match:\n        raise ValueError(\"輸入格式錯誤，無法解析\")\n    nums_str, val_str = match.group(1), match.group(2)\n    nums = eval(nums_str)           # 轉成 list\n    val = int(val_str)\n    return nums, val\n\ndef format_output(nums, k):\n    \"\"\"\n    將結果格式化成 'k, nums = [elem1,elem2,_,_]' 的字串。\n    未使用的元素以 '_' 取代。\n    \"\"\"\n    parts = []\n    for i in range(len(nums)):\n        if i < k:\n            parts.append(str(nums[i]))\n        else:\n            parts.append('_')\n    return f\"{k}, nums = [{','.join(parts)}]\"\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    # 解析輸入\n    nums, val = parse_input(raw_input)\n\n    # 執行核心邏輯\n    sol = Solution()\n    k = sol.removeElement(nums, val)\n\n    # 輸出結果\n    print(format_output(nums, k))",
      "virtual_code": "Thinking...\nWe need to produce virtual code for problem: remove element in array in-place, returning k. Use two-pointer method: iterate, keep write index. Provide step-by-step virtual code with comments. Output must be line by line, with arrow, start, end, decision. Let's craft:\n\nStart\n→ Step 1: 初始化 writeIndex 為 0 // writeIndex 用於放置非 val 元素\n→ Step 2: 循環遍歷 nums 的每個元素 i // 逐個檢查\n    → Decision: 如果 nums[i] != val? // 判斷是否不是要刪除的值\n        Yes → Step 3: nums[writeIndex] = nums[i] // 把非 val 元素寫到 writeIndex\n        Yes → Step 4: writeIndex += 1 // 移動寫入指標\n        No  → (不做任何操作) // 如果是 val，跳過\n→ Step 5: 返回 writeIndex // writeIndex 為剩餘元素數量 k\nEnd\n\nAdd more explanatory comments. Each line with // explanation. Use arrows. The Decision lines must have Yes/No branches. We need to show the No branch (maybe just comment). Format must match spec: \"虛擬碼步驟\" + space + \"// 解釋\". Let's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 writeIndex 為 0 // writeIndex 用於記錄下一個非 val 元素寫入的位置  \n→ Step 2: 循環遍歷 nums 的每個元素 i // 逐個檢查每個元素  \n  → Decision: 如果 nums[i] != val? // 判斷當前元素是否不是要移除的值  \n   Yes → Step 3: nums[writeIndex] = nums[i] // 把非 val 元素寫到 writeIndex 所指的位置  \n   Yes → Step 4: writeIndex += 1 // 移動寫入指標，準備寫入下一個非 val 元素  \n   No  → Step 5: (不做任何操作) // 若為 val，直接跳過  \n→ Step 6: 返回 writeIndex // writeIndex 即為 k，剩餘非 val 元素的個數  \nEnd // 程式執行結束"
    },
    {
      "title": "Count Numbers with Unique Digits",
      "source_file": "Leetcode/leetcode357.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 2",
          "expected_output": "91",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '91'\nGot (Norm):      '101'\n--- (Raw) ---\nRaw Expected: '91'\nRaw Got:      '101'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def countNumbersWithUniqueDigits(self, n: int) -> int:\n        # 如果 n 為 0，只有 0 這一個數字\n        if n == 0:\n            return 1\n        # 超過 10 位數不能再有全不同的數字\n        n = min(n, 10)\n\n        total = 1          # 包含 0\n        count = 10         # 1 位數的數量\n        total += count     # 加入 1 位數\n\n        if n == 1:\n            return total\n\n        # 之後的每一位\n        available = 9\n        for _ in range(2, n + 1):\n            count *= available   # 本位數的排列數\n            total += count       # 累加到總數\n            available -= 1       # 下一位剩餘可用的數字\n        return total\n\ndef main():\n    data = sys.stdin.read()\n    # 從輸入中找出第一個整數\n    match = re.search(r'-?\\d+', data)\n    if not match:\n        return\n    n = int(match.group())\n    solution = Solution()\n    result = solution.countNumbersWithUniqueDigits(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode (virtual code) for this problem: count numbers with unique digits from 0 to 10^n - 1. The known solution: use counting permutations. For n=1, answer 10. For n>10, maximum unique digits is 10. For each length k from 1 to n: count permutations: 10 * 9 * ... (10-k+1). For n=0, answer 1 (empty number? Actually count of numbers with 0 <= x < 10^0 = 1: only 0). So algorithm: if n == 0 return 1. Else: total = 10 (for length 1) ; then for k=2 to n: count += 9 * P(9, k-1). Where P(9, k-1) = 9 * 8 * ... (10 - (k-1)). Implementation in pseudocode.\n\nWe need to output line by line with explanation. Use Start, End, Decision, etc. Provide virtual code steps. We'll incorporate loops and decisions.\n\nLet's produce something like:\n\nStart\n→ Step 1: Input integer n // 取得 n\n→ Decision: n == 0? // 檢查 n 是否為 0\n    Yes → Step 2: Return 1 // 只有 0\n    No  → Decision: n > 10? // 若 n 大於 10，實際最大長度為 10\n        Yes → Step 3: Set n = 10 // 限制到 10\n        No  → Step 3: Do nothing\n→ Step 4: Set total = 10 // 第一位數 0-9\n→ Step 5: Set available = 9 // 第二位可選的數字個數\n→ Decision: n == 1? // 如果 n 只到 1 位\n    Yes → Step 6: Return total // 回傳 10\n    No  → Step 7: Set currentCount = 9 // 第二位數的排列開始\n→ Decision: n >= 2? // 若 n 至少 2\n    Yes → Loop i from 2 to n\n        → Step 8: Set total = total + currentCount // 加入本位數量\n        → Step 9: Set available = available - 1 // 下一位剩餘可選數\n        → Step 10: Set currentCount = currentCount * available // 更新排列數\n    No  → Step 7 // 跳過迴圈\n→ Step 11: Return total // 結果\nEnd\n\nBut we need to be more precise: For each length k, count = 9 * P(9, k-1). We can compute iteratively.\n\nSimpler: Start with total = 1 // count 0 (0-digit number). Then for i=1 to n: if i==1: count = 10 else count = count * (10-i+1). Actually known formula: total += 10 * P(9, i-1). Implementation:\n\nInitialize total = 1 // count zero\nSet count = 10 // count for length 1\nIf n>=1: total += count\nFor i from 2 to n:\n    count = count * (10 - i + 1) // multiply by remaining digits\n    total += count\n\nBut we should account n>10: break at i=10 because cannot have more unique digits.\n\nLet's produce final pseudocode.\n\nMake sure each line has \"虛擬碼步驟\" followed by // 解釋.\n\nUse arrow \"→\" for steps. For loops: \"Loop i from 2 to n\".\n\nWe'll include Decision and Yes/No.\n\nLet's write.\n\nStart // 程式開始執行\n→ Step 1: Input integer n // 取得使用者輸入的 n\n→ Decision: n == 0? // 檢查 n 是否為 0\n    Yes → Step 2: Return 1 // 只有數字 0，回傳 1\n    No  → Step 3: Decision: n > 10? // 若 n 大於 10，最多只能 10 位\n        Yes → Step 4: Set n = 10 // 限制 n 為 10\n        No  → Step 4: // 直接使用輸入的 n\n→ Step 5: Set total = 1 // 先算 0 的情況\n→ Step 6: Set count = 10 // 1 位數的排列數\n→ Decision: n >= 1? // 若 n 至少 1 位\n    Yes → Step 7: total = total + count // 加入 1 位數\n    No  → Step 7: // 不做任何事\n→ Decision: n <= 1? // 若 n 只到 1 位，結束\n    Yes → Step 8: Return total // 回傳結果\n    No  → Step 9: Set remaining = 9 // 第二位可用的數字數\n→ Step 10: Loop i from 2 to n // 依次計算 2 到 n 位數\n    → Step 11: count = count * remaining // 更新本位數的排列數\n    → Step 12: total = total + count // 累加到總數\n    → Step 13: remaining = remaining - 1 // 下一位剩下的可用數字\n→ Step 14: Return total // 程式結束，回傳結果\nEnd // 程式結束執行\n\nCheck lines: step numbers but not necessary. They should be consistent.\n\nMake sure we use \"→\" at start of each step after decisions.\n\nAlso we need to include \"Decision:\" lines with Yes →, No →.\n\nMake sure each line is exactly \"虛擬碼步驟\" + space + \"// 解釋\".\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Input integer n // 取得使用者輸入的 n  \n→ Decision: n == 0? // 檢查 n 是否為 0  \n    Yes → Step 2: Return 1 // 只有數字 0，回傳 1  \n    No  → Decision: n > 10? // 若 n 大於 10，最多只能 10 位  \n        Yes → Step 3: Set n = 10 // 限制 n 為 10  \n        No  → Step 3: // 直接使用輸入的 n  \n→ Step 4: Set total = 1 // 先算 0 的情況  \n→ Step 5: Set count = 10 // 1 位數的排列數  \n→ Decision: n >= 1? // 若 n 至少 1 位  \n    Yes → Step 6: total = total + count // 加入 1 位數  \n    No  → Step 6: // 不做任何事  \n→ Decision: n <= 1? // 若 n 只到 1 位，結束  \n    Yes → Step 7: Return total // 回傳結果  \n    No  → Step 7: Set remaining = 9 // 第二位可用的數字數  \n→ Step 8: Loop i from 2 to n // 依次計算 2 到 n 位數  \n    → Step 9: count = count * remaining // 更新本位數的排列數  \n    → Step 10: total = total + count // 累加到總數  \n    → Step 11: remaining = remaining - 1 // 下一位剩下的可用數字  \n→ Step 12: Return total // 程式結束，回傳結果  \nEnd // 程式結束執行"
    },
    {
      "title": "Ones and Zeroes",
      "source_file": "Leetcode/leetcode474.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "strs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m = 5, n = 3",
          "expected_output": "4",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '4'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: '4'\nRaw Got:      '2'"
        },
        {
          "example_index": 1,
          "input": "strs = [\"10\",\"0\",\"1\"], m = 1, n = 1",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '1'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def findMaxForm(self, strs, m, n):\n        # dp[i][j] 表示使用 i 個 0 和 j 個 1 能形成的最大字串數\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n        for s in strs:\n            zeros = s.count('0')\n            ones = s.count('1')\n            # 逆序遍歷，避免重複使用同一個字串\n            for i in range(m, zeros - 1, -1):\n                for j in range(n, ones - 1, -1):\n                    dp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1)\n        return dp[m][n]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 取得所有雙引號內的字串作為 strs\n    strs = re.findall(r'\"(.*?)\"', data)\n    # 取得所有整數，假設第一個是 m，第二個是 n\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    if len(nums) < 2:\n        return\n    m, n = nums[0], nums[1]\n\n    ans = Solution().findMaxForm(strs, m, n)\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps with explanation. It's dynamic programming typical. We'll produce steps: Start, initialize DP array of size (m+1)x(n+1) zero. Iterate each string, count zeros and ones. For each i from m down to zeros, for each j from n down to ones: dp[i][j] = max(dp[i][j], dp[i-zeros][j-ones]+1). After processing all strings, answer is dp[m][n]. End. Also maybe output subset size. Provide explanation per line.\n\nNeed to produce virtual code with arrow and indentation for decisions? Not necessary. Just sequential steps. Use Start End and arrow.\n\nWe'll produce lines:\n\nStart // 程式開始\n\n→ Step 1: 初始化 dp 表為 0 // 創建 (m+1)x(n+1) 的 2D 數組，所有值設為 0\n\n→ Step 2: 迭代 strs 中每個字串 // 對於每個字串進行處理\n\n→ Step 3: 計算 current string 的 0 數與 1 數 // 計算 zeros、ones\n\n→ Step 4: 內層迴圈: i 從 m 降至 zeros // 避免重複計算\n\n→ Step 5: 內層迴圈: j 從 n 降至 ones\n\n→ Step 6: dp[i][j] = max(dp[i][j], dp[i-zeros][j-ones] + 1) // 更新 DP 值\n\nAfter loops:\n\n→ Step 7: 返回 dp[m][n] // 最終答案\n\nEnd.\n\nWe also need to show Decision arrows? Not necessary.\n\nBut the requirement uses Decision lines for conditions. In step 4, we might have a decision: if i >= zeros? but we loop from m to zeros, so no decision needed. We can use Decision: if i >= zeros? But we are iterating.\n\nBetter to follow simple arrow.\n\nAlso we can include Decision: if zeros <= m? maybe for skipping strings that exceed. Let's add step:\n\n→ Decision: if zeros > m or ones > n → Skip this string // 字串超出限制\n\nThis will be included.\n\nLet's produce final virtual code with each line: \"Start // ...\".\n\nMake sure each line includes the virtual code step, a space, then comment. Use arrow \"→\". Use indentation for nested steps? The sample uses indentation for decisions. We can indent Decision steps.\n\nWe'll produce:\n\nStart // 程式開始\n→ Step 1: 初始化 dp 表為 0 // 創建 (m+1)×(n+1) 的 2D 數組，所有值設為 0\n→ Step 2: 迭代 strs 中每個字串 // 對於每個字串進行處理\n    → Decision: 如果字串的 0 數 > m 或 1 數 > n? // 超出總量，無法加入\n        Yes → Step 3: 跳過此字串 // 直接繼續下一個字串\n        No  → Step 4: 計算 zeros 與 ones // 正常情況\n→ Step 5: 內層迴圈: i 從 m 降至 zeros // 避免重複使用同一字串\n    → Step 6: 內層迴圈: j 從 n 降至 ones\n        → Step 7: dp[i][j] = max(dp[i][j], dp[i-zeros][j-ones] + 1) // 更新子問題答案\n→ Step 8: 返回 dp[m][n] // 最終答案\nEnd // 程式執行結束\n\nBut each line must be separate. Indentation lines may count as separate lines. So we need each line separately.\n\nWe must maintain formatting: Each line includes arrow and text.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始\n→ Step 1: 初始化 dp 表為 0 // 創建 (m+1)×(n+1) 的 2D 數組，所有值設為 0\n→ Step 2: 迭代 strs 中每個字串 // 對於每個字串進行處理\n    → Decision: 如果字串的 0 數 > m 或 1 數 > n? // 超出總量，無法加入\n        Yes → Step 3: 跳過此字串 // 直接繼續下一個字串\n        No  → Step 4: 計算 zeros 與 ones // 正常情況\n→ Step 5: 內層迴圈: i 從 m 降至 zeros // 避免重複使用同一字串\n    → Step 6: 內層迴圈: j 從 n 降至 ones\n        → Step 7: dp[i][j] = max(dp[i][j], dp[i-zeros][j-ones] + 1) // 更新子問題答案\n→ Step 8: 返回 dp[m][n] // 最終答案\nEnd // 程式執行結束"
    },
    {
      "title": "Shuffle an Array",
      "source_file": "Leetcode/leetcode384.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"], [[[1, 2, 3]], [], [], []]",
          "expected_output": "[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[3,1,2],[1,2,3],[1,3,2]]'\nGot (Norm):      '[null,[1,2,3],[2,3,1],[2,3,1]]'\n--- (Raw) ---\nRaw Expected: '[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]'\nRaw Got:      '[null, [1, 2, 3], [2, 3, 1], [2, 3, 1]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\n\nclass Solution:\n    \"\"\"隨機打亂數組的類別。\"\"\"\n\n    def __init__(self, nums):\n        \"\"\"\n        初始化，保存原始陣列的副本，並建立可變副本作為工作陣列。\n        :param nums: 初始整數陣列\n        \"\"\"\n        self.original = list(nums)  # 原始陣列的不可變副本\n        self.nums = list(nums)      # 可變副本，用於 reset / shuffle\n\n    def reset(self):\n        \"\"\"\n        將陣列重置為原始順序，並回傳。\n        :return: 重置後的陣列\n        \"\"\"\n        self.nums = list(self.original)\n        return self.nums\n\n    def shuffle(self):\n        \"\"\"\n        隨機打亂陣列，採用 Fisher-Yates 洗牌演算法，並回傳。\n        :return: 隨機打亂後的陣列\n        \"\"\"\n        n = len(self.nums)\n        for i in range(n):\n            j = random.randint(i, n - 1)\n            self.nums[i], self.nums[j] = self.nums[j], self.nums[i]\n        return self.nums\n\n\ndef parse_input(data: str):\n    \"\"\"\n    將整個輸入字串解析成兩個列表：commands 和 arguments。\n    支援「一行」或「兩行」的輸入格式。\n    \"\"\"\n    data = data.strip()\n    if not data:\n        return [], []\n\n    # 先嘗試以換行符分割\n    parts = data.splitlines()\n    if len(parts) >= 2:\n        cmd_part, arg_part = parts[0], parts[1]\n    else:\n        # 只有一行，必須自行找到兩個 JSON 陣列之間的逗號\n        s = parts[0]\n        depth = 0\n        sep = None\n        for i, ch in enumerate(s):\n            if ch == '[':\n                depth += 1\n            elif ch == ']':\n                depth -= 1\n            elif ch == ',' and depth == 0:\n                sep = i\n                break\n        if sep is None:\n            raise ValueError(\"輸入格式錯誤\")\n        cmd_part = s[:sep]\n        arg_part = s[sep + 1:]\n\n    commands = json.loads(cmd_part)\n    arguments = json.loads(arg_part)\n    return commands, arguments\n\n\ndef main():\n    input_data = sys.stdin.read()\n    commands, args = parse_input(input_data)\n\n    results = []\n    obj = None\n    for cmd, arg in zip(commands, args):\n        if cmd == \"Solution\":\n            # arg 為 [[1,2,3]] 形式，取第一個元素作為 nums\n            obj = Solution(arg[0])\n            results.append(None)\n        elif cmd == \"reset\":\n            results.append(obj.reset())\n        elif cmd == \"shuffle\":\n            results.append(obj.shuffle())\n        else:\n            raise ValueError(f\"未知的命令: {cmd}\")\n\n    # 使用 json.dumps 以得到 null 代替 None\n    print(json.dumps(results))\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the algorithm: The algorithm is to shuffle an array using Fisher-Yates. We need to produce step-by-step pseudo-code for a class with constructor, reset, shuffle. Provide each line with \"→\" arrow. Provide comments. Also include Start and End. The steps inside methods. Let's craft.\n\nThe virtual code should use Decision, etc. For shuffle: For i from 0 to n-1: pick random j from i to n-1; swap arr[i], arr[j]. For reset: return copy of original.\n\nLet's produce a structured pseudo-code: Start // program start, but we can start with class.\n\nWe might need to represent the initialization of the Solution object. So:\n\nStart // 程式開始執行\n\n→ Step 1: 定義類別 Solution // 定義 Solution 類別\n\n→ Step 2: 宣告變數 numsCopy, originalNums // 用於儲存原始陣列副本\n\n→ Step 3: 定義建構子 Solution(int[] nums) // 初始化物件\n\n    → Step 3.1: originalNums ← nums // 儲存原始陣列參考\n\n    → Step 3.2: numsCopy ← 複製 nums // 創建可變副本\n\n→ Step 4: 定義方法 reset() // 重置陣列\n\n    → Step 4.1: numsCopy ← 複製 originalNums // 還原為原始\n\n    → Step 4.2: return numsCopy // 回傳重置後陣列\n\n→ Step 5: 定義方法 shuffle() // 隨機打亂陣列\n\n    → Step 5.1: n ← 長度 numsCopy // 取得陣列長度\n\n    → Decision: n 是否 > 0? // 確認陣列非空\n\n        → Yes → for i from 0 to n-1 // 逐個位置\n\n            → Step 5.2: j ← 隨機數 i~n-1 // 隨機選擇 j\n\n            → Step 5.3: swap numsCopy[i] 與 numsCopy[j] // 交換\n\n        → No → // 若空陣列，直接返回\n\n    → Step 5.4: return numsCopy // 回傳打亂後陣列\n\nEnd // 程式結束\n\nBut we need to maintain arrow lines with \"→\". For nested, we can indent? The format example uses indentation by spaces.\n\nLet's produce.\n\nAlso need to ensure each line includes explanation after //.\n\nMake sure to start with \"Start\". Then \"→\" for each line. We can use \"→ Step X:\" etc. Provide decisions.\n\nWe should include \"Decision:\" lines.\n\nOk produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類別 Solution // 建立 Solution 類別  \n→ Step 2: 宣告兩個陣列變數 originalNums, numsCopy // originalNums 儲存原始陣列，numsCopy 用於操作  \n→ Step 3: 定義建構子 Solution(int[] nums) // 物件初始化  \n → Step 3.1: originalNums ← nums // 把傳入陣列參考存入 originalNums  \n → Step 3.2: numsCopy ← 複製 originalNums // 建立一份可變副本供後續使用  \n→ Step 4: 定義方法 reset() // 重置陣列回原始順序  \n → Step 4.1: numsCopy ← 複製 originalNums // 還原 numsCopy 為原始陣列  \n → Step 4.2: return numsCopy // 回傳重置後的陣列  \n→ Step 5: 定義方法 shuffle() // 隨機打亂陣列  \n → Step 5.1: n ← 長度 numsCopy // 取得陣列長度  \n → Decision: n > 0? // 檢查陣列是否為空  \n  Yes → for i from 0 to n-1 // 逐個位置進行交換  \n   → Step 5.2: j ← 隨機數 i~n-1 // 隨機選擇 j 的索引  \n   → Step 5.3: swap numsCopy[i] 與 numsCopy[j] // 交換元素  \n  No  → // 若陣列為空，直接跳過  \n → Step 5.4: return numsCopy // 回傳打亂後的陣列  \nEnd // 程式執行結束"
    },
    {
      "title": "Subsets",
      "source_file": "Leetcode/leetcode78.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nGot (Norm):      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nRaw Got:      '[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]'"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef subsets(nums):\n    \"\"\"Return all possible subsets of the unique-element list `nums`.\"\"\"\n    res = []\n\n    def backtrack(start, path):\n        # Add a copy of the current subset\n        res.append(path[:])\n        # Try adding each remaining element to the subset\n        for i in range(start, len(nums)):\n            path.append(nums[i])          # include nums[i]\n            backtrack(i + 1, path)        # recurse\n            path.pop()                    # backtrack: remove nums[i]\n\n    backtrack(0, [])\n    return res\n\ndef main():\n    # Read entire input from stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Extract the list literal from the input string\n    match = re.search(r'\\[.*\\]', data, re.S)\n    if match:\n        nums = eval(match.group(0))\n    else:\n        nums = []\n\n    result = subsets(nums)\n    # Print the result in Python list format\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line, with explanation comments, following the format. Should describe algorithm for generating subsets: typical backtracking recursion or iterative method.\n\nWe must not output actual code, only virtual steps with arrows. Use Start, End, Decision, Yes/No arrows. Provide explanation after //.\n\nSo we can produce steps:\n\nStart\n→ Initialize result list\n→ Call backtrack(startIndex=0, currentSubset=[])\n→ Decision: if startIndex == len(nums) → Yes → add currentSubset to result\n→ No → For each i from startIndex to len(nums)-1\n    → Add nums[i] to currentSubset\n    → Recursively call backtrack(i+1, currentSubset)\n    → Remove last element from currentSubset (backtrack)\n→ End\n\nExplain each step.\n\nWe need to make sure it's line-by-line.\n\nWe should include the recursion function as a virtual step.\n\nWe'll include indentation maybe? The format example uses indentation with decisions. Use tab or space indentation.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Initialize result list to store all subsets // 建立結果容器  \n→ Define backtrack(startIndex, currentSubset) // 定義遞迴函式  \n → Decision: 是否已經處理完所有元素? // 判斷是否到達結尾  \n  Yes → Add a copy of currentSubset to result // 把目前的子集加入結果  \n  No  → For i from startIndex to length(nums)-1 // 逐一嘗試每個剩餘元素  \n    → Add nums[i] to currentSubset // 把元素加入目前子集  \n    → Call backtrack(i+1, currentSubset) // 進入下一層遞迴  \n    → Remove last element from currentSubset // 回溯，移除剛加入的元素  \n→ Call backtrack(0, empty list) // 從第一個元素開始遞迴  \nEnd // 程式執行結束，返回結果集"
    },
    {
      "title": "Task Scheduler",
      "source_file": "Leetcode/leetcode621.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 2",
          "expected_output": "8",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '8'\nGot (Norm):      '10'\n--- (Raw) ---\nRaw Expected: '8'\nRaw Got:      '10'"
        },
        {
          "example_index": 2,
          "input": "tasks = [\"A\",\"A\",\"A\", \"B\",\"B\",\"B\"], n = 3",
          "expected_output": "10",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '10'\nGot (Norm):      '12'\n--- (Raw) ---\nRaw Expected: '10'\nRaw Got:      '12'"
        }
      ],
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\nclass Solution:\n    def leastInterval(self, tasks, n):\n        # Count the frequency of each task\n        task_counts = Counter(tasks)\n        # Find the maximum frequency\n        max_freq = max(task_counts.values())\n        # Count how many tasks have the maximum frequency\n        max_count = sum(1 for count in task_counts.values() if count == max_freq)\n        # Calculate the minimal number of intervals\n        parts = max_freq - 1\n        empty_slots = parts * n\n        available_tasks = len(tasks) - max_freq * max_count\n        idles = max(0, empty_slots - available_tasks)\n        return len(tasks) + idles\n\ndef parse_input(input_str: str):\n    \"\"\"\n    Parses the input string of the form:\n    tasks = [\"A\",\"A\",\"B\"], n = 2\n    and returns a tuple (tasks_list, n_value).\n    \"\"\"\n    # Extract the list of tasks\n    tasks_match = re.search(r'tasks\\s*=\\s*(\\[[^\\]]*\\])', input_str)\n    # Extract the integer n\n    n_match = re.search(r'n\\s*=\\s*(-?\\d+)', input_str)\n    if not tasks_match or not n_match:\n        raise ValueError(\"Input format is incorrect.\")\n    tasks_str = tasks_match.group(1)\n    n_str = n_match.group(1)\n    # Evaluate the list safely (the list contains only strings)\n    tasks = eval(tasks_str, {\"__builtins__\": None}, {})\n    n = int(n_str)\n    return tasks, n\n\ndef main():\n    # Read the entire input\n    input_data = sys.stdin.read().strip()\n    if not input_data:\n        return\n    # Parse tasks and n from input\n    tasks, n = parse_input(input_data)\n    # Compute the result\n    solution = Solution()\n    result = solution.leastInterval(tasks, n)\n    # Output the result\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need produce virtual code for scheduling CPU tasks with cooling interval n. The algorithm: count frequencies, find max frequency, count how many tasks have that max freq, compute parts = maxFreq - 1, emptySlots = parts * n, availableTasks = totalTasks - maxFreq * maxCount, idles = max(0, emptySlots - availableTasks). totalIntervals = totalTasks + idles. That's known solution. We produce virtual code line by line with explanations, using arrows and decision etc. Must not output real code. Use virtual code steps. Provide each line with explanation after //.\n\nLet's craft:\n\nStart\n→ Step 1: Build frequency map of tasks // Count how many times each letter appears\n→ Step 2: Find maxFreq and number of tasks with maxFreq // Determine the most frequent task(s)\n→ Step 3: Compute parts = maxFreq - 1 // Number of full cycles excluding the last occurrence\n→ Step 4: Compute emptySlots = parts * n // Spaces that need to be filled by other tasks or idle\n→ Step 5: Compute availableTasks = totalTasks - (maxFreq * maxCount) // Remaining tasks that can fill slots\n→ Decision: 如果 availableTasks >= emptySlots? // Check if all empty slots can be filled\n    Yes → Step 6: idles = 0 // No idle time needed\n    No  → Step 7: idles = emptySlots - availableTasks // Idle intervals needed\n→ Step 8: totalIntervals = totalTasks + idles // Sum tasks and idle times\nEnd\n\nWe need to use arrow formatting as specified. Should include spaces. Use \"Decision:\" with \"Yes →\" \"No →\" lines. Use \"Start\" and \"End\". Provide explanations after //.\n\nMake sure each line has one virtual code step plus explanation. Use Chinese explanation.\n\nLet's craft final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立任務頻率表 // 計算每個字母出現的次數  \n→ Step 2: 找出最大頻率 maxFreq 與擁有此頻率的任務數量 maxCount // 確定最常見的任務  \n→ Step 3: 計算 parts = maxFreq - 1 // 將最常見任務分為幾段（不含最後一次）  \n→ Step 4: 計算 emptySlots = parts * n // 每段之間需要的空閒時間數量  \n→ Step 5: 計算 availableTasks = totalTasks - (maxFreq * maxCount) // 其餘任務可填補空閒時間  \n→ Decision: 如果 availableTasks >= emptySlots? // 判斷空閒時間能否全部被填滿  \n Yes → Step 6: idles = 0 // 不需要空閒時間  \n No  → Step 7: idles = emptySlots - availableTasks // 需要的空閒時間數量  \n→ Step 8: totalIntervals = totalTasks + idles // 完整 CPU 週期數（任務 + 空閒）  \nEnd // 程式執行結束"
    },
    {
      "title": "Range Sum Query - Immutable",
      "source_file": "Leetcode/leetcode303.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"NumArray\", \"sumRange\", \"sumRange\", \"sumRange\"], [[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]",
          "expected_output": "[null, 1, -1, -3]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpg4bu5s9b.py\", line 50, in <module>\n    main()\n  File \"/tmp/tmpg4bu5s9b.py\", line 31, in main\n    arguments = json.loads(args_str)\n                ^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 337, in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 353, in raw_decode\n    obj, end = self.scan_once(s, idx)\n               ^^^^^^^^^^^^^^^^^^^^^^\njson.decoder.JSONDecodeError: Expecting ',' delimiter: line 1 column 52 (char 51)"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass NumArray:\n    \"\"\"用前綴和加速區間求和的資料結構\"\"\"\n    def __init__(self, nums):\n        # 前綴和陣列，prefix_sums[i] = nums[0] + ... + nums[i-1]\n        self.prefix_sums = [0]\n        for num in nums:\n            self.prefix_sums.append(self.prefix_sums[-1] + num)\n\n    def sumRange(self, left, right):\n        # 区间和 = prefix_sums[right+1] - prefix_sums[left]\n        return self.prefix_sums[right + 1] - self.prefix_sums[left]\n\ndef main():\n    # 讀取整行輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 分離兩個列表（命令與參數）\n    # 假設格式為: [cmd1, cmd2, ...], [[args1], [args2], ...]\n    split_pos = data.find('],')\n    if split_pos == -1:\n        raise ValueError(\"輸入格式不符合預期\")\n\n    cmds_str = data[:split_pos + 1]          # 包含左方括號結尾\n    args_str = '[' + data[split_pos + 2:]    # 重新包裝右方括號\n    commands = json.loads(cmds_str)\n    arguments = json.loads(args_str)\n\n    results = [None] * len(commands)\n    obj = None\n\n    for i, cmd in enumerate(commands):\n        args = arguments[i]\n        if cmd == \"NumArray\":\n            obj = NumArray(args[0])\n            results[i] = None\n        elif cmd == \"sumRange\":\n            results[i] = obj.sumRange(*args)\n        else:\n            raise ValueError(f\"未知命令 {cmd}\")\n\n    # 使用 json.dumps 以符合範例輸出格式（null 代表 None）\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations. Need to cover class definition, constructor, sumRange method. Use Start, End, Decision if needed. No actual code. Just steps. Probably include building prefix sum array. Provide explanation. Use 虛擬碼步驟. Provide arrows. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 NumArray 類別 // 建立一個用於處理範圍求和的類別  \n→ Decision: 如果輸入陣列 nums 非空? // 檢查是否有資料可處理  \n  Yes → Step 2: 建立 prefixSum 陣列，長度為 nums.length + 1，且 prefixSum[0] = 0 // 初始化前綴和陣列  \n   → Step 3: 從索引 1 到 nums.length 迭代  \n    → Step 4: 計算 prefixSum[i] = prefixSum[i-1] + nums[i-1] // 將原始陣列的元素累加進前綴和  \n  No  → Step 5: prefixSum = [0] // 若陣列為空，僅保留一個 0 作為前綴和  \n→ Step 6: 完成建構子初始化 // NumArray 物件已準備好前綴和資料  \n→ Step 7: 定義 sumRange(left, right) 方法 // 用於回傳指定區間的總和  \n  → Step 8: 檢查 left, right 是否在合法範圍內 // 確保索引有效  \n   → Decision: 若 left > right?  \n     Yes → Step 9: 回傳 0 或拋出錯誤 // 以避免非法輸入  \n     No → Step 10: 計算 sum = prefixSum[right+1] - prefixSum[left] // 使用前綴和快速求和  \n     → Step 11: 回傳 sum // 結果輸出  \nEnd // 程式執行結束"
    },
    {
      "title": "LFU Cache",
      "source_file": "Leetcode/leetcode460.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"LFUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"get\", \"put\", \"get\", \"get\", \"get\"], [[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]",
          "expected_output": "[null, null, null, 1, null, -1, 3, null, -1, 3, 4]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpv38cak6w.py\", line 71, in <module>\n    main()\n  File \"/tmp/tmpv38cak6w.py\", line 53, in main\n    ops, args = json.loads(data)\n                ^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 83 (char 82)"
        }
      ],
      "generated_code": "import sys\nimport json\nfrom collections import defaultdict, OrderedDict\n\nclass LFUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.min_freq = 0\n        self.key_to_val_freq = {}  # key -> (value, freq)\n        self.freq_to_keys = defaultdict(OrderedDict)  # freq -> OrderedDict of keys (LRU order)\n\n    def _update(self, key: int):\n        value, freq = self.key_to_val_freq[key]\n        # Remove key from current freq list\n        del self.freq_to_keys[freq][key]\n        if not self.freq_to_keys[freq]:\n            del self.freq_to_keys[freq]\n            if self.min_freq == freq:\n                self.min_freq += 1\n        # Add key to next freq list\n        self.freq_to_keys[freq + 1][key] = None\n        self.key_to_val_freq[key] = (value, freq + 1)\n\n    def get(self, key: int) -> int:\n        if key not in self.key_to_val_freq:\n            return -1\n        self._update(key)\n        return self.key_to_val_freq[key][0]\n\n    def put(self, key: int, value: int) -> None:\n        if self.capacity == 0:\n            return\n        if key in self.key_to_val_freq:\n            # Update value and frequency\n            self.key_to_val_freq[key] = (value, self.key_to_val_freq[key][1])\n            self._update(key)\n            return\n        # If cache is full, evict LFU key\n        if len(self.key_to_val_freq) >= self.capacity:\n            evict_key, _ = self.freq_to_keys[self.min_freq].popitem(last=False)\n            del self.key_to_val_freq[evict_key]\n            if not self.freq_to_keys[self.min_freq]:\n                del self.freq_to_keys[self.min_freq]\n        # Insert new key\n        self.key_to_val_freq[key] = (value, 1)\n        self.freq_to_keys[1][key] = None\n        self.min_freq = 1\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    ops, args = json.loads(data)\n    results = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"LFUCache\":\n            obj = LFUCache(arg[0])\n            results.append(None)\n        elif op == \"put\":\n            obj.put(arg[0], arg[1])\n            results.append(None)\n        elif op == \"get\":\n            val = obj.get(arg[0])\n            results.append(val)\n    # Format output like LeetCode expects\n    out = '[' + ', '.join('null' if v is None else str(v) for v in results) + ']'\n    print(out)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation, not actual code. The virtual code must use arrows, Start, End, Decision. It's a step-by-step algorithm design for LFU cache. Must include initialization, get, put operations with O(1). We should outline data structures: hash map key->node, freq map freq->double linked list of keys, minFreq tracking.\n\nWe need to produce a pseudo-code that outlines the process line by line. The user wants a design, not implementation details. But we should show operations like: initialize capacity, current size, minFreq. Node struct holds key, value, freq.\n\nWe need to produce virtual code lines for the class, constructor, get, put. The lines should be sequential with decisions. It's not actual code, just steps.\n\nLet's craft virtual code:\n\nStart\n→ Initialize LFUCache with capacity\n    → Set capacity\n    → Set size=0\n    → Set minFreq=0\n    → Create keyMap (key->node)\n    → Create freqMap (freq->list of nodes)\nEnd\n\nDefine Node struct: key, value, freq\n\nFor get(key):\n    → Decision: if key not in keyMap?\n        Yes → return -1\n        No → Retrieve node\n            → Increment node.freq\n            → Remove node from old freq list\n            → If old freq list empty and old freq==minFreq, increment minFreq\n            → Add node to new freq list\n            → Return node.value\nEnd\n\nFor put(key, value):\n    → Decision: if capacity==0? → return\n    → Decision: if key exists?\n        Yes → Update node.value\n            → Increment node.freq (same as get logic)\n        No → Decision: if size==capacity?\n            Yes → Find node with minFreq list front (LRU)\n                → Remove that node from keyMap and freqMap\n                → Decrement size\n            No →\n            → Create new node with freq=1\n            → Add to keyMap\n            → Add to freqMap[1]\n            → Set minFreq=1\n            → Increment size\nEnd\n\nAlso need helper: removeNode(node), addNode(node, freq). But we can mention these as steps.\n\nWe need each line with virtual code + comment.\n\nLet's format.\n\nWe might need nested decisions; use indentation.\n\nWe must ensure each line uses arrow.\n\nLet's produce.\n\nAlso note that we need to use `→ Decision:` for ifs, `Yes →` and `No →`.\n\nLet's create Start block, then steps for initialization, etc.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: Define struct Node { key, value, freq } // 建立節點資料結構\n→ Step 2: Define LFUCache class // 主要類別\n    → Step 2.1: Constructor LFUCache(capacity) // 初始化\n        → Set this.capacity = capacity\n        → Set this.size = 0\n        → Set this.minFreq = 0\n        → Create this.keyMap = {} // key -> node\n        → Create this.freqMap = {} // freq -> DoubleLinkedList of nodes\n    → Step 2.2: get(key) // 查詢\n        → Decision: if key not in this.keyMap?\n            Yes → Return -1\n            No → node = this.keyMap[key]\n                → Increment node.freq\n                → oldFreq = node.freq - 1\n                → Remove node from freqMap[oldFreq]\n                → Decision: if freqMap[oldFreq] is empty AND oldFreq == this.minFreq?\n                    Yes → this.minFreq += 1\n                → Add node to freqMap[node.freq] (create list if absent)\n                → Return node.value\n    → Step 2.3: put(key, value) // 插入/更新\n        → Decision: if this.capacity == 0?\n            Yes → Return\n        → Decision: if key exists in this.keyMap?\n            Yes → node = this.keyMap[key]\n                → node.value = value\n                → // Update frequency same as get\n                → Increment node.freq\n                → oldFreq = node.freq - 1\n                → Remove node from freqMap[oldFreq]\n                → Decision: if freqMap[oldFreq] is empty AND oldFreq == this.minFreq?\n                    Yes → this.minFreq += 1\n                → Add node to freqMap[node.freq]\n            No →\n                → Decision: if this.size == this.capacity?\n                    Yes →\n                        // Evict LFU node\n                        → freqList = this.freqMap[this.minFreq]\n                        → nodeToRemove = freqList.tail.prev // LRU in minFreq list\n                        → Remove nodeToRemove from freqList\n                        → Delete keyMap[nodeToRemove.key]\n                        → this.size -= 1\n                    No →\n                → // Insert new node\n                → newNode = Node(key, value, freq=1)\n                → Add newNode to keyMap\n                → Add newNode to freqMap[1] (create list if absent)\n                → this.minFreq = 1\n                → this.size += 1\nEnd // 程式結束\n\nWe need to ensure each line uses arrow. Indentation: we can use spaces. But each line must contain '虛擬碼步驟' + space + '// 解釋'.\n\nAlso we need to maintain the arrow at start for each step, not for the class definition.\n\nWe need to avoid actual code. We can use pseudo-code tokens.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Define struct Node { key, value, freq } // 建立節點資料結構，保存鍵值與使用頻率\n→ Define class LFUCache // 主類別\n    → Constructor LFUCache(capacity) // 初始化 LFU Cache\n        → Set this.capacity = capacity // 設定容量上限\n        → Set this.size = 0 // 現有項目數量\n        → Set this.minFreq = 0 // 最小頻率初始化\n        → Create this.keyMap = {} // key → Node 映射，快速查找\n        → Create this.freqMap = {} // freq → DoubleLinkedList，按頻率存儲節點\n    → Method get(key) // 查詢鍵值\n        → Decision: if key not in this.keyMap?\n            Yes → Return -1 // 鍵不存在，返回 -1\n            No → node = this.keyMap[key] // 取出節點\n                → Increment node.freq // 使用次數加 1\n                → oldFreq = node.freq - 1 // 原先頻率\n                → Remove node from this.freqMap[oldFreq] // 從舊頻率列表移除\n                → Decision: if this.freqMap[oldFreq] is empty AND oldFreq == this.minFreq?\n                    Yes → this.minFreq += 1 // 若最小頻率列表清空，更新 minFreq\n                → Add node to this.freqMap[node.freq] (create list if absent) // 加入新頻率列表\n                → Return node.value // 返回對應值\n    → Method put(key, value) // 插入或更新鍵值\n        → Decision: if this.capacity == 0?\n            Yes → Return // 容量為 0，直接返回\n        → Decision: if key exists in this.keyMap?\n            Yes → node = this.keyMap[key]\n                → node.value = value // 更新值\n                → // 同 get 操作，更新頻率\n                → Increment node.freq\n                → oldFreq = node.freq - 1\n                → Remove node from this.freqMap[oldFreq]\n                → Decision: if this.freqMap[oldFreq] is empty AND oldFreq == this.minFreq?\n                    Yes → this.minFreq += 1\n                → Add node to this.freqMap[node.freq]\n            No →\n                → Decision: if this.size == this.capacity?\n                    Yes →\n                        // 需要淘汰一個節點\n                        → freqList = this.freqMap[this.minFreq] // 取得最小頻率列表\n                        → nodeToRemove = freqList.tail.prev // 最舊的節點（LRU）\n                        → Remove nodeToRemove from freqList\n                        → Delete this.keyMap[nodeToRemove.key] // 從 keyMap 刪除\n                        → this.size -= 1 // 容量減 1\n                    No →\n                → // 插入新節點\n                → newNode = Node(key, value, freq=1) // 新節點頻率為 1\n                → this.keyMap[key] = newNode // 加入 keyMap\n                → Add newNode to this.freqMap[1] (create list if absent) // 加入頻率為 1 的列表\n                → this.minFreq = 1 // 重置最小頻率為 1\n                → this.size += 1 // 容量加 1\nEnd // 程式執行結束"
    },
    {
      "title": "Different Ways to Add Parentheses",
      "source_file": "Leetcode/leetcode241.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "expression = \"2-1-1\"",
          "expected_output": "[0,2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[0,2]'\nGot (Norm):      '[2,0]'\n--- (Raw) ---\nRaw Expected: '[0,2]'\nRaw Got:      '[2, 0]'"
        },
        {
          "example_index": 1,
          "input": "expression = \"2*3-4*5\"",
          "expected_output": "[-34,-14,-10,-10,10]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[-34,-14,-10,-10,10]'\nGot (Norm):      '[-34,-10,-14,-10,10]'\n--- (Raw) ---\nRaw Expected: '[-34,-14,-10,-10,10]'\nRaw Got:      '[-34, -10, -14, -10, 10]'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def diffWaysToCompute(self, expression: str):\n        memo = {}\n\n        def ways(expr: str):\n            if expr in memo:\n                return memo[expr]\n\n            res = []\n            for i, ch in enumerate(expr):\n                if ch in '+-*':\n                    left = ways(expr[:i])\n                    right = ways(expr[i+1:])\n                    for l in left:\n                        for r in right:\n                            if ch == '+':\n                                res.append(l + r)\n                            elif ch == '-':\n                                res.append(l - r)\n                            else:  # '*'\n                                res.append(l * r)\n            if not res:\n                res.append(int(expr))\n            memo[expr] = res\n            return res\n\n        return ways(expression)\n\ndef main():\n    data = sys.stdin.read().strip()\n    # 尋找第一個雙引號中的內容，若不存在則直接使用整行\n    match = re.search(r'\"([^\"]*)\"', data)\n    expression = match.group(1) if match else data.strip('\"')\n\n    solution = Solution()\n    result = solution.diffWaysToCompute(expression)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode for the algorithm: parse expression string, compute all possible results by adding parentheses in all ways. Standard problem: \"Different Ways to Add Parentheses\". Approach: recursion with memoization: For each operator position, split expression into left and right sub-expressions, compute recursively all results for left and right, combine with operator.\n\nPseudocode structure: Start → parse expression → call helper function to compute all results → return results → End.\n\nNeed to adhere to format: each line: \"虛擬碼步驟 // 解釋\".\n\nUse arrow notation. Use \"Start\", \"End\", \"Decision:\" with Yes→ No→.\n\nAlso we need to describe memoization mapping.\n\nWe need to not output actual code, just pseudocode steps.\n\nLet's produce step-by-step.\n\nPotential steps:\n\nStart\n\n→ Step 1: Define function `diffWays(expression)` // Main function to compute results\n\n→ Decision: Is expression a single number? // base case check\n    Yes → Return list containing the number // single numeric result\n    No → Step 2: Initialize result list // to collect all results\n\n→ Step 3: For each character `c` with index `i` in expression\n    Decision: Is `c` an operator (+, -, *)? // operator positions\n        Yes → Step 4: Split expression into left = substring(0, i), right = substring(i+1)\n               → Step 5: Recursively compute leftResults = diffWays(left)\n               → Step 6: Recursively compute rightResults = diffWays(right)\n               → Step 7: For each l in leftResults\n                    For each r in rightResults\n                       Compute combined = applyOperator(l, r, c)\n                       Add combined to result list\n\n→ Decision: Is memoization map contains key expression? // caching results\n    Yes → Return cached list // avoid recomputation\n    No → Step 8: Store result list in memoization map with key expression // cache\n\n→ Return result list\n\n→ End\n\nBut we need to show memoization at start maybe. Let's incorporate memoization as global map.\n\nAlso include applyOperator pseudocode.\n\nWe also need to mention parsing numbers; we can parse substring to integer.\n\nAdd explanation lines.\n\nLet's produce final pseudocode accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義函式 `diffWays(expr)` // 用來計算所有可能的結果  \n→ Decision: 如果 `expr` 只包含一個數字? // 基本情況判斷  \n  Yes → Return [轉為整數(expr)] // 直接回傳數字本身  \n  No  → Step 2: 初始化空列表 `results` // 用來收集所有計算結果  \n→ Step 3: 對 `expr` 中每個字元 `c` 以及索引 `i` 進行迭代 // 掃描所有運算子位置  \n  Decision: `c` 是否為運算子 (+, -, *)? // 判斷是否需要分割  \n   Yes → Step 4: 取得子表達式 `left = expr[0:i]`, `right = expr[i+1:]`  \n    → Step 5: 計算左邊結果 `leftVals = diffWays(left)`  \n    → Step 6: 計算右邊結果 `rightVals = diffWays(right)`  \n    → Step 7: 對於 `l` 在 `leftVals`  \n     對於 `r` 在 `rightVals`  \n      → Step 8: 依運算子 `c` 計算 `combined = applyOperator(l, r, c)`  \n       → Step 9: 把 `combined` 加入 `results`  \n   No  → 跳過非運算子字元  \n→ Decision: 是否已在快取 `memo` 中存在 `expr`? // 檢查是否已計算過  \n  Yes → Return `memo[expr]` // 直接回傳快取結果  \n  No  → Step 10: 存入快取 `memo[expr] = results` // 儲存以便重複使用  \n→ Return `results` // 傳回所有可能的結果  \n→ Step 11: 定義輔助函式 `applyOperator(a, b, op)`  \n  → Decision: `op` 是 \"+\"?  \n   Yes → Return `a + b`  \n   No → Decision: `op` 是 \"-\"?  \n    Yes → Return `a - b`  \n    No → Return `a * b` // 只處理 *  \n→ End // 程式執行結束"
    },
    {
      "title": "Basic Calculator",
      "source_file": "Leetcode/leetcode224.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"1 + 1\"",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '1'"
        },
        {
          "example_index": 1,
          "input": "s = \" 2-1 + 2 \"",
          "expected_output": "3",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '3'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: '3'\nRaw Got:      '2'"
        },
        {
          "example_index": 2,
          "input": "s = \"(1+(4+5+2)-3)+(6+8)\"",
          "expected_output": "23",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '23'\nGot (Norm):      '8'\n--- (Raw) ---\nRaw Expected: '23'\nRaw Got:      '8'"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def calculate(self, s: str) -> int:\n        stack = []          # 用於存放前一個累加值和符號\n        current_num = 0     # 正在解析的數字\n        last_sign = '+'     # 前一個運算符\n\n        # 在字串末尾加一個空格，確保最後一個數字能被處理\n        s += ' '\n        i = 0\n        while i < len(s):\n            c = s[i]\n\n            # 跳過空格\n            if c == ' ':\n                i += 1\n                continue\n\n            # 整數解析\n            if c.isdigit():\n                current_num = current_num * 10 + int(c)\n\n            # 開啟子表達式\n            elif c == '(':\n                # 把前一次的結果和符號存入堆疊\n                stack.append(last_sign)\n                stack.append(current_num)\n                # 重置為子表達式內的初始狀態\n                last_sign = '+'\n                current_num = 0\n\n            # 關閉子表達式\n            elif c == ')':\n                # 完成子表達式中的最後一個數字\n                current_num = self._apply_sign(last_sign, current_num, 0)\n                # 取出前一次存儲的數字和符號\n                prev_num = stack.pop()\n                prev_sign = stack.pop()\n                # 把子表達式的結果加到前一個狀態\n                current_num = self._apply_sign(prev_sign, prev_num, current_num)\n\n            # 遇到運算符時處理前一次的數字\n            else:  # c is '+' or '-'\n                current_num = self._apply_sign(last_sign, current_num, 0)\n                last_sign = c\n                current_num = 0\n\n            i += 1\n\n        # 末尾還有未處理的數字\n        current_num = self._apply_sign(last_sign, current_num, 0)\n        return current_num\n\n    @staticmethod\n    def _apply_sign(sign: str, num: int, acc: int) -> int:\n        \"\"\"將 num 按照 sign 加到 acc，返回新的 acc.\"\"\"\n        if sign == '+':\n            return acc + num\n        else:\n            return acc - num\n\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 取出引號中的內容，如果有引號\n    if '\"' in data:\n        first = data.find('\"')\n        last = data.rfind('\"')\n        expr = data[first + 1:last]\n    else:\n        expr = data\n\n    solution = Solution()\n    result = solution.calculate(expr)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps for evaluating a string expression (likely including + - * / parentheses). It's a basic calculator. No eval. Use stack, parsing digits and handling precedence.\n\nWe should provide each line of virtual code with explanation, following format: e.g.,\n\nStart // 程式開始執行\n→ Step 1: 初始化堆疊 stack, current number = 0, last sign = '+'\n→ Step 2: 遍歷字串 s，對每個字符 c\n→ Decision: 如果 c 為數字? // etc\n\nWe need to handle parentheses: push current state onto stack, reset, etc. For basic calculator with + - * / parentheses, typical algorithm uses stack to handle parentheses and multiplication/division via current term.\n\nWe'll produce a line for each logical step.\n\nWe must use \"虛擬碼步驟\" and explanation. Use arrow, Decision.\n\nLet's draft.\n\nStart // 程式開始執行\n→ Step 1: 初始化變數 stack = [], currentNum = 0, lastSign = '+'\n→ Step 2: 在 s 的末尾加一個空格，以便最後一次處理\n→ Step 3: 變數 i = 0\n→ Step 4: 遍歷 s 的每個字符 c\n→ Decision: 如果 c 是空格? // 跳過空格\n    Yes → Continue // 進入下一字符\n→ Decision: 如果 c 是數字? // 解析完整數字\n    Yes → Step 5: currentNum = currentNum * 10 + int(c) // 組合多位數\n→ Decision: 如果 c 是 '('? // 開始子表達式\n    Yes → Step 6: 將當前 lastSign, currentNum, stack 推入堆疊\n    → Step 7: lastSign = '+', currentNum = 0\n→ Decision: 如果 c 是 ')'? // 子表達式結束\n    Yes → Step 8: 根據上一次 stored state，計算子表達式結果\n    → Step 9: 把結果累加到堆疊中\n→ Decision: 如果 c 是運算符 (+ - * /) 或到達字串末尾? // 處理前一次的 lastSign\n    Yes → Step 10: 根據 lastSign 計算 currentNum 並把結果放入堆疊\n    → Step 11: lastSign = c\n    → Step 12: currentNum = 0\n→ Step 13: i += 1\n→ End 循環\n→ Step 14: 返回堆疊中所有數字之和\n\nBut we also need to handle parentheses with stack storing previous sum and sign. A simpler approach: maintain sum stack, lastSign. For parentheses: push sum and sign, reset sum to 0, lastSign '+'. On ')', pop previous sum and sign and add current sum.\n\nWe can produce more explicit steps.\n\nLet's write final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化變數  \n stack ← [] // 用於存放小括號前的累加結果和符號  \n currentNum ← 0 // 目前正在組合的數字  \n lastSign ← '+' // 上一個運算符，預設為 '+'  \n→ Step 2: 在字串 s 的末尾加一個空格，以確保最後一個數字被處理  \n s ← s + ' '  \n→ Step 3: i ← 0 // 循環索引  \n→ Step 4: 循環遍歷 s 的每個字符 c  \n while i < len(s):  \n  c ← s[i] // 取得當前字符  \n  → Decision: c 是空格? // 跳過空格  \n   Yes → i ← i + 1  // 進入下一個字符  \n   No  →  \n    → Decision: c 是數字? // 解析完整數字  \n     Yes → currentNum ← currentNum * 10 + int(c) // 組合多位數  \n     No  →  \n      → Decision: c 是 '('? // 開始子表達式  \n       Yes →  \n         stack.push((lastSign, currentNum)) // 把前一個符號和數字存入堆疊  \n         lastSign ← '+' // 子表達式內的運算符重置為 '+'  \n         currentNum ← 0 // 數字重置  \n         i ← i + 1"
    },
    {
      "title": "Contains Duplicate III",
      "source_file": "Leetcode/leetcode220.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,1], indexDiff = 3, valueDiff = 0",
          "expected_output": "true",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpme4wqrvr.py\", line 3, in <module>\n    from sortedcontainers import SortedList\nModuleNotFoundError: No module named 'sortedcontainers'"
        },
        {
          "example_index": 1,
          "input": "nums = [1,5,9,1,5,9], indexDiff = 2, valueDiff = 3",
          "expected_output": "false",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpa1xrj03h.py\", line 3, in <module>\n    from sortedcontainers import SortedList\nModuleNotFoundError: No module named 'sortedcontainers'"
        }
      ],
      "generated_code": "import sys\nimport re\nfrom sortedcontainers import SortedList\n\nclass Solution:\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\n        \"\"\"\n        檢查是否存在 i ≠ j，且\n        |i - j| <= k 以及 |nums[i] - nums[j]| <= t\n        \"\"\"\n        if k <= 0 or t < 0:\n            return False\n\n        window = SortedList()\n\n        for i, num in enumerate(nums):\n            # 在窗口中找最小不小於 (num - t) 的位置\n            pos = window.bisect_left(num - t)\n            if pos < len(window) and abs(window[pos] - num) <= t:\n                return True\n\n            window.add(num)\n\n            # 若窗口大小超過 k，移除最舊的元素\n            if len(window) > k:\n                window.remove(nums[i - k])\n\n        return False\n\ndef parse_input(text):\n    \"\"\"\n    解析形如:\n    nums = [1,2,3,1], indexDiff = 3, valueDiff = 0\n    之輸入，返回 (nums, indexDiff, valueDiff)\n    \"\"\"\n    nums_match = re.search(r'nums\\s*=\\s*(\\[[^\\]]*\\])', text)\n    index_match = re.search(r'indexDiff\\s*=\\s*(-?\\d+)', text)\n    value_match = re.search(r'valueDiff\\s*=\\s*(-?\\d+)', text)\n\n    if not (nums_match and index_match and value_match):\n        raise ValueError(\"輸入格式錯誤\")\n\n    nums_str = nums_match.group(1)\n    nums = eval(nums_str)  # 直接轉成 list\n\n    indexDiff = int(index_match.group(1))\n    valueDiff = int(value_match.group(1))\n\n    return nums, indexDiff, valueDiff\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    try:\n        nums, indexDiff, valueDiff = parse_input(data)\n    except Exception as e:\n        print(\"false\")\n        sys.exit()\n\n    sol = Solution()\n    result = sol.containsNearbyAlmostDuplicate(nums, indexDiff, valueDiff)\n    print(\"true\" if result else \"false\")",
      "virtual_code": "Thinking...\nWe need to produce a virtual code algorithm for the problem. Provide step-by-step. Probably using sliding window with a balanced BST or multiset to check value diff constraints. Since we need only pseudo, we can outline logic: maintain window of indices <= indexDiff using a data structure to allow O(log n) queries. For each new index j, query if any element in window has abs difference <= valueDiff. Use sorted container to check nearest values. Implementation: iterate j from 0 to n-1: maintain sorted list of nums[i] for i in [j-indexDiff, j-1]. For each j, find lower_bound of nums[j] - valueDiff and check if exists <= nums[j] + valueDiff. If found return true. After check, add nums[j] to window. Remove nums[j-indexDiff] when window too large. End return false.\n\nSo produce pseudo code lines accordingly.\n\nEnsure each line has \"虛擬碼步驟\" followed by space then comment.\n\nUse Start, End, Decision, etc.\n\nWe can break into steps.\n\nLet's produce:\n\nStart\n\n→ Initialize empty SortedList window // 用來存放滑動窗口內的值\n\n→ For j in 0 .. n-1 // 逐一遍歷每個索引\n\n    → Decision: if j > indexDiff? // 確保窗口大小不超過 indexDiff\n\n        Yes → Step: remove nums[j-indexDiff-1] from window // 把最舊的元素移除\n\n    → Step: targetLow = nums[j] - valueDiff // 計算允許值的下界\n\n    → Step: targetHigh = nums[j] + valueDiff // 計算允許值的上界\n\n    → Step: idxLow = window.lower_bound(targetLow) // 找到不小於 targetLow 的位置\n\n    → Decision: if idxLow exists and window[idxLow] <= targetHigh? // 是否存在符合差值的值\n\n        Yes → Step: return true // 找到合法對\n\n        No  → // 沒有符合的值，繼續\n\n    → Step: insert nums[j] into window // 將當前值加入窗口\n\nEnd // 若未找到，返回 false\n\nBut need to output \"虛擬碼步驟\" + comment. Let's write each line accordingly.\n\nUse arrow arrows and indent decisions.\n\nMake sure each line ends with comment.\n\nLet's output.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Initialize empty SortedList window // 建立一個可排序的資料結構作為滑動窗口  \n→ Step 2: For j in 0 .. n-1 // 從頭到尾逐個處理索引 j  \n    → Decision: j > indexDiff? // 檢查窗口是否已超過允許的距離  \n        Yes → Step 3: Remove nums[j-indexDiff-1] from window // 把最舊的元素移出窗口  \n        No  → // 窗口大小未超過，保持不變  \n    → Step 4: targetLow = nums[j] - valueDiff // 計算可接受數值的下界  \n    → Step 5: targetHigh = nums[j] + valueDiff // 計算可接受數值的上界  \n    → Step 6: idxLow = window.lower_bound(targetLow) // 在窗口中尋找不小於下界的位置  \n    → Decision: idxLow exists and window[idxLow] <= targetHigh? // 是否存在符合差值限制的數值  \n        Yes → Step 7: Return true // 找到合法對，結束並返回真  \n        No  → // 無符合數值，繼續處理  \n    → Step 8: Insert nums[j] into window // 將當前值加入滑動窗口  \nEnd // 若整個迴圈結束仍未找到對，返回假并結束程式"
    },
    {
      "title": "Random Pick with Weight",
      "source_file": "Leetcode/leetcode528.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"], [[[1,3]],[],[],[],[],[]]",
          "expected_output": "[null,1,1,1,1,0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,1,1,1,1,0]'\nGot (Norm):      '[null,1,1,0,0,0]'\n--- (Raw) ---\nRaw Expected: '[null,1,1,1,1,0]'\nRaw Got:      '[null, 1, 1, 0, 0, 0]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\nimport bisect\nimport json\n\nclass Solution:\n    def __init__(self, w):\n        # 建立累積權重表\n        self.prefix = []\n        s = 0\n        for weight in w:\n            s += weight\n            self.prefix.append(s)\n        self.total = s\n\n    def pickIndex(self):\n        # 產生一個 1~total 之間的隨機整數\n        target = random.randint(1, self.total)\n        # 找出最小的索引 i，使得 prefix[i] > target-1\n        return bisect.bisect_left(self.prefix, target)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 解析輸入，預期形如 '[\"Solution\",\"pickIndex\"], [[[1]],[]]'\n    ops, args = ast.literal_eval(data)\n\n    instance = None\n    results = []\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            instance = Solution(arg[0])\n            results.append(None)\n        else:\n            # 動態呼叫方法\n            method = getattr(instance, op)\n            res = method(*arg)\n            results.append(res)\n\n    # 輸出結果，將 None 轉成 JSON null\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce a pseudo code line-by-line that implements the random index picker weighted by weights. Provide explanation after each line. Use Start, End, Decision. Probably include building cumulative sum array in constructor and picking in function. Use random number r between 0 and sum exclusive. Binary search or linear scan. We'll do binary search. Provide pseudo code steps.\n\nLet's produce:\n\nStart\n→ Step 1: Receive weight array w // Input array\n→ Step 2: Initialize prefixSum array // cumulative weights\n    → For i from 0 to w.length-1: prefixSum[i] = (i==0? w[0] : prefixSum[i-1] + w[i]) // build cumulative sums\n→ Step 3: total = prefixSum[w.length-1] // total sum\nEnd // constructor\n\nThen pickIndex function:\n\nStart\n→ Step 1: Generate random double r between 0 (inclusive) and total (exclusive) // random value\n→ Decision: Find smallest index i such that prefixSum[i] > r // binary search\n    → Yes → Step 2: Return i // selected index\nEnd\n\nBut need lines with \"→\" and explanation.\n\nLet's produce more explicit: Step names maybe \"BuildPrefixSums\", \"PickRandom\", etc. Use Decision.\n\nLet's produce.\n\nAlso include comment for binary search.\n\nReturn lines.\n\nLet's output accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Receive weight array w // 取得給定的權重陣列\n→ Step 2: Initialize prefixSum array // 用來儲存累積權重\n    → For i from 0 to w.length-1: prefixSum[i] = (i==0? w[0] : prefixSum[i-1] + w[i]) // 建立累積和\n→ Step 3: total = prefixSum[w.length-1] // 計算總權重\nEnd // 建構完成，準備使用\n\nStart // pickIndex() 函式開始執行\n→ Step 1: Generate random double r ∈ [0, total) // 產生隨機數\n→ Decision: 是否存在索引 i 使得 prefixSum[i] > r？ // 透過二分搜尋找出\n    Yes → Step 2: Return i // 這個索引即為選中結果\nEnd // pickIndex() 執行結束"
    },
    {
      "title": "Multiply Strings",
      "source_file": "Leetcode/leetcode43.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "num1 = '2', num2 = '3'",
          "expected_output": "'6'",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '6'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: \"'6'\"\nRaw Got:      '2'"
        },
        {
          "example_index": 1,
          "input": "num1 = '123', num2 = '456'",
          "expected_output": "'56088'",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '56088'\nGot (Norm):      '123'\n--- (Raw) ---\nRaw Expected: \"'56088'\"\nRaw Got:      '123'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def multiply(self, num1: str, num2: str) -> str:\n        # 快速判斷是否為 0\n        if num1 == '0' or num2 == '0':\n            return '0'\n\n        m, n = len(num1), len(num2)\n        pos = [0] * (m + n)\n\n        # 從最低位開始相乘\n        for i in range(m - 1, -1, -1):\n            d1 = ord(num1[i]) - ord('0')\n            for j in range(n - 1, -1, -1):\n                d2 = ord(num2[j]) - ord('0')\n                mul = d1 * d2\n                p1, p2 = i + j, i + j + 1\n                sum_ = mul + pos[p2]\n                pos[p1] += sum_ // 10\n                pos[p2] = sum_ % 10\n\n        # 把結果轉成字串，去除前導零\n        result = ''.join(map(str, pos)).lstrip('0')\n        return result if result else '0'\n\ndef main():\n    data = sys.stdin.read()\n    # 找出所有整數字串\n    nums = re.findall(r'\\d+', data)\n    if len(nums) < 2:\n        return\n    num1, num2 = nums[0], nums[1]\n    sol = Solution()\n    print(sol.multiply(num1, num2))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need produce pseudo-code for multiplication of two numbers given as strings without converting to int or using BigInteger. Typical approach: multiply each digit like manual multiplication, store intermediate sums in array.\n\nWe output step-by-step lines with arrows and decisions. Provide explanation per line. Ensure Start, End. Use arrow for each step. Use decisions for loops? We'll use loops as pseudo code, maybe \"For i from len1-1 down to 0\" etc.\n\nWe need each line include virtual code step and comment after //.\n\nLet's craft.\n\nStart\n\n→ Step 1: Determine lengths len1 = length(num1), len2 = length(num2) // Get number of digits\n\n→ Decision: If num1 == \"0\" or num2 == \"0\"? // Quick zero check\n\n    Yes → Step 2: Return \"0\" // product is zero\n\n    No → Continue\n\n→ Step 3: Initialize result array of size len1 + len2 with zeros // holds digits in reverse\n\n→ Step 4: For i from len1-1 downto 0 // iterate over digits of num1\n\n→ Step 5:     digit1 = num1[i] - '0' // convert char to int\n\n→ Step 6:     For j from len2-1 downto 0 // iterate over digits of num2\n\n→ Step 7:         digit2 = num2[j] - '0' // convert char to int\n\n→ Step 8:         product = digit1 * digit2 // single digit multiplication\n\n→ Step 9:         sum = product + result[i + j + 1] // add to existing value at position\n\n→ Step 10:         result[i + j + 1] = sum % 10 // store units digit\n\n→ Step 11:         result[i + j] += sum / 10 // carry over to next position\n\n→ End Loop for j\n\n→ End Loop for i\n\n→ Step 12: Convert result array to string, skipping leading zeros // build final string\n\n→ Step 13: Return the constructed string // output product\n\nEnd\n\nWe need to include arrow and decision arrow formatting: maybe \"Yes →\" and \"No →\". For loops, we can just list as \"→ Step ...\". Might be fine.\n\nMake sure each line ends with // explanation. Provide proper indentation? In example, indentation is not required but arrow indicates nested. We can indent lines for inner loops for clarity.\n\nLet's produce.\n\nCheck formatting: each line: virtual code + space + // explanation. Use spaces. Include \"Start\" line and \"End\" line.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: len1 ← length(num1) // 取得 num1 的位數  \n→ Step 2: len2 ← length(num2) // 取得 num2 的位數  \n→ Decision: num1 == \"0\" 或 num2 == \"0\"？ // 快速判斷是否為 0  \n  Yes → Step 3: Return \"0\" // 若任一為 0，直接回傳 0  \n  No  → Continue // 兩數皆非 0，繼續運算  \n→ Step 4: result ← 數組(len1 + len2) 0 // 初始化結果陣列，反向存放各位  \n→ Step 5: For i ← len1 - 1 downto 0 // 逐位遍歷 num1  \n  → Step 6: digit1 ← num1[i] - '0' // 把字元轉為數值  \n  → Step 7: For j ← len2 - 1 downto 0 // 逐位遍歷 num2  \n    → Step 8: digit2 ← num2[j] - '0' // 把字元轉為數值  \n    → Step 9: product ← digit1 * digit2 // 單位乘法  \n    → Step 10: sum ← product + result[i + j + 1] // 加上已存數值  \n    → Step 11: result[i + j + 1] ← sum % 10 // 存取最低位  \n    → Step 12: result[i + j] ← result[i + j] + sum / 10 // 將進位累加  \n    End Loop j // 結束內層迴圈  \n  End Loop i // 結束外層迴圈  \n→ Step 13: index ← 0 // 找出第一個非零位  \n  → Decision: result[index] == 0 且 index < len(result)？ // 跳過前導 0  \n    Yes → index ← index + 1 // 進一步搜尋  \n    No → Skip  \n→ Step 14: str ← 空字串 // 建立結果字串  \n  → While index < len(result) // 從第一個非零位到結束  \n    → Step 15: str ← str + char(result[index] + '0') // 加入字元  \n    → index ← index + 1 // 移至下一位  \n  End Loop // 結束字串拼接  \n→ Step 16: Return str // 傳回最終乘積字串  \nEnd // 程式執行結束"
    },
    {
      "title": "H-Index II",
      "source_file": "Leetcode/leetcode275.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "citations = [0,1,3,5,6]",
          "expected_output": "3",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '3'\nGot (Norm):      '0'\n--- (Raw) ---\nRaw Expected: '3'\nRaw Got:      '0'"
        },
        {
          "example_index": 1,
          "input": "citations = [1,2,100]",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '0'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '0'"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef h_index(citations):\n    \"\"\"\n    計算 h-index 的 O(log n) 算法。\n    citations 已經按非遞減排序。\n    \"\"\"\n    n = len(citations)\n    left, right = 0, n - 1\n    while left <= right:\n        mid = (left + right) // 2\n        # citations[mid] 是第 mid+1 篇論文的引用數\n        # 若至少有 n - mid 篇論文被引用至少 n - mid 次，\n        # 那麼 h-index 可以是 n - mid，嘗試往右移動。\n        if citations[mid] >= n - mid:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return n - left\n\ndef parse_input(line: str):\n    \"\"\"\n    從類似 'citations = [0,1,3,5,6]' 的輸入字串中解析出整數列表。\n    \"\"\"\n    # 找到方括號中的內容\n    match = re.search(r'\\[([^\\]]*)\\]', line)\n    if not match:\n        return []\n    nums_str = match.group(1)\n    # 空列表或逗號分隔的整數\n    if not nums_str.strip():\n        return []\n    return [int(x.strip()) for x in nums_str.split(',') if x.strip()]\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    citations = parse_input(data)\n    result = h_index(citations)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code (pseudo) line by line with explanations. Should include Start, Decision, etc. Should implement algorithm to find h-index in sorted citations array in non-decreasing order. O(log n) algorithm: binary search for first index where citations[i] >= n-i. Actually h-index is maximum h such that at least h papers have >= h citations. In sorted ascending, we can find first position where citations[i] >= n - i, then h = n - i. Or use binary search on h value. We'll produce algorithm steps: Start, get length n, left=0, right=n-1, result=0, while left <= right: mid=(left+right)//2, if citations[mid] >= n - mid: result = n - mid; left = mid + 1; else: right = mid - 1; End. Then return result.\n\nWe should output each step as virtual code lines with explanation. Use arrow arrows? The example uses \"→ Step 1:\" etc. Should include Start, End. So produce something like:\n\nStart // 程式開始執行\n→ Step 1: n ← length of citations // 取得文章數量\n→ Step 2: left ← 0 // 設定二分搜尋左邊界\n→ Step 3: right ← n - 1 // 設定二分搜尋右邊界\n→ Step 4: result ← 0 // 初始 h-index\n→ Decision: left ≤ right? // 判斷是否還有區間可搜尋\n    Yes → Step 5: mid ← (left + right) // 2 // 計算中點索引\n    → Decision: citations[mid] ≥ n - mid? // 檢查中點是否滿足 h-index 條件\n        Yes → Step 6: result ← n - mid // 更新 h-index\n        → Step 7: left ← mid + 1 // 嘗試更大 h-index\n        No  → Step 8: right ← mid - 1 // 調整到左半區間\n    Yes → (loop back) Decision: left ≤ right? // 迴圈\n    No  → End // 搜尋結束\n→ Step 9: return result // 輸出最終 h-index\n\nBut need \"→\" arrow. For loop we use Decision: left ≤ right? with Yes → ... and No → End. For inner decision we need indentation. The example uses indentation via spaces. So produce accordingly.\n\nMake sure each line contains \"虛擬碼步驟\" and comment. We'll produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← length of citations // 取得文章總數  \n→ Step 2: left ← 0 // 設定二分搜尋左邊界  \n→ Step 3: right ← n - 1 // 設定二分搜尋右邊界  \n→ Step 4: result ← 0 // 初始 h-index 為 0  \n\n→ Decision: left ≤ right? // 是否仍有區間可搜尋  \n    Yes → Step 5: mid ← (left + right) // 2 // 計算中點索引  \n    → Decision: citations[mid] ≥ n - mid? // 檢查此索引能否成為 h-index  \n        Yes → Step 6: result ← n - mid // 更新 h-index 為 n - mid  \n        → Step 7: left ← mid + 1 // 嘗試更大 h-index（右半區）  \n        No  → Step 8: right ← mid - 1 // 調整到左半區  \n    Yes → Decision: left ≤ right? // 重新檢查是否還有區間  \n    No  → End // 二分搜尋結束  \n\n→ Step 9: return result // 輸出最終計算得到的 h-index\n\nEnd // 程式執行結束"
    }
  ]
}