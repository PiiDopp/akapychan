{
  "run_index": 1,
  "source_file": "leetcode552.json",
  "problem_index_in_file": 0,
  "problem_data": {
    "title": "Student Attendance Record II",
    "description": "An attendance record for a student can be represented as a string where each character signifies whether the student was absent, late, or present on that day. The record only contains the following three characters:\n\n'A': Absent.\n'L': Late.\n'P': Present.\nAny student is eligible for an attendance award if they meet both of the following criteria:\n\nThe student was absent ('A') for strictly fewer than 2 days total.\nThe student was never late ('L') for 3 or more consecutive days.\nGiven an integer n, return the number of possible attendance records of length n that make a student eligible for an attendance award. The answer may be very large, so return it modulo 10^9 + 7.",
    "examples": [
      {
        "input": "2",
        "output": "8",
        "explanation": "There are 8 records with length 2 that are eligible for an award:\n\"PP\", \"AP\", \"PA\", \"LP\", \"PL\", \"AL\", \"LA\", \"LL\"\nOnly \"AA\" is not eligible because there are 2 absences (there need to be fewer than 2)."
      },
      {
        "input": "1",
        "output": "3"
      },
      {
        "input": "10101",
        "output": "183236316"
      }
    ],
    "solution": "class Solution:\n    def checkRecord(self, n):\n        MOD = 10**9 + 7\n        # dp[a][l] = count of sequences with a 'A's and ending with l consecutive 'L's\n        dp = [[0]*3 for _ in range(2)]\n        dp[0][0] = 1\n\n        for _ in range(n):\n            new_dp = [[0]*3 for _ in range(2)]\n            for a in range(2):\n                for l in range(3):\n                    val = dp[a][l]\n                    if val == 0:\n                        continue\n                    # Add 'P'\n                    new_dp[a][0] = (new_dp[a][0] + val) % MOD\n                    # Add 'A'\n                    if a == 0:\n                        new_dp[1][0] = (new_dp[1][0] + val) % MOD\n                    # Add 'L'\n                    if l < 2:\n                        new_dp[a][l+1] = (new_dp[a][l+1] + val) % MOD\n            dp = new_dp\n\n        return sum(dp[a][l] for a in range(2) for l in range(3)) % MOD"
  },
  "experiment_result": {
    "success": false,
    "error": "AI 未生成任何有效測資",
    "generated_tests": [],
    "parsed_tests": [],
    "runlog": "",
    "all_passed": false,
    "total_tests": 0,
    "passed_count": 0,
    "accuracy_rate": 0.0
  }
}